{"meta":{"title":"我没有三颗心脏的博客","subtitle":"SOMEWHERE NOT HERE","description":"分享知识&技术&思考&成长","author":"我没有三颗心脏","url":"http://www.wmyskxz.com","root":"/"},"pages":[{"title":"about","date":"2019-06-21T11:12:57.000Z","updated":"2019-06-21T11:13:36.000Z","comments":true,"path":"about/back.html","permalink":"http://www.wmyskxz.com/about/back.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-11T02:01:04.448Z","updated":"2020-08-11T02:01:03.376Z","comments":true,"path":"about/index.html","permalink":"http://www.wmyskxz.com/about/index.html","excerpt":"","text":"「 96年奋力奔跑的自由技术人 」 关于本站本站所使用的主题是：Volantis，与主题相关的疑问请前去主题文档页面查询或者提 issue 求助，请不要在我的博客评论里面发，谢谢！ Voliantishttps://volantis.js.org/"},{"title":"categories","date":"2019-06-21T12:48:39.000Z","updated":"2020-08-11T01:27:56.526Z","comments":true,"path":"categories/back.html","permalink":"http://www.wmyskxz.com/categories/back.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-08-11T01:27:56.523Z","updated":"2020-08-11T01:27:56.522Z","comments":true,"path":"categories/index.html","permalink":"http://www.wmyskxz.com/categories/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-08-23T07:14:42.326Z","updated":"2020-08-23T07:14:42.324Z","comments":true,"path":"tags/index.html","permalink":"http://www.wmyskxz.com/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-21T12:49:45.000Z","updated":"2019-06-21T12:50:00.000Z","comments":true,"path":"tags/back.html","permalink":"http://www.wmyskxz.com/tags/back.html","excerpt":"","text":""},{"title":"学习路线","date":"2021-04-08T03:03:37.716Z","updated":"2021-04-08T03:03:37.716Z","comments":true,"path":"learning-path/index.html","permalink":"http://www.wmyskxz.com/learning-path/index.html","excerpt":"","text":"后端技术人员成长路线 参考：https://roadmap.sh/backend Part 0. 编码之前必须了解的东西 当大学选择了计算机之后应该知道的计算机发展史—从织布机到IBM计算机系统概述一文了解二进制和 CPU 工作原理机器指令到汇编再到高级编程语言 Part 1. 网络基础 图解|网络究竟是如何运作的？28张图解 | 互联网究竟是「如何连接，如何进行通信」的？DNS 是什么？如何运作的？惊了！原来浏览器的秘密藏在这31张图里！关于 HTTP 后端人员需要了解的 20+ 图片！！ Part 2. 基础前端知识 HTML/CSS 入门 Part 3. 基础操作系统知识 待补充… Part 4. 学习一门语言 Java 基础快速入门Day 0：Java 发展史及起航新世界Day 1：环境搭建和程序基本结构元素Day 2：变量、数据类型和运算符Day 3：构建程序逻辑的方法Day 4：面向对象基础Day 5：面向对象进阶——继承详解Day 6：面向对象进阶——多态Day 7：接口详解 Part 5. 版本管理 待补充… Part 6. 数据库 待补充… Part 7. 数据库进阶 待补充… Part 8. APIs 待补充… Part 9. 缓存 Redis 系列Redis【入门】就这一篇!Redis(1)——5种基本数据结构Redis(2)——跳跃表Redis(3)——分布式锁深入探究Reids(4)——神奇的HyperLoglog解决统计问题Redis(5)——亿级数据过滤和布隆过滤器Redis(6)——GeoHash查找附近的人Redis(7)——持久化【一文了解】Redis(8)——发布/订阅与StreamRedis(9)——史上最强【集群】入门实践教程妈妈再也不担心我面试被Redis问得脸都绿了 Part 10. 测试 待补充… Part 11. 开发设计原则学习 待补充…"}],"posts":[{"title":"游戏数值策划入门（一）：属性对应关系","slug":"游戏数值策划入门1","date":"2021-12-14T15:42:05.000Z","updated":"2021-12-14T15:44:21.318Z","comments":true,"path":"2021/12/14/you-xi-shu-zhi-ce-hua-ru-men-1/","link":"","permalink":"http://www.wmyskxz.com/2021/12/14/you-xi-shu-zhi-ce-hua-ru-men-1/","excerpt":"前言 PS：本文仅为分享学习成果，如有错误，欢迎指正。","text":"前言 PS：本文仅为分享学习成果，如有错误，欢迎指正。 这一段时间以来，都在捣鼓制作一个 RPG 向的游戏服务器，其中就涉及到有关数值策划的东西。 买了两本参考书目来看： 但发现几乎都是一套一套成熟的复杂的“拿来主义”，知其然不知所以然，翻看了两下就放下了。 后来在 B 站上遇到了从零开始的游戏数值生活系列视频，解答了我心里面的很多疑惑。 听讲课的刘勇老师说，它的自研体系制作出了一系列「成功」的游戏，算是“最高荣誉拿齐”了。 今天就来跟大家分享一下视频里面的精髓部分。 数值策划干什么的？简单来说，游戏策划的主要工作：1）保证游戏环境的平衡；2）达到预期策划的效果。 这里有一个容易遗漏的重点是：数值是为预期策划效果服务的，所以，我们的数值应该是与策划高度对齐的。 而数值策划的日常也可以简单分成前、中、后期： 如何保证平衡？首先需要知道，游戏为什么不平衡。其中大部分的锅，可以丢给 「伤害计算公式」 来背，另外一部分，则可以丢给 「属性对应关系」。 一对多问题我们先来说一下简单的部分，就是「属性对应关系」。不同属性之间，总共只有三种对应关系： 单一属性影响多个属性的设定，就属于一对多的范畴之中了。（比如:敏捷属性会影响攻击、防御、人物移速三个方面） 如果我们想要做数值平衡，就要保证在不同的属性值 「成长曲线」 中，能够找到相对平衡的 「平均线」： 而一对多的属性加入之后，数据就很难达到平衡了。 假设，攻击力会受力量、敏捷、霸气等多个属性值影响，它们直接叠加起来，整个攻击力成长曲线就会非常混乱（如上图右边）。 所以理论上，多曲线的数据平衡是不成立的。 一个失败的例子： 一对多：导致数据很难平衡； 数据类型和变化范围不一样：攻击力是自然数，是属于无上限的，而暴击加成是一个有限域内的比例数（百分比）； 攻方数据和防方数据掺杂：攻击力和暴击属性攻击方的数据，而格挡属于防守方； 简而言之，如果属性值一对多，所面临的的数据平衡问题会几何倍地增长，最终导致游戏无法平衡。 如何解决？不要设计一对多的属性值对应关系。 多对一的问题假设： 那非常完美，因为 武器、角色、饰品 彼此是独立的三个来源，不属于 「一对多」 的范畴。 但假如一个玩家的设定是：防御力 = 衣服防御 + 腰带防御 + 鞋子防御，而 衣服、腰带、鞋子 都属于 装备 的范畴，这里就出现了 「多对一」 的问题了。 一对多是致命的，但多对一不是，因为多对一的多指的是「同一类型下的多个内容」，这还属于我们可以自行调节的范畴之内。 但仍然存在问题，假设： 一颗强化武器的宝石增加 300 攻击力； 一颗强化防御的宝石增加 80 防御力； 那么对应下来，一颗攻击宝石的价值几乎就是一颗防御宝石的 4 倍。直接导致的结果就是，玩家本来就喜欢在游戏里面砸攻击力，你反而让效率增加了 4 倍。 问题的本质是：同样的投入下，「投入攻击」的性价比比「投入防御」要高得多，这很不公平，也很难平衡。 有一个极端的例子是：征途有一个玩家疯狂堆防御力，最终导致防御力&gt;攻击力的情况，出现一人屠一国的震撼场景： 如何解决？让装备和属性一一对应就好了。 比如，武器就加攻击力，腰带就加生命值，盔甲就加防御力。但做到如此极致的游戏，是很少见的。（但据我观察，现在很多手游都采用了「一对一」的形式） 小结好了，今天我们知道了「保证游戏平衡」中关于「属性值对应关系」的简单部分： 杜绝「一对多」的设计；「多对一」很难平衡； 尽量保证装备与属性「一对一」的关系； 后续我们将分享关于「计算公式」的秘密，以及如何「达到预期效果」的分享，欢迎关注。","categories":[{"name":"游戏","slug":"游戏","permalink":"http://www.wmyskxz.com/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://www.wmyskxz.com/tags/%E6%B8%B8%E6%88%8F/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 43 期）：如何保持每天精力充沛？","slug":"weekly43","date":"2021-12-12T02:10:00.000Z","updated":"2021-12-12T02:16:32.881Z","comments":true,"path":"2021/12/12/weekly43/","link":"","permalink":"http://www.wmyskxz.com/2021/12/12/weekly43/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 前段时间，韩国釜山市政府和科技公司 OCEANIX 签署了一份协议，将在釜山市建造世界上第一个可持续的漂浮城市原型，预计于 2025 年建成，由 6 个六边形的浮岛组成，分别承担医疗、教育、购物、文化中心等公共用途，预计可容纳约 1 万名居民。 据悉，这是抵御全球变暖，带来的海平面上升风险的又一举措。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 前段时间，韩国釜山市政府和科技公司 OCEANIX 签署了一份协议，将在釜山市建造世界上第一个可持续的漂浮城市原型，预计于 2025 年建成，由 6 个六边形的浮岛组成，分别承担医疗、教育、购物、文化中心等公共用途，预计可容纳约 1 万名居民。 据悉，这是抵御全球变暖，带来的海平面上升风险的又一举措。 本周讨论：如何保持每天精力充沛？（文案来自：宝藏公众号@L先生说） 先想一想，你对于「做事」和「休息」这两件事，是否秉持着以下的观念： 1）事情做完了再休息，保持专注；2）休息时就要做些不动脑子的事； 注意，这是👆我们首先需要先打破的两个「误区」，因为这样会导致两个结果，1）你工作时大脑一直高度紧张，因为事情一件接着一件；2）下班，你精力透支，告诉自己需要「放松一下」，于是埋头在低品质娱乐上，时间一晃就过去； 于是你陷入了「日复一日」的循环之中，无法自拔。 这样的一种休息模式，是一种 「被动休息」 的模式：我们的精力严重透支之后，不得不去休息。 而更好的一种休息模式，是一种 「主动休息」 的模式。 被动休息的弊端，是因为我们长时间专注于工作而导致的透支，所以更好的模式，一定是工作和休息交替进行的。也就是：主动掌控工作和休息的节奏。 所以，被很多人推崇的番茄工作法是合理的，但不一定要以默认的 25 分钟为一个番茄钟——那样很容易打断思路——而是不以具体时间，而是某一个小阶段为单位。 比如说：写文时把它分段，写一段就走动一下；写代码分小功能点，写完就休息一下。重点是要做点别的，转换思绪，让大脑得到放松。 那放松时我们应该做些什么呢？ 首先，刷剧、刷手机其实是一种用外在的新鲜刺激去填充注意力的方式，依靠这种刺激把大脑一次次拉回外界。但这种刺激是无意义的，很容易提高大脑的阈值，从而令你感到无聊、烦躁、提不起兴致。 更好的休息方式则是去做一些中低耗能的事，这些事最好与日常工作不同，激活大脑不同的运转模式。 比如：继续阅读读到一半的书、思考之前没有想明白的问题、看一些有趣的科普视频等。 最后还有三条具有实践意义的建议： 每天抽出一段固定的时间，去做一些超出生活日常模式的事； 重点在于：每天给自己一段固定的时间，排除其他信息的干扰，让自己能够充分地发挥好奇心、创造力和想法，做一些自己感兴趣的、有一定门槛的、需要动脑思考或动手的事情。 因为只有具备一定门槛，需要付出脑力去思考、认真对待，你才能够进入「心流」状态，从而，从做这些事情里面获得创造的幸福感和乐趣。 给自己设定边界； 事情是永远做不完的，你必须明确，哪些是你应该做的，哪些是你可以选择做或不做的；哪些是非常重要、优先要做的，哪些是可以缓一缓、或可以转交给他人去做的。 不是你的事，你就要学会「课题分离」，不要过度担责。包括拒绝同事的请求或朋友的求助。 另外工作上、生活上的一些琐事，我们要学会化零为整，把它们集中在固定的时间去处理，尽量不要让这些事情占据我们每天的休息时间和空余时间。 运动； 提高精力上限的办法，有且只有一个，就是运动。 所以，平时一定要想办法多运动、多锻炼，最低的程度，哪怕是出去散步都可以。最好是每天能有半小时比较剧烈的运动时间，每周能有 3-5 小时的累计运动时间。 以上，感谢阅读，Be Better~ 热点新闻1、国产新冠特效药上市 近日，由清华大学医学院张林琦教授领衔研发的新冠特效药，获得国家药品监督管理局的应急批准上市。 最终结果显示，与安慰剂相比，药物能够降低高风险新冠门诊患者住院和死亡风险 80%。 2、Meta 开放 VR 虚拟世界 只要你是 18 岁以上的美国和加拿大用户，再配备一台「Oculus Quest 2」VR 头显，就能够在 Meta 最新发布的虚拟世界 Horizon Worlds 免费游玩。 目前看来，Horizon Worlds 很大程度上还是在依靠游戏在吸引用户，当前世界也提供了很多自定义的世界和免费游戏供大家游玩。 当然这样的开放世界，也免不了依赖用户创建，也拿出了相当的奖金（1000 万）来激励创作者。 3、漫画化 AI 在线工具 二次元漫画风格迁移工具 AnimeGANv2，利用 AI 能够把「合适的照片」迅速二次元化，效果可以用「惊艳」来形容了。（体验地址） 4、3D 打印安乐死胶囊舱 近日，瑞士一款 3D 打印的辅助自杀胶囊舱「Sarco」通过法律审批。使用者可以舒服地躺在胶囊舱中，启动后胶囊舱内部会被充入氮气，大约 30 秒，其中的氧气含量会从 21% 迅速降至 1%，使用者会感到迷失方向，在其失去意识前可能还会有轻微兴奋感。 死亡将由缺氧和低碳酸血症导致，人不会有恐慌或窒息的感觉。 PS：在荷兰，任何 12 岁以上的人，如果有“无法忍受的痛苦且没有改善的前景”，都可以要求安乐死，但 16 岁以下的儿童需得到父母同意。 5、恐龙能跑多快？ 足迹化石分析显示，来自西班牙北部的一只约 2 米高、4-5 米长恐龙，在 1 亿多年前曾跑出过 12.4 米/秒（44.6 千米/时）的速度，这是目前计算出最快的兽脚类恐龙奔跑速度之一。 目前人类短跑记录保持者博尔特的成绩是 44.72 千米/时（普通人就慢多了）。 6、全球互联网公司的不眠夜 12 月 10 日凌晨，Apache 开源项目 Log4j （一个记录日志的优秀组件）的远程代码执行漏洞细节被公开，攻击者只需要一段代码，就可以在被攻击的电脑上，执行任意代码！注意，这里是任意代码！ 这个 Java 生态底层被广泛使用的组件库，几乎影响了全球的互联网公司，甚至连 MC 电脑版，因为也使用了 Java 的 Log4j，沦为被攻击的对象，很多服务器也被迫关停了。 那个原本应该下班（10 日正好是周五）休息的夜晚，却让无数互联网人和互联网公司“熬夜修复”。 文章1、防止 CSS 出错的写法（英文） 当网页是动态时，CSS 可能会发生奇怪的事，为了防止这样的情况发生，这里总结了一些「拿来主义」的经验。 2、比尔·盖茨的 2021 年总结 比尔·盖茨每年都会写一篇文章，回顾这一整年人类面对的挑战，以及他的基金会所做的工作。 这是今年的文章，开头是这样写的： “我和保罗创办微软时，有一个共同的愿景：个人电脑有一天会在人们的生活中扮演重要角色。但我们当年都没有预料到，未来某一天电脑会成为你与世界唯一的联系。像很多人一样，今年我时常一整天下来都只能通过屏幕与人交流。” (via@科技爱好者周刊（第 187 期） | 阮一峰) 3、不到 125 行编写一个简单的 16 位 VM（英文） 用不到 125 行的 C 语言代码，编写出的 VM 具有以下功能： 将主程序加载进主内存中； 在 RPC 寄存器中，保存了当前需要执行的指令； 从指令中获取操作码（前 4 位），并在此基础上对其余参数进行解码； 执行与给定指令相关的方法； 递增 RPC 并继续执行下一条命令； 文中有大量配图和说明，初学者也能看懂。 4、运气 | @公众号@孟岩 孟大的文章都值得深读几遍，摘录一下文中的精华部分： 这并不是一个因果关系主导的世界，偶然性、或者说运气，在其中起了很大的作用。 但我们依然可以找到方式与运气相处： 1）不下牌桌，长期坚持做一件事； 2）提升自己做这件事的数学期望，或者说成功的概率。 5、自由主义和社会民主主义的区别 当一个自由主义者看到贫穷和困难时，他们的本能是想办法帮助这个人。 当一个社会民主主义者看到穷人时，他们不会想到我怎样才能帮助这个特定的人，或者这个人的生活中出了什么问题。相反，他们的问题会是：社会在哪里失败了？社会中的什么机制阻碍了这个人获得富裕的生活？ 这是区别的一部分，更多感兴趣可以戳一戳。 6、JavaScript 异步函数如何使用缓存（英文） 本文介绍了一些函数缓存的概念和实现（基于 JavaScript）。 7、面试官在意的简历四要素 求职过程中，简历是万里长征第一步。本文从形式、内容等各方面细节入手，给简历排了不少雷。 8、Typora 1.0 详细评测 作为一款几乎「全桌面平台支持」的本地 Markdown 编辑器，Typora 可谓是「知名度」很高。 最近正是推出了 1.0 版本，开始采用买断制的方式收费，如果你还在犹豫，可以考虑先看看测评。 好奇星人本周暂无； 言论1、 人们喜欢虚拟世界的理由很简单，因为现实世界太沉重，生活太累了，太乏味，日复一日缺乏趣味。虚拟世界就是一个精神的寄托，也是一个避难所，让你暂时忘记现实的烦恼，让你有一个更美好、更有趣味的世界可去。 –阮一峰 2、 才华横溢的日本作家村上春树曾写道：“永远记住，争论并获胜，就是打破你所反对的人的现实。失去现实是痛苦的，所以要善良，即使你是对的。” –为什么事实不会改变我们的想法（英文） 3、 经常开怀大笑；赢得智者的尊重和孩子们的喜爱；赢得诚实的批评家的赏识，忍受虚伪朋友的背叛；欣赏美；发现别人的优点；让世界变得更好一点；知道哪怕只有一条生命因为你的存在而呼吸得更轻松。这就是成功。 –拉尔夫·沃尔多·爱默生 4、 冯·诺依曼曾说过这样一句话：如果有人不相信数学是简单的，那是因为他们没有意识到人生有多复杂。 生活从不缺聪明人，但，人生又何时有过必胜法？ 在人生这场复杂的博弈游戏之中，合作，才是化繁为简的唯一解。 –如何才能赢得生活？ 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 42 期）：如何过得爽","slug":"weekly42","date":"2021-12-05T00:40:00.000Z","updated":"2021-12-05T01:34:31.545Z","comments":true,"path":"2021/12/05/weekly42/","link":"","permalink":"http://www.wmyskxz.com/2021/12/05/weekly42/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 圣家族大教堂始建于 1882 年，经历了 139 年，终于在今年完成了圣母塔的“封顶”——用一颗大星状 12 面体的水晶玻璃。不过，整个建筑可能还需要几年时间完成。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 圣家族大教堂始建于 1882 年，经历了 139 年，终于在今年完成了圣母塔的“封顶”——用一颗大星状 12 面体的水晶玻璃。不过，整个建筑可能还需要几年时间完成。 本周讨论：如何过得爽（文案参考：過去可以被改變的真正原因，被討厭的勇氣 | 老高與小茉）（视频） 阿德勒是 1870 年出生在奥地利维也纳的一个心理学家。由他创建的「个体心理学派」对后世产生了深远的影响。 他最主要的理论有三个，是关于「人生如何获得幸福」很好的回答，也就是本周话题 「如何过得爽」，跟大家一起分享。 第一个，目的论。 这是一个跟「心理创伤」相关的理论。与弗洛伊德提出的 「决定论」 不同，弗洛伊德是认为：你现在出现的问题，是由于过去的一段悲惨经历所引发的，所以要治疗，需要抚平过去的悲惨经历。 而阿德勒持有完全相反的观点：你现在的问题，是由于你现在的目的所引发的。而这个目的有可能是存在于你的潜意识当中的。 比如，一个人因为结巴不去跟喜欢的女生表白。以弗洛伊德的理论需要先解决结巴的问题，而阿德勒则认为你不去表白并不是因为结巴的问题，而是因为不表白不被拒绝的心理状态是你觉得舒服的，所以你才不去表白。 所以阿德勒认为，恐惧也好、自卑也好，都是用来逃避现实的工具而已。而且人现在做出的决定，还可能反过来影响过去。 比如，爱因斯坦上学的时候连小板凳，如果后来他没有这么成功，这可能就成了心理创伤，但后来因为他的成功，这反而成了天才的特质。 第二个，课题分离。 首先，阿德勒认为，人的所有烦恼都来自于「人际关系」。你觉得穷，是因为你见过富的；你觉得自己长得不好看，是因为有长得好看的。 所以一切烦恼的根源都是来自于与他人的比较。怎么解决呢？这就需要课题分离理论。 任何一个问题，你需要把它拆解成两个部分，一个是「你的问题」，另一个是「别人的问题」。你只能解决「你的问题」，而不能去干涉「别人的问题」。 比如，家长都希望孩子学习好，你给他提供一个良好的学习环境，引导他好好学习，告诉他为什么学习很重要，这些都没问题，但是你强迫他学习，这就干涉了孩子的课题，就不对了。 比如，你想辞职去创业，而你的老婆可能因为风险选择离开你，去不去创业是你的课题，而你的老婆离不离开你，是她的课题，你不能干涉。如果你要创业，就要承担老婆离开的风险。（这个例子建议去看看视频…） 很多人会说我为了你怎么怎么样，你可不可以为我怎么怎么样，这就涉及「干涉」了，就涉及「人际关系」的烦恼之中了。 但注意，阿德勒并不是希望每个人都自私，而是希望每个人的内心都能够强大起来，不依赖于其他人，因为我们不能指望其他人对我们负责，并且我们也不能够真正设身处地地替他人着想。 第三个，共同体感觉。 阿德勒认为，人不应该追求获得他人的认可，而应该追求共同体感觉。 换句话就是说，我们存在的价值并不是通过别人的认可获得的，而是应该通过对集体的贡献获得的。所以阿德勒认为，任何人都不应该参与竞争，竞争就是一种没有自信的表现。 如果你是为了别人的评价在努力的话，那么你就永远不会获得自由。 比如，夫妻也是一种共同体，如果双方都是为了对方而活，会非常累（目标不一致的话）。所以真正的夫妻之道应该是：两个人都为了两个人好而努力，而不是为了对方而努力。 怎么才能有这种共同体感觉呢？那就是 「参与共同体」。 第一步，接受自己；第二步，信赖他人，而且这种信赖，是无条件的；第三步，为这个共同体做出贡献，由此获得幸福。 不活在别人的评价里，就会被别人讨厌。而不要害怕被别人讨厌，你就能获得真正的自由。这也就是阿德勒最广为人知的「被讨厌的勇气」来源。 PS：由于篇幅原因，提炼了一些重点说明，觉得不够的朋友建议去阅读《被讨厌的勇气》一书，另外视频也说得很精髓，很有参考价值。 热点新闻1、JetBrains 轻量级编辑器 Fleet JetBrains 推出的全新轻量级编辑器，有点儿 VS Code 的意味，同时具有多语言、分布式的特性。 另外，除了能够轻松支持 Dockerfile 的自定义功能： 还有一个多人协作的模式，看上去也十分炫酷： 官方也说明了建立 Fleet 的初衷： Fleet 的目标是为了满足那些可能只需要一个编辑器，但也同时需要 IDE 中的强大功能的场景，想要使用单一工具而非多个专用工具的用户提供不同的体验。 不过目前还处于预览阶段，不提供下载。 2、2021 年度最常用 Emoji 榜单 近日，一个非营利机构 Unicode Consoritum 列出了「2021 年使用最多的 emoji」，下图每个 Emoji 的大小说明了它的相对受欢迎程度。 乍一看，和 2019 年的前十名重复率极高： 3、虚拟世界土地销售超 1 亿美元 根据 DappRadar 的数据，The Sandbox、Decentraland、CryptoVoxels 和 Somnium Space 这四款元宇宙产品上，关于「虚拟土地」仅上周的销售额就超过了惊人的一亿美元！ 仅这四个虚拟世界就有 6000 名交易者，其中最高的 The Sandbox 交易量就超过 8600 万美元。 4、悬浮投影 在本周的《自然》上，一项研究展示了可以从任何角度进行观察的 3D 图像生成系统，而在生成立体图像的同时，这套系统还可以提供声音和触觉效果。 这是一种基于“声镊”的技术。利用超声波，研究者让聚苯乙烯小球在声场中悬浮，控制它快速运动，并用红、绿、蓝三色 LED 将小颗粒照亮。当小球的运动和照亮它的光变化足够快时，移动的亮点就会在视觉暂留的作用下变成一幅完整的彩色图像。 这种“逐点照亮”的成像方式与老式显像管电视有点相似，不过它可以在三维空间中进行。同时，这套系统也可以产生能被人耳听到的声音，并利用声压在人的指尖产生触觉感受。 文章1、为了拿捏 Redis 数据结构，我画了 40 张图（完整版） 小林Coding 新文章，不多说了，发车发车。 2、27岁转行风雨路2——前端跳槽之路 从最开始因为儿子出生，“不得不”从 3k+ 的公务员转型程序员，入职同样 3k 的前端入门工作；到后来转战小外包的疯狂学习和后来转战科大讯飞 9k；最后到现在 13k 的前端技术负责人工作。 作者分享了自己转行前端一路以来的经历和感想，非常励志和真实。摘录其中的一些部分： 想来想去，我唯一的优势，可能就是：不要钱。 没有任何困难能阻止我，我必须在十月入职。 虽然没人要求我什么，可我不站出来，老婆孩子就要顶着生活的苦 出来的时候，我一路飞奔到停车场，关上面包车，激动的大喊大叫。 现在实习期到手 12k，转正 13k，房贷 3000 车贷 2000，给老婆 5000，自己还能有 3000，加上补助 600，我…真的太有钱了 心思雀跃，一定加倍努力，想尽一切办法也要转正啊。 3、Linux 视频教程（视频） B 站上反响不错的 Linux 学习“全家桶”，一共有 118 个视频。 4、Python 实现一个弹幕控制的直播间 作者介绍了如何使用 Python 提取弹幕流来达到「弹幕控制电脑操作」的玩儿法，还是十分新颖，文章最后也附了 Github 地址，不过作者弱弱的表示： 由此可得出结论，我，先得有粉丝，才能玩得起来啊，呜呜呜呜.. 5、三十多岁的人，或者死过去，或者死一次 这是公众号@读库主编老六，回顾自己如何走出三十多岁的人都将经历的「精神危机」的所思所想，招招见血。 虽然我离那个阶段还有不少距离，但也能从文字中获得不同的感受。分享其中一个片段： 那几年处于心理低谷时，我经常有这样的幻觉：每个夜晚来临的时候，一个自己看另一个自己把该做的事情做完，按部就班地躺在床上，然后平静地用目光扫视那个辗转反侧的躯体。 抚尸痛哭吗？要有这种可以外化的痛苦就好了，或潸然泪下，或强颜欢笑。事实上，什么也没有。一个自己很安静，另一个自己也很安静，消沉到连麻木都意识不到。这才是最让人沮丧之处。 6、让生活更简单，是一件很复杂的事 看标题以为是探讨哲学的文章，但戳进去发现是介绍华为在「爱是最伟大的科技」这句话背后所做的努力。 特别是文章中的视频，看完特别温暖。 7、高迪圣家堂的历史 题图故事，如果对这个建筑的历史感兴趣，可以读一读。 8、为什么 MySQL 的自增主键不单调也不连续 原因也很简单，虽然在获取 AUTO_INCREMENT 时会加锁，但是该锁是语句锁，它的目的是保证 AUTO_INCREMENT 的获取不会导致线程竞争，而不是保证 MySQL 中主键的连续 PS：最近大佬出了一本关于 Go 语言的书，虽然我平时不用 Go，但我也买了一本，希望能中签名版😄… 好奇星人1、穿越回哪一年最惨？ “这是最好的时代，也是最坏的时代”。 自 19 世纪纪狄更斯在《双城记》中写下这句话，各个时代的人都会时不时引用一番，表达对自己所处的年代又爱又恨的心情。 但从历史的角度来看，显然有那么几年绝对丧失了被称为“最好的时代”的资格，并成为“最糟糕年代”的有力竞争者。比如 1349 年，黑死病杀死了欧洲超过一半的人；1918 年，一场大流感让五千多万人丧生。 不过，如果时间机器只有一个禁选列表，那一定是 536 年。 这是因为，这一年，神秘的大雾笼罩了欧洲、中东和亚洲部分地区，带来了长达 18 个月的黑暗。气温下降 2.5 摄氏度之多，中国甚至开始六月飞雪。不充足的光照和降温使农作物普遍减产，造成了世界范围内的饥荒。 PS：还有罗马帝国的衰败。 科学界一直以来都怀疑导致这一灾难的原因是火山喷发。当火山爆发时，它会把硫磺、铋和其他一些物质喷向大气的高处，这些物质构成了一张喷雾罩，把阳光反射回太空，让地球冷却。 而现在，来自欧洛诺市缅因大学（UM）气候变化研究所的麦考密克和冰川学家马耶夫斯基所带领的团队指出了另一位可能的始作俑者：一座位于冰岛的火山。 言论1、 先把基础概念记下来； 花一点时间理解新概念； 用自己的话写，理解多少写多少； –如何真正理解一个新概念 2、 所以在家办公的确更难，自我约束、自我管理和自我协调还都只是表面，更大的议题在于我们有没有对这份自由负责。作为一种新型的办公模式，在家办公克服了很多传统办公时代衍生的陋习，而进步不要只用来赞美时代，也要落实到每一独立的个体。 –逃离办公室以后，我们去哪？ 3、 同样，生活也有某种节奏。然而身在其中的角色，是没法听到电影给我们安排的 BGM 是什么的。所以很多时候，与其在未知的焦虑中抗争命运，不如就，go with the flow。 –创作中的「节奏」 4、 所以，如果你想成为一个收入不错的高级工程师，那么匠心可能主要体现在，把自己放到一个可以持续交付用户价值的公司里面去，交付用户价值。 –软件工程师的匠心 5、 我时常会想起那艘已经飞出太阳系的探测器，并且——很荒谬地——和它有种惺惺相惜的感觉。也许是因为我潜意识里觉得，我们所做的事并无两样：用音乐去穿透时空，走向人心深处，甚至沟通不同的文明。 这可能就是音乐的力量。如果你也相信，则曲高未必和寡，水滴也可汇流成川，奔腾入海。 –网易云音乐上市，丁磊发布公开信：不循旧章才能通向新大陆 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 41 期）：成为更好管理者的六条违反直觉的规则","slug":"weekly41","date":"2021-11-28T01:45:00.000Z","updated":"2021-11-28T01:50:43.470Z","comments":true,"path":"2021/11/28/weekly41/","link":"","permalink":"http://www.wmyskxz.com/2021/11/28/weekly41/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 近日，美国、中国、日本、印度、英国等石油消费大国考虑协同释放各自的部分石油战略储备，以期给油价降温，稳定各自国内通胀趋势。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 近日，美国、中国、日本、印度、英国等石油消费大国考虑协同释放各自的部分石油战略储备，以期给油价降温，稳定各自国内通胀趋势。 本周讨论：成为更好管理者的六条违反直觉的规则 我不算一个合格的管理者。前段日子，我找到之前的领导「取经」，他一针见血地指出了我的问题：“你应该从代码的思维之中跳出来”。 过了些日子，又看到这一篇文章，我想这可能是执行人员转向管理人员的通病：当我们负责执行的时候，一直关注的是怎么做，是聚焦在一个点上做事；切换成管理人员视角，则更加全局，并且是新一套的问题（如何招聘、面试、带团队等..）等着你去解决。 当团队项目复杂度较低、团队较小时，你还可以一个人「冲锋」，但当复杂度达到一定程度，规模上去之后，你不得不依赖团队完成，而管理，是其中的必修课。 推荐大家都看看这篇文章，这其中说到的管理问题，很多是自己没有意识到的，文章是英文版，我从中摘取一些比较有启发的内容： 规则 #1：管理不是领导 管理不是告诉人们该做什么，不是设定一个愿景让人们为其工作，这是领导力的范畴； 真正的管理是让你周围的人变得更好，就是对员工进行投资，弄清他们是谁，擅长什么，动机是什么，然后将公司的工作和他们的角色与成长结合起来； 管理者的工作就是激发⼈们最好的一面。所以这并不是很多人乐在其中的原因； 如何发掘自己是否适合管理工作？可以来查看：你周围的人都在成长吗？他们是不是在扩大范围？你是否看到他们在六个月前不擅长的事情上有所改变？你是否在推动你的最高绩效者，看着他们爆发？你是否在帮助那些业绩较差的员工找出哪些工作不起作用? 虽然我一直在招聘时的沟通上、在日常任务的说明上，都尽可能地说明我们最终的目的和上下文，希望以此来点燃它们的热情，但却忽略了去了解他们做事的动机，认为大家都应该跟我一样的投入和热情，但实际上并非如此； 规则 #2：不要试图创造机器人，专注于管理什么，而不是如何管理 高效的团队不是由机器人组成的，而是由能够独立实现目标的人组成的； 最好的管理关系是，你们彼此做事的方式不同，但是他们还是把目标达成了； 关注「这个人应该负责什么」，而不是他们「怎么做的」。关注在「是什么」，而不要去关注「怎么做」； 刚开始的时候，我容不得跟我想法差别很大的 case，时常冒出：「要不我自己三下五除二弄了算了」的想法。但后来随着复杂度的增加，我渐渐关注在「如何拆解任务」上，我希望每个人都独立关注一些事，也不再询问他们怎么做，只在我觉得必要时给予一些提醒和帮助。 规则 #3：优秀的管理者从不创造第二个病人 如果你精疲力尽，几乎不可能帮助任何人。作为管理者一定要确保自己不变成第二个病人，照顾好自己才能照顾好团队； 之前，我把自己压得很紧，很多事情「理想主义」，deadline 也是理想化，这导致我一方面因为繁重的任务和额外的工作（招聘、面试等事宜）而分身乏术，更别说关注团队的目标、个人的成长了，另一方面又因为理想化的策划方案，在实践过程中不断修改、返工，造成了额外的工作开销，我就强迫自己先停下来，先想想什么是重要的，这个事、这个需求不做会造成什么后果？可以承担吗？ 后来我渐渐开始不压自己那么紧了，每天回家给自己一些时间思考，每周对齐一下团队的目标和任务，能简化的地方都尽量简化，反而事情的进度更好了； 规则 #4：花费比你认为你需要的更多的时间和你的优秀员工在一起 把大部分时间花在推动公司发展的人身上，而非花在有问题的人身上； 如何帮助做得好的人做的更好，核心是腾出时间来帮助个人反思他们的学习； 回顾过去：你喜欢做什么/ 什么感觉很好/ 讨厌什么/ 学到最重要的事情是什么/ 想做更多还是更少/ 下次想做点什么不同的事 展望未来：下一个挑战是什么/ 下一个重要的目标是什么/ 想干什么，已有的还是新的 需要不断地给优秀的员工设定目标，并在他们可能失败的地方提出重大挑战； 之前有挑战，总想着自己去为团队「扫清障碍」，效率为本，但这样就造成了团队其他人员得不到成长；现在有挑战的地方，我都乐于给时间让他们去尝试，然后整个团队一起分享成果； 规则 #5：设定期望，但要知道你并不总是那个能带来清晰方向的人 要想成为一个更好的管理者，你必须对你能控制什么，你能提供什么以及你不能提供什么保持现实客观的态度； 通常情况下，表现不佳的人并不是天生表现不佳的人，而是处于周围环境不对的人————他们要么是在错误的岗位上，要么是在错误的组织里； 我现在时常会反思自己，没有在对齐任务时，给出足够的上下文，这可能会导致他们走一些弯路；现在一方面开始不断完善文档，一方面也要说服自己不要「自以为」或「偷懒」的认为他们有足够的知识背景； 规则 #6：进行艰难但直接的谈话——在你认为需要的时间之前 人们可以在他们职业生涯的任何时刻成长和改变。但因为他们没有得到诚实的反馈而没有成长； 一个成熟的组织不可能没有人退出，但也会有很多错配。直接沟通就是去调整这些差距，重新评估； 这是我一直欠缺的部分，一方面可能是因为公司现在没有一个单独的房间，可以自由的交谈，另一方面也是因为自己太专注在「业务」和「团队」上，可能忽略了个人的； 诚实的反馈是非常有必要的，哪怕自己不情愿，也要去沟通，因为这有助于构建团队的文化，是发展的基石，在这个过程也会帮助自己或者帮助他人的成长； 希望今天的内容对你有所启发。要始终相信：一个人走得快，但一群人才走得远。Be Better~ 热点新闻1、文字 P 图 最近，英伟达公布了他们最新的 AI 模型 GauGAN2，不仅能根据字词生成逼真的风景照，还能实时使用文字 P 图！ 从单词到短语，这只 AI 全都能搞定，只需要给出描述词汇就可以了： 不仅仅能自定义风格，而且还能自行用笔刷调整，直呼好家伙。 PS：在线体验地址 http://gaugan.org/gaugan2/ 2、Nike 的虚拟运动乐园 最近，耐克入驻了 3D 沙盒创意社区 Roblox，建造了自己的虚拟世界「Nickland」。 里面分布了各种耐克主题的建筑、跑到和竞技场，还有诸多迷你小游戏，目前都是免费提供给玩家游玩。 进入数字陈列室，还可以用各种耐克运动鞋、服饰等装扮你的虚拟化身。 耐克声称，希望借此给经典游戏一次全新的尝试，「运动的未来由你创造」。 3、NFT 邮票 瑞典邮政出品了 13 种共计 175000 张 NFT 邮票，购买后，将保存于 NFT 电子钱包之中，每一枚售价为 8.9 法郎。 4、首艘电动无人驾驶货轮 近日，世界上第一艘全自动无人驾驶货轮在挪威亮相，这艘全自动驾驶货轮长 80 米、载重 3200 吨，能够在传感器的帮助下，自行完成 7.5 海里（约 14 公里）的航行，对比传统的货轮来说，每年减少的二氧化碳排放量相当于 4 万辆卡车每年排放的二氧化碳。 5、“外星文明信号”其实来自人类 “突破聆听”项目是旨在搜寻外星信号的观测项目，在去年的时候发现了一个备受关注的疑似外星文明的候选信号，但近期，两篇发表在英国《自然·天文学》杂志上的研究论文详尽介绍了发现信号过程和先进的信号分析手段，最终，科学家们将这个信号从外星文明候选名单中剔除了。 6、无痛、无针头注射疫苗机器人 据美国《快公司》杂志网站近日报道，加拿大初创公司 Cobionix 宣称，他们研制出了全球首款能注射疫苗的机器人——Cobi，其能以自主、无痛且无针头方式（改用压力喷射）注射疫苗。 这可以解决一部分医务人员劳动力缺失和人们（特别是儿童）害怕针头的问题。 文章1、构建终身学习体系进行自我提升 看完也许值得你的一句「感谢分享」。 PS：挺喜欢这个博客的“极简主义”风格… 2、数字技术简史：三位奠基人、三个阶段、五大定律、十项发明 如题，简明扼要的说明了数字技术的发展历程。 3、2021 年轻人熬夜报告 对于大多数年轻一代来说，夜晚似乎独具魅力，在与整日的忙碌短暂告别后，回归自己的“小世界”，不惜用“熬”的方式，在每个深夜，追逐这来之不易的“自由”。 这份报告中最有意思的是，令人向往的「自由职业者」，反而是熬夜最多的那一个： 且熬且珍惜… 4、我从构建生产数据库中学到的 42 件事（英文） 一位前 Facebook 底层 Delos 存储系统技术负责人总结过去经验得到的文章，从用户、项目管理、设计、代码审查、战略等多个方面总结的 42 条「经验之谈」。 5、为什么苹果的 M1 芯片这么快？（英文） 非常详细地解释了以下两个问题： 是什么技术让 M1 如此快速？ 为什么英特尔和 AMD 不行？ 6、手把手教你造一个元宇宙丨图图科幻 1.0 到 5.0。 PS：又一个宝藏公众号 7、GTA 重制三部曲有多烂 R 星公司最近发布了老游戏《GTA 三部曲》（侠盗猎车手）的重制版，售价60美元，结果重制版居然比近20年前的原版还要差。本文让大家看看，一个重制的游戏软件可以差到什么地步。（来源：@阮一峰） 好奇星人1、为什么理发店门口总是有三色柱？ 世界各地的理发店，门口都有一个红白蓝三色的旋转灯柱，这是为什么呢？ 其实，这关系到一段血腥的历史——放血疗法。 在中世纪的欧洲，人们认为生病主要是由于体内各元素不平衡，只要引出多余的“元素”，就会恢复健康。医生会割破病人的前臂或者颈部，通过放血来治病。 当时的放血师多半是教堂僧侣，后来，罗马天主教廷认为神职人员沾染血液有污信仰，禁止他们参与任何形式的外科手术。 当时的理发师不仅会帮人剪头发、修剪胡须，还可以拔牙、治疗跌打损伤等外科病，外科治疗经验丰富。于是，“放血治疗”这项工作就自然而然落在了理发师身上。理发师经常把洗过的绷带挂起来吹干，风中的绷带扭转缠绕着柱子，远看就像是红白条纹。 1540 年，经英格兰国王批准成立了理发师、外科医师联合会，并为此举行了庄严的仪式。从此，理发师正式打出了外科医师的牌子，并选三色柱作为他们行医和理发的标志。三色柱中的红色代表动脉，蓝色代表静脉，白色代表纱布。 直到 1745 年，英国国王乔治二世敕令成立皇家外科医学会，外科医生和理发师开始各司其职，理发师逐渐开始专职理发、刮脸。但理发店门前的三色灯柱，因为够醒目、有特色，就一直被各国效仿，沿用至今。 言论1、 关于低代码的能力边界有个很好的比喻：低代码更适合做企业数字化建设当中“最后一公里”的事情，基于数字化系统构建创新类应用、运营类应用。这个比喻也很能明确的显示低代码的能力圈范围。 –风口上的低代码：我们看到了这些变化与趋势 2、 一开始，市场经济面对着产品稀缺，生产力是关键；在生产力跟上以后，又变成了信息、服务稀缺。 现在我们面临着什么资源都不稀缺的市场，但以产品、服务和价格为核心的竞争策略已不再能获得持续的竞争优势，客户体验管理（CEM,Customer Experience Mangement）被认为是体验经济时代企业获取差异化竞争的重要战略。 –体验经济爆发，CEM能掀起下一次客户产业革命吗？ 3、 关于精神消费，我们还需要更多元的填充和探索。但值得注意的是，当节日成为狂热的精神收割机，我们更需要保留住精神的种子。 –一年 1000 个新节日，你还嗨得起来吗 4、 每个人，都是被慢慢推向成人世界的孩子，会被嘲笑、被戏弄、被奚落，被命运一次次打倒在地。 我们也早就明白了，自己或许根本不是传奇故事中，智慧、武力和运气都加满的主角。 笨拙、幼稚、灰头土脸、满身伤痕的波吉，或许才更像我们。 –9.6分刷爆热搜，他越大笑，我越想哭 5、 幸运方程式 = X * Y X 就是你所准备的，Y 就是你遇到的机会； 如果你的准备为零，不管你遇到多大的机会，你都不会抓住。你会失去每一次的机会。 你准备得越充分，X 就越大，那么你就越幸运。哪怕遇到的只有一个小机会，也会成倍的放大。 –运气方程式（英文） 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 40 期）：皮克斯讲故事的方法","slug":"weekly40","date":"2021-11-20T01:45:00.000Z","updated":"2021-11-22T12:09:32.316Z","comments":true,"path":"2021/11/20/weekly40/","link":"","permalink":"http://www.wmyskxz.com/2021/11/20/weekly40/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 当地时间 11 月 17 日，近日，澳大利亚圣诞岛，红蟹开始大规模迁徙，成群结队地穿过道路、桥梁、岩石和溪流，所到之处满眼红色，场面壮观。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 当地时间 11 月 17 日，近日，澳大利亚圣诞岛，红蟹开始大规模迁徙，成群结队地穿过道路、桥梁、岩石和溪流，所到之处满眼红色，场面壮观。 本周讨论：皮克斯讲故事的方法（文案参考：皮克斯讲故事的方法） 皮克斯一直是电影业最成功的工作室之一，电影票房收入超过 140 亿美元，并赢得了 23 项奥斯卡奖。 那皮克斯究竟是如何构建出这些引人入胜的故事的呢？答案是：它们有一整套严谨和结构化的故事创作过程和规则。 当你需要「讲故事」或者「理清最重要的 Point」时，完全可以把皮克斯公式套用其中： 从前有 _。每天， _。一天 。正因为如此，。正因为如此，_。直到最后 _。 我们拿一些创业公司说故事的方式来举例。 1）”从前” → 提出问题 首先我们需要构建世界的初始条件，这个世界上有哪些人？他们每天需要完成哪些具体的事？ 也可以为我们的故事设定背景，这个世界正在发生什么问题？有哪些经济力量、社会行为或技术是跟这个问题相关的？ 🏠 Airbnb 旅行以 X% 的速度增长，但预订酒店是旅行者最关心的问题之一。 💰 Coinbase 比特币的使用在早期采用者中迅速增长，但购买和存储它很复杂。 🚀 SpaceX 作为人类生存风险的保险，我们需要开发可以帮助我们殖民火星的火箭。 2）”而且每一天” → 为什么现在的解决方法很糟糕 在这一步，你要解释步骤 1 中的那些人，是如何解决他们的问题的。 他们当前的解决方法是什么样的？为什么不能很好地解决？当前的解决方法有什么「后遗症」没有？时间、金钱、精力？ 这一步的设置主要是为了后续我们自己提出更好的解决方案。 🏠 Airbnb 酒店预订价格昂贵，并不能让您真正体验城市生活。 💰 Coinbase 当前的工具很难拼凑起来，并将比特币的采用限制为工程师和黑客。 🚀 SpaceX 当前的火箭不够强大或负担不起，无法将足够多的人运送到另一个星球。 3）”直到有一天” → 提出你的解决方案 前面已经铺垫了客户、问题、当前的解决方案，以及为什么他们不够好，终于是时候介绍自己的解决方案了。 这一步的关键是，一定是要「具体」和「实事求是」的解决方案。他是一个有特殊能力的人？一个应用程序？一个硬件？连接两方市场？ 🏠 Airbnb 我们正在建立一个市场，让旅行者可以向当地房东预订房间。 💰 Coinbase 我们正在制作一个托管的比特币钱包。 🚀 SpaceX 我们正在制造可重复使用且强大到足以可靠地将人们送上火星的火箭。 4）”正因为如此” → 为什么你的方案好 10 倍 现在知道了你的解决方案了，是时候解释为什么它要好上 10 倍了。 这里的要点是，要能跟第二步中提出的「原来解决方案最大的问题」给呼应上，这也就是你解决方案中最大的价值主张。 是当前解决方案太昂贵了吗？那你的解决方案应该能负担得起；当前的解决方案太复杂了嘛？那你的解决方法应该足够简单；当前的解决方案太满了吗？那你的解决方法应该要快上很多。 🏠 Airbnb 这意味着旅行者可以预订更便宜的住宿，而房东可以从他们的空闲房间中赚钱。 💰 Coinbase 任何人只要连接他们的银行账户，就可以轻松地购买、出售和存储他们的比特币。 🚀 SpaceX 由于我们的火箭是可重复使用的，我们大大降低了发射成本，我们将利用我们的发射来开发强大到足以将人类运送到火星的火箭。 5）”正因为如此” → 你的吸引力 现在我知道了你的解决方案为什么好了，但是你还需要向我提供一些证明。 如果你已经创造出了产品，那么就可以展示产品实际在市场上的效用。 如果你还没有产品，那么可以谈谈你为什么对自己的解决方案这么地有信心。 🏠 Airbnb 我们已经在平台上进行了 X 次预订，并且我们每个月都在以 X% 的速度增长。 💰 Coinbase 这就是为什么我们的用户群每月以 X% 的速度增长，而且我们已经管理了超过 $B 的比特币。 🚀 SpaceX 我们的第一步是通过使用我们最初的火箭为付费客户将卫星送入轨道来赚取收入。自我们开始以来，我们已经预订了 $B 的发布。 6）”直到最后” → 你正在占领市场 如果你的解决方案真的能解决问题，并且有足够的吸引力证明这一点，那么就要告诉我你究竟可以做到多大？ 🏠 Airbnb 凭借我们对每笔交易收取的 % 费用和每年 _ 百万次旅行，使用我们的产品是有意义的，我们正在研究一个 _B 美元的市场。 💰 Coinbase 随着比特币市场的价格为 B 美元，并且有 % 的新比特币买家适合我们的用户资料，我们正在追求价值 B 美元的市场。 🚀 SpaceX 商业卫星发射行业是 B 美元，但我们预计我们较低的发射成本会在未来 10 年内将其增长到 B 美元。 如果仔细分析，可以发现大多数的故事都可以直接套用上这一套皮克斯公式，它不仅能说好故事，也可以帮助我们用极短且易于理解的方式来描述事情的要点。 当然，就像皮克斯一样，你可能会需要不断迭代你的故事，以确保最后的产出，但你可以时常使用皮克斯公式来进行验证和反思自己正在做的事。 热点新闻1、触觉手套 Meta（前 Facebook）公司最新展示了旗下研制的触觉手套，带上它，可以在 VR 里模拟出触觉，与虚拟物体交互更真实。 配合物理引擎，除了可以游玩儿一些小游戏： 两个人还可以在虚拟空间完成握手、碰拳等精细度更高的动作： 虽然该项目还处于原型阶段，但看上去非常酷炫。 2、Apple 自主维修计划 最近苹果宣布「自助维修计划」，也就是说，用户将可以从线上商店购买到原装零件、工具，自己来维修损坏的产品。 不仅有大家常见的显示器、电池、摄像头等零件， 维修之后替换下来的旧零件，还可以给苹果公司回收获取相应积分，用来抵扣购置苹果设备。 但目前仅支持 iPhone 12 和 iPhone 13 系列，接下来也会慢慢开放到 Mac 电脑等领域。 虽然用户自助维修会有各种各样的麻烦问题，但我在想会不会在经历过一大波调教之后，苹果直接来一个支持自定义的 iPhone： 我们收到的可能全是根据自己需求选够的配件，最后由自己组装。 3、美国首个商业规模海上风电场动工 美国第一个商业规模的海上风电场 Vineyard Wind 1 正式破土动工，包括了 62 台风力涡轮机，将于 2023 年开始向马萨诸塞州超过 40 万个家庭提供清洁能源。 4、Github 年度报告 GitHub 重磅发布 2021 年度报告，透露了一个数据：全球已有超过 7300 万的 GitHub 开发者用户，几乎近 60% 来自北美之外的地区。其中，中国有 755 万，位居全球第二。 另外，报告也显示，JavaScript 仍然是 GitHub 上最受欢迎的编程语言，而 Python 现在是第二受欢迎的语言，紧随其后的是 Java 和快速增长的 TypeScript。 PS：755 万稍微换算一下，就意味着在中国，每 200 个人就有一个人是开发者？ 5、星巴克的无人咖啡馆 在纽约市公园大道和列克星敦大道之间的第 59 街，星巴克和亚马逊「合伙」开了首家 「无人」咖啡馆，已于 11 月 18 日营业。 它的特点是融合了亚马逊无人收银、星巴克啡快服务和传统第三空间。 进入该空间需要先使用亚马逊购物 app、Amazon One 或插入信用卡通过门禁，然后你从货架上取下的任何东西，都会自动添加到虚拟购物车中；如果你选择放回，它们就会从你的虚拟购物车消失。 这是由亚马逊的「Just Walk Out」技术实现的——摄像头和货架传感器会统计「谁」拿了「哪些东西」，并在他们离开商店时向他们收费。 虽然表面上节省了聘请柜台人员的成本，但背后隐藏了很多设备和技术的隐形成本。另外绝对的「无人」也并不是最终的追求，而应该是从消费者的角度出发，从「数字体验」中获得更好的体验，这倒是一个很好的出发点。 6、VR 成「电子止疼药」 11 月 16 日，EaseVRx 获美国食品和药物管理局（FDA）授权，可以作为「处方药」销售，可用于治疗慢性腰疼。起作用原理是，通过深度放松、注意力转移、内感受意识、换位思考、分心、沉浸式享受等方法，转移你的注意力，以达到减轻疼痛的效果。 另外，VR 除了用于治疗慢性腰疼，甚至还可以用来治疗儿童多动症和儿童弱视。 文章1、交互式学习正则表达式（英文） 网站提供了 55 道题目，可以交互式地学习，从容易到困难，一步一步攻克，从而学习 RegEx。 2、双 11 所有数据 这篇文章搜集了今年双 11 相关数据及资料，从平台成绩、直播电商、品牌销售、消费者画像、品牌营销五个方向切入，绘制出了一份完整的双 11 消费数据地图。 感兴趣的可以戳一戳。 3、运行内存都在运行什么？ 少数派与国民好物 aigo 联合推出的信息储存设备的科普系列文章，已经出到了第 5 篇，前面几篇也收录在了《一周分享》里面，感兴趣的童鞋可以戳一下。 PS：略有一点文不对题，其实文章描述的是运行内存的结构、原理和参数 4、我的阅读工作流（2021版） 作者分享了自己日常的阅读工作流，是非常完整的 PKM（个人知识管理）的实践分享。 5、万字长文解剖《原神》庞大游戏系统 本文是对《原神》主要系统各部分的概述及分析，篇幅略长，可以挑自己感兴趣的部分阅读。 PS：非常详细…. 6、OKR.COM 字节跳动作为 OKR 工具的践行者（使用飞书），利用该网站进行「布道」工作，感兴趣的可以戳戳。 7、直觉，好奇心，以及“闲逛（wandering）”的力量 勉强算是周末鸡汤？但味道挺不错的，属于咸淡适中的口味。大概就是说，不要紧绷，也不要放松，过流水一样的生活，控制自己能控制的部分，其他的听天命。 PS：安利一下这个公众号@极简主义生活方式 好奇星人1、白噪音可以缓解失眠和保持专注，有科学依据吗？ 直接说结论：除婴儿外，白噪音的作用就是掩盖其他声音。 因为有研究表明，婴儿在没有出生之前，会在妈妈的肚子里面听到类似于白噪音的声音。所以对于婴儿，白噪音确实能够起到助眠的作用。 另外，有相关研究表明一定程度的白噪音可以提高患有注意力缺陷多动障碍(ADHD) 的中学生的认知功能，但对没有多动症的学生整体影响是负面的；也有相关研究证明一定程度的白噪音虽然可以让人在嘈杂环境中更专注工作，但会降低人的复杂认知能力。 总之呢，我们日常所使用的那些所谓“白噪音”，可能就只有掩盖其他声音的作用，并且只是个人喜好的问题。 但有一点需要注意：不管什么噪音，超过一定分贝和一定时长，都可能造成听力的损害。 最后文章给出了几条建议： 达到效果的情况下，音量越小越好； 使用时间不宜过长，如果只是想要助眠，可以设定定时关闭； 不到万不得已，避免搭配耳机使用； 言论1、 无论界面多么复杂，或者用户学习使用它的路径有多复杂，他们仍然应该积极参与这个过程，而不是因为复杂性而气馁或感到不知所措。界面不应该回避复杂性，而应该引导和帮助用户理解复杂性——让他们获得学习的途径，而不是感到沮丧。 –关于接口的一些思考（英文） 2、 你不能用视频等其他信息来源代替阅读，因为你需要阅读才能写作，你需要写作才能思考。 –保罗·格雷厄姆（英文） 3、 有一句名言，医学生被教授的信息中，有 50% 会在几年内过时——但没人知道是哪 50%！ 在软件方面，我相信我们有类似的东西，除了它更像是我们编写的代码 100% 会出错——我们只是不知道什么时候！ 在需要时保持各种代码易于完全重写有助于减少技术债务和遗留代码。 –解耦代码含义的两种不同观点（英文） 4、 目前，这种还不具备很强的技术可行性，但这不重要。重要的是众多科技企业关注这个方向，并意识到了其中的可能性：即使只是个假设，元宇宙也确实解决了物理、商业、政治等现实层面的难题。 如果成为现实，那么元宇宙最终将建立起“公司国家”或者说“国家公司”，这个超大版亚马逊能够将原材料、供应链、生产制造、分销乃至使用等所有元素汇总到同一个服务体系之内。而这也成为我们永远无法逃离的消费黑洞。 –我们不需要元宇宙 5、 在提升效率的同时，公司也需要画红线。效率最高的方法就是让人一直工作不停歇，但这是不是真能在单位时间内产出更多工作成果还需要打一个问号，何况这种强制他人持续工作的方法少了点尊重，多了点不信任。 –《员工摸鱼被通报批评，大厂没有「厕所自由」，问题到底出在哪？》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 39 期）：什么是元宇宙","slug":"weekly39","date":"2021-11-14T01:45:00.000Z","updated":"2021-11-14T01:47:58.602Z","comments":true,"path":"2021/11/14/weekly39/","link":"","permalink":"http://www.wmyskxz.com/2021/11/14/weekly39/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 美国总统拜登当地时间 11 日签署了《安全设备法案》（Secure Equipment Act）。该法案旨在阻止被判定为安全威胁的公司获得新的电信设备牌照，被认为是针对中国通信和科技公司采取的最新限制措施。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 美国总统拜登当地时间 11 日签署了《安全设备法案》（Secure Equipment Act）。该法案旨在阻止被判定为安全威胁的公司获得新的电信设备牌照，被认为是针对中国通信和科技公司采取的最新限制措施。 本周讨论：什么是元宇宙（文案参考：【游戏之外】超硬核！深度拆解元宇宙！我们能否迎来全新的时代与机遇？）（视频） 最近，「元宇宙」这个概念在各个地方层出不穷，先有英伟达的「工程师元宇宙」，后有 Facebook 改名「Meta」，腾讯、阿里等一众互联网公司都宣布要参与进来。 到底是什么样的技术和概念，让一众互联网公司和媒体疯狂呢，我们尝试用简单的语言来解释一下「元宇宙是什么」。 首先，元宇宙（Metaverse）是 1992 年小说《雪崩》中出现的词语，这个小说描绘了一个多人在线的虚拟世界，大家戴着目镜，就可以在这个虚拟世界中玩乐、工作，甚至可以购买土地的开发许可证，建造楼房、公园等等，简单来说，有点像《头号玩家》这部电影。 但这部小说是 1992 年出版的，为啥突然在 2021 年火热起来了呢？ 这就需要牵扯到一个公司：ROBLOX 罗布乐思。 2021 年 3 月份罗布乐思在纽交所上市，然后市值一路上涨，现在股价 84 美元，市值 480 亿美元。 这是什么概念呢？EA 游戏公司被号称为美国腾讯，每年营收高的可怕，目前市值也就 400 亿美元而已。 那罗布乐思是一个什么公司呢？简单来说，他就相当于一个游戏平台，上面有很多类似于 4399 一样的小游戏，而且绝大部分都是玩家自己创造的。比如低配版绝地求生、各类 RPG、最新的鱿鱼游戏等。 官方也提供了一个简陋的开发编辑器，有点类似于魔兽争霸 3 的那种地图编辑器，但大神也能够创造丰富多样的游戏玩法。 这些自定义的东西魔兽争霸 3 也可以，我的世界也可以，像是老滚 5、辐射 4 等各种游戏的 MOD 编辑器都能做到，那为什么罗布乐思就这么牛逼呢？ 很简单，因为大神们在罗布乐思平台开发了游戏以后，可以卖。玩家们可以通过充值获得“萝卜币” Robux，然后购买别人开发的游戏。 罗布乐思平台在每笔交易中抽水一部分后，开发者将分到剩下的萝卜币，只要开发者一年赚到了 10 个萝卜币，就可以加入开发者兑换计划，可以将萝卜币换成美元。 最牛逼的是，你的游戏还可以做成「免费游玩，内购收费」的模式，可以在自己的游戏里面制作游戏商城，卖皮肤、卖道具都是可以的。 2020 年一整年，有 300 名开发者的收入超过 10 万美元，1250 名开发者收入超过 1 万美元。有一个叫 Alex 的小朋友，9 岁就开始在这个平台上做游戏，17 岁时做了一个《越狱》，爆火了，他每年通过这个游戏就能赚几百万美元。 罗布乐思在上市的时候，首次把「元宇宙」这个概念写进招股书里面，资本市场一看，哇，太牛逼了，纷纷买进他家的股票，之后更多的公司也都来蹭「元宇宙」这个概念了。 资本市场推动「元宇宙」的概念，还有另一个原因，那就是疫情。 中国的感受可能不太明显，因为即使是最严重的武汉，也仅仅封了几个月，其他地区解禁就更快了。但就在这宅家的几个月期间，中国各个游戏公司的收入大涨，包括 B 站等各种视频网站也迎来了一波爆发式增长。 这就说明了大家宅在家，都需要找一个娱乐方式。 但是国外的疫情管控没有我们这么好，很多人长时间待在家，他们对娱乐的需求也会大大增加。而且他们社会停摆的时间也比我们久，这也催生了很多事件的爆发，比如《黑寡妇》通过流媒体发放，导致最后寡姐告了迪士尼一通。 这其中有一个很重要的事，有一个叫 Travis Scott 的受欢迎的歌手想要开演唱会，但是疫情开不了了，于是跟 Roblox 合作，来了一场「游戏中的演唱会」，这一场演唱会全球有 1200 万观众，就算一个体育场观众拉满，也就 3-6 万，这事儿一出，让资本市场开始思考，元宇宙大有可为，紧接着 Roblox 就上市了，脸书、腾讯、阿里也纷纷宣布入局。 另外还有一个很重要的事，美国疯狂放水，然后各国央行都有一定程度的放水，这么多的钱需要找个地方消耗出去，所以很多人就把目光转向了「数字资产」。 注意这里说的是资产，而不是游戏道具。你王者荣耀充值再多皮肤，原神抽再多角色，那都只是游戏道具，是一段代码的复制品，而 CSGO 中的饰品系统就有点类似于数字资产，因为它们不仅可以交易，而且都可以溯源，这很重要。 总之，就是想象一个游戏，你戴上某个可穿戴设备之后，就完全进入了另一个虚拟世界，你可以在里面娱乐、工作、购物等等。 有人说，我不玩游戏怎么办？注意，「游戏」是一个哲学概念。比如你父母可能不玩游戏，但他们打不打麻将？你朋友可能不爱玩王者荣耀，但他可能每个周末都出去玩剧本杀。 没有人是可以不玩游戏，人类的精神是一定需要待在一个虚拟世界的，不管它的形态是文学、短视频、电影还是游戏。 所以元宇宙想做的事，就是把人从虚拟世界中拉到元宇宙世界中。但这是怎么做到的呢？ 举个例子，原来我们需要上街去购物，现在虽然我们可以网购，但也只能让我们看到图片，元宇宙要做的，就是让你戴上 VR 眼镜直接进入店铺进行选购，你甚至还能拉上好友一起逛街，说不定还能碰见其他熟人。 虽然这事儿现在八字还没一撇，但有些学家已经指出，电子游戏就是新时代的「工业革命」。 初中我们都学过工业革命，一提到这个词，我们想到的就是蒸汽机啊、轮船啊、飞机啊之类的，但却是「纺织业」带动了整个工业革命的发展。 为什么会是这个东西呢？首先衣食住行是第一需求，然后纺织活动又是一些简单重复的活动，就很容易机械化，而且还不依赖天气、光照这些东西，其次就是这个行业链条特别长，从产出到运输，能够带动和养活特别多的人。 所以纺织业为什么能带动工业革命呢，它有以下几个特征： 行业空间很大，需求很大，人民群众需要这个东西； 产业链条很长，这个链条上的人都能吃到红利； 需要的技术很多，而且这些技术都成熟以后会开始爆发，引起变革的连锁反应； 巧的是，电子游戏产业跟棉花纺织产业的特征几乎一模一样。 讲到这里不知道大家感受到「元宇宙」的魅力没有，它就是一个虚拟世界，我们能在里面干任何想干的事情，不管是购物、社交、演唱会等，只不过这一切都是以「游戏」的形式呈现。 热点新闻1、自动驾驶双 11 专线 10 月 31 日，济南和上海之间架起了一条「双 11 自动驾驶专线」，每天两班，单程 880 公里，目前 90% 的行程都已实现由汽车的辅助驾驶系统完成，每次行程需要一名经过培训的司机。 2、中国 200 所大学无人车送快递 今年双 11，中国 200 多个大学的收快递方式，已经改由达摩院旗下的无人车「小蛮驴」来完成。无人车会自己驾驶到寝室楼下，下楼就能取件。 从 11 月 1 日到 10 日的情况来看，它们以日均 10 万件的速度疯狂「跑单」，堪称劳模。 3、吸入式新冠疫苗 11 月 12 日全球首款可吸入式新冠疫苗亮相海南博览会，使用方法就是嘴部对准，像喝奶茶一样疯狂吸入就可以。 原理是把药物雾化，通过口部吸入的方式进入呼吸道和肺部，从而激发黏膜免疫，而这种免疫是通过肌肉注射所不能带来的。目前二期临床试验已取得阶段性成果，正在推进紧急使用的申请工作。 4、口红打印机 YSL 推出首台彩妆私调概念机，底部的三个唇釉管芯，可以通过手机 APP 控制不同的配比，从而调出上千种唇色。 APP 支持色谱取色： 实景取色： 穿搭配色： 目前已上架平台支持购买，仅含 3 支管芯的套装售价 RMB 3190，12 支管芯的售价为 RMB 5350。 5、葡萄牙禁止老板下班后联系员工 作为被称为“休息权”的新法律的一部分，葡萄牙禁止老板（员工人数超过 10 人）在工作时间以外给员工发短信和发电子邮件。 还有新规定允许有孩子（未满 8 周岁）的员工远程工作，公司也可能不得不因以家庭为基础而导致更高的家庭账单，例如能源和互联网成本。 6、全球首个宣布加入元宇宙的城市 韩国首尔表示，它将成为第一个进入元宇宙的大都市。如果计划成功，首尔市政府将在 2022 年底前开发自己的元宇宙平台，到 2026 年全面运行时，首尔居民可以通过戴上虚拟现实的护目镜，完成各种公共功能。 文章1、建立第二个大脑：概述（英文） 一篇非常好的「第二大脑」构建指南。 2、制作流行开源项目的 3 个技巧（英文） 文章的切入点是 Github 上的开源项目，但其实所有的项目（或者说产品）都对其中提到的 4 个（最后一条是提炼）技巧适用，它们分别是： 精心设计自述文件； 创造人们想要的东西； 传播； 发现自己独特的风格以及适合自己的风格； 3、如何制作 CPU（英文） 第一步是得到一块石头（最好是硅石）。 经过一系列提纯，现在有了 98% 浓缩二氧化硅。 又一系列提纯，得到 99.999999% 的多晶硅金属。 …. 总之就是图片的形式简单说明了 CPU 的制作过程。（其中过程可能过于省略，但好在易懂…） 4、2021 年 RSS 订阅源推荐 订阅源非常广泛，感兴趣的童鞋可自取。 5、对回复的思考，或许是时候改变 很值得读的一篇文章，引用文章中的几句话： 对于回复，有人喜欢「从前车马慢」的慢节奏，有人是即发即回的「复恐匆匆道不尽」，也有人坚持直接通话因为「天涯共此时」，但无论如何，你的回复方式显现了你的个人风格，如果你发现自己的节奏超速了，或者他人对你的节奏超速了，那就不妨放慢，表明自己的态度，重新调整他人对你的期望。 关掉推送吧，这也是教会我们的手机一些礼仪，让它不再是一个大大咧咧吵个不停的大嘴巴，而是准备好成为一个服务周到又礼貌的秘书。 6、财富创造机制目录（英文） 文章总结了创造财富的九种基本机制，它们分别是： 把东西从一个地方移到另一个地方；（运输业） 存放东西；（零售业） 以化学或机械方式改变事物；（制造业） 农业； 建造建筑物；（建筑业，也可以认为是 3 的子集） 从地球或太空中提取自然资源；（采矿、石油勘探、渔业等） 治愈疾病，或至少改善症状；（医疗业） 寻找全新的方式更有效地完成上述任何一项工作；（研究发明） 为人们提供有用的信息； 帮助匹配供需；（包括企业家） 帮助人们找出规则；（律师和顾问） 提供本身有用的信息；（新闻和写作） 个人觉得，对于个体来说最简单行之有效的路径就是最后一条了，博主就对应其中。 7、【游戏之外】超硬核！深度拆解元宇宙！我们能否迎来全新的时代与机遇？（视频） 也就是本期主题讨论引用的视频，非常建议观看一下。 8、千萬不要錯過，將會徹底改變世界的元宇宙（视频） 老高与小茉的作品，配合上面的视频一同食用吧~ 好奇星人1、为什么你喝完咖啡就犯困? 我们之前说过咖啡提神的原理是“鸠占鹊巢”，代替腺苷和受体结合，让腺苷“无家可归”，大脑就接收不到来自身体的犯困信号。 但是咖啡因并不是永久起作用，而是有一个半衰期，通常约为 4 小时。但每个人体质不同，将咖啡因代谢出人体的速度也不同。 一般情况下，当咖啡因阻碍腺苷发挥作用，你的身体会误以为腺苷还不够多，就会产生更多的腺苷进行补偿，于是，大量腺苷会在体内累积。 当咖啡因被身体代谢排出体内，这些腺苷会“卷土重来”，重新占领受体， 你也会比之前更加疲惫。 如果你代谢速度太快，咖啡还没来得及完全发挥提神作用，反而可能让你犯困。 如果实在撑不住了，就好好睡一觉吧。毕竟欠下的睡眠债，总是要还的。 言论1、 双十一就像一个赌场，有人发财，但更多的是赔钱。电商平台则相当于赌场，赌场是不会赔钱的。 –全球最大的消费主义盛典，是如何变「低调」的？ 2、 事实上，承认你不知道市场走向通常是你作为投资者可以做的最好的事情。 为什么？ 因为它会引导您分散投资组合，并为可能出现的许多可能结果做好准备。 –如何在不知道未来的情况下投资（英文） 3、 在网红种草到处都是坑的情况下，人们在做消费决策，尤其是体验更复杂的线下服务时，普遍变得越来越理性。不少用户回过头来才发现，用大众模式帮助种草或者拔草，才是最有用的。 –出门消费，我还是选择相信大众点评 4、 远程工作正在创造一个新的经济利基，投入工作来填补它的国家最终将能够与美国竞争以吸引人才。这是小而稳定的国家实现经济增长、多样化和提高技能的千载难逢的机会。 –远程工作将打破美国对全球人才的垄断（英文） 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 38 期）：我们需要延迟满足吗","slug":"weekly38","date":"2021-11-07T07:55:00.000Z","updated":"2021-11-07T07:56:01.057Z","comments":true,"path":"2021/11/07/weekly38/","link":"","permalink":"http://www.wmyskxz.com/2021/11/07/weekly38/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 11 月 7 日，中国 LPL 赛区战队 EDG 在 1:2 落后的情况下，连追两分，战胜 LCK 赛区战队 DK，夺得《英雄联盟》S11 总决赛冠军！我们是冠军！","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 11 月 7 日，中国 LPL 赛区战队 EDG 在 1:2 落后的情况下，连追两分，战胜 LCK 赛区战队 DK，夺得《英雄联盟》S11 总决赛冠军！我们是冠军！ 本周讨论：我们需要延迟满足吗这是来自公众号@L先生说的「每周一篇智识」系列，分享给大家。 1960 年代，斯坦福大学 Walter Mischel 博士做了一个广为人知的棉花糖实验。 据此，Walter Mischel 博士认为：那些等待研究者回来的孩子，他们有一种很强的能力，叫做 「延迟满足」。这种能力使得他们可以抵抗美食的诱惑，从而也能在今后的人生中，更好地校正自己的道路，抵制诱惑和歧途。 1998 年，心理学巨匠 Baumeister 提出了 「自我损耗」 理论。他认为：延迟满足的本质，就是一个人的意志力。意志力强的人，就更容易抵抗即时的诱惑，去做更加长期的事情。 进一步，Baumeister 的自我损耗理论还认为： 1）意志力是一种「心理能量」，你每使用一点，它就会消耗一点。 2）它的生理基础是糖。一杯加了糖的柠檬水，就能快速有效补充意志力。 3）它就像肌肉一样，可以通过锻炼来加强。经常训练它，就可以提高你的意志力。 这个理论看上去实在太简洁、太美妙了，又跟我们的直觉无比契合。因此，自我损耗理论提出来之后，就立刻风靡全球，被无数人奉为圭臬。说它是 21 世纪初影响力最大的心理学理论，也不为过。 但是，自我损耗理论真的是对的吗？「延迟满足」真的那么重要吗？ 实际上，近 10 年以来，这个理论正在遭受着狂轰滥炸的质疑和审视。 近几年的实验不断向我们证明：我们所推崇的「延迟满足可以让一个人变得更优秀」的观点，很可能是错的。延迟满足很可能并不是原因，而是结果。 什么样的结果呢？主要有两方面：一是对环境和外部世界的信任，二是较为良好的认知能力。 也就是说：父母本身较为优秀、且成长环境良好、得到足够关爱的孩子，他们普遍会有更杰出的成就，同时也会表现出更强的「延迟满足」能力。 后两者都是前者的结果，它们本身并没有因果关系，只是我们一直误以为它们存在因果关系罢了。 我们更应该追求的是 「长期反馈」。 延迟满足和长期反馈两者的区别是什么呢？ 延迟满足，是把本应得到的回报往后延，告诉自己：我现在得不到这些回报，但我将来总是能得到的，所以我要控制自己，压抑自己，撑过这段时间。 它本质上是一种对欲望和需求的抑制，用未来的回报来激励自己。 而长期反馈呢，则是把回报的时间拉长，把它分摊在达成目标的一整个过程之中，并且学会从过程中获得乐趣，把精神上的满足感和成就感也视为一种回报。 它并不抑制你的欲望和需求，而是通过改变你的心态，用一种更灵活、更具策略性的方式，不断在你奔赴目标的过程中为你注入能量、打气加油。 打个比方。 比如你开一家创业公司，前几年一定是非常艰苦的，但你说服自己，说，等熬过这段时间就好了，到时就有回报了 —— 这是延迟满足。 再比如，你开一家创业公司，前几年很艰苦，但每克服一个难关，你都能感受到满满的成就感；每上一个台阶，都感到离目标更近了一步，于是不断从中获得反馈和动力 —— 这是长期反馈。 所以，延迟满足最大的问题是什么呢？它会不断堆高你对于未来的奖励的期待。它相当于用过程里的「压抑」和「忍受」，去换取结果的「丰厚回报」。 这种期待一旦过高，当你真正去获得它的时候，你从中获得的奖赏感反而就更少了 —— 因为我们知道：大脑的奖赏机制，是实际奖励和期望的差值，而不是实际奖励本身。 进一步，当你没有能够获得如期的丰厚回报时，你就很容易陷入失望和沮丧之中。你会感觉：那我前面这段时间是为了什么呢？我的苦是不是白捱了呢？ 所以，我们要培养长期反馈的习惯，要能够从成长、克服困难里面获得成就感和幸福感 —— 而不是要去追求「延迟满足」。 因为，吃苦没有任何意义。我们无需白白地去在我们人生的任意一个阶段里去「压抑」或「忍受」，这除了为我们创造不堪回首的回忆之外，没有任何作用。 追求「长期反馈」有一个重要的思维方式，就是要去找到目标。在这个过程中，发挥自己的能力，感受到自己的成长，找到「做成一件事」的成就感和幸福感。 这才是更高层次的「满足」所在。Be Better~ 热点新闻1、 美国普渡大学机械工程系阮修林教授团队研发了一种可以辐射制冷的硫酸钡超白漆，这种油漆不仅能反射 98.1% 的太阳辐射，最高可降温 11 ℃，还成为吉尼斯世界纪录中“最白”的油漆，并且申请了多项国际专利。 2、 最近，有一家名叫 EnLiSense 的公司与得克萨斯大学联合开发了一款皮质醇水平检测设备，可以利用微量汗液实时反馈受检者的压力水平。 3、 11 月 5 日消息，中央网络安全和信息化委员会近日印发《提升全民数字素养与技能行动纲要》（以下简称《行动纲要》），对提升全民数字素养与技能作出安排部署。 《行动纲要》提出，到 2025 年，全民数字化适应力、胜任力、创造力显著提升，数字素养与技能提升发展环境显著优化，基本形成渠道丰富、开放共享、优质普惠的数字资源供给能力。初步建成全民终身数字学习体系，老年人、残疾人等特殊群体数字技能稳步提升，数字鸿沟加快弥合等。 4、 腾讯视频举行的“2022腾讯在线视频v视界大会”上，电视剧《三体》预告片进行了全球首发。 就在不久前，Netflix（文中简称：奈飞）也公布了主创阵容。 虽然两大平台的文化背景截然不同，但对《三体》的巨大投入和与原著作者的紧密合作，却保持一致。由此，无论市场还是原著粉，对腾讯和奈飞两大平台即将播出的《三体》，给予了不同的想象。 文章1、Linux x86 程序启动 / main() 是如何跑起来的？（英文） 本篇适合那些想要了解程序是如何在 Linux 下加载的人。 2、如何成为一名黑客（Hacker）（英文） 2001 年的一篇旧文，但仍然可以作为「黑客白皮书」使用。 3、跟李沐学AI | bilibili（视频） 这个学期，李沐在斯坦福大学开了一门《实用机器学习》的新课，除了斯坦福学生能在线下学到以外，课程的录像、PPT 也都在网上免费公开。 不过B站上能看到的版本却不是课程录像，而是李沐回到家里再专门用中文重新录制的！ 不仅 AI 专业的导师们纷纷推荐给学生看，甚至导师自己也追更？甚至有网友直呼“简直是做慈善”。 不说了，先关注一波沐神。 4、刘润年度演讲 2021：进化的力量（演讲全文） 进化的力量，就是面对变化，用海量「随机」的物竞，应对终极「任性」的天择的力量。 这一篇演讲全文略长，建议选择阅读。 5、聊聊这些年极简对我生活的改变 我对极简的理解是心里知道生活的重点在何处，知道如何分配自己的时间和精力，不过随波逐流的生活，不迷恋繁花似锦，而专注内心的丰盈。 6、Google、Twitter 和 Spotify 如何建立文档文化（英文） 软件公司的内部文档，往往是一个痛点，要么根本没有文档，要么就是杂乱不堪，分散在代码、Word 文件、Confluence 等各处。软件公司越大，这个问题越严重，本文介绍三家大型互联网公司如何处理内部文档。（来源@阮一峰的科技爱好者周刊（第 182 期）） 7、用直观抓住NFT是什么 你很难想象，上面这个小小的图标，卖了 750 万美元。一个 png 文件为什么能卖到如此价格？ 这一篇来自 @卫sir 的文章从细节处出发，解答了 NFT 的各种问题。 8、以游戏的方式学习代码 | CodeGym CodeGym 是国外的学习网站，但大家完全不用恐惧英文的问题，因为网站提供了完全的汉化版本。 该网站围绕 Java 体系，设计了一整套基于游戏方式学习的关卡，最关键的是剧情和动画都还算有意思。感兴趣的小伙伴可以体验一下。 9、万字爆肝｜80% 设计师都不清楚的设计系统 如图。 好奇星人1、皮卡丘是如何发电的？ 首先，根据官方的介绍：皮卡丘的电，一般放电电压达 10W 伏，爆发的时候高达 100WV。考虑到皮卡丘自身并无旋转机制，所以不会产生旋转电场和磁场的作用，所以，皮卡丘放的电为直流电。 那么根据直流电进一步推测，发电的方式基本可以分为物理、化学、生物发电三种方式： 物理发电：受光照刺激造成电子跃迁形成电流（太阳能发电技术的原理）； 化学发电：燃料电池、锂离子电池等技术； 生物发电：比如电鳗，就是很多发电细胞积累膜电位，接到神经系统信号后有些电位反转，就放电了。简单讲就是很多很多细胞，积累了电势，像一堆串联起来的电池，收到信号以后电池被接通了，迅速放电~ 根据动漫里面的场景和描述：如果是化学发电，那么燃料非常不方便补充，适用性也非常有限，所以排除； 如果是物理发电，皮卡丘有夜晚战斗的事迹，没有光照的条件下也能发电，所以大概率也排除； 所以，剩下的最合理的方式也就是生物发电了。 PS：可爱的问题，但是看了 ≈ 没看系列… 不过原答案有详细的公式计算，比较硬核，这里就不放上来了… 言论1、 我想知道如何才能在不依赖社交媒体的情况下找到值得阅读的内容。因为现在这看起来几乎是不可能完成的任务。一切都通过时事通讯或社交媒体渠道汇集。 –我不知道如何浏览互联网了（英文） 2、 虽然可以在两个世界都有一份大脑拷贝，但是无形世界的生活如同毒品一样，一旦经历过那生活，谁也无法再回到有行世界，我们充满烦恼的世界对于他们如同地域一般。 –刘慈欣 2001 年小说《时间移民》 刘慈欣说，“人类面前有两条路。一条是向外，通往星辰大海；一条向内，通往虚拟现实。”前一条道路是“飞船派”，探索广袤的宇宙世界，另一条是“元宇宙派”，刘慈欣是铁杆的飞船派，对于扎克伯格的Metaverse战略，刘慈欣认为，那将是一条自娱自乐的死路。 –对待元宇宙：罗永浩的积极与刘慈欣的悲观 3、 对于打工人而言，互联网大厂的退休政策和待遇目前并不重要，重要的是有没有机会干到退休。大佬们可以挥挥衣袖，功成身退，对打工人来说，退休还是奢望，不被优化就已经谢天谢地了。 –没人能在腾讯干到退休 4、 时至今日，除了日本雅虎外，雅虎这个名字在互联网中存在的痕迹也已经越来越淡。但不管怎么说，尽管雅虎未来可能会消亡，但是杨致远与大卫·费罗定下“开放、免费和盈利”的游戏规则，还是会一直长存。 –《雅虎中国终谢幕，但失败在16年前就已注定》 5、 也许有一天，我说也许，也许有一天，我们会对英雄联盟或电子竞技失去了信心。因为韩国的宰治，在今日为止，都还在持续，但我觉得不是今天。 也许有一天，这些我们所热爱的选手，没有办法坚持在舞台上了，但也不是今天。 –LPL解说记得 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 37 期）：程序员仍是「版本最佳答案」","slug":"weekly37","date":"2021-10-31T01:59:00.000Z","updated":"2021-10-31T02:16:09.989Z","comments":true,"path":"2021/10/31/weekly37/","link":"","permalink":"http://www.wmyskxz.com/2021/10/31/weekly37/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 2021 年 10 月欧洲天然气等能源价格普遍大涨，在多国出现能源短缺状况之际，俄国表示，除非摩尔多瓦清偿欠七亿美元债务，否则有可能 12 月 1 日起停止供气。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 2021 年 10 月欧洲天然气等能源价格普遍大涨，在多国出现能源短缺状况之际，俄国表示，除非摩尔多瓦清偿欠七亿美元债务，否则有可能 12 月 1 日起停止供气。 本周讨论：程序员仍是「版本最佳答案」 本期讨论来自于 1024 程序员节半佛出的一期视频，他的结论是：程序员仍然是现在普通人的最佳版本答案。 为什么程序员看起来这么「卷」，可依然是「版本答案」呢？我简单复盘一下视频里的核心观点： 第一，高薪。 大家都在说互联网不好干了，程序员卷起来了，35 岁怎么怎么惨，但怎么还这么多钱？ 其实答案很简单，「卷」和「给钱」，这两件事并不冲突。其他行业即使再怎么卷，能卷到程序员的高薪吗？ 第二，程序员这个职业的最大优势，就是可以提前兑换价值。 如果拿 MOBA 类游戏来类比的话，那老师、医生很可能是属于后期职业，而大部分程序员则是前期职业（其中也有越到后期越吃香的大佬）。 老师、医生这些职业之所以越到后期越吃香，是因为前期吃下的资源足够多，后期发力也就足够有力。 譬如，要培养出一个优秀的医生，需要经历过多少病人？要锻炼出一个经验丰富，熟悉学生心理的老师，要教多少学生？ 这些职业不能速成，也很难低成本重复，他们的工作经历本身，就是一种难以复制的资源。 但如果你完成了从普通程序员到技术大佬的转型，你在程序员阶段积攒了足够多的「经验」，依然可以是非常强有力的后期职业！ 换个角度说，虽然从普通程序员变成技术大佬很难，但从普通老师变成名师，从普通医生变成名医，不是一样难？并且如果你转型成功，是前期香，后期更香。 可能程序员没有过去那么神了，但只要程序员收入的起点还是某些行业的天花板，这个职业就一定是非 ban 必选。 为啥？ 你选择当程序员，哪怕 35 到 40 岁不做了，用十几年的时间赚到其他职业一辈子的收入，只要你不是胡乱挥霍，后面只要你不是马上猝死，干点啥都是赚的。 你为自己赢得了生命中属于自己的时间。关键是，同样的收益，在二十年前拿到，和二十年后拿到，价值可能是截然不同的。 程序员哪哪不好，但好就好在可以先 TM 买房啊！想想别的行业熬了二十年了，终于要崛起了，可是很多程序员二十年前就已经把红利变现了，然后买了房，你还怎么对抗啊？ 拿着钱，干点啥不行，人生不一定要一直卷的，活着，有空闲时间，干点喜欢做的事情，这本身就是一种价值。 第三，35 岁危机可以「和平过渡」。 你说 35 岁怎么办，可是冷静想象，35 岁也不是必然失业，还可以降薪去小公司，降完薪还是比其他行业的同龄人赚得多。 也搞不好你已经转型管理岗了呢？而且为啥程序员不多研究业务，直接转产品经理呢？ 反正钱已经赚到了，就看你有没有攒下来了。 说白了，有问题的从来都不是职业，而是你怎么玩儿弄这个职业。无论你是已经工作了，还是正在选择以后的职业道路，想要降低中年危机的风险，都可以考虑一下以下问题： 1、如果你的职业现在很赚钱，这个赚钱能持续多久？你的身体变化和年龄增长会影响收入吗？行业的变化趋势是什么样的？ 只要还没有财务自由，就不要养成高消费的习惯，以免泡沫消失后接受不了落差。 2、你的职业可替代性强吗？如果把你辞退了，老板需要花多大代价才能找到差不多的人？这样的人愿意接受和你一样甚至更低的薪水吗？ 无论从事什么行业，都要多吃资源，增加个人价值，来提高企业的替代成本。 有时候社会竞争的本质逻辑，就是比拼谁能在短时间吃下更多的资源，然后快速消化，再去抢更多的资源。 我们不能决定命运要用怎样的姿势对我们下手，但我们至少可以在它下手前，挣扎得不遗余力。 如果不能反抗，那就享受吧。Be Better~ PS：看完蚌埠住了..另外我觉得还有第四点，也比较关键：那就是程序员是一个完全可以靠个人努力实现理想的职业..这一点很重要，有些行业太“费爹”了.. 热点新闻1、 Facebook 正式改名 Meta，取自单词 Metaverse，意为元宇宙，扎克伯克在《创始人的信》中解释了更名的原因： 现在我们的品牌与一个产品紧密相连（指 Facebook），但它不可能代表我们现在所做的一切工作，更不用说未来了。随着时间推移，我们更希望被看作是一个元宇宙公司，我希望我们的工作和身份被锚定在我们正在做的东西上。 扎克伯格阐述它所期望的「元宇宙」很酷：“你不仅仅是使用或者看着它，而是身在其中。你可以将任何现实世界中的东西带到云宇宙里来，一切格式的影视媒体作品、书籍、照片、实物都将以全息图的形式出现。” 对于 Facebook 更名，以及他所描绘的元宇宙愿景，你怎么看？ 2、 「沙丘」是 Frank Herbert 创作的史诗系列科幻小说，最近同名电影也正在热映。故事发生在遥远的未来，发生在沙漠星球阿拉基斯 (Arrakis) 上。然而，如果真的存在这样的世界，那究竟会是什么样子呢？ 国外的一个团队根据小说中的描述：行星的地形、运行轨道等，运用计算机真实地模拟出了这个 1965 年就完成的小说里的幻想星球 Arrakis。 发现书中的大部分描述都比较符合预期，除了书中说 Arrakis 不会下雨，而模型表明不仅会下雨，而且夏季气温会融化冰层，而冬季不会有降雪来补充冰盖。 3、 在芬兰，超速罚单与您的收入有关，罚款金额是按照违反人员每日可支配收入计算的，这也就意味着，当那些富豪违规之后，会开出一些「天价罚单」。 例如，前诺基亚董事 Anssi Vanjoki 因骑摩托车在 50 公里/小时区域内以 75 公里/小时的速度行驶而被罚款 116,000 欧元（103,600 美元）。 2015 年，芬兰商人 Reima Kuisla 因以 22 公里/小时的速度超过 50 公里/小时的速度限制而被罚款 54,000 欧元（62,000 美元）。 然而，芬兰并不是唯一一个对超速罚款实施所谓“渐进式惩罚”的国家。瑞士、英国、法国、西班牙等都有类似规定。 4、 US News 世界大学排行榜，新鲜出炉。今年“排位赛”的亮点如下： 哈佛、MIT和斯坦福稳居前三，与去年排名保持一致 中国（含港澳台）共有 289 所高校入围，数量位居全球第一 内地高校入围前 100 名仅清华和北大，前 200 名共 11 所 吉林大学、哈工大排名惹争议，不及山东科技大学和湖南大学 5、 麻省理工学院计算机科学与人工智能实验室 ( CSAIL ) 和 Senseable City 实验室的科学家们推出了第一艘自动导航、完全自主的机器人船（可以理解为自动驾驶的水上出租车），本周，在阿姆斯特丹运河上正式试运行。 该船能装载 5 个人，并且能够用来收集垃圾、运送货物以及其他人们用船做的事。目前该船采用电池供电，一次充电能够运行 10 小时。 6、 VS Code 正式发布了官方的浏览器版本，这意味着你可以在任何设备上登录并使用这个编辑器。跟之前 Github 发布的 github.dev 很接近，唯一的区别是还支持除了 Github 之外的其他代码托管服务。 7、 「子不教，父之过」上升为法律，中华人民共和国主席令第九十八号发布，通过了家庭教育促进法，这是我国首次就家庭教育进行专门立法，自 2022 年 1 月 1 日起执行。 法律明确，未成年人的父母或者其他监护人负责实施家庭教育。国家和社会为家庭教育提供指导、支持和服务。未成年人的父母或者其他监护人应当合理安排未成年人学习、休息、娱乐和体育锻炼的时间，避免加重未成年人学习负担，预防未成年人沉迷网络。 8、 日本一家科技公司今日研发出一款酷炫的「飞行摩托车」，售价为 7770 万日元（约合 435 万元人民币），目前已接受预定，并将于 2022 年上半年正式发货，全球限定 200 辆。 文章1、2021 年最佳开源软件 InfoWorld 是致力于引领 IT 决策者走在科技前沿的国际科技媒体品牌，每年 InfoWorld 都会根据软件对开源界的贡献，以及在业界的影响力评选出当年的“最佳开源软件” (InfoWorld’s Best of Open Source Software Awards, Bossies)，该奖项评选已经延续了十多年。 这是今年获奖的 28 个项目。 2、为什么甲骨文价值 $260B？（英文） 如果您是一名开发人员，您可能听说过 Oracle 公司，但是为什么这么多大公司都在使用它家的产品呢？为什么它的市值又值现在的 $260B 呢？ 这一篇文章就尝试解答上述的问题，感兴趣可以戳一下。 3、沙丘电影注释（英文） 很多朋友去电影院看了沙丘一脸懵，其中吐槽最多的是：为什么都 10xxx 年了还在肉搏。 其实沙丘的整个世界观很庞大，这一篇注释可能会为你解答观影过程中的大部分问题。 4、重度互联网用户的大脑再训练指南（英文） 这篇文章适用于那些担心自己的「数字习惯」会干扰自己的幸福感、生产力、创造力和动力的重度互联网用户。 作者提出，多年的大量的互联网使用经验，我们的大脑已经被「重新编程」了，所以我们需要「反编程」。以下是作者关于如何「保持一种冷静、清晰的思维状态」提出的九条原则： 对「数字设备」有目的性； 取代「数字设备」在生活中的核心作用； 减少垃圾食品的摄入； 停止多任务处理； 用真实的社交互动取代社交媒体； 别看色情片了； 早上和晚上别看屏幕； 让价值观和「线上行为」保持一致； 追求真正的卓越； 5、张一鸣最后一次演讲《平常心做非常事》 世界在动态变化，外部波澜起伏，内心要保持平静如常。 3 月 30 日，在公司 9 周年庆上，字节跳动创始人张一鸣发表了演讲《平常心做非常事》，分享了他对于“平常心”的思考：如何以平常心对待自身、公司业务、行业竞争、成功和失败。 时看时有新的感悟，算是一次回顾吧。 6、《鱿鱼游戏》背后的反讽 可能不少人都已经看过《鱿鱼游戏》了吧？尽管中国大陆是 Netflix 在全世界未能进入的四个市场之一（另外三个分别是朝鲜、叙利亚和克里米亚地区）。 这部剧为什么会这样成功？除了分析游戏设计、布景、色彩、造型等等元素之外，我读到的文章里面还经常提到的一点是：因为它讲述了在残酷的资本主义制度之下，人们的共同感受。 来自方老师的一篇深度解读，推荐★★★★★。 7、怎样让基民也赚钱？ 孟大的一篇文章，开头通过权威机构的报告，点明了一个有趣的结论：公募基金行业里，基金赚钱，但基民不赚钱。 看完之后越发地觉得大道理都是具有「普世价值」的，各领域的道理也几乎都是趋同的。 8、看看高人是如何理解当今国际形势和中美关系的 咳咳… 列举一下文中 38 条鲜明观点的其中几条： 21、第二个问题是分配问题：收入差距重新严重拉大，多数人收入不增长。1978～2019，美国无专业技能普通工人工资上涨了仅仅14%；日本人平均工资在2000年是38364美元，2020年是38514美元，20年间增长了0.4% 22、这30年来，只有1%的人受益了，99%的人都没有受益。美国从事金融、高级官员收入增加最明显；律师和大学教授收入基本不动；美国中产阶级，每个月扣完税，大概就是3000～4000美元；欧洲交完税，也就2000美元。所以欧美老百姓收入也不高，过的日子并不好。 31、谁在全球化中受益？掌握资本的、掌握知识的。而多数人不掌握资本和知识，所以全球化并不是让多数人受益，只是少数人受益。 感兴趣可以戳一下。 好奇星人本周暂无。 言论1、 如果使用得当，正如俄亥俄航空学校的 Ben H. Darrow 在 1929 年所建议的那样，广播、电视和未来的技术将有助于“……不是为了分散注意力，而是激发学习、激励，为旅途增添乐趣。” –广播真的可以教育吗？（英文） 2、 这些商业书籍大多是回顾过去的：企业是做了什么才成功的？未来永远难以预测，了解过去才有价值；另一方面，这些商业书籍隐含的信息是，这些公司使用的原则不仅使它们在过去取得了成功，而且为它们的持续成功奠定了基础。 在某种程度上，这并不是真的，这就对这些书的基本前提提出了质疑，不是吗？ –受幸存者偏见困扰的商业建议（英文） 3、 为什么没有更多不同类型的开放世界游戏？《侠盗猎车手 III》二十年了，为什么它们中的大多数仍然是光鲜的谋杀模拟器？ 甚至像《对马岛之魂》这样视觉效果极佳以及对封建日本还原叹为观止的游戏，都是围绕杀死数十名敌人而建立。 答案在很大程度上与开发这些游戏的成本和时间有关：考虑到财务投资，大型工作室倾向于远离实验，转而支持熟悉和安全的东西，尤其是随着越来越多的人参与管理级别。“你要确保它足够”香”，这样更多的人才能真正进入它，”Désilets 说。通常情况下，这意味着杀戮。 –在“侠盗猎车手 III”之后，开放世界游戏从未（并且总是）相同（英文） 4、 没有任何外部因素会让你更有效率，而且如果你需要某种氛围才能处于最佳状态，你就无法真正控制自己。 –但首先，不要洗碗（英文） 5、 尤其是在这个正在经历巨大变化、几乎所有人都看不清前路的时候，我们或许都应该学会与不确定性共存，接受“没有答案”也是一种答案，至少是暂时的答案。 –和“没有答案”共存 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 36 期）：当世界置身一片火海","slug":"weekly36","date":"2021-10-24T01:28:00.000Z","updated":"2021-10-24T01:28:49.400Z","comments":true,"path":"2021/10/24/weekly36/","link":"","permalink":"http://www.wmyskxz.com/2021/10/24/weekly36/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 据调查显示，澳大利亚东北部大堡礁近年面临的珊瑚白化危机史无前例，目前已有三分之二的珊瑚遭到破坏。 PS：珊瑚白化是气候变暖引发海水温度上升，导致珊瑚及体内的共生藻死亡，仅剩下透明的珊瑚虫或白色骨胳的现象。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 据调查显示，澳大利亚东北部大堡礁近年面临的珊瑚白化危机史无前例，目前已有三分之二的珊瑚遭到破坏。 PS：珊瑚白化是气候变暖引发海水温度上升，导致珊瑚及体内的共生藻死亡，仅剩下透明的珊瑚虫或白色骨胳的现象。 本周讨论：当世界置身一片火海 可能很多美国大学生很迷茫，看到世界这么“乱”（疫情、气候灾难、种族主义、极端主义、不断扩大的贫富差距…），有点不知所措，所以耶鲁大学校长才会在开学典礼上做了一篇名为「当世界是一片火海（When The World Is on Fire）」的报告。 报告很好地回答了关于「年轻人求学意义何在」的问题。我觉得不光光是求学，我想结合吴军老师的解读，把这篇报告作为「做事没有动力，迷茫」的通用解，一起分享给你。 先转述下这场报告的核心思想： 苏必德先回应了学生的担忧，说世界上一片混乱，不是今天才有的事情，历史上这种情况时常发生。 他特别讲了上个世纪 60 年代，美国对越南发起的那场战争。 当时美国之外，越南战争让东南亚陷入水深火热；美国国内，民权运动和女权运动正朝着新的方向发展。整个社会处于新旧更迭的时代，忽明忽暗，谁也看不清楚未来。 在这样的变局中，当时的老师和学生也在担心耶鲁大学的未来。特别是学生们，身处瞬息万变、未知明日的环境里，开始怀疑一所大学存在的价值及意义。他们当时就想，外面的世界战火纷飞，我们在平静的环境中读书还有意义吗？我们难道不应该投身到运动中，去参与变革，去改变世界么？ 苏必德的回答是，且慢，在改变世界之前，我们需要先改变自己，在领导世界之前，我们必须先学会领导我们自身。 他举了一个他们犹太民族历史上的例子，是发生在 19 世纪的穆萨尔(Musar)运动。 当时欧洲各国反犹，许多犹太人被同化为基督教徒，犹太人的生存空间也越来越小，很多犹太人的机构开始瓦解。 犹太教教徒担心同胞们从此失去自己的信仰和生活，就开始想办法拯救日益衰落的犹太文化和犹太民族。这项运动让犹太的伦理和价值观复兴，最终让几乎所有派别的犹太人受益，尤其是当时在美国的犹太人。 苏必德认为，穆萨尔运动最终成功的原因，不是因为他们一开始就立志要领导社会、改变世界，而是因为他们先学会了如何领导自己。 这里的启示是，比改变世界更重要的是，我们要先弄清楚、弄明白自己有着什么样的价值追求，自己是否已经具备足够的知识储备。 为什么苏必德会得出这个结论呢？ 他的启发来自穆萨尔运动中的核心人物，一位犹太拉比的故事——拉比在希伯来语中，是智者、老师的意思。 一开始，这位拉比也想着要改变世界，但他失败了。他决定把目标定得小一点，先试着影响波兰的犹太人社区，没想到，也失败了。后来，他把目标聚焦在他的家乡雷丁（今天在白俄罗斯），很遗憾，也没有很成功。再往后，他把所有的精力都用在改变自己的家庭上，但还是失败了。最后，他决定只改变自己，这次他成功了，并最终成为了对世界产生重大影响的人。 因此，苏必德建议学生们，不要管外面的世界，也不要去想如何改变那个世界，先在耶鲁读好书，改变自己——因为没有比现在更好的读书机会了。 大家当然可以忧国忧民，但是，在具备这个能力之前，操心一些没用的事情，对自己、对别人都是没有帮助的。郭德纲有句话流传很广，说“有的人挣的是卖白菜的钱，操的是卖白粉的心”，这句话不好听，但这种现象其实很普遍。 要知道，范仲淹在说出“先天下之忧而忧，后天下之乐而乐”时，已经当过参知政事了，也就是宋朝的副宰相。可以说，他已经具备了忧天下的能力。 对我们普通人来讲，生逢盛世非常难得，我们做好自己的本职工作，就是在帮国家大忙。任何时候，我们操好自己该操的心，就是对社会的贡献。 最后，分享一下吴军老师解读下方最热门的一条评论： 今天的信很有启发，在我们在做某件事前先成为一个被这件事需要的人。如果我们想得到某样东西前，就先让自己有能力配得上它。比如我们想遇到好的爱人，就先要成为值得被爱的人。想要得到尊重，就先成为会尊重别人的人。想感受世界的温柔，就先成为温柔有光的人。因为，向内求永远在自己的把握之中，而向外求永远只能等待。 与人相处也一样，曾经有段时间我总想别人按我的想法去做，结果是相处得很不愉快的。后来懂得其实想要改变一个人是非常难的，越是这样甚至会适得其反。后来看书时有句话让我很受启发：改变别人是痛苦的，改变自己才是幸福的开始。与其总想着改变别人，不如先改变自己。每个人都有权利选择自己的生活，所以别将自己的手随便伸进别人的生活里。人对他人的要求越少，就会活得越自如。 热点新闻1、 苹果推出全新 M1 Pro 芯片，其 CPU 性能最高是 M1 的 1.7 倍，GPU 则最高提升 2 倍。 而 M1 MAX 更甚，图形性能堪比 RTX 3080，4 倍于 M1。 另外，苹果这次全新推出的 Mac 也放弃了“未达预期体验”的 Touchbar，而重新引入了丰富的接口，特别是 MagSafe 端口的回归。 不过引入的电脑“刘海屏”被人广为诟病，但如果你换个角度想：这相当于变向多送了你 3.5 mm 的屏幕空间。是不是就容易接受多了？ 2、 2021 年云栖大会现场，平头哥公布了最新的造芯成果：5nm、单芯 600 亿晶体管、128 核、主频 3.2 Ghz 的倚天 710，超出业内标杆 20%，能效比提高 50%，号称业内性能最强 ARM 服务器芯片，阿里第一颗为云而生的 CPU 芯片。国产牛逼🤟。 3、 Github 上有一个基于 TensorFlow.js 实现的 AI 开源项目 YoHa（Your Hand Tracking），可以实时识别手部动作，实现“空中写写画画”的功能。 虽然目前仅仅能够识别对捏手指和握拳两个指令，但 TensorFlow.js 的加持让性能一点儿都不低，来看看网友的“买家秀”： 4、 据央视新闻报道称，按照俄罗斯方面的公告，为应对新冠疫情，俄罗斯将于 10 月 30 日至 11 月 7 日全国放假。普京提到，如有必要，可以在 11 月 7 日之后延长非工作假期。 5、 10 月 17 日，科技视频博主@老师好我叫何同学，发布了新一期的视频，介绍了自制的一款名为 AirDesk 的产品。 不仅实现了任何角落自动充电、自动寻找下一个充电设备的功能，还在桌内嵌入了一台 Mac mini，让桌面变身电脑，在桌面显示待办事项、专注模式等。 最后一分钟的“带货”环节，更是在第二天让乐歌股份暴涨 13.51%，市值 5.9 亿元。🐮 PS：原视频播放已过千万，有兴趣的小伙伴可以去瞻仰一下，看完直呼太酷了吧… 文章1、做一款游戏哪最难？ 一款游戏的制作对于任何体量的团队来说，都是一件非常艰难并且庞大的工程，那么开发游戏到底哪最难呢？这个系列总共三篇文章，收录了那些来自开发团队的“吐槽”： 从一个地方移动到另一个地方； 任何东西与其他东西的互动； 讲述一个连贯的故事； 让玩家做你想让他们做的事； 保存游戏； 与其他人一起玩； 菜单和用户界面； 所有问题加在一起； 以上都是冰山一角，用文章的总结就是：开发者说哪都难！ 2、数字存储完全指南 03 ：固态硬盘的历史、结构与原理 上周分享了前两期的内容（机械硬盘原理、存储设备历史），这是最新的一期，关于固态硬盘的方方面面都挺到位的，感兴趣的朋友可以戳戳。 3、玩转 Obsidian 06：如何用渐进式总结笔记，把知识交给未来的自己 这是一个系列教你如何使用 Obsidian 进行知识管理的文章，非常硬核实用。 即使不使用 Obsidian，其中的很多观念也是值得借鉴的，比如这一篇中倡导的：把知识留给未来。 很多时候，随着时间的积累，我们保存的和收藏的很多文章、视频等内容，我们已经忘了当时的初衷。 如果换一个思路，我们考虑如何用「销售思维」去将知识「卖给」未来的自己，那么你就会想办法设计好这个产品（一个收藏 or 一篇笔记）的内容，并且你也会随时想办法去优化它。这一点很赞！ 4、如何用flomo，做好读书笔记 塑造我们的，不是我们读过多少书，而是在遗忘之后，剩余的那一小部分。所以重要的不是记录，而是如何更好地思考。 5、为什么要解决一个问题两次？设计模式让您可以将现有的解决方案应用到您的代码中（英文） 软件工程中最令人激动的问题是那些以前没有人解决过的问题。但现实是，我们面临的大部分挑战都已经得到了解决，我们可以使用现有的方案改进改善我们的代码，而这些典型解决方案，就是设计模式。 虽然老生常谈，但也时看时新。 6、JavaScript 游戏基础教程（英文） 这个英文教程一共 10 节课，教你使用 JavaScript 开发一个网页游戏。（来源：@阮一峰180期） 另外一提的是，微信小程序和抖音小程序似乎也支持 JavaScript 的方式来进行开发。 7、Java 周刊（英文） 国外开发者编写的 Java 周刊，提供各种关于 Java 技术进展的最新咨询。 8、影视内容的尽头是游戏 抛开索尼这种全能选手不谈，如今从迪士尼到 Netflix 都开始越发关注游戏业务的发展，如今几乎所有主流的娱乐形式都是技术、内容与商业模式的集合体，可以说今天的游戏行业最接近漫画在上世纪出现的黄金时代和白银时代。 如今有数据显示 68% 左右的人用超 1 倍速的速度看剧，但我们并没有听过“电影成瘾”或者“沉迷剧集”的相关概念，换个角度看，或许那些提供高度沉浸式的游戏体验（如主机游戏）才是对抗如今碎片式内容消费的终极反抗吧。 好奇星人1、中国人为什么这么爱喝热水？（视频） 热水在中国，就像仙丹一样神奇，万病皆可多喝热水，这一篇视频解答了为什么偏中国人爱喝热水的问题。 但要注意，65 度以上的热饮，是世卫组织钦定的 2A 级致癌物，长期饮用会增加患食管癌的风险。 热水虽好，可不要贪杯哦。 言论1、 游戏在社交体验方面的优势越来越大，也使得视频更难做得更好。你可能更喜欢看 Netflix 的剧集，而不是玩《使命召唤：战地》，但当你的朋友也在玩《使命召唤》的时候就不一样了（这种可能性越来越大）。梅特卡夫定律（Metcalfe’s law）对多人游戏的影响甚至比最具社会性的电视连续剧更强烈。 PS：梅特卡夫定律是说，一个网络的用户数目越多，那么整个网络和该网络内的每台电脑的价值也就越大。 –Netflix进军游戏领域，解药还是毒药？ 2、 我以前认为人工智能会取代简单重复的工作，但现在我认为相反：它将取代更多的“高级”职位，如医生、律师、教师和股票分析师。另一方面，劳动密集度更高的工作将更难被取代。我最近装修了我的房子，需要一个电工来重新布线整个客厅。我真的看不到人工智能可以在短期内取代那种工作的情况。 –刘慈欣（英文） 3、 追求稳定无可厚非，但也不要嘲笑那些创业冒险的人，前者是我们的本性，后者是社会的希望。 –考公怎么突然那么热了？ 4、 说到底，一支视频是三五百万也好，能给公司股价提升5.5亿股价也好，那也只是代表了资本市场对他的期待值，而一个青年才俊的未来，又哪里是数字可以定义的呢？ –“何同学”到底值多少钱？ 5、 幸福感的本质是什么？ 不是你拥有什么，而是你拥有的东西，跟你期望自己所拥有的东西的比值 —— 即使你客观上过得已经非常富足了，但只要你觉得「身边的人都比我更好」或是「我本来可以有更好的生活」，你的幸福感就是很低的。 这就导致了一个奇怪的现象：很多人都觉得自己不够幸福，但真正幸福的状态是什么呢？很少有人能说得清楚。似乎每个人都在望着更高处，但却永远没有一个尽头。 –你在为别人而活，还是为自己而活？ 6、 每一行代码，都是改变世界的力量。 by the way，节日快乐。 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 35 期）：首先是人，然后才是职场人","slug":"weekly35","date":"2021-10-17T01:36:00.000Z","updated":"2021-10-17T01:37:31.973Z","comments":true,"path":"2021/10/17/weekly35/","link":"","permalink":"http://www.wmyskxz.com/2021/10/17/weekly35/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 由于煤炭库存严重不足，印度全国 135 座燃煤火力发电厂面临供电危机，在一个 70% 的电力供应来自燃煤的国家，这是一个令人担忧的大问题，因为它有可能破坏印度新冠疫情后的经济复苏。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 由于煤炭库存严重不足，印度全国 135 座燃煤火力发电厂面临供电危机，在一个 70% 的电力供应来自燃煤的国家，这是一个令人担忧的大问题，因为它有可能破坏印度新冠疫情后的经济复苏。 本周讨论：首先是人，然后才是职场人（来源：《请把自己变成一家公司》@L先生说） 上一周分享了 “工作的目的是追求「合作」” 的核心观点，这一周继续分享其中的另一个观点：你首先是一个人，然后才是一个职场人。 很多人会有一种根深蒂固的思维：用自己所做的职业，来为自己贴标签，对自己下定义。比如：我是某某公司的；又比如：我是做运营/策划/产品/生意的…… 这种做法有问题吗？在进行自我介绍的时候当然没问题，它可以快速帮助对方了解你。但如果你自己对自己的定义，也局限在这个思维里面，那就未必是一件好事了。 为什么呢？原因很简单：有什么东西是能伴随你一生的？你的职业吗？当然不是。能伴随你一生的，只有你自己的能力、经验、知识、思维，只有那些真正属于你自己的东西，才不会随着外在环境的变化而变化。 许多人很容易犯的错误，就是把平台「借给」自己的资源当成是自己的资本，把自己因为平台而拥有的权力当成是自己的能力，把自己背靠平台所做成的事情当成自己的成功，把别人因为平台而对你的尊敬当成自己的光环。 但这些东西始终都是外部的，换一个位置就没有了，它们不会一直陪伴你。 真正属于你自己的，只有在这个过程中，你对各个领域的理解和经验，你做事情的「手感」，你处理问题的思考方式，你归纳、总结出来的方法论，你磨炼出来的心性，以及别人对你这个人的认可、好感和信任…… 所以，一定要明确一点： 你首先是一个人，拥有各种各样的技能和经验，然后才是你曾经做出来过的成果，然后才是你的履历和职业，然后才是你的收入方式…… 你会发现，这个思维链条是什么呢？从内部逐步向外部延伸、拓展。一定是你内部的东西决定了外部，而不是反过来。 一定不要用外部的事物来定义你。 一旦你明确了这一点，你会发现，你就不会那么容易对外界的变动而感到不知所措 —— 因为你会清楚地知道：一切行业和岗位都是暂时的，你也只是暂时地在这个位置上做事情，通过付出你的劳动来收获对应的「经验值」而已。 你需要考虑的是： 我现在做的事情，从长远来看，能够带给我什么？ 我这段履历，从长远来看，对我会有什么影响和帮助？ 我的工作成果和产出，能够如何丰富「我」这一个个体？ 换句话说，成长，永远都应该是我们考察一个岗位、一段职业生涯最重要的因素。 分享一个思维方式：你可以从这三个方面，不断去思考自己的定位： 1）我是谁？ 我对自己的定位是什么？我有过哪些能够代表自己的成果和作品？我可以如何让别人记住自己、对自己留下印象？ 2）我擅长什么？ 我做过哪些行业和岗位？我拥有什么样的技能和长处？我可以为别人提供什么价值？我希望你在需要什么服务时可以想到我？ 3）我想做什么？ 我的长远目标是什么？如果不考虑收入，我想做什么？我想成为一个什么样的人？我想在这个世界上找到一个什么样的位置？ 这三个方面，不是一蹴而就的。你可以把它们写下来，定期去思考，以及用它们来驱动自己、反思自己，看一看自己手头上在做的事情，能否进一步填补、丰富这三个问题。 只有能够使你变得更好的工作，才是有意义的。Be Better 🙏。 热点新闻1、 美国陆军协会年会亮相了一只背着半自动步枪的机械狗，射程 1200 米，可自主移动。 做机器人最出名的波士顿动力公司在合同中禁止给他们的机器人产品配备武器，但拦不住别的机器人公司这样做。 2、 卡罗莱纳州和斯坦福大学的研究人员开发了一种 3D 打印的微针疫苗贴片，只需要贴在皮肤上，就可以溶解在皮肤中，这样不仅省去了专业的疫苗冷藏和专业接种人员的成本，还可以提高疫苗接种率。 3、 现在，我们所有人都可以通过浏览器访问 Google 艺术与文化团队提供的“袖珍画廊”，去云游览观赏约翰内斯·维米尔（Johannes Vermeer）等艺术家的作品。 早在 2018 年，就推出过基于增强现实（AR）的袖珍画廊项目，只是最近 Google 宣布将其免费开放。 4、 西门子和德国铁路运营商 Deutsche Bahn (DB) 于 10 月 11 日星期一在汉堡市发布了世界上第一辆无人驾驶的全自动列车。 据悉，该列车能够多承载 30% 的乘客，并节省 30% 以上的能量。由于使用了人工智能，新列车的效率更高，这有助于列车按时行驶，并比人类驾驶员更有效地满足日益增长的旅行需求。 5、 10 月 9 日，深圳地铁站更新了宣传标语 “不躺平、不摸鱼、不划水、不内卷、不甩锅”。 文章1、公司作息表 继 996.ICU 之后，程序员的又一次“空前团结”。 记录了几乎所有中国目前互联网、科技公司，具体到每个部门的工作作息表。 甚至是精准到部门领导的性格。 另外从别处摘抄了一下上班超过 10 个小时的公司：滴滴，阿里，拼多多，字节跳动，便利蜂，vivo，幻萌，中软国际，腾讯，美团，完美世界，快手，得物，微众银行，腾讯云，百度，京东，华为，快手，小米。 2、十年创业者，万字长文分享“我”是怎么招人的 文章都是一些非常硬核“拿来主义”的经验谈，有几点“眼前一亮”的是： 要万分警惕：多数面试只问了 Skill 技能和 Knowledge 知识，没有问 Ability 软素质。软素质不行，硬技能再高也不能要，这个坑一定不能踩； Ability 软素质体现在：聪明、正直、勤奋、上进、普世价值观、逻辑、常识通识、自驱 + 有感恩之心； 3、储存设备的诞生与历史 该系列的文章可以帮助你了解世界的存储设备：基本原理、复杂的参数都是什么、如何挑选、如何更好使用和保存我们的数据； 4、机械硬盘的原理与参数详解 接上。 5、SSH 隧道（英文） SSH 典型的用例是安全地访问远程服务器，但也可以传输文件、转发本地和远程端口、挂接远程目录、重定向 GUI，甚至代理任意流量。 这一篇文章就详细地介绍 OpenSSH 支持的这些功能。 6、个人知识管理指南 flomo 官网的一篇文章。文章的末尾有一段话： 当我们离开一家公司时，我们带走了什么？是公司的 title 吗？事实上这并不是最重要的事，名声很快会过去。是工资么？除了少数拥有期权的人，你每个月获取工资的时候，你产生的价值就已经被几乎全部兑现掉（剩下的基本上会在年终奖中兑现）。 这些都不是你的资产。 我们能带走的是属于我们自己的知识。如果在离开公司之后，你写的周报，项目和知识库都留在公司里不能访问了，你还能留下些什么？ 随着年龄的增加，我们最大的资产不是金钱而是知识，未来我们能因为知识而获得更大的回报。 所以，我特别希望不论你在哪里积累知识，请为你自己也积累一份。这是个好习惯，可以伴随你一辈子。 最近频繁的在 flomo 上记录一些自己的想法还有摘抄，没有负担很轻量，去回顾的时候也比较方便。 7、我应该全面备考吗？ 一篇比较全面分析全职备考利弊的文章。 前一段时间有粉丝问我究竟应该保研本校还是应该拼一拼去更好的学校，我没有给出建议，因为我觉得建议是有上下文的。结合自身情况，深思熟虑之后好好准备就可以了。 8、教你体面和公司说再见——离职的流程和注意事项 更多的是好奇心，好奇作者是如何做到“体面”二字的，该兴趣或者有需要的朋友也可以戳一戳。 好奇星人1、CPU 究竟跑得有多快？ 下面这张 2020 年的数据统计图，具体展示了 CPU 执行关键步骤时的时间： 这图中一个小的黑方块代表 1 纳秒，一个蓝方块代表 100 纳秒，绿方块代表 10 微秒，红方快代表 1 毫秒。 但我们人类对于纳秒和毫秒的感知太弱了，我们换两种表达方式。 假设我们把耗时最小的 L1 Cache 访问时间假定为 1 秒，那么访问内存的延迟就高达 3 分钟。 从内存上读取 1MB 数据需要 5 天，从 SSD 上读取 1MB 需要 20 天，磁盘上读取 1MB 数据高达 1 年的时间。 假设物理重启时间为 2 分钟，那么这就需要 5600 年，中华文明上下五千年，也就这样一个尺度，感受下。 以上是基于时间维度，我们换一个距离维度换算试试。 假定 CPU 访问 L1 Cache 的时间我们能走 1 米，大概就是你走两步的距离。 CPU 访问内存的时间里，我们可以行走 200 米，大概是你出门去楼下便利店的距离； CPU 从内存读取 1MB 的时间里，我们可以行走 500 公里，这个距离是从北京到青岛的直线距离。 从 SSD 中读取 1MB 的时间，可以让我们行走 2000 公里，大概是从北京到深圳的距离。 从磁盘中读取 1MB 的时间，可以让我们行走 40000 公里，正好是围绕地球转一圈的距离。 而网络数据包从美国加利福尼亚到荷兰转一圈的时间，可以让我们行走 30 万公里，正好是从地球到月球的距离。 物理机重启一次的时间，可以让我们行走 1.2 亿公里，差不多是地球到火星的距离。 现在，你对 CPU 计算机运算速度有一定的感知了吧。 言论1、 好的问题集中在用户的需求和问题，以及 TA 是怎么解决它的。不好的问题，出发点都是我们自己。 如果用户抱怨说 TA 遇到了一个很烦恼的问题，但又说不出来 TA 尝试过什么办法去解决，大概率其实这不是个很刚性的需求。一个被鼻炎困扰的人，大概试过 100 多个偏方，一个说「我怎么吃都不长肉烦死了」的人，其实没有在烦恼。 –《The Mom Test》 2、 事实上时时刻刻都要保持积极进取的状态，也可能是盲目和虚假的上进心。 如果你觉得现在的方向上努力的很疲倦，或许可以听从林恩·贝格教练的建议，暂时放下时时刻刻紧绷着要努力进取的神经，去重点关注那些让你真正产生成就感和自我价值感的事情，看看在这些事情上能不能有更多的发展。 –放弃，是一段新人生的开始。 3、 我们是为用户服务的，不是为强迫症服务的。 代码能力是基本盘，但代码永远不如人重要。 –如何成为一名成熟的软件开发工程师？ 4、 不妨接受，为了获得回报，你会浪费大量的赌注；为了做出伟大的东西，你会浪费大量的时间。这时间一开始甚至都不是浪费在你的兴趣上，而是浪费在不断尝试并且确认自己的兴趣在哪里的过程中。 –你的赌注 5、 很多心灵鸡汤会把这些误读为”你一定要找到自己感兴趣的事情”，这其实很容易让人跳进火坑。从接触到感兴趣并不难，比如踢球，比如唱歌，比如写作，比如编程，很多人接触了会觉得很有兴趣。然而从爱好变成职业，就需要反复枯燥的练习并且和其他人进行竞争。如果你为一件自己仅仅是感兴趣的事情就调转了职业方向，很多时候都会感到后悔莫及。 要坚持下来真正熬出头，需要极度勤奋和高度专注，即便你的目标不是变成顶尖高手（那么大概不需要10000小时），过程也会非常苦。 但熬过就是另一番天地。 –关于工作与生活@Lenciel 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 34 期）：工作的目的","slug":"weekly34","date":"2021-10-10T01:48:00.000Z","updated":"2021-10-10T01:50:58.300Z","comments":true,"path":"2021/10/10/weekly34/","link":"","permalink":"http://www.wmyskxz.com/2021/10/10/weekly34/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 本周潘多拉文件披露近 1200 万份文件，揭示全球一些富人和权贵人士的隐藏财富、避税以及洗钱行为。 其中涉及约旦国王，阿塞拜疆执政者阿利耶夫的家族，捷克总理、肯尼亚总统肯雅塔和七名家庭成员以及英国前首相布莱尔夫妇。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 本周潘多拉文件披露近 1200 万份文件，揭示全球一些富人和权贵人士的隐藏财富、避税以及洗钱行为。 其中涉及约旦国王，阿塞拜疆执政者阿利耶夫的家族，捷克总理、肯尼亚总统肯雅塔和七名家庭成员以及英国前首相布莱尔夫妇。 本周讨论：工作的目的 最近喜欢去阅读一些“老文章”，结合公众号@L先生说的文章《请把自己变成一家公司》和自己最近的经历和思考，想要跟大家重新讨论一下“工作”这件事。 由于篇幅问题，我们只能阐述一下上述文章一个非常核心的观点：工作的目的是追求「合作」。 首先请大家想一个问题：我为什么工作？ 很多人会不假思索地回答：当然是挣钱。那挣钱的目的是什么呢？换句话说，如果你挣了足够的钱，你想要过什么样的生活？ 可能很多人的想法是，挣钱，当然是为了可以不工作——但这真的是一种理想生活吗？ 国外有一个理念，叫做 FIRE（Financial Independence, Retire Early）。也就是努力攒钱，攒够一笔足够生活的积蓄，然后早早退休，做自己想做的事情。（FIRE 生活 | 豆瓣小组） 那么，那些实现了 FIRE 的人，都去做什么了呢？每天不工作，坐吃山空，游山玩水吗？ 不是的。实际上，如果你接触过这些 FIRE 的人，你会发现，他们大多数人依然还在工作。只不过他们的工作会更加的自由，不再把高收入和高社会地位作为唯一的追求，而是会更多地考虑自己的喜好、兴趣和平衡。 所以工作的本质是什么？是自我价值和自我意义的实现，也是一个个体为这个世界创造价值的过程。借由这个过程，我们才能够明确自身所处的位置，感受到自己的存在感和意义感。因此，认为「财务自由」就意味着「不工作」，实际上是一种巨大的误解：真正「不工作」的人，其实生活是非常乏味、无趣的。 我们要摆脱的，永远不是工作本身，而是「受困于工作」这个现象。 同样，我们要追求的，也一定不是不工作，而是：我可以更加自由地从事我想做的工作，从中体会到愉悦感、成就感、意义感，而无需被逼着加班、熬夜，被强迫剥削，付出健康、生活和家庭的代价。 换句话说，这就是一种「自由度」，是让自己拥有更多选择的能力。 当你刚进入职场时，你是一名职员，是名为「公司」这台庞大机器的一环，你不得不去为了公司所要达成的目标去工作，为这个系统的运转去发光发热。这是每个人都不得不经历的必经之路。 但当你慢慢在职场中成长起来，你开始拥有足够的资源，包括能力、经验、成果、影响力……于是，你慢慢地可以用一种更加平等的姿态去跟公司对话，开始用「合作」去替代掉「工作」。 在未来，每个人可能本身就相当于一个小型的公司，通过跟别的个体或机构「合作」，来为这个世界提供价值。 最理想的状态是什么呢？你有一个目的，或者一个兴趣，而恰巧别人也有同样的目的，而你们刚好可以互补，于是你们通过合作，你提供技能、经验、思想，对方提供资源、平台，你们一起去创造出一些有意义的成果出来，共同实现双方的目标，并从中获得回报。 当然，也许对很多人来说，这还是一个愿景。但我希望，每个人都应该有这样的思维：我现在的工作，不是为了「财务自由」之后可以不再上班，而是为了可以用一种更平等的姿态，更高的自由度，去跟这个世界「合作」。（Be Better~🙏） PS：抛砖引玉，后续会进一步来探讨一下这个话题。强烈建议读一下原文章，相信会有所启发。 热点新闻1、 Stack Overflow 是国外的一家程序员问答知识分享社区，每天全球数以万记的程序员通过它复制粘贴代码来推动社会和行业的发展，如同那句名言：好的艺术家复制。伟大的艺术家偷窃。最伟大的艺术家复制，然后粘贴。 早在今年开春的时候，社区的人们就开始谋划一年一度的愚人节玩笑： 首先是在 Stack Overflow 上复制内容的时候，在右下角弹窗提示你已经没有免费的“复制额度”了，然后，如果你还想要复制，则弹出你需要购买 The Key（上面只有三个按键的键盘）的提示。 如今，这款键盘在一众网友的情愿下，真的被做出来了，定价 $29 美元，并且支持购买。 2、 美东时间 10 月 4 日上午 11:45 左右，社交平台 Facebook、Ins，以及 WhatsApp 陷入大规模瘫痪，宕机近 6 个小时，最终问题定位在 DNS（域名系统）故障。 3、 最近，Linux 基金会和在线课程平台 edX 共同发布了一份 2021 开源工作报告：远程工作成为主流，云技术的兴趣激增，这也使得 Linux 今年来首次作为非第一需求技能。 首先今年需求最高的是云容器技术，第二才是 Linux 开发和管理。 促成这一局面，不仅说明越来越多的公司受益于容器技术，也侧面反映了这一类合适的人才仍然很难被找到。 4、 Github Markdown 支持脚注了，这一最新特性有利于我们构建更加友好的文档。 5、 9 月 29 日——10 月 5 日，卡特迈国家公园一年一度的胖熊周活动如期举行，让网友们评选出最胖棕熊。 胖熊周比赛设单场淘汰赛，每场两只熊参赛 PK 人气。这期间，网友们每天可以在比赛网站选出自己心中“最肥的”、增肥速度最快的那只。每天得票最多的熊晋级，直到 10 月 5 日的 “胖熊星期二”那天参与决赛，人气最高的那只会被授予冠军。 最终，经过投票，747 号熊获得了今年的冠军。 文章1、2021 OKR 实践白皮书 飞书 OKR 团队结合市场实践和客户反馈，对于企业如何更好的落地 OKR、应用 OKR 做了深入研究，总结出了这一篇。 根据官网介绍，你可以从中了解到： OKR 为何适用于今天的组织管理 OKR 对于企业的价值 OKR 成功落地案例 OKR 最佳应用实践 2、Python 编写简单解释器（英文） 全篇一共有 19 篇文章，一步一步使用 Python 搭建了一个简单的解释器，不过使用了 Python 的一些第三方库，如果你想自己动手，这是一个不错的开始。 3、MacOS，kernel_task CPU 使用率高的原因(英文) 使用 Mac 的朋友肯定遇到过莫名其妙的 kernel_task 占用 CPU 过高的情况，如今的原因找到了：充电引起的底盘温度过高。 文章给出了一些解决方案： 将充电从左侧接口移到右侧； 从左侧拔下一些东西，直到电池充满； 使用一些软件强制风扇达到最大； 移到凉爽的房间； 4、黑客法则（英文） Github 上星标超过 18k 的仓库，收录了开发人员发现的有用的法则、理论、原则和模式。 5、JavaScript 侦测手机浏览器的五种方法 有的时候，前端页面需要知道用户使用的是手机浏览器还是桌面浏览器，这里介绍了 5 种能够知道的方法。 6、创业公司知识管理指南（英文） Notion 官方出品一篇博文，其核心论点是：无论您现在处于哪一个阶段，“知识”都是公司最大的资产。 PS：如果把个人职业生涯看做运营公司的话，你也需要“知识管理”。 7、Shyrism.News #5 好奇驱动世界 📮 Shyrism.News 是一份甄选的时事通讯，两周一期，涵盖新奇趣闻、热点议题、前沿科技以及其他关于生活、关于未来的事物。 这是该期刊的第五刊，标题是：好奇驱动世界。 8、500行代码实现自动停车（英文） 配合一个模拟网站，作者使用 300 行代码，利用遗传算法的工作原理，最终让小车自动、安全地停入了车库，感兴趣的可以了解一下。 9、我在 20 年的软件工程师生涯中学到的 20 件事（英文） 又是一篇来自“编程老兵”的经验总结，20 条经验读下来还是很受用的，特别是开头的提醒： 任何建议都是有上下文的，如果你不了解上下文，那么建议就毫无意义。 所以按作者的观点，当你身处一个小团队时，看看这些建议更有“意义”。 10、拉闸限电背后的复杂困境与逻辑 前段日子，关于双控、拉闸限电和东北某些地区的居民生活用电被停等诸多事件，混杂了生活受到影响的人民群众的不满后，事态变得更为复杂。 如果你对此感兴趣，可以看看这篇深度的解读。 好奇星人1、中国从哪里来？——地理视角（视频） 非常高质量的视频，从地理的角度系统性地解答了「中国从哪里来，将往何处去」的问题。 其中，对于「青藏高原是如何形成的」，就可以用“大碰撞”来解释： 从中国的山、水、气候自然区的形成，到动物植被的分布都做了详细的解释。感兴趣的小伙伴强烈建议戳一下视频。 PS:喜欢看文字版的也可以戳他们的公众号 言论1、 全职工作会限制我的时间，而且还会限制我所能拥有的经验。一份全职的生活会强加给我一张时间表，我所有的生活都必须围绕这张时间表。 每一个涉及时间的决定都必须优先考虑工作。这意味着实际上我的时间并不属于自己，更像是从老板那里借来的。即使他们慷慨地给予我宝贵的假期，也必须获得使用的许可。 –为何从 Google 离职？ 2、 在大厂，与聪明人在一起的重要性在于，你能够不知不觉中提高了自己的标准，提高了对成功的期望，这对于未来无论从事什么行业来说，都非常重要。 –采访 8 位谷歌前员工 3、 你可以用编程语言做几乎任何事情。但问题在于：你要做真正需要做的事情。这些事情是容易做，还是难做？ –一位热爱技术 82 岁的老太太 4、 时间空间碎片化确实能够提高学习的效率（其实也干不过电脑），而信息碎片化和知识结构碎片化带来的，则是学习效率的倒退和焦虑之源——因为他毁掉你的主动搜索能力和主动链接的能力，也就是深度思考的能力。 这就是碎片化的陷阱，极大的提高了并没有什么卵用的信息，而降低了最重要的独立思考的能力。 –《为什么越学反而越蠢？》 5、 高级开发人员正在流行“大辞职运动”，原因之一是科技公司设置荒谬的进入壁垒——即使是中小型公司。 所有公司（无论规模和薪水如何）都会让有能力的开发人员经历 4-7 场艰苦的面试； 一份可验证的业绩记录被忽略了，反而是充满形容词的简历更重要； 白板面试（抛出一个问题请你给出解决方法）测试的是解决方法的再现性，而不是对问题的实际理解； 口头面试（加上性格测试）都是程式化的，人们很难不就自己的职业生涯撒谎就能通过面试； 公司雇佣了 3 名准备在 2 年内跳槽的程序员，把巨额的技术债务留给下一个问题解决者（大多是高级开发）； 科技行业也存在严重的年龄歧视。年龄歧视的程序员是那些没有任何代表的人。他们提高声音的唯一方法就是反抗和放弃； 因此，资深且有能力的开发人员(年龄在30-45岁之间)不再希望加入其他公司，他们想开展自己的业务。 –《为什么高级开发人员正在领导伟大的辞职运动》（英文） 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 33 期）：创业者需要知道的50句话","slug":"weekly33","date":"2021-09-26T00:48:00.000Z","updated":"2021-09-26T00:49:10.223Z","comments":true,"path":"2021/09/26/weekly33/","link":"","permalink":"http://www.wmyskxz.com/2021/09/26/weekly33/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 当地时间 2021 年 9 月 20 日，美国当日开始将得克萨斯州一个边境城镇扎营的海地人空运回国，并试图阻止其他人从墨西哥越境。 这可能是美国几十年来规模最大的难民驱逐行动之一。报道称，美国驱逐了在得克萨斯州德尔里约一座桥周围扎营的 12000 多名移民。（图/视觉中国）","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 当地时间 2021 年 9 月 20 日，美国当日开始将得克萨斯州一个边境城镇扎营的海地人空运回国，并试图阻止其他人从墨西哥越境。 这可能是美国几十年来规模最大的难民驱逐行动之一。报道称，美国驱逐了在得克萨斯州德尔里约一座桥周围扎营的 12000 多名移民。（图/视觉中国） 本周讨论：创业者需要知道的50句话（来源：《未来世界的幸存者》 | 阮一峰 有一种说法是：把你自己当成公司。所以不管是创业者，还是个人，以下来自 David Cummings 的“创业经验谈” 50 条，放在一起看，确实都会让人收益。 1、只管去做。（Just do it） 2、99%的决策，都可以更改。（99% of decisions aren’t permanent） 3、招人要慎重，解雇要快速。（Be slow to hire and quick to fire） 4、工作成效必须有评估。（Measure what you manage） 5、客户比竞争对手更重要。（Competition isn’t as important as the customer） 6、95%的创业公司不应该融资。（95% of startups shouldn’t raise money） 7、加入创业者团体。（Join a startup peer group） 8、快速增长带来的最大挑战，就是如何让每个员工找到合适自己的位置。（The biggest challenge with growth is keeping everyone aligned） 9、价格战走不远，客户服务才是根本。（Price differentiation doesn’t last long but customer service does） 10、成功的最重要因素，就是选对了时机。（Market timing is the most important factor for homeruns） 11、让客户成为你的销售员。（Empower customers to help sell new customers） 12、为你的团队创造最好的工作环境。（Create the best environment you can for your team） 13、与其乱猜答案，不如提出正确的问题。（Asking good questions is more important than guessing the answer） 14、建立各种人际关系，日后会帮到你。（Build relationships before you need them） 15、开始谈判前，就做好不成功的准备。（Always consider the best alternative outcome before beginning a negotiation） 16、在经营外部业务和管理内部运作之间，正确分配时间。（Consciously balance time working in the business vs working on the business） 17、你只有一次机会，得到他人对你的第一印象。（You only get one first impression） 18、你一开始做的事情，可能不是最终让你成功的事情。（What you start out doing isn’t likely where you’ll find success） 19、搞对公司文化，一切就会井然有序。（Get the corporate culture right and everything will fall into place） 20、不要去想将来如何退出，这就是最佳退出战略。（The best exit strategy is to not need one） 21、网站最大的敌人，就是浏览器的“后退”按钮。（The biggest enemy of websites is the browser Back button） 22、经常性收入是收入的最好形式。（Recurring revenue is the best form of revenue） 23、不要过河拆桥，世界很小，你会有报应的。（Don’t burn any bridges as it is a small world） 24、建立一个针对性很强的品牌，然后围绕它把各方面都做好。（Build a niche brand and curate all aspects of it） 25、创业公司的循环往复，是健康的迹象。（Pivoting and iterating is healthy in a startup） 26、永远要求供货商提供折扣价。（Always ask for a discount） 27、不要以为，天底下只有你想到了这个主意。（Your idea isn’t unique） 28、与他人分享创意，会让你得到意料之外的好处。（Sharing your idea with others will lead to benefits you can’t predict） 29、越简单越好。（Keep it as simple as possible） 30、人们认同公司，甚于认同产品。（People identify with companies more so than products） 31、花钱请专业人员（律师、会计师等）一次把事情做对，是值得的。（It’s worth paying a professional (lawyer, accountant, etc) to do it right the first time） 32、制定一个目标，然后习惯于你得到的决策信息永远在变。（Set goals and adapt to changing information） 33、讲故事是最有力的推销手段。（Storytelling is more powerful than marketing） 34、大多数创业公司，最初为自己的产品定价时，都定得太低。（Most startups initially price their product/service too low） 35、一定要有思考的时间。（Make time to think） 36、关注公司的节奏、统计数据和优先任务。（Focus on rhythm, data, and priorities） 37、不要把你的业务说成全新模式，而要用传统行业的例子描述。（Develop offline analogies to describe your startup） 38、开公司不仅仅是为了钱。（Companies aren’t just about profits） 39、即使小小的胜利，也值得庆祝。（Celebrate the small victories） 40、你要扬长避短。（Play to your strengths） 41、不要被用户的意见左右。（Be opinionated about your product when considering customer suggestions） 42、知道自己的特点何在，然后清晰地表达出来。（Know why you’re different and clearly articulate it） 43、不要闭门造车。（Don’t develop products in a vacuum） 44、与雇员、客户、投资者和社区，保持经常性的沟通。（Regularly communicate with employees, customers, investors, and the community） 45、所有对你至关重要的人，你都要保持良好关系。（Remove friction for all stakeholders） 46、找不到决策依据，人们会自行编造。（Absent information people make up reasons） 47、人的精力有限，同一时间最多只能干三件事。（It is difficult to concentrate on more than three things at any one time） 48、你雇到什么人，决定了一切。（Employees are the most important stakeholder） 49、没有完美无缺的计划。（No plan is perfect） 50、是你“玩”创业，而不是创业“玩”你。（Consume the startup but don’t let it consume you） Be Better~🙏 热点新闻1、 中国人民银行（央行）9 月 24 日发布通知宣布，虚拟货币不具有法定货币等同的法律地位，任何虚拟货币相关的业务活动为非法活动。 通知把境外虚拟货币交易所通过互联网向中国境内居民提供服务同样视为非法的金融活动。 PS：其实中国的银行从 2013 年就开始禁止使用加密货币，但这个禁令在实际上并没有完全落实，监管部门也对比特币的挖矿和交易一直采取睁一只眼闭一只眼的态度。现在尘埃落定，已经属于“违法行为”的行列了。 2、 经典开源前端 UI 框架 Layui，官网宣布将于 2021 年 10 月 13 日关闭，但仍然会活跃在 Github 和 Gitee 平台，根据官网介绍： layui 官网将不复存在，这不是终结，只是重归到开源的纯粹中。 如果有什么想说的，官网也给了留言通道。 3、 9 月 24 日，《迪迦奥特曼》全网下架，一时间网友讨论不断。 不少网友认为，此次下架可能与此前有家长举报《迪迦奥特曼》中有暴力犯罪的镜头有关，江苏省消保委当天则表示，《迪迦奥特曼》的全网下架可能是相关平台的自主行为，与江苏省消保委没有关联。 PS：奥特曼系列只有迪迦不能播放了，同时下架的还有《刺客伍六七第一季》、《RE:从零开始的异世界》等… 4、 近期美国肯德基表示，因无骨鸡肉供应不足，决定暂时取消该产品的广告宣传。 此外以“炸鸡翅”闻名全美的快餐店 Wingstop，近日因为鸡翅大量缺货，而不得已开发新的鸡腿产品做替代。 最新数据显示，美国 8 月份禽类供应量同比减少 20%；牛肉储备同比下降 7.7%；猪胸肉储备同比减少 44%，降至 2017 年以来最低水平。 5、 据中科院消息，中科院天津工业生物技术研究所宣布在国际上首次实现了二氧化碳到淀粉的从头合成。 该技术不依赖植物光合作用，不需要大面积种地、施肥和农作物加工，原料只需二氧化碳，氢气和电，就能生成淀粉。 这一人工途径的淀粉合成速率是玉米淀粉合成速率的 8.5 倍。网友调侃：「靠西北风就能吃饱肚子要从俏皮话编程中国科学家的黑科技了」。 虽然该技术目前还属于实验室阶段，但一旦成熟并投入工业应用，将会节约 90% 以上的耕地和淡水资源，避免农药、化肥对环境的负面影响。 这是继上世纪 60 年代在世界上首次完成人工合成结晶牛胰岛素之后，中国科学家又在人工合成淀粉方面取得重大颠覆性、原创性突破。 6、 近日，来自美国西北大学研发出了史上最小人造飞行器，仅一粒沙子大小，却能搭载复杂的继承电路，是监测空气污染、空气传播疾病的理想选择。 根据对植物种子空气动力学特征的研究，最终，研究人员从三星果属植物中获得了最直接的灵感。 另外这些微型飞行器所能搭载的复杂电路，在未来还有很多想象的空间。 7、 上海首台智能采血机器人在中山医院“上岗”，它可自动完成装载采血管、采血针等全链条血液标本采集工作，7×24 小时待命。 文章1、The One Number You Need to Grow（英文） 如果增长是您的追求，那么您将无法从客户满意度或保留率的复杂测量中学到很多东西。 您只需要知道您的客户如何向他们的朋友介绍您。 PS：哈佛商业评论营销十大必读文章 2、退出社交媒体的 20 个理由（英文） 当然不是让你真的退出社交媒体，而是退一步过来反思，我们丢失的“注意力”应该在一些什么样的地方。 3、面包多 2 年小复盘：100 万用户，数千万流水以及一些碎碎念 面包多是一个为创作者牟利的平台。这是来自一线创业亲历者的复盘，感兴趣的可以读一下。 作者对于其目标人群的画像总结是： 我们所面对的创作者们，既非 B 端用户，也非 C 端用户，而是介于两者之间，他们以圈子为形态聚集，但是每个圈子又非常分散，他们有创造能力，这种能力蕴涵着巨大的商业价值，有些人对这种价值的发掘已经完成，另一些则刚刚开始，大概率，他们不会被小恩小惠打动，也不吃软磨硬泡那一套，他们有自己的文化，有自己的语言，和他们建立信任的方式，最有效的可能只有一种——让他们看到你闪光的地方。 4、如何有效的建立「个人数据库」？ 作者以三款产品为载体，详细阐述自己是如何有效建立「个人数据库」的，对于想要自己进行「知识管理」，做这样尝试的同学，这一篇文章会给你一个「可行性」相当高的答案。 5、Ghost Blog 部署指南 作为 WordPress 的有力竞争对手之一，Ghost 风格更为简约。 本文从 0 到 1，手把手搭建了一个 Ghost 博客，想要尝试的童鞋学起来。 6、详解开源许可证 无论你是准备在开发项目中使用开源代码，还是计划将自己的软件以开源方式，抑或只是下载使用开源软件的普通用户，都值得花些时间认真了解开源软件及其许可证。 7、7000 字告诉初学者 2022 Google SEO 怎么玩 本文是相对初级地介绍 Google 搜索引擎的逻辑和提高搜索结果的方法，具有一定实操性，可以帮助解决一些 SEO 方面的困惑。 好奇星人1、如何成为一只警犬 一只狗狗想要考入“公务员”，一般会考虑两个方面：1）品种；2）出身； 品种是警犬筛选的第一道门槛。过于活泼，或者太有想法，训练起来往往更困难。 在中国，最早的警犬以德国牧羊犬为主，2000 年后又有 6 个新品种加入，包括从欧美进口的 5 个品种，以及中国本土培养的昆明犬。 出身，构成筛选的第二道门槛。中国的警犬大体可分为“校招”和“社招”两类。有少数天赋异禀的小狗通过社会渠道进入体制，但大多数警犬，都来自公安部直属或省级警犬基地的“受训犬”。 以公安部直属的南昌警犬基地为例，它占地面积 200 亩，负责周边十个省区的警犬相关指导；它不仅承担繁育工作，还有专门的科研部门，产出专业成果。 基地的幼犬到了两个月大，就要开始“实习”，走上训练之路。常用的幼犬测试项目多达十几项，类别繁杂。 还有一些能力需要渐渐培养：障碍物项目中瑟瑟发抖的小德牧，需要变得勇敢起来。 分科训练后，受训犬还要经历最终的“入职”考试。 以武警某部的入警考试为例，狗狗需要一次通过对嗅觉辨识、跨越障碍、解救人质、扑咬嫌疑人等多项内容的综合测试。从训练到入职，有一点不达标的狗狗，都会被淘汰。 南京警犬研究所 13-20 年的受训犬数据显示，近两千只幼犬中，近十分之一会被淘汰。“无法衔回指定物品”这一项，就淘汰了 107 只幼犬；还有 30 只胆小狗狗，也将失去冲锋陷阵的机会。 无法“入职”的狗狗，可能会被拍卖。而成功“入职”的，训练也不能间断。 训练一只警犬，除了像这样费力，也费钱。这份深圳市公安局罗湖分局的预算显示，2021 年，罗湖分局共有警犬 30 头，平均每只犬的每年费用将近七万元。 PS：看完狗狗考“公务员”，你觉得如何？ 言论1、 我们的教育的确很“废柴”，但这不是我们成为“废柴”的原因。如果我们的学习还停留在“别人给我什么我就学什么”的被动学习阶段，那么你真的不懂怎么是学习。 我们身边有很多很多优秀的人，网上有很多优秀的文章，书店里也有很多不错的书，而且我们的软件开发日趋成熟，如果我们还学不好的话，那么我们就是在犯罪！ –《给程序员新手的一些建议》 2、 如果已正常纳税，如果已尽了应尽的社会责任，如果也没欠薪什么的，企业利润应积极投入于扩大再生产之中。为促进当前正在回落的经济和投资增长，作出自己的贡献。而这正是夯实共同富裕基础之必需。 当企业家们研究“要不要捐钱”的时间和精力，影响到了“要不要投资”的时间和精力，经济大概率将下行。这才是大问题。 –共同富裕如果错误理解势必共同贫穷 3、 有人问，为什么选择登月？为什么把这个当成目标？他们也许还会问为什么，为什么我们要登上最高的山峰，为什么要在35年前飞越大西洋，为什么莱斯大学要与德克萨斯大学进行（橄榄球）比赛？ 我们选择登月。我们选择登月……我们选择在这个十年登上月球，并完成其他的事，不是因为它们很简单，而是因为它们很困难，也是因为这个目标可以统筹和测试我们最为顶尖的技术和力量，也是因为这个挑战是我们乐于接受的，是我们不愿推迟的，是我们志在必得的，其他的挑战也是如此。 –肯尼迪 1962 年演讲《我们选择登月》 4、 迪迦第八集的原话如下： 大古：你对那个孩子做了什么？！ 怪兽：我把他的梦想拿了过来。 大古：不行！把梦想还给他，那个孩子的梦想只属于他自己！ 怪兽：小孩子不需要梦想，在他们长大之前只要像洋娃娃和玩具一样受人摆布就可以了。 大古：你把小孩子弄到哪里去了？！ 怪兽：我把他们扔到梦想的坟墓去了。我才不要大人的呢，吸了大人的梦想只会把我的肚子搞坏。 –@公众号评论 5、 对程序员来说，只要保持不断学习，这场攀爬竞赛，就有了护身的绳索。可能没办法保证你持续上升，但起码，在滑落的时候，能尽可能地，兜住⾃⼰。 –不断攀爬的程序员 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 32 期）：知识广度 vs 知识深度","slug":"weekly32","date":"2021-09-19T01:45:00.000Z","updated":"2021-09-25T06:28:12.801Z","comments":true,"path":"2021/09/19/weekly32/","link":"","permalink":"http://www.wmyskxz.com/2021/09/19/weekly32/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 Space X 已经从佛罗里达肯尼迪航天中心发射升空，将四名乘坐“灵感4”太空舱的宇航员送入轨道。 四人中有 1 名亿万富翁和 3 名“普通公民”组成，接下来的三天，他们将和这个“龙”太空舱一起围绕地球飞行。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 Space X 已经从佛罗里达肯尼迪航天中心发射升空，将四名乘坐“灵感4”太空舱的宇航员送入轨道。 四人中有 1 名亿万富翁和 3 名“普通公民”组成，接下来的三天，他们将和这个“龙”太空舱一起围绕地球飞行。 本周讨论：知识广度 vs 知识深度（本文来源：阮一峰） 国外作者画了一张图，将世界上的程序员比喻成三种形状。 大饼型：拥有知识广度，但没有知识深度。 竹竿型：拥有知识深度，但没有知识广度。 T 型：介于前两者之间。 那篇文章也认为，通常情况下，竹竿型程序员的出路最好，雇主愿意为知识深度买单。因为现代社会高度分工，越是大公司，岗位职责越明确，需要的是领域专家，而不是多面手。 但是作者提到，有一种情况例外，知识广度有明显优势，那就是确定项目路线的时候。 请看上图，右上角有一个黑点，那是公司的目标。当前位置在左下角的原点，两点之间没有现成的道路，需要自己寻找实现路径。 这时，知识广度就发挥作用了，了解的信息越广泛，知道的情况越多，就越可能具备洞察力，能够在多条路径里面，选出最合适的道路。知识面狭窄的人，由于不了解其它道路，不管遇到什么问题，可能都选择他会的那一条路，比如 Java。 这就是全能程序员的优势，判断正确的仰角 θ，使得两点之间距离最短；特长程序员的优势是前进速度 r，可以在既定道路上做到快速前进。所以，知识的广度能告诉你什么是正确的方向，知识的深度则可以让你在该方向上快速前进。 对于长期而艰巨的项目，走得快固然重要，但更重要的是走对方向。如果仰角 θ 不对，走得再快也没用，因为一开始就走错方向，后期必须停下来校正方向，甚至可能永远到达不了目标，白白浪费了生命。 因此，全能型的人才比较适合确定项目方向，担任团队领导。乔布斯、马斯克就是这样的人，强在知识的广度，而不是知识的深度。他们既懂技术，又懂市场和管理，还了解人文（”我喜欢站在人文和技术的交叉点”），一旦掌握资源，就能带领团队，做出创新的产品。但是，如果让他们担任工程师，绝对是糟糕的工程师，会被开除。 不过话说回来，现实中，谁会因为你知道的事情多，就让你担任团队领导呢？反而是因为你克服了技术难题，才有机会来领导团队。乔布斯和马斯克都是自己创业才出头的，恐怕不是偶然。 总结一下，对于公司来说，如果有明确的技术方向，那么就需要聘请特长程序员，帮助加快开发速度。如果是刚刚诞生的创业公司，方向还在摸索之中，那么全能程序员也许更有价值。 热点新闻1、 最近，英国床褥制造商 Sleepseeker，针对全球 16 个主要国家进行调查，然后公布了全球疲劳国家排名。 新加坡凭借超高的生活节奏，超过中日韩，成为全世界“最累的国家”，而中国则排名第九。 排名时主要考虑四个因素：1）民众睡眠时间；2）民众每日上网时间；3）民众平均每年工作时长；4）Google Keyword Planner中不同语言睡眠相关关键字搜寻次数； 2、 中国每年发表的科学论文数量已经超过美国。 虽然不能证明创新方面的突破，但也侧面展示了中国科研能力的提高。 3、 近日，大连理工大学研究生学生手册中的一条规定引发热议：学习期间发生未婚性行为者，给予记过以上处分。 另外从国内 20 所高校官网发现，包括浙江大学、复旦大学、华中师范大学等都有相同规定，另有多所大学对宿舍留宿异性做出禁止。 4、 9·18，不敢忘，不能忘。 5、 世界目前最大的二氧化碳捕捉工厂，最近在冰岛建成了。它通过风扇吸入空气，过滤出二氧化碳，然后再将二氧化碳液化，注入地下 1000 米深处的矿洞存储。 二氧化碳的过度排放，是气候变暖的主要原因，目前没有好的方法吸收二氧化碳。该工厂每年只能吸收 4000 吨二氧化碳，只相当于 800 多辆汽车的排放量，而全世界 2015 年的二氧化碳排放量是 360 亿吨。(@阮一峰) 6、 今天是 9 月 17 日，工信部要求各大互联网公司解除“屏蔽网址链接”的期限已至。 腾讯迈出了一大步：用户升级最新版本微信后，可以在一对一聊天场景中访问外部链接，群聊尚不支持。 文章1、全自动炒股源码 作者用 Python 写了一个全自动炒股的脚本软件，每天定时发送邮件然后手动操作。 具作者描述，他实现的策略，8 年回测，收益 715.44%，最大回撤 28%。 PS：同时 B 站也有视频，播放超 70w 2、一图流｜一张图带你看完 Apple 2021 年秋季新品发布会 最简单直观的方式迅速了解本届 Apple 新品发布会的完整动态。 3、用 CSS 设计漂亮的阴影（英文） 一篇探讨如何提高阴影品质的文章。 4、OpenJDK 17 中的 Shenandoah（英文） 本文解释了 Shenandoash GC 如何解决剩余垃圾收集暂停的问题，并在 JDK 17 中提供可靠的亚毫秒级垃圾收集暂停。 5、SQL 交互式学习网站（英文） 一个交互式的英文在线教程，一共 19 课，从零开始讲授 SQL 知识，以及如何查询数据库。 6、1985年《花花公子》采访乔布斯 1985 年乔布斯只有 29 岁，但已经被称为计算机革命之父，身家曾一度高达 5 亿美元——1985 年的 5 亿。 《花花公子》的记者在这篇采访中，谈及了以下问题（部分摘录）： 乔布斯的财富和财富观； 计算机普及的可能性； 对技术未来的展望； 乔布斯所面临的权力斗争； 乔布斯对苹果公司的愿景和价值观的解读； 苹果与IBM的市场与路线之争； …. 感兴趣的可以看看，全程高能。 7、为什么数据库不应该使用外键 外键提供的几种在更新和删除时的不同行为都可以帮助我们保证数据库中数据的一致性和引用合法性，但是外键的使用也需要数据库承担额外的开销，在大多数服务都可以水平扩容的今天，高并发场景中使用外键确实会影响服务的吞吐量上限。 PS：Draveness 大佬文章质量一直贼高，没关注的朋友建议关注一波。 8、Python 修饰器的函数式编程 关于 Python 修饰器比较详细系统的文章，对于新手也非常友好。 好奇星人1、猫为什么会用猫砂 简单来说，就是为了掩埋气味，不暴露自己的行踪。这是喵星人祖上传下来的刻在基因里的东西。 家养喵星人的祖先是生活在沙漠里的纯肉食动物，这让它们的排泄物非常“重口味”。 在摄取水分少的情况下，猫科动物让水分尽量保持在体内，所以它们排除的尿液浓度很高，味道也比较“浓郁”。 猫的粪便也是发酵后、未完全消化的高蛋白质的产物，那味道相信各位铲屎官也体会过。 因此为了不暴露行踪，大部分猫科动物都会寻找隐蔽的地方排泄，不给捕猎和逃避天地造成麻烦。 而在沙漠里，松软的沙土无疑是掩埋排泄物最好的天赐礼物。 后来喵星人足迹遍布全球，这种习惯也没有改变。 自 1937 年第一款猫砂 “Kitty litter” 诞生起，为了替代沙土，已经做了很多改良。 言论1、 你的成功多半取决于你愿意进行多少长令人不快的对话。 斩断关系，拒绝邀请，提出请求，都需要艰难的对话，而为了满足自己的诉求，这样的对话越多越好。 –最棒的人生建议 2、 Go 通常更适合那些已经知道如何编码并希望将另一种编程语言添加到他们的武器库中的人。正如 Go FAQ 报告的那样，它是根据 Google 工程师现有的问题创建的。 在运行时没有关于类型的奇怪转换，没有棘手的指针算法，没有泄漏。 –编写 Go 的乐趣（英文） 3、 工程师们喜欢把它做好；而企业家喜欢完成它。 –工程师与企业家心态（英文） 4、 如果美国当年不去起诉微软垄断，如果微软有在 Windows 上任意屏蔽程序和网站的能力，那么就不会又后来的 Google、Facebook 和 Amazon。 腾讯明明只是个信息管道，但是这个管道居然以为自己有权力控制信息内容和走向，它想太多了。 –知友@姚东 5、 首先，会带来新的流量红利。 其次，可以活跃互联网创业市场。 –当微信能打开淘宝页面，对于中国互联网意味着什么？ 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 31 期）：特斯拉是如何称霸的","slug":"weekly31","date":"2021-09-12T01:45:00.000Z","updated":"2021-09-12T08:01:31.635Z","comments":true,"path":"2021/09/12/weekly31/","link":"","permalink":"http://www.wmyskxz.com/2021/09/12/weekly31/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 2001 年 9 月 11 日的袭击改变了美国和世界历史，如今已过去 20 年，四架被劫持的飞机撞向了象征美国经济、政治和军事实力的两座标志性建筑。 该袭击造成 2996人 死亡，这是有史以来美国本土遭到的规模最大的袭击，其后果延续至今。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 2001 年 9 月 11 日的袭击改变了美国和世界历史，如今已过去 20 年，四架被劫持的飞机撞向了象征美国经济、政治和军事实力的两座标志性建筑。 该袭击造成 2996人 死亡，这是有史以来美国本土遭到的规模最大的袭击，其后果延续至今。 本周讨论：特斯拉是如何称霸的（本期来源：温义飞的急救财经） 做生意的底线到底是法律还是道德？特斯拉给出了「答案」。 特斯拉当初作为一个名不见经传的小车厂，怎么就在几年之间，突然就做成了世界上最好的自动驾驶系统，并且称为了电动车行业的霸主呢？ 先跟大家普及一下汽车行业里面一个著名的事故——福特平托案。 福特是曾经汽车行业里面最大的巨头，它曾经有一款车叫平托，销量非常好，在美国就卖了 1000 多万辆。 但是它有一个安全隐患——它的油箱很容易爆炸。 后来果然有不少人因此就被烧死了，然后就起诉了福特。 结果大家就发现，福特汽车当年在设计这个车的时候，早就知道了这个油箱会有爆炸的问题，而且是有方法解决的，只需要多安装一个零件，成本是 11 美元。 当时福特公司就算了一笔账，这车卖了 1250 万辆，如果每一台都增加一个零件，那么费用就是 1.37 亿美元； 如果不装，大概会有 180 个人因为这件事死掉，当年的赔偿金是每人 20 万美元，然后还有 180 个人受伤，受伤的赔偿金是 6.7 万美元，再加上一些修车的钱，就把这些赔偿金都赔了，一共才 4000 万元。 装需要花 1.37 亿，不装才花 4000 万，那就不装了。这样看起来很残酷，但这就是一个标准的商业决策。 你说它违背道德吗？近 200 条人命的大事，为了省点钱就让它这样发生了，这何止是违背道德，简直就是草菅人命。 但是你说它违背法律吗？如果他们不公开自己有过这样的研究，那它就是一个设计缺陷，出了事福特也认赔，该赔多少赔多少，态度也很不错。 你说哪辆车的设计是绝对完美的，难道造车有缺陷也犯法吗？ 其实不光是企业，再告诉你一个数据，美国交通部给一条人的人命定价是 900 万美元左右，安装红绿灯的成本大概是 1 万多美元，所以一个路口装不装红绿灯，就要看它降低的死亡率能不能覆盖成本。 我们说回特斯拉，当年特斯拉的无人驾驶系统，刚刚开发出来的时候还很不成熟，实际上到今天也没有完全成熟，何况五六年前。 那它是怎么敢开放给用户使用的呢？ 因为技术的发展，特别是算法的迭代升级，是需要大量的数据作为基础的。 在实验室里面，你根本还原不了真实世界那么多复杂的路况，也不可能有那么大的数据量供你去升级研究。 所以多年之前，第一批特斯拉的用户，就是小白鼠。 奔驰宝马，难道不想得到这样的数据吗？它们也想，但它们有很重的历史包袱。 你想想，如果奔驰贸然安装了无人驾驶系统，死了好几个人，奔驰的总经理肯定负不起这个责任，他只能辞职。 但是特斯拉那个时候什么也不是，赢了它就是一场逆袭，输了也很正常。创业公司本来就是 100 家里面死 99 家。 其实不光是无人驾驶，特斯拉到现在为止都敢上别人不敢上的技术，因为它一直是行业的探索者，很多事它就是第一个干，干之前真不知道能不能行。 比如取消 PTC，还有改用电机堵转发热替代技术等。 作为一个产品，你让我买肯定得掂量掂量，毕竟很多人因为它的缺陷而丧命，这是人命关天的大事。 但是从商业的角度看，它后来确实也因此成功了。 热点新闻1、 9 月 5 日第 16 届夏季残奥会闭幕式在东京如期举行，中国队以 96 金 60 银 51 铜收官，连续五届残奥会金牌榜、奖牌榜双第一。 2、 为进一步鼓励香港市民积极接种新冠疫苗，香港举行打疫苗送千万豪宅活动，一 80 后接种者获奖。 3、 北京时间 9 月 8 日，墨西哥发生 7.1 级地震，天空出现诡异蓝光，截至目前死亡人数为 1 人。 4、 据微博大V @巍岳钦禹 爆料，腾讯视频海外版播放的扫黑风暴，是没有超前点播的，也就是说买一次 VIP 就行，不用再额外花钱，也不存在“会员专属广告”。 此外，他还表示，腾讯锁了中国 IP，中国用户在腾讯视频海外版上搜不到扫黑风暴剧集。实属“吃相难看”。 5、 能够看到密闭的房间内，曾经是超级英雄的技能。但是斯坦福计算成像实验室的研究人员已经扩展了一种称为非视距成像的技术，这样进入房间的单个激光点就可以用来查看里面可能有什么物理物体。 简单来说，就是可以通过钥匙孔发射的单个激光可以暴露房间内的一切。 6、 SpaceX 公司预定在下周三（9月15日），发射一艘宇宙飞船，四名宇航员全部都是平民。这是历史上第一次“平民宇航员”的宇宙飞行，为将来的太空旅游做尝试。 这四名乘客此前没有任何宇航经验，他们将在太空停留三天。这与贝佐斯今年 7 月份仅仅持续 50 分钟的”飞出大气层”之旅完全不一样，更接近真正意义上的”太空旅游”。 7、 最近，有一款游戏刷屏全网，它叫做人生重开模拟器，简单的选选“天赋卡”，分配分配点数，就能够体验到“人生无常”。 短短 3 天就超 2 亿访问量，并且开发者表示打算最近出一款手游。 文章1、《C 语言入门教程》 阮一峰大大的新作。 2、产生随机数背后的原理（英文） 计算机生成随机数比你想象中要复杂得多，主要有两种算法，其中一种开发者朋友应该比较熟悉，是基于上一个答案生成下一个答案的伪随机算法，这也是为什么 random() 函数需要种子的原因（上图）。 3、“中国邮政为啥还不倒闭？” 中国邮政的身影似乎逐渐消失在年轻人的视野，因为我们嫌它慢。但大家可能有所不知，中国邮政的主要服务对象，可能并不是居住在城市里的我们，而是每一个中国人。 中国邮政默默地为中国做的那些事，值得让大家知道。 4、Python Pands 操作指南（英文） Pandas 是一个用于分析、数据处理和数据科学的 Python 库，这里是面相初学者完整的操作指南合集。 5、理解 CSS 中的百分比（英文） 如果你还没有理解 CSS 中的百分比是如何工作的，可以来看看这位老哥的“研究”。 6、快写鸭一站式写作工具 「快写鸭」是一款专为开发者开发的一站式写作、管理、发布的更简单且下载即用的效率工具，Github 上有开源代码。 7、美团公开外卖配送算法规则 美团计算预估时间的模型有四个： 在这四个时间中，美团表示“因为担心模型预估时间与现实情况不符”，所以为了减轻骑手的配送压力，会从中选择一个最长时间。 除此之外，还额外有两条补充算法： 考虑到骑手从接单到送达的整个过程中可能会遇到多种突发状况，会有“在异常场景下为骑手提供时间补充”； 如骑手遇到远距离、单量多等情况，“将‘预估到达时间’变为‘预估到达时间段’”； 这一举动引发网友好评，“透明也是一种力量”。 好奇星人1、那些长期喝咖啡的人，后来都怎么样了？ PS：因为实属精品文章，所以摘选内容较多 咖啡是不是对身体不好？一天喝多少咖啡才算多？ 在回答问题之前，先说一说为什么你会用咖啡续命。 在你的大脑中枢神经系统中，有一种叫腺苷的东西，它是让人产生睡意的“始作俑者”之一。 腺苷和腺苷受体结合，让你肌肉放松，变得瞌睡。运动越多、用脑越多，腺苷产生的量就越多，这也是你一看书就想睡觉的原因。 而咖啡提神的原理，是咖啡因插足当了第三者，抢在腺苷前面，跟受体结合，阻止你产生睡意，强行让你支棱起来。 我们常常听说喝咖啡对身体不好，要少喝一点。这倒也不是空穴来风。20 世纪 80 年代，很多研究表明咖啡对身体有害。 但是后来学者发现，类似的研究存在缺陷，喜欢喝咖啡的人通常也爱抽烟，研究并没有把这两种习惯分割开来，导致抽烟造成的锅，扣在了咖啡的头上。 而现在，科学界几乎已经达成共识，适量的咖啡不仅对身体没有害处，甚至还能降低死亡率，抵御各种疾病。 一项对 40 万 50－71 岁中老年人的研究发现，每天喝三杯以上咖啡的人，男性死亡率比不喝咖啡的低 10％，女性低 13％。 在针对 18.5 万美国非裔、本土夏威夷人、日本裔、拉丁裔和白人的研究中，每天喝两三杯咖啡的人，死亡率比不喝咖啡的人低 18％。 还有各种论文表明咖啡可以降低中风、帕金森症等慢性病的患病风险。 但问题是，每天喝多少咖啡，才不算过量呢？目前科学并不能给出统一而精确的剂量。 比如 2019 年的一项研究发现，每天喝 1－2 两杯咖啡的人最不容易得心血管疾病，其次是少于 1 杯、3－4 杯和 5－6 杯的人，但如果每天喝 6 杯以上咖啡，得心血管疾病的概率就会陡增 22％。 美国食品药品监督管理局建议，成年人每天摄入的咖啡因最好不超过 400 毫克。 这是个什么概念？一杯 240 毫升左右的咖啡，约含 80－100 毫克的咖啡因，也就是一天不超过四五杯。 一杯同样容量的普通绿茶或红茶，咖啡因含量在 30－50 毫克左右，够你喝上十杯。 言论1、 我认为让你进入编程的是解决问题的挑战。挑战不应该来自学习新技术，而是来自解决深层问题。有了更多的时间，就可以更轻松地使用新算法和让用户感到惊讶的深层功能来解决领域中的具有挑战性的问题，而不是像将数据从表单存储在数据库中这样的浅层功能。 –斯蒂芬·施密特 2、 我们的结果表明，转向全公司范围的远程工作会导致协作网络变得更加孤立——跨越正式业务部门或微软非正式协作网络中的结构漏洞的联系更少——并且这些孤岛变得更加紧密相连。此外，网络变得更加静态，每月添加和删除的关系更少。 我们预计，我们观察到的对员工协作和沟通模式的影响将影响生产力，从长远来看，还会影响创新。 –《远程工作对信息工作者之间协作的影响》（英文） 3、 无论一个游戏的包装如何，只要游戏的核心足够有趣，这个游戏就是一个成功的游戏。 这不是玩法的创新问题，这是对游戏制作的态度问题。这个人生重来的玩法不是独创，无非是把赛马娘的一整套养成换成了最简单的文字，但是每一条成长词条都是用心写的，看得出来作者却不仅仅是为了做游戏而做游戏，他通过制作自己的游戏得到了快乐，这是把游戏当作游戏，而不是像国内的很多厂商一样把游戏当作赚钱的工具。 –知友 @五只羊 4、 事实上 React 现在就是用上一堆手动优化也还不如 Vue 3 或者 Svelte 默认无优化的性能，反而因为显式的手动优化让用户获得了性能提升的心理感受，真是高。 –尤雨溪 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 30 期）：软件公司的两种管理方式","slug":"weekly30","date":"2021-09-05T01:45:00.000Z","updated":"2021-09-12T08:00:41.031Z","comments":true,"path":"2021/09/05/weekly30/","link":"","permalink":"http://www.wmyskxz.com/2021/09/05/weekly30/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 德国柏林各大学食堂因气候原因，将从下学期起改以供应纯素食和素食为主的“气候友好型”的餐单（68% 纯素食，28% 素食，以及 4% 的肉类和鱼类），并期望以此来减少碳排放。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 德国柏林各大学食堂因气候原因，将从下学期起改以供应纯素食和素食为主的“气候友好型”的餐单（68% 纯素食，28% 素食，以及 4% 的肉类和鱼类），并期望以此来减少碳排放。 本周讨论：软件公司的两种管理方式（文章来源：酷壳 - CoolShell） 总体来说，这个世界上存在两种不同的软件公司的组织结构。一种是 Widget Factory（小商品工厂），另一种是 Film Crews（电影工作组）。 Widget Factories 想要去解决怎么去激发被 X 理论所影响的人。 X 理论是说，一般人的本性是懒惰的，工作越少越好，可能的话会逃避工作，大部分人对集体（公司，机构，单位或组织等）的目标不关心，因此管理者需要以强迫，威胁处罚，指导，金钱利益等诱因激发人们的工作源动力。 于是，经理总是要去做他下属的工作。 基于这种前提下所思考出来的管理方式，很自然的就是——整个团队能够容易地被经理一个人所取代，这种团队中的每一个人都很容易被别人取代，在这种团队里，经理的工作能力不断地被加强。因此，这种公司一般使用树形层级的组织结构，而不是水平式的工作角色。 Widget Factory 管理体系运作于软件需求的某种假设，就需要项目管理者提前定义一个非常明确的“软件说明书”。 一个 Widget Factory 的公司的管理可以通过观察这个公司员工的谈话方式识别出来。他们很喜欢谈论： Resource 资源（包括干活的人也叫做resource； Process 流程； Operating efficiency 运作效率； Uniformity 一致性； Repeatability 可重复性； 严格地控制对资源的使用，鲜明的工作角色和鲜明的流程定义（inputs 和 outputs）。他们对实实在在的软件开发漠不关心，他们想要把理想中的软件开发运作变成他们看得见的图画。 另一种是管理方式是 Film Crews 。 这种公司认为人是有相当高的智力和创造力的，是自己可以激发自己的，人们努力工作，并且可以享受工作，就像孩子喜欢玩一样。 Film Crews 认为，每一个个体的自已专业能力，要远远优于那种被组织和协调出来的能力。 因为经理不再代替每一个人，而树形的层次架构也不能很好的运作——人们不得不以比较复杂和形式合作才能把事搞定。工作职责变得非常地垂直——你需要具有从上到下的而比较宽泛的各种能力，这种管理也就是基于 McGregor 的 Y 理论。 对于一个拍摄组的导演来说，他需要了解把一个伟大的软件组合起来的每一个碎片，他需要组织一个无与伦比的团队，并且要帮助这个团队能凝聚在一起，团结在一起工作。他的角色是鼓舞大家，守护着构想（Vision），提供方向和集中大家的精力。 当我们用报酬来表示的话： Widget Factories 认为，有价值的东西总是从 PM 和 BA 派生出来的，所以他们常驻在管理层的上面，也有相应的报酬，而对于软件团队，只要他们正确地把需求变成可工作的代码后，软件团队就变得无所谓了； Film Crew 更主张的是平等的工作职能，每个成员都可以不受限制地获得主要的和原始的信息，其鼓励所有人形成自己的价值判断，并且可以自由地选择不同的方式来达到团队的构想，报酬折射出这个人是怎么在这个项目中工作的，需要明白这个人为我们的软件创造了多大的价值和产生了怎么样的结果； 今天，我们也一点也不奇怪大多数公司的软件开发团队和一些咨询工作运行于 Widget Factories，在这种情况下，管理上来说，PM 和 BA 要被程序员挣得更多，这是基本一种他们可以创造更多价值的假设。 在这种组强架构和管理里，程序员们很难证明管理是错误的。 成功的软件公司都会趋于采用 Film Crew 的方式，任何其它的东西都会妨碍他们吸引牛人的能力，因为只有吸引了牛人，你才能创造出伟大的软件。 在这种公司里，一个好的程序员的收入会高过 BA 和 PM 很多。 你的公司属于哪一种呢？ 热点新闻1、 8 月 30 日，国家新闻出版署关于进一步严格管理，切实防止未成年人沉迷网络游戏的通知，其中包括： 9 月 1 日起，所有网络游戏企业仅可在周五、周六、周日和法定节假日每日 20 时至 21 时向未成年人提供 1 小时网络游戏服务，其他时间均不得以任何形式向未成年人提供网络游戏服务。 这意味着未成年人的每周游戏时间不会超过 3 个小时。 2、 8 月 30 日，教育部发布《通知》（简称）：小学教育不得以任何名义设置重点班、小学一二年级不进行纸笔考试。 3、 8 月 31 日，是字节跳动取消大小周后的第一个发薪日，员工薪资普遍降低了 17%。 大小周意味着每个月需要加班两天，而这两天都有双倍工资，就意味着员工可以多拿到 4 天工资。一个月的工作日有 22 天，减少了 4 天，意味着工资减少了近 20%。 有人吐槽：“双休瞬间不香了”，因为这意味着员工不加班将损失一笔不小的资金。 4、 据央视财经《中国美好生活大调查》显示，中国人每日平均休闲时间是 2.82 小时，其中每日休闲时间为 1-3 小时的人最多，占比近四成。 调查还发现，“撸铁”成国人休闲最爱。 5、 最近复旦大学团队以柔性电子材料打造的可充电衣物登上 Nature，半年前，他们才刚打造“衣物显示器”。 这双剑合璧，直接把能源问题给解决，还真有“科幻大片”那味儿了。 其中的关键就是纤维锂离子电池，将其同普通纺织物织到一起，手机平板都能充电。 折叠、水洗也都没啥影响，安全性也有保证，遭受外力的情况下，依然能保持稳定。 此外，这一衣服电池在 500 次充放电循环之后，容量保持率能达到 90.5%，库仑效率为 99.8%，成本还很低，每米成本略低于 0.05 美元（约合 0.3 元人民币）。 6、 谷歌发布最新“视频扣图术”，不仅使用简单，还能大力助力“UP 主”的视频剪辑。 比如复制或删除图像： 顺滑切换背景： 还可以实现这一经典操作，让原本依次掉水的小孩一起入水~ 7、 东京大学和密歇根大学的研究人员发明了这样一个无线充电室，可以提供 50W 的传输功率，成功为屋内的手机、电台灯和小风扇充上了电。 该充电室和市面上的无线充电设备第一个区别：可以任意位置充！ 虽然小米今年提出了一个真正的无线充电桩，但它的功率只有 5W，相比起来无线充电室的另一个优势是能提供 50W 的功率。 文章1、如何有效地学习（英文） 比较系统性介绍学习的文章，对于如何做这里提炼了几点要素： 把学习时间分配到更多的较短课程中，而不是塞进一个马拉松课程中； 当您学习可能容易混淆的类似主题时，最好交替学习； 专注于构建自己对主题的理解，而不是复制别人的； 您应该将自我测试视为学习的一个组成部分。一种方法是阅读、背诵和复习 (3R) 方法：阅读一段文本，当您尝试用自己的话回忆其内容时将其放在一边，然后检查您的回忆，必要时重复； 避免默认采用习惯性、被动的学习方法，例如重读和突出来源。这些没有利用记忆的重建性质，使其更乏味和效率更低。 2、完整的 GraphQL 安全指南（英文） GraphQL 正在崛起，称为 API 生态系统中的重要参与者。这篇文章讨论了如何使您的 GraphQL API 更安全并为生产做好准备（修复 13 个常见漏洞）。 3、《资本之后的世界》（英文） 美国一位风险投资家撰写的工业时代→知识时代的“指南书”，很有指导意义，摘录开头： 技术进步已经改变了人类的稀缺性。当我们觅食时，食物稀缺。在农业时代，它是土地。工业革命之后，资本变得稀缺。随着数字技术的出现，稀缺性再次发生转变。我们需要弄清楚如何在资本之后的世界中生活，在那里唯一稀缺的是我们的注意力。 4、漫画 | 为什么中国没有搞出浏览器引擎？ 一是回顾这些浏览器引擎的发展历史，发现我们已经错过了浏览器开发的这一波浪潮；二是讲述了浏览器引擎的发展路线和当前的三大引擎缘起。 5、为什么 Linux 不需要碎片整理（英文） 介绍了碎片为什么产生，以及 Linux 的文件系统是如何更加“智能”地解决碎片问题。 6、芯片短缺越来越严重，为什么我们不能做更多？（英文） 简单的答案是，制造芯片非常困难，而且越来越难。而对于「为什么难」这个问题，文章做了生动详细的图文介绍。 7、掌握 Python 中的网页抓取：从头开始抓取（英文） 使用 Python 爬取网页的“保姆级”入门教程。 8、个人信息整理术：用 Notion 搭建我的「每日看板」 作者分享了如何使用 Notion 管理自己的各类信息的心得，对于期望这一类尝试的小伙伴是一篇不错的分享。 不过这一类软件的重点还是：先使用起来！ 好奇星人1、狗狗一见面，为什么会先“闻屁股”？ 不管是什么类型的狗，两只相遇，总会发生一个奇特的现象：就是这些狗总喜欢互相闻对方的屁股。 这其实是为了获取对方的信息，与对方打招呼，进行交流。 狗的嗅觉超级灵敏，能从气味中分辨出许许多多种信息。根据科学家的研究，狗鼻腔中用来捕捉各种气味分子的器官——嗅上皮，总面积为 170 平方厘米，是人类的 17 倍。 嗅上皮的面积越大，其嗅觉细胞也越多，能够分辨的气味也就更多、灵敏度也就更强。而且同样的面积下，狗的嗅觉细胞是人类嗅觉细胞密度的 100 倍。综合而言，狗的嗅觉灵敏度是人类的上千倍。而且研究显示，狗鼻子大约能辨别 200 万种不同的气味。 每种动物对臭味的理解也并不完全相同，狗狗闻对方的屁股，可能并不觉得臭。狗的屁股处有一种器官叫做肛门腺，可以分泌信息素。 狗狗闻屁股的这一行为主要就是通过气味来识别对方的身份信息，比如：性别、年龄、最近吃的啥、健康程度咋样等等。 “老熟狗”之间就不会闻屁股了。 此外，狗狗们在闻对方屁股之前，还会先竖起尾巴示好，告诉对方，自己很友善，不会有什么恶意。 任何动物都有自己的交流语言，只是它们没有形成像人这样复杂的交流方式。自然界当中的动物们主要通过肢体、气味、声音等进行交流，而狗主要是通过尾巴和气味进行交流的。 言论1、 如果你想致富，你会怎么做？我认为你最好的选择是开始或加入一家初创公司。数百年来，这一直是致富的可靠方式。 –《如何创造财富》，by：保罗·格雷厄姆（《黑客与画家》作者）（英文） 2、 1）这种竞争导致一种非常高度的整合能力，就把所有的人都统一思想，所有的人一起消耗精力和生命，也不想别的，让大家就是这么的忙碌着。 2）我们今天讲的内卷的一个很重要的前提条件是不分化，大家认准一个目标，为同一个唯一的目标活着。否则的话，如果你在职场不高兴，你去干点别的，开个面馆不行吗？不可以，大家一定要挤在一个道上。 3）但是在生存方面是不竞争的，这里的安排是比较复杂的。比如每个人的守猎能力有高低，比如你能够打到一只鹿，大家在声望上都会认可你的，赞扬你的勇敢以及打猎技巧，但是肉是一定要平均分配的。中国的情况是，现在像这样的分化没有了，通通就是要竞争。 4）我们最大的问题是末班车过了，但是我们又不愿意开出新的小道来。 5）所谓内卷性不仅仅是说竞争激烈不激烈的问题，而是说白竞争，明明知道最后的收获也没有什么，大家还是要竞争。不知道除了竞争之外，还有别的什么方式值得去生活。如果你退出竞争的话，你有道德压力。 –专访｜人类学家项飙谈内卷：一种不允许失败和退出的竞争 PS：关于“内卷”比较有深度的一篇文章，这里只是其中一部分摘录。 3、 Kafka 是一个非常好的、强大的工具，当它真正需要时，大多数公司在首先使用时应该三思而后行。这相当于用锤子杀死苍蝇——或者，在这种情况下，通过定制的开放区域跟踪苍蝇的气压。 –《你不需要 Kafka》（英文） 4、 借助表情包、梗、流行语、省略语的表达，不是你在说话，而是「话」在说你，未经你的思考和语言生成，梗借助你的指尖和嘴把自己说了出来，你不过是那些梗的通道。久而久之，你的文字表达能力便被梗塞住了，成为「语梗」患者，也就是文字失语，失去自如地用文字表达想法的能力。 –《拿什么拯救被「梗」住的「文字失语者」》 5、 这件事说明什么？说明像加班费这种带有不确定性因素的钱，不要试图和带有确定因素的工资产生联系。以后，和公司谈薪水的时候，要谈确定性的工资。 那些带有不确定因素的福利政策看似很诱人，很具有诱惑性，如果你把它们当成你钱包里的一份子，就是自己在欺骗自己，当你习惯了之后，上述政策一旦变化，吃亏的只有是你自己。 –@非著名程序员 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 29 期）：技术人员的发展之路","slug":"weekly29","date":"2021-08-29T00:50:00.000Z","updated":"2021-08-29T00:54:56.504Z","comments":true,"path":"2021/08/29/weekly29/","link":"","permalink":"http://www.wmyskxz.com/2021/08/29/weekly29/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 联合国称，位于非洲东海岸的岛国马达加斯加正处于现代历史上全球第一次“由气候变化引发的饥荒”的边缘。在部分地区连续四年没有降雨的情况下，成千上万的人正面临“灾难性”的饥荒和粮食风险。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 联合国称，位于非洲东海岸的岛国马达加斯加正处于现代历史上全球第一次“由气候变化引发的饥荒”的边缘。在部分地区连续四年没有降雨的情况下，成千上万的人正面临“灾难性”的饥荒和粮食风险。 本周讨论：技术人员的发展之路 左耳朵耗子（陈皓），在 2016 年底分享了一篇基于自身经历和思考的文章，详细论述了一个技术人员的发展道路，我觉得很受益，特此分享一下。 以下正文（略作精简和修改）： 20-30 岁是人生的重要阶段，这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。 高效的学习能力。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。 解决问题的能力。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。 如果你拥有这两个能力的现象是—— 在团队或身边的人群中的显现出 Leadership。 Leadership 并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象： 帮人解问题。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？ 被人所依赖。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。 一但你在 30 岁之间出现了 Leadership 这样的特征，那么，你会进入一个正循环的阶段： 因为你学习能力强，所以，你会有更多的机会解决难题。 你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。 上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。 显现出 Leadership，那么你才谈得上个人发展，后续的内容也可能才会对你有意义。 总体来说，发展有三大方向（它们之间可能会有重叠）： 去职场中打拼 → 1）到真正的技术公司成为一个专心做技术的人；2）成为一个职业的经理人； 去经历有意义有价值的事 → 单从技术角度：1)到技术创新的发源地去经历创新；2)去经历下一个热点技术的发展； 追求一种自由的生活 → 1）第一层：工作自由；2）第二层：技能自由；3）第三层：物质自由； 无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。 他们都有重叠，比如： 你可以在职场中去追求那些刺激的经历的公司。 同样也可以通过加入有潜力高速发展的公司来达到自由。 你也可以通过追寻不一样的经历来达到人生的自由。 …… 总之，这里的逻辑是—— 能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人。 有很多机会和可能性的人，通常都是有 Leadership，喜欢冒险的人。 有 Leadership 喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。 学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。 懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的 KPI、奖金和晋升。 最后，祝大家都能走在自己想去的路上，Be Better~🙏 热点新闻1、 今年 9 月 1 日开始，公安部在全国 28 个城市，全面推行电子驾照，效力与纸质驾照完全相同。电子驾照通过 “交管12123” APP发放，领取后只要携带手机，就不需要携带纸质驾照了。 电子驾照下方还有实时生成的二维码和条形码信息，交警通过扫描二维码，能够快速获取车主的身份证信息和车辆登记信息。 2、 2020 年，我国总生育率为 1.3，低于国际警戒线 1.5，生养教成本高系主要因素。 3、 近日，最高人民法院与人力资源和社会保障部明确了 996 属于严重违法。 用人单位制定违反法律规定的加班制度，在劳动合同中与劳动者约定违反法律规定的加班条款，均应认定为无效。 这意味着如果拒绝上述无效加班安排，应被视为维护自己合法权益，不能据此认定其在试用期间被证明不符合录用条件。 PS：生育率面前的“老虎”，国家要一个一个除。 4、 微信儿童手表版上线，画风以黄色为基调，非常可爱活泼。 5、 8 月 27 日，中国互联网网络中心发布了第 48 次《中国互联网络发展状况统计报告》。 报告显示，截止 2021 年 6 月，我国网民规模达 10.11 亿，较 2020 年 12 月增长 2175 万，互联网普及率达 71.6%。 我国网上外卖用户规模达 4.69 亿，较 2020 年 12 月增长 4976 万。 PS：更多详情戳报告~ 6、 东京残奥会开幕式发出“改变世界”呼声的当天，日本政府和东京电力公司就迈出了“改变世界”的惊人一步。 日本放送协会 24 日报道，日本政府和东京电力公司已基本敲定，将用大量海水稀释福岛核污染水，再通过修建海底隧道，把核污染水引流到距海岸 1 公里附近的海中排出。 此举到底是稀释核污染水，还是更方便扩散核污染水？ 文章1、为什么超链接是蓝色的？（英文） 互联网如今已经进入我们生活的方方面面，那么多的超链接，为什么是蓝色的呢？ 该文章从互联网的历史发展角度，深度解读了这样做的原因。 2、我使用联想 THINKPAD 笔记本电脑的 7 个原因（英文） 国外一位老哥讲述了自己坚持使用 THIINKPAD 笔记本的原因，大概以下几点： 1）优秀的 Linux 支持；2）用户可修复；3）机身结实；4）键盘舒服；5）小红点；6）便宜；7）接口丰富； 其实以前一直不知道 THINKPAD 的优势在什么地方，看完有些恍然大悟了。 3、软件危机 2.0（英文） 大佬从第一次软件危机一路分析到现在，讨论了软件开发中的各种问题以及解决方案，内容非常扎实。 PS：这篇文章可以不看，但是大佬的博客质量都很高，建议收藏。 4、左耳朵耗子：从“打工人”到技术创业者，我是如何作死的 大佬左耳朵耗子的经历故事。 5、如何动手做出一个 CPU 对于技术类的小伙伴来说，自己动手搭建一个 CPU 有点不敢想象，但作者利用闲暇时间真的弄出来一个，而且里面还有保姆级教学。 6、软件开发中的时区问题 对于国际化的软件系统来说，时区是需要特别关注的，那些对应需要关注和注意的点，文章都一一列举了出来。 7、为什么 TCP 协议有性能问题 TCP 协议可以说是今天互联网的基石，作为可靠的传输协议，在今天几乎所有的数据都会通过 TCP 协议传输，然而 TCP 在设计之初没有考虑到现今复杂的网络环境，当你在地铁上或者火车上被断断续续的网络折磨时，你可能都不知道这一切可能都是 TCP 协议造成的。 本文分析了 TCP 协议为什么在弱网环境下有严重的性能问题。 8、边缘人的力量 这是美国最著名的创投公司 Y ZCombinator 创始人保罗·格雷厄姆（Paul Graham）在 2006 年写的一篇文章 The Power of the Marginal，如今看，仍然受益匪浅。 文中讲述了两种人：边缘人和精英人士，以及他们为什么走上了完全不同的道路。 PS：我读了 5 遍，本来想选作本期讨论，但由于实在不知道怎么缩小篇幅，就选作了文章，强烈建议阅读！ 好奇星人1、猫为什么不能拒绝猫薄荷? 无论大小，无论高冷与否，有一样东西是许多猫咪无法抗拒的，那就是猫薄荷，可是为什么呢？ 其实猫薄荷不是猫喜欢的唯一植物，还有银藤，这两种植物至少会让猫咪发呆。 是因为它们其中都存在着一种生化分子——荆芥内酯。 现在这种东西经常被添加到驱虫剂中，因为它有很好的驱蚊效果，这也就是猫咪喜欢靠近这两种植物的原因——它可以保护猫咪免受蚊子和其他寄生虫的伤害。 “趋利避害”在自然选择中起作用，猫咪进化到喜欢猫薄荷的本能。 另外，当猫对猫薄荷和银藤做出反应时，一个控制强烈快乐的奖励机制的奖赏通道(被称作μ-阿片类系统)被激活，这是让猫咪欲罢不能的生理原因。这就像我们刷短视频根本停不下来一样，因为刷短视频的过程也激活了我们大脑的奖励机制。 猫薄荷经常被形容为“猫界大麻”，所以很多猫主人担心它会影响猫，或者猫是否会上瘾。但 2012 年就已经辟谣了，虽然猫薄荷和银藤会对猫产生积极的反应，但它们不会让猫上瘾。 这其实只是一种进化机制，和它们抓到一只耗子玩上半小时对大脑的影响差不多。 言论1、 所谓“内卷”，指的是增加工作时间却不能增加产出。那么，对抗它的方式，自然是在不增加工作时间，甚至是减少工作时间的情况下，增加产出。我想，停下来好好思索自己从每一个选择当中获得的是什么，就是重要的第一步。 –疫情让大家更“卷”了，不如停下来想一想 2、 我发现了这样一个规律，那些不用微信的人，大多是中年人——这个年龄，意味着他们已经在自己所在的领域做出了一些成绩，是颇有话语权的人，唯有如此，他们才掌握了说「不」的权利。 –人物《不用微信的人》 3、 个人一样需要向外发展，而不是一味地向内求索。个人也要和外部世界同步，寻求创新发展和局面突破，而不是追求一劳永逸的生活，人必须要在发展中获得动态满足，人不可能有长久的安逸。 –“内卷”到底是什么意思？如何突破“内卷”？ 4、 Linus 表示，只有在创建了 Git 之后，他才觉得自己是一个成功的程序员。因为在那之后，他再也不需要担心 Linux 只是个一次性产物。 –Linux诞生30周年 5、 其实让人焦虑的，不是忙也不是累，而是没有什么特别感兴趣的东西，也没有什么特别想爱的人，明知道自己该努力了，却又不知道该往哪里用力。 –网易云音乐热评《我还年轻我还年轻》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 28 期）：软件工程师的职业建议","slug":"weekly28","date":"2021-08-15T13:36:00.000Z","updated":"2021-08-15T13:49:55.199Z","comments":true,"path":"2021/08/15/weekly28/","link":"","permalink":"http://www.wmyskxz.com/2021/08/15/weekly28/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 8 月 10 日晚，雷军进行了年度演讲&amp;小米发布会，并官宣苏炳添为小米代言人。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 8 月 10 日晚，雷军进行了年度演讲&amp;小米发布会，并官宣苏炳添为小米代言人。 本周讨论：软件工程师的职业建议（摘录自：阮一峰《未来世界幸存者》） 下面的职业建议分别来自台湾的侯捷老师，以及美国的著名程序员尼古拉斯.泽卡斯（Nicholas C. Zakas）。我觉得这些建议非常好，很有启发，不仅适合 IT 行业，也适合其他行业。 1. 兴趣 只有兴趣才能使你乐在其中，乐在其中你才会产生热情，充满热情才能使你做到卓越。 2. 认知 认知影响态度，态度决定一切。 做 IT 产业非常寂寞，也非常辛苦，大家可能在周末的晚上都要加班，这就要求从事该产业的人必须甘于寂寞，具备一定的忍耐力。 3. EQ（情商） 有能力读完大学的人，聪明才智基本上处于同一水平，没有人可以凭借聪明就可以取得成功。尤其是在进入社会后聪明才智已经退为次要位置，人们更重视 EQ 方面的东西，包括你的人际关系能力、沟通表达能力，抗压性、处理危机的能力等等。 4. 学技术要掌握本质 我们在学习技术时应该注意掌握技术的本质性、不变性和可复用性。本质的东西不易变，不易变就可复用，这三者是一体的。世界上没有万变不变的手法，只有万变不变的宗旨。 5. 刻苦修炼内功 学武的人都必须从最基本的马步、吐纳等内功方面学起，招术很重要，但如果没有内功方面的基础，招术也只能停留在基本的层面，不会到达很高的成就。 在技术追求方面也一样，我们有时候会太热心于学习业界的新技术，每一样都想沾一点。其实不必太急，基本功的东西更重要，研究得扎实一些，招术就比较容易创作了。 6. 唯坚持得成功 有一句话说：在大树底下站久了，树阴就是你的。虽然有时坚持并不代表一定成功，但只有坚持才能有成功的机会。年轻时尽量刻苦一些，使肉体承受最大的痛苦，年龄稍大一些的时候才能享受成果。 7. 不要别人点什么，你就做什么 尼古拉斯.泽卡斯的第一份工作，只干了8个月，那家公司就倒闭了。他问经理，接下来他该怎么办，经理说： 小伙子，千万不要当一个被人点菜的厨师，别人点什么，你就烧什么。不要接受那样一份工作，别人下命令你该干什么，以及怎么干。你要去一个地方，那里的人肯定你对产品的想法，相信你的能力，放手让你去做。 他从此明白，单单实现一个产品是不够的，你还必须参与决定怎么实现。好的工程师并不仅仅服从命令，而且还给出反馈，帮助产品的拥有者改进它。 8. 推销自己 即使做出了很好的工作，别人都不知道，也没用。做一个角落里静静编码的工程师，并不可取。你的主管会支持你，但是他没法替你宣传。公司的其他人需要明白你的价值，最好的办法就是告诉别人你做了什么。一封简单的 Email：”嗨，我完成了 XXX，欢迎将你的想法告诉我“，就很管用。 9. 学会带领团队 当你的技术能力过关以后，就要考验你与他人相处的能力了。 10. 生活才是最重要的 有一段时间，泽卡斯在雅虎公司很有挫折感，对公司的一些做法不认同，经常会对别人发火。他问一个同事，后者怎么能对这种事情保持平静，同事回答： 你要想通，这一切并不重要。有人提交了烂代码，网站下线了，又怎么样？工作并不是你的整个生活。它们不是真正的问题，只是工作上的问题。真正重要的事情都发生在工作以外。我回到家，家里人正在等我，这才重要啊。 从此，他就把工作和生活分开了，只把它当作“工作问题”看待。这样一来，对工作就总能心平气和，与人交流也更顺利了。 11. 自己找到道路 你不可能把时间花在所有事情上面，必须找到一个重点。 12. 把自己当成主人 泽卡斯每天要开很多会，有些会议根本无话可说。他对一个朋友说，我不知道自己为什么要参加这个会，也没有什么可以贡献，朋友说： 不要再去开这样的会了。你参加一个会，那是因为你参与了某件事。如果不确定自己为什么要在场，就停下来问。如果这件事不需要你，就离开。不要从头到尾都静静地参加一个会，要把自己当成负责人，大家会相信你的。 从那时起，他从没有一声不发地参加会议。他确保只参加那些需要他参加的会议。 本期较多，感谢耐心观看🙏 热点新闻1、 根据美国国家海洋和大气管理局国家环境信息中心发布的新全球数据，2021 年 7 月成为有记录以来世界上最热的月份。 2、 从 2021 年 8 月 13 日太平洋标准时间 09:00 开始，GitHub.com 上对 Git 操作进行身份验证时将不再接受帐户密码的方式。 相反，所有经过身份验证的 Git 操作都需要基于令牌的身份验证（例如，个人访问、OAuth、SSH 密钥或 GitHub 应用程序安装令牌）。 3、 Github 开放云开发环境 Codespaces，并免费体验至 9 月 10 号。 不仅拥有 VSCode 的全部功能，而且可能比你的电脑还快，最关键的是仅需一部联网设备就可以在线使用了。 标准化的开发环境、端口转发等功能都一应俱全，感兴趣的小伙伴可以自行去体验一下。 4、 东京一项全球应用下载量的报告（2020 年）显示，TikTok 已经超越 Facebook 成为全球下载量最大的应用。 5、 一位 Youtuber 跟一位物理学家打赌，说风力驱动的车辆速度能够达到风速的两倍，最终 Youtuber 赢取了赌注的 1 万美元。 最终测试时，车辆在 10 英里/小时的顺风中达到了 27.7 英里/小时的速度。 6、 近日，科研界终于迎来了「机器版」变色龙。首尔大学与汉阳大学的研究团队开发出了一个仿变色龙软体机器人，它具备实时、自动融入背景环境的伪装能力。 7、 东京奥运会闭幕，中国队以 38 金 32 银 18 铜的好成绩位居金牌总榜第二；苏炳添担任闭幕式旗手；东京巴黎交接奥运旗帜，夏季奥运会正式进入巴黎时间。 8、 近日，教育部等四部委联合发布了《营养与健康学校建设指南》，文件第二十五条规定：不得在校内设置小卖部。 如果严格按照《指南》执行，「校园小卖部」将成为回忆。 9、 近期，美国新冠肺炎疫情迅速恶化，日增确诊病例数大幅反弹。美媒报道称，现在有超过 98% 的美国人所处地区，存在高水平或大量的社区传播风险。而在一个月前，这一数字还是 19%。 文章1、HTTPS 是如何保护安全的 从 HTTP 的不安全，到 HTTPS 如何保证安全，虽然是老生常谈的问题，但这一篇文章算是“可读性”很高（配图）。 2、深度学习简介（英文、视频） 从自适应线性神经元到使用 Transformer 进行零样本分类的 170 个视频讲座，并且附带了代码地址。 3、用你的技术能力赚更多的钱 《黑客与画家》里面说，程序员想要致富需要具备两点：1）可测量性；2）可放大性； 可测量性是说产生的收入可测量，譬如销售，一个月能有多少收入是跟销售额成正比的。 可放大性是说有无放大你收入的可能，譬如 CEO，他的决策决定了整个公司的方向，收入和风险成正比，如果你有一份令你感到安全的工作，那么你不会致富。 普通人想要靠技术赚取更多的钱，需要两种途径都有： 时刻想着量化自己的贡献（可测量性）； 自己的工作没法放大，但自己的品牌可以放大； 4、Stack Overflow 2021 开发者调查报告 需要注意的是，在 8 万名的受访者中，中国的受访者仅有 1 千人左右，不到美国的十分之一。大量的开发者还是来自美国（18%）和印度（12.6%），其他国家开发者人数均不足 10%，所以该调查数据无法完全反映我国开发者现状，国内开发者参考就好。 5、「2021年度演讲全文」雷军：我最艰难的10个选择 雷总年度演讲图文版，讲述了这十年来与小米共同的经历。比较喜欢其中的「最好的投资，就是投资自己」言论。 6、Rebase 被认为是有害的 我喜欢 Rebase，因为它不会使主线产生混乱。 文中探讨了一些 Rebase 不好的点，但对于小团队来说，例如时间戳混乱的问题，不能说是有害不有害的问题，而是能不能接受的问题。 最终我还是选择 Rebase。 7、Apple AirDrop 的设计缺陷与改进方案 一篇出自“安全客”之手的文章，讨论了 AirDrop 存在的缺陷并设计了改进的方案。 8、海外玩家在玩哪些国产手游？ 8 月 3 日，App Annie 联合 Google 发布《2021 年移动游戏出海洞察报告》，此报告仅针对移动游戏市场，重点为中国游戏公司 2021 年上半年的出海表现，并围绕高潜力的细分游戏赛道进行市场分析。 总的来说，2021 年上半年，在出海路上高歌猛进的中国游戏公司，已占据 23% 的全球消费者移动游戏支出的市场份额。 好奇星人1、为什么当代手机电池还是这么不经用？（视频） 我小学的时候有一部诺基亚，一个月只需要充一次电。科技飞速发展，为什么我们现在的手机甚至撑不了一天了呢？ 可以简单概括为两点原因： 我们手机的功能越来越复杂，各类 App 越发地丰富，这也就意味着需要抽取更多的电量； 科技发展有“摩尔定律”，也就是每过大概 2 年，单个微信处理器上的晶体管数量会翻一倍，这也就意味着更多的电量消耗，但电池的发展并没有“摩尔定律”； 很多年以前，我们已经达到了电池材料的极限（如今电池内的空间已经被用尽了），如今我们已经步入了一个新的阶段：通过更换电池材料来提升能量密度。然而这个过程显然是比较漫长的。 言论1、 这几年在国内风光无限的互联网公司，大多是主打消费型产品，无论是短视频、手游还是购物、外卖，目的都是让更多人消费。然而，在这个过程中，我们越来越发现：沉迷消费的我们，并没有得到自己想要的东西；我们被垃圾信息和对立情绪包围，我们被有意欺骗和误导，我们沉迷在小小的发光屏幕上但内心空虚——我们并不快乐。 从一开始，互联网的底色就是生产工具，而不是消费平台。或许，是时候重新想象互联网了：将它当成工具，而不是消费品。 –川叶 2、 程序员现在的高薪，恰恰是和资本家博弈的结果。资本家能用 5000 块招到合格的程序员，他难道愿意花 1 万块吗？恰恰是中国优质程序员的供给太少，使得程序员的薪资不断攀升。 –知乎：国家何时整治程序员的高薪现象？ 3、 今天的社会给人们传达的信息是：唯一可以确定的是所有东西都在变化，变化的速度不断加快，如果你要抓紧时代的列车，你就得加快速度了。然而，我们应该提醒每个人：其实，我们的基本需求从来不会变化——被看见的需求，被欣赏的需求，对归属感的需求，对附近性和关怀的需求，对一点点爱的需求。这些需求，只能通过人类关系中的慢才能获得。所以，要想掌握变化，我们首先要恢复慢速，恢复反思，恢复团结。只有这样，我们才能找到真正的更新。 –挪威哲学家Guttorm Fløistad 4、 我倾向于认为科技行业的就业就像骑牛。你会被甩掉，这只是时间问题。如果我真的被扔了，我会站起来，擦掉身上的灰尘，然后继续前进到下一头公牛。 所以这真的是我要给出的第一条建议；不要把失去工作或不得不换工作太个人化，因为这几乎肯定会在某个时候发生。 –老黑客关于保持工作的秘诀（英文） 5、 我觉得中文把上学说成读书很有道理，学校不一定能教人什么东西，重要的是读书，自己多看书就行了。 –李银河《活过，爱过，写过》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 27 期）：游戏是“精神鸦片”吗？","slug":"weekly27","date":"2021-08-08T01:46:00.000Z","updated":"2021-08-10T23:17:25.385Z","comments":true,"path":"2021/08/08/weekly27/","link":"","permalink":"http://www.wmyskxz.com/2021/08/08/weekly27/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 一艘由以色列公司管理的油轮早前在安曼海岸被无人机袭击，造成船上两人死亡。美国军方公布调查结果，再次指控伊朗发动了袭击。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 一艘由以色列公司管理的油轮早前在安曼海岸被无人机袭击，造成船上两人死亡。美国军方公布调查结果，再次指控伊朗发动了袭击。 本周讨论：游戏是“精神鸦片”吗？ 现在算是作为半个游戏行业从业者，先回答：不是。 最近文化娱乐产业出手整治得厉害，不单单对饭圈文化整治，还包括对未成年人沉迷游戏的现象进行舆论抨击。(via) 在 8 月 3 日，有媒体在早上 8 点 28 分发表了一篇名为《“精神鸦片”竟长成数千亿产业》的文章。 文中使用“精神鸦片”、“电子毒品”来形容整个游戏产业，这显然是有些夸大的成分了。 一时间，腾讯股价跌 10%，网易跌超 13%，港股手游集体下跌。 可能是影响范围超出了媒体的想象，所以这篇文章发出去 4 个小时就被主动删除了，后来重新发表了一篇《网络游戏长成数千亿产业》，内容里面也没有再提及“精神鸦片”和“电子毒品”这一类的词汇。 很显然，这是一次把「未成年人防沉迷」这样一个比较有针对性的现象，不合理的扩大到对整个行业的打击。 不能把游戏称为“精神鸦片”的理由有几条： 如果按“游戏是毒品”的认知框架，我们应该禁止游戏，但显然与现实情况不相符； 人类对娱乐的正常需求，是存在于人的本能，是不可能杜绝的； 很多研究表明，玩游戏对我们有许多正向的影响，比如可以刺激大脑关于认知处理和运动相关脑区的发育； 如果非要比喻，我觉得最贴切的应该是，游戏像糖，我们每个人生命中不可或缺的糖，然而多食却又有害； 如果我们能够学会主动掌控，善用生命之糖，游戏可以带来快乐，也可以提供能量； 逐利是资本的天性，因此游戏上瘾机制被精心设计，并充斥大量劣质“圈钱”游戏，对它们上瘾也不能全怪我们； 前一段时间，国产独立游戏《戴森球计划》被各大媒体网络吹爆，我也下载并畅玩近百小时，可是因为太杀时间，就弃坑了。 不过我找回了小时候玩儿红警、玩儿帝国时代的那种纯粹的快乐和那种忘却时间的“心流”状态。 其实我们沉迷游戏，往往是因为我们还没有找到自己真正想去做的事，缺乏这种热爱的喜好去释放自己精力，那么我们过剩的精力和时间，只能通过各种娱乐渠道去消遣来打发时间。 说白了，大多数时候，我们只是因为太闲了，亦或者就是精神生活太空虚了，才会沉迷在各种娱乐方式。 如果我们找到自己内心真正的追求，那么游戏也只会被当做一种娱乐消遣，而不会沉迷。 所以我对游戏的态度还是很理性客观的，我既不认同把游戏妖魔化的做法，也认为我们需要正视现在的游戏产业存在的各种各样的问题。 作为游戏从业者，我希望我们的游戏产业，可以诞生出更多像《戴森球计划》这样更优质的游戏，是真正在为玩家做好玩的游戏，赚钱只是在这个前提下，自然而然的水到渠成结果。 而不是把赚钱放在首要目的，一门心思只想着通过收割玩家去赚钱，而不是为了服务玩家去获得合理收益。 结论是，我们不能因噎废食，但也应该加以引导整治，尽快推行分级制度，不能任由资本无序的扩张持续下去。共勉🙏。 热点新闻1、 知名奢侈品品牌 LV 为庆祝创办人路易威登先生 200 岁诞辰，特别推出了一款「Louis the game」的手游。 主要玩儿法就是在 6 个主题关卡中自由探索，在旅途中收集蜡烛并获得 LV 明信片。 游戏过程中有机会遇见 NFT 彩蛋，跳出黄金明信片，点击之后会获得抽取 Louis 纪念品的数字纪念品的资格。 2、 Windows 365 云电脑刚上线第二天，就因为涌入用户太多，不得已暂停了免费试用功能。 3、 8 月 3 日，腾讯推出了游戏未成年人保护“双减双打”的新措施，《王者荣耀》未满 12 周岁禁止充值。 4、 字节教育转型：刮刮龙体验课教辅裁员 50% 以上，你拍一、GOGOKID 将被放弃。 另外在线教育公司 VIPKID 也宣布关停主营业务，不再售卖涉境外外教的新课包。 5、 印度收获奥运田径首金，这也是印度赢得的首枚奥运会田径金牌，总理莫迪发推祝贺：历史在东京改写。 6、 全球最大轮胎垃圾场（科威特）着火，5200 万条轮胎仍在燃烧，太空可见浓烟，或致全球生态灾难。 文章1、Linux 内核模块编程指南（英文） Github 上硬核的免费的 Cookbook。内涵大量的示例。 2、拿自己做实验，试试不过双休日 公众号「也谈钱」的作者发起了一个有趣的真人实验：有没有可能不过双休日反而会更让我们更加舒服自在呢？ 这里是他的第 4 次记录，其中分享了它顿悟式的体验： 有一天我在像往常一样写东西，突然就有点犯懒，特别想去看动漫（以前周末经常看）。但不知道哪根筋搭错了，我突然问了自己两个问题，结果问完自己就懵掉了： 「我想去看动漫，OK，说明看动漫应该很开心的。那我现在回忆一下过去这些年立刻就能想起的幸福瞬间，有哪些是和动漫有关的？」 结果，一个都没有。最幸福的瞬间往往都是工作、生活上取得了巨大进展的时刻。 突然间，我感觉有点迷惑了，再接着问了自己第二个问题： 「刷完一部动漫，那我是感觉自己更幸福了还是更空虚了？」 ……… 这个发现让我非常意外——那些我一直认为自己很喜欢的事儿，我其实并不喜欢。 过周末和不过周末，到底有什么不同呢？感兴趣的小伙伴可以戳一下交流交流。 3、开发心得：为何掌握游戏分析法如此重要 腾讯游戏学院出品的文章，长文讲述如何对一款游戏进行分析，掌握了更多关于游戏性的原理，我们就能为我们的创新提供正确的方向，也能较好的判断创新的成功率。 4、苏炳添论文“如何跑出亚洲最快” 除了短跑运动员之外，苏炳添还有另外两个身份：暨南大学体育学院副教授以及北京体育大学2019级博士研究生。 这是它研究100m短跑的论文，非常专业。 5、起底德堡惊人黑幕（视频） 中国网友做了个片子，起底德堡惊人黑幕。 6、 没有阅读更多…. 好奇星人1、奥运会的球类运动里，哪种球速度最快？ 相信很多人都知道，答案是，外形一点也不像球的羽毛球。 2013 年 7 月，马来西亚运动员陈文宏与队友李宗伟受邀参加某公司的新球拍速度测试赛，陈文宏以 493 公里 / 小时（将近 137 米 / 秒）的速度创造了世界记录。 不过由于这是在实验室测试时的球速，不是在真实的比赛中，因此该记录并未得到吉尼斯世界纪录官方的认可。 目前吉尼斯官方认可的最快的羽毛球记录来自丹麦选手科丁，2017 年 1 月 10 日，在印度羽毛球超级联赛上，科丁在正式比赛中杀出一记速度高达 426 公里 / 小时（约 118 m/s）的杀球。 这两个记录中，羽毛球的最高速度都比“复兴号”动车组列车的最高运行时速（400 公里 / 小时）要快。 原因其实并不复杂，主要是因为羽毛球比较轻（重量只有 5 克），并且球拍足够长（不超过 680mm）。 羽毛球的快仅仅体现在一瞬间，在很多人看来，这似乎有一点“胜之不武”的成分。 严格意义上，一次击球过程中的平均速度往往更符合“最快”的标准。 由于阻力过大，羽毛球只得名落孙山，而此时拔得头筹的又会是谁呢？ 答案是高尔夫球。 言论1、 我认为网络环境的恶化是内生性的。正如我在之前关于TikTok的文章里说的那样：“软件和互联网确实是在吞噬世界。但这种吞噬是魔人布欧式的。软件和互联网在吞噬世界的同时，也变成了世界本身，揭示了世界本来的面目。有美丽的，也有丑恶的”。 –@即刻App 2、 当你只想着进步10%的话，你把自己置身于所有同行的竞争当中，而且你很可能输掉； 当你朝着进步10倍的目标努力，并努力做非常困难的事情时，你会试着用完全不同的方法解决问题； 当你认为任何问题都可以被解决时，哪怕你还不知道怎么解决，你会被你接下来的想法而震撼。 –《登月思维》 3、 决定你成功的不是“你想享受什么？” 而是，“你想要承受什么样的痛苦？” 你的生活质量不是由你积极体验的质量决定的，而是由你消极体验的质量决定的。善于处理负面经历就是善于处理生活。 –《你生命中最重要的问题》（英文） 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 26 期）：世界不是天才创造的","slug":"weekly26","date":"2021-08-01T02:38:00.000Z","updated":"2021-08-03T09:17:29.960Z","comments":true,"path":"2021/08/01/weekly26/","link":"","permalink":"http://www.wmyskxz.com/2021/08/01/weekly26/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 7 月 26 日东京奥运会铁人三项比赛后，一些参赛选手出现了倒地、呕吐等现象，其中包括获得冠军的挪威选手布鲁蒙菲尔特在内，至少有 4 位选手赛后出现不适。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 7 月 26 日东京奥运会铁人三项比赛后，一些参赛选手出现了倒地、呕吐等现象，其中包括获得冠军的挪威选手布鲁蒙菲尔特在内，至少有 4 位选手赛后出现不适。 本周讨论：世界不是天才创造的 最近读到一篇 06 年的旧文「世界不是天才创造的」，忍不住同大家分享。 我们先来玩一个游戏，规则如下： 每人给出一个从 0 到 100 之间的数字。把所有人的数字求算术平均值。谁选的数字最接近这个算术平均值的 2/3，谁就赢得整场游戏。 这是个有趣的游戏，不妨细读一下题目，想一下，试一下？ 选一个数，写一个理由，再往下看。 先来分析一下这个游戏里的每个人。如果每个人都是真的随机的选择的话，大家平均值应该在 50 左右。50 的 2/3 应该是 33.3，对吗？很多人都写了 33.3。（当然还有很多人没有想到这一步） 不过多想一步，如果你写了 33.3，难道其他的人不会想得和你一样，也写 33.3 吗？如果这样，你应该写 22.2。如果继续想下去，大家的平均值应该越来越小，就是这样….. 50 33.33333333 22.22222222 14.81481481 9.87654321 6.58436214 4.38957476 2.926383173 1.950922116 .... 最后，把问题想得非常地复杂的人的答案是 0。 然而多次游戏的结果是：几乎都是选择 22 左右的人获胜。 这个游戏告诉我们，这个世界不是由天才决定的。在众人决策的过程中，赢得游戏的人，都是比别人多想一步的人，而不是多想两步或更多步的人。 这个游戏里面，选择不同的数，或许就代表了不同的人。 先来说说选择超过 66.67 的人。大致想一下就应该知道，就算所有人都写 100，最终获胜的数字也才 66.67，所以会有人选超过 66.67 的数字吗？ 事实是：我们不能指望所有的用户都和和业内人士有一样的判别力，一样的了解规则，对吗？没有听清或者没有读懂游戏规则而胡乱游戏的人比比皆是。 再来说说选择 0 的。越是理性的群体，选 0 的比例越高，比如微软研究院 30 个人里面高达 3 个人选 0。选 0 的人，沉浸于自己对世界了解的快感中，却知之者甚少。 我们假想一下，如果天才的理论有机会向每一个参与者传播，让他们理解，跟随天才的选择，说不定他还有一线获胜的机会，不过让每个人了解，从古到今就不曾在天才在世的时候实现过。天才不是疯了，就是穷困潦倒。 选择 33.3 的或许是平凡的人，而选择 22 的也只是比规则前进了一步。 对于这个社会，必然有看得比别人稍微透彻些的，离真理更近些的，我们姑且称之为天才吧。这些已经窥探到天机的天才，在现实世界里面，选 0 还是选 22，这是个问题。 选零，就注定了要放弃大多数人的认可。这认可可能是名声，可能是钱。选零的人，适合当教授，适合当评论者，不合适自己来做商业。 如果你本来想选 0，却又为了迎合大众选了 22，就注定了你要伪装的傻一些，要被业内人士批判，会被选 0 或者 8 的人认为不紧跟潮流。 大家看一看现在大凡成功的公司，从美国的软件业网络业巨头们，到中国的门户和成功网站，哪个躲得过选 0 的人的指指点点？或者说，选 22 的人是易中天，会用通俗（甚至有些错误）的方式讲史，而选 0 的人就是严肃的历史学家。通俗文学，流行音乐和热门网站，在大众和同行两个世界里面有完全不同的声名，大多是因为这样。 没有选 0 的人，这个世界何以进步？选零的天才们艰难的拖着这个世界前行。我对他们表示敬佩。只可惜，他们获得的只有一小部分人的敬佩。 对于选 22 的人，帮助了无数选 33 的人改善了生活，他们也获得了巨大的商业成功。没有 22，世界怎么可能从 33 过渡到更小的数字去呢？我对他们也表示尊敬。 世界毕竟不是由天才创造的。共勉。 热点新闻1、 过去，在奥运奖牌中加入回收材料中提炼的金属是一个传统，但在今年的东京奥运会奖牌中，100% 都是由回收的电子设备制成的。 2017 年至 2019 年间，日本各地捐赠了旧电子设备总计数万吨，并提取了 32 公斤黄金、3500 公斤白银和 2200 公斤铜锌作为奖牌。 2、 根据最新的美国就业报告，在 3.32 亿总人口中，有 1.458 亿非农就业人员。 而亚马逊在美国有 95 万员工，这意味着，每 153 名美国工人中就有 1 名是亚马逊员工。 3、 近日，美国飞行汽车商 Joby Aviation 公司在网上发布了一段电动飞机的测试视频，在测试中该飞机完成了超过 150 英里（约合 240 公里）的连续飞行实验，并安全降落。 目前，该电动飞机采用的是三组锂电池，飞行时速最快可达 200 英里/小时（约合 321 公里/小时），单次充电后飞行里程可达 150 英里（约合 240 公里）。 该公司表示，或在 2024 年正式上线 “飞行出租” 服务。 4、 中国人民大学《人民币国际化报告2021》显示：人民币已经超过日元和英镑，成为世界第三大国际货币。 5、 29 日，Nature 发表了一篇来自清华的重磅论文：成功在自然环境条件下用镜像 DNA 储存信息长达一年。 不明觉厉。另外 DNA 储存信息的密度令人震惊。有计算显示，全世界现有的数据信息可以储存在 1 公斤中的 DNA 里。 6、 截止 31 日，我国健儿共收获 21 金，13 银，12 铜。 7、 7 月 31 日晚通报：针对网络举报的“吴某凡多次诱骗年轻女性发生性关系”等有关情况，经警方调查，吴某凡（男，30岁，加拿大籍）因涉嫌强奸罪，目前已被朝阳公安分局依法刑事拘留，案件侦办工作正在进一步开展。 网友戏称：吴某凡是最讲信用的男明星。 文章1、在 Github Pages 上托管 SQLite 数据库（英文） 静态网站比真正的服务器要容易很多，有很多免费且可靠的选项，例如 Github、GitLab Pages、Gitee 等。 本文作者写了一个可以在静态托管网站中使用真正的 SQL 数据库的工具，并在文中展示了一个包含 6 个表和超过 800 万行的数据集使用情况。 2、如何成为技术一号位？ | @阿里巴巴中间件 作者分享了自己从普通开发到技术一号位的经验经历：重点是在思想上转变过去“研发本位”的认知误区，然后加强“业务学”的广度和积累。 3、编程与数据科学的经验之谈 跟 23 期的《程序员的酒后真言》如出一撤，不过是国人的经验之谈，还是很值得借鉴的。 4、关于地铁进水这件事，聊点你可能不知道的 作者系地铁从业人员，本文仅从技术角度出发作科普目的，旨在让读者了解地铁内相关技术应用和特殊情况危害，部分技术内容已进行精简或省略。 5、我从来没见过如此公正的奥运会！（视频） 周末了，可以来看看这些「阴阳怪气」放松放松。 6、软件未来的10个预测（英文） 一个云计算专家预测软件未来的10个变化，可以当作一家之言看看。（@阮一峰） 7、50 种配色（英文） 属于比较清新的风格，直接拿来吧你。 8、鸿星尔克爆火的背后是什么？ 从产品的角度分析了为什么鸿星尔克爆火的原因： 1）冲突；2）克制；3）情节；4）情绪；5）蓄力；6）借力；7）造梗；8）若愚； 其实我觉得造梗是现下比较流行和容易造势的方式。 好奇星人1、营养成分表的真正含义 我们所购买的食品背后，都会有一张营养成分表，这并不是指食物中的营养配比，而是根据人体每天应摄入营养量计算出的一个参考值。 比如上图包装中，写着蛋白质 29%，脂肪 11%，不是指这个食物中 29% 是蛋白质，11% 是脂肪。 而是说吃了这个食物，就摄入了全天应摄入蛋白质的 29%，应摄入脂肪的 11%。 另外有一个冷知识是：国家规定 100g 固体或 100ml 液体食品中，含糖量不高于 0.5g 就可以标注无糖，市面上无糖饮料的甜味，主要来源于甜味剂（一种不会被人体代谢吸收的低热量代糖）。 言论1、 每个人都知道尽全力做事，但是很少有人注意细节。他们并没有把一件事做到100分，而只是把一件事重复做了100次。而且，即使这样，他们也没有总结过这100次之间的差异。不仅如此，稍微碰到一点儿挫折或者来自外界的质疑，他们就会选择放弃。 多年职场经验教会了我两件事。第一，注意每一个细节；第二，从细节中寻找关键。第一点会让你更敏锐，考虑更周全。第二点则能让你完成从量变到质变的进化。 –《真正的勤奋，不等于忙碌》 2、 编写软件曾经是一种乐趣。我们在办公桌前待到深夜，因为我们热爱我们的工作，我们热爱我们被对待的方式，而不是因为我们害怕下一次审查，或者我们有荒谬的截止日期。 –《软件开发人员的代沟》（英文） 3、 必须认识到，收入并不是跟技术水平、辛劳程度匹配的，在好一点的环境，技术水平、辛劳程度跟收入的匹配程度比较高。但在人情环境浓郁的地方，人情 / 人际跟收入的匹配程度一定是高于技术和付出的，并有很多堂而皇之的依据来说明你配得上或配不上多少收入。 –Twitter 用户@im2gua 4、 “如果我们自己不创造能够杀死 Facebook 的东西，其他人将会这样做。……互联网不是一个友善的地方。那些不重要的东西甚至都没有机会留下遗迹。它们消失得无影无踪。” –2012年，Facebook 发行股票上市，每个员工收到了一本小红书 5、 还有一个案例是《逆战》射击类游戏动作的优化。大家都玩过CS，为什么感觉CS时人走路非常难看，身体不晃，不自然。我们也和游戏研发团队商量，为什么做成这个样子？他们的理由非常不可辩驳，因为我要瞄准，要射击，如果对方身体在晃没有办法瞄准，会影响用户体验。这个理由确实非常对，可就不能改了吗？当然可以改！我们想了一个很简单的方法，做成两套动作，加上必要的逻辑就可以。怎么做呢？我们做一套非常生动的动作，走起很自然，人会有上下高低的走动，肩也会抖动的动作，这种动作是你看自己的时候，看你队友的时候；当你瞄准别人放第一套动作，不会上下动的动作。把逻辑理清楚，玩家在感受的时候就比较生动，又不影响射击体验。 –《“王者荣耀”之父姚晓光：像蘑菇那样思考 》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 25 期）：不要在功能上竞争","slug":"weekly25","date":"2021-07-25T01:45:00.000Z","updated":"2021-08-03T09:17:47.852Z","comments":true,"path":"2021/07/25/weekly25/","link":"","permalink":"http://www.wmyskxz.com/2021/07/25/weekly25/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 东京时间周五（7月23日）晚上八时，东京新国立竞技场亮起的光芒给日本国都平添了又一分色彩。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 东京时间周五（7月23日）晚上八时，东京新国立竞技场亮起的光芒给日本国都平添了又一分色彩。 本周讨论：不要在功能上竞争(观点来自：《未来世界的幸存者》@阮一峰) 苹果公司的电子产品，最大的特点就是它的易用性（usability）—-简单，美观，容易上手。它们通常不是功能最强大的，但往往是最好用的。 很多产品经理都想模仿这些特点。但是，一个难题就会随之而来：很难让一件产品保持简单易用，同时还具备大量的新功能。 如果你不断为产品添加新功能，在变得强大的同时，它还会变得越来越复杂，增加了用户的使用难度；如果你大力简化产品，在功能上比较单一，那么怎样与竞争对手抗衡呢？ 正确的做法，就是不要在功能上竞争。 如果你的产品的核心概念行不通，那就重新定位这个产品，而不是为它添加新功能。你必须牢记在心，创造一个有竞争力的新产品，不要着眼于它的功能比别人多，而要着眼于它有一个截然不同的市场定位。 如果市场上都是复杂的企业级工具，那就开发一个针对个人用户的简化版；如果市场上都是很正式的高端葡萄酒，那就开发一种便宜的、针对年轻人的、更休闲的酒精饮料；如果市场上都是提供长篇Blog服务的网站，那就开发一个很简单的、每次只能写140个字的网站；如果市场上都是技术性的、廉价的电子设备，那就开发人性化的、高价的电子设备。 总之，你要做的不是添加功能，而是做一个市场定位不同的产品。 这主要有两个原因。 首先，你不太可能通过一个更多功能的新产品，战胜现有厂商。因为你开发出全面胜过别人的产品，需要很多时间；而且，等你开发出新功能，别人可能又做出了改进，或者拷贝了你的新功能。 其次，比起新功能，消费者更容易为一个特殊定位的产品掏钱。 所以，更好的策略是，开发一个简化的产品，突出某种不同的市场定位，争夺现有厂商的低端用户。这样的话，你不用开发一个全功能的产品，节省了时间，而且由于设计目标不同，更容易做出颠覆式创新（disruptive innovation）。 下面是开发新产品时，几点可行的做法： 你不是做一个比竞争对手“更好”的产品，而是做一个“不同”的产品。 你只提供部分功能，但是很好地满足了用户的需求。 如果新产品的市场反响不好，增加新功能并不能解决问题。你应该重新定位你的产品，想想它能向消费者提供哪些不同的价值。 在产品设计和推广的每一个环节，都突出它的不同定位。 🙏共勉。 热点新闻1、 7 月 20 日，最高时速 600 公里的磁悬浮列车亮相青岛。 以这个速度，从北京到上海仅需 2.5 小时，相比之下，乘坐飞机需要 3 小时，高铁需要 5.5 小时。 2、 7 月 24 日，国家市场监管局责令 QQ 音乐 30 天内解除独家音乐版权、停止高额预付金等版权费用支付方式。 不久将来，终于又能在其他平台听到周董的歌了。 3、 前一段时间，大熊猫的受威胁程度等级由“濒危”降为“易危”。 这是因为我国已建立了较为完备的自然保护地体系，野生生物生态环境得到有效改善。大熊猫野外种群数量已经达到 1800 多只。 4、 近日，东京奥运会正式开幕，但因为其节目过于 “阴间”，引发众网友吐槽：艺术可以接地气，但请不要接地府。 中国队本次共有 777 名运动员参加，截止 7 月 25 日 00：00 开赛 1 日，中国队共获取 3 金 1 铜的好成绩： 🏅个人重剑 - 孙一文； 🏅女子十米气步枪 - 杨倩； 🏅女子举重 49 公斤级 - 侯志慧； 🥉男子十米气步枪 - 庞伟； 5、 在河南省会郑州周二（7 月 20 日）遭遇有气象记录以来最大的暴雨。三天几乎下了一整年的雨量，如 317 座西湖倒灌。 据《河南日报》消息，截至 7 月 23 日 12 时，省会郑州暴雨引发的洪涝和次生灾害已经导致 51 人遇难。 🙏河南加油。 6、 ARM 公司宣布他们用一种塑料和薄膜晶体管制成了一种新的处理器 PlasticArm。 其生产过程不涉及到硅元素，生产成本大概为同类硅芯片的 1/10，但缺点就是只有 1% 的能量用于执行计算。 7、 近日，98.5% 人类蛋白质结构被 AI 预测出来了，而且还做成了数据集，全部免费开放！ 譬如跟遗传病成因有关的 Wolframin： 有条件的小伙伴可以访问网址去玩一玩：https://alphafold.ebi.ac.uk/ 文章1、Git 教程 | TOWER（英文） 质量非常高的一套 Git 教程，知名软件 TOWER 官方博客撰写。 2、WEB 简史（英文） 收录了从 1989 年以来至 2020 年互联网发展的所有事件。 3、如何创建和提供有效的课程（英文） 围绕「如何创建和提供有效的课程，并围绕它们建立教学社区」这个话题，展开了事无巨细地描述和教学。 4、精英主义：21世纪最大的陷阱 阶级固化是老生常谈的话题了，这一篇文章让我明白了，所谓“精英”之间的内斗也尤为严重。 5、如何做一个有质量的技术分享 陈皓大大分享了一些关于做好「技术分享」的心得，关键就是： 把复杂问题简单化； 有各种方案的对比； 原理、思路、方法论； 描述好问题； How 比 What 重要； 一定要有 Best Practice 或方法论总结； 6、Python import 的原理（英文） 这是一个揭露 Python 底层原理的系列文章，较为深入，感兴趣的小伙伴可以当读物来了解一下。 7、反垄断究竟是在反对什么 这是 19 年的旧文，非常有看点，总共有 5 篇。 科技大公司全力加速赛博朋克化的趋势已经被反复说了好多年，但丝毫没有要放缓的意思，不管是来自监管还是民间的力量似乎都没法停下这趟不断加速前冲的无限列车。 8、钢铁侠马斯克的故事以及 30 点学习建议（英文） 钢铁侠马斯克的故事。读起来有一种戏说的传奇感，但这个人的经历本身就足够传奇了。 最后文章总结了能从中学习的 30 点经验（谨慎参考）。 好奇星人1、没有空调的古人住宅，在夏天是如何避暑的？ 第一招，隔绝热空气。 大多数中东和南亚建筑的墙壁都很厚（甚至可厚达几米），窗户却很小，数量也不多。厚厚的墙壁可以有效隔热，小小的窗户则阻止了阳光射入。比如上图中德里红堡的内院。 第二招，蒸发制冷。 在建筑内修筑水渠，水分蒸发吸收热量，有一定的降温作用。 平民家庭可能造不起喷泉之类的，所以利用 Mashrabiya 的结构，突出墙面，上面开很多空，用来捕捉气流，使空气通过。里面则放置一些水盆，用来蒸发制冷。 第三招，加强对流。 古人在建筑结构上动足了脑筋，通过强化对流来增强蒸发制冷。例如伊朗亚兹德水库的附属风塔： 以及中国的风扇车： 第四招，地热耦合。 在中亚和中东，有许多以地下暗渠连通竖井，通过蓄水池储存水分的沟渠系统。 土壤隔热，因此在夏天，坎儿井中的水温要比地表的气温低得多。利用两者的温差，就可以用坎儿井中的水来冷却地面的建筑。 言论1、 “如果我不在微软工作，我今天会买一台 Mac” –Jim Allchin 2004 年对比尔盖茨说（英文） 2、 为什么成功的人能够做他们不喜欢做的事情而失败的人不喜欢呢？因为成功人士有一个足够强大的目标，使他们形成做他们不喜欢做的事情的习惯，以实现他们想要完成的目标。 –《成功的共同点》（英文） 3、 在中国，不管去哪个城市，都感觉像在同一个城市。几乎所有的城市不外乎由这五个部分构成：一个低矮陈旧的老城区，一个高楼林立的新城区，一条专宰外地人的步行街，一个买假酒和假手工的仿古文化街区，一个要收5道门票茶叶蛋10块一个泡面30一碗的5A级风景区。这是标配，没有高配。 –Twitter 用户 4、 进入互联网大厂前，看大厂就像看高速公路上的奔驰宝马玛莎拉蒂、非常神气，那些小公司在那就像骑自行车灰头土脸；等真的进到大厂里去内卷和谋福报了，才发现什么奔驰宝马玛莎拉蒂、那都是个纸壳子，纸壳子里面也都还是人在灰头土脸地骑自行车。 —— 观某互联网大厂技术架构有感 –Twitter 用户 5、 荧幕鲜肉是时代的淫欲黑洞，职场和情爱是千年不变的注水套路，一上来就安排好财富和智商的等级序列，是国产剧最危险的地方。 –影评人毛尖 6、 20 年前，一介平民如果有什么冤情，真的只有一条路，那就是写信给媒体，盼着媒体能派记者去采访。所以，那时候他去一个偏远农村采访，全村人会杀鸡宰牛招待他，会排成长队欢迎和欢送他。而现在，这样的情景不会再出现，因为大家有了微博。 –《微博会被取代吗？》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 24 期）：这是做事情的正确顺序吗？","slug":"weekly24","date":"2021-07-18T02:00:00.000Z","updated":"2021-08-02T15:50:56.565Z","comments":true,"path":"2021/07/18/weekly24/","link":"","permalink":"http://www.wmyskxz.com/2021/07/18/weekly24/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 近日， 欧洲遭遇破纪录的暴雨，导致河流决堤，欧洲广泛地区受到毁灭性影响。一场数十年一遇的洪水在欧洲西部已造成至少120人死亡，数以百计的人员下落不明。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 近日， 欧洲遭遇破纪录的暴雨，导致河流决堤，欧洲广泛地区受到毁灭性影响。一场数十年一遇的洪水在欧洲西部已造成至少120人死亡，数以百计的人员下落不明。 本周讨论：这是做事情的正确顺序吗？最近订阅了少楠的产品沉思录，收获颇丰，拜读主理人的公众号，里面有一篇文章，看完第一反应就是忍不住想要分享给大家。 文章的核心观点是：知道事物的顺序是非常重要的。不时的问问自己，这是做事情的正确顺序吗？这真是一种强大的技能。 a. 对于大多数人来说，睡的越早质量越好，所以晚上看 Netflix 和早上看影响是不同的，晚上的损害更大一点。 b. 把早上的时间拿来读深度的东西，而不是去读碎片的社交资讯或者博文，这也许是另一种塑造更好的深度工作时间。 c. 下午锻炼似乎要比早上精力充沛（做创造性事情）或者晚上精神疲惫时收益更高，因此你可以更好的利用这些时间从而获得更多的锻炼和更有效的利用时间。 d. 在销售产品之前建立一个网友群可能更有效，正确的顺序为弹弓打开了更大的通道（重力弹弓效应）。 e. 如果事先让你知道俄罗斯方块中的所有方块，并按照你的喜好排列他们，你会更加喜欢这个游戏吗？ 在 Twitter 上 James Clear，就分享了他的一个非常简洁的读书方法。 他写道，人们都说读书重要读书容易，你只需要花费你的时间，但往往我们都知道说的容易做的可一点都不容易。既然我知道人类这种局限性，我该用一种什么策略读书了，一种使我能够阅读更多书，而又不会让典型的情况打断我的阅读了？ 策略就是，「Read 20 pages to start the day」。他通常都是一睁眼醒来，喝一杯水，写下醒过来之后最让他感激的 3 件事，然后就开始读 20 页的书。按这个阅读速度，一年可以读 36 本书。 他解释道，20 页足够小，不会让人感到阅读的恐惧。大多数人可以在 30 分钟内阅读完 20 页。如果您在早晨做了这件事，那么一天的忙碌也不会受到影响。即便你一天过的很丧气，你想到你早上读完的 20 页书，心里也会有一点安慰。 在你的生活没有变得你理想中那样，请读一本好书吧，就如同大多数会极大影响您生活的习惯一样，不紧不慢的每天读 20 页书，这就是你的全部，这也是一种带有复利的顺序，投资这种事情吧。 本期内容较多，请耐心观看。共勉。 热点新闻1、 最新的研究表明，亚马逊雨林现在排放的二氧化碳多于吸收的二氧化碳。 每年排放的二氧化碳达 10 亿吨，大部分排放是由火灾引起的。 2、 微软推出了云端虚拟桌面服务「Windows 365」，8 月 2 日上线。 届时，用户可以通过任意设备的浏览器，使用 Window 10（未来会是 Window 11），所有状态都会保存在云端。 3、 7 月 16 日，Steam 公开了自家的掌机，命名为 Steam Deck，据说可以流畅运行 3A 大作，将于今年 12 月正式开始，价格为 399 美元（约合人民币 2567 元）。 4、 近日消息称，阿里巴巴和腾讯正考虑互相开放生态系统。 阿里巴巴的初步举措可能包括将微信支付引入淘宝和天猫；而腾讯可能将允许阿里巴巴的电商信息在微信分享，或者允许微信用户通过小程序使用阿里巴巴的一些服务…… 5、 最新一次的比特币挖矿难度调整，下调了 27.94%，是历史上最大的难度下调。而且，难度已经连续下调了三个周期，比五月份高点下降了 42.6%。 根据比特币的设计，每挖出 2,016 个区块，就要调整一次挖矿难度，防止挖矿变得过难或过易，保持每10分钟挖出一个比特币的速度。 这次挖矿难度下调，应该与国内取缔比特币挖矿有关，使得算力大大减少，挖矿时间变长，难度不得不下调。 (via：@阮一峰) 6、 英国亿万富豪布兰森（Richard Branson）7 月 11 日晚搭乘维珍银河（Virgin Galactic）的太空船升空，并在约 40 多分钟后顺利回程并降落。 这趟旅行标志着太空旅游普及化踏出重要一步。 文章1、Go 内存模型更新（英文） 当前的 Go 语言内存模型是在 2009 年编写的，此后进行了小幅更新，这篇文章是介绍“它们”的以及更新的理由。 2、世界上最糟糕的音量控制用户界面（英文） 在 Reddit 上有一个由开发人员和设计师发起的讨论，看看谁能想出世界上最糟糕的音量控制界面，于是各种离谱的操作层出不穷： 3、Dropbox 工程职业框架（英文） 列举了工程师职业框架中各个 title 所承担的期望和核心职责，可以作为「如何工作」的参考指南。 4、忘掉 To-Do List 吧，改用 “ABCD” 方法 听上去是一种新的方法论，但核心非常简单：区分优先级，并不惜一切代价重点完成高优先级的任务，而不是将任务列表中的条目一视同仁地对待。 其中有几条原则值得学习： 最高优先级不超过 3 个任务； 需要自己完成的最多只有 3 个优先级； 在这以下的任务要么委托给别人，要么放弃； 5、剧本杀的“前世今生” 在中国，桌面角色扮演游戏系统分成了剧本杀和跑团两个方向。跑团在中国水土不服，而对剧本杀这股热潮，一些人失去了兴趣，一些人则看到了机会。 6、关于 996 工作制度，十二篇值得一读的报道 近些年，加班文化一直是大家关心的热点话题，自 996.ICU、996 福报论之后，最近些年，媒体都是如何对加班文化进行报道的？其中又有哪些深度的文章？这一篇我相信可以给你一个满意的答卷。 7、首发遇冷的《罗布乐思》：比《Roblox》缺少的，或许不只是内容 最近登录腾讯 QQ 会发现一款名叫《罗布乐思》的强推送广告。 虽号称继承了《Roblox》，但推广至今，截至 7 月 17 日，七麦数据显示，《罗布乐思》已从国区 App Store 免费榜第一下跌至第十名，畅销榜上仍在百名开外；安卓渠道也是下降明显。 尽管起步略有受阻，需要指出的是，《罗布乐思》是走的编程工具和编程学习的培训体系路线。 段志云表示：“简单来说，罗布乐思的游戏内容虽还没有准备充足，但编程工具和编程学习的培训体系已经准备好，形成了从专业知识学习到实战的完整创作线。”开发团队也预计到了发行初期可能的遇冷期，并做好了相关准备。 总而言之，想要实现 “元宇宙”的 “中国梦”，《罗布乐思》还有很长的一段路要走。 8、开始 Python（英文） OVERFLOW 上的一篇文章。收录了一些 Python 入门级的教程，新手友好向。 9、编写代码注释的最佳实践（英文） 收录了 9 条写代码注释的最佳实践。 10、我从 Nathan Latka 那学到的 6 个教训 无关乎 Nathan Latka 是谁，下面这六个教训，非常受用： 先建立注意力，再建立产品; 任何东西都是可以破解的; 充分利用你所拥有的一切; 允许自己有远大的梦想; 理解并利用情绪; 奋力前进，但要尽可能高效; 好奇星人1、古人的假期有多长？ 古人大部分不上班，只有政府官员等少数群体有假期。 汉朝时，官员每工作五天放假一天，称为“休沐”。沐，是指洗头发，也就是说每五天放假一天让你回家洗头发，顺便探亲。加上各种节假日，差不多一年总共有 60 天左右。 到了唐朝，官员已经不需要在官署寄宿了，下班后直接回家，于是休沐假就没了，把每五天休一天改成了每十天休一天，称为“旬假”，虽然例假少了，但节假日多了，综合下来唐朝官员每年的假日至少能达到 100 天。 宋朝是中国历史上生活最舒服的朝代，节假日多而且很多奇葩的节假日，实际休息日比唐朝还多。 到了元明清三朝，中央集权进一步发展，为了加强对社会的控制，官员工作自然不敢放松，旬假逐渐淡化甚至一度被取消。节日假也少得可怜。综合各种说法，明清两朝每年的假期最多不超过 50 天。 纵观古代假期长短的变化，本质上体现的不光是统治者人性化的增减，也是朝廷对社会管控程度的变化——越是专制的时代，就越需要加强对社会的管控，官员的假期也就越少。 言论1、 如果事先让你知道俄罗斯方块中的所有方块，并按照你的喜好排列他们，你会更加喜欢这个游戏吗？ –《这是做事的正确顺序吗》 2、 我们应该忘记自己有多少读者，只是持续不断的写，有纪律的写，无论心情或天气的好坏，一直写下去。在这个过程中，提高自己的写作能力，建立读者的信任，找到自己为什么要写 newsletter 的原因。 慢慢的，我们会习惯甚至爱上写 newsletter 这件事，而随之而来的更多的读者，只是对于我们额外的犒赏而已。 –《如何让你的 newsletter 胜出》 3、 我们以前还需要写事故报告，发现大家都很抗拒，虽然也不和任何工资/奖金挂钩，后来改成写叫「踩过的坑」，大家就好多了。 –《可甜CEO：青年管理者指南 职场必读》 4、 反人性的做不大，比如代餐；但把反人性变成督促反人性的就能做大，比如 K12 和托福 GRE 培训班。 –@彭萦 5、 （公众号 @生财有术 的一群大佬总结的经验教训，其中摘录了一些） 很多人能赚钱，但守不住钱。知进退很重要，血淋淋的教训太多了。第一要有预期控制，不要过度追求回报率。第二要有止损纪律并且严守。第三是学一点对冲策略，学会锁定收益。 副业是用来图发展，主业才是用来图生存的，但是大多数人都搞反了。如果你认为你的主业未来很有发展又能赚钱，但是当下不赚钱，那么建议你抛弃一切副业思想专注于主业的修炼。如果主业一般，那么就当一个养家糊口的事情干着，要利用业余时间找到更有发展的副业来干，这才是你未来的生存发展之本。 学习规则，利用规则，特别是学习罚则利用罚则。不允许做某事=如果做了某事，会遭受某某惩罚。在权衡行为和后果之后，我们会偶尔发现，一些罚则简直就是在鼓励我们做某某事。 –《五四青年节，分享 84 条实用赚钱建议》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 23 期）：程序员的酒后真言","slug":"weekly23","date":"2021-07-11T10:23:00.000Z","updated":"2021-07-11T10:26:18.085Z","comments":true,"path":"2021/07/11/weekly23/","link":"","permalink":"http://www.wmyskxz.com/2021/07/11/weekly23/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 直布罗陀机场，是世界上唯一一条与道路相交的机场跑道。幸运的是，这不是一个繁忙的机场。它每周仅处理大约 30 个航班，所有航班都往返于英国。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 直布罗陀机场，是世界上唯一一条与道路相交的机场跑道。幸运的是，这不是一个繁忙的机场。它每周仅处理大约 30 个航班，所有航班都往返于英国。 本周讨论：程序员的酒后真言（来源：阮一峰） 美国最大的论坛 Reddit，最近有一个热帖。 一个程序员说自己喝醉了，软件工程师已经当了10年，心里有好多话想说，”我可能会后悔今天说了这些话。” 他洋洋洒洒写了一大堆，如今已获得获得 10k+ 赞。内容很有意思，值得一读，下面是节选。 1）职业发展的最好方法是换公司。 2）技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。 3）工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。 4）我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。 5）如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。 6）好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。 7）作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。 8）网上的口水战，几乎都无关紧要，别去参与。 9）如果我发现自己是公司里面最厉害的工程师，那就该离开了。 10）我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。 11）技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。 12）如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。 13）对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。 14）测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。 15） 政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你将被禁锢在深奥的专用工具里面，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄中位数在 50 岁以上是有原因的。 16）再倒一杯酒。 17）大多数头衔都无关紧要，随便什么公司都可以有首席工程师。 18）手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。 19）当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。 20）有些技术太流行，我不得不用它。我心里就会很讨厌这种技术，但会把它推荐给客户，比如我恨 Jenkins，但把它推荐给新客户，我不觉得做错了。 21）成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。 22）发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。 23）我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。 24）算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。 25）做自己喜欢的事情并不重要，不要让我做讨厌的事情更重要。 26）越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。 27）即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。 28）人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。 29）我挣的钱还不错，对此心存感激，但还是需要省钱。 30）糟糕，我没酒了。 完） 热点新闻1、 最近，国外研究人员设计了一种看起来像日常 T 恤的面料，但可以使身体降温近 5°C。 2、 据国家互联网信息办公室官方微信消息，根据举报，经检测核实，“滴滴企业版”等 25 款 App 存在严重违法违规收集使用个人信息问题。依据相关规定，通知应用商店下架滴滴旗下 25 款 App。 3、 字节跳动表示，将于 2021 年 8 月 1 日起施行取消大小周制度，8 月开始有需求的团队和个人，可以通过系统提交加班申请。 4、 海地临时总理克劳德·约瑟夫 (Claude Joseph)表示，当地时间周二(7月6日)夜间，一群身份不明的武装分子突袭莫伊兹总统的私人宅第并开枪打死了总统若弗内尔·莫伊兹(Jovenel Moïse)，其妻玛蒂娜（Martine）也受伤住院。 5、 冰岛试行一周四天工作制度，工人工时缩短，但是薪酬不变。研究人员指出，这样做之后，大部分工作场所的生产力没有改变，甚至有所提升。 6、 苹果公司据报道将大量 iCloud 数据，存储在谷歌云，总量达到 800万 TB，单单今年的费用就是 3 亿美元，是谷歌云最大客户。 这表明，苹果自己的数据中心可能规模很小，根本存储不了它的所有数据。 文章1、四十分钟讲完三体（视频） 三体是非常经典的科幻类题材小说，如果你不想读纸质类的书籍，那么这个视频可以带你深入了解。 2、图形解释 SQL 连接类型（英文） 使用图形的形式，生动解释了 SQL 中的不同连接类型究竟是怎样连接的。 3、新手如果没有搭建环境，还能怎样快速练习写代码？ 很多时候，浇灭新手的不是什么复杂的 Coding，而是搭建编程环境。 文章介绍了很多「开箱即用」的编程环境，对于初学者来说无疑是个提高学习效率或保持编程热情的解决方案。 4、iOS 15 如何让您的应用程序启动更快（英文） 文章揭示了 iOS 15 是如何让程序更快的原因。 5、如何使用 Python 构建股票交易机器人（英文） 作者用 Python 搭建了一个简单的自动交易的机器人程序，虽然国内似乎没有接口实现，但看上去还是挺有趣的。 6、相机维修课程（英文） 在过去，相机维修技术人员需要跑到专门的学校学习，但现在所有的学习材料在互联网上都是公开的。 7、编程语言内存模型（英文） 这一篇文章揭示了一些通用的，被各大编程语言使用的内存模型。 8、Git 最佳实践（英文） 最佳实践因环境而异，并没有一个正确的答案，但仍然有一些 #git 的共识，需要提前了解，并且在某些情况下可以帮助您构建讨论以生成您自己的最佳实践。 好奇星人1、为什么许多游戏在存档时会提示「不要关闭电源」？ 第一，减少意外。 玩家所擅长的领域千差万别，不是每一个人都知道“写入磁盘时掉电可能会对数据乃至磁盘本身产生重大危害”——偏偏玩游戏的过程中存档又是一个非常频繁的操作。设备坏了事小，心血没了事大啊。 加上提示以后，如果真的因为关机丢失了存档，也可以很大程度上规避责任，避免和玩家扯皮。 第二，丢失存档的技术细节。 其实现代游戏，如果处理方式合适的话，丢失存档的概率可以做到非常低。存档的逻辑可以用伪代码这样表示： 功能：存档() 步骤 1. 将当前需要保存的数据全部整理出来，转换为一串纯数据 data 步骤 2. 打开存档文件 步骤 3. 写入存档数据 data 步骤 4. 关闭文件这一连串功能中，如果执行步骤 4 时关闭电源，大概率会丢失存档。 步骤 2~3 时关闭电源，有可能丢失存档，概率大小取决于存档大小，以及主机写文件的速度。 所以如果这块代码写的合适，存档容量不特别大，丢失存档的概率并不高。因关闭电源而丢失存档可以看成是巧合。 最后，也是可以防止玩家在存档时闲着没事儿做，给一句苦口婆心的忠告。 言论1、 软件开发机会如此丰富，以至于大多数雇主发现招聘专家开发人员几乎是不可能的。机会如此丰富，以至于尽管全世界有名副其实的大量新手开发人员，但他们中的每一个人都存在工作机会。 最后，软件工程没有任何把关。任何人都可以参加编码训练营，参加一些在线编码课程，并在第二天开始在 Upwork 上销售他们的服务。他们的工作产品可以立即投入生产，无需监管。 将这三者结合起来，很容易理解为什么有这么多糟糕的软件。软件正在吞噬世界，它的错误和安全漏洞也是如此。 –《为什么世界上有这么多垃圾软件》（英文） 2、 编码只是解决问题。学习编码不会花费您太多时间，但是您需要花费大量时间来培养敏锐的解决问题的能力。 –Twitter用户 3、 真正有效的减肥方式，是你要找到一种能够令你感到舒适的，同时又相对比较健康的饮食模式，按这个模式去践行就可以了。 也就是说：最核心的关键，是找到一种能够自发持续实践下去的饮食方式，而不是强行靠意志力「坚持」下去。 –《如何长期坚持做一件事情？》 4、 人类学习效率最高的方式，不是”读书 + 思考”，而是”观察 + 模仿”。 前者需要较长时间的注意力投入，后者只需要短时间注意力，更符合人类的天性。 –阮一峰 5、 公司不喜欢员工远程工作，因为觉得员工像在兼职，而公司却支付了全职的薪水。 公司的想法是，既然我支付了全职薪水，那么从早上9点到下午5点，我对你的所有时间、注意力和精力，拥有所有权。这种所有权的体现就是，这段时间你需要到我指定的办公场所，让我看着你在工作。 –《远程工作会摧毁老板》（英文） 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 22 期）：YouTube 知识转移革命","slug":"weekly22","date":"2021-07-04T07:51:00.000Z","updated":"2021-07-04T07:53:25.690Z","comments":true,"path":"2021/07/04/weekly22/","link":"","permalink":"http://www.wmyskxz.com/2021/07/04/weekly22/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 伦敦一家新的猫咪咖啡厅是 9 只救援猫咪的新家，在它们找到新主人前，它们将在这里与人类互动，适应人类的环境。但是对于猫咪来说，这种猫咪咖啡厅真的是一个健康且快乐的场所吗？","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 伦敦一家新的猫咪咖啡厅是 9 只救援猫咪的新家，在它们找到新主人前，它们将在这里与人类互动，适应人类的环境。但是对于猫咪来说，这种猫咪咖啡厅真的是一个健康且快乐的场所吗？ 本周讨论：YouTube 知识转移革命（素材来源：YouTube 知识转移革命） 朱利叶斯·叶戈 ( Julius Yego )在肯尼亚出生，年轻的他想要成长为一名有抱负的标枪运动员，但苦于找不到教练：在一个跑步者享有最高声望的国家，导师几乎不存在。 为了取得成功，他转而观看了挪威奥运会标枪运动员 Andreas Thorkildsen 的 YouTube 视频，并记录了详细的笔记并试图模仿他动作的精细细节。 叶戈因此在 2015 念北京世锦赛上获得金牌、在 2016 年里约热内卢奥运会上获得银牌，并保持世界纪录第三长的标枪投掷距离。 叶戈的崛起是由 YouTube 促成的。 然而，现代视频媒体被认为可能会缩短注意力并分散对较长形式的交流方式的注意力，例如书面文章或书籍。但被严重忽视的是，它开启了一种历史上前所未有的大规模隐性知识传播形式，促进了可能会丢失的知识的保存和传播。 隐性知识是无法通过口头或书面指令正确传播的知识，例如创造伟大艺术或评估初创公司的能力。 在视频大规模可用之前，隐性知识必须亲自传播，以便学习者可以密切观察知识并实时学习——例如，熟练的金属加工是教科书无法教授的。 由于这种强烈的地方性，提出了一个独特的强大的继承问题：如果一位木工大师不能将他的隐性知识传授给他店里的少数学徒，那么即使他写了关于它的书，知识也会永远丢失。 的确，有些人可以通过直接与掌握的对象互动，自己摸索来获得隐性知识，但这是非常困难的。能够发明自己的技术的真正自学者很少见，但许多人可以通过观察和模仿来学习。 事实是，能够真正从所学知识中学习的人很少，这就是为什么 2010 年代初期的大规模开放在线课程没有奏效的原因，95% 的注册学生甚至连一门课程都没有完成，而且逐年增加年学生保留率低于 10%。 但现在大量可用的实践者的视频记录完全改变了这一点。通过这些视频，学习者现在可以部分复制师徒关系，打开以前被个人访问封锁的技能领域和经济领域。 这种大规模传输视觉上明显的隐性知识的能力直到最近才在技术上成为可能： 高质量的数码相机已经变得足够便宜以供大众使用：此类摄像机的可用性将记录活动的手段分发到可能存储隐性知识的社会的所有角落和缝隙； 海量宽带互联网接入：它使我们能够以足够的质量按需观看录制的视频； 成熟的搜索引擎； 便携式屏幕无处不在； 所有这些因素都汇集在 YouTube 中，人们在 YouTube 上将他们的数字视频上传到互联网上的观看平台，该平台允许轻松搜索和聚合内容——所有这些都是大规模的。 如果今天谁争辩说，YouTube 有朝一日会被归入印刷机或者电报相同的类别，答案很可能会是肯定的。 热点新闻1、 最近，Brickit 发布了一个应用程序，它可以扫描你的乐高堆，然后进行大量运算可视化你现在可以搭建的物品。 2、 亚马逊有 14 项员工长期坚守的企业价值观，在本周四，就在创始人贝索斯即将卸任的前几天，又新增了两个要点：努力成为地球上最好的雇主、成功和规模带来广泛的责任。 3、 美国一家公司推出了一种 5 万美元以下的模块化住宅 不仅拥有全尺寸的厨房、浴室等一系列完整家电，并且方便搭建，水电费也更便宜。 4、 加拿大和美国西北部地区连日来受到高温热浪侵袭，多地气温直逼摄氏 50 度，突破过去的历史最高温纪录。 持续多日的热浪高温也造成美国加拿大数百人死亡。 极端的高温天气甚至让路面都变形了。 5、 7 月 2 日早些时候，墨西哥国家石油公司位于尤卡坦半岛西部海域、连接钻井平台的水下管道发生气体泄漏，海上燃起熊熊大火，火焰巨大，宛如“火眼”。目前大火已经被扑灭。 6、 近日，维他柠檬茶一位采购部主任，从背后捅了一名警察（属于恐怖分子行为）。 一家正常的公司，在员工做出杀人袭警的事情后，一般都会第一时间声明自己不支持员工行为，或者至少说一下“这是员工个人行为，和公司无关”。 然而维他奶第一时间传出来的通告却是下面这样。 “有关一位同事于事件中身故” 这样一种不健康又赫然支持暴徒、支持恐怖主义、支持台独的资金企业，我是不想再买他们家的产品了。 文章1、让团队更好的工程原则（英文） 一个还处于 MVP 状态的项目，介绍了一些实用啥的工程原则。 2、要求开发人员进行 QA 是行不通的（英文） Rainforest 是一家致力于构建无代码 QA 自动化测试的国外平台。在官方的博客中分析了让程序员进行 QA 和拥有一个独立 QA 团队的利弊，并最终得出：应该让对产品的业务成果负责的角色（例如产品经理）进行 QA 的结论。 3、中国共产党的一百年时间线 图文详细介绍回顾了中国共产党在这一个世纪里是如何发展壮大，又是如何巩固权力的过程。 4、漫画 | 浏览器一个比一个“无耻” User Agent 字符串之所以这么古怪， 要从 20 多年前的 Mosaic 说起。 5、A/N 显卡十年变化对比图标 几天前，网友 u/Vito_ponfe_Andariel 在 Reddit 上分享了基于 T4CFantasy 数据库的可视化图表，从而让我们更加直观地感受到了 A / N 两家显卡大厂在过去十年里的技术创新。 6、气候变化：拯救地球6个你意想不到的方法 解决气候变化可能是人类面临的最大挑战，世界各地有很多人在尝试用不同方法应对，有些方法可能让你意想不到。 7、我希望 Git 拥有的东西：提交组 在这样的纠缠图中，几乎很难找到任何你想找到的东西，现有的 Git 操作很难解决这样的问题，所以作者提出了新的解决思路：Git 支持提交组（就像矢量图形程序的“组”功能）。 8、团队管理的四大挑战——招人篇 人才是企业发展的核心驱动力。作者在创业公司待了三年时间，分享了一些值得学习的经验。 好奇星人1、从概率学上看，输一把睡觉vs赢一把睡觉，哪个胜率更高一些？ 先说结论：两种策略的赢率是一样的，但是赢率的波动性大小不同。如果你是高玩，胜率大于 0.5，那么采用赢了就睡的策略能更快睡觉。 假设你叫小明，玩一把游戏获胜的概率为 p，输的概率为 q = 1 - p，对应引入两个随机变量：输一把就睡 X 和赢一把就睡 Y。 1）什么时候能睡觉？ 计算游戏局数的期望值： 类似地，由对称性： 也就可以算出，如果小明胜率低于 50%，那么“输一把睡觉”能够更快地睡上觉，反之如果小明错误地采用了“赢一把睡觉”的策略，那么它平均需要玩： 因此对于菜鸟来说，赢一把就睡策略的潜台词就是我要通宵。 2）胜率如何？ 简单给出结论：如果每天采取同样的策略玩游戏，长此以往，两种策略的赢率是一样的，都是 p。 3）如何稳赢？ 假设小明现在有三种游戏策略：a. 赢一把就睡；b. 输一把就睡； c. 赢一把就睡； 假设小明是高玩，胜率趋近于 0.9，那么根据计算，可以看到随着游戏天数增加，三种策略的平均胜率很快趋向于 0.9，但”输一把就睡”的 error bar 更窄，说明胜得更稳。 但如果小明是菜鸡，那么采取赢一把就睡的策略，不仅能够爽玩，赢率也更稳定。 言论1、 我觉得每十年都在加速——确保你每一两年检查一下你的生活目标和幸福并做出调整，否则你可能会发现很多年都在眨眼之间。 –Hackernews读者 2、 衣服既是“功能性的”，也是“社交性的”。从功能上讲，衣服让我们保持温暖、凉爽和干燥，保护我们免受伤害，保护隐私，并帮助我们携带物品。但由于它们通常是他人可见的，因此衣服也让我们能够识别不同的群体，展示我们的独立性和创造力，并表明我们的财富、职业和社会地位。环境越温和，我们就越期望衣服的社会作用主导其功能作用。 信念也具有功能性和社会性。在功能上，根据我们的偏好，当我们选择我们的行为时，信念会通知我们。但是我们的许多信念也是社会性的，因为其他人会看到我们的信念并对其做出反应。因此，信念还可以让我们认同群体，展示我们的独立性和创造力，并表明我们的财富、职业和社会地位。 –《信仰就像衣服吗?》（英文） 3、 最新的趋势是，软件公司希望用户体验足够好，不需要用户文档。采用的方法是，不再投入专门的人员写用户手册，改为雇佣用户体验设计师。 –《软件技术写作是一个垂死的职业》（英文） 4、 当年轻人意识到中国共产党和我们一样年轻后，我们可以期待，下一个百年，会是什么光景。 –《越来越多年轻人觉得，中国共产党是浪漫的》 5、 Python 4.0也许永远都不会有！我和Python核心成员对Python 4.0一点都不兴趣！ –Python 创建者吉多 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 21 期）：高考的重要性，正在下降","slug":"weekly21","date":"2021-06-27T01:41:00.000Z","updated":"2021-06-27T01:45:54.812Z","comments":true,"path":"2021/06/27/weekly21/","link":"","permalink":"http://www.wmyskxz.com/2021/06/27/weekly21/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 新冠疫情之下，在印控克什米尔地区，喜马拉雅山脉深处的一些学童要走上半天才有网络信号上网课。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 新冠疫情之下，在印控克什米尔地区，喜马拉雅山脉深处的一些学童要走上半天才有网络信号上网课。 本周讨论：高考的重要性，正在下降（观点来源：子皮商论） 这个观点来自于「子皮商论」的一条视频，他的核心观点是：高考的地位会越来越低，并且学区房的地位以后也会越来越低。他给出了三点理由。 第一，高考在过去，会成为举国上下最关心的一件事，是因为这是当时人们上升通道的最大出口，也是全中国孩子最公平竞争的舞台。 不管你是贫寒子弟，还是达官显贵，谁家孩子在高考面前，都是人人平等。 当我们的人才选拔还很单一，找不到更好的方式时，的确，没有必要高考更好的工具了。 但是现在变了，真正的人才，只有高考这种方式才能筛选出来吗？ 应试教育的唯分数论，一方面缺陷越来越大，一方面呢，精细化的人才筛选方式越来越多，这个矛盾已经严重了。 越好的学校一定会跟越好的大学进行接轨，分数只是一个重要的参考系，但绝对不是唯一参考系。 第二，站在国家的大局考虑，中国未来三十年最缺的不是大学生，而是各类职业人才，比如工程师、技师。 真正搞基础研究的天才、有天赋的孩子，早就在各种竞赛、综合素质测评中就被挑出去了，要什么高考啊。 而平庸的人呢，上大学和没上大学区别并不存在巨大的鸿沟，反而容易高不成低不就：找问题一流，让ta解决问题却犯难。 所以我们需要那么多大学生吗？ 我们要的是一技之长的人，能为这个社会实实在在解决问题的人。 我们要的是真真切切提高高级工人、各种专业技能人员的报酬，而不是因为你有大学文凭，就该给你高薪，凭什么呢？ 第三，越来越多的迹象表明，我们的社会接下来会进入曾经的光荣时代。它一定会慢慢提倡多元价值观、多元职业的平等性。 新时代的工人、农民、科学家、老师、医生、商人都是平等的，相互尊重的，而且都是可爱的人。 所以，值得我们去尊重的是你的职业，是你为这个社会做了什么，而不是你的学历。 大学生不等于了不起，不等于被尊重。 未来可能除了基础科学，其他各个领域可能会越来越注重实效性，以结果挂帅，多问问做了什么，而不是考了什么文凭。 越来越多的职业院校、专业学院的地位会上升，我们需要那么多综合大学吗？未必呀。 你怎么看呢？ 热点新闻1、 剑桥大学公布了比特币电力消费指数报告，整个比特币网络占世界总发电量的 0.3%，总用电量的 0.34%，比孟加拉国、哥伦比亚一年的发电量还要多，仅次于智利（2016 年估计）。 比较有意思的数据是：仅在美国，永远在线但不活动的家用设备每年消耗的电量就可能为整个比特币网络供电 3 年。 2、 本周四早上，佛罗里达州南部的一栋公寓大楼突然坍塌。截止周四晚统计，至少有 4 人被确认死亡，另外 159 人仍然下落不明——这可能是美国历史上最严重的建筑物倒塌灾难之一。 3、 清华大学对今年通知书的外壳材质和立体二校门结构都进行了全新升级，激光雕刻、手工拼插的新版通知书颜色更加靓丽持久，立体结构更加稳固。 4、 近日，乐高推出了首批由废弃塑料瓶制成的积木，这是乐高迈向可持续发展的一大步。乐高称，旗下所有产品将会在 2030 年全部实现可持续化。 5、 6 月 24 日消息，微软发布 Windows 11 ，新一代 Windows 在图标、菜单栏、声音、性能上均有变化，并且还可以实现自定义电脑的新方法。 6、 GitHub 大幅改版 issue 功能，由原来的讨论区，转变为项目管理工具，提供了看板视图和表格视图（上图），大大增加了 issue 的任务属性。 文章1、每个程序员都应该知道的关于 SSD 的知识（英文） SSD 很大程度上已经取代了磁盘作为了标准存储介质，这一篇文章从程序员的角度，解释了 SSD 跟磁盘的不同。 2、Windows 11 介绍 | 微软官方（英文） 微软官方出品的 Windows 11 系统介绍。 3、如何睡个好觉 | 睡眠知识科普 非常详细的睡眠指南书。 4、如何快速入门一个新领域 作者以产品经理为例，介绍了如何入门一个新领域的思路和方法，其重点是搭建起自己的一套知识框架。 5、一个员工的离职成本到底有多高？ 员工的离职成本非常高，尤其在软件行业。 除了和传统企业一样，在员工离职时，会付出招聘、交接、培训成本外。离职率太高，对软件企业，还有一个极度恶劣的后果，那就是： 极大的加速软件系统的腐败。 因为软件是纯粹脑力劳动的结果，极度依赖软件工程师本人。因此，软件的交接就不简单是生产工具的交接，更是知识的传递。而只要有知识的传递就必然有丢失，有变形。因此一个离职频繁的团队，知识的反复交接，必然会丢失大量的细节，以致于到最后，接手的程序员对系统的理解是面目全非。 而且最严重的不仅是知识的丢失，更有责任心的丢失。 需要时刻诫勉自己：务必善待同事，因为在软件行业，人真的就是一切！ 6、猎聘发布《中国人力资本生态十年变迁白皮书（2011-2021）》 6 月 23 日，猎聘发布了《中国人力资本生态十年变迁白皮书（2011-2021）》。 白皮书涵盖十年间影响人力资本变革的技术及政策因素分析、热门领域机会与吸引力分析、人力资源领域变迁分析、求职者的转变分析、猎头行业的演变分析、未来十年人力资本趋势展望等六部分。 7、Unix 哲学基础（英文） 最容易使用的程序，是那些对用户的新知识要求最少的程序。 8、一份小团队项目管理的简易指南 作者分享了一些管理上的经验和指南，比较了几种项目模式的优劣，对于独立开发者或者小型开发团队比较具有参考价值。 好奇星人1、为什么「天舟二号」带上太空的菜是「鱼香肉丝」和「宫保鸡丁」？ 首先，神舟九号的航天食品已经快到 100 种之多了，「天舟二号」带上去的也绝对不止这两道菜。 那么为什么这两道菜品入选了载人飞船食物清单呢？ 好吃当然是重要因素，其他的原因包括不限于：1）没有渣，不掉粉，不会在失重的情况下飘得到处都是；2）都很方便做成「软罐头（常温料理包）」的形式常温保存；3）这两者都属于荤素搭配，用料比较丰富，从营养价值上来看相对比较均衡一些； 2、中华文明对人类有哪些主要贡献？ 看图说话： 可以感受一下，如果没有这些成就，当下生活将会变得如何不同。 3、蚊子怎么吸血？ 夏天是蓝星人和蚊子之间的战斗。可是你有没有好奇过，蚊子究竟是怎样吸血的呢？ 看一下蚊子嘴巴的构造，就知道这究竟有多复杂了。（总之不是一根针戳你那么简单） 言论1、 其实，计算机行业恐怕是问题最不严重的了。 这是因为，市场对真正会做事的人，还是一直有需求的。有需求，就会有人来满足需求。这才导致大量优质国外书籍被翻译引进；在这些书籍的对比下，那些“考试神书”才显得质量低劣。 –知乎讨论 | 为什么高质量计算机书籍几乎都是外国人写的？ 2、 几年前我们希望我们的 Web 应用程序动态呈现 html 并且不想每次用户转到新页面时都刷新整个页面。 所以我们一直在构建我们的前端框架，十年后我们加载了 10 万行 javascript 到前端，让 Web 应用程序顺利运行，天知道他们在做什么。 –通过添加更多来解决软件问题（英文） 3、 随着互联网巨头不断反思加班和大小周的合理性，中国的互联网行业或许才有机会真正成为一个技术密集型产业，而不是劳动密集型产业。 –《快手取消大小周，互联网“反内卷”时代来临？》 4、 美国学生贷款总额达 1.7 万亿美元，借债人超 4500 万，占全国总人口近 14%。这意味着，至少 9 个美国人中，就有 1 人背负学生贷款。 –美国大学生想躺平：读书4年还贷40年，300万人60岁还背债 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 20 期）：你是飞鸟还是青蛙？","slug":"weekly20","date":"2021-06-20T01:59:00.000Z","updated":"2021-06-20T02:02:51.060Z","comments":true,"path":"2021/06/20/weekly20/","link":"","permalink":"http://www.wmyskxz.com/2021/06/20/weekly20/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 106 岁的艾琳·克莱默（Eileen Kramer）在 100 岁生日之后，反而迎来她创作的一段高峰时期。她一生在全求各地巡演，现在仍然在跳舞。 本周讨论：你是飞鸟还是青蛙？2020 年 2 月 28 日，著名数学物理学家弗里曼·戴森（Freeman Dyson）在美国普林斯顿因病去世，终年 96 岁。 今天想跟大家分享，这位杰出的数学物理学家生前的一个观点，这个观点来自于他 2008 年的一篇演讲《鸟和青蛙》： 有些数学家是鸟，其他的则是青蛙。鸟翱翔在高高的天空，俯瞰延伸至遥远地平线的广袤的数学远景。他们喜欢那些统一我们思想、并将不同领域的诸多问题整合起来的概念。青蛙生活在天空下的泥地里，只看到周围生长的花儿。他们乐于探索特定问题的细节，一次只解决一个问题。我碰巧是一只青蛙，但我的许多最好朋友都是鸟。 显然，用这个标准去衡量，爱因斯坦绝对是一只飞鸟，而且是人类历史上，可能飞得最高的一只鸟。 因为他一生擅长跨界思维整合，一生立志于大一统理论。这样的鸟历史上，还有很多，例如：笛卡尔、希尔伯特、杨振宁等。 而像培根、居里夫人、法拉第、孟德尔，这些都是青蛙，他们一生只想弄清楚一个问题。 那么谁好谁坏呢？佛里曼·曼森说： 数学既需要鸟也需要青蛙。数学丰富又美丽，因为鸟赋予它辽阔壮观的远景，青蛙则澄清了它错综复杂的细节。 如果声称鸟比青蛙更好，因为它们看得更遥远，或者青蛙比鸟更好，因为它们更加深刻，那么这些都是愚蠢的见解。数学的世界既辽阔又深刻，我们需要鸟们和青蛙们协同努力来探索。 对应现实世界的例子有很多。 例如，投资人就更像是鸟，他们比创业者看过更多的项目、更多的商业模式，比创业者能看到更多的风险，而具体到某个领域，投资人的纵深能力就会捉襟见肘。 而创业者呢，更像是青蛙。大多数创业者深陷在自己的一亩三分地，低头拉车，他们对自己的行业了如指掌，纵向足够深，但是对商业的横向底层逻辑，就不会太精通。 聚焦到投资人和创业者的群体个人，又进一步分成了鸟和青蛙。 现实世界也是既需要鸟也需要青蛙。有几点建议是： 1）认清自己是青蛙还是飞鸟；2）利用好自己的优势，而不是补充自己的短板；3）在一个体系里，去弥补自己的不足； 共勉。 热点新闻1、 微软表示，它将在 2025 年停止支持 Windows 10。这是微软第一次下一代版本还没有公布就宣布停止支持上一代版本。 2、 朝鲜领导人金正恩正式承认朝鲜正面临粮食短缺危机。金正恩在劳动党中央委员会会议上称：“人民（面临）的粮食状况现在越来越紧张”。 他说由于去年台风引发洪灾，农业部门未能实现粮食目标。 3、 美国国家地理学会宣布，南极洲周围海域被定名为南大洋（Southern Ocean，又译南冰洋、南极海），正式承认南大洋为地球第五大洋。 4、 最近，中国科学家成功让雄性大鼠“怀孕”并顺利诞下后代，打破自古以来的自然界规律。 据介绍，他们从海马身上得到启发，通过手术将雌性大鼠和雄性大鼠连接到一起并完成血液共享以此构建“雄性怀孕模型”，从而使胚胎在“雄性子宫”（移植而来）中存活。 5、 6 月 19 日消息，深圳西部滨海、毗邻前海湾的大铲湾港区一带近日已经高耸起打桩机等大型机械，腾讯全球总部――“互联网 +”未来科技城正动土兴建。 文章1、Kafka 图解指南·儿童读物（英文） 图文的方式，以故事来讲解 Kafka，甚至面向的群体是儿童。 2、如何成为一个糟糕的开发者（英文） 文章列举了一些成为糟糕开发者的要素，例如乐于编写更多代码、永远不要假设写的代码存在错误等，如果想成为更好的开发者，你需要知道应该避免什么。 3、如何将字节大小格式化为人类可读格式（英文） StackOverflow 有一个复制次数很多的有趣问题，简单来说就是如何将 123,456,789 字节 之类的格式格式化为 123.5 MB 作者最初的答案版本在十年前写的，但最近修复了 BUG，文章末尾有最终的代码，评论也几乎全是“哇塞”。 4、负责增长两个月后的总结 这里面记录了一些关于产品、战略、组织的增长条目，每一条都挺实用的，除了最后一条。 5、如何使用网络唤醒计算机 教你如何设置，达到使用网络消息唤醒计算机的效果。 6、为什么 Python 不是未来的编程语言（英文） 文章说明了 Python 的存在几点问题，包括不限于速度、作用于、Lambda 表达式等。 7、地球改变之年 | 纪录片（视频） 去年 4 月，一张照片刷爆了印度的社交网络，在印度北边某小城的东北方向，30 年来，人们第一次在城里看见传说中的“喜马拉雅山”，以往它被厚厚的空气污染物挡住。 直到 2020 年，印度封城仅仅 12 天，这一座山，就逐渐现出真身。 不仅仅是印度，随着人类活动大幅减少，地球上的每个角落都发生了神奇的改变。 8、如何让你的 Windows 变得 mac 里 mac 气 喜欢 Mac 外观的朋友可以上车，还是非常美观的。 好奇星人1、谣言被揭穿：宽轮胎并不慢（英文） 你是否觉得骑自行车时，窄轮胎会比宽轮胎更快呢？这当然是你的错觉，原因有两个： 轮胎越窄，传递给骑手的能量越多，就像一个豆袋掉在地上而没有反弹——所有的能量都被豆子之间的摩擦吸收了。这就让你产生了“更快”的感觉，因为你本身的反馈更明显。 我们骑得越快，自行车振动的频率就越高，因为我们的轮胎以更高的速度遇到道路不规则。然而，窄轮胎也会增加它们传递的振动频率。基本上，窄轮胎的自行车感觉更快，即使它实际上可能更慢。 总之结论是：轮胎宽度会影响自行车的感觉，但不会影响其速度。 言论1、 对存储系统和 CPU 进行测试以确保在大规模使用中不会发生错误在技术和经济上都是不可行的。 即使可以说服硬件供应商为可靠性投入更多资源，这也不会消除软件对返回的核心计算结果保持适当怀疑的需要。 –《大规模的不可靠性》（英文） 2、 一项长期开展的全球调查显示，日益增长的不平等感正在破坏对社会制度和资本主义的信任。 人们不再相信努力工作会带来更好的生活。 –《调查显示人们不再相信努力工作会带来更好的生活》（英文） 3、 我觉得今天的互联网就像一个现代化的购物中心，枯燥乏味，只有主品牌服装店、美食广场，没有其他很多东西。而我觉得旧的互联网更像是一个令人兴奋的城市游乐场。 –《我想念旧的互联网》 4、 也许鸡汤可以治疗抑郁症。 这个争议性的说法，不只是来自深夜电视导购节目里的江湖郎中，耶鲁大学社会心理学家约翰·巴什(John Bargh)也是这么说的。 –《TED演讲治不好你的抑郁症》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 19 期）：学校扼杀创造力","slug":"weekly19","date":"2021-06-13T01:00:00.000Z","updated":"2021-06-13T00:55:16.924Z","comments":true,"path":"2021/06/13/weekly19/","link":"","permalink":"http://www.wmyskxz.com/2021/06/13/weekly19/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 据华尔街日报报道，黑客从麦当劳在美国、韩国和台湾的计算机系统窃取了数据，包括客户电子邮件、电话号码和地址。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 据华尔街日报报道，黑客从麦当劳在美国、韩国和台湾的计算机系统窃取了数据，包括客户电子邮件、电话号码和地址。 本周讨论：学校扼杀创造力–Ken Robinson | TED 2006 TED 是一个非盈利性的组织，其创办目的旨在传播有独特的思想来改变生活态度，进而改变世界。 它专门邀请站在各个领域前沿的创新者和实践家来做 18 分钟以内的演讲。这 25 年以来在这些演讲者中，已经包括了微软总裁比尔·盖茨、美国政治人物及环境学家阿尔·戈尔、英国生物学家珍·古道尔、美国作家伊丽莎白·吉尔伯特等人物。 但如果你按照受欢迎程度排序，你会发现第一名的视频名称叫做：Do schools kill creativity?（学校会扼杀创造力吗？） 史上最受欢迎的 TED 演讲，得出了一个令人沮丧的结论：我们所受的教育让我们丧失了创造力。 教授说了一个故事： 一个小女孩正在上绘画课。小女孩只有六岁，她坐在教室的后排正在画画，而她的老师评价她几乎从来不认真听讲，出了绘画课。老师饶有兴趣地走过去问她：“你在画什么？”小女孩说：“我在画上帝。”老师说：“可是没人知道上帝长什么样？”小女孩说：“他们很快就会知道了。” 这个故事告诉我们，孩子们愿意冒险。对于未知的事物，他们愿意去尝试。即使尝试的结果是错误的，他们也不惧怕。当然，我并不认为错误的尝试等同于创新。 但我们都知道，如果你不打算做错误的尝试，你永远不会创造出新东西。如果你不让孩子们做错误的尝试，等他们长大了，大多数孩子就会丧失创新的能力，惧怕错误的尝试。我们不能容忍错误，这就使得现在的教育体系成为最不能容忍错误的领域。这样做的后果就是我们的教育体制正在扼杀孩子们的创造力。 当你周游世界，你会发现每个国家的教育体系都存在相同的科学等级制度，排在最前面的是数学和语言，接下去是人文学科，艺术排在最后，世界上所有国家都这样。 注重培养学术能力的观点根植于我们的教育体系之中，形成这种状况的原因是，所有国家的教育体系在最初建立时，（也就是在 19 世纪之前，那是教育还不是公共事业）是为了满足工业化发展的需求。 所以，对工作最实用的科目是最重要的科目，世界各个国家的公共教育也都是一种按部就班的程序，最终目标是为了考入大学。 这造成的后果就是许多很有天赋的、有创造力的学生被钝化了。因为这些学生发现他们的专长在学校并不受重视甚至还受到蔑视。 根据联合国教科文组织的统计，今后 30 年全世界毕业的学生将超过过去的总和，这是人口增长造成的，这关系到我们谈论的许多话题，包括技术和技术变革对生产力的影响、人口统计学及人口爆炸。很快，文凭就不再有含金量了。在以前有文凭就有工作，那时候如果你没工作，那是因为你不想找工作。 但现在的状况是，孩子们有文凭却经常呆在家里打电脑游戏，因为以前只要学士学位的工作岗位，现在需要硕士学位，还没毕业的孩子将来就得有个博士学位才好找工作。这就是学术学位的通货膨胀，这是整个教育体系坍塌的前兆，我们必须从根本上反思我们评价好学生的标准。 视频中也提到了培养人才有三个原则。 第一，多样化。我们认知世界的角度不同，有人从视觉角度，有的从听觉角度，有的从美学角度，有的从抽象的角度，有的从动态的角度。 第二，好学生应该是充满活力的。如果观察一下人类大脑的内部组织，就会发现大脑发育具有关联性，大脑不应该被分成几部分。应该创造性地把大脑看作一整套工序，生产有价值的原创想法的工序。这种原创想法往往来自互动的思考方式，而不是呆板的常规模式。 第三，个性化。相信对于未来，我们的唯一出路，是贯彻一种新的人性化生态的思想，也就是说我们应该重新定义人类能力的多样化。我们的教育体系培养我们的方式，正如我们开采地球的方式——以功利为目的。但这种方式对于未来将不再适用。我们必须重新思考那些最基本的准则，包括教育孩子的准则。 共勉。 热点新闻1、 6 月 7 日，武汉一高考考生用手机拍下试题上传小猿搜题 APP，被工作人员发现后截图举报，随即被取消考试资格，各科成绩无效。 2、 亚马逊公司（Amazon）创始人杰夫·贝佐斯（Jeff Bezos）表示，他将和弟弟作为蓝色起源（Blue Origin）的首批乘客之一进入太空。蓝色起源是贝佐斯创办的太空旅行公司。 目前太空舱里这个座位的竞拍价已达到 280 万美元。 3、 萨尔瓦多总统周三宣布，该国的国营地热能源公用事业公司将开始使用来自火山的电力进行比特币开采。 与此同时，该国也是世界上第一个正式将比特币归类为法定货币的国家。 4、 宾夕法尼亚州立大学的交通工程教授，最近研究发现，取消左转，可以让交通更有效，对公众更安全。 5、 6 月 10 日，一款迄今效果最好的减肥药物在美国上市，这距离它收到美国食品药品监督管理局（FDA）的批准不到一周。 今年早些时候发表的一项研究表明，每周打一针这款名为司美格鲁肽的药物，经过 68 周的治疗，受试者平均减重近 15%。有些人减得更多，超过三分之一的受试者减重 20% 以上。 6、 最近，光子工作室计划试行“强制不加班双休”的政策，对比同行的 996，光子工作室员工每周的上班总时间为 49.5 小时（午休 1 小时），比 996 少 16.5 小时，相当于少上一天半的班。 7、 美国爱荷华大学的研究人员现在发现，北极光是由地磁风暴期间强大的电磁波产生的，并首次在实验室验证北极光产生原理。 文章1、海底电缆地图 2021（英文） 可以浏览到最新的全球海底电缆建设情况，包括 464 个电缆系统和 1245 个目前正在使用或在建的。 2、新晋总监生存指南终章 这个系列总共有五篇，从建立指标、制定 OKR、项目执行到人才运营以及构建团队信息通道等各个方面做了详细地论述。 3、一张图带你看完 WWDC21 Apple 在本届 WWDC21 开幕式上发布了 iOS、iPadOS、macOS 和 watchOS 的最新版。如果你没有熬夜看发布会，不用担心，少数派不仅整理了发布会的详细回顾文章，还连夜赶制了发布会要点的一图流，让你用最简单直观的方式迅速了解本届 WWDC 开幕式上的全新动态。 4、一份不完整的高级工程师需要的技能清单（除了编码）（英文） 一份不完整的软技能清单。 5、2021 年 10 大网页设计趋势报告 互联网世界正在高速发展，设计也正不断地适应着身边持续增长的互联网世界。 6、高考作弊攻防战 | 回形针（视频） 如何在高考当中作弊？官方有哪些高科技反作弊手段？ 7、塑造世界的三种重要力量（英文） 1）现代经济的人口转变；2）财富不平等达到了不可避免的突破点；3）获取信息可以弥补过去造成社会无知的鸿沟； 8、非 CS 科班自学蜕变 Google 大神的励志故事 之前很早就有耳闻过一个名叫 John Washam 的外国小哥自学编程的励志故事，还曾一度登上 GitHub 热度榜。 他的故事说来也挺励志。为了让自己从一个非 CS 科班的自学党蜕变成 Google 的软件工程师，每天坚持自学 8~12 小时，持续了数月之后，他如愿以偿，成为了一名大厂软件开发工程师。 重点是这位小哥也乐于分享，他将自己成为一个软件工程师的学习历程整理成了一个丰富的 GitHub 资源仓库并开源了出来，而且一度被称为 GitHub 上最励志的计算机自学教程！ 好奇星人1、都是可乐，麦当劳的为什么这么好喝？ 麦当劳可乐赢得口碑最重要的原因就是它真正做到了低温。 这一是与口腔温度相差很大的低温本身就能引起舌头上味觉感受器的兴奋，二来也是因为保持低温能够锁住更多的二氧化碳，又具有适当的甜度。 在官方的解释中，还提到了吸管的作用。麦当劳的吸管相比其他快餐店的更粗一些，更粗的吸管意味着更多的可乐入口，从而带来更多的碳酸刺激，所以提升了畅饮感受。 2、为什么雪糕化了再冻上就变成冰了？ 原因在于缺失了一个关键步骤。雪糕在生产的时候，有一步非常重要的工艺：一边降温使得雪糕凝固，一边搅拌使得雪糕混入大量空气。 因为这项工艺，我们买到的雪糕，一般都含有 30%-50% 的空气。 雪糕通常由几部分组成：水、蛋白质、油脂、糖。 水和油脂互不相溶，这个步骤能让雪糕成为一个混合且相对稳定的体系。而且因为混入了空气，它能让成品的味道、质地和外观变得更优秀。 但一旦雪糕融化，这个体系就不稳定了。 言论1、 游戏行业收入高，单纯的依靠高收入，已经不能满足部分人群的需求了，50万和60万差别很大吗？真不算太大，但是加班和不加班差别就很大了。随着员工水平提升，年薪增加，会越来越重视加班程度，加班少的企业，哪怕给的少点，也更容易吸引优秀员工。 –@知乎用户 2、 其实也不是一定要参与这种游戏，你也可以降低物质欲，选择不与其他人竞争的生活。但是，如果已经身在其中，或者不得不参与，那么下面几条《吃豆人》游戏的快速过关策略，似乎可以参考。 （1）不能留在原地，妖怪会感知你的位置。 （2）必须时刻在前进。 （3） 一旦前面的路上出现妖怪，必须立刻改道。 （4）尽快吃掉离你最近的能量豆，取得阶段性成果。 –《生活就像吃豆人游戏》@阮一峰 3、 其实当时真的没有想到票房会这么好，电影演的也是大家可以看到，我看了一会看不下去了，我就没看，演的其实我真不觉得怎么好，但是票房超过 50 亿，后来我一想我们唯一给出的解释就是，疫情把人给憋坏了，憋的大家都出不来，有这么一个电影，男女老少，老幼咸宜，大家结着伴儿去看电影。这个电影是真的没想到，所有的人工智能模型去推测，都没推测出来，所以我觉得这个AI基本上是以骗人为主，以忽悠为主，所以别再相信了。 –投资人谈《你好，李焕英》 4、 现实太复杂，价值实现的时间周期，则有长有短，短的也许下一秒就能够涨到你的目标价位，长的则可能要用数代人来体会。如果非要选择一个东西来作为信仰的话，选择时间总会没错。 –《坚信长期的力量——世界本就如此》 5、 管理是阻止开发人员创建满足迫切需求的产品的真正问题。 –开发人员无法修复糟糕的管理（英文） 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 18 期）：为什么现代人的时间越来越少？","slug":"weekly18","date":"2021-06-06T01:53:45.000Z","updated":"2021-06-06T01:53:53.408Z","comments":true,"path":"2021/06/06/weekly18/","link":"","permalink":"http://www.wmyskxz.com/2021/06/06/weekly18/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 2021 年 6 月 3 日下午，象群在昆明市晋宁区双河乡活动。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 2021 年 6 月 3 日下午，象群在昆明市晋宁区双河乡活动。 本周讨论：为什么现代人的时间越来越少？（内容引用：得到·邵恒头条） 最近，关于“躺平”的讨论非常热烈。但不管你对于这个词保持怎样的态度，我想在这件事情上，大家都是有共识的——那就是年轻人的压力越来越大，自己被逼成了一台工作机器，但是对于改变现状又无能为力。 我们经常说一个人应该找到“生活和工作”的平衡，但为什么随着时代的进步，这种平衡越来越难找到了呢？ “人生学院”（英国作家阿兰·德波顿成立的一个教育组织，他们希望通过教育，缓解现代人的心理压力）上有一篇文章叫做《怎样不让工作毁掉你的生活》 ，它揭示了一个事实，那就是我们觉得现代化能让我们更好享受生活，但其实让生活被挤压的罪魁祸首，正是现代化。 文章列举了三个原因，它们都是现代化带来的。 第一个原因，那就是现代化带来的通讯技术进步，让我们生活和工作的边界被不断打破。这一点我们都理解：老板随时能在微信上找到你，你最多能在飞机上能获得片刻安宁。 第二个原因是市场经济制度带来的竞争。 充分竞争是现代市场经济的重要特征。在有效市场理论当中，竞争是一种应该被鼓励的行为，因为竞争会给消费者带来一系列的好处，比如更低的产品价格，更丰富的产品选择。 而一个市场有效的标志，按理说就应该是竞争越来越激烈，让这个领域的利润越来越趋近于零，商品越来越便宜。 竞争的目的并不是为了让生产者受益，而是为了让消费的人受益。 但是，我们每个人都有双重身份：我们既是消费者，也是生产者。当我们作为消费者的利益被重视的时候，这意味着我们作为生产者的利益在被牺牲掉。当我们追求更便宜、更好的商品，我们所在的厂商、公司，也不得不提升自身的效率，力求在竞争中获胜。 理论上来说，在这样的机制下，如果没有适当的干预，生产者内部的员工越来越累，越来越内卷，是每个领域都会发生的必然趋势。 第三个原因，是现代化让我们的嫉妒心增加了。 我们不仅在跟朋友圈那些“看起来过得比自己好的人”比较，因为传媒的发展，我们常常是在和全世界最出色的那些人比较，比如明星、富豪。 在这样的比较当中，只有极少数的人能够获得内心的平静。人类的嫉妒心被广泛唤起，这让我们会更拼命工作。 这篇文章听起来挺扎心的，在作者的观点中，做不到工作和生活的平衡是我们享受现代生活的必然副作用。 但作为“惜命”的一代人，还是希望大家身体要紧。🙏共勉。 热点新闻1、 中共中央政治局 5 月 31 日召开会议，听取“十四五”时期积极应对人口老龄化重大政策举措汇报，审议《关于优化生育政策促进人口长期均衡发展的决定》，开放三胎政策。 2、 南非统计局每个季度都会发布失业数据，最新的数据显示，15 到 34 岁的年轻人中不仅有 43% 失业。而且他们也没有接受“教育或培训”。 3、 最近，美国卖掉了今年 2 月份扣押的一艘伊朗油轮上载运的大约 200 万桶石油，获利 1.1 亿美元（约合 7 亿元人民币） 4、 6 月 1 日，清华大学迎来一位特殊的学生，名为华智冰，她是一位女生，智商和情商超高，不仅颜值出众，还很有艺术细胞，能绘画，能题诗，还能创作音乐！ 5、 6 月 2 日，华为召开鸿蒙操作系统及华为全场景新品发布会。 6、 近日，微信公号「计算机世界」发布消息称，《计算机世界》报停止纸本发行。《计算机世界》报拟于 2021 年 6 月正式停止纸质版的出版与发行。总 1844 期是《计算机世界》报以纸质版形式面向读者的最后一期。 7、 带着全世界代码跑的传奇问答网站，计算机学子真正的老师——Stack Overflow（SO）近日被以 18 亿美元收购了。 文章1、对快餐式修图不满意？收下这份六年 VSCO 使用经验 从这篇文章不仅能感受到作者对于这款软件的喜爱，也可以学习到 VSCO 的各种实用技巧。 2、斯坦福大学 2021 CS 课程（英文） 一个在线 Google 文档，其中收录了 2021 年斯坦福大学公开所有授课的 CS 课程列表。 3、官方揭秘！你的颜色是这样算出来的…… 这一篇文章揭秘了上周三朋友圈刷屏的主导色，是如何被计算出来的。 4、怎样找到喜欢的事情？ 一篇心理学的文章，对于「怎样找到喜欢的事」，这是作者 Lachel 的答案。 5、我为什么还在使用钢笔？ 如今，钢笔这种古老而又年轻的书写工具早已不是市场主流，但钢笔的使用者、爱好者仍然不在少数。如果你仍然对钢笔感兴趣，可以看看。 6、使用 Notion API 建立自己的账本 Notion 最近开放了 API，作者详细介绍如何写一个 Python 脚本，调用 Notion API，将支付宝和微信导出的交易记录，输入 Notion 形成一个账本。 7、我的外包经历（英文） 作者讲述了自己的一段外包经历，自从把软件外包出去，就开始噩梦不断。 8、CAP 定理解读（英文） 这篇文章从学术角度，详细解读分布式系统的 CAP 定理，写得很好。CAP 定理的核心含义就是，发生故障时，开发者必须选择，优先满足一致性还是可用性。 好奇星人1、长颈鹿耳朵痒了怎么办？ 对，就互相挠耳朵。文中最后一句话特别有意思：你有找到你的长颈鹿群吗？ 新奇1、 某国外网友的参赛作品掉到了地上，重新制作太麻烦了，直接换了个名字叫《挤地铁》，竟然获奖了！ 言论1、 生产力的真正秘诀是反过来：倾听你的身体。饿了就吃饭，累了就睡觉，无聊的时候休息一下，做一些看起来很有趣的项目。 –《如何提高生产力》 2、 一天玩下来，只感觉到一个字“累”。我不知道为什么要我去调查蝗虫，明明我发现的每个证据警察都已知道；也不明白庄园内的摩尔，怎么会有那么多信物、礼物，要我在地图间来回奔波，充当他们之间的传声筒。 –一个晚上后，我终于做完了《摩尔庄园》的任务 3、 现在的问题是结婚率上不去，离婚率高，生育率低，这并不是因为政策没放开，或者是年轻人不想要爱情，不想要孩子，而是条件不充足。 –如何看待我国将进一步优化生育政策，一对夫妻可以生育三个子女？@知乎网友 4、 中国的学术硕士是一个非常尴尬的学位， 毕业生的理论能力和实践能力都不强。如果想留在学术界，必须再读一个博士学位；如果去企业，跟那些两三年前就进公司的本科生相比，能力相差不大，却比人家少几年的实践锻炼。 正是因为看到这一点，国家才最终决定，不发展学术硕士了，高层次的学术人才就是本科毕业直攻博士。硕士学位以后只用来培养专业硕士，以及像美国的很多研究型大学一样，读博士读不下去的同学，就发一个硕士学位，安慰一下，方便他找工作。 –《再见了，学术硕士》阮一峰 5、 工作和生活是两件需要同一个主体，你，投入身心的事情。你可以把两件都做得马马虎虎，你可以把其中一件做得不错另一件做得挺糟，你也可以把其中一件做得出类拔萃另一件完全不做。但你没法两头都做好，因为没有平行世界。 –《Work Life Balance的神话》Lenciel 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 17 期）：国家对比特币目前是什么态度？","slug":"weekly17","date":"2021-05-29T23:15:45.000Z","updated":"2021-05-29T23:58:45.557Z","comments":true,"path":"2021/05/30/weekly17/","link":"","permalink":"http://www.wmyskxz.com/2021/05/30/weekly17/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 国王大道位于印度首都的中心，对德里来说，相当于纽约的中央公园，或巴黎的香谢丽舍。为了修建新的总理官邸，现在的国王大道成了建筑工地。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 国王大道位于印度首都的中心，对德里来说，相当于纽约的中央公园，或巴黎的香谢丽舍。为了修建新的总理官邸，现在的国王大道成了建筑工地。 本周讨论：国家对比特币目前是什么态度？（内容来自：公众号@微月人话） 从单价 9000 美元到超过 6.4 万美元，再到一度跌破 3 万美元，加密货币比特币在一年时间里走出“过山车”行情。一边“造富”，一边“割韭菜”，剧烈波动表象下，比特币真实价值几何？应如何看待加密货币？ 首先，国家的基本态度仍然是在 2013 年文件中明确的。 2013 年 12 月 5 日，人民银行、工信部、银监会、证监会和保监会（注：原银监会和保监会后合并为银保监会）等五部委发布《关于防范比特币风险的通知》（以下简称“2013年通知”）。 在中央政府门户网站上，就此通知，发布了“人民银行相关负责人就比特币相关事宜答记者问”。 其中最核心的观点是：比特币“不是由货币当局发行，不具有法偿性与强制性等货币属性，并不是真正意义的货币。从性质上看，比特币是一种特定的虚拟商品，不具有与货币等同的法律地位，不能且不应作为货币在市场上流通使用。”，“比特币交易作为一种互联网上的商品买卖行为，普通民众在自担风险的前提下，拥有参与的自由。” 在人行的官网上，也有关于答记者问的文章，并且有对文件明确的解读： 《通知》要求，现阶段，各金融机构和支付机构不得以比特币为产品或服务定价，不得买卖或作为中央对手买卖比特币，不得承保与比特币相关的保险业务或将比特币纳入保险责任范围，不得直接或间接为客户提供其他与比特币相关的服务，包括：为客户提供比特币登记、交易、清算、结算等服务；接受比特币或以比特币作为支付结算工具；开展比特币与人民币及外币的兑换服务；开展比特币的储存、托管、抵押等业务；发行与比特币相关的金融产品；将比特币作为信托、基金等投资的投资标的等。 这里说的很明确，金融机构（如银行、证券、保险等）和支付机构（如支付宝、财付通、银联支付等）不能买卖比特币，不能拿比特币作为产品的定价，也不能为客户提供任何与比特币相关的服务，不管是直接的还是间接的。 所以，不久之后，2014 年 4 月至 5 月，各大银行纷纷声明： “为保护社会公众的财产权益，防范洗钱风险，维护人民币的法定货币地位，从即日起，任何机构和个人不得将我行账户用于比特币、莱特币等的交易资金充值及提现、购买及销售相关交易充值码等活动，不得通过我行账户划转相关交易资金。一经发现，我行有权采取暂停相关账户交易、注销相关账户等措施。” 由于很多人并不知道 2014 年的那波声明，以至于看到最近中信银行声明的时候，还以为是新的举措。 监管在 2013 年的主要担心，是比特币猛涨猛跌带来的金融风险，以及不法分子利用比特币进行犯罪活动的风险。 到了 2017 年，打击的主要是代币发行（即 ICO），本质上是保护老百姓不要被 ICO 这种融资行为割了韭菜，不要把手中价值比较高的比特币、以太币换成其他山寨币、空气币，垃圾币。 然后，今年五月以来，主要发生了五件事：1）中国互联网金融协会、中国银行业协会、中国支付清算协会联合发布《关于防范虚拟货币交易炒作风险的公告》；2）有关金融委会议的报道，提到“打击比特币挖矿和交易行为”；3）内蒙古拟打击挖矿；4）传央行约谈交易平台；5）新华社发文探讨比特币价值问题； 目前国家对比特币（泛指所有虚拟货币）的总体态度，做个总结就是： 比特币是一种虚拟商品，不是货币。 普通民众投资比特币是合法的，是一种“另类投资”，买卖比特币是普通民众的自由。 要坚决打击利用比特币进行洗钱、传销、诈骗、非法集资等违法犯罪行为。 要限制甚至禁止“挖矿”。 要保护和教育普通民众，一是不要涉入违法行为；二是注意投资风险，防范资金损失；三是如果不太懂，最好不要碰了。 共勉。 热点新闻1、 世卫组织研究发现，一年内有超过 74.5 万人因过度工作而死亡。 2、 中国甘肃白银周六（5月22日）发生一起严重的马拉松越野赛事故，21名参赛者在比赛中身亡。 3、 5 月 28 日晚，在广汉三星堆博物馆举行的三星堆文化全球推广活动中，一件神秘的国宝级文物首次亮相：来自三星堆遗址 3 号祭祀坑的青铜器“铜顶尊跪坐人像”。 4、 5 月 28 日消息，游族网络官微宣布，与华为正式达成游戏业务战略合作。 5、 二手电子产品交易平台爱回收提交赴美 IPO 申请。 文章1、摸索八年，再谈效率 作者分享了自己「探索如何更加效率」八年过程中的折腾和思考。 2、回顾IE传奇的一生 不久前微软正式宣布，Internet Explorer 浏览器将于 2022 年 6 月开始停用。 作为陪伴我们大多数人漫长岁月的上网冲浪必备工具，很值得我们回顾一下 IE 的一生。 3、2021 Google I/O大会都说了什么 今年的 5 月 18 日，Google 按照惯例举行了为期三天的 Google I/O 大会，如果你错过了，可以在这里回顾一下大会所有的内容。 4、问 HN：个人最喜欢的博客是什么？（英文） Hacker News 的读者们对个人最喜欢的博客是什么这个问题进行了讨论和分享，里面有很多宝藏。 5、在家管理项目时如何防止范围蔓延（英文） 当在开发过程中要求进行意外更改时，您的最终产品可能比您的规范最初要求的要复杂得多。这种现象被称为“范围蠕变”。再加上一个完全远程的团队，工作与生活之间的界限很窄，你就会遇到问题。 范围蔓延是不可避免的，尤其是当您的团队采用强调快速冲刺和持续改进的项目管理方法时。所以我们的目标不是完全阻止它，而是适当减轻它。总共有六种策略： 1）定义项目范围和时间表；2）实施变更管理流程；3）有效地安排你的一天；4）确保与同事的清晰沟通；5）让您的团队参与决策过程；6）计算浪费的时间和成本； 6、SpaceX 火箭、星际飞船和卫星互联网背后的软件和工程（英文） OVERFLOW 上的一个文章合集，收录了与 Dragon 的软件开发负责人 Steven Gerding 讨论的关于软件开发对 SpaceX 的许多任务所面临的特殊挑战。 7、新冠疫苗：副作用、混合接种和其他几个基本问题 | BBC 新冠疫苗大规模接种在全球铺开，从最初辉瑞和莫德纳疫苗举世无敌，到至少 6 种疫苗列入世界卫生组织紧急使用授权清单，还有更多疫苗在等候审批结果，对现有疫苗的改良、升级和新疫苗的开发也在继续。 许多人关心，接种疫苗有哪些副作用？不同疫苗混合接种是否可行？ 另外还有几个你可能需要了解的基本问题，包括疫苗能提供多大的保护？免疫效力可持续多久？不同的疫苗怎么比较等等。 你都可以在这一片 BBC 的文章中详细地了解到。 8、我编程 20 年的指导原则（英文） 一个编程20年的资深程序员，总结自己编写软件的原则，其中一条是：安全性 &gt; 可用性 &gt; 可维护性 &gt; 代码简洁 &gt; 性能 。另一条是，除非已经完全理解了所要解决的问题，否则不要动手写代码。 好奇星人1、为什么冬泳不会失温，甘肃马拉松会因为失温出这么大的问题？ 冬泳如果没有做好安全措施，也会失温的，冬泳和甘肃马拉松相比，一个是严格可控的，一个是不可控因素太多。 人体所处环境低于 20℃ 就已经可能出现失温，而 0~10℃ 则是失温的高发温度区间。 简单来说：冬泳练习者往往可以在一级失温的时候就能救起，而甘肃马拉松在长久的低温下无法得到有效救治，两者是无法相提并论的。 2、你喝的牛奶从哪来？ | 回形针PaperClip（视频） 牧场里奶牛的一生是如何度过的？为了让我们喝上牛奶，奶牛都付出了哪些努力？ 新奇1、因为修苹果电脑太贵 美国人自学当上百万粉博主 一位美国网友的 Macbook 坏了，因为觉得维修费用太贵，就开始自学修理。 学习的方式很简单，就是买一个二手的，然后修好它，再毁掉它，然后再修理，如此循环往复。 如今这位叫 Louis Rossmann，路易斯·罗斯曼的网友，已经成为了一名 YouTube 视频博主，粉丝达 157 万。 如今，他在切尔西经营着 16 个人的工作坊，提供维修服务。 言论1、 11月23日，星期日 吴陈二位先生说：没有特殊理由，不要与众不同。这是不是我的缺点呢？下午讨论学习的目的和方法。 结论是：学习的目的是要过真善美的生活，学习的方法是读我们喜欢而又应该读的书，理论联系实际并不容易，大家玩的时候一个人要读书也难。今晚大家都看电影《巴黎蜜月》，我没有特殊理由，也就不必与众不同了。 –《西南联大求学日记》 2、 许多经济学家说，技能对现代经济至关重要。随着美国经济的增长，随着公司争先恐后地寻找有技能的人才来招聘，工作岗位正在空缺。 这有一个反面：由于某些技能变得稀缺，这提高了公司愿意支付给拥有这些技能的人的金额。这种情况同样提高了技术娴熟的公司所有者可以赚取的利润，而技术和全球化正在进一步放大急需技能的价值。 –让我们谈论那 0.01%（英文） 3、 当我们的生活朝不保夕，完全无力控制我们的生存环境时，就会执着于熟悉的生活方式。我们通过把生活模式固定化去对抗深深的不安全感。借此我们给自己制造了一种幻象：不可预测性已为我们所驯服。 –《狂热分子》 4、 健身毕竟不等同于追剧刷短视频，它需要持续投入时间和汗水，常常是乏味而痛苦的。“假装健身”，只是折射了他们“渴望变好”的憧憬，虚构出一种掌控自我的感觉。也正是在这个意义上，诸如“跑步教”“健身教”之类的戏称，更显示出几许恰如其分的意味。 –马拉松悲剧背后的健身时代：身体形塑、中产焦虑与朋克养生 5、 各类应景性、应酬性活动，少一点科技人员参加，不会带来什么损失。 决不能让科技人员，把大量时间花在一些无谓的迎来送往活动上，花在不必要的评审评价活动上，花在形式主义、官僚主义的种种活动上。 –习近平总书记首次为“科技自立自强”加上了一个重要定语——“高水平” 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 16 期）：初次管理团队应该怎么做？","slug":"weekly16","date":"2021-05-23T01:23:45.000Z","updated":"2021-05-23T01:38:14.469Z","comments":true,"path":"2021/05/23/weekly16/","link":"","permalink":"http://www.wmyskxz.com/2021/05/23/weekly16/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 欧洲航天局（ESA）最近在南极洲发现了一座冰山，其表面积约为 4,320 平方公里，成为世界上最大的冰山。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 欧洲航天局（ESA）最近在南极洲发现了一座冰山，其表面积约为 4,320 平方公里，成为世界上最大的冰山。 本周讨论：初次管理团队应该怎么做？最近团队招了两个人，这突然让我意识到一直在“野蛮奔跑”的团队，缺少了很多东西。 所以结合最近的阅读和学习，简短地分享一下。 从思想上，刚开始做管理的同学最容易犯的两个错误是：1）把管理当做“晋升”；2）把管理当做“工作的一部分”； 首先，做管理是切换到一个全新的通道上，你是新手，你欠缺大量的必备技能，需要大量的学习，所以在很长一段时间里面，你会表现得非常糟糕，如果你感觉良好，这可能只是你表现得特别糟糕的迹象而已。如果你没有服务意识和同理心，那就最好不要做管理。 其次，写代码和解决重要的技术问题，是两码事。管理岗位的工作，时间是碎片化的，解决技术问题则需要有比较连续的不被打扰的时间。选择了做管理，就要习惯被各种人和事情打断。 最后，做管理是服务团队，激励员工，不管面对的是新项目还是烂尾楼，把商业目标分解成任务计划，把战略分解成战术，推动，执行，落地。在做员工的时候，我们看公司就好像在逆向工程一个复杂系统一样：根据获得的片面的信息，猜测公司怎么每天都在做各种我们看起来这么挫的决定。等做了管理者，你会学习到公司运营的更多细节、以及如何让团队协作等。 在行为上，在一开始，作为管理者，你要识别哪些事情是“有用功”。在互联网行业，有很多地方在 996，这当然增加了总共，但未必增加了“有用功”。 效率 = 有用功/总功 遇到活不要想着加人：作为管理者，你想到的是加人或者加钱，这不叫管理者，谁都可以做这样的管理者。 代码应该越写越少，活应该越干越轻松。 如果团队有 80 个人，你每天想的是这些人干嘛。如果是 8 个，你想的应该是，我干什么才是对的。 受限的团队才能抓住重点。当然也需要做一些必要的管理动作。 每天： 了解每个同学的计划、进度和困难。可以通过站会，也可以通过聊天，但是必须这么做； 解决所有同学们提出的困难，这里的解决是指说明方向，而不是手把手做出来； 查看大家提交的代码和文档，知道大家是不是在做有用功； 以身作则流程化，把所有的需求、结论、思路整理并跟踪起来； 做好负载均衡，把任务均匀地分配给同学们，不要让每个人手上有太多并发的任务； 如果发现有人阻塞了，主动疏通； 每周： 审视整体进度，根据实际情况增加或延后任务； 和产品协作，做好任务分解，确保所有人对任务的理解一致（包括一些细节）； 了解大家本周做了什么，下周要做什么，需要什么帮助； “怎么做管理”是一个特别庞大的话题，我自己的路也还很长，这里给出的建议或许也主观片面，请酌情食用。总之，要干的开心，共勉。 热点新闻1、 埃及决定加宽和加深苏伊士运河的部分区域，以避免三月份的悲剧再次发生。 2、 Masaru Tange 是日本一家软件测试公司 SHIFT Inc的 CEO，他说，使他的公司成为日本表现最好的股票之一的策略可能令人惊讶：他收购了较小的公司并提高了工人的工资。 3、 2021 年 5 月 22 日 13 时 07 分，我国著名科学家、“共和国勋章”获得者、中国工程院院士袁隆平，因多器官功能衰竭，在湖南长沙，与世长辞。享年 91 岁。 4、 微软公司宣布，从明年 6 月 15 日起，IE 浏览器将基本淘汰，标志着又一款数字产品将退出历史。不过不少网友担心，各种网上考试报名咋办？ 5、 5 月 19 日消息，歌手兼词曲作者星野源于 5 月 19 日在 Instagram 上宣布与新垣结衣结婚。 6、 17 日，美国前总统奥巴马在一档电视节目上被问及外星人的问题，他回应称，有些话不能在直播中说，但确实有视频和记录显示，天空中有一些我们不知道的物体。 7、 周五，云南与缅甸交界地区的一次 6.4 级地震造成至少 3 人死亡，20 多人受伤；数小时后，周六凌晨，青海省南部地区发生一次 7.3 级的地震，导致一座桥梁倒塌及其它人员、财产损失。(via) 8、 周六（5 月 22 日），辽宁大连劳动公园北门发生严重交通事故，一黑色轿车高速直冲过斑马线的人群，多人瞬间被撞飞。（由于画面过于惨烈引起不适，就不放图片和链接了） 9、 热门视频应用抖音的母公司字节跳动周四（5 月 20 日）表示，联合创始人张一鸣将在今年年底辞任首席执行官一职，退居二线。 10、 以色列与巴勒斯坦伊斯兰抵抗运动（哈马斯）武装组织达成了停火协议，并在周五正式生效，结束了这场持续了 11 天并造成超过 240 人死亡的轰炸冲突。 文章1、Notion 灵活性背后的数据模型（英文） 在 Notion 中所有内容都可以作为一个「块」来独立存在，这使得它拥有可以成为几乎任何工具的灵活性，而这一篇文章介绍了其背后的数据模型。 2、《爱，死亡和机器人2》完全看片指南 这部由大卫·芬奇和蒂姆·米勒担任监制的动画，集结了目前欧美动画最顶尖的梦之队，以单元剧形式将一个个独立的科幻短篇小说改编为极度风格化的短片，画风包括但不限于2D、3D 、CGI。 这是整理的一篇观影指南，包含每集的原著特色、情节亮点和作者介绍。 3、Google 免费 CSS 教程（英文） 除了跟着 Google 学习一下 CSS 基础知识，另外也可以学习一下 Google 介绍 CSS 知识的思路。 4、如何致富（不靠运气）（英文） Naval 是一个投资人，它分享了自己如何致富的经验教训。这一篇不仅收录完全并做了详细的解释。（篇幅略长） 5、初创企业常犯的数据库模型错误（英文） 收录了五大初创企业来自数据库模型方面的痛苦根源。 6、年轻人的体检指南 01：体检在检查什么 主要解析体检中各种检查项目的意义，以及介绍体检相关的基础知识。 7、复盘新中国水稻育种研究：袁隆平究竟处在什么位置？ “他使全球育种学家看到了通过科技创新解决粮食安全问题的信心”。 8、走进半导体巨头（英文） 美国 CBS 电视网的著名新闻节目《60分钟》，最近播出了一期半导体特辑，访问英特尔和台积电的 CEO，报道芯片为什么会出现短缺。这是节目的文字稿。 9、Marc Andreessen 的创业指南（英文） 本系列文章将重点介绍从整个硅谷初创企业的整个过程中吸取的教训。 10、做有门槛的事 一篇心理学相关的文章。动脑很辛苦，为什么还要？ 好奇星人1、我们为什么如此热爱袁隆平？ 袁老爷子用一生追求“发展杂交水稻，造福世界人民”的生动写照，被写进下面这 5 组数字里，这也许是对这一提问的最好回答。 1152.3 公斤、3000 斤。2018 年，袁隆平团队选育的超级杂交水稻，实现百亩片平均亩产 1152.3 公斤；2020 年，第三代杂交水稻早晚双季稻达到 1530.76 公斤，平均亩产突破 3000 斤。 2.4 亿亩、60.9%。袁隆平培育数代的“超级杂交水稻”年种植面积超过 2.4 亿亩；1990-2016 年间，中国食物不足人口占比下降了 60.9%，高出世界平均水平 20 个百分点。 14 亿、7000 万人口。袁隆平一生致力于解决 14 亿中国人吃饭问题；每年因种植杂交水稻而增产的粮食，可以多养活约 7000 万人口。 800 万公顷、2 吨。目前，杂交水稻已在印度、孟加拉国、印度尼西亚、越南、菲律宾、美国、巴西、马达加斯加等国大面积种植，年种植面积达 800 万公顷，平均每公顷产量比当地优良品种高出约 2 吨。 80 多国、14000 多人。从上世纪 80 年代至今，袁隆平和他的团队通过开办杂交水稻技术培训国际班，已经为 80 多个发展中国家培训了 14000 多名杂交水稻的技术人才。 言论1、 世界变化太快，最聪明的人会不断修改自己对世界的理解，重新考虑那些有定见的问题。他们不断用新的信息、新的想法挑战自己的思维方式。这并不意味着，你认定自己的观点就是错的，而是说你应该把自己的观点视为暂时的。 –《杰夫·贝佐斯（Jeff Bezos）的一些建议》 2、 财富再多都是后面零的增加，而健康是最前面的“1”。 作为一个国家，最底线的期待是解决最普遍的违法现象；而对于各位打工人来说，需要做的是更多关注自身健康，能不加的班就别加了，把自己人生的“1”立住、立稳，这比什么都重要。 –996的危害：每周工作超55小时有危险！ 3、 创业公司的三个核心要素：团队，产品和市场。其中最重要的是市场，用户数量和增长率是决定性因素。创业公司失败的第一大原因就是缺乏市场。 –Marc Andreessen 的创业指南 4、 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 15 期）：如何进行思考","slug":"weekly15","date":"2021-05-16T02:00:45.000Z","updated":"2021-05-16T01:59:58.818Z","comments":true,"path":"2021/05/16/weekly15/","link":"","permalink":"http://www.wmyskxz.com/2021/05/16/weekly15/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 5 月 15 日，以色列在加沙地带南部的拉法镇发动空袭，烟雾滚滚。（@来源） 本周讨论：如何进行思考William Deresiewicz 是美国的一个作家。2009 年 10 月他在美国军事学院发表了题为《孤独与领导力》的公开演讲，不仅仅讲述了孤独与领导力之间至关重要且经常被忽略的联系，也对如何进行思考做出了独特的理解。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图 5 月 15 日，以色列在加沙地带南部的拉法镇发动空袭，烟雾滚滚。（@来源） 本周讨论：如何进行思考William Deresiewicz 是美国的一个作家。2009 年 10 月他在美国军事学院发表了题为《孤独与领导力》的公开演讲，不仅仅讲述了孤独与领导力之间至关重要且经常被忽略的联系，也对如何进行思考做出了独特的理解。 不管你可以咨询多少人，最终你都是必须作出艰难决定的人。 在这样的时刻，你真正拥有的就是你自己。 他总结到：真正的领导力意味着能够自己思考并根据自己的信念行事。但是如何做到自己思考呢？ 几个月前，斯坦福大学的一组研究人员进行了一项研究。研究人员想弄清楚当今的大学生如何比成年人更有效地完成多项任务。却发现答案是他们并没有执行多个任务。研究人员期望找到的增强的认知能力，使人们有效地完成多项任务的精神能力根本不存在。换句话说，人们不能有效地执行多个任务。这是一个令人惊讶的发现：同时处理任务越多的人，他们的能力越差，不仅在其他心理能力上，而且在多任务本身。 使这项研究与众不同的一件事是，研究人员在多任务处理过程中并未测试他们的认知功能。他们将主题组分为高多任务处理者和低多任务处理者，并使用一组不同的测试来衡量多任务处理中涉及的各种认知能力。他们发现，在所有情况下，多任务工作人员的得分都较差。他们在区分相关信息和无关信息而忽略后者方面表现得更糟。换句话说，它们更容易分散注意力。它们在您所谓的“心理归档”方面更糟：将信息保存在正确的概念框中并能够快速检索。换句话说，他们的思想更加混乱。在定义多任务本身的事情上，他们甚至更糟：在任务之间切换。 简而言之，多任务处理不仅不帮助思考，还会损害思考能力。思考意味着专注于一件事情足够长的时间以形成关于它的想法。不要学习别人的想法，也不要记住大量的信息，但是有时候这些信息可能很有用。形成自己的想法。简而言之，为自己着想…. 我自己发现，我的第一个念头从来都不是我最好的念头。我的第一个念头总是别人的：它总是我过去听说过的，传统的观点。只有专注，坚持问题，保持耐心，让我的所有想法发挥作用，我才能得出一个原始的想法。通过让我的大脑有机会建立联系，建立联系并让我感到惊讶。通常，即使是这个主意也不是很好。我也需要时间去思考，去犯错误，认出错误，错误的开始并改正它们，以克服我的冲动，打败我宣告工作完成并继续下一步的愿望。 以前有学生向我吹嘘他们的论文写得有多快。我想告诉他们，伟大的德国小说家托马斯·曼说过，作家对他来说写作比其他人更难。最好的作家比其他人写得慢得多，而且写得越好，写得越慢。詹姆斯·乔伊斯写 20 世纪最伟大的小说《尤利西斯》用了 7 年的时间，每天约 100 个单词，相当于我之前给你们读的《黑暗的心》选集的一半。T.S. Eliot 是我们国家有史以来最伟大的诗人之一，在他 25 年的职业生涯中写了大约 150 页的诗。这是一个月半页。任何其他形式的思想也是如此。你通过放慢速度和集中注意力来做最好的思考。 结论或许有些无语：提高思考能力的最佳方法是花时间思考。 亚马逊创始人贝佐斯曾经就分享过自己的成功经验：作为一个决策者，你的职责不是做出很多决定，而是只需做出几个高质量的决定。如果我每天做出三个不错的决定，就很满意了。巴菲特说，他的一年就是做对三个投资决定。 判断一个人做决定的能力的试探法是看他有多少时间。最忙的人往往是做出最糟糕决定的人。忙碌的人花很多时间纠正错误的决定。因为他们忙于纠正过去的决定，所以他们也没有时间做出好的决定。 前段时间尤雨溪大大安排了一场直播，其中令人印象深刻的问答是： Q：如何平衡 Vue 与 Vite 的开发？ A：以周或者月为单位来进行切换。 所以如果你想更好地思考，那就请安排时间来研究和加深你对问题的理解。共勉。 热点新闻1、天问一号着陆器成功降落火星 北京时间 2021 年 5 月 15 日上午 8 点 20 分左右，我国天问一号着陆器确认成功降落火星，着陆地点位于火星北半球的乌托邦平原，着陆器上搭载的是我国“祝融”号首辆火星车，这是我国首次实施火星着陆任务。 2、武汉 9 级龙卷风致 6 人死亡 218 人受伤 截至 5 月 15 日中午 12 点，现场搜救工作基本结束，目前统计数据，共有 8 人在这次事故中不幸遇难，受伤人员 230 人，3568 人受灾，紧急转移安置 1197 人，倒塌房屋 28 户 86 间，严重损坏房屋 130 户 400 间。 3、一句话消息 最近，全球最大的珠宝商潘多拉（Pandora）表示，将不再出售矿产钻石，而将转为专门由实验室制造的钻石。 Notion 发布了可供开发者调用的 API 接口。 马斯克突然宣布，两个月前刚宣称能够支付购买特斯拉车辆的比特币，因为环保原因，将暂停不再使用。 5 月 13 日，新财富 500 富人榜正式发布。今年，中国前十富人大洗牌。史上第一次，中国前十富人财富值均跨过 2000 亿元门槛。 黑客组织 DarkSide 曾勒索攻击了美国最大燃油管道运营商并导致其网站下线，多个州出现了燃料短缺，最近它表示收到美国不明压力，要停手了。 最近，谷歌因 Google Play 滥用支配地位被意大利反垄断部门罚款 1 亿欧元。 最近，有报道称 Uber 利用 50 家在荷兰的空壳公司回避了近 60 亿美元的税收。 近日，中信银行宣布“封堵”比特币，称从即日起，任何机构和个人不得将中信银行账户用于比特币、莱特币等的交易资金充值及提现、购买及销售相关交易充值码等活动，不得通过中信银行账户划转相关交易资金。 前段时间，奈良县生驹市在稀释疫苗的时候忘了加疫苗，于是只给接种者接种了生理盐水，问题是还搞不清哪些人接种了生理盐水，只能测抗体，抗体低的补一针。该医院相关人士致歉。 文章1、存在于所有 Wi-Fi 中的安全漏洞演示（英文） FragAttacks 收录了所有影响 Wi-Fi 设备的安全漏洞，并附赠了视频演示。 2、SpaceX 星际飞船是如何降落的？（英文） 讲述了星际飞船着陆的一部分原理，包括最优降落轨迹如何选择、着陆代码如何编写等。 3、2021，未来趋势是什么？ 前百度贴吧运营总监张新泳以《2021，未来趋势是什么》为题的分享，本文为演讲内容实录。 4、敏捷宣言背后的原则（英文） 介绍了敏捷开发背后的原则。可能大家都知道敏捷，但如何做到敏捷，这里的每一条都非常受用。 5、通货膨胀最终指南（英文） 通货膨胀是一个有争议的和复杂的主题。本文着眼于 150 年的数据跨多个国家提供一个通用的通货膨胀是什么、如何投资以及通胀和通缩风险的指南。 6、天问一号成功着陆火星，它经历了怎样的挑战？ 火星又被称作“着陆器坟场”，着陆成功率仅47%。这一篇文章详细介绍了着陆火星所需要克服的重重困难。 7、第七次全国人口普查主要数据情况 国家统计局发布的第七次全国人口普查情况。据报告，全国人口共 141178 万人。 8、1972 年 Dijkstra 获图灵奖时的演讲（英文） 学过算法的同学应该都接触过最短路径 Dijkstra 算法，这是作者在 1972 年时获得图灵奖发表的演讲，比较长，但我仍然连着读了两遍，你很难想象这是一篇来自 1972 年的讲话。 其中他描述了为持续交付高质量软件，而需要的三把革命钥匙： 1）使用抽象让程序在智力上更加易于管理；2）程序员应该让正确性证明与程序齐头并进（一个人不应该先编写程序然后证明其正确性，因为提供证明的要求只会增加可怜的程序员的负担）；3）在程序开发过程中保持谦逊； 或许下一期可以来好好说说这一篇文章。 9、认识 Mac 桌面 少数派编辑新开的坑，旨在教导新手如何上手 Mac 系统。 10、10个让用户一眼就爱上的设计心理学知识 第一印象是最令人难忘的，积极的体验可以在用户和产品之间创造持久的关系。如果能让用户在一开始就喜欢上我们的设计，就能为我们的产品创造了一个很好的优势。 好奇星人1、蚊子喜欢咬谁? 科学家发现，散发二氧化碳（严格地说，还包括乳酸、丙酮和雌二醇）越多的人，越容易被蚊子咬。这解释了为什么较胖的人、孕妇被蚊子咬得比较多。 另外 O 型血比 A 型或者 B 型血的人更容易被咬；蚊子脱水也更容易咬人（例如你去偏远的地区旅行）。 2、为什么要洗钱，直接花不行吗？ 有能力取得黑钱的人，本身合法收入就足以满足日常消费。 你突然多出来的几个小目标、过于频繁的高消费，被亲朋好友，同事邻居察觉，消费能力与收入不匹配，举报就会被查。因此，想正大光明的用，就需要这笔钱找合法来源。 新奇1、搭积木世界纪录 最近国外网友发布了一张图片，显示了他在 1 块积木上搭了 1500 多块积木，而创造了新的世界纪录。 2、喷气式战衣（视频） Youtube 上发布了一条关于英国皇家海军陆战队试穿喷气式战衣的视频，非常具有科技感，并且链接下方有官方网站介绍，并公开预定售卖。 言论1、 “自己”这个东西是看不见的，撞上一些别的什么，反弹回来，才会了解“自己”。所以跟很强的东西、可怕的东西、水准很高的东西相碰撞，然后才知道自己是什么，这才是自我。 –山本耀司 2、 用户获取内容的主要渠道，已经从内容类网站转向了社交平台。用户看到什么内容，不再是网站主编决定的，而是由热搜榜和推荐算法决定的。所以，内容渠道才会大幅贬值，因为它已经不重要了。 –阮一峰 3、 到了 40 岁，觉得自己一事无成。 –雷军 4、 具有大学文化的人口为 2 亿 1836 万人，与 2010 年相比，每 10 万人中，具有大学文化程度的由 8930 人上升为 15467 人。 –第七次全国人口普查主要数据情况 5、 当您购买未来的现金流时，您会变得富有。当您购买未来的债务时，您会变得贫穷。 –停止购买更多东西（英文） 6、 我开始觉得，如果我们都赞成人就是一种情绪动物，互联网造就的表达和讯息分发平民化是大势所趋，而大数据时代的降临又在所难免，那么人们观点的撕裂，可能会趋于无解。 –为什么在成都49中事件里，那么多人「争输赢」？ 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 14 期）：为什么你找不到喜欢的工作了","slug":"weekly14","date":"2021-05-09T02:00:45.000Z","updated":"2021-05-09T02:02:21.598Z","comments":true,"path":"2021/05/09/weekly14/","link":"","permalink":"http://www.wmyskxz.com/2021/05/09/weekly14/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：为什么你找不到喜欢的工作了（观点来自：你可能这辈子都找不到喜欢的工作了）","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：为什么你找不到喜欢的工作了（观点来自：你可能这辈子都找不到喜欢的工作了） 在职场里有一个经典命题：激情假设。 在这种假设里，人只有找到一份满怀激情的天命工作，就可以像永动机一样，在工作中孜孜不倦了。 很多人脑海中里的这一层假设，也许是来自乔布斯曾经在斯坦福的演讲，那一句他为世界留下的 “follow your heart”，不知道 move 了多少男女的心。 但这里面存在三个幻觉。 第一个幻觉是：它的前提 “激情” 是开启工作的唯一条件，我们在开始一份工作前就会提前预知对它的喜欢与不喜欢。 然而世界上任何一份工作，在你深入了解之前，你都不了解它，你的了解都是肤浅的，所以你对于个人喜欢与否的先在判断，也是肤浅的。它是头脑的游戏，与延迟行动的借口。 多数时间里，我们都被“不知道自己喜欢什么所以什么也不做”给困住了，但没见到这一想法的 B 面，是“不知道自己喜欢做什么，所以其实也意味着我什么都可以做”。 这和人不知道自己会和谁结婚一样。 年轻人追求对象都凭着对某个人一腔热血的喜欢——这是一根直肠通大脑的简单逻辑：我喜欢你所以你要和我在一起。 上了年纪的都凭感觉，结婚也会凭感觉。这份感觉，已经不再是单维度的喜欢，而包含着多层含义：合适、惬意、舒适、安心、稳定、喜欢… 第二个幻觉是：你不是对当下的工作没有热情，只是没有能力 hold 住这份工作。 这也是 “激情假设” 的一个问题：过分放大喜欢的前提，忽视了态度问题。 对多数普通人来说，喜欢的工作，只能干出来，不能找出来。 因为世界上任何一个工种，只要你深入下去，都会经历问题、挫折、磨难。对，即使是看上去再快乐的那一种。 而激情和热情又是快消品，人极其容易在早期消耗掉大量的激情能量，然后又掉入了对于“喜欢”和“不喜欢”的头脑判断死循环，变得愈发不勤恳、不诚恳、不认真，最后找个借口说，嗯，其实是因为自己不喜欢。 “我不喜欢这份工作”它的深层心理表达，也可能是在说“我都说了我不喜欢，所以即使我做不好也可以免受责难”。 所以，你究竟是因为能力不足，才用“不喜欢”的说辞来让自己好受一点，还是你真的只是不喜欢以至于需要对这份工作的价值进行全面否定。 第三个幻觉是：我们始终在想，要是找到一份有热情的工作就好了。 这和我们平日里幻想的要是有一天能财务自由就好了，是没啥区别的。佛家讲这是颠倒梦想。 就跟高考前学渣都希望自己能超常发挥一样，但经历过高考的都知道，大概率绝大部分人都是正常发挥，都能获得一个跟平时表现相应的分数。失常和超常都是极少数。 当人们陷入困顿的时候，首先想的是逃避和退缩，想的是“我是不是应该换一份更有热情的工作”，而不是“我该如何解决当下工作中的这个问题”。 潜意识里，人们会认为，“喜欢”和“热情”意味着没有痛苦，没有代价。 但恰好相反，喜欢往往意味着更高的代价。 我们都是太多谈喜欢，太少谈代价。太多谈热情，太少谈服务。 “激情假设”之所以流行，就是因为它符合人们对于捷径的想象。可有的人的喜欢，是不配称之为喜欢的。 喜欢，不是捷径。喜欢的那一刻，只真实地发生在人们愿意接受它高代价的那一刻。 把时间拉长了看，每个人都是会活出ta自己的。锤子会活成锤子样，钉子会活成钉子样。 我们每一次既完成不好当下的工作，又想着哪里有一份热情工作在等着我的样子，很像在依萍和茹萍之间徘徊不定的何书桓。 而头脑一旦产生杂念，也就意味着当下的精力没有投入到工作质量上，工作打折扣，自然收不到好的正向反馈，越没正向反馈，越会怀疑自己是不是不喜欢，越觉得不喜欢，越做不好。 日子一久，人会对自己失望的。 但何书桓不知道，他只要坚定一点，不管是和茹萍过，还是和依萍过，他都会幸福。只要开始自私地计算了，便是不幸的开始。共勉。 热点新闻1、IBM 宣布全球首个 2nm 芯片制造技术 IBM 宣布推出全球首个 2nm 芯片制造技术引起了大家的注意。与 7nm 的技术相比，预计将带来 45% 的性能提升或 75% 的能耗降低。 从 IBM 的表述中，这或许意味着将来你的手机的电池寿命将延长三倍，用户只充电一次可以用四天； 2、青春有你 3 停播 该次事件主要有两个原因： 1）4 月 29 日，媒体爆出粉丝为投票将大量未饮用牛奶倒入下水道。新华社于五四青年节当天，写了篇热评，严厉谴责浪费等不尊重劳动的行为，严令反对对青少年造成不良影响和引导的营销方式。 2）另一个就是 4 月 30 日媒体爆出的余景天双国籍，其父母经营的 KTV 涉毒涉黄。 3、京东售后涉嫌显卡套利 5 月 7 日消息，近期，在微博和黑猫投诉平台上，有用户反映，早前在京东购买了显卡，出现问题后申请售后，却被京东售后告知无法维修、无法换货、要求原价退款。同时，也有用户称自己高价买入的显卡，使用痕迹明显，疑似二手卡。有人认为，这是京东售后利用金融的手段“做空”显卡，结果穿仓了。 对此，京东集团回应称，京东一直严格遵循相关售后服务政策，不存在传言中显卡售后服务 “金融化”的情况。 4、中澳对峙升级 中国“无限期暂停”两国战略经济对话 自澳大利亚去年呼吁追查新型冠状病毒源头，以及禁止中国科技公司华为参与建设澳洲 5G 网络之后，中澳关系一直处于紧绷状态。 去年，中国对澳大利亚的葡萄酒及牛肉等产品进口实施制裁。 4 月下旬，澳大利亚政府宣布首次引用《外交安排政策法》（Foreign Arrangements Scheme），取消当地维多利亚州与中国签署的参与“一带一路”倡议的两份协议。 中国外交部发言人汪文斌在当时曾表示，澳大利亚的做法表明“他们对改善中澳关系毫无诚意”，而中国将会对澳大利亚否决中澳“一带一路”协议的决定采取“坚决有力回应”。 5、一句话消息 iOS 14.5 的更新中对于跟踪权限进行了严格的限制。有消息称，已经有超过 96% 的用户禁用了 Facebook 的跟踪权限，Facebook 失去苹果用户的噩梦或已成真。 太空专家预测，4 月 29 日由中国发射的长征 5B 会有某些组成部分失去控制，坠落在地球上，时间预估在 5 月 9 日 12：37 ET 前后 28 小时。 Bootstrap 5 发布。新的 logo 和新的文档是最大的变化之一。 5 月 3 日消息，美国微软公司创始人比尔·盖茨与梅琳达·盖茨宣布离婚。 文章1、COVID-19 全球死亡人数预估报告（英文） IHME 是华盛顿大学医学院的一个独立的全球健康研究组织，该组织对 COVIE-19 问题进行了严格且可比的评估，发现已在全球造成 690 万人死亡，是官方报告显示的两倍多。 从 2020 年 3 月至 2021 年 5 月，COVID-19 死亡总数最高的三个国家分别是：美国（905,289）、印度（654,395）、墨西哥（617,127）。数量相当可怕。 2、如何做好一个产品——产品认知篇 如果把「如何做好一个产品」看做问题，那么我们需要先了解产品相关的知识，建立对应的认知和思维。这一篇文章就详细地讲解了这一部分。 3、编程语言的历史（英文） 从历史的角度，研究了编程语言的两个核心问题：1）语义是如何出现的；2）语言是如何发展的。 4、如何提高英语水平：开发人员指南（英文） 英语水平可能是职业生涯的潜在障碍。这是作者在回顾过去时，总结的一些方法教训。 5、程序员应该访问的最佳网站 Github 上 Star 超过 3k 的宝藏级项目，收录了一些对程序员有用的网站。 6、成为自由职业者所需的一切（英文） 1）垂直的领域；2）个人品牌；3）联网；4）客户；5）耐心和勤奋；6）追加销售；7）多个收入来源；8）使用工具； 7、120年了，中国早已不是那个大清，你们该醒醒了！ 或许，这个世界并没有想象中的和平，但幸运的是，我们生活在了一个和平的国家。 8、独立技术人指南 独立技术人，是以技术为基础，有更多盈利选择，包括但不限于技术咨询、销售网课、自媒体变现、著书出版，最终也可以达到财务独立，自主支配的自由工作状态。 这是一篇独立开发人的完整指南，感兴趣的可以看看。 9、我不想做这样的人（视频） 今年的五四青年节，很多人都被 B 站发布的特别企划《我不想成为这样的人》演讲视频刷屏了。 视频中，还有不少内容表现了初中生们对于未来的向往，但是也有很多地方，能看出制作者的固有观念的附加。 10、ARM 芯片是如何诞生的（英文） 本文介绍了英国 ARM 公司的由来，以及他们设计的芯片。对于了解 x86 和 ARM 两种 CPU 架构的早期历史和区别，很有帮助。 好奇星人1、每天少睡两个小时会怎样？（视频） 最近在阅读知识星球出品的《绝非偶然》，里面一位海外并购专家张伟华分享了自己每天只睡 4-5 个小时的作息习惯，并称「因为有更充裕的工作时间」。 减少睡眠时间确实能做更多的事，但对于一般人 8 个小时的最佳睡眠时间来说，这方法明显不科学。 研究显示，10 天内每天只睡 6 个小时的结果，与连续 24 小时不睡觉是一样的，认知能力下降，相当于醉酒后的反映。 这些研究还表明，参与者根本没有意识到他们认知能力的下降。换句话说，当你很困时，就像是一个人在聚会上喝醉了，还坚持说自己开车回家没有问题一样。 与其增加工作时间，不如好好研究应该如何提高效率。 言论1、 以前的选秀——勉强算选秀。 现在的选秀——完全靠资本。 –知乎网友 2、 但我们不再相信在人生的下一篇章里，还能作为夫妻共同成长。 –梅琳达和比尔盖茨 3、 如果真的希望通过“小长假”提振内需、促进消费，或许我们需要的是，让大家不仅拥有消费的时间，也拥有消费的心情。 –@看理想 4、 组织和个人努力的方向，都应该是让有效时间内输出最大化：说简单一点儿，即便有必要加班，目的都应该是为了能尽早达到按时下班，而不是在公司里面形成一种”多花点儿时间就能做出更多东西”的错觉。 –关于工作与生活 5、 40 年前算法很重要，大部分程序员都需要懂，因为硬件差，必须靠算法保证性能。 但是今天只剩下不到 1% 的程序员直接跟算法打交道，其他人都使用现成的软件包，或从大公司购买算法，算法已成为一种商品，普通程序员不再需要自己生产了，也不需要有很深入的了解。 –《算法现在是商品》 6、 信息成瘾指的是强迫性信息消费：明明已经看完所有内容，你仍在继续滚动浏览 Facebook；你刚刚关闭 Instagram，立即再次打开它；你每五分钟拿起手机，检查有没有新的通知。 –《什么是信息成瘾》 7、 拉丁语中，”激情”的意思就是”受苦”。如果你热爱一样东西，却不感到痛苦，那就不是激情。 –《我热爱的是什么？》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 13 期）：大坑和小铲子","slug":"weekly13","date":"2021-05-01T23:06:45.000Z","updated":"2021-05-01T23:06:47.265Z","comments":true,"path":"2021/05/02/weekly13/","link":"","permalink":"http://www.wmyskxz.com/2021/05/02/weekly13/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：大坑和小铲子(观点来自：阮一峰)","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：大坑和小铲子(观点来自：阮一峰) 假设你的目标是要找到地下的金子，但是你不知道它埋在哪里，也不知道埋得有多深。你只知道，运气好的话，可能会偶然走在路上，就在草丛里捡到金子；运气不好的话，在地底挖一辈子，依然两手空空。 你唯一的工具就是一把小铲子。可能因为没有资金，或者没有人脉，总之，你只搞到了一把小铲子。悲惨的人生，不是吗？ 你一个人，加上一把铲子，开始了寻找黄金之旅。长途漫漫。 现在，你有两种选择。 选择一：留在一个地点，挖一个大坑，但是不知道何年何月才能挖到地下的金子。 选择二：每个地点挖 5 米，如果找不到金子，就换个地方再挖。结果你挖了几百个小坑，而不是一个大坑。 请问你会如何选择？ 推而广之，如果你在经营一项事业，你就有两种策略。 策略一：单一化策略。认准一个方向，不断地挖坑，通过长期重复性的付出，创造价值，赢得他人的信任，把产品销售出去。 策略二：多元化策略。你四处出击，到处挖坑，将有限的资源分散使用。这时，你最好期望你的眼光很准，能找对地方，一旦将产品投入市场，就立刻能打开销路。因为你的铲子很小，如果金子埋得很深，你就不会有第二次机会。 有些人出生的时候，是带着大铲子来到这个世界的。因为铲子大，他挖一下，等于别人挖十下，那么也许他可以多挖几个地方。 但更多的人只有一把小铲子，其他的都要靠自己。这种时候，你最好不要采用第二种策略，因为埋得浅的金子都被大铲子或者幸运儿挖走了，不会留给你的。事实上，你唯一的机会就是在一个方向不停地挖。 你必须认识到，不是你一个人在找金子，是所有人都在找金子。那些容易找到的金子，几乎可以肯定，一定已经被别人捡走了。那些有高级设备的人，把埋得浅的金子，也挖得差不多了。这就是说，第二种策略实际上是无效的，就算你挖一千个小坑，也找不到金子。 你唯一的策略，就是认定一个方向，坚持不懈往下挖，直到挖成。你很可能还是不会找到金子，但是在往下挖的过程中，你可能会找到其他有用的矿物。而且，由于长期地在这个领域奋斗，你会对周围一切极其熟悉，变成这个领域的专家。附近的人遇到各种问题，也会来找你征求意见。 另一方面，风沙来临的时候，那些小坑都会被掩埋，只有你的大坑会留下来，成为地面上难以磨灭的印记。或者，随着时间流逝，那些小坑都会慢慢荒芜，野草覆盖，人们再也无从发现它们，只有你的大坑还能被后代的人们辨识出来。 举例来说，古罗马都是石头建筑，建造起来非常困难和昂贵，可能一年只能造一幢，但是两千年过去了，很多建筑都留到了今天；古代中国都是木建筑或砖瓦建筑，建造起来比较容易和廉价，可能一年可以造几十幢，但是根本留存不下来，完整的唐朝和唐以前的建筑，现在完全找不到，就连许多清朝的房子，现在都腐烂得不像样子。 最后，如果你想人生中留下一些东西，那么因为你挖了一个大坑，人们会记得你。这就是你留下的痕迹。共勉。 热点新闻1、奇葩学术宇宙 最近，一篇有关#熟蛋返生孵雏鸡论文#在网上疯传，引发网友热议：少一点修仙搞笑，不要侮辱我智商。 据公开报道信息显示，该校老师郭平长期从事人体潜意识唤醒开发运用研究，还有物体穿瓶越壁、熟绿豆返生发芽等相关著作。 并且深扒下来，还是开设“超感知全能全脑”、“原子能量波动速读”、“蒙眼辨色”课程的全能训练班学校的校长。说到底，作妖的背后都是为了圈钱。 2、郑爽天价片酬背后，可能存在“局中局”？ 最近郑爽在热搜上挂了好几天，原因是 4 月 26 日，郑爽的前男友张恒曝光了郑爽通过阴阳合同在《倩女幽魂》项目中获得收入 1.6 亿元，按 77 个工作日计算，日薪超 208 万元。 这个事情，一是她被曝通过阴阳合同逃税漏税，涉及到了全体纳税人的利益和社会公平的问题； 二是背后的投资方深扒下来，让人有“不好的联想”：会不会阴阳合同只是幌子，天价片酬的背后，有没有可能是在帮人洗钱？ 对这件事情感兴趣的朋友强烈建议读一读链接，记录了郑爽瓜的始末，让人咋舌。 另外受该事件影响，75 位一线艺人旗下的公司已经关闭超过 200 家。相关部门也已经展开了调查。 3、北京人社局副处长体验送外卖：「太委屈了，这个钱太不好挣了」 4 月 27 日，北京卫视播出《我为群众办实事之局处长走流程》纪录片。在该纪录片中，北京人社局副处长拜师“外卖小哥”，体验送外卖的一天。一小时挣不到三块钱，12 小时送单却只赚 41 块。他累瘫在马路上：“太委屈了，这个钱太不好挣了。” 知乎骑友表示：直观来看，应该是国家想着手改善骑手的工作环境， 并派人实地调研了。 为这样走在一线，不坐在办公室里制定政策的领导点赞！ 4、一句话消息 美国时间上周六凌晨 4 点左右，一条海狸咬断了一条重要的光纤电缆，造成不列颠哥伦比亚省的大约 900 位客户的互联网服务中断。 思科表示计算机芯片短缺还将持续六个月。这主要是 5G、云计算、物联网和人工智能等技术推动需求的大幅增长。 最近，腾讯因为经典游戏《DNF》被其他公司抄袭复刻为手游（例如：《阿拉德之怒》），获赔 3000 万。 谷歌第一季度财报展示，由于疫情影响，员工都在家办公，减少了出差和娱乐的费用，按年算，这将直接为谷歌省下 10 亿美元。 最近，在腾讯起诉 DD373 交易平台的庭审直播中，腾讯律师公然表示根据用户协议，明确禁止游戏账号、游戏币交易，用户对数据和虚拟物品不享有财产上的所有权，仅为使用权，如果账号被盗，腾讯保留追究的权利。引起网友热议。 文章1、身边的 SOLID 原则（英文） 在本文中，使用生活中的一些例子，利用图片，简要介绍了面向对象编程和设计的 S.O.L.I.D 原则。 2、中国人吃肉有罪，日本人排核废水无罪 从核废水的始末，延伸到国际上的各种歧视，特别是对于中国。中国新疆的棉花能够对世界构成威胁，而日本的核废水不会。去你丫的吧。 3、前端2D游戏化互动入门基础知识 阿里系出品文章。现在已经有越来越多的“游戏化”产品，这是一篇对于使用 Eva.js 2D 游戏化互动的基础介绍。 4、为什么 UML “真的” 消失了（英文） UML 是一种用来构建软件模型的方法和语言，我在大学里学过。这一篇文章讨论了为什么 UML 消失的真正原因。 5、苹果的设计为什么那么厉害！ 无论是界面还是文案，苹果无疑都是最好的参考。这里详细介绍了苹果的设计是如何引领行业的原因和方法。 6、开发人员远程工作的 10 个最佳实践（英文） 如果您有计划或者对远程工作比较感兴趣，可以看看这总结的 10 点经验。 7、2020 中国独立开发者生存现状调研报告 根据报告，大部分的独立开发者在一二线城市、每周平均工作 4 小时以下、做着开发网页的工作。更多请戳报告~ 8、设计模式图文教程 看图就知道，是一个不容错过的优质网站。 9、大多数教程中都看不到的 CSS 技巧 介绍了一些非常实用的 CSS 技巧。同系列的还有：HTML Tip 和 JavaScript Tips。 10、生活中有很多压力，怎么办？ 第一，做有门槛的事；第二，运动；第三，理解和评估情绪；第四，自我抽离。一定要记住：压力永远都不可怕，可怕的是面对压力的软弱。挺过去，这些就会成为丰富你生命体验的元素。 好奇星人1、三大运营商的基站为什么要伪装？ 首先，基站有辐射这个事儿是谣言。站在基站 0.5 米远的位置，辐射仅为 0.01uT，而同等距离，笔记本电脑为 1.13uT，手机充电器为 16.11uT。 但是谣言却很难消除。特别是小区里的大爷大妈，你敢建，我就敢拆。 尽管多方辟谣，央妈也亲自上阵，但仍然无济于事。 所以为了能够在大众的视野里活下去，基站的伪装，堪比谍战大片。 新奇1、第一个使用当地土壤材料 3D 打印的房子 最近，意大利一家 3D 打印公司 Wasp 使用当地的土壤为原材料，用 200 个小时 3D 打印出了一个 60 平方米的房屋。 内部是一个起居区，厨房和卧室，家具部分集成到了结构中，其他独立的物件则设计为可回收或再利用。 由于完全使用现场发现的材料，从而消除了将材料运输到建筑工地的环境影响，对环境相当友好。并且建成该建筑平均耗电量不到 6 千瓦，也就是 6 度电。 言论1、 行业红利没享受过，却又实实在在地见证过；早工作五到十年的同事积累的财富，又是自己一辈子都很难企及的。这种落差感、无力感，每天都活生生地上演，眼睁睁而无法逃避。 –为什么几乎所有大学专业都在劝退？ 2、 打工人从秦朝忙到现在，也挣不了这么多。 –郑爽一部戏挣1.6亿？ 3、 事实上，用户根本就不关心你使用什么样的编程语言、你的代码是如何地优雅、干净、模块化和可维护。 –Nobody cares about your beautiful code 4、 不管狗狗币是不是真的有价值，人们对狗头表情的爱都是真实的。 –狗头，这可能是人类历史上最有价值的表情包 5、 金钱就像狗尾巴，你要追着它跑，永远抓不住，但是你如果往前跑，它自然会跟着你。 –财富一定通往自由？ 6、 但现在的很多孩子，除了老师讲授的内容，他知道的东西非常有限。而且，我现在越来越少遇到那种学生——在谈及自己喜欢的东西时，眼里散射着光芒。 –海淀区高中老师：每天被鸡的娃们，已经开始秃了….. 7、 希望我们的虚拟财产，也可以收到一份安全的保障，而不是一夜之间，我们都成了游戏公司的打工人。 –知乎用户 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"长期不上班是一种什么体验？","slug":"长期不上班是一种什么体验？","date":"2021-04-25T11:24:05.000Z","updated":"2021-04-25T11:30:52.258Z","comments":true,"path":"2021/04/25/chang-qi-bu-shang-ban-shi-yi-chong-shi-me-ti-yan/","link":"","permalink":"http://www.wmyskxz.com/2021/04/25/chang-qi-bu-shang-ban-shi-yi-chong-shi-me-ti-yan/","excerpt":"以下是粉丝邀请回答知乎问题：「长期不上班是种怎样的体验？」的原答案。 粉丝邀请，强答一波。 我是 19 年本科毕业，19 年 11 月被裁员，之后就一直没工作了。 平时就写写公众号（wmyskxz），网上冲冲浪，做做游戏开发。 上个月（2021 年 3 月）用五天时间肝出来的一个 Mod（可以理解为小游戏） 赚的钱，差不多相当于今年每个月拿着 1w5 的月薪，并且还在持续创收中。 要说体验就是：已经越来越不想上班了。","text":"以下是粉丝邀请回答知乎问题：「长期不上班是种怎样的体验？」的原答案。 粉丝邀请，强答一波。 我是 19 年本科毕业，19 年 11 月被裁员，之后就一直没工作了。 平时就写写公众号（wmyskxz），网上冲冲浪，做做游戏开发。 上个月（2021 年 3 月）用五天时间肝出来的一个 Mod（可以理解为小游戏） 赚的钱，差不多相当于今年每个月拿着 1w5 的月薪，并且还在持续创收中。 要说体验就是：已经越来越不想上班了。 现在的状态就是：早上尽量早起，记录一下昨天发生的事，网上冲会儿浪看会儿书，然后喝杯咖啡就开始做自己的事情。 早上效率高一些，中午经常过了饭点才想起来吃饭。偶尔得闲也会自己弄一些简单的「一人食」。 晚上也尽量早睡（理想情况）。尽管可以睡到自然醒，但是我依然非常需要规律的作息来维持我做事的能量。 从几个方面聊聊这一年多以来的感受和经历吧。 关于幸福感1、 关于幸福感，那可以说是爆棚。 每天做着自己喜欢的事，不用通勤上下班，时间自由，收入过得去。至少我还蛮喜欢的。 不知道大家对于通勤怎么看。之前上班住的地方离公司骑车 5 分钟就到，公交车 2 个站。 我对于超过半小时的通勤有强烈的抵触。所以我宁愿多花点儿钱，图个心情愉悦。 现在每天床离「办公桌」的距离不超过 1 米，这就很 Nice~ 2、 我挺喜欢「分享」这件事，特别是还能够帮助到其他人的话。 我很憧憬像 阮一峰、陈皓、Lenciel、Draveness 这样的大佬们，它们总是把一些复杂的东西用简单的叙述描述得很清楚。 看他们的文章，毫不夸张地说：如沐春风。 我自己也从最开始写点儿小东西，到现在也想输出一些系统的更有价值的东西。（自己有个小破站——wmyskxz.com） 虽然也一直没多少人看（主要是自己级别不够），但也收到不少粉丝的支持和鼓励，还有很多「正反馈」——比如工作机会和写书邀请。这些都让我有了更多坚持下去的勇气。 每次收到读者的消息、鼓励，都蛮开心的。特别是当他们反馈说有帮助的时候。（甚至有粉丝给我写小作文..） 现在每周天，我都会把自己一周以来的学习和值得分享的内容整理成「一周精彩内容分享」发布出来，不知不觉已经 12 期了。 不出意外的话，「分享」这件事，我会长期坚持下去。 3、 之前在一家 K12 教育公司上班，有时候会帮客服同事解答一些小朋友提出的编程问题。（现在小朋友太厉害了..） 说实话，一直在写后台代码，虽然说写的代码确实有几十万人在使用，但你很少能直观地感受到你所提供的价值。 反而是这些小事，是跟小朋友们的交流，让你会有切实的感受。 我现在通过网易的平台，在「我的世界」发布自己设计的 Mod 来赚钱（目前是主要来源）。有一次我回老家，发现老家的小朋友居然在玩「我的世界」。 那一刻你会感觉到你做的东西，真实地连接着用户。 特别是我现在又充当策划、又充当产品，负责开发，需要运营，有时候甚至客串一下美术。 拿着自己设计的东西去直面真实的市场，还挺有意思的。 有时候信心满满，却惨遭打击。 有时候心血来潮，就为自己图个新鲜图个爽。 但也有时候，我们“小获成功”。 这些 Mod 都真实地运行在玩家们的手机上，有好有坏。但是能真实地链接玩家，面对真实的市场，提供独有的价值，还是挺有成就感的。 4、 我不喜欢酒局。我指的是相当客套、相当社会那种。 之前上大学的时候，在班里当班长。有时候会通知一些无意义的讲座活动，必须要班上多少个人去参加，还是每次轮流到哪个班哪个班的那种。 我就会选择性地不通知或者不强制（中国好班长）。可能是从小被放养长大，我对这一类莫须有的东西有天然的逆反心理。 身在职场的好朋友也经常跟我吐槽这一类不想参加又不得不参加的「局」。 我比较幸运地没有参与过这一类。单纯做技术还是会好一些。 我也不喜欢节假日的那种「人潮汹涌」。简直能让我窒息。 现在上面这两个我不喜欢的东西，都可以被我“隔离”得远远的。（加通勤一个） 5、 有一天下午写完代码，看外面太阳特别好。于是想着出去走走，顺便买杯奶茶喝喝。 回来的路上，过天桥。太阳光正好把天桥分为阴暗两面。 当我跨过阴暗的一面，阳光将我洒满。正好一撇头，看见桥下拥堵的车流。耳朵里塞着喜欢的音乐，手里拿着喜欢的奶茶。 那一刻，脑海里一幕一幕，只觉得幸福。 关于不上班1、 从某种程度上来说，我确实过上了令人“羡慕”的生活。 不用朝九晚五的打卡签到，不用硬着头皮出去应酬，不用做违心的事只为了应付 KPI，也不用面对复杂的职场关系，想吃啥就可以吃，想去哪儿玩儿就可以去。 但其实只有自己知道，这其中的“难”… 不上班之后，能打断你的事情比你预想的要多得多。最新的电影要不要看？综艺要不要追？游戏要不要打？聚会参不参加？面对亲戚朋友的质疑关心你又如何反应？ 把生活比喻成一条河流是有道理的。这另一层意思就是：就算你不动，生活也会推着你往前走。 当你一下子“自由”之后，生活不推你了，你还继续走吗？是往前走吗？哪里又是前呢？ 一方面要聆听自己内心的声音，另一方面要独自处理生活的琐碎，以及应付家人朋友们的关心，其实并不容易的。 从上图中节选自去年四月份记录的日记，你就能够感受得到那种一边给自己内心喊话，一边过着颓废生活的纠结。 一个人的时间确实能够获得难得的专注，不仅仅包括学习、工作，娱乐也是一样。特别是当生活不再推着你的时候。 去年 10 月份，挣了点钱，于是想着给自己放放假。这一放假不要紧，一不小心就给形成惯性了，也是花了差不多三个月之久才把自己的状态调整回来。 2、 不上班并不是意味着不工作。这也可能意味着：工作和生活就分不开了，醒来就是工作，工作就是生活。 事实上，醒来的大部分时间都用来做自己的事情了。 也有不少熬夜奋战的时刻，比如突然有什么想法想要尝试一下，就想熬夜写写；或者是写什么东西入了迷，也就忘了时间。 “自由”之后，我确实拥有了很多时间，但反而让人最不自由的就是时间了。 就拿写博客来说吧。之前上班时间那么紧，却总能找到间隙输出技术文章，现在时间多了，反而输出感觉不太够了。有时间给你反反复复思考一些琐碎的事情，反而因为「完美主义」，效率给拉下去了。 我现在的解决办法就是：有想法了就一鼓作气地做完，做完再说。 比如有什么游戏上的新点子，跟小伙伴交流一下大方向没问题，就直接上手做！直接先把主要逻辑弄出来再说。上面那个魂环我就熬了几天大夜肝出来的。 再比如之前写关于「如何评价 wolai 这个产品？」的回答，就直接肝了两天，一口气写出来的。 现在我写文章、写游戏，都是这样的，这样的方式挺适合我。因为我发现一旦这件事情超过几天没有去动手做出来或者开始实践，那么后续想要完成也就挺难的了。 另外我也挺认同我之前分享的一个观点：做得快比做得好更重要。 拿我做游戏举例。每做一个游戏 Mod，我都会往我的脚本库里积攒一些东西，以至于现在我开发越来越轻松。能够让时间成本降下来，也就可以实现越做越快、从而多做、越多做越好的良性循环了。 3、 扯远了。来谈一下为什么会走上这条「不上班」不归路吧。其实不上班这个选择，还是挺需要勇气和一点理想主义的（说直白点就是傻气和天真劲儿）。 对于我来说，最容易的选择就是上班，只需要努力就行了，并且收入还不会低。 当时刚被辞职，本来想休息几天的，结果第二天就有 HR 打电话邀约面试.. 我心想算了，不休息了，找工作得了.. 那段时间最怕听到的就是面试官问我：「你对 HashMap 了解多少？」。说实话，有点被问吐了。 一方面我在经历过的千篇一律的面试，那些反反复复的面试套路问题之后，开始对「工作」重新审视起来：「无非是换个地方拧螺丝而已吗？」 另一方面又看向公司高层和那些技术大牛们，他们背上了房贷、车贷，家里老婆孩子等着照顾，一刻不敢停歇忙碌的身影，我问自己：「这就是我未来理想的生活吗？」 答案很明显。 我不想要 30% or 50% 的幸福，我对自己承诺的是 100% 的幸福 (尽管这一点都不现实，甚至有点魔幻主义)。 正好又有成为 MC 开发者的机会，至少生存问题不会太吃紧，自己也想要尝试输出一些东西，咨询了前辈、朋友，就直接上路了。 只是没想到这一出发，已经一年多了，并且越来越不想回头。 4、 前一段时间我翻看了一下之前上班时记录的周报，突然觉得自己还挺“卷”的… 我其实觉得自己挺适合待在职场的，不怕吃苦，积极主动，能力在线，并且善于思考反思。哪个团队不爱呢。 只是机缘巧合吧。在大家都选择上山的时候，我选择找了一条人迹罕至的小径，在这里找了一个凉亭，舒舒服服地喝茶。 并且，我还希望做那个，在你们上山的时候，帮你们递瓶水的人。 5、 另外我还发现一个有意思的事，那就是我所在的环境里，上一辈人对于工作，特别是好工作有一种特殊的执念。并且大概率会觉得好工作的天花板就是「公务员」。 不知道你们的环境是怎样的，至少我时常还是会听见或看见： 不知道做什么工作？考个公务员吧？ 干得不开心了？回家考公务员吧？ 工作很辛苦？要不回家考个公务员算了？ …. 好像 「公务员」 是一把开启人生答案的 「万能钥匙」，前段时间在看《精进2》，里面有一段话瞬间挺有感触的。 大概意思就是：如果有人告诉你有一种包治百病的药，那么你可能会觉得对方有病。 这是当然，因为病跟病不一样，这意味着治愈病要满足的限制也不一样，根本就不存在所谓的「万能药」。 但是这事儿放在「找工作」上，特别是 当「公务员」 上，我发现人们没有像「万能药」那般持有怀疑态度，反而有些深信的意味。 我反正更深信 Lenciel 说的那样： 究竟该怎么活，自己真正享受什么，喜欢什么，很多时候不是通过循规蹈矩的生活就能弄明白的，总得为什么东西拼过。 关于自律1、 挺重要的。不管上不上班都挺重要的。 之前上班的时候，因为家离得近点儿，9 点上班，我就八点半到公司，看半个小时的书。 就是半个小时时间（实际可能长点儿），经过几个月时间，看的书竟然都比大学时间总共捧起的课外书都多，不禁唏嘘。 另外早起我是从小就习惯了。发现自己早上精神集中一些的时候，就索性把闹钟定在了 5 点半。 当大家正在朦朦胧胧在被窝纠结起床的时候，我已经吃完早饭，看完书，回顾昨天写了晨间日记，已经开始新的一天了。 但后来就蛮难坚持的了，一方面是早上真的饿，早餐店真的没开门。另一方面，自己也贪玩了起来。再另一方面，渐渐有了自己的环境，早起的需求就不那么大了，也不想自己那么“另类”了。 现在基本维持在 7 点之前起床，12 点前睡觉，午睡半个小时。 我时常都在想，我应该如何离「平庸」远一些，或许自律是个不错的开始。 2、 另一个比较受益的事情是：我每天早上几乎都会记录一下昨天发生的事情。 不知不觉间已经坚持差不多快两年了。当然记录有时也是断断续续的。就拿 2020 年来说，总共也才记录了 179 天。今年倒是自律许多。 一个方面是，真实地记录自己有好处，已经过了一天，你看待很多事情更加客观，能够进行更好的反思。 另一个方面是，很多事情，你不记录下来，他们就真的“消失”在了你的生命。 我觉得信任大脑可不是一个好主意。 3、 关于自律，我的个人感受是，你几点起床，做什么其实并不重要。重要的是自己要在一个状态里面。习惯了也就行了。 所以为什么人是环境的产物呢。只不过很多时候这个环境需要自己去创造罢了。 有些诱惑，抵挡不住还是拿远一点比较好。如果实在家里觉得太安逸，现在也有很多自习室可供选择。 总之，你需要创造一个自己的环境。 只不过弊端就是，习惯了，也挺难改变的。譬如我一直期望自己能够一边旅游（或者别的什么，总之不待在家）一边工作，但是我发现我习惯了自己家里的工作环境，换个环境效率直接拉胯。 渐渐地，也就把自己圈在了家里。 有时候家里会担心「脱离社会」，但我的视野正好相反，反而是他们「更加远离社会」。 这几年通过公众号，认识了天南地北的人。透过网络世界，看到了各式各样的生活和世界。其实，你只要不是主动“闭塞”交流的窗口，你很难做到的「脱离社会」。 反而是“管中窥豹”的长辈们，先入为主地理解了这个本来丰富多彩的世界。现在越来越多的事，正在以他们看不懂的姿态越来越多地绽放。（比如直播、抖音） 特别真实的例子是，当我给我妈说我的收入时，她的第一反应是：哎呀，儿子，你这个合法吗？ 结尾说实话，我属于幸运的那一拨。幸运地遇到这样的时代，幸运地喜欢计算机，幸运地家里没有大的负担，所以我才能像现在这样“自由”。 说到底，人生很长。重要的不是 25 岁还没有做到什么，是你才 25 岁，还想要做到什么。下好自己的赌注，心平静气地接受结果就好了。 希望大家都能够奔赴在各自想去的路上吧，共勉。 另外欢迎各位来我的公众号（wmyskxz）喝茶聊天呀。平时主要分享一些技术和所思所想，就算不搞技术，每周天的一周分享看看也总归是好的嘛~ 卑微端茶~","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 12 期）：提高收入的根本途径","slug":"weekly12","date":"2021-04-25T01:45:45.000Z","updated":"2021-04-25T01:45:42.837Z","comments":true,"path":"2021/04/25/weekly12/","link":"","permalink":"http://www.wmyskxz.com/2021/04/25/weekly12/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：提高收入的根本途径（观点来自：阮一峰）","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：提高收入的根本途径（观点来自：阮一峰） 挪威和孟加拉是两个截然不同的国家，但是它们有一个共同点：渔业都是两国的主要产业，很多人以打渔为生。 挪威渔民非常有钱，挪威是世界上最富裕的国家之一，人均 GDP 接近 8 万美元。 孟加拉国属于世界最贫穷的国家，人均 GDP 大约 2000 美元。 同样是打渔，为什么渔民的收入相差那么大？ 你可能马上就会想到，他们的设备不一样，影响了收入。挪威渔民拥有大型现代化渔船，接受过各种培训，只要几个人就能捕到大量的鱼，所以收入高。孟加拉渔民只有小渔船，捕鱼能力有限，所以收入低。 上个世纪 70 年代，发生了一件事情。挪威向孟加拉国赠送了现代化渔船，作为援助。 孟加拉渔民现在有了同样的设备，能够提高收入吗？ 答案还是不能。仅仅过了一年，这些现代化渔船就无法使用了，援助行动以惨败告终。孟加拉渔民缺乏相应的知识和技能，无法操作挪威渔船，同时也缺乏进行维修的基础设施和零配件，没有任何学校教渔民怎么修理这些船。现代化设备在孟加拉渔民手里，很多功能发挥不出来，出海遇到故障，只有眼睁睁看着整艘船坏掉。 一条现代化渔船，其实不仅仅是单纯的一条船，而是许多千丝万缕的因素联合在一起，使它能够建造出来，并得以良好地运行。 这件事的启示就是，一个国家比另一个国家富裕，很大程度上并不取决于人民是否努力工作 （孟加拉人的努力程度，事实上可能远胜于挪威人），也不取决于设备，而是取决于许多其他因素，比如资本、知识技能、基础设施、销售渠道等等。所有这些外部因素，才是国家富裕的根本原因，人民的努力不是决定性因素。 这个道理放到人的身上，也是一样的。人与人的收入不一样，原因不是甲比乙更努力，而是很多外部因素综合起来的结果。 甲拥有的资本、技能和环境条件超过了乙，使得甲所在的层次高于乙。一个餐厅服务员，无论怎样努力，收入恐怕都不会超过基金经理，道理就在这里。 这告诉我们，如果你想真正地提高收入，努力仅仅是一部分的因素，更重要的是，你必须设法提升自己的资本、技能和环境的层次。 你需要的不是”水平方向的努力”，而是”垂直方向的努力”。共勉。 热点新闻1、我国首辆火星车命名正式公布：“祝融号” 4 月 24 日，中国航天日主场活动开幕式在南京举行，开幕式上，我国首辆火星车名称揭晓。 “祝融号”火星车将在火星上开展地表成分、物质类型分布、地质结构以及火星气象环境等探测工作。计划于 5 月至 6 月择机实施着陆任务。 2、Apple 发布会 21 日凌晨，Apple 举行了 2021 年第一场线上发布会。发布会上，此前传闻已久的蓝牙物品追踪器 AirTag 终于正式发布，搭载 M1 芯片、经过全新设计的 iMac 也正式亮相；令人没有料到的是，iPad Pro 系列除了常规配置升级、以及 12.9 英寸版本支持 mini-LED 显示屏以外，M1 芯片也正式来到了 iPad 产品线上。 此外，发布会上还公布了新款 Apple TV 4K、iPhone 12 系列的新配色，以及诸多新配色和新款式的配件产品等。 3、人类首次地外受控飞行实现 4 月 19 日，“机智”号成为了人类首架在其他行星上飞行的可控旋翼飞行器！整个飞行过程，持续了 39.1 秒。 在火星飞行难点主要在于稀薄的空气和充电问题。这意味着飞行器需要更高的转速和更强大的零部件才行。 4、印度新冠疫情： 三天内近百万人确诊，医疗系统濒临崩溃边缘 印度新增新冠病例持续破纪录，医疗体系正面对巨大压力，病床和气氧供应也非常紧张。周六（4 月 24 日），印度公布有超过 34 万宗确诊个案，连续第三天刷新世界纪录，24 小时内死亡人数为 2624 人，同样再次破纪录，累计全国有 18.9 万人死亡。 5、一句话消息 GitHub 新增了一个徽章系统，只要你拿到了某项成就，个人页面上就会显示相应的徽章。目前主要有三种徽章：火星徽章（ NASA 火星探测用到了你的仓库）、北极徽章（你的仓库被放入北极保存）、赞助徽章（你资助了他人的开源项目）。 4 月 23 日，人民海军官方宣传片《大海向党旗报告》震撼发布，新时代的人民海军正在走向深蓝。多型装备镜头首次曝光！ 最近，科学家首次创造了人猴嵌合体胚胎。尽管伴随伦理问题，但仍然证明了：人类细胞可以在猴子胚胎中存活并增殖，数量相对较高。研究小组说，目标是为研究生物学发展，进化，疾病进展和治疗方法提供更好的模型。 近年来，加密货币矿机已加剧了显卡短缺现象，这对于期望购买新 GPU 的沮丧的游戏玩家而言，无异于雪上加霜；而一种新出现的加密货币 Chia 已影响一批不同的 PC 部件：即硬盘。Chia 尚未公开发售，它旨在成为一种环保型的加密货币，因此它不是依靠耗电的 GPU（或 ASIC 设备），而是充分利用硬盘的功能：即耗电量低得多的 SSD 或硬盘。 文章1、阿里技术专家详解DDD系列 第五讲：聊聊如何避免写流水账代码 这是阿里系技术文章 DDD 系列的第五讲。无关乎 DDD 你也应该看的「内功心法」，该系列每一篇都质量杠杠，值得细读几遍。 2、毕业两年，我要跳槽去阿里巴巴了，做个阶段总结，开启新的人生 作者讲述了自己是如何从普通二本，大四找不到工作，到如今跳槽阿里的经历和一些思考。 3、重置并非万无一失：设备转手前不能忽视的一件小事 设备恢复出厂设置有可能并不能彻底清理掉你的个人数据，第三方很有可能会「偷偷地」恢复你的数据，造成隐私等严重问题。 我们在出售、赠送或折扣电子产品之前，能够做的，切实保护自己隐私的事情。 4、关于读书 作者从应不应该读书、要不要读书、应该读什么书、应该怎样读书四个方面，进行了深入的思考。 5、业余编译器作者资源（英文） 这里收录了一些关于业余开发编译器的一些资料。内容比较深入，而且几乎全是英文的 PDF 资料，感兴趣有能力的读者可以看看。 6、2021全国职场人阅读报告 这是一份关于职场人阅读的详细报告。调查显示，2021 年职场人纸质书+电子书平均阅读量为 19.54 本，超过去年的 18.75 本。 7、关于 AirTag 的一切 苹果最近发布蓝牙标签 AirTag，贴在各种物品上面，然后手机可以查看该物品的位置。最特别的是，它的蓝牙信号可以被附近的所有苹果设备读取，这意味着不管被带到哪里，都可能追踪到它的位置。 如果你对此感兴趣，这是一篇关于 AirTag 比较全面深入的文章。 8、Python 装饰器详解 Python 修饰器属于元编程的领域，是非常实用的编程技巧。这里有 11 条实用的建议。 9、最多能创建多少个TCP连接？ 就像文章中说的：结论不重要，重要的是思考这样的问题是要去寻找限制条件，仅此而已。 10、美股市场上学到的道理 作者分享了这几年在美股市场上学习到的道理。 好奇星人1、人工智能已在哪些领域超越了人类的表现？ 简单来说就是：在多数条件和边界都清晰的决策对弈边界清晰的任务中，人工智能早已超过人类。 比如：国际象棋、围棋、图像和物体识别等。 2、芯片是怎样炼成的？ 长图漫画，轻松科普。 3、什么是 Mini-LED（视频） 苹果从 2021 年开始替 iPad Pro 和 MacBook 采用 Mini-LED。如果你对此有好奇，可以看看这个 4 分钟的科普视频。 言论1、 中国式调休和公摊面积有异曲同工之妙。 –知乎用户 2、 理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。 –博士学位论文《人机交互式机器翻译方法研究与实现》致谢 3、 人类飞行器两次划时代意义的突破。 –知乎用户 4、 虽然工程师需要具备一些开发者的技能，比如写代码，但从根本上，工程师的能力，和代码无关。 –王建硕 5、 计算机是中国普通家庭最好的专业。因为它最公平， 最纯净，不论出身。是普通人阶级上升最好的选择。 –知乎用户 6、 内推最有价值的是人脉背书。 –大家都内推，内推还有什么意义？ 7、 在工位上，我们眉头紧锁，键盘敲得噼里啪啦响，但在屏幕上，是一个 996 以外的世界，我们用自己的视角看待互联网，而互联网又用另一个视角看待我们。 –在大厂，假装996 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 11 期）：寻找你愿意忍受的痛苦","slug":"weekly11","date":"2021-04-18T01:17:45.000Z","updated":"2021-04-18T01:17:44.808Z","comments":true,"path":"2021/04/18/weekly11/","link":"","permalink":"http://www.wmyskxz.com/2021/04/18/weekly11/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：寻找你愿意忍受的痛苦(观点来自: 阮一峰)","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：寻找你愿意忍受的痛苦(观点来自: 阮一峰) 约翰·乌歇尔（John Urschel）是一个职业橄榄球运动员。 2017 年退役后，他改行研究数学，先在宾夕法尼亚大学拿到数学硕士，现在麻省理工学院攻读数学博士。 约翰·乌歇尔从小就对数学有兴趣，在他还打球的2015年，就在学术杂志上发表过论文《用于计算图拉普拉斯算子的 Fiedler 向量的级联多重网格算法》，这种题目一看就属于专业数学家的范畴，说明那时他的数学水平已经不低了。 因此，外界对这件事情的看法就是，他具有数学天才，所以改行去读数学也很正常。 一次采访中，他回应了这种看法。说得真好，推荐给大家。 “在别人眼里，数学对于数学家是很容易的。错了，那是一场斗争，艰苦而孤独，不确定能得到成果，而且需要很长时间的奋斗。数学家是热爱斗争的人。“ 他的意思是，即使他真心热爱数学，依然觉得数学研究非常艰苦。（注意，一个真心热爱的人还说艰苦，如果换成普通人，感受可想而知。）他能够坚持下去，并不是因为他觉得很容易，而是因为他可以忍受这些痛苦。 这段话对我很有启发。大家往往只看到成功时的荣耀，而忽视成功之前那个痛苦的过程。英国著名作家奥威尔就说过：”一个人如果将他自己描述得很好的话，他十有八九是在撒谎，因为任何生命从内部审视都只不过是一系列的失败。” 实际上，一个人能够成功，仅有热爱是不够的，还必须有强大的忍受能力，能够吃苦。 很多人建议，寻找人生方向时，你应该听从自己的内心，寻找真正热爱的事情。我现在觉得，更现实的建议应该是，寻找你愿意忍受的痛苦。你在哪一个方向上，愿意心甘情愿地、经年累月地吃苦，具有最大的忍耐，”虽九死其尤未悔”，那就是你应该选择的方向。 你能在某件事上赢过别人，原因很可能不是你比他强，也不是你比他更热爱这个事业，而是你比他更抗打击。生活虐你千百遍，等到别人都放弃的时候，你还没有放弃。 热点新闻1、央行工作论文引热议 4 月 14 日，央行发布工作论文《关于我国人口转型的认识和应对之策》，得出了一个时评圈已经存在了多年的共识：应全面放开和鼓励生育，切实解决妇女在怀孕、生产、入托、入学中的困难。 这篇论文之所以引起围观，只在于一个论断：“（中国要）重视理工科教育，东南亚国家掉入中等收入陷阱原因之一是文科生太多。” 要理解这一点，我们决不能断章取义。但之后选文还是选理，应该不用多说了吧？ 2、苹果公司宣布 4 月 20 日举行新品发布会 预测称，除了可能性较大的新款 iPadPro、iPad mini、AirPods 3 和 AirTag，还有一些传言表示 AppleTV、全新设计的 iMac 等产品线也将更新。 3、菜鸟驿站可以免费送货上门了，覆盖北上杭 4 月 15 日上午，菜鸟驿站通过官方微信公众号发布消息称：今天开始免费送货上门。 送货上门首批启动北京、上海和杭州三个城市，包裹入站后，消费者可以自主选择送货上门或到驿站自提，两项服务均不产生任何费用。据介绍，目前在北上杭三城 90% 以上的菜鸟驿站站点完成了服务开通。 4、自动驾驶公交车在重庆永川“跑”起来了 4 月 12 日，重庆市永川区举办了自动驾驶公交车运营启动暨智慧交通项目战略合作签约仪式。活动当天，全国首个自动驾驶公交车示范运营项目正式落地重庆永川，这标志着中国自动驾驶落地迎来重大突破，可进行收费模式探索。 作为全国首座启动自动驾驶收费示范运营的城市，重庆市民可以通过 Apollo Go、百度地图、永川服务公社等 APP 端口进行预约，体验自动驾驶公交车出行。运营路线途经永川神女湖、农机校、兴龙湖、文理学院东门、观音山公园等站点，双向里程近 10 公里。 文章1、15 个著名的设计心理学原理以及在设计中的应用 “除非有更好的选择，否则就遵从标准”。 2、技术债的真正含义（英文） 为什么会发生技术债？发生技术债的两个原因？以及如何破局。 3、一个技术总监的忠告：你精通那么多技术，为何还是做不好一个项目？ 本文试图总结出了一些问题项目普遍存在的共性问题，并给出相应的解决方案。 编写高质量可维护的代码既是程序员的基本修养，也是能决定项目成败的关键因素。相信看完你也会一定程度的收获！ 4、谷歌地球多年来最大的更新-Timelapse（英文） 谷歌官方博客。介绍了自 17 年以来最大的更新，现在所有人都可以利用 Google Earth看到过去 37 年中，对 2400 万幅卫星照片编译而成的 4D 交互式体验地图，并见证四十年的行星变化。 5、对话 Vue.js 作者尤雨溪 《程序员》发布的，关于尤雨溪的「开挂」人生分享，深度分享他在将 Vue 项目打造成为业界主流框架的八年间鲜为人知的心路历程。 6、GitHub Actions 被滥用挖矿 最近，有人向各种 GitHub 仓库疯狂提交 Pull Request，只为了触发 GitHub Actions 跑他的挖矿脚本。本文详细介绍这个事件。 7、如何用 5000 行 JS 撸一个关系型数据库 作者使用 5000 行，实现了一个轻量级的关系型数据库 JSDB（开源）。其核心是一个SQL编译器，支持增删改查。 8、谈谈 Kubernetes 的问题和局限性 每个技术都有自己的生命周期，虽然 Kubernetes 是当今容器界的扛把子，但是未来的事情没有人可以说的准。我们要时刻清楚手中工具的优点和缺点，花一些时间学习 Kubernetes 中设计的精髓。 9、比特币入门新手指南（英文） 这是一篇为刚接触加密货币并想要了解比特币的个人指南。 10、中国的人口（英文） 使用数据，剖析了中国人口的相对数量。总体而言，中国的人口规模大于近四个地区的总和：南美，欧洲（不包括俄罗斯），美国和加拿大以及澳大利亚和新西兰。 好奇星人1、五一假期，该如何找到「人少不贵」的旅游地点？ 五一小长假快到啦，有需要的童鞋拿走吧~ 2、用蛇毒毒毒蛇，毒蛇会不会被蛇毒毒死？ 分为两种情况。第一种是毒蛇咬自己，通常毒液不是致死直接原因，而是咬伤；第二种是被其他毒蛇咬，通常来说是能造成有效伤害的，但有些毒蛇作为捕食者，进化出了对自己猎物（当地的某些毒蛇）毒液的抗性。 3、日本政府正式决定将福岛核污水排入大海，会对周边国家造成哪些影响？目前有哪些解决方法？ 简单叙述就是。核废水会先往美国漂，然后再漂回来（年内就会回来）。 中国大陆地区沿海理论上受影响不大。 新奇1、Psilocybin: 神奇的蘑菇化合物 “有希望 “治疗抑郁症。 言论1、 目前，W3C 规范有 1,217 个，总字数超过 1 亿。这意味着，已经不可能从头开发一个全新的网络浏览器，因为网络已经变得如此复杂，创建新的网络浏览器的工作量可与阿波罗登月或曼哈顿计划相媲美。 –《网络浏览器的无限范围》 2、 很多人认为他们需要使用面向对象编程，实际上他们只需要模块化。 –Hacker News 读者 3、 目前中国总体的物质资源已经够大家生活了，但没有人这么想，大家都觉得不发展就完蛋。 –喧嚣的内卷：中产青年为何自称“打工人”？ 4、 挣钱是世界上最体面的生活方式。 –《迷茫时代的明白人》 5、 1982 年，最常见的财富来源是遗产继承。 2020 年，最常见的财富来源是创业与投资。 –当下，人们是怎么赚钱的？ 6、 这段歌词的优势不仅仅在于朗朗上口、容易模仿，还在于它提出了一个问题，但没有给出解答，以至于每个人都可以给出一个自己的答案。 –“什么是快乐星球？”魔性出圈 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 10 期）：别让自己\"墙\"了自己","slug":"weekly10","date":"2021-04-11T02:57:45.000Z","updated":"2021-04-11T03:06:37.290Z","comments":true,"path":"2021/04/11/weekly10/","link":"","permalink":"http://www.wmyskxz.com/2021/04/11/weekly10/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：别让自己”墙”了自己","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：别让自己”墙”了自己 三月初，我们发布的一款游戏（Mod）获得了”小小的成功”，但随之而来的一些竞品也在清明节前如期而至，我立马下载下来玩了一下，觉得它们很多地方都很一般，甚至粗糙，但内容上却比我们完整完善得多，也因此获得了不错的销量。 我由此想到了两个故事。一个关于马斯克造车造火箭，另一个关于球球大作战。 通常，我们要造一台电车，首先就要研发电池，这是电车的一个核心技术。必须研发出高性能的、高马力的或者大容量的电池，才能研究出更好的汽车。 但马斯克不是这么想的，他用的就是最普通的松下电池，用一大堆给它绑一块，然后组成一个特别合理的结构，就形成了特斯拉。 所以马斯克在研发电池这个问题上，没有花太多的钱和精力，很快就领先了所有的电车。 这个思路同样被马斯克用在了造火箭上。他就是把一些小火箭绑在一起，就成了一个大火箭。 这样做的好处就是，小火箭在空中还能分离开来回收利用，不至于造一个大火箭直接整个飞走了。这让 Space X 一家私营企业把国际空间站的运输成本降至原先的 5%（降低了 95% 的费用）。所以 Space X 现在就是最牛的火箭公司了。 另一个故事是来自洋哥（公众号：findyi）分享的血泪教训。2015 年，洋哥团队用一个月不到的时间就上线了一款实时玩家操作的大球吃小球的竞技游戏。但最终被「球球大作战」打败，错失 10 个亿。 我的创业团队都是 360 班底，大家执行力非常强，不到一个月我们的游戏就上线了。但上线后碰到一个问题，实时同步导致游戏有点卡。这时候 360 出来的一个工程师建议：“要不我们做个假实时，用机器人和玩家互动”。 当时我心气非常高，直接否决了这个建议，怎么能做个假的？之后，这款游戏按照实时同步的方案上线，迅速积累了不少用户。 这个时候「球球大作战」出来了，我惊奇的发现他们居然一点也不卡！因为球球大作战更流畅的用户体验，我们很快败北。 后面的故事大家都知道：「球球大作战一年积累千万用户，之后积累数亿用户」。 很长一段时间，我都觉得是我们没处理好实时同步问题，直到有一天和一个 360 的技术总监聊天，他告诉我，360 后来也做了类似游戏，但是以 360 的服务端团队都干不过球球大作战，之后他们才知道：上线初期「球球大作战」没有实时同步！采用的方案是机器人和玩家互动。 …. 在 360，周鸿祎有一次跟我们开会，说了这段话：“360 能走到今天，幸亏我是门外汉，乱拳打死老师傅。门外汉没有思维定势，不会心存敬畏之心。安全行业别人干了 20 年，但是我啥也不懂，正因为无知无谓，我们就挑了一个点，杀流氓软件”。 不知道大家看完这两个故事有什么样的感想。很多时候我们觉得做一件事情条件不够、完美主义，往往是因为自己”墙”了自己，首先不要有思维定势，意识到自己有更多的可能性，才能在更高维度上做成一件事。 就像当初非得要发明一个在太空能用的油笔，花了几百万，而苏联人用铅笔就解决了这个问题。 本期分享较多，感谢耐心观看。 热点新闻1、LG 正退出手机业务 韩国 LG 电子株式会社 5 日宣布，因其手机业务持续亏损，企业决定缩减手机生产和销售规模，7 月底彻底停产。 这意味着 LG 在经营 26 年手机业务后，最终放弃了这块市场。 另外有意思的是，有社区正在请愿开源 LG 手机（包括硬件和软件）。 2、90 亿美元 Java 案大翻盘！美最高法院判谷歌未侵权 本周一，美国最高法院以 6 票支持 2 票反对，通过了甲骨文诉安卓系统 Java 源代码侵权案的裁决结果，宣布谷歌并未侵权。 这场长达十年的诉讼争端，两次败诉的谷歌最终完成了翻盘。 3、货车司机疑因定位掉线被罚款自杀 4 月 5 日，金德强途经唐山市丰润区超限检查站，因北斗定位掉线，被处以扣车、罚款 2000 元。随后他去附近的商店购买了一瓶农药，在留下遗言后服毒，并于当日 23 时抢救无效离世。 自杀前，金德强在微信群中说，“我不是不值 2000 元钱，我是为了广大卡车司机说句话……” 遗书的尾声，金德强留下了自己的车牌号，1308。这个车号上曾经承载着一家人希望，是他 10 年运输事业的缩影，也是被强硬扣下时，压垮他的最后一根稻草。(via) 4、顺丰发一季度业绩预告：估亏11亿 4 月 8 日晚间消息，顺丰控股公告称，预计第一季度（2021 年 1 月 1 日至 2021 年 3 月 31 日）净亏损 9 亿-11 亿元，上年同期盈利 9.07 亿元。 5、泄露用户隐私信息 意大利启动对LinkedIn调查 4 月 9 日，微软旗下 LinkedIn 正遭到意大利隐私监管机构的调查，因为这家职业社交网站泄露用户个人数据，包括用户姓名和电话号码等。 此前，爱尔兰隐私监管机构表示正在对全球最大的社交媒体网站 Facebook 展开调查，因为上周末媒体报道称，Facebook 泄露了超过 5 亿用户隐私数据。 但 Facebook 方表示：并不打算通知相关用户 6、日本政府基本决定将福岛核污水排入大海 日本政府 4 月 9 日基本决定将福岛第一核电站核污水排入大海。4 月 13 日，日本政府将召开内阁会议，正式决定。 7、市场监管总局依法对阿里巴巴垄断行为作出行政处罚 2020 年 12 月，市场监管总局依据《反垄断法》对阿里巴巴集团控股有限公司（以下简称阿里巴巴集团）在中国境内网络零售平台服务市场滥用市场支配地位行为立案调查。 2021 年 4 月 10 日，市场监管总局依法作出行政处罚决定，责令阿里巴巴集团停止违法行为，并处以其 2019 年中国境内销售额 4557.12 亿元 4% 的罚款，计 182.28 亿元。 8、猴子用“意念”打游戏！马斯克称未来瘫痪患者能隔空玩手机 9 日，埃隆·马斯克创办的脑机连接公司在社交媒体上公布了一段猴子用自己的意念玩电子游戏的视频。马斯克表示，这一技术的远期目标是让瘫痪的人可以通过意念使用手机。 文章1、现代 JavaScript 教程 Github 上被翻译成各个语言的 JavaScript 教程，中文版 Star 4.4 k，原版 14.7 k。 2、文本编辑器比较（英文） 文本编辑器是程序员的必备工具，这里比较了十几个常见编辑器的性能，包括内存占用、文件打开时间、正则搜索速度、大文件支持等方面。 3、2021 年如何制作 Python 包（英文） 如果您不时地编写了一个有用的 Python 实用程序，并希望与其他人分享，最好的方式是制作一个 Python 包。这里是一个细致的教程。 4、所有C++20 核心语言功能以及示例（英文） 一个页面对 C++20 核心功能进行了简短的总结。 5、17K star 仓库，解决 90% 的大厂基础面试题 这是一份开源的面相前端的面试资料，作者已维护三年之久，至今也有 17k star。 6、什么是数字游民 数字游民是通过互联网远程工作方式获得收入，可以在全世界任何地点生活的人。 这是来自「数字游民指南」社区的介绍。该社区提倡 [远程办公、环游世界] 的自由生活方式。 7、登上火星，我们会看到什么？ 人类探索火星虽已有 61 年。这是一篇让你系统了解「火星的一生」的硬核文章。 8、俄式方案，助力日本暴打核电站 文中讲述了日本核废料的始末，很清晰。看完直呼日本真会过日子。 俄罗斯提供了一个黑魔法打败黑魔法的方案：在福岛核电站原址上扔一个氢弹。氢弹没有辐射，非常清洁，再计算好量，让核材料的链式反应释放完全，放射性几乎就没有了。 9、编写SQL查询的最佳实践（英文） 收录了一些编写 SQL 查询的最佳实践。 10、CPU 和 GPU - 异构计算的演进与发展 非常硬核地讲解了 CPU 和 GPU 的演进与发展。 好奇星人1、点读笔是怎么做到“哪里不会点哪里”的？ 简单来说，广义上的”点读笔”经历了三次大的迭代。 第一代产品点读机，是通过磁力让设备感知当前所指向图文内容的具体坐标，然后由语音压缩芯片播放预先存储在卡带中的音频信息。 第二代产品点读笔，是通过红外光的笔尖扫描所谓“CMYK全彩印刷”隐藏的不影响正常阅读的 OID 编码，来发对应的的音频内容。 第三代点读设备——即扫读笔、翻译笔的工作原理，每一个现代人能轻松秒懂。 2、你为什么总是抓不到娃娃? 简而言之：钢爪力度（甚至抓取和拾起两个阶段可以单独设置）和操作钢爪的时间都是可人为设置的。 而且，精明的娃娃机厂商还发明了另一项功能：可以直接设定一个固定的成功概率。 就算你是下面这样的奇才，商家依然有治你的办法（设置最大支出限制——也就是说抓走太多娃娃就不让你玩了），亏本是不可能的。 新奇1、疫情带来“意外之喜”，粉红海豚重回香港水域 由于疫情的影响，香港轮渡服务被削减，水域污染减少，粉红海豚重新开始活跃，现身频率增加。但专家表示，这种突破是暂时的，香港珍稀动物的未来并不光明。 言论1、 它不仅仅是一根棍，它代表了古往今来男人所有的烂漫与无限的可能：它可能是卢克手里的光剑，可能是大圣的金箍棒，可能是云师弟的血饮狂刀，可能是李云龙的汉阳造，用法之妙，全凭一心。 –为什么很多男人对又直又长的棍没有抵抗力？ 2、 职场就这样，你走了，什么都剩不下，人品好坏，能力强弱，不会有人在乎，因为留下的人不会再找你干活，也没法再让你背锅。 –都说“离职见人品”，你怎么看？ 3、 电影的意义不在于提供唯一正确的答案，而在于提出问题、让观众从问题中看见属于自己的诉求。 –如何评价电影《我的姐姐》？ 4、 英国《自然》杂志 7 日发表的一项心理学研究发现，当人们被要求对物体、想法和现状进行改进时，更倾向于“做加法”而不是“做减法”。 –人们在改进问题时更倾向于“做加法” 5、 谷歌曾是我生活中的伊甸园，但在我遭遇骚扰、并向人力部门投诉后，我才明白，这只是一种幻觉。任何上市公司都不可能成为什么大家庭。 –在谷歌遭遇性骚扰后，我再也不会爱上一份工作 6、 如果我整天看电视，我会觉得自己正在走向灭亡，但如果是忙忙碌碌做无意义的事情，这样的警报就不会响起。因为我所做的事情表面上看起来像是真正的工作，比如处理电子邮件。 表面上看，你一天都在办公桌前工作，但其实你也是在浪费时间，因为这不会让你的生活发生真正的变化。而且由于你的内心不会发出警报，比起看电视，假工作才是浪费时间最危险的方法。 时间要用来做对你真正重要的事情，不要落入假工作的陷阱。 –时间是如何浪费掉的？ 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"清明去了西安，分享一些趣事","slug":"西安","date":"2021-04-09T08:57:00.000Z","updated":"2021-04-10T01:07:21.851Z","comments":true,"path":"2021/04/09/xi-an/","link":"","permalink":"http://www.wmyskxz.com/2021/04/09/xi-an/","excerpt":"清明节三天，去了西安，分享一些趣事。","text":"清明节三天，去了西安，分享一些趣事。 1、 可能是思维比较活跃发散吧，我老是能注意到一些奇怪的地方。比如在成都坐地铁，你会看到 「请勿穿旱冰鞋」 的指示牌： 对比起其他诸如「禁止吸烟」、「禁止坐卧」等警示，「请勿穿旱冰鞋」显得格外突兀。 别的先不说，你就想象一下，是不是特别有画面感！ 没想到去西安又有了精彩的发现，西安地铁指示牌更有画面感，「禁止卖艺」： 好家伙，这两个警示牌一对比，瞬间就觉得这里面饱含着精彩的故事，有强烈的地方特色。我当场震惊！ 2、 刚从钟楼地铁站出来，一群扎堆的大妈格外显眼，特别是你一句我一句的在吆喝着什么。 但是根本听不懂，就只隐约听得见：「诶~ （未知语言…）」。 起初不是很在意，但因为就住在钟楼附近，每天出去回来，大妈们都在，这就引起了强烈的好奇心。 经过好几天的反复蹲点，来回确认，终于，在一位大妈手上拿着一件衣服在缝缝补补的时候，我瞬间听懂了：「诶~ 补衣服不~」 我更懵了，为什么会在大街上补衣服啊… 好奇怪… 直到写这篇文章的时候查资料才发现，这居然是西安钟楼的地方特色： 原来，这些”大妈众”是西安深藏不露的”手艺人”，江湖人称——“织补女”。 3、 你们吃饭有被老板骂过吗？ 没有的话，建议去西安吃「羊肉/牛肉泡馍」，自己掰体验一下「吃饭被骂」的感觉。 没去过不知道，一上来老板就给我们一块馍让我们自己动手掰馍（其实可以直接吃老板掰好的）： 掰了老半天，自信满满地给老板，结果被老板一顿臭骂，说这个太大了做不了。 又好气又好笑。特别是坐我对面的大哥，一身正装，坐的笔直，硬生生从我们点菜开始，一直掰馍掰到我们吃完。 好家伙，吃馍 5 分钟，掰馍 1 小时？！ 4、 越出去，越想念成都的好。 西安作为中国古城代表，就三天短暂的相处来看，基础建设也挺”古老”的——这里特指交通。 主道路交通有很多地方都在修建。地铁缓慢，打车困难。 不过相比成都，西安人民倒是挺懂得「先下后上」的道理的，这可能也是地方特色。 在西安，大部分的吃食在成都也能吃到，更多的是去感受了一把陕西人民特有的忠厚吧（参考掰馍 1 小时的大哥）。 不知道你们旅游一般是怎么度过的，反正我对「兵马俑」这种地方不是特别感冒，可能更多的想去领略一些新奇的东西吧。 5、 突然就很好奇，你们当地的地铁牌子上都有哪些神奇的警示牌？！","categories":[{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 9 期）：活在自己的时区","slug":"weekly9","date":"2021-04-04T00:07:45.000Z","updated":"2021-04-04T00:08:59.600Z","comments":true,"path":"2021/04/04/weekly9/","link":"","permalink":"http://www.wmyskxz.com/2021/04/04/weekly9/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：活在自己的时区","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：活在自己的时区 不知道从什么时候开始，身边的朋友都陷入了莫名的”忙碌”和”焦虑”之中——它们大多都来自于同别人的比较——身边的朋友都恋爱了，于是自己也慌忙地想要恋爱；周围的朋友都买房了，于是也开始焦虑地标榜上”一心搞钱”的标签。 最近读到一首小诗，我觉得会是在这个浮躁社会下的一丝安慰，所以特此分享一下。 纽约时间比加州时间早三个小时，New York is 3 hours ahead of California, 但加州时间并没有变慢。but it does not make California slow. 有人22岁就毕业了，Someone graduated at the age of 22, 但等了五年才找到好的工作！but waited 5 years before securing a good job! 有人25岁就当上CEO，Someone became a CEO at 25, 却在50岁去世。and died at 50. 也有人迟到50岁才当上CEO，While another became a CEO at 50, 然后活到90岁。and lived to 90 years. 有人依然单身，Someone is still single, 同时也有人已婚。while someone else got married. 奥巴马55岁就退休，Obama retires at 55, 川普70岁才开始当总统。but Trump starts at 70. 世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone. 身边有些人看似走在你前面，People around you might seem to go ahead of you, 也有人看似走在你后面。some might seem to be behind you. 但其实每个人在自己的时区有自己的步程。But everyone is running their own RACE, in their own TIME. 不用嫉妒或嘲笑他们。Don’t envy them or mock them. 他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours! 生命就是等待正确的行动时机。Life is about waiting for the right moment to act. 所以，放轻松。So, RELAX. 你没有落后。You’re not LATE. 你也没有领先。You’re not EARLY. 在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 有人遇到爱情，同时也有人被爱辜负。身边有些人看似比你幸福，也有些人看似比你悲剧。不必羡慕别人，自己亦是风景。 人生有时候走得慢一点，稳一点，反而会更快靠近自己想要的生活，有些东西来得晚一点，等得久一点，往往更珍贵，你没有落后，也未曾领先。 这并不是倡导消极地等待或接受命运的安排，随波逐流、随遇而安。而是选择一种积极的心态，选择和时间做朋友，最终收获自己想要的人生。 希望你跟我都能享有想要的人生。共勉。 热点新闻1、中国与伊朗签署 25 年全面合作协议 中国国际电视台（CGTN）3 月 27 日消息，中国和伊朗正式签署一项为期 25 年的协议，其中包括政治、战略和经济合作。 其中比较特别的一点是：中伊之间的石油结算和贸易往来将使用中国人民币和中国新推出的数字人民币结算，避开美元结算。(知乎讨论) 2、雷军：最后一次创业，为小米汽车而战！ 3 月 30 日的小米春季发布会上，雷总真诚热切地说：”我很清楚，这个决定意味着什么，我愿意押上我人生全部的声誉，再次披挂上阵，为小米汽车而战！” 3、苏伊士运河通了，脱困的“长赐号”却没走成！埃及当局要索赔10亿美元 随着“长赐号”脱困，苏伊士运河终于恢复通航，但这并不意味着一切的结束。正停留在大苦湖中接受检查的“长赐号”，面临的或是埃及方面高达10亿美元的索赔。 4、台铁“太鲁阁号”火车出轨事故造成惨重伤亡 4 月 2 日，台湾“台铁”一辆清晨由台北树林前往台东的“太鲁阁号” 408 车次，上午九点左右于台湾东部花莲县清水隧道出轨，车厢猛烈撞上隧道墙壁。 台湾“台铁”“太鲁阁号”事故截至目前造成至少 50 人死亡，140 多人受伤。台湾将下半旗 3 天表示哀悼。 文章1、黄峥自述：一路走来，我的经历与思考 拼多多前 CEO 黄峥从经历、创业理念、思维方式三个方面讲述了自己一路走来的经历。 2、《学习究竟是什么》笔记 简单总结：学精第一；学广第二；创造第三；策略第四；兵器第五；无为第六； 3、工作几年，分享50个让你代码更好的小建议 一些非常简洁实用的建议。包括日常工作 SQL 、Java 代码等，相信看完一定会有收获。 4、工作三年，让我懂得工作和事业的区别 Mdnice 作者分享的关于自己的经历。正如文中所说的：离开这个平台能带走的东西才是真正属于你的东西。共勉。 5、分析了1亿个帖子：如何写出一个好的标题（英文） 文章很长，但要素只有两点：1）简洁地表达信息；2）刺激人们点击、点赞、分享； 6、社交币 人都有追求利益的本能，想要用户分享你的产品，就必须给用户提供“利益”。这是一篇关于社交币概念的解读文章。 7、创业的N种死法 互联网大佬们的创业传奇广为流传，这些故事常常让人热血喷张、兴奋不已。但失败才是常态。如何面对失败，是创业者在创业前要想透的第一件事。这里是关于失败的故事。 8、为什么基金赚钱，基民不赚钱（视频） 参考《2021一季度基民报告》：2018 年以来，盈利的投资者只占 41.2%，盈利超过 30% 的仅占 6.5%。这里是一些原因。 9、为什么早期的 Windows 需要整理碎片 不知道今天的 Windows 是否还需要磁盘整理，但是无论是 Linux 还是 macOS 上都没有类似的工具3，这不禁让作者想要研究一下背后的原因。总得来说，操作系统需要碎片整理主要有以下两个原因： 1）文件系统的设计使得资源被释放后出现很多碎片；2）机械硬盘的随机读写性能比顺序读写差几个数量级； 10、《REWORK》摘录及感想 | 陈皓 《REWORK》是一本每一次看都值得人思考的书。左耳朵耗子（陈皓）早些年结合自己的经历，输出了一些值得让人思考的感想。 好奇星人1、让梗成为艺术品的数字货币 NFT 究竟是什么？ 每张照片，每条推特，每个梗，都可以明码标价的 NFT，究竟是什么？ 2、新疆棉花是怎么采收的？机械化程度有多高？ 2020 年北疆地区的机采率已超过 95%。 我们来看下采棉机的基本构成与结构，我们以三行机为例，从上往下分别为盛放收集作物的棉箱，清洗系统，驾驶室，液压系统，风机风道，最前部的采棉头。 三个采棉头之间的动力传递是（从右往左）1 号传递至 2 号，再由 2 号传递至 3 号，采棉头在结构上相互独立，采棉原理一致。 3、为什么清明节要扫墓？ 扫墓，是我们对于先人的祭奠和思念，也是我们心灵的寄托、情感的释放。 新奇1、科学家创造出简单的合成细胞，可正常生长和分裂（英文） 五年前，科学家创造了一种只有 473 个基因的单细胞合成生物，是迄今为止已知的最简单的活细胞。但是，这种细菌样生物在生长和分裂时表现异常，产生形状和大小完全不同的细胞。 现在，科学家们已经鉴定出七个可以添加的基因，以驯服细胞的不守规矩的性质，使它们整齐地分成均匀的球体。 该发现揭示了控制生命最基本过程的机制。 言论1、 男的点外卖为了填饱肚子，女的点外卖为了享受美食。 –某外卖小哥 2、 我很怕现在的人有无数的朋友圈，没朋友；天天在聊天，没人谈心；知识获取无限，离智慧很远；什么都知道，什么都不知道；看似人人都在说个性，可是，以我作为一个旁观者，我发现现在的年轻人非常一样。 骗别人太容易了，骗自己太难了。 –白岩松 3、 因为重要的，不是你已经 25 岁了，却还没做到什么； 而是你才 25 岁，你还要做些什么。 –25岁的男生，没有存款正常吗？ 4、 小米是什么？是工程师的梦想，靠技术和产品亲手改变世界。 –《一往无前：雷军亲述小米热血 10 年》 5、 保持平常心，接受当下的自己，把自己做好，往往就能把事情做好：平常人也可以做非常事。 –张一鸣 6、 设计失败了，营销成功了，这200万如果是广告费，一点不贵。 –B 站用户评价「小米新LOGO真是被设计师忽悠了吗？」 7、 我们学计算机当程序员最大的福气不是可以到大公司里加班和996，而是我们生活在了第三次工业革命的信息化时代，这才是最大的福气，所以，我们应该努力地提升自己，而不是把自己当劳动力一样的卖了！ 在这样的一个时代，你要做的不是通过加班和拼命来跪着挣钱，而是通过技能来躺着挣钱…… –左耳朵耗子（陈皓） 8、 “看这盛世如我所愿，这盛世里，有你有我。你记得我，我就活着。”致敬英烈！ –烈士的告白 | 微博 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 8 期）：做得快比做得好更重要","slug":"weekly8","date":"2021-03-28T01:48:37.000Z","updated":"2021-03-28T01:49:40.321Z","comments":true,"path":"2021/03/28/weekly8/","link":"","permalink":"http://www.wmyskxz.com/2021/03/28/weekly8/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：做得快比做得好更重要(观点来源：阮一峰)","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：做得快比做得好更重要(观点来源：阮一峰) 一件事情”做得好”比较好，还是”做得快”比较好？ 鱼和熊掌不可兼得，你可以选择：做得好，但是付出的代价可能是耗时长、成本高；做得快，意味着完成度低、不是精品。 我很赞同一篇文章的结论：做得快更好。 做得快不仅可以让你在单位时间内完成更多的工作，而且因为你工作得很快，所以你会觉得成本低，从而倾向于做更多。 写一篇博客，你可能需要两天。这是很高的时间成本，你觉得太贵了，于是你很少写。但是，做好一件事的唯一方法，就是多做这件事。做得越快，这件事的时间成本就越低，你会愿意做得更多。 人们总是倾向于，多消费时间成本低的东西。网站很快，就会多访问；搜索很快，就会多搜索；文章很容易读懂，就会多读几篇。 做得快的核心，就是要让时间成本降下来，从而多做。 热点新闻1、阿里云盘正式公测：“无论免费收费，未来都不限速” 3 月 22 日，阿里云盘今天宣布正式公测。对此，阿里云盘还表示：“无论免费收费，未来都不限速”。 2、2020 年，腾讯员工人均年薪 81 万，小米人均年薪 45 万 腾讯发布了 2020 年业绩，同时公布了 2020 年薪酬情况：2020 年，腾讯雇员福利开支 696.38 亿，去年同期 531.23 亿，员工人数从 2019 年的 62885 名增加到 85858 名。 小米截至 2020 年 12 月 31 日，拥有 22074 名全职雇员，其薪酬开支总额（包括以股份为基础的薪酬开支）为人民币 99.15 亿元。 据网友计算，腾讯员工 2020 年人均年薪 81.11 万，小米人均年薪 44.91 万元，人均月薪大约 3.74 万元。 3、H&amp;M：国际服装巨头因拒用新疆棉花遭遇中国强烈抨击 瑞典著名服装零售品牌 H&amp;M 因对新疆棉花的一则旧声明，受到中国网民猛烈抨击。舆论持续发酵，耐克、阿迪达斯等国际运动品牌卷入争议，多名中国艺人宣布终止和 H&amp;M 合作。 在淘宝、京东等多个中国大型电商平台上也已经无法搜索到 H&amp;M 的名字。 4、知乎上市 2021 年 3 月 26 日，北京时间 21:30，知乎正式上市。 5、苏伊士运河遭堵 3 月 23 日，苏伊士运河航道被搁浅货船堵塞，阻塞了其他船只的通道，并造成苏伊士运河的交通堵塞。 图片来源：via 有报道称，这一事件已经导致载有 1300 万桶原油的 10 艘油轮停止通行，任何船只改道后都将增加 15 天的航程。 有人算了笔账，堵着的这些船，每堵一小时，最高能造成 4 亿美元损失。 另外这有可能是一起全球最大的集装箱索赔灾难。运河管理局要索赔、被堵的船只要索赔、船上货物的主人要索赔，甚至光是这艘闯祸的船的损坏，就得赔上 1 个多亿美元。 另外堵着的这些船船上大部分是原油、石油、煤炭、金属、木材等大宗商品，这一堵相当于直接全球经济脑血栓。全球油价可能会因此上涨。 6、美国SEC再下“黑手”：中概股集体重挫 赴港二次上市潮将至？ 24 号晚上，在美股上市的中概股集体大跌，实属罕见。简单来说：美股的大门正在对中概股缓缓关闭。 3 月 24 号，美国证券交易委员会（SEC）发布公告宣称，《外国公司责任法案》细则已经确定，离执行越来越近了。(via) 这要求外国来美股上市的公司，要出示自己的”家底”——包括一些压根不属于商业范畴的东西。 好比你去公司应聘，面试官问你一堆和工作无关的问题。比如你父母什么工作？父母多少收入？你女朋友好不好看有没有前任？ 这样的问题按理应该有权拒绝回答，但法案要求，要不你自己说，要不我们派人来调查。这明显就是摆明了不想”录用”外国企业。 文章1、1.5 万字 CSS 基础拾遗（核心知识、常见需求） 本篇文章围绕了 CSS 的核心知识点和项目中常见的需求进行了细致的描述。阅读的时候可以适当跳过已经掌握的部分。 2、二维码扫码登录是什么原理 二维码扫码背后的逻辑是通过 token 认证机制与二维码状态变化来实现扫码登录。感兴趣的朋友可以看一看。 3、Vue 3.0 新特性以及使用经验总结 比较全面的总结了 Vue 3.0 的新特性。 4、我为什么选择离开字节跳动 “在字节，别把自己当人，把自己打碎，当做好用的工具就好了。” 作者分享了为什么从字节离职的原因。值得思考。 5、假如你来发明编程语言 从 1/0 的组合到高级编程语言的进阶。帮助大家理解一门编程语言的核心思想。 6、我离职了 前几天 @敖丙 离职了，分享了他自己这一路走来的经历，并列举了一些可能的方向，说自己还需要一段时间去证明。 我想说的是：人生不是一道证明题，按照自己喜欢的方式生活就是最大的成功。共勉。 7、实用的浏览器扩展，我们又为你找到了 11 款 少数派编辑良心推荐的 11 款 Chrome 扩展。真香警告 8、如何干好架构师(3) 这个系列有三篇内容。具有相当的借鉴意义。 9、仅使用CSS提高页面渲染速度 阿里系列文章。硬核讲解只用 CSS 提高渲染速度的系列技巧。 10、一文入门 Python 机器学习（英文） 如果你对 Python 机器学习感兴趣，这是一篇非常好的入门学习资料。就像配图一样，直接起飞。 好奇星人1、人和狗谁更能熬夜？ 先说结论：仅从熬夜时间上对比，人比狗更能熬夜（不考虑熬夜时做事），但从熬夜效率上来看，狗更占优势。 2、免税店为什么能帮你薅羊毛？ | 回形针 简单总结就是：免税 + 更少的流通成本。 3、三星堆是外星人文明？还是一夜毁灭的古代强国？ 前几天四川三星堆遗址连开N个“盲盒”，发掘出了大量珍贵文物。这些文物让我们对数千年存在于此的古蜀文明，又多了一丝好奇。 新奇1、这个拒绝内卷的AI狼火了！高智商却自暴自弃，不想抓羊只想躺 近日，一个狼吃羊的 AI 火了！在一个狼吃羊的 AI 智障游戏中，狼发现自己吃不到羊，直接选择了「自杀」。然而，狼选择撞石的原因竟是「自杀分数高」！ 言论1、 不要让错误的经验，剥夺了对于游戏最原始的认知，不要让作为从业者的经验，模糊了自己作为玩家的审美。 –知乎日报 2、 我们需要的是人才而不是人口，也只有总劳动力数量下去了，八小时工作制才能真正的执行到位。 –为什么在中国很难普遍执行八小时双休工作制？ 3、 太能赚了。 –总之，腾讯太能赚钱了 4、 能够获得暴利的职业，都有一个共同特点：可扩展性（scaling），一次劳动可以服务成千上万的人。 –阮一峰 5、 很多人觉得生活的意义和目标是向外追寻的，因此产生了“我做不到”的自我质疑。其实，寻找意义和目标，更应该向内搜寻。学会与自我和解，探索自身，才能慢慢找到生活的意义。 –找不到活着的意义，怎么办？ 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"HTML/CSS 入门","slug":"HTML&CSS入门","date":"2021-03-27T01:48:37.000Z","updated":"2021-03-30T05:27:07.763Z","comments":true,"path":"2021/03/27/html-css-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2021/03/27/html-css-ru-men/","excerpt":"前言我们在之前的学习中，对于网络有了一定的了解。现在我们来学习一些基础的 HTML/ CSS 知识。希望阅读完这篇文章能达到编写简单页面的程度。 目录： HTML/ CSS 的发明； HTML 基础； CSS 基础； 页面是如何渲染的；","text":"前言我们在之前的学习中，对于网络有了一定的了解。现在我们来学习一些基础的 HTML/ CSS 知识。希望阅读完这篇文章能达到编写简单页面的程度。 目录： HTML/ CSS 的发明； HTML 基础； CSS 基础； 页面是如何渲染的； Part 1. HTML/ CSS 的发明1989 年 3 月，互联网还只属于少数人。 同年，蒂姆·伯纳斯·李（Tim Berners-Lee）提出了一种能让远隔两地的研究者们共享知识的设想。 这一想法的实践促使了万维网的诞生。它基于现有的 TCP/IP 协议构建，包括 4 个部分： 一种表示超文本文档的文本格式，即超文本标记语言（HTML）； 一种用于交换这些文档的简单协议，即 HyperText 传输协议（HTTP）； 一个客户端可以显示这些文档，第一个 Web 浏览器称为 WorldWideWeb。 一个可以访问文档的服务器； 这四部分在 1990 年底完成。虽然此时 Web 页面只能显示单纯的文本内容，浏览器也只能显示呆板的文字信息，不过这已经基本满足了建立 Web 站点的初衷，实现了信息资源共享。 从 HTML 被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。 随着 HTML 的成长，为了满足页面设计者的要求，HTML 添加了很多显示功能。但是随着这些功能的增加，HTML 变的越来越杂乱，而且 HTML 页面也越来越臃肿。于是 CSS 便诞生了。 1995 年 www 网络会议上 CSS 被提出。同年，W3C 组织成立，层叠样式表的开发就此走上正轨。 HTML 负责网页内容，CSS 负责内容的基本样式。 Part 2. HTML 基础什么是 HTML HTML 是 Hper Text Markup Language 的简称，即超文本标记语言。它就像我们熟知的 Word 一样，只不过它适用于 Web。 HTML 同 Word 一样提供了标题、段落、列表、表格、图像、粗体、斜体等文本来构建文档。关键区别在于 Word 中的格式文本是可视的，而 HTML 代码纯粹是语义的。 HTML 基础像任何语言一样，HTML 带有一组规则。这些规则相对简单，就是要界定界限——知道从哪里开始，从哪里结束。 例如，HTML 表示的段落将被写为： 说明： 一对尖括号 （&lt;/ &gt;）中间的就是 HTML 标签。 不同的标签有不同的含义。这里的 p 代表了一个段落的意思； HTML 标签通常成对出现，开始标签（opening tag）&lt;p&gt;定义了段落的开始，结束标签（closing tag）&lt;/p&gt;定义了结束； 开始和结束标签之间唯一的区别就是标签名称前的斜杠 /； 当您把开始标签和结束标签以及两者之间所有内容组合在一起时，就获得了一个 HTML 元素； 标签（尖括号内的内容都）不会被显示，仅仅用于区分内容的语义并提供一些默认的样式； 在哪里写 HTML？就像我们熟知的 .txt 文本文件一样， HTML 文档（后缀为 .html）也可以使用任意文本编辑器打开。 打开您的任一文本编辑器，然后复制并粘贴以下内容： &lt;p>这是我的第一个网页&lt;/p> 将文件另存为 my-first-webpage.html ，然后使用浏览器将其打开，您就会看到： 但实际上，我们一般会选择更加专业的软件： 属性属性就像绑定到 HTML 元素的额外信息一样。它们写在 HTML 标签内，所以，浏览器也不会显示它们。 例如，href 属性就是用来定义 a 标签跳转目标链接的属性： &lt;a href=\"https://www.wmyskxz.com/\">点击会跳转到我的主页&lt;/a> 有 16 个 HTML 属性可用于任何 HTML 元素，所有这些都是可选的。 我们最常用的就是 class 属性（用于 CSS）。 一些 HTML 元素具有强制属性。例如，插入图片时，必须使用 src （source）属性来提供图像的位置： &lt;img src=\"#\" alt=\"Description of the image\"> 考虑到 &lt;img&gt; 标签的意义，强制性的要求设置显示图像的路径，是有意义的。 注释如果你有一些不想显示但是又想提醒代码阅读者的一些事情，通常可以添加注释。 HTML 注释以 &lt;!-- 开始，以 --&gt; 结束。如下所示： &lt;!-- This is an HTML comment --> &lt;!-- This is a multi-line HTML comment that spans across more than one line --> &lt;p>This is a normal piece of text.&lt;/p> 您还可以注释掉部分 HTML 代码来进行调试，如下所示： &lt;!-- Hiding this image for testing &lt;img src=\"images/smiley.png\" alt=\"Smiley\"> --> 自封闭元素一些 HTML 元素只有一个开始标签： &lt;br> &lt;!-- 换行标签 --> &lt;img src=\"#\" alt=\"Description\"> &lt;!-- 图像标签 --> &lt;input type=\"text\"> &lt;!-- 文字输入标签 --> 因为它们没有结束标签，因此内部不能包含任何内容。所以自封闭元素通常带有一些属性，以便为它们提供附加信息。 HTML 块和内联在 HTML 中，您主要会遇到两种类型的 HTML 元素： 块元素用于通过将内容划分为连贯的块来构造页面的主要部分。 &lt;p>这是第一段内容&lt;/p> &lt;p>这是第二段内容&lt;/p> 内联元素旨在区分文本的一部分，以赋予其特定的功能或含义。内联元素通常包含一个或几个单词。 &lt;p>如果感兴趣，可以点击&lt;a href=\"https://www.wmyskxz.com\">这里&lt;/a>来访问我的主页&lt;/p> 开始和结束标签所有块级元素都有一个开始和结束标签。 所以，自封闭元素都是内联元素，仅仅是因为它们的语法不允许它们包含任何其他 HTML 元素。 HTML 层次结构HTML 文档就像一棵大的家族树，上面有父母、兄弟姐妹、孩子、祖先和后代等。 这源于 HTML 元素具有相互嵌套的功能。 嵌套让我们编写一个简单的段落，并通过插入两个内联元素来区分文本各个部分来对其进行增强： &lt;p> &lt;strong>培根&lt;/strong>曾经说过：&lt;q>合理安排时间，就等于节约时间&lt;/q>。 &lt;/p> 结果： 其中： &lt;strong&gt; 对「培根」这一个词语进行了强调； &lt;q&gt; 对「合理安排时间，就等于节约时间」这句话加上了引号； 使用 &lt;strong&gt; 会加粗标签内的内容，这只是浏览器的默认行为。请注意：您必须根据 HTML 元素的含义而非其外观来选择 HTML 元素。 这种情况下： &lt;p&gt; 是 &lt;strong&gt; 和 &lt;q&gt; 标签的父元素； &lt;strong&gt; 和 &lt;q&gt; 同为 &lt;p&gt; 元素的子元素； &lt;strong&gt; 和 &lt;q&gt; 是同级元素； 顺序如何嵌套 HTML 文档取决于打开和关闭标签的位置。 由于 HTML 元素包含打开和关闭标签，以及介于两个标签之间的内容，一个子元素的关闭必须结束于父元素之前。 &lt;!-- This is INVALID code! :-( --> &lt;p> This HTML code won't work because I the \"strong\" tag is opened here &lt;strong>but is only closed after the paragraph. &lt;/p>&lt;/strong> 上述代码是不合法的，因为 &lt;strong&gt; 标签打开在 &lt;p&gt; 标签之后（因此 &lt;strong&gt; 被认为是 &lt;p&gt; 的子元素），所以 &lt;strong&gt; 必须在 &lt;p&gt; 元素关闭之前关闭。 &lt;!-- This is valid code. :-) --> &lt;p> This HTML code will work because I the \"strong\" tag is opened &lt;strong>and closed&lt;/strong> properly. &lt;/p> 深度由于子元素本身可以包含其他子元素，所以可以在 HTML 文档中编写更深的层次结构。 例如，我们可以编写一段： &lt;article> &lt;h1>题图故事：光努力是没有用的&lt;/h1> &lt;p> 漫画家蔡志忠有一个演讲，题目叫做&lt;a href=\"https://www.yuque.com/book-academy/share/shp7tu\">《努力是没有用的》&lt;/a>。读完这份演讲稿，我觉得他说的有道理。 &lt;/p> &lt;p> 有些人非常勤奋，别人休息和娱乐的时候，都在工作学习。但是努力了一辈子，人生也没有显著的提升，就像报道里经常说的：&lt;q>某某在平凡的岗位上，勤勤恳恳工作了一辈子&lt;/q>。 &lt;/p> &lt;p> 另一方面，很多成功者似乎也没有特别努力，就取得了许多成就，过上了好日子。蔡志忠以自己为例，他从小就喜欢画画，然后一直画，不知不觉就成了大漫画家，名利双收，从没有觉得过得很辛苦。 &lt;/p> &lt;/article> 结果： 在这种情况下，该 HTML 文档的家族树看起来会是这样： &lt;h1&gt; 和三个 &lt;p&gt; 是兄弟姐妹；每个 &lt;p&gt; 的父亲都是 &lt;article&gt;；每个元素（除开 &lt;article&gt;）都是 &lt;article&gt; 的后代； 块元素和内联元素嵌套块元素可以包含块元素或内联元素。 但是，内联元素只能包含其他内联元素。（&lt;a&gt; 标签除外） &lt;!-- This is INVALID code! :-( --> &lt;strong> &lt;p>You can't put a paragraph inside a \"strong\" tag. &lt;/strong> 但是要记住元素的家族树。这种层次结构在 CSS 中很有用。 HTML 是语义的HTML 标记的目的是向文档传递含义。所以不必担心网页的外观，应该关心每个标签的含义。 选择合适匹配的元素根据要编写的内容，可以选择与文本含义相匹配的适当元素。 不要过分考虑语义大约有 100 个语义 HTML 元素可供选择。遍历该列表并为您的内容选择适当的元素可能会让人不知所措。 但是不要花太多时间担心这一点。基本上能用好上面的标签就足够好了。 一个有效的 HTML 文档HTML 文档需要特定的结构才能生效。 文档类型提供的第一个信息就是我们正在编写的 HTML 文档的类型：Doctype。 曾经有很多 HTML 版本共存。如今，HTML 5 已经成为规范。 所以，我们要告诉浏览器这个 HTML 文档是 HTML 5 的版本，只需要在最开始写上： &lt;!DOCTYPE html> 注意：HTML 是大小写不敏感的。这意味着你只需要单词拼写对就可以了——但仍需要保持规范。 HTML 5 文档类型没有提到数字 “5” 的原因是：W3C 认为以前的文档类型定义太混乱了，借机吧任何 HTML 版本的信息都给简化掉了。 &lt;html&gt; 元素除了 doctype 外，所有 HTML 文档都必须包装在一个 &lt;html&gt; 元素内： &lt;!DOCTYPE html> &lt;html> &lt;!-- The rest of your HTML code is here --> &lt;/html> &lt;head&gt;&lt;head&gt; 标签相当于整个页面（&lt;html&gt; 包裹的内容）的属性。为整个页面提供了附加的额外信息，并且不会显示。 例如，文档的标题就包含在 &lt;head&gt; 标签内： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>网页标题&lt;/title> &lt;/head> &lt;/html> &lt;body&gt;&lt;body&gt; 使我们编写所有网页内容的地方。里面的所有内容都会显示在浏览器窗口中。 完整的有效 HTML 文档综合所有这些要求，我们可以编写一个简单有效的 HTML 文档： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>我没有三颗心脏&lt;/title> &lt;/head> &lt;body> &lt;p>欢迎关注公众号：wmyskxz&lt;/p> &lt;/body> &lt;/html> 浏览器视角： Part 3. CSS 基础为什么存在 CSS？随着 90 年代网络的普及，将特定设计应用于网站的意图也随之增强。Web 开发人员依靠特定的 HTML 标签来增强网页显示： &lt;basefont&gt; 为整个 HTML 文档定义了一种字体 &lt;font&gt; 为它包含的文本定义字体，颜色和大小 &lt;center&gt; 将所有内容水平居中 &lt;big&gt; 增加文字大小 &lt;strike&gt; 带有删除线的渲染文本 也可以使用几个 HTML 属性： bgcolor 在元素上定义背景色 text 定义文字颜色 几个margin属性可用于在元素的任何一侧添加间隔的空间 但最重要的是，为了创建视觉上对齐（通常是彼此定位）的元素，Web 开发人员通常会使用 &lt;table&gt; 来设计网页，因为它自然地提供了视觉网格： 但这种方法很麻烦，原因如下： HTML &lt;table&gt; 定义是冗长的：它们需要很多样板代码 标签在语义上是错误的：&lt;table&gt; 应该用于多维数据 更改布局需要更改标签：如果我们想将左列移动到右侧，则必须修改 HTML 结构 容易出现语法错误：行和单元格需要按特定顺序进行排序和嵌套才能有效 标签不可读：表格之间相互嵌套 这就是为什么逐渐放弃使用表进行布局的原因，而改用 CSS 的原因。 什么是 CSS?CSS 是 Cascading Style Sheets 的缩写，即层叠样式表。其目的是为标记语言（如 HTML 或 XML）设置样式。因此，CSS 本身一文不值，除非与 HTML 文档相关联。 CSS 通过设置字体、颜色，定义边距、定位元素、动画交互等等，使 HTML 文档栩栩如生。 CSS 是如何工作的?CSS 的工作方式是选择一个 HTML 元素（如一个段落），选择一个要更改的属性（如颜色），并应用一个特定的值（如红色）： p {color: red;} “样式” 一词可能具有欺骗性。CSS 不仅仅可以用于修改文本的颜色、大小、字体等，还可以用来定义高度、宽度、内部和外部的边距、位置等。 我在哪里写 CSS？CSS 作为标签属性您可以使用 style 属性直接在 HTML 元素上编写 CSS： &lt;p style=\"color: red;\">This paragraph will be red.&lt;/p> 结果： &lt;head&gt; 中的 CSS您也可以在 &lt;head&gt; 中使用 &lt;style&gt; 标签来使用 CSS： &lt;html> &lt;head> &lt;title>Hello World&lt;/title> &lt;style type=\"text/css\"> p{ color: red;} &lt;/style> &lt;/head> &lt;body> &lt;p>This paragraph will be red.&lt;/p> &lt;/body> &lt;/html> 结果： CSS 在单独的文件中您也可以把 CSS 编写为带有 .css 扩展名的单独文件，然后使用 &lt;link&gt; 标签来将其链接到 HTML 中： p{ color: red;} &lt;html> &lt;head> &lt;title>Hello World&lt;/title> &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"> &lt;/head> &lt;body> &lt;p>This paragraph will be red.&lt;/p> &lt;/body> &lt;/html> 目录结构： Desktop ├── style.css ├── my-first-webpage.html 结果： 这种单独使用一个 CSS 文件的方法是优选的。 为什么不直接在 HTML 中设置样式？因为我们要把内容和其表示形式分开。这样做的好处显而易见。 首先是可阅读性变高了，有哪些元素，以及元素哪些属性一目了然，也利于分别维护和修改。（类似于书的目录和对应内容一样） 另外是你可以提炼一些通用的属性来减少描述： 简而言之：更易维护、更灵活。不过应该怎么描述是相当看经验的。 CSS 基础语法CSS 的目的是定义 HTML 元素的布局和样式。语法非常简单： /* A CSS rule */ selector{ property: value;} 您也可以将其看作是： who{ what: how;} CSS 选择器因为我们不想一次为所有 HTML 元素设置样式，所以我们需要能够定位这些 HTML 元素的子集。 CSS 选择器定义了我们希望样式应用到哪些元素。 通用标签选择器定位通用 HTML 标签很容易：只需使用标签名称即可。 a{ /* Links */ } p{ /* Paragraphs */ } ul{ /* Unordered lists */ } li{ /* List items */ } HTML 标签的名称和所使用的 CSS 选择器之间存在直接联系。 class考虑到我们可能不希望所有段落或所有标题的样式都相同，因此需要区分它们。 在所有 HTML 属性中，该 class 属性对于 CSS 来说是最重要的。它允许我们定义一组专门设计的 HTML 元素。只需在要使用的类名前面加一个点 . ： .date { color: red; } 这样，所有具有 class=&quot;redColor&quot; 的 HTML 元素都会被设置为红色： &lt;p class=\"date\"> Saturday Feb 21 &lt;/p> &lt;p> The event will be on &lt;em class=\"date\">Saturday&lt;/em>. &lt;/p> 结果： IDs你也可以使用 id 属性来作用于 HTML，只需要在 CSS 选择器前面加上 # ： #tagline{ color: orange;} &lt;h1 id=\"tagline\">This heading will be orange.&lt;/h1> id 属性有点类似于 class 属性，但 id 只能作用于唯一一个 HTML 元素，而 class 可以作用于一类。 一些例子 组合选择器我们重用之前的示例，该实例中，我们希望日期显示为红色： .date { color: red; } &lt;p class=\"date\"> Saturday Feb 21 &lt;/p> &lt;p> The event will be on &lt;em class=\"date\">Saturday&lt;/em>. &lt;/p> 但如果我们希望 em 元素中的日期改为蓝色应该怎么办？我们可以添加以下 CSS： em.date { color: blue; } 结果： 该 em.date 选择器仅适用于 &lt;em class=&quot;date&quot;&gt;&lt;/em&gt; 的 HTML 元素。它不会影响 .date 或 em。 层级选择器选择器中的空格定义祖先/后代关系。假设我们希望标题中的链接为红色： header a { color: red; } 可以读作：”选择 header 标签内所有的 a 元素”。这样可以防止所有其他链接（不在标题中）受到影响。 伪类选择器HTML 元素可以具有不同的状态。最常见的情况是当您将鼠标悬停在链接上时。当此类事件发生时，CSS 中可能会应用不同的样式。 伪类选择器附加到常规选择器上，并以冒号开头:： /* 正常情况下的样式 */ a { color: blue; } /* 鼠标悬停时的样式 */ a:hover { color: red; } CSS 继承假设我们要更改网页的文本颜色，为每个 HTML 元素指定颜色将很麻烦： p, ul, ol, li, h1, h2, h3, h4, h5, h6{ color: grey;} 值传递但其实 color 值是可以从祖先继承的。考虑到我们要更改整个页面，我们可以选择所有 HTML 元素的祖先 body 标签： body{ color: grey;} 所有子元素和后代元素都将从其共同祖先继承该值。 当然我们也可以使用 html 标签。 继承的属性只能从祖先那里继承少数 CSS 属性。它们主要是文本属性： 文字颜色 字体（大小/ 字体 Family/ 样式/ 粗细） 行高 一些 HTML 元素不会从其祖先那里继承。例如，链接（&lt;a&gt; 标签）不继承该color属性。 CSS 优先级一个 HTML 元素可以被多个 CSS 规则作为目标。让我们以一个简单的段落为例： &lt;p class=\"message\" id=\"introduction\"> 欢迎关注公众号：wmyskxz &lt;/p> 我们有三种方式使用 CSS 来对其设置样式： /* 标签名 */ p{ color: blue;} /* 类名 */ .message{ color: green;} /* id */ #introduction{ color: red;} 由于浏览器只能选择一种颜色应用于该段落，因此必须决定哪种 CSS 规则优先于其他规则。这就是 CSS 优先级。 在我们的示例中，该段落将为红色，因为#id选择器比其他选择器具有更高优先级。 CSS 规则的顺序如果您的 CSS 中有类似的选择器，则最后定义的选择器将具有优先权。 p{ color: green;} p{ color: red;} /* Paragraphs will be red */ 快速判断的方法判断 CSS 优先级的一种快速方法是给选择器的打分： #id 选择器价值 100 .class 选择器价值 10 tag 选择器价值 1 无论 CSS 出现的顺序如何， “得分”最高的选择器都将优先。 #introduction{ color: red;} .message{ color: green;} p{ color: blue;} &lt;p class=\"message\" id=\"introduction\"> 欢迎关注公众号：wmyskxz &lt;/p> 结果这一段将是红色的。因为 #introduction{ color: red;} ID 选择器具有更高的优先级。 如何避免冲突在编写CSS时，很容易编写有冲突的规则，比如多次应用同一属性。 为了避免这种情况： 仅使用类：使用.introduction代替#introduction，即使该元素仅在您的网页中出现一次 避免在单个 HTML 元素上应用多个类：不要编写&lt;p class=&quot;big red important&quot;&gt;，而是&lt;p class=&quot;title&quot;&gt;在语义上更具描述性； 不要使用像这样的内联样式&lt;div style=&quot;background: blue;&quot;&gt; CSS 常用属性一览表body { width:100px;/*宽度*/ min-width:1000px;/*最小宽度*/ height :100px;/*高度*/ line-height:100px;/*行高*/ font-family:SimSun,\"Microsoft YaHei\";/*字体*/ font-size :16px;/*字体大小*/ font-style :italic;/*字体风格*/ font:16px/26px \"微软雅黑\";/*字号/行高 字体*/ color:#ccc;/*字体颜色*/ border-width:10px;/*四边边框粗细*/ border-style:solid;/*四边边框的风格*/ border-color:red;/*四边边框的颜色*/ border:10px solid red;/*border-width,border-style,border-color的简写*/ border-top-width:10px;/*上边框的粗细*/ border-top-style:dashed;/*上边框的风格*/ border-top-color:red;/*上边框的颜色*/ border-top:10px solid red;/*上面三个简写*/ border-radius:2px;/*边框圆角*/ text-align:center;/*left,center,right,justify 水平方向居中*/ letter-spacing:10px;/*字间距*/ word-spacing:10px;/*单词之间的间距*/ text-indent:10px;/*首行缩进*/ margin-top:10px;/*上外边距*/ margin:10px;/*四边外边距*/ padding-top:10px;/*上内边距*/ padding :10px;/*可以设置一,二,三,四种值.内边距*/ float:left;/*right 左浮动,右浮动*/ clear :both;/*清除浮动,,清除左浮动或者右浮动*/ position:relative;/*相对定位*/ position:absolute;/*绝对定位*/ position:fixed;/*固定定位*/ z-index:1;/*设置层叠元素的上下位置*/ background-color:#ddd;/*背景颜色*/ background-image:url(\"\");/*背景图片*/ overflow:hidden;/*溢出部分隐藏*/ visibility:hidden;/*隐藏,占位置*/ display:block;/*设为块状元素 块级元素自带的属性*/ display:inline;/*设为行内元素*/ display:inline-block;/*非块状元素的块状盒子*/ display:none;/*隐藏，不占位置*/ opacity:0.5;/*透明度 兼容ie9以上的浏览器*/ filter:alpha(opacity=50)/*设置透明度 兼容i6~ie8*/ } Part 4. 页面是如何渲染的浏览器具有运行在操作系统之上的”操作系统”的”美称”。这意味着这是一个相当复杂的过程。 对于浏览器如果感兴趣的话，可以参考之前的文章。这里简单回顾一下。 首先，渲染进程内部包含主线程、工作线程、合成线程和光栅线程。 请先想象一个这样的场景：您站在一副简单绘画的面前，如何通过打电话来让您的朋友知道这幅画究竟长什么样子呢？ 浏览器实际上要知道绘制些什么元素，每个元素属性如何是要分成三步的：1）通过 HTML 绘制元素树（俗称 DOM 树）；2）通过 CSS 文件绘制样式树（俗称 CSSOM 树）；3）综合两颗树绘制渲染树（俗称 Render Tree）； 现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的像素，我们称为光栅化。 处理这种情况的一种简单的方法是，先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。 但是，现代浏览器会运行一个更复杂的过程，我们称为合成。 合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。 后记如今我们纷繁复杂的网页几乎都靠 HTML 和 CSS 来实现。至此，我们已经对它们有了最基础的了解。 这一个系列的文章是准备尝试跟着后端学习路线图的脚步跟着大家一起学习进阶。后续还会继续更新，请持续关注。 Hi，这里是我没有三颗心脏，在公众号 wmyskxz 分享一个自由技术人的成长和思考，2021，与您在 Be Better 的路上共同成长！ 参考资料 关于 HTTP 后端人员需要了解的 20+ 图片！ 惊了！原来浏览器的秘密藏在这31张图里！ 百度百科 | CSS MarkSheet HTML Tutorial CSS 常用属性","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 7 期）：工作的热情从何而来？","slug":"weekly7","date":"2021-03-21T02:01:37.000Z","updated":"2021-03-28T01:49:36.853Z","comments":true,"path":"2021/03/21/weekly7/","link":"","permalink":"http://www.wmyskxz.com/2021/03/21/weekly7/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：工作的热情从何而来？(观点来自:@阮一峰) BBC 报道，一位新加坡心理学家发明了《工作热情测量表》，可以测量一个人对自己的工作有多大的热情。","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：工作的热情从何而来？(观点来自:@阮一峰) BBC 报道，一位新加坡心理学家发明了《工作热情测量表》，可以测量一个人对自己的工作有多大的热情。 工作热情很重要，如果没有热情，干什么都不会出色。 特朗普就说过：”没有热情，你就没有能量。没有能量，你什么都没有。” 工作热情有很多来源：经济收入、职业前景、社会荣誉……据说，《工作热情测量表》可以测量这些诱因，对你的刺激有多大。 我有一个简单的方法，根本不需要什么心理测试，就能知道你最有工作热情的事情是什么。 你只需要问自己一个问题：即使没有报酬，你也会去干的工作是什么？ 如果一种工作根本得不到报酬，你也愿意去做，这就是你最喜欢、最有热情的事情，千万要珍惜。 JK.罗琳写《哈利波特》第一卷时，根本不知道能否出版，她就是有写的冲动，每天去咖啡馆的角落写到天黑。理查德·斯托曼是 GCC 和 Emacs 的作者，写完以后就把代码开源了，所有人都可以免费用，尽管那时他还没地方住，只能睡在办公室里面。 他们的工作热情之高，已经不需要金钱激励了。我就是想去做，管它有没有报酬。我们要的就是这样一种工作状态，热情不是来自外部的激励，而是来自内在的自我实现的需要，这比外部激励强大得多。 很多最优秀的作品，都是这样产生的。 如果你有这样的工作，得不到一分钱，依然有强烈的冲动去做。那么恭喜你，已经找到了自己最有工作热情的事情。你根本不需要《工作热情测量表》，那张表测量出来的热情值，跟我们内心的追求比起来，都不值一提。在自己热情最高的领域，你做出优秀成果的可能性，将远大于那些需要测量表的领域。 每个人心中都有一个火种，不要听任它熄灭，要找到它，点燃它。 共勉。 热点新闻1、x3+y3+z3=3第三组整数解是多少？这个58年难题被40万台电脑算出来了 目前这个方程有两组解，自 1953 年数学家 Louis Mordell 提出疑问以来，一直没找到第三组解。 最近，这组解终于被找到了。利用了 40 万台电脑采用一定的算法终于找到了。 那么问题又来了 x3+y3+z3=3 的第 4 组解是多少？ 可能有生之年很难见到了，因为求下一组解需要的计算量是现在的 1000 万倍，需要 4 万亿台电脑才能算出，而且可能还不够。 2、中美对话现场燃爆！ 3 月 18 日，中美高层战略对话在阿拉斯加举行。 对话刚一开始，美国代表就严重无视了事先商定好的程序。 在致开场白时，美国代表不光严重超时，还用一种居高临下的语气，对中国的内外政策无礼攻击指责，挑起争端。 这样做，或许是想给中国代表一个下马威，但面对这种毫无待客之道、无视基本外交礼节、违反双方商定安排的行径，中国代表杨洁篪强硬回击，掷地有声： “我们把你们想的太好了，我们认为你们会遵守基本的外交礼节。” 然而，更无理的事情发生了！美国方不顾外交礼仪，让早已入场的中国记者离开现场。不仅是对记者们的不尊重，更是对中国代表的不尊重！ 而这场充满火药味的激烈交锋，让见过不少大世面的CNN记者都无比吃惊。 3、第一张量子纠缠照片公布！ 近日，苏格兰的科学家们创造了历史，捉到了第一张量子纠缠的实际照片！ 虽然对于普通人来说，这张照片平平无奇，但它为科学家打开了一扇新大门。 这张特殊的照片显示了两个光子之间的纠缠，它们在极短时间内分享了彼此的物理状态，其中两团模糊的灰色块就是粒子间的相互作用。 4、拼多多黄峥卸任董事长 3 月 17 日晚，凭借 “年活跃买家数7.88亿” 数字成为 “中国电商第一” 的拼多多，在发布 2020 年第四季度及全年财报的同时，向外界公布了一个重磅消息：创始人黄峥卸任拼多多董事长，放弃 “超级投票权”，个人名下股票将继续锁定 3 年不会出售。 5、三星堆考古重大发现 3 月 20 日，“考古中国”重大项目工作进展会通报：三星堆新发现 6 座器物坑，现已出土金面具残片、巨青铜面具、青铜神树、象牙等重要文物 500 余件。 在新发现的五号坑中，三星堆考古发掘出土大量黄金制品，其中包括一张独特的金面具。 文章1、什么时候我应该打扰别人？（英文） 作为技术人员，时常面临解决技术问题时僵住的情况。 通常，越是初级的技术人员就越不会打扰同事，但实际的经验是：如果你被困住一个小时，最好寻求帮助。 2、1000行 Python 代码编写浏览器引擎（英文） 一本正在写作中的开源书籍，介绍如何使用1000行 Python 代码，实现一个简单的网页浏览器。 3、可视化数据时应该怎样使用颜色？（英文） 可视化数据时，我们总会需要用到颜色。这是一篇全方位的配色指南。 4、独立游戏开发是一种什么样的体验？ 作者分享了自己独立开发的历程和思考。如果你对于独立开发有好奇，那么这一篇文章或许可以解答玩家的一部分疑问。 5、图解 HTTP 缓存 本文针对 HTTP 缓存整体的流程做一个详细的讲解。 6、未来十年，中国有哪些机会？ 迈入第十四个五年规划，展望2035年远景，中国的未来会如何？每个人的生活又将发生怎样切实的改变？ 7、97.16% 的加班率，给你 3 倍工资：你愿意去大厂吗？ 大厂就业为什么这么火？在大厂中工作究竟是怎样一种体验？我究竟适不适合去大厂工作？ 8、为什么我们赚不到，自己认知范围以外的钱？ 关于赚钱这件事，不少人都抱着极为热情的心情，但很多时候，我们又总会缺少些专业知识。 这里是整理的一份和投资及金融有关的影片。它不能帮你迅速提升赚钱能力，但至少能够让想接触投资的你对赚钱这件事，有基础的了解。 9、Java 16 新特性 2021 年 3 月 16 日，甲骨文正式发布了 Java 16！一起来看看新特性吧。 10、上个世纪计算机行业的先锋们 这里收录了行业先锋们的精彩故事。有句话实说：如果你不了解思维增强技术的历史，你就无法理解它的发展方向。 好奇星人1、味精对身体有害吗？ 味精的化学名叫谷氨酸钠，谷氨酸是一种食物中常见的氨基酸，钠就是食盐中含有的那个钠。 味精加热致癌主要来自于一个流言： 味精（谷氨酸钠）加热到 120℃ 以上时，可能产生焦谷氨酸钠。而这种物质不仅有毒，还是“致癌”的罪魁祸首。 说法前半句是正确的，但生成的焦谷氨酸钠对人体是安全的，不仅毒性极低，而且并不会“致癌”。 各种酱料中，味精的应用就更广泛了。我们的生活已经离不开味精，即使你完全不用味精，它也会存在在我们的各种调料中。 说到底，味精呀，挺安全的，放心吃，控制好量就行。 2、沙尘暴哪里来的？ 最近帝都朋友圈摄影大赛开始了（沙尘暴席卷）。据说这样的天气最适合拯救地球了。 从东到西，北方省份一个没放过。 可是沙子哪里来的呢？风沙又是如何形成的？这一篇文章给了详细解答。 3、高铁年年亏钱，为什么还要年年修？ 根据国铁集团发布的《2020年上半年审计报告》，仅仅是 2020 年的上半年就亏损了 955.4 亿。那么问题来了，高铁年年都在亏钱，可为什么还年年都在不停地修建呢？ 有一个词可以很好地概括高铁带来的好处：高铁经济效应。 一是带动周边地区 GDP 增长。 二是在经济不景气的时期，高铁的建设也可以提供大量的就业机会，同时带动其他相关产业的发展，比如：建筑、钢铁和水泥行业等等，这本质上就是在刺激经济。 三是可以加快城镇化的发展，对人口流动起到很关键的作用。 说白了就是铁道的相关部门在亏钱，却让其他相关产业和城市获得更大的收益。从综合的角度来看，修建高铁长期来看是一件好事。 4、熬夜如何搞坏你的身体 | 回形针 北京时间 21:00，打工人小吴结束了疲惫的工作。22:00，小吴到家，随即瘫倒在床上开始刷短视频。凌晨 1:00 ，小吴终于感到困了，洗漱完毕并调好明早 8:00 的闹钟后…… 他缩进被窝里继续玩手机。而真正入睡的时间，往往都在 2:00 以后。 这样晚睡早起的生活持续一段时间后，小吴的身体会发生什么样的变化？熬夜，又是怎样在不知不觉中影响我们的身体的？ 言论1、 It’s true for a lot of us. –Reddit用户 2、 在整个互联网行业，只要需要做用户运营，所谓的大数据杀熟就是一个约定俗成的事情。 –网约车“杀熟”真相 3、 周五摸个鱼都被你们发现了？ –淘宝 3 月 19 日有不少用户反映，淘宝疑似出现服务器故障，页面一度出现无法显示、无法刷新情况，并且 “淘宝崩了”还登上了新浪微博热搜榜。 对此，@淘宝 微博回应称，“周五摸了个鱼都被你们发现了？” 4、 生活哪里有什么胜利，挺住意味着一切。内部经济下行，外部环境恶化。在国内、国际两条主线上，中国经济正在经历 40 年未有之变局。 –《钱从哪里来》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 6 期）：光努力是没有用的","slug":"weekly6","date":"2021-03-14T09:04:37.000Z","updated":"2021-03-21T02:01:54.098Z","comments":true,"path":"2021/03/14/weekly6/","link":"","permalink":"http://www.wmyskxz.com/2021/03/14/weekly6/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：光努力是没有用的(观点来源：@阮一峰)","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：光努力是没有用的(观点来源：@阮一峰) 漫画家蔡志忠有一个演讲，题目叫做《努力是没有用的》。读完这份演讲稿，我觉得他说的有道理。 有些人非常勤奋，别人休息和娱乐的时候，都在工作学习。但是努力了一辈子，人生也没有显著的提升，就像报道里经常说的：”某某在平凡的岗位上，勤勤恳恳工作了一辈子”。 另一方面，很多成功者似乎也没有特别努力，就取得了许多成就，过上了好日子。蔡志忠以自己为例，他从小就喜欢画画，然后一直画，不知不觉就成了大漫画家，名利双收，从没有觉得过得很辛苦。 老师或父母老是说，努力就会走到巅峰—-才怪。如果这样，不是所有人都走上巅峰了吗？没有人开始不努力，为什么后来不努力，因为努力没有效果。” 人生不是走斜坡，你持续走就可以走到巅峰；人生像走阶梯，每一阶有每一阶的难点，学物理有物理的难点，学漫画有漫画的难点，你没有克服难点，再怎么努力都是原地跳。所以当你克服难点，你跳上去就不会下来了。 蔡志忠的核心观点就是上面重点标注的那句话，成功的人生是台阶式向上，而不是一条水平线。努力只是说明你拼命在走，跟你能不能向上走，关系不大。 那些努力却没有结果的人，根本原因就在于，他一直走在平面上，没有走到更高的台阶。 也就是说，垂直方向的努力更有意义，水平方向的努力意义不大。你把同一件事情勤奋地做上十遍，还是只会做这一件事；你做完这件事后，再去挑战更难的事情，就有机会学会做两件事。 只有通过解决更多的问题，人生才能摆脱水平运动，进入上升运动。当然，这里还有一个天赋和兴趣的问题，如果找到属于你的领域，不用特别努力就能上台阶；如果找不对领域，再努力也只能做水平运动。 热点新闻1、全国政协委员李国华：建议对996工作制监管 尽管 996 问题凸显，但我觉得劳动法无法阻止 996。 一是因为人们的幸福感被网络中自媒体渲染的「成功」所「剥夺」掉一部分，导致形成了「一定要努力赚钱」的社会信念。 二是因为社会竞争不断在增强，始终会有人愿意”主动加班”。 三是因为这很符合企业家和打工者的利益关系：企业家省钱、打工者用额外劳动挣钱。 2、GitLab 宣布默认主存出库将从 Master 更名为 Main 对于开发者来说，请注意自管理的实例会在升级至 v14.0 版本时，通过 GitLab GUI 创新的新项目将默认启用 main 这个默认主分支名称。 3、华人小哥用苹果音响「隔空」测心率，论文登上 Nature 子刊 对，没错，使用 HomePod 也能测心率。 关键在于研究团队将智能音箱改造成一个「短距离有源声纳系统」，用来检测某人皮肤运动的微小变化。 具体来说，人的胸部或脖子等区域，会因脉搏跳动而产生皮肤振动，当一个人距离智能音箱大约 30～60 厘米之间时，智能音箱会发出 18～22kHz 的人类听不到的声音信号，这些信号会被人体反射，再由麦克风接收。 接着，算法将这些数据转换为心率读数，并且测量出跳动速度的快慢。 4、清华大学开设《摸鱼学导论》 没错，就是摸鱼——本应该做正事儿的时候不做正事儿，悄悄地偷懒不干活。 而且还特别一本正经。 文章的评论也特别有意思： 想上摸鱼课，得先上清华。大师，我悟了–@rewn 文章1、帝都四十岁程序员的日常 一位帝都四十岁程序员在天涯论坛分享的日常：上班、下班、周末带娃。还正在热更中。 楼主说四十岁了精力体力都还行，不知道这样的话语算不算一种遥远的安慰。 2、和孩子互换人生是什么体验 非常有意思又值得深思的一组漫画。祝我们的小朋友和大朋友们，真的能，幸福快乐！ 3、2 万字系统总结，带你实现 Linux 命令自由？ 内容较多，比较全面。适合当文档和扫盲贴来看。 4、为什么 Kubernetes 要替换 Docker 2020 年 12 月，Kubernetes 社区决定着手移除仓库中 Dockershim 相关代码。这一篇文章详细分析了其中的原因。 5、敏捷开发超强指南 保姆级指南。 6、Goodbye MongoDB, Hello PostgreSQL（英文） 作者对比了 MongoDB 和 MySQL，最终选择了拥抱 PostgreSQL。 7、Dolt 是 Git for Data：一个可以 fork、克隆、分支、合并的 SQL 数据库（英文） 如题，链接过去的是 Github 地址。 8、如何成为一个优秀工程师（英文） 作者谈了自己在 Stripe 公司担任 SRE （系统可靠性）工程师的经历。（篇幅略长，采用漫画的形式） 9、条形码如何工作？（英文） 怎么解读条形码，本文还给出了 Python 的扫码实现。 10、手写迷你版 Tomcat - Minicat 一步一步使用 Java 还原了一个迷你的 Tomcat，附有完整 demo。 好奇星人1、华莱士相对于肯德基来说为什么这么便宜？ 本来是怀着好奇心点开了这一知乎讨论，没成想出来却中了江湖传言「只要你吃了华莱士，那么你就会变成喷射战士。」的毒。 总体来看，华莱士这样的品牌卫生还是存在问题的。为了避免小伙伴去做「无谓的科学献身」，补一张图： 2、Windows 开始菜单是怎么发明出来的？（视频） 1992 年，当时的 Windows 还是 3.1 版本，用户体验很不好，微软自然也不满意。 于是成立了一个专家小组，专门找出用户界面中的不足以及提出一个更好的方案。 然后就找来了两只猴子，尝试教它们英文单词，并研究它们的反应。 很快，他们认为问题出在用户身上，而不是操作系统。换句话说：用户不知道从哪着手，而观察他们的程序员认为他们是白痴。 这一行为心理学实验最终促进了开始菜单的诞生。 言论1、 长达 20 多年的时光里，我一直以一种打排位赛的方式活着。一个段位，一个分数，甚至一个模糊的目标，都能驱使我前进，我从来没有也不需要思考人生的方向和目的。 但是有一天，我发现这个世界不止有排位赛，还有山川河流，我甚至可以停下来，做我想做的任何事，这让我无所适从。 同时，我也发现，排位的终点没有领奖台，甚至台下竟然连观众也没有，更可悲的是，我甚至没有能力冲过终点线亲眼证实这一切。 或许我曾经可以是一个快乐的烤箱，但是制冷了 20 年，我只能继续做一个困惑的冰箱。 –V2EX 用户评论「奔三了,感觉生活毫无意义」 2、 所以说国内为啥卷，学生时代的单赛道竞争思维改不过来。 中学比分数，大学比学分绩，毕业比进了哪家公司，薪资多少。工作了几年比职级，比 title，比来比去的结果就是大家都往死里加班。 –知乎用户回答「如何评价轮子哥 VCZH 在微软十几年还是 SDE2？」 3、 在当前市场波动加大的情况下，我们更应该相信专业的力量，给投资经验丰富、能力全面、回撤控制能力强的绩优基金经理更长的时间进行专业的运作，用时间换取投资增值。 –支付宝 4、 去发现，发现你生活的目标，然后去过那样的生活。可是有的时候，你只有生活过，才能认识到早已有了生活的目标，也许这目标你从来不曾想到。 –《群山回唱》 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 5 期）：货拉拉悲剧的背后","slug":"weekly5","date":"2021-03-07T03:24:05.000Z","updated":"2021-03-07T03:27:01.531Z","comments":true,"path":"2021/03/07/weekly5/","link":"","permalink":"http://www.wmyskxz.com/2021/03/07/weekly5/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：货拉拉悲剧的背后（观点来自：via）","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：货拉拉悲剧的背后（观点来自：via） 3 月 3 日，警方针对“货拉拉女乘客坠车死亡事件”的调查结论出来了——检察机关以涉嫌过失致人死亡罪对犯罪嫌疑人周某春批准逮捕。 稍微整理一下事件经过： → 2 月 6 日 15 时许，周某春通过手机 App 货拉拉平台接到车某某的搬家订单。 → 2 月 6 日 20 时 38 分，周某春驾车抵达天一美庭小区并与车某某取得联系。 两人见面后，周某春询问车某某是否需要付费搬运服务，被车某某拒绝。 车某某先后 15 次从 1 楼夹层将衣物、被褥等生活用品以及宠物狗搬至车上。 其间，周某春多次催促车某某快点搬东西上车出发，并告知车某某，按照货拉拉平台规定，司机等待时间超过 40 分钟将额外收取费用，车某某未予理会。 → 21 时 14 分，周某春驾驶车辆出发前往目的地，车某某坐副驾驶位。 周某春再次问车某某到达目的地后需不需要卸车搬运服务，遭到了车某某的拒绝。 在行驶过程中，周某春为节省时间并提前通过货拉拉App抢接下一单业务，更改了行车路线。 → 21 时 29 分许，受害人车某某两次提出车辆偏航，周某春起先未搭理，后用恶劣口气表&gt; 露对车某某不满；后车某某又两次提出车辆偏航并要求停车，周某春未予理睬。 发现车某某起身离开座椅并将身体探出车窗外后，周某春未采取语言和行动制止，也没有紧急停车，仅轻点刹车减速并打开车辆双闪灯。 车某某从车窗坠车后，周某春停车查看，发现车某某躺在地上，头部出血。 → 21 时 30 分，周某春拨打 120 急救电话，后在救护车司机提醒下拨打 110 报警。 → 2 月 23 日，公安机关以涉嫌过失致人死亡罪对周某春刑事拘留。 → 3 月 3 日，检察机关批准逮捕。 看完事情原委之后，不知道大家什么感觉，反正我的第一感觉是唏嘘，又觉得荒诞——整个事件没有发生任何侵害行为，完全是两个升斗小民，为了几两碎银，相互计较，最后一个没了性命，一个毁了下半生；对于双方的家庭而言，亦是如此。 一个在平台规则内，为了避免多花钱；一个想多赚点钱，弥补下等待的时间成本。 当两个面对生活压力的人开始斤斤计较，最初的龃龉就这样在行车过程中慢慢积累。当利益、情绪、沟通、安全、不信任等问题交织在一起，司机拉着女孩最终开往了最恶的终点站。 沟通能力、共情能力是一方面。可根本问题在哪呢？平台？ 尽管货拉拉的道歉诚恳，措施落实到个人，但解决问题吗？在货拉拉选择扩张、高收益、低成本、外包化的业务模式开始，就注定和安全绝缘。 货拉拉无论从执行力还是动机上，都没有理由去严格约束司机。而且执行了还会把司机往竞争对手那里送。这就是一个死局。 本质上，这就是一个互联网公司讲资本故事，为了快速扩张和压低成本，搞出的东西。不光是货拉拉，货拉拉只是最近被拉出来挨打了。 现在的被困在系统里的骑手、快递员，还有所有的互联网服务行业，都面临同样的问题——无恒产者无恒心，但为了降低成本，为了财报好看，这些互联网公司又不可能提供恒产。 快递也好，外卖也好，货运也好，都一样，服务业如果没有办法给资本一点真正的拳头，平台永远都不会改。 热点新闻1、微软 Mesh 正式推出，虚拟现实融入工作 在微软 Ignite 2021 大会上，出现了一个科技感十足的海底世界虚拟舞台，使用 HoloLens 2 头戴设备，讲述一个用技术将科幻变成现实的故事。 微软混合现实平台 Mesh 通过混合现实技术，可在任何设备（手机、平板、个人电脑、虚拟现实VR眼镜等）来实现身临其境的现场感和共享体验。 让相隔万里的人们将自身影像传送到同一空间，进行虚拟的 3D 内容互动，彼此交流。 今年春晚刘德华演唱《牛起来》时，大家在问到底他有没有到现场？这其中采用了全息投影技术。 Mesh 也一样，可将远程用户全息投影到现场，通过 AI 驱动的运动模型，来捕获用户的运动和表情，和现实小伙伴互动交流、实时对 3D 内容进行创意创作等。 2、微软发布低代码编程语言：Power Fx 微软近日宣布了一种新的开源编程语言，专门为企业用户和专业开发人员设计。 Power Fx旨在成为任何人都可以使用的一种低代码语言。据微软声称，这种语言基于 Microsoft Excel，使用人们已经很熟悉的公式，因而支持一系列广泛的用户和技能。 3、黑客自行优化 GTA 5 节省 70% 时间并嘲讽 R 星代码写得烂 “7 年了！GTA 5 联机版加载还是这么慢？？” Reddit、Steam、HackerNews 上，无数玩家吐槽抱怨 GTA 5 联机版的加载速度慢，进游戏少则等5、6 分钟，多则 20 分钟。 终于，一个黑客大哥实在忍不了，用逆编译器逐条查看运行情况，终于找到原因。 原来，R星（游戏开发商 RockStar）写的代码太低效，加载时，一个 if 语句竟然循环了 19.8 亿次…. 一顿分析、破解、优化，把原先的 6 分钟，下降到了现在的 1 分 50 秒！而且，用的还是七八年前的硬件配置。 在此，应该手动@R星：你学废了吗？ 4、极米成功上市 3 月 3 日，极米科技通过上海证券交易所在科创板成功上市，股票代码为 688696，开盘当日，公司股价报 511.11 元/股，较发行价 133.73 元/股上涨 282.20 %，发行市盈率 72.81 倍，公司总市值达到 255.56 亿元。 5、《你好，李焕英》总票房超越《哪吒之魔童降世》位列中国影视第二 灯塔专业版数据显示，截至 3 月 6 日 21 点 00 分，上映第 23 天的电影《你好，李焕英》票房达到 50.37 亿，超越《哪吒之魔童降世》，成为中国影史票房榜第二名。 6、知乎提交IPO申请 正式启动赴美上市 美东时间 2021 年 3 月 5 日，中国最大在线问答社区知乎首次向美国证券交易委员会（SEC）提交了 IPO（首次公开发行）申请，计划在纽约证券交易所挂牌上市，代码为 “ZH”，瑞信、高盛、摩根大通担任承销商。 招股书显示，知乎 2020 年总营收为 13.52亿 ，同比增长 101.7%。 截至 2020 年 12 月 31 日，知乎累计拥有 4310 万内容创作者，已贡献 3.53 亿条内容，其中包括 3.15 亿个问答。 如果对知乎招股书比较感兴趣，可以戳这里详细了解。 文章1、我为什么不推荐你买 M1 Macbook 搭载 M1 芯片的 MacBook 广受好评，针对一款生产力工具，尤其是对开发的同学，这位童鞋从软件、硬件、系统、设计缺陷等多个方面提出了不同的意见。 2、数据库如何工作？（英文） 比较硬核，从原理一步一步用 C 带你一个数据库。如果你对数据库原理感兴趣，可以阅读一下。 3、什么样的人容易猝死？996 的我该怎么做？ 在我国，每年每 10 万人中就有 41.84 例猝死发生，以常住人口 850 万的南京市来估算，每天都有 10 例猝死发生。 讲真，有被吓到。 4、个税汇算清缴到底是什么？ 相信最近几天，关于「个税退税」的各种视频、攻略正在你的社交媒体刷屏。 这篇文章，整理和介绍了与这次个税汇算清缴有关的操作流程和背后的法规原理，希望能帮你对自己的税负了解更多。 5、从零开始，打造 iPad 电子化学习环境 每个人的学习方法千差万别，但如果你想用 iPad 做尝试的话，这篇文章或许对你有帮助。 6、如何写游戏策划文档？ 非常详细的分享，从各个方面详细做了介绍，包括最佳实践。但受众或许比较小，属于感兴趣才能”啃”得下来的一类素材。 7、引擎动画 用动画的方式讲解了一些引擎的运作方式。 8、重构Python代码的10种方法（英文） 这一篇文章细致地讲述了重构代码的 10 种方法，无关乎语言。不管你是用什么语言都能够有所收获。 9、教你一种我百试不厌的配色技法 不可否认，人是一种视觉动物。这是一篇关于如何配色的技巧流程，帮助大家更好的进行创意配色，并使用自己喜欢的色彩。 10、955 加班少的公司名单 如果你想要去一个稍微 955 一点的公司的话，我这里有一个名单可供参考一下。 好奇星人1、剃成光头还会有头皮屑吗？ 头皮屑是人体头部表皮细胞新陈代谢的产物，是正常现象。 所以其实，人只要有头皮，就会有头皮代谢产物…而且，没有头发的保护作用，过度的日晒、气候变化等环境刺激，会直接作用在头皮上。 2、为什么鸟只能往前飞，不能往后飞？ 几乎所有的鸟只能往前飞，但蜂鸟是个例外！这小家伙不仅会悬停，还能倒着飞… 3、地铁列车晚上都停在哪里？ 我心里一直有个这样的疑问：这些火车地铁，到底从哪来？跑到终点了，又回到哪里去了呢？ 好家伙，原来除了我们日常能看见的 “车辆段” 之外，还有一大截藏匿在大众视线范围外的 “列检库”： 言论1、 究其原因，我以前的工作轨迹都是，认真工作，学习技术，得到认可，升级加薪。而现在，我之前维系自己生活方式的公式变了，而时间又很多，容易瞎想，乱七八糟的不知道该干嘛。 –V2EX用户回二线上了岸之后慢慢开始不适应发出感慨 2、 只有辗转几个城市，颠沛些许人生，知道了自己也不过是个过客，才会在它们消失的时候，心下生出些唇亡齿寒的黯然。 –再见，达叔 3、 如果我能在一个不确定的时代为营造积极氛围作出一些贡献，成为其中的一分子，我将深感荣幸。 –石黑一雄接受 BBC 采访时如是说。 4、 家庭是永恒的，无论发生什么，我们都不会选择离开彼此。 –旺达幻视心碎混剪 5、 几个段子开场+讲述自己的悲惨经历+落泪煽动情绪=跑票？ 我所期待的奇葩说不是这样。 –知乎用户@昧媪回答问题「如何评价《奇葩说》第七季傅首尔获得 BBking？」 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。 （完）","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"2021 年写博客指南·万字长文警告","slug":"how-to-write-blog-2021","date":"2021-03-06T13:15:28.000Z","updated":"2021-03-06T13:16:41.040Z","comments":true,"path":"2021/03/06/how-to-write-blog-2021/","link":"","permalink":"http://www.wmyskxz.com/2021/03/06/how-to-write-blog-2021/","excerpt":"前一段时间，被一篇名为「短视频时代，仍在做图文的我还有救吗？」的文章标题所吸引，这引发了我的思考。尽管疫情加速了短视频时代的到来，但作为技术人员，图文仍然是更低成本建立个人品牌的选择。 这也是为什么我强烈建议你写博客的原因之一。今天，以个人的角度来谈谈为什么建议你要写博客以及如何去写的问题。（欢迎指正和讨论） 目录： 思想篇； 理论篇； 实践篇；","text":"前一段时间，被一篇名为「短视频时代，仍在做图文的我还有救吗？」的文章标题所吸引，这引发了我的思考。尽管疫情加速了短视频时代的到来，但作为技术人员，图文仍然是更低成本建立个人品牌的选择。 这也是为什么我强烈建议你写博客的原因之一。今天，以个人的角度来谈谈为什么建议你要写博客以及如何去写的问题。（欢迎指正和讨论） 目录： 思想篇； 理论篇； 实践篇； Part 1. 思想篇把自己想象成一家企业尽管我的工作生涯非常短暂（只有 7 个月），但是第一天入职上班时领导找我谈话的内容却记忆犹新。 感激并赞成。这里的潜台词是：你并不是来同公司「做生意」的（以劳动换取报酬），而是来「创业」的（提供服务）。 这种心态的转变尤为重要。只有你开始把自己当做一个企业去思考时，你才能做出良好的商业决策。 如果你习惯于领取一份（不取决于你表现的）固定薪酬时，很容易产生一个心态——我只是在为某个公司打工。尽管在你的职业生涯的某个特定时间段里，你可能确实是在为某家公司打工，但是千万不要让那个特定的角色固化了你和你的整个职业生涯——这一点非常重要！ 想象一下：一家企业，拥有某个产品或服务，他们将如何推广这一产品从而可以做到卓尔不凡？ 大多数的程序员👨‍💻‍一头扎进工作中，根本不能做到。相反地，我们需要： 专注于你正在提供的服务，以及如何营销这项服务； 想方设法提升你的服务； 思考你可以专注为哪一特定类型的客户或行业提供特定的服务； 集中精力成为一位专家，专门为某一特定类型的客户提供专业的整体服务； 另外，还要想想如何更好地宣传你的服务，以及如何更好地找到你的客户。这也是我建议你写博客的原因之一了。 大多数软件开发人员在写好一份简历之后就随意丢给一些公司和招聘人员。但是，当你把职业生涯当作一个企业时，你真的认为这就是你拓展潜在客户的最佳途径或唯一方法吗？当然不是。 大多数成功的公司都会开发出让客户主动上门购买的产品或服务，它们才不会一个接一个地追逐客户。 再来想象一个场景：你走进面试房间，与面试官握手致意。当他看到你的时候，脸上露出了似曾相似的笑容：“嘿！我认识你，我在你博客上看过你的照片，也读过你博客的好多文章呢。” 你觉得你这场面试的成功率是多少呢。 事实就是人们很难通过面试的几个小时里充分了解你，但你如果有博客或别的什么，那么情况就会不太一样。 另一点是，当许多技术过硬的开发人员都在竞争同一个工作岗位时，决定胜负的最大因素已经不再是技术能力了。 基于信息论的人生观先来看两条”消息”。 第一条消息是我乱打的。第二条则是 2017 年获得诺贝尔文学奖的石黑一雄的小说《被掩埋的巨人》中的一句话。 请问，哪条消息的“信息量”更大？ 从直觉上来说，第二条的信息量更大，因为它至少是一条信息，而第一条则完全是乱码。但第二条消息只不过是看起来更有意义而已——信息量更大的其实是第一条。 即使把第二条消息中多余的字去掉一些，我想你也能猜到内容吧。这一眼就能猜到是”星期天是休息的日子”。也就是说，第二条消息是可压缩的。 而第一条消息则不同，拿掉任何一个字，你都猜不出它是哪个字。 也就是说，一段消息所包含的信息量，并不仅仅由这条消息的长短决定。这就好像人生一样，活了同样岁数的两个人，他们人生经历的丰富程度可能大不相同。 信息就是意外。从“信息论”这个维度出发，有两种事情就特别值得我们去做： 出乎别人意料的事； 给自己增加选项的事； 所以如果你想给这个世界留下信息，那么写文章（出乎意料的）或许是一个不错的选择——几乎不用付出什么代价又可能回报高昂。 但你也需要注意信息量的问题。既要有创造性，又要可预测，这才是合理的信息输出。 如果你的观点非常新颖，语言又特别简练，那信息量就太大，别人很可能难以理解。而如果你文章中的道理很少，车轱辘话却说了很多，那也不行。 信息量到底要多少才好，这是一门艺术，你得慢慢摸索。在我看来，增加文字冗余度的唯一好处就是方便别人接收，只要读者能理解、能记住，信息就应该越密集越好。 人生价值在于”表达”为什么大多数人的工作都不开心？ 答案就是：因为他们工作的价值由他人来判定。 尼采在《重估一切价值》中指出： 人类社会的组织形式越精密，人的个体价值丧失就越彻底。 无论是打工，还是创业，或者是在体制内混日子，这个世界上大多数的工作都是具有 “迎合” 性质的——就是为了赚钱”迎合他人”。 创业迎合用户，打工迎合老板，体制内迎合上司。它们的本质都是通过委屈自己来顺应外部环境进而获得金钱。 你看那些既有钱还很开心的人，要么就是已经财务自由，不需要出卖自己的时间和劳动来赚取金钱，要么就是虽然也上班，但是做的都是创造性的工作。 相反有些老板虽然收入也不低，但是除了业务范畴之外的事，对世界的认知格外短浅。因为他们的工作就是纯然的 “迎合”，没有任何创造的空间。 那么什么才是创造性的工作呢？ 不需要通过 KPI 考核、业绩决定收入，而是由自我价值的输出来决定收入的工作，就是创造性的工作。 举例来说：「设计师」 的工作虽然像是在创造，但是决定他收入的是甲方是否满意，这就不能算创造性的工作。而一个 「画家」，在画画的时候并不知道会卖给谁，这就是纯然的表达，这种工作就是创造性工作。 生命的本质在于体验，而价值在于”表达”。体验是输入，而”表达”则是输出。 当然这种”表达”不仅仅局限于文字，任何不以迎合外部世界为目标的行为，都是”表达”。 为什么现在互联网上喷子、杠精越来越多。这是因为他们在现实生活中的”表达空间”越来越小了，就只能通过网络的途径来实现”表达”的诉求。 这也是为什么建议你写博客的第三个原因。 一定要提高”表达”能力。随着人工智能技术的进一步发展、社会分工进一步变革，人们”表达”的空间会被进一步压缩。 而不懂得”表达”的人会被剥夺人的根本属性，甚至会被剥夺“充当工具的权利”。(观点来自下 3) 输出是最好的输入根据美国国家训练实验室的学习内容平均留存率研究，该研究统计了学习两周后，学习内容的留存率： 研究表明：教授他人是学习留存率最高的学习方式。 你完全可以想象一个上至 60 岁下至 6 岁的读者朋友，用自己的话，不带行业术语地把这些读者朋友说明白了，那你就真的 “理解” 这些知识了。 要达到这样的目的，自然而然地你也会主动去获取更多的知识。 这也就是为什么费曼学习法（简单说就是把书读薄）被称为世界上最好的学习方法的原因了。 小结综上所述，建议写博客的理由如下： 为了更好的宣传你的服务，更好的找到你的客户； 为世界留下更多的信息，制造更多的意外，输出自己独有的价值； 满足”表达”诉求，并锻炼”表达”的能力； 为了自身更好的学习； Part 2. 理论篇好文章的模样我们能写的文章差不多可以分为如下几类： 不同类别的文章当然有不同的写文策略，我们在这里不做讨论。但是好的文章总归会有如下几个特点： 有溢出价值：你看完能有收获，能带来思考或成长； 可阅读性高：排版舒适，读者不累，看得也很流畅； 我们就以上几点详细来谈谈。 溢出价值很多人不写博客的一大原因是：之前已经这么多人都折腾过的东西了，自己没必要再重复地再折腾一遍。 如果你写的东西只是现有东西的简单重复，那相信你自己也很难说服自己，它存在的意义和价值。如何避免这一情况呢？有几个简单可行的方法。 更多的输入关于学习的本质，有一个说法是：把原本不相干的东西联系在一起的过程。 我们对某一个概念的认识总是有限的，通过更多的输入、不同领域的输入，再结合每个人自身的认知、见解的不同，就会产生新知。 我每一次看奇葩说，都觉得感叹：看似平平无奇的问题居然能有这么多不同立场、不同角度的解读。 这和我们学习是类似的。我们平时积累、学习，应该是对世界越来越不确定，而不是越来越确定。 我们可以通过不断的输入、不同领域的输入，来建立自己的新知，也就能带来更多的价值啦。 分享一些比较好的内容平台： *欢迎评论区补充你常用的内容搜索平台吧~ 使用恰当的比喻我们认识事物的捷径就是：用熟悉的事物做类比。 譬如，钱钟书在《围城》中有一句很著名的比喻： 忠厚老实人的恶毒，像饭里的沙砾或者出骨鱼片里未净的刺，给人一种不期待的伤痛。 譬如，在介绍「数据类型」时，引入了一张”被撕碎的纸片”，这就使得「数据类型」这个”形象”更具体了： 恰当的比喻，能够帮助我们加深对概念的认识和印象。 说一个好故事关于故事的重要性，美国著名女诗人穆里尔·鲁凯泽（Muriel Rukeyser，1913.12.15—1980.2.12）有两行诗广为流传： 穆里尔·鲁凯泽（Muriel Rukeyser）墓志铭 The universe is made of stories,not of atoms.——Speed of Darkness 组成宇宙的是故事，而非原子。——《黑暗的速度》 自互联网普及以来，「碎片化」的趋势愈发明显，「故事」或许是对「注意力不聚集」的一个良好解决方案。近来也涌现了一大批故事的创作者，比较典型的代表就是码农翻身。 事实固然有趣、理念自然重要，但是只有精彩的故事才会让然赞叹、难忘。 使用图片代替人类是一种非常视觉化的动物，超过 50% 的大脑用于处理视觉信息，而触觉只有 8%，听觉只有 3%。在我们写博客时，需要牢记这点。 有时真的是一图胜千言，例如在介绍 Redis GeoHash 算法时，这一张图就把区域编码的核心逻辑展示地非常清晰： 高密度高质量的内容输出，本身就给人深刻的印象。图片就是很典型的例子。制图史学家亚瑟·鲁滨逊（Arthur Robinson）解释说：“以缩小的空间来替代现实空间，这本身就会给人留下深刻的印象。” 另外人的注意力本来就是有限的，在有限的时间内不断获取有用的知识内容不仅能帮我们重新捕获注意力，也能加深我们的印象。（参照抖音） 由于大脑极其重视视觉信息，所以，改善博客的视觉吸引力有助于提高价值和可信度。这就需要使用大量高密度高质量的图片来替代枯燥的文字。 体系价值假设，两位医生，分别接诊了两个大腿中间的士兵，因为知识体系的分别结果完全不同 (参考出处)： D1 缺乏诊治箭伤的知识体系，脑中只有几点零散的知识，只会头痛医头脚痛医脚，想不到感染、发烧、饮食禁忌等事情，结果他的病人回去后，伤口感染、化脓，引起各种并发症，后来救治无效，含恨离世。 反观 D2，因为有知识体系，能够系统的、多维度的、多环节的考虑各种问题，妥善制定箭伤医治策略，他的病人得到了很好的诊治，很快就痊愈了。 医疗领域的知识体系，可以治病救人，效用立竿见影，其他领域的知识体系同样有这样的效果。写文章如是。 通常来说，一篇技术文章只要囊括 What/Why/How 就已经挺完整了。当然这只涉及某一个知识点，你仍然可以就相关的概念进行必要的论述。 体系完整的知识会有额外的体系价值。（这也是为什么会有万字、十万字文章出现的原因） 良好的阅读性是如何建立的？读者阅读文章大概有两种方法。 所以基于读者的阅读习惯，提高文章的可读阅读性，我们能大致采取如下的办法：高亮关键词、开门见山的标题、首段点明文意、分点叙述等。 下面我们结合一些设计上的知识来详细说说。 少即是多爱因斯坦曾经说过： If you can’t explain it simply, you don’t understand it well enough. 如果你没办法简单说明，代表你了解得不够透徹。 我心目中有两个优秀的案例，一是苹果的官网；二是阮一峰大大的博客。 为什么我们阅读优秀作品时，总会感觉干净清晰，给人清晰的视觉感受。其中很重要的原因就是：它们都能用最少的元素表达最清晰的意思。 没有什么比通篇的长难句、字体墙更让读者感到崩溃了。 要遵循少即是多的（设计）原则，有几点需要注意。 首先，每行控制在 25-40 个字：（尽可能…） 其次，采用费曼学习法给知识做减法： 其实也就是通过不断的输入学习来简化知识的过程。 然后，尽量避免宏大的主题。 切忌不要贪多，其实每一篇说清楚一个问题就够了。比如我非常喜欢的为什么这么设计系列文章，每一次就只说明一个问题，但每一个都足够深入，这就够了。 亲密性原则这是设计中的概念，亲密原则指的就是相关的部分组织在一起，安排好他们之间的间距与主次。 把相关的元素组织在一起，信息就会更有条理，也更容易阅读和记住。这其中包括几点设置。 行间距设置： 行间距推荐使用字体大小的 1.4-1.6 倍。小于 1 倍或大于 2 倍会影响正常的阅读。 段间距设置： 另外不同类别元素之间体现「远近」的距离也需要不一致。这样才能下意识认为它们是一组的。 对比原则对比分为三个方法：大小对比、粗细对比、颜色对比。运用好对比可以使你的主次分明，可以很好的突出重点。 如果两个元素想要形成对比，就应当使之不同，而且是截然不同。 注意节奏我喜欢听歌。一个好的编曲一定是有起有伏，有高潮有低缓的。 听觉如此，视觉也是如此。一篇优秀的文章，要懂得如何妥善控制好视觉的轻重缓急、信息的密度等。对于这方面，我没有很好的建议——我自己也完全凭借直觉。 例如，一段干巴巴的技术输出之后，我会理所应当地觉得应该”适当休息一下”，加一些图片或者表情包之类的。 虽然内容为王，但是适当的”呼吸感”是必要的。我有时候在 B 站看半佛仙人，吸引我的一方面是深刻的见解，另一方面是生动有趣的表情包。 这两方面都不可获取，组合起来产生了一种是神奇的化学反应，让我不断地有看下去的欲望。 标题党有必要吗？先说结论：很有必要。 随着互联网行业快速发展，“标题党”曾是一个极具讽刺的名词。 但随着编辑行业自己的方法论、系统的编辑规范也都出来，在互联网的新时代，“假大空”的标题已走进历史，“标题党”也有新的诠释。 在基于内容真实性的情况下，根据用户的心理使用一些技巧来激发用户对内容的感知，从而促使用户去获取对自己有用的信息才是如今“标题党”的追求。 下面介绍一些常见的“标题党”姿势。 震惊式通过反常规的现象、事件，引起目标用户强烈的情感反应，让用户当时的感觉是震惊的，以至于特别想去了解一下详细情况。 举例： 又出事了！特斯拉开着开着竟然起火了！ 木桶理论已死，长板理论才是你 2021 年必须掌握的！！ 骚操作！阿里对业务中台痛下杀手！但却继续推进数据中台？ 数字式用数字简洁、明了的传递信息，给观众一种确定感，然后促使读者迫切知道数字背后的点。 举例： 月薪 10k 和 30k 的 Java 程序员有什么区别？ CPU 执行程序的秘密，藏在了这 15 长图里 关于 HTTP 后端人员需要了解的 20+ 图片 “抱大腿”式借助大众所知、热点、辨识度较高的名人、名企、名物的势能来彰显内容的价值。 举例： 马云、马化腾、李彦宏等互联网大佬管理之道 周鸿祎：学习郎平好榜样 农夫山泉背后的男人”有点狠” 悬念式采用一种欲言又止说一半留一半的方式，勾起人们的好奇心。 举例： 阿里、京东仓库打开后，千万人惊呆了 警惕！朋友圈这 6 个坑千万不要踩 男子拒送女儿上学自己教 11 年，结果… 疑惑式关键词：为什么、如何、怎么做……，通过构造一个场景、前置条件顺势抛出问题让用户产生疑惑。 举例： 红利期已过，用户快速、持续增长，应该做好哪些事？ 如何干净利落打造一篇 10 万+的文章？ 搞 Java 的年薪 50w 是什么水平？ 信息冲突式在标题中制造两种信息的冲突、矛盾形成强烈的对比，从而放大用户的兴趣点。 举例： 0 成本获得 25000 粉丝，我是怎么做到的 两次破产，坐过牢，竟创立 190 亿方便面帝国，靠一狠招 土豆一斤 50 元，全球最贵超市天天排队，竟用这 3 招颠覆沃尔玛 其他比如请君入瓮式：传递出和用户有某种关系、体现出某种特定的标签，让用户有感同身受的感觉，自然就进入你设的瓮。 举例： 给你说个笑话，我是做互联网的 张一鸣：我遇到的优秀年轻人的 5 个特质 再比如一些精华总结式：系统的梳理出垂直领域的知识、看点，方便用户集中的看到所有想看的。 举例： 国庆赴日旅游最值得去的十大景点 史上最全最优质的 PPT 模板 小结我写了 3 年多博客了，个人的感受是：酒香也怕巷子深。 但我们仍应该保持基本原则：在保证内容质量和真实性的前提下，提炼对读者有用的信息才是我们的追求。 另外从长期来看，标题也应该尽量符合搜索引擎的要求。千万不要起一些奇怪的只为博眼球的名字，譬如：《Java 这么多锁，能锁住灭霸吗？》 Part 3. 实践篇从哪里开始好了，我们终于要开始写文章了，从哪里开始呢？ 如果实在不知道的话，就从如何踏上编程这条路开始吧。只要你开始了，就会停不下来。 当你有了一个什么新的想法、想要写的点子，把它记录下来！用手机的标签、或者 Todo List 软件都可以。但是不要太相信你的大脑。 原因是大脑并不靠谱，也有说法是：大脑不是用来记忆的，而是用来思考的。 写作工具我们避免为什么使用 Markdown 的讨论（这样可以专注于内容，而非样式）。我们假设宁默认使用 Markdown 进行文章的书写✍️。 下面介绍几款写作时用到的工具。 Mdnice 编辑器墨滴软件退出的一款 Markdown 编辑器，支持 PC/ 网页/ 浏览器插件 三种形式，官方网址：https://product.mdnice.com/ 不仅仅可以一键复制到公众号、知乎等平台，还支持脚链、文件历史等额外功能。 当然还有丰富的 CSS 主题和代码主题供你选择。 有 CSS 功底的童鞋还是建议自己基于现有的一些主题进行自定义的改造，这样就能形成自己的风格。（我就是基于上面那个兰青改造的） 我一般也就是用的这个进行排版和写作。 Typora作为老牌 Markdown 编辑器，Typora 也是当仁不让地好用（谁用谁知道），最有特色的就是所见即所得功能： 其优势就在于方便的本地文件管理、导出（PDF/ 图片/ Word等多种格式）等功能。 如果你想要设置自定义的 CSS 主题，可以在设置中打开主题文件夹，放入自己定制好的 CSS 文件重启选中主题就好了： 图床如何搭建最开始我在简书上更新文章，那时候简书还能够当作图床在各个平台分享发表。后来突然外部就不能访问简书的图片了。 想象一下：有一天你博客的所有图片都显示无法加载，该是什么心情。我想每一个经历过图床失效的博主，都能够感同身受。 所以我们需要搭建自己的图床。我尝试过很多图床和方法，直接说推荐的：Github + jsDelivr。 搭建也非常简单，结合上面👆推荐的写作工具分别来说一下。 Github 图床创建首先需要现在 Github 上创建一个仓库，命名就随便你啦。 然后点自己的头像，点【setting】，进入到【Developer settings】标签页下： 再点【Personal access tokens】，新建一个 token： 填写新 token 的设置内容，记得一定要勾选 repo： 复制生成的 token（关闭网页这个 token 就没法复制了！） 好了，至此 Github 的工作就结束了。 Mdnice 编辑器设置 最后一步设置填写上 Github 相关信息就好了。（用户名是 Github 名字，token 是刚才复制的 token） 这样就可以愉快的在 Mdnice 上「Ctrl + V」一键上传图片了。 Typora 设置这个稍微麻烦一点儿，你首先需要下载一个 PicGo 软件（地址：https://github.com/Molunerfinn/picgo/releases） 安装完成之后打开设置页面一顿设置就好啦： 注意这里的自定义域名需要额外设置一下： https://cdn.jsdelivr.net/gh/用户名/仓库名/ 这里就相当于给你上传的图片加上一个前缀，比如你上传的图片原本名字叫 a.jpg，设置了自定义域名之后，就会自动变成：(上面那一串)a.jpg。 平时你有图片需要上传就可以复制然后按下默认快捷键「Ctrl + U」进行上传了。 如果你想要上传之后的图片能够自动应用一些格式 （替换剪贴板），比如自动适应 Markdown 的格式，你也可以进行自定义设置： 这时候我们仅仅是拥有了一个自动上传图片的应用，我们需要 Typora 跟 PicGo 之间建立关联，进入 Typora 的设置： 我是默认勾选上了所有图片都上传 PicGo，有时候会出现我复制剪贴也会重新上传一遍的情况（这也是为什么我不喜欢用 Typora 而是 Mdnice 的原因），你可以根据自己的情况设置。 这样，在 Typora 也拥有了一键粘贴上传的便捷体验了。 配图如何搞定好了，现在我们也拥有了自己稳定的图床，可是博文中的图片怎么来呢？ 图片大致分为：外部引入和自己原创的两类。 外部引入原则是：一定要有作品版权意识。 你可以去一些没有版权的图片网站搜索图片： https://unsplash.com/ （英文，推荐） https://pixabay.com/zh/ （中文） https://www.pexels.com/zh-cn/ （中文） …. 当你想要使用某一个图片时，一定要标注出出处，对别人原创的保护，就是对自己原创的保护，谨记x3。 自己原创当你自己想要绘图时，有一些比较好的在线网站。 https://draw.io 方便简单，使用免费。而且没有什么限制。【小林coding】就用这个工具画了许多图。 https://www.processon.com/ 也是免费方便，里面有很丰富的模板可以参考使用。但是个人觉得丑了些。 画图工具使用在线工具虽然方便，总归有一定的局限性。下面就介绍一些顺手的工具吧。 Sketch 这个工具是因为 Draveness 大佬在用，所以有自己尝试过，但是始终不是很顺手，如果感兴趣可以去阅读一下它博客中的技术文章配图指南。 来稍微欣赏一下 Draveness 大佬用 Sketch 画的配图吧。 最开始大佬的风格是下面那种，很喜欢于是开始模仿。后来大佬换成上面那种风格了。（不知道是不是因为有 “模仿者” 出现，哈哈哈） OmniGraffle 非常强大的一款工具，到现在我也一直在使用。不仅仅拥有在线网站那般拖拽自如的方便，最关键的是可以很容易搭建一套属于自己的组件库。 这些组件库使用起来也极其方便，只需要拖拽就可以使用了。 除了方便的绘图，还可以很方便的转换成需要的格式。（选中元素→编辑→拷贝为） 这就很符合要求了：方便、简单、美观。 如何制作动图说一下我自己目前制作动图的方法吧，需要用到三款软件： OmniGraffle：制作基础元素； PPT：利用「平滑」专场效果和动画制作整个流程和元素的对齐； Gifox：录制 PPT 的最终播放效果并转换成 .gif 文件； 为什么使用这三款软件呢，最大的原因是：它们都很简单又特别好用。 OmniGraffle 和 Gifox 没什么好说的，可能大家对于 PPT 比较陌生，着重说一下 PPT 如何制作动图吧。 其中最重要的原理就是「平滑」转场，如果你在两页 PPT 之间加上「平滑」，那么相同的元素就会自动过渡。 平滑功能的强大或许远超你想象，来看看大牛们的 PPT 吧： 上面是靠 PPT 3D 模型 + 平滑功能做出来的，如果想要进一步了解，可以戳这里。 可是有时候相同元素识别有误或者效果不太理想： 我们可以通过强制把两个元素绑定起来完成顺畅的过渡： 怕有些童鞋看不清楚，给个文字版的： 「开始」标签页下点击「排列」，把「选择窗口」打开； 给两个元素命名相同的名字，规则是前面需要加两个感叹号（!!任意字符），表示强制绑定； PPT 的动画就不说了，都是上手就能用的。只是要保证连续流畅的 PPT 自动运行，需要对 「切换」 选项进行一些额外的设置： 第一页：设置为点击鼠标时，这样能控制整个 PPT 的开始； 中间页：设置自动换片，间隔可以自己调整，这样可以保证 PPT 的自动运行； 最后一页：既不能点击，也不自动切片，这样防止 PPT 进入黑色结束页； 如此，PPT 就可以从自己点击鼠标开始自动播放到最后一页了，Gif 动图也就能录制好了。 写作平台可供选择的写作平台有很多：简书、博客园、CSDN、知乎、掘金、开源中国、思否、微信公众号、GitChat。 没什么好说的，前期就是别挑，自己更新一段时间就知道主要火力在哪里了。 这里有一些简洁的经验：（个人向） 简书 SEO 最好，但是社区纷繁复杂； 知乎回答问题引流最好，且用户偏年轻； 博客园氛围最好，经常能有良好的互动； CSDN 最老牌，有很多大牛，但相对曝光度不是那么高； 掘金经常能上推荐，氛围也不错，中规中矩； 公众号最适合沉淀、分享，但是别沦为广告转载号； 写文的一些技巧一些简单实用的小技巧送给大家，这些都是经验谈啊： 不要超过三级目录，否则反思自己的内容是否合理； 把所有有序列表的序号都写成 1.，这样可以避免排序更改序号的问题； 要注意标点符号附近的 ** 强调，不同编辑器的兼容性是不同的； 可以把一些公共的图片（例如二维码、表情包等）专门在图床中创建一个分类，这样就不用每次上传浪费空间，统一修改也非常方便； 欢迎留言区补充…. 后记互联网内容从贴吧论坛的传奇志怪，到微博时代的段子手，再到自媒体时代的长文章，到信息量更大的视频时代。 时代在不停变化，但优质的内容创造者们始终得以保留。 福柯在《语言的秩序》中提出了著名的哲学命题：“语言即权利”。而如今，基于算法的新兴媒体又为这一命题提供了技术条件。 我呼吁所有渴望”表达”、内心丰富、对世界有深刻见解的表达者，不要管粉丝和点赞，只管表达。 算法的进化最终会淘汰那些低劣的洗稿和营销号，把真正优质的内容和优质内容的创造者们留给世界。 参考资料 《软技能：代码之外的生存之南》 《你有你的计划，世界另有计划》 抖音 | 创造与表达 - https://v.douyin.com/e136mMr/ 文字排版四小点 - https://www.zcool.com.cn/article/ZMTE2NDE4OA==.html 设计者的气质-从技法到设计心理 - https://www.zcool.com.cn/article/ZNjY2NTEy.html 利用”亲密性”原则，让排版不再散乱 - https://www.shejidaren.com/qinmi-xing-yuan-ze.html 一名“标题党”自我修炼的 10 大技巧 - http://www.woshipm.com/operate/404315.html PicGo+jsDelivr+GitHub搭建免费cdn加速图床 - https://www.sakura521.cn/technology/picgocdn.html (完)","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 4 期）：你的命运不是一头骡子","slug":"weekly4","date":"2021-02-28T02:17:53.000Z","updated":"2021-02-28T02:18:14.274Z","comments":true,"path":"2021/02/28/weekly4/","link":"","permalink":"http://www.wmyskxz.com/2021/02/28/weekly4/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图故事：你的命运不是一头骡子(观点来自: 阮一峰)","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图故事：你的命运不是一头骡子(观点来自: 阮一峰) 2016 年 9 月，杭州将举办盛大的 G20 峰会。全城都在忙碌地筹备，山路上也不例外。距离西湖最近的一圈山头，都在安装照明设备，准备在夜间亮灯。 那些灯柱都是铸铁做的，高度六七米，非常沉重。施工队使用骡子，将灯柱从山脚运到峰顶。 每头骡子的屁股后面，都跟着一个拿着木棍、看管它的施工人员，防止它走错路。以及在骡子突然停下来时，立即用棍子戳它，好让骡子继续前行。 骡子并不知道，为何要把如此重的铁管背到山顶，就是因为主人要求它这么做，就任劳任怨地干了。 说起来，中国人与骡子真的有很多相似性。一方面，许多人背上的生活压力，不会比那头骡子小多少，尤其是底层民众。另一方面，中国人的勤劳和忍耐能力，更是有过之而无不及。最重要的一点是，骡子只能接受现实，接受命运的安排，人又何尝不是如此呢？ 当然，在生存面前，一切都是合理的。骡子为了生存，必须俯首听命。但是，21 世纪的中国青年，生存本身似乎已经不是问题了。在这样一个产能和资本过剩的时代，除了赚钱以外，是不是应该对自己的人生做一些认真的思考，不要让”赚钱“成为思想懒惰的借口。退一步说，就算你像骡子那样活着，真的赚到了很多钱，是否可以就此认定，当一头骡子是正确的事情？ 说实话，我不太确定。假如有一道填空题，”如果因此可以获得彩票头奖，为什么不____呢？“，在下划线的地方填入”当一头骡子“，似乎逻辑上也说得过去。但从内心里，或者说基于我的偏执，我还是认为这样是不对的。 让我举一个实际的例子。我比较熟悉软件工程师这个职业，也就是职业程序员。在我看来，这种职业跟骡子有很多相似性，尤其在大公司里。因为大公司有严格的分工，设计师出视觉稿，业务部门提出需求和业务逻辑，产品经理负责项目实施，工程师的职责就是严格按照设计稿，将产品一模一样地实现出来。本质上，这跟骡子背铁管上山，并没有区别。 《黑客与画家》的作者保罗•格雷厄姆，做过一个非常好的概括。 “……（你）只是一个负责实现领导意志的技术工人，职责就是根据规格说明书写出代码，其实与一个挖水沟的工人是一样的，从这头挖到那头，仅此而已，从事的都是机械性的工作。” 我不是说这样的流程有什么不对，而是说在这个流程里，人只是充当一种工具。 就像骡子只是铁管上山的一种手段，你只是产出代码的一种手段，本身并没有”自由意志“体现在里面。或者说，你身上体现的都是他人的（或资本的）意志，你无法表现出自我。评价骡子的标准是，铁管背得比较多、比较快，评价软件工程师的标准又何尝不是如此呢，都是看是否忠实有效地实现那些外部意志。 我见过许多年轻的程序员勤奋工作，从早到晚一刻不停地编码，周末也来加班，努力完成公司的一个个目标，从来不问、甚至不想“这种需求对不对”、“这个功能有没有必要”，更不要说想一想“我的人生规划是什么”。中国的现实也很残酷，公司的哲学就是告诉你做什么，你就做什么，不想做就离开。 可以想象，等到九月盛会召开时，工程完成，山头亮起灯光，与明月共同照映山脚下的西湖，平湖如镜，游人泛舟，夏夜凉风吹拂，何等的美景美事。骡子参与了这一切的创造过程，但是有谁会记得它们呢，它们的宿命就是接着去下一个工程背铁管。 更糟的是，当骡子老了、病了、残了，背不动钢管了，你觉得等待它的命运是什么？ 骡子只是施工队的工具，跟锄头或者扁担没有本质区别。 但你不是他人的工具，你活着不是为了被动地被他人使用，而是应该要有自己的价值。我觉得，人应该过一种有乐趣、有追求、自己做主的生活，而不能像骡子那样被推着走。 热点新闻1、华为发布最新折叠屏手机 Mate X2 2 月 22 日，华为消费者业务 CEO 余承东在线上发布了华为新一代折叠屏手机 Mate X2，其中，256 GB 版本售价 17999 元，512 GB 版本售价 18999 元。 跟目前所有已发布的折叠屏手机不同之处在于，Mate X2 虽然也采用了内外双屏设计，但左右两部分是双楔形一体的。 这样的设计不管是单手还是双手操作，都达到了重量上的平衡。也能让折叠后可以严丝合缝，最薄的地方仅 4.4 毫米。 另外华为宣布今年 4 月份 Mate X2 可以陆续升级使用自研操作系统鸿蒙 OS。 2、“最强打工人”：库克喜提 8 亿年终奖 在 2 月 23 日举行的线上苹果公司股东大会上，苹果股东投票批准了针对苹果高管的薪酬计划，其中包括首席执行官蒂姆·库克的薪酬计划。 针对库克的一揽子股票计划是，如果苹果达到某些业绩目标，该计划将使他获得 100 万股新股。据此方案，库克将得到 100 万股苹果股票的奖励。如果按照 2 月 24 日的美股收盘价计算，这笔年终奖价值 1.25 亿美元（约 8 亿人民币）。 苹果董事会在一份文件中表示，从库克 2011 年担任苹果首席执行官到 2020 年 9 月以来，包括股息在内，给股东带来了 867％ 的回报。 3、习近平：在全国脱贫攻坚总结表彰大会上的讲话 2 月 25 日，全国脱贫攻坚总结表彰大会在北京人民大会堂隆重举行。中共中央总书记、国家主席、中央军委主席习近平在大会上发表重要讲话。 4、小米米聊火速重生，欲打造 “中国版”Clubhouse 2 月 19 日 12 点 00 分，米聊官宣停止服务。仅仅一周，正式关停的米聊又重现出现在大家眼前。 2 月 26 日晚间消息，米聊团队发布题为《米聊，重新出发》的公告。称新 “米聊”再次上线，其全新定位是一个面向专业人士的语音聊天 App。 5、吴孟达因病救治无效去世，享年68岁 2 月 27 日，吴孟达因病救治无效去世，享年 68 岁。 6、教育部称不得要求家长检查批改作业 2 月 23 日，教育部召开新闻发布会，介绍了 2021 年春季学期学校疫情防控和工作教育工作相关的情况。会中特别提到：不得要求家长检查、批改作业。 作业本该是老师查验教学成果，学生检验学习效果的事情，如今越来越像是一种”任务”。特别是夹在家长中间各种无奈表现出来之后，教育部的这一发文，更显得 “拧巴”。 文章1、积累10年的北京生存抠门指南 如题，就是教你在北京如何有效的薅羊毛的。 2、可视化美国从 COVID-19 中死亡的 500,000 人（英文） 目前美国从 COVID-19 中死亡的人数已经超过了 50 万。这个数字让人咋舌，也让人难以想象。人脑并非天生就可以理解大量的数字，这么多人丧生，到底是一个什么概念？ 这篇文章用一些可视化的比喻来让你理解 50 万的真正含义。 3、前端优秀实践不完全指南 别称又叫「Web 用户体验设计提升指南」，文章从页面展示、交互细节、可访问性三个方面入手，罗列一些在实际的开发过程中，积攒的一些有益的经验。 4、作为独立开发人员如何有效 Git（英文） 现在 Git 有许多的使用规范。作者只是从自己的职业生涯的经验中，说明了从中得到了什么，以及如何运用 Git 帮助自己的工作。 5、用 Python 编写自己的 Git（英文） 比较硬核的一本小册子。详细介绍了如何使用 Python 一步一步还原，编写自己的 Git。 6、货拉拉事件后，我们整理了这份搬家避坑守则 前不久，长沙一名 23 岁女孩在货拉拉搬家跟车途中意外身亡。据媒体报道，这段不到十公里的路程，涉事司机曾三次偏离导航路线，直到目前，事件的真相也没有一个定论。 这一份搬家避坑守则，可以或多或少地帮助年轻人避免”一顿毒打”。 7、新兴前端框架 Svelte 从入门到原理 Svelte 本意是苗条纤瘦的，是一个新兴热门的前端框架。 在最新的《State of JS survey of 2020》中，它被预测为未来十年可能取代 React 和 Vue 等其他框架的新兴技术。这一篇有助于你快速了解它。 8、CSS 过渡的交互指南（英文） 图文并茂的 CSS 过渡交互指南，从理论到实践，非常高质量的一篇文章。 9、使用 M1 Mac GPU 挖掘以太坊（英文） 根据作者测试，在拥有 M1 芯片的 Mac Air 的 GPU 上挖掘以太坊，算力大概是 2 Mh/s。总的来说，虽然有利润，但是微不足道。里面附了代码，感兴趣的可以了解一下。 10、晋升述职指南 晋升述职常见的问题是：1）思路不清晰，变成流水账；2）项目沉淀少，内容很空洞；3）想的贼清楚，讲得特糊涂。 如果你被上述问题困扰着，不妨阅读一下这篇文章。 好奇星人1、政府可以停止比特币吗？（英文） 自从十二年前创建以来，比特币一直不败。它的价格从 $5 涨到 $50 到 $500 涨到 $5,000 到现在的 $50,000。 文章指出，杀死比特币的唯一方法可能就是制造它。 2、1959 年的打孔卡计算机如何加载程序？（英文） 我们现在所使用的个人计算机都搭载了操作系统和 ROM，可是在 1959 年这些都还没有。那时还是老式的打孔卡计算机。每一个数据记录使用一张卡。 没有操作系统和 ROM，打孔卡是如何加载程序的呢？文中做了详细描述，感兴趣可以阅读一下。 3、猫真的喜欢被我们撸吗？ 每个猫咪的性格和喜好不同，但大部分是喜欢被撸的。但是手法和时机也很重要。 这一知乎讨论就介绍了很多撸猫的手法。学会方圆 5 公里的猫都说好。 新奇1、朋友开了个老年公众号劝自己的妈妈 分享了一个为了劝自己的妈妈，专门开了一个老年人公众号，编一些文章专门用于分享给长辈的有趣故事。 2、美国第一个被克隆的濒危灭绝物种（英文） 您可能听说过绵羊多莉。现在，您遇到了黑脚雪貂伊丽莎白·安（Elizabeth Ann）。 科学家已经使用一种死了的野生动物保存的细胞成功地克隆了一种濒临灭绝的黑脚雪貂。这是美国首次克隆任何本地濒危物种。 言论1、 我们不能成为别人的判断题我们要成为自己的选择题我们要活在自己的选择题里 –李想 2、 很多事情，如果认真一想，其实就是一部恐怖片。 –少数派编辑 3、 现在我还无法接受。 –周星驰 4、 在大厂里收入可观，但因为长期加班失去生活；大城市里租房的生活让人感到漂泊不定，小镇里的安全感则相比起来更让人安心。 –谷雨数据-腾讯新闻 5、 新基民买的是基金，填补的是焦虑。 –@后浪研究所 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。 （完）","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"关于 HTTP 后端人员需要了解的 20+ 图片！","slug":"网络5","date":"2021-02-27T12:07:59.000Z","updated":"2021-02-27T12:09:38.693Z","comments":true,"path":"2021/02/27/wang-luo-5/","link":"","permalink":"http://www.wmyskxz.com/2021/02/27/wang-luo-5/","excerpt":"前言当您网上冲浪时，HTTP 协议无处不在。当您浏览网页、获取一张图片、一段视频时，HTTP 协议就正在发生。 本篇将尽可能用简短的例子和必要的说明来让您了解基础的 HTTP 知识。 目录： 什么是 HTTP？ HTTP 简史； HTTP 与 HTTPS；","text":"前言当您网上冲浪时，HTTP 协议无处不在。当您浏览网页、获取一张图片、一段视频时，HTTP 协议就正在发生。 本篇将尽可能用简短的例子和必要的说明来让您了解基础的 HTTP 知识。 目录： 什么是 HTTP？ HTTP 简史； HTTP 与 HTTPS； Part 1. 什么是 HTTP？互联网是有关 web 客户端和 web 服务器之间的通信。 HTTP（HyperText Transfer Protocol）又叫超文本传输协议。本质上就是一个协定好双方如何进行交流沟通的约定。 这就好比我在一起玩游戏的朋友群里发送一条 「1？」 的消息，朋友们就立即知道是在询问今晚是不是要一起游戏的意思。 但是如果我给其他人发送 「1？」 就可能出现问题：他们不知道我在说什么。 本质上，这就是 HTTP 协议所代表的含义。我们已经同意，如果我们以特定的方式发送消息，则服务器就会理解消息的意图并作出回应。 Part 2. HTTP 简史1989 年 3 月，互联网还只属于少数人。在这一互联网的黎明期，HTTP 诞生了。 HTTP / 0.9 - 单行协议1989年，当时还在欧洲核子研究组织（CERN）工作的蒂姆·伯纳斯·李（Tim Berners-Lee）提出了一种能让远隔两地的研究者们共享知识的设想。 最开始称为 Mesh，后来在 1990 年实施期间将其重命名为 World Wide Web（万维网）。它基于现有的 TCP/IP 协议构建，包括 4 个部分： 一种表示超文本文档的文本格式，即超文本标记语言（HTML）； 一种用于交换这些文档的简单协议，即 HyperText 传输协议（HTTP）； 一个客户端可以显示这些文档，第一个 Web 浏览器称为 WorldWideWeb。 一个可以访问文档的服务器； 这四部分在 1990 年底完成。虽然此时 Web 页面只能显示单纯的文本内容，浏览器也只能显示呆板的文字信息，不过这已经基本满足了建立 Web 站点的初衷，实现了信息资源共享。 以下就是 HTTP/0.9 的请求内容： GET /page.html 用唯一可用的 GET 方法向目标服务器获取指定的文档。（一旦连接到服务器，协议、服务器、端口号这些都不是必须的） 响应也极其简单：只包含文档本身。 &lt;HTML> 网页的内容 &lt;/HTML> 这意味着 HTTP/0.9 只能够传输 HTML 文件。一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。 HTTP/1.0 - 构建可扩展性由于 HTTP/0.9 协议的应用十分有限，加之 HTTP 使用量和 HTML 的高速发展，浏览器和服务器迅速扩展其内容使其用途更广： 协议版本信息会随着每一次请求发送； ----------HTTP/0.9请求---------- GET /page.html ----------HTTP/1.0请求---------- GET /page.html HTTP/1.0 -> 新增协议版本 服务器在响应时回复状态码，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或失败）； ----------HTTP/0.9响应---------- &lt;HTML&gt; .... &lt;/HTML&gt; ----------HTTP/1.0响应---------- 200 OK -&gt; 新增状态码 &lt;HTML&gt; .... &lt;/HTML&gt; 引入了 HTTP 头的概念，无论是请求还是响应，允许传输其他信息，使协议更灵活以及更具扩展性； 在 HTTP 头的帮助下，具备了除传输纯文本的 HTML 文件以外，还可以传输其他类型文档的能力（归功于 Content-Type 头）； HTTP/0.9 规范大约只有一页，而 HTTP/1.0 在 RFC-1945 中定义的规范则足足有 60 页。这说明 HTTP 已经成长为一个重要的工具。 尽管 HTTP/1.0 从 HTTP/0.9 有了很大的飞跃，但仍然存在许多必须解决的已知缺陷。例如与 TCP 协议交互不良、没有充分考虑缓存等问题。 拿与 TCP 协议交互不良举例。由于 HTTP 是基于 TCP 建立的，所以通讯之前需要建立连接，通讯结束之后需要断开连接。 HTTP/1.0 每一次的通讯都需要建立并断开连接，这无疑增加了无谓的通信开销。 HTTP/1.1 - 标准化的协议文档 RFC 1945 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。所以实际运用起来非常地混乱。所以实际上自 1995 年开始，即 HTTP/1.0 文档发布的下一年，就开始修订 HTTP 的第一个标准化版本。 HTTP/1.1 在 1997 年 1 月以 RFC 2068 文件发布。HTTP/1.1 消除了大量歧义内容并引入了多项改进： 连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间； 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟； 支持响应分块； 引入额外的缓存控制机制，在 HTTP Cache-Control 标头中引入了很多可以选择的选项； 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换； 能够使不同域名配置在同一个 IP 地址的服务器上。 一个典型的请求流程， 所有请求都通过一个连接实现，看起来就像这样： 超过 15 年的扩展由于 HTTP 的可扩展性——创建新的头部和方法是很容易的——HTTP 协议稳定使用了超过 15 年。期间不断对 HTTP/1.1 协议进行修订（RFC 2616、RFC 7230、RFC 7235），为 HTTP/2.0 作了十足的铺垫。 HTTP/2.0 - 为更优异的表现这些年来，网页愈渐变得复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过 HTTP 请求被传输。 在 2010 年到 2015 年，谷歌通过实践证明了实验性的 SPDY 协议的可行性，这成为了后来 HTTP/2 协议的基础。 HTTP/2 在 HTTP/1.1 有几处基本的不同： HTTP/2 是二进制协议而不是文本协议，不再可读。头信息和数据体都是二进制（体积更小），并且统称为帧(frame)。 这是一个复用协议，可以多路复用。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束; *注：这里 HTTP/2 并不是合并成一个包，而是分成多个 Stream 发送，这里只是为了绘画方便。 大家可以通过点击这里直观感受到 HTTP/2 比 HTTP/1.1 快了多少。 压缩了 Headers。因为 Headers 在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。实现这一功能的算法被称为 HPACK 算法; 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求； 详细的 HTTP/2 优秀的地方可以参看下 4 链接 在 2015 年 5 月正式标准化后，HTTP/2 取得了极大的成功，在 2016 年 7 月前，8.7% 的站点已经在使用它。高流量的站点最迅速普及，在数据传输上节省了可观的成本和支出。 这种迅速的普及率很可能是因为 HTTP2 不需要站点和应用做出改变：使用 HTTP/1.1 和 HTTP/2 对他们来说是透明的。 拥有一个最新的服务器和新点的浏览器进行交互就足够了。只有一小部分群体需要做出改变，而且随着陈旧的浏览器和服务器的更新，而不需 Web 开发者做什么，用的人自然就增加了。 后 HTTP/2 进化随着 HTTP/2 的发布，就像先前的 HTTP/1.x 一样，HTTP 没有停止进化。HTTP 的扩展性依然被用来添加新的功能。 HTTP 的进化证实了它良好的扩展性和简易性，释放了很多应用程序的创造力并且情愿使用这个协议。 HTTP/3 - 更好的未来HTTP/3 是即将到来的第三个主要版本的 HTTP 协议。与前任协议不同，在 HTTP/3 中，将弃用 TCP 协议，改为使用 UDP 协议和 QUIC 协议实现。 此变化主要为了解决 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。 截至 2021 年 1 月，HTTP/3 仍然是草案状态。 小结 HTTP/0.9 只能传输单一的 HTML 纯文本，不够灵活； HTTP/1.x 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷； HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的； QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议； Part 3. HTTP 与 HTTPS 为什么需要 HTTPSHTTP 协议在设计之初就没有充分考虑安全性的问题。所以基于 HTTP 的这些应用都承担着如下的几个风险： 使用明文（不加密）进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能是伪装的； 无法验证信息的完整性，也就是说信息可能是被篡改过的； HTTPS（HTTP over SSL）采取嵌套新一层安全套接字层（Secure Socket Layer,SSL）来解决网络传输的安全性问题。 如何防止被窃听？加密是很容易联想到的解决方法。但如何保证传输加密方法的过程不被窃听呢？ 这时候非对称加密的出现解决了这一大难题。它把密码革命性地分成公钥和私钥，由于两个秘钥并不相同，所以称为非对称加密。 举个例子，假设我们现在需要加密的字符是 520，我们加密的方法是把这个数乘以 91，并把结果的最后三位公布出来： 注：这里的 91 相当于公钥，任何人都可以知道。 解密我们当然不能通过除以 91 来完成，而是通过 x11，取出结果后三位来还原： 注：这里的 x11 相当于私钥，只有解密方才知道。 这是因为 91*11=1001，任何一个三位数乘以 1001 显然后三位是不会变的。这大概就是非对称加密的原理了，基于这个原理我们通信的双方就可以各自生成自己的公钥私钥并进行相对安全的通信了。 如何验证对方身份？上面的过程看似无懈可击，但在 TCP/IP 的端到端的通信里，路途遥远，夜长梦多。 如果在第二步的时候，信息被黑客截取，在严刑拷打之下知道了这是传输公钥的信息。那么完全可以自己生成一对密钥和公钥，冒充是彼此来传输自己的秘钥。 加密危机之后，又产生了信任危机。我们需要一个有公信力的组织来证明身份，这个问题就得到了解决。 这个可信的组织就是颁发 HTTPS 证书的组织 CA（Certificate Authority）。每次有客户端或者服务端想要公开自己的公钥时，都需要向 CA 做出申请，通过后 CA 会颁发一个与公开公钥绑定的数字证书。(了解更多证书) 进行 HTTPS 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。 如何防止被篡改？在之前介绍比特币原理的时候，我们提到过一种哈希算法。它的作用是能把任意长度的输入编程固定长度的二进制输出。 注：为了简化右边为 16 进制数 在 HTTPS 中，有一种新的摘要算法，可以简单理解为是对于内容的一种压缩。所以但凡内容变化一丁点，哪怕是一个标点符号，压缩之后的数字哈希也不对。 客户端在发送明文之前会通过摘要算法算出明文的 「指纹」，发送的时候把 「指纹 + 明文」 一同加密成密文后，发送给服务器。 服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的 「指纹」 和当前算出的 「指纹」 做比较，若 「指纹」 相同，说明数据是完整的。 HTTP 与 HTTPS 有什么不同？尽管听上去 HTTPS 就是更安全的 HTTP，但也有许多细节方面的不同： HTTP 明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输； HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输; HTTP 的端口号是 80，HTTPS 的端口号是 443; HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的; 后记HTTP 协议是纷繁复杂的网络世界的基础，它保证了各个应用之间的”交流无阻碍”。本篇也尽可能使用动图的形式清晰地表达，希望大家能用餐愉快。 至此，我们对 HTTP 协议已经有了相当的了解了。后续也会继续跟大家一起学习计算机网络的基础知识，也会尝试着跟着后端学习路线图的脚步跟着大家一起学习进阶。 这里是我没有三颗心脏，欢迎关注公众号 wmyskxz，2021，与您在 Be Better 的路上共同成长！ 参考资料 How HTTP Works and Why it’s Important – Explained in Plain English - https://www.freecodecamp.org/news/how-the-internet-works/ Evolution of HTTP - https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP The Evolution of HTTP - https://www.oreilly.com/library/view/learning-http2/9781491962435/ch01.html xxxxHub 都用上了 HTTP/2 ，它牛逼在哪？ | 小林Coding - https://mp.weixin.qq.com/s/TvGAmKKrKrcWlsV2cfC34g 一文读懂 HTTP/2 及 HTTP/3 特性 - https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/ （完）","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络","slug":"基础知识/网络","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 3 期）：开工大吉的 B 面","slug":"weekly3","date":"2021-02-21T02:40:04.000Z","updated":"2021-02-21T02:40:48.787Z","comments":true,"path":"2021/02/21/weekly3/","link":"","permalink":"http://www.wmyskxz.com/2021/02/21/weekly3/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：开工大吉的 B 面(观点来自:via)","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：开工大吉的 B 面(观点来自:via) 不论是大火的程序员考公指南反映出来的考公热，还是《2021人才资本趋势报告》反映出来的疫情之下的归乡潮，都论证了一件事：”越来越多的人「卷不动了」”。 与开工大吉热闹奔腾的 A 面不同，B 面则是越来越多逃离互联网的年轻人们。 观察身边但凡是在 30 岁前选择结婚生子的朋友们，大都一样： 本地人在本地工作，毕业后大多很快就结婚了； 在省会城市或二线城市有稳定工作的，只要家里能在当地买得起房，基本也都结婚了； 说白了，在工作地有一套房子做底气之后，大多数人才有勇气迈向婚姻。哪怕出身名校，房子依然像一道鸿沟，横亘在家乡与北上广深之间。 于是，相比于在北上广深的互联网待了十年最终依然买不起房，回家捧铁饭碗对于一部份年轻人来说不失为一个选择。 也有一部分毕业生，既无力支撑北上广深的房价，也不满足于在机关单位里安稳一生，他们选择了另一条路。 一名 985、211 院校毕业的本科生在北上广深可能只是沧海一粟，但来到其他地区的一些上市企业却能得到重用。谁又能肯定去北上广深就一定过得好？回到家乡就一定不好呢？ 当压力成为共识，我们能选择与取舍的并不是“卷”或“不卷”，而是在哪“卷”，如何“卷”。 行走在如今的社会中，当遇到一些不可抗力的时候到底应该“逼自己一把”还是“放自己一马”？没人能说得清。 人生各有抉择，在开工大吉的日子里，祝君所得皆所愿。 热点新闻1、《你好，李焕英》票房破30亿 根据灯塔专业版数据显示，截止 2 月 18 日 14：34，贾玲执导的电影《你好，李焕英》票房正式突破 30 亿，成为了中国影史上第 12 部票房破 30 亿的影片。 另外分享一则有趣的知乎讨论： 2、英特尔新 CEO 正式上任 2 月 15 日，英特尔公司正式完成 CEO 过渡，鲍勃·斯旺（Bob Swan）今天起正式离任，帕特·基辛格（Pat Gelsinger）上任成为英特尔公司创立以来第八任 CEO。 近期以苹果为首的 ARM 架构处理器大放异彩，而英特尔还在 14nm 工艺节点打磨。这次帕特·基尔辛格的上任就是让英特尔这艘已偏离航线行驶的大船重新回到正确的航路上。 3、官宣！英伟达一季度将推出以太坊挖矿专用 GPU 北京时间 2 月 19 日凌晨，英伟达发布博客宣布，该公司将会发布一系列新的 GPU 产品，新处理器被命名为 “CMP”，全称 “Cryptocurrency Mining Processor”（加密货币开采处理器），专门用于开采第二大加密货币以太坊。 4、美国总统拜登宣布德州处于重大灾难状态 美国德克萨斯州近日来受罕见暴风雪天气影响，断水断电，情况仍未完全缓解。美国总统拜登宣布德州进入重大灾难状态，为批准更多联邦救援资金扫清障碍。 暴风雪天气已造成德州多人死亡，其中包括一些人死于交通事故，同时，还有人因为在车内和室内用发动机取暖导致一氧化碳中毒身亡。 关于德州为什么停电，这里是一篇更为详细的讨论，感兴趣的可以看一下。 5、中国公布八个月前中印冲突中四名官兵死亡的消息 近期一段中印边境冲突的视频火了，这个 “滚” 字喊得尤为热血，但这是去年 6 月发生的事情。 可是为什么八个月后才发布呢？简单概括：1）大国气度担当；2）美国因素；3）疫情之下；4）难解的边境问题。 文章1、【电商设计思维】 如何打造一款价值10000+的爆款详情页？ 设计的本质是信息的有效传达。本文从视觉和营销 2 个方向来讲解电商详情页如何制作可以达到最大的转化率效果，全方面解析爆款详情页是如何产出的。 2、剧本杀新手入坑指南 近几年各类剧本杀层出不穷，这是一篇从概念到玩法都详细介绍的小白入坑指南。 3、字节半年，我的认知升级 作者从加班、提效、团队、取舍四个方面，殊途同归的回到「你能创造更多价值吗？」的思考，很有参考意义。 4、可视化拖拽组件库一些技术要点原理分析 现在有很多现成的可视化拖拽组件的产品，例如 Processon、墨刀等，文章分为三篇，一步一步带大家还原了一个可用的 DEMO（上图）出来。 5、惊了！原来浏览器的秘密藏在这31张图里！ 现代浏览器十分复杂，颇有运行在操作系统之上的”操作系统”的意思，文章用简单容易理解的例子来简单概括它主要的工作逻辑。 6、如何毁灭地球（英文） 毁灭地球比您可能难以想象的要难。对于那些不希望地球存在的人来说，这是一个指南。 以上是文章的前言，详细介绍了一系列毁灭地球的方法，属实硬核。 7、素材如何分类管理 “to B or not to B?This is a question.” 分类管理是永恒的难题，甚至近几年的一些笔记类软件提出不要分类的理念。但如果你想要学习一些素材管理术，这一篇文章或许会给你一些启发。 8、虚幻引擎又进化了！ MetaHuman Creator 是一款云端流送应用，设计目的就是在不牺牲质量的前提下，使实时数字人类的创作时间从数周乃至数月缩短到一小时以内。 这对于那些需要创作众多各具特色的数字人类，而且品质要达到次世代平台和高端虚拟制片的要求来说，是个好消息。 9、如何使用Python创建简单的神经网络（英文） 16 行代码实现了一段非常简单的神经网络代码，包括训练和预测的代码，可以通过这个例子简单了解神经网络是如何进行自我调整的。 10、我们工作到底为了什么？ 此文为惠普大中华区总裁孙振耀 2007 年退休后，在网上广为流传的一篇文章。 文章总结人生有三个阶段：1）为了现实找一份工作；2）为现实，但可以选择一份自己愿意投入的工作；3）为理想去做一些事情。 11、数字时代的中国支付体系现代化 中国人民银行的原行长周小川的公开演讲，谈中国数字支付的发展方向，里面有相当多的技术内容。（略枯燥） 上一段时间，去超市买东西时发现成都已经开始试用数字人民币了： 为什么中国一定要发展数字人民币呢？这里有一个特别的角度，这个角度叫「新时代的”货币战争”」。 好奇星人1、贾玲通过《你好，李焕英》能赚多少钱？ 根据猫眼专业版给出的预测数据，《你好，李焕英》最终票房将达到 51.82 亿。那么，不禁令人好奇，作为这部电影导演、编剧、主演以及投资方之一的贾玲，能从中赚到多少钱呢？ 虽然片方、电影院等影片参与者对如何分账通常会涉及到部分商业机密问题，但是仍然可以通过公开信息计算出贾玲大概能通过这部电影获利多少。 答案是可能 1 亿不到，并且票房约高赚的越少。本文做了详细论述，感兴趣的可以看看。 2、葡萄酒如何品鉴？ 简短 6 分钟的时间，介绍了葡萄酒入门品鉴指南，直接可以化身餐桌上的新晋品酒凡尔赛人。 3、春运火车票为什么不涨价？ 每年春节都有火车票要不要涨价的话题，媒体也乐意看到经济学家要求涨价而被大众围攻的景象，甚至还有人把支不支持火车票涨价，当作有没有经济学思维的试金石。 这篇文章告诉你，其实没有那么玄乎。 4、垃圾如何分类？ 有消息称，将在 3 月 1 日开始在成都试运行垃圾分类。如果对于垃圾分类还一无所知的小伙伴可以参看一下这篇文章。 另外支付宝也有小程序可以帮忙哦。 言论1、 好的代码是为了提高未来的效率，这里的效率不只是编码的效率，还有沟通的效率。 –博客园用户 2、 未来可能有战胜他的人类，但是至少我认为，我这辈子是没什么希望了。 –柯洁谈 AI 3、 恋旧的本质，是人在某种困境中失去了当下，也走不进未来，无所适从，只好淹留在确凿的美好回忆中寻求一点遥远的安慰。 –App@One 4、 这是一个千年未遇的大时代，大家的温饱都解决了，可是我们却比任何一个时代都更焦虑，这太不可思议了…… –郑也夫 5、 目前的状况是，在线教育只是课堂教学的一个低成本替代， 因为不能现场教学，只好看视频上课。这导致在线教育的效果，无法超过课堂教学，所以做不到真正地迅猛发展，只能作为课堂教学的补充手段。 –阮一峰 6、 谢谢你做的一切，我们的李焕英。 –@一个影视 7、 社交的本质是能量争夺战。 –豆瓣小组 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。 （完）","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"惊了！原来浏览器的秘密藏在这31张图里！","slug":"网络4","date":"2021-02-16T03:42:20.000Z","updated":"2021-02-16T07:39:59.967Z","comments":true,"path":"2021/02/16/wang-luo-4/","link":"","permalink":"http://www.wmyskxz.com/2021/02/16/wang-luo-4/","excerpt":"前言现代浏览器十分复杂，颇有运行在操作系统之上的”操作系统”的意思，我们将尽可能用简单容易理解的例子来简单概括它主要的工作逻辑。 目录： 进程与线程概述； 浏览器架构； 浏览器视角下的输入； 页面如何渲染； 如何进行交互；","text":"前言现代浏览器十分复杂，颇有运行在操作系统之上的”操作系统”的意思，我们将尽可能用简单容易理解的例子来简单概括它主要的工作逻辑。 目录： 进程与线程概述； 浏览器架构； 浏览器视角下的输入； 页面如何渲染； 如何进行交互； Part 1. 进程与线程概述计算机的核心是 CPU，它承担了几乎所有的计算任务。 你可以把 CPU 想象成是一个工厂，时刻在运行着。 假设这个工厂的电力有限，同一时刻只能供一个车间使用。这也就意味着，一个车间正在使用，其他车间都将不会被使用。 进程就好比车间，是工厂将要执行的任务。潜台词就是说，单个 CPU 任意时刻总是只能运行一个任务。 一个车间可以有很多的工人，它们协同完成同一个任务。 线程就是车间里的工人。 假设工人都是很耗电的机器人，靠着分得工厂给的电力进行任务，每一次给的电力刚好够完成本次的任务，而工厂同一时刻又只能给一个机器人供电。 这几乎就是单核 CPU 的工作方式了：同一时刻只能做一个工作。 但你仍然感觉到许多不同的任务正在 “同时” 运行着，这是因为当切换任务的速度足够快时，你将感知不到 CPU 同一时刻只能做一个工作的特性： 我们的 CPU 就这样飞速地奔腾着。 每当我们打开一个应用，就会启动一个进程。程序也会创建一个或多个线程来帮助它完成工作。 操作系统会为进程提供一个可使用的 “一块” 内存，就像开工厂占地一样，所有应用程序的状态信息都会保存在该私有内存空间中。程序关闭时，相应进程会消失，操作系统也会释放内存。 进程可以请求操作系统启动另一个进程来执行不同的任务。此时内存不同区域会分给新进程。 如果两个进程需要对话，他们可以通过 进程间通信（IPC） 来进行。 许多应用程序就是这样设计的，如果一个工作进程失去响应，该进程就可以在不停止应用程序的情况下靠着其他进程重新启动。 Part 2. 浏览器架构那么如何通过进程和线程构建 web 浏览器呢？ 虽然对于如何构建 web 浏览器没有明确的标准，但现在拥有一个导航栏、输入框、标签页这样类似的设计却是不同浏览器之间默契的共同选择。 浏览器的架构也总体分为两类： 现在已经很难看到单进程的架构方式了，因为单进程的浏览器需要处理的事情太多（网络、渲染、管理插件等），极不稳定和安全。因此市面上主流的浏览器都已经升级为多进程的方式。 就拿 Chrome 举例来说，就采取了下方的架构方式： 最顶层是浏览器进程，负责协调处理其他进程模块的任务。 UI 进程负责控制地址栏、标签页等； 渲染进程控制标签页内网站的展示。 插件进程控制站点使用的任意插件，比如：Flash。 GPU 进程单独处理来自不同应用发送的绘制请求。 …. 多进程的好处显而易见。比如当你打开了三个标签页，其中一个崩溃了，你可以关掉它而不会影响其他两个标签页： 并且由于进程的数据是私有的，所以一定程度上能够保证安全性。 但缺点也显而易见。我们上面用车间来类比进程，用工人来类比线程，显然「建一座车间」比「招聘一个工人」消耗的资源要大得多——哪怕车间只有一个工人——这里比较明显的是对内存的消耗。 为了避免过大的内存消耗，Chrome 把一些服务做了聚合： 这样就能一定程度上减少内存的开销。 Part 3. 浏览器视角下的输入当在浏览器中键入一个 URL 地址，浏览器会做什么处理呢？ 第一步：处理输入我们已经习惯了一个链接打开就对应一个外部网站，但它还可能是浏览器本身的设置页（如 chrome://settings/），或是本地硬盘的地址（如 Mac 下的 \\）： 所以我们的第一步就是要判断这个输入到底是个啥： 第二步：开始导航随着用户输入完毕按下 Enter 键，UI 线程知道要启用网络去调取网站的信息。网络线程会负责联系目标主机并获取到信息： 网络线程获取信息的过程，发生了很多事，比如 DNS 域名解析、TLS 建立连接等，如果不熟悉可以看看之前的系列文章。 第三步：读取响应总之网络线程为我们取到了来自网站的响应，大概长这样： 响应分为 header 和 payload 两个部分。header 类似于一本书的版权、作者介绍等相关信息，而 payload 才是真实的数据内容。 浏览器需要根据响应头里的 Content-Type 来区分对应内容的类型，例如 text/html 时浏览器会对内容进行 HTML 解析，image/png 则调用图片渲染器。 然而完全信任网站响应的 Content-Type 是不行的，因为一旦 Content-Type 未指定或者是一个错误的值的时候，就会发生未知的错误。 所以当收到响应主体（payload）时，网络线程会在必要时检查数据的前几个字节，以确保数据内容与 header 里标识的数据类型（Content-Type）一致。如果不一致，那么就需要进行 MIME 类型嗅探来猜测该数据的类型。 当响应是一个 HTML 文件时，此时也会进行安全检查（SafeBrowsing 检查）。如果域名和相应数据似乎匹配到了一个已知的恶意网站，那么网络线程会显示一个警告页面。 除此之外，还会发生 Cross Origin Read Blocking（CORB）检查，以确保敏感的跨域数据不被传给渲染进程。 第四步：查找渲染进程一旦所有的检查执行完毕并且网络线程确信浏览器会导航到请求的站点，网络线程会告诉 UI 线程所有的数据准备完毕。UI 线程会寻找渲染进程去开始渲染 web 页面。 由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。 当第 2 步 UI 线程正发送一个 URL 请求给网络线程时，它已经知道它们会导航到哪个站点。在网络请求的同时，UI 线程并行地尝试主动寻找或开启一个渲染进程。 这样，如果一切按预期进行，渲染进程在网络线程接受到数据时就已经处于待命状态。 第五步：提交导航现在数据和渲染进程已经就绪，浏览器进程会发送一个 IPC（进程间通信）到渲染进程去提交导航。 这时地址栏会更新、标签页的历史记录也会更新，前进/后退按钮会走向刚导航过的站点。渲染进程根据 HTML 内容开始解析并渲染页面。最终您将看到网站设计者设计的网站。 Part 4. 页面如何渲染渲染进程涉及 Web 性能的许多方面，流程非常复杂，我们只做必要的理解。如果您想要深入了解，可以在 web.dev 找到相关资源。 渲染进程内部包含主线程、工作线程、合成线程和光栅线程。 在详细说明之前，请先想象一个这样的场景：您站在一副简单绘画的面前，如何通过打电话来让您的朋友知道这幅画究竟长什么样子呢？ 如果您真打算这么做，这里参考 HTML 解析的过程给您提供一些建议。 首先，图中的元素以及具体元素的属性分开描述（如：图里有一个圆是元素，圆有多大具体在什么位置等是属性）： 这样做的好处是可阅读性变高了，有哪些元素，以及元素哪些属性一目了然，也利于分别维护和修改。（类似于书的目录和对应内容一样） 另外是你可以提炼一些通用的属性来减少描述： 然后，最好是分层进行描述，因为图画是有层次的，光有元素大小、位置等信息是不够的： 元素实际上就是我们通常说的 HTML 文件，HTML 文件中包含了描述元素属性的 CSS 样式文件。每个浏览器对应常见的样式都会有默认的样式。 浏览器实际上要知道绘制些什么元素，每个元素属性如何是要分成三步的：1）通过 HTML 绘制元素树（俗称 DOM 树）；2）通过 CSS 文件绘制样式树（俗称 CSSOM 树）；3）综合两颗树绘制渲染树（俗称 Render Tree）； 现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的像素，我们称为光栅化。 处理这种情况的一种简单的方法是，先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。 但是，现代浏览器会运行一个更复杂的过程，我们称为合成。 合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。 另外需要说明的是如何进行描述是有相当的技巧的。例如「正中心有一个 半径为 2 的圆」和「正中心有一个 直径为页面宽度 50% 的圆」是完全不同的： 如何进行组织描述，这需要网站建设者的经验。 Part 5. 如何进行交互在浏览器眼中，用户的一切行为都是输入。不单单是滚动鼠标滑轮，或是点击屏幕、按下按键等。 对于浏览器进程来说只存在事件和对应坐标，只有渲染进程知道页面究竟长啥样，以及究竟该如何处理事件。浏览器进程只负责把事件和坐标发送给渲染进程。 我们也可以编写自己的逻辑文件（js 文件）来监听某一事件进行对应的处理。然后再统一由渲染进程进行合成。为了浏览流畅，浏览器需要保证渲染进程的渲染速度与屏幕刷新率一致（大概每秒 60 帧）。 另外为了降低主线程中传递过量的调用，Chrome 也会把一些连续的事件进行合并。 浏览器进程监听并发送事件给渲染进程进行渲染，这大概就是浏览器交互的基本方式。 后记浏览器的复杂远不是一篇文章能解释清楚的，本篇文章也只是想让大家理解浏览器的基本过程和原理。尽可能使用动图的形式清晰地表达，希望大家能用餐愉快。 本文大量借鉴了 Chrome 官方 developer 分享的系列文章（下2），如果有想更加深入了解的小伙伴也可以阅读更加硬核的浏览器工作原理揭秘文章（下4） 至此，我们对浏览器已经有了相当的了解了。后续也会继续跟大家一起学习计算机网络的基础知识，也会尝试着跟着后端学习路线图的脚步跟着大家一起学习进阶。 这里是我没有三颗心脏，欢迎关注公众号 wmyskxz，2021，与您在 Be Better 的路上共同成长！ 参考资料 进程与线程的简单解释 - http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 转载：现代浏览器内部揭秘 - https://hasaki.xyz/blog/2020-01-20-%E8%BD%AC%E8%BD%BD%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8%E6%8F%AD%E7%A7%98/ 深入浅出浏览器渲染原理 - https://blog.fundebug.com/2019/01/03/understand-browser-rendering/ 浏览器工作原理幕后揭秘 - https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ （完）","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络","slug":"基础知识/网络","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 2 期）：年味去了哪里？","slug":"weekly2","date":"2021-02-14T02:08:48.000Z","updated":"2021-02-14T02:24:32.423Z","comments":true,"path":"2021/02/14/weekly2/","link":"","permalink":"http://www.wmyskxz.com/2021/02/14/weekly2/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：年味去了哪里？","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图讨论：年味去了哪里？ “再也感受不到以前过年的感觉了。”(via) 不知道从什么开始，许多人都习惯性地感叹年味变淡了。我们怀念的那些不可复制的传统年味，似乎已经越来越遥远。 老舍在《北京的春天》里写：“照北京的老规矩，春节差不多在腊月的初旬就开始了”，人们在腊八那天要熬腊八粥、泡腊八蒜，腊月二十三过小年，然后就是最热闹的除夕了，正月初一要去给亲戚们拜年。“元宵上市，春节的又一个高潮到了”，直到正月十九，春节才算结束。 哪一天得做什么事，得准备一些什么，大人心里一清二楚，也都得弄得妥当。这是过节的一种仪式感，这种仪式感赋予了平凡的日子特殊的感情，让平凡的日子不平凡起来。 这样的仪式感，是旧时生活里的必须。这过节里，也饱含孩子们的期待。 可是今昔对比，我们不难发现「年味变淡了」的主观感觉从何而来：在物质贫瘠的往昔，过年是一个盛大而隆重的节日，我们所希望、所渴望的许多东西，只有等到春节才能够实现，所以我们对过年怀有强烈的期待，进行着充分的准备。而今日子变好了，少了期待和苦中作乐，年味自然变“淡”了。 生产力的提升当然是一部分原因，另一部分原因可能是： 仪式感不再像过去那样强烈，淡的是「仪式感」； 中国的家庭规模和家庭结构发生了巨大的变化，小家庭取代了大家庭，家庭成员之间的关系也变得疏离，淡的是「人与人之间的感情」； 更重要的是，团圆的意义变得“淡”了； 但据我观察，似乎小孩子们的”年味儿”仍然那么浓烈，我不禁反思：是不是因为越长大，身上责任越多，越会不自知”年味儿”去了哪里呢？ 不管怎样，不管年味是浓还是淡，都全身心投入到家的温暖中去吧，家永远是咱们温馨的港湾。 祝：新年快乐！ 热点新闻1、腾讯拟发价值超6万元股票：不是每个人都有 据说腾讯系的朋友朋友圈全变成了这样： 2、拜登叫停特朗普对微信和TikTok的禁令 2 月 12 日，美国传来消息，新任总统拜登，叫停了上任总统特朗普对微信和 TikTok 的禁令。 3、日本本州东岸近海发生 7.3 级地震 2 月 13 日 22 时 07 分，日本本州东岸近海（北纬37.70度，东经141.80度）发生 7.3 级地震，震源深度 50 千米，目前为止没有人员死亡和重伤。 据日本气象厅分析称：这是十年前 311 大地震的余震。 文章1、计算机科学界至今未解决的四大难题 伟大的计算机科学家们已经解决了很多理论难题，但是时至今日，仍然有一些未解决的难题。 2、Windows 10X 上手体验 Win 10X 可以认为是微软为了补齐移动端短板的操作系统，如果感兴趣，可以跟着作者一起提前感受下 Win 10X 的魅力。 3、亲历：一行代码，百万人民币打水漂！ 真实一行代码引发线上故障，造成百万级资金损失的故事。 4、产品细节剖析，让你看看大厂是如何做设计的 文章从「微信」、「饿了么」、「爱奇艺」、「微博」、「QQ」等多个热门应用的细节入手，剖析了大厂是如何把控和设计产品的。 5、程序员购钻指南：钻戒值不值得买？怎么买？ 相信我，本篇文章跟程序员的唯一关联是：这是一名程序员写的。 6、现代浏览器内部揭秘 现代浏览器越来越复杂，对于我们来说，也越来越像一个黑盒，在 2018 年 Google develop 网站分享了四篇揭秘的文章，已被翻译成中文，质量较高，感兴趣的可以阅读一下。 其他三篇也贴一下： 现代浏览器内部揭秘（第二部分） 现代浏览器内部揭秘（第三部分） 现代浏览器内部揭秘（第四部分） 7、2021 年度设计趋势分析 文章从 7 大设计领域、400 多个设计案例中，总结出了 9 条属于 2021 年的设计趋势。 8、就地过年的程序员们 今年，你回家过年了吗？这里收录了一些就地过年的程序员的生活。 9、为什么 CPU 有多级缓存？（英文） 非常形象生动地揭示了 CPU 多级缓存的设计故事。 10、程序员如何优雅的挣零花钱？ 一位独立开发者整理成册的《程序员挣零花钱指南》，虽然部分内容已经有些过时，但仍然有很强的借鉴性。 好奇星人1、全网刷屏求码，语音聊天室 Clubhouse 是怎么火起来的？ 近期火爆硅谷的语音聊天软件 Clubhouse 一码（邀请码）难求，如果你对这个软件有所困惑，可以看看这篇文章。 2、小黄人讲得是什么语言？ 小黄人系列电影大受欢迎，其中小黄人说的话有趣但不知所云，却也基本都是有来源的。 3、春晚 XR 黑科技？ 春晚的舞台上，刘德华亮相，却并未真实地登台春晚现场，而是通过 AR、云技术 “出现” 在现场的。 跟关晓彤、王一博的自然互动是如何做到的？这一视频详细解释了 XR 技术的原理以及相关的揭秘。 言论1、 前期靠追逐工资来麻痹，从几k到几w，补偿意义缺失；中期靠追求事业能力来延缓，从小兵到领导，尝试成为意义；后期靠挖掘了解自己，从外在到内心，找到真正适合自己与社会链接的方式 —铲屎大将军（豆瓣小组：大家都是怎么克服生活的无意义感的？） 2、 急功近利的游戏市场环境，催生出的割韭菜小游戏还会涌现。 —大西瓜“爆了”，网红小游戏割韭菜套路大揭秘 3、 无论是任何关系，最终目的都应该是让自己变成更好的人。 —“90后已经不结婚了……” | 公众号@行动派 4、 我们像个回复机器，面对每个熟悉的陌生人，说着早就想好的场面话。 「面子」取代了「温情」，成为春节最炙手可热的缀饰，而家人之间可以聊的话题也越来越浅显。 所以我们变得抵触回家。 –“ 爸妈，我真的不想走亲戚了——” | 公众号：@概率论 5、 每周的周二飞机票最便宜，周五最贵；看不到太阳的飞机票最便宜；每年旺季提前两个月预定会相对便宜；非旺季一般提前 23-30 天最便宜； –抖音：@有用的知识 6、 事实有真假，而观点无对错。人通常只会用自己的观点去评价别人，而不是根据事实。 –你是否能分清观点和事实？ | @抖音：Ethan清醒思考 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。 （完）","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"DNS 是什么？如何运作的？","slug":"网咯3","date":"2021-02-08T09:23:22.000Z","updated":"2021-02-08T09:24:20.352Z","comments":true,"path":"2021/02/08/wang-ge-3/","link":"","permalink":"http://www.wmyskxz.com/2021/02/08/wang-ge-3/","excerpt":"","text":"前言我们在上一篇说到，IP 地址的发明把我们纷乱复杂的网络设备整齐划一地统一在了同一个网络中。 但是类似于 192.168.1.0 这样的地址并不便于人类记忆，于是发明了 域名(Domain Name) 来帮助解决这样的问题。 对应的，我们也需要一个系统来帮助”翻译”： Part 1. DNS 是什么？DNS （Domain Name System 的缩写） 的作用非常简单，就是根据域名查出对应的 IP 地址，你可以把它想象成一本巨大的电话本。 换句话说，DNS 是将域名映射到响应 IP 地址的服务。 Part 2. DNS 是如何工作的？DNS 是我们今天使用 Internet 的核心。 最新报告显示，2020 年第三季度有 3.71 亿个域名，如果没有 DNS 将其对应解析成对应的 IP 地址，我们将会在网络世界中迷路。 当宁想要使用手机打电话给某人，宁几乎不太可能背出确切的电话号码，而是直接使用此人的名字进行搜索和拨号。 当宁想要加载网站时，DNS 会执行类似的操作。 解析域名或者主机名需要经历几个不同的阶段。 在某些情况下，DNS 解析是一个一步就完成的过程，而某些情况下，则需要联系多个 DNS 服务器。 下图就展示了这一过程必要的步骤，并且没有考虑浏览器缓存： 过程可能有些复杂，为了便于理解，我们在进一步说明之前需要先说明两点：「DNS 服务器和域名的分级」 以及 「DNS 缓存」。 Part 3. 域名和 DNS 服务器的分级域名的分级我们日常上网输入的网址，比如：https://www.google.com，其实可以拆成几个部分看待： 默认支持的服务类型（HTTP/ HTTPS）、主机名（www）、端口号（80）、默认文档（index.html）是可以省略的，所以以上网址可以省略为：google.com。 严格来说，google.com 才被称为域名（全球唯一），www 是主机名，对应着一种服务，google.com 域名下不同的主机服务器，可以提供很多不同的服务： www、blog 等很多服务可以部署在同一台服务器上，而一台服务器独占着一个 IP 地址，可见，域名和 IP 地址的对应关系可以是多对一的，或者一对多（负载均衡），也可以一对一。 所有的域名都有一个根的概念，所以整个互联网的域名空间看起来会是这样： DNS 分级把全世界所有的电话号码存储在同一个通讯录里面既不现实也效率低下。 DNS 也是类似，对应域名空间，DNS 也有类似的结构： 整个域名系统采取分布式存储。 全世界根域名服务器总共有 13 个，其中 10 个在美国，英国瑞典各 1 个，日本 1 个： 这是逻辑上的数量，这 13 个根域名器服务器背后其实还是有很多台物理的服务器在工作。 根域名服务器只负责管理顶级域名服务器（Top Level Domain，简称 TLD），记录所有 TLD 的位置。 而 TLD 则对应管理着所有注册在当前顶级域名下的所有权限服务器，也就是真实提供服务的服务器的真实 IP 地址。 这有点儿类似于我们真实的通讯录，比如我们想要给 香克斯 打电话： 可以这样想象：全世界的域名被根域名服务器逻辑的统一在一个通讯录中，而根域名服务器就像右边的导航一样，存储着不同标识对应列表的位置信息； 而这些标识类似于顶级域名服务器，存储着注册其下所有的权限服务器（比如 google.com 对应的服务器）信息； 只有查询权限服务器，你才能拿到详细的 IP 地址（不考虑缓存的情况下）； Part 4. 为什么需要 DNS 缓存？通过上面通讯录的例子，我们已经足够理解 DNS 查询的主要过程了：（再来看一眼） 但实际上，真正访问 DNS 服务器之前，我们会在多个地方缓存域名与 IP 之间的对应关系： 这样可以减少对 DNS 服务器的访问，减缓 DNS 服务器的访问压力； 这样也能够加快域名解析的过程； 涉及 DNS 的地方就会有缓存，包括浏览器、操作系统、本地 DNS 服务器、路由器、ISP 提供的递归路由器、根域名服务器等，它们都会对 DNS 结果做一定程度的缓存。 但是，DNS 缓存也存在一些问题： DNS 更改刷新需要时间来传播，这意味着每一台 DNS 服务器缓存更新到最新的 IP 需要一段时间； DNS 缓存也是黑客潜在的攻击手段； Part 5. 一次请求的详细过程这一次我们来跟踪一次详细的过程，例如我们在浏览器输入网址 www.example.com 并回车： 查询浏览器缓存，有结果则返回；（如果你使用 Chrome 浏览器可以输入 chrome://net-internals/#dns 自行查看） 查询系统缓存，通常存在于 host 文件中，有结果则返回； Mac：/etc/hosts Windows：C:\\Windows\\System32\\drivers\\etc\\hosts 向本地 DNS 服务器，通常是路由器，有结果则返回，否则向上查询直连 ISP 的递归 DNS 服务器； 查询 ISP 提供的 「递归 DNS 服务器」，有缓存则返回，否则一直递归查询到 「根服务器」； 「递归 DNS 服务器」 向 「根服务器」 查询 「.com 权威 DNS 服务器」 的地址； 「递归 DNS 服务器」 向 「.com 权威 DNS 服务器」 查询 「example.com 所使用权威 DNS 服务器」 的地址； 「递归 DNS 服务器」 向 「example.com 所使用权威 DNS 服务器」 查询解析获得 DNS 记录并缓存； 「递归 DNS 服务器」 向浏览器返回结果； 浏览器拿到 IP 地址并向 www.example.com 发送请求；（完毕） 结合上面的内容，我相信你已经对 DNS 如何工作不再陌生。 相关问题为什么根 DNS 只有 13 台？简而言之：由于历史和技术原因，对于 IPv4 来说，根 DNS 只能有 13 个。 不简而言之的简而言之： DNS 消息使用 UDP 协议进行传输，这规定了消息最大的长度在 512 字节（不包含 IP 头部、UDP 头部）。 有了最大长度限制之后，一个 UDP 协议传输的 DNS 响应能够返回的资源记录数量就是有限的。 要让所有的根服务器数据能包含在一个 512 字节的 UDP 包中，根服务器只能限制在 13 个。（事实上改进之后才能容纳 13 个，最开始也没有 13 个这么多） （扩展阅读(下3)） 当键入网址后，到网页显示，其间发生了什么？本文涉及输入网址访问，这是自然而然会联想到的问题。但本文只是详细说明了 DNS 查询域名背后 IP 的过程。 该问题涉及浏览器原理、网络协议等细节问题，感兴趣可以戳这里(下4) 美国如果把根域名服务器封了，中国会从网络上消失吗？美国拥有最多的根域名服务器，如果美国把根域名服务器封了，中国会从网络上消失吗？ 答案是：不会。 因为虽然根不在我们手里，但是我们有镜像（备份）。 扩展阅读(下5) 后记这一篇文章我们又进一步揭开了一点网络关于 DNS 一角的神秘面纱： 也是使用了 PPT 制作了动图帮助大家理解，希望大家能够有所收获。 后续也会继续跟大家一起学习计算机网络的基础知识，也会尝试着跟着后端学习路线图的脚步跟着大家一起学习进阶。 （完） 参考资料 What Is A Domain Name System (DNS) &amp; How Does It Work? - https://phoenixnap.com/kb/what-is-domain-name-system-works 域名报告 - https://www.verisign.com/assets/domain-name-report-Q32020.pdf 根域名服务器只有 13 台？ - https://zhuanlan.zhihu.com/p/107492241 30张图解：当键入网址后，到网页显示，其间发生了什么？ - https://zhuanlan.zhihu.com/p/113702574 美国如果把根域名服务器封了，中国会从网络上消失？ - https://segmentfault.com/a/1190000023696737","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络","slug":"基础知识/网络","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"一周精彩内容分享（第 1 期）：\"世纪逼空大战\"","slug":"weekly1","date":"2021-02-06T03:09:05.000Z","updated":"2021-02-07T01:28:33.988Z","comments":true,"path":"2021/02/06/weekly1/","link":"","permalink":"http://www.wmyskxz.com/2021/02/06/weekly1/","excerpt":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图故事：”世纪逼空大战”","text":"这里记录过去一周，我看到的值得分享的东西。 一方面是整理记录一下自己一周的学习，另一方面也是期待自己有更多的输出，有更多的价值。 周刊开源（Github：wmyskxz/weekly），欢迎提交 issue，投稿或推荐精彩内容。 题图故事：”世纪逼空大战” 前段时间，美股 GameStop 游戏驿站上演了一场 “世纪逼空大战”。 美股的散户们疯狂抱团，活活把一支行将退市的垃圾股，从 3 美元拉到 300 多美元，暴涨 100 倍，把华尔街的资本家们彻底按在地上反复摩擦，搞得金融巨头们只能举白旗投降。 堪称一部史无前例的金融大电影。 下面是我整理精简之后的整个事件的大致时间线：(via) 2020 年 7 月 一名 ID 为 DeepFuckingValue（以下简称DFV）的用户在 WallStreetBets（华尔街赌场）论坛上分析认为：游戏驿站将形成轧空（过度做空后形成的股价暴涨）。于是，DFV 在游戏驿站低点时买入 5 万美元股票和看涨期权。 2020 年 8 月 —— 12 月 游戏驿站的股价不断走高，每股单价从年初的 4 美元左右涨到了 20 美元左右。 2021 年 1 月 11 日 一个利好消息传来，游戏驿站新任命三名公司董事中，就有前宠物电商 Chewy 的创始人 Ryan Cohen。游戏驿站的股价开始一路上涨。 2021 年 1 月 19 日 在游戏驿站暴力拉升之后，香橼在社交媒体上表示，游戏驿站的买家“是这场游戏中的傻子”，这一言论点燃了散户的怒火，经过媒体报道，越来越多的散户入场。 2021 年 1 月 22 日 期权交割日。空头没有等来股价回落，只能承受股价的向上熔断，以 65 美元每股交割期权。 2021 年 1 月 26 日 脸书的早期员工之一、硅谷风投 Social Capital 创始人查马斯·帕里哈皮蒂亚在推文中公开表示，自己购买了游戏驿站看涨期权，股票当天上涨 92%。 香橼（空头代表）最终认输。 2021 年 1 月 27 日 WallStreetBets 服务器突然遭到 Discord 平台的封杀，页面突然变为了私人页面，令美国散户炸锅。 颇有打不过就拔网线的意思。 2021 年 1 月 28 日 美国时间 1 月 28 日开盘后，被称为“散户大本营”的零佣金在线券商罗宾汉（Robinhood）突然关闭了游戏驿站的股票买卖。 随后，据 CNBC 报道，美国最大在线券商之一的盈透证券（Interactive Brokers）也限制了 GME 及相关热门股的股票和期权交易。 截至北京时间 2021 年 1 月 28 日 19 时许，做空机构继续败退，在美国散户疯狂抱团下，游戏驿站盘前大涨超 40%。 这场史诗级金融电影仍在继续，无论结局如何，游戏驿站必然将成为美国证券史上的一个标志性事件。 热点新闻1、虾米音乐停止服务 2 月 5 日零点，是虾米音乐原定停止服务的时间，当天仍有 100 万 “音乐难民” 在虾米音乐直播间在下沉的世界里做最后狂欢。 2、程序员拒绝春节带电脑回家工作被开除 判决获赔19.4万 据上海浦东法院公众号消息，因为春节拒带工作电脑回家被开除，上海一位软件工程师起诉获赔 19.4 万元。公司不服提出上诉，后被驳回，目前判决已经生效。 3、抖音正式起诉腾讯，要求停止封禁 抖音方面主张，腾讯通过微信和 QQ 限制用户分享来自抖音的内容，构成了《反垄断法》所禁止的“滥用市场支配地位，排除、限制竞争的垄断行为”，并要求腾讯方面进行 9000 万的赔偿。 双方在短短两天内进行了四个回合的交战，可以说是火药味十足。 4、人人影视被查封 2 月 3 日，上海市公安局召开新闻发布会，通报侦破一起侵犯影视作品著作权案。 这个被连根拔起的应用，不是一般的盗版网站，而是存活了十几年、且有众多美剧死忠追随者的人人影视字幕(YYeTs.com)。 5、国产游戏戴森球计划被老外吹爆 2020 年 8 月，一段国产游戏《黑神话·悟空》的实机演示宣传视频刷爆海外社交媒体。 而最近，一款国人自主研发的科幻建造类游戏《戴森球计划》，成功的再次刷爆国外玩家圈，优秀口碑更是达到恐怖的 97%。 而这样一个几乎完美的游戏的创造者，居然仅仅只有五个年轻人。 5、中国首幅火星图像 据中国探月工程官方消息，2 月 5 日 20 时，中国首次火星探测任务“天问一号”探测器发动机点火工作，顺利完成地火转移段第四次轨道中途修正，确保按计划实施火星捕获。 在 2 月 6 日首次对外公开了天问一号在距离火星约 220 万公里处，获取第一张火星图像。 文章1、从 “�” 到 “锟斤拷”，这都是些啥玩意？ 本篇从技术的角度详细论述了无处不在的“�”到底是什么，怎么来的这一类问题。 2、尤雨溪 3 天 10 更的 Vite 究竟有什么魔力？ 使用 webpack 打包 Vue 项目缓慢，该篇讲述了 vite 工具是如何解决 webpack 存在的问题的。 如果想了解 vite2 的最佳实践，也可以戳这里 3、NoSQL：一个帝国的崛起 用漫画的方式讲解了 NoSQL 是如何一步一步建立起来的。 4、写了十年技术博客，我收获了什么 作者分享了这十年写技术博客的经验和理解，好奇心、表达欲的保持，或许是作者想要表达的关键点。 5、Java和现代CPU，第1部分：内存和缓存层次结构（英文） L1 是手中的啤酒瓶，L2 是沙发旁的冰箱，L3 是厨房中的冰箱，主内存是转交的存储柜。 本文实际通过一些例子和测试来论证了：通过了解 CPU，内存和缓存如何影响程序执行，您可以了解应用程序性能并优化软件方法。 6、UX 设计方法和可交付成果的完整列表（英文） 从服务蓝图、消费者地图、角色、生态系统、竞争审计、价值主张、关键绩效指标、故事板等各个维度，介绍了设计人员在整个设计过程中最常见的工具、方法、过程和可交付成果。 7、开发人员如何管理时间（英文） 三个原则：1）善待自己，拥抱正在学习的新技能；2）专注于输出而不是等待完美；3）抵抗过早的自动化； 四种策略：1）确定优先事项；2）屏蔽您的日程安排；3）重新调整内容的用途，选择深度而非广度；4）通过微调系统来提高吞吐量； 8、字有道理，文字编排的细节 文字编排有两个层面的作用。其一，它做了一些传递信息的工作；其二，它自身在合理地编排下就会有韵律的美感。文章详细论述了这两个方面的作用。 9、来自一位”老司机”的困惑 一位职场工作快 10 年的设计师，发出了独属于 “老司机” 的迷茫、困惑。 10、全世界最受欢迎的字体——Helvetica——将何去何从？ 中立的特性体现在瑞士设计文化的方方面面，这其中就包括全世界最受欢迎的字体——Helvetica 。 由瑞士设计师 Eduard Hoffmann 和 Max Miedinger 于 1957 年设计，并在美国的推广策略中将它命名。Helvetica 意为“瑞士的”。 本篇文章介绍了 Helvetica 的过去，以及想要讨论在追求个性化的今天，这个追求 “中性” 的字体究竟该何去何从？ 好奇星人1、《戴森球计划》是如何做优化的？ 《戴森球计划》中可以有数千艘运输机在忙碌，数千座设施在运作，数万个太阳帆在环绕，数十万货物在运送，斗转星移，地面上所有太阳能板都面朝着太阳… 这计算量可不是闹着玩的！而以上还只是这一个星球。 游戏是如何保证流畅性的，作者大大在这一篇中给了尽可能的解释。 2、揭秘隔空充电技术（中文） 小米 11 支持隔空充电，本文介绍背后的技术原理。 3、电视剧是如何盈利的？ 这是一个典型的 “羊毛出在狗身上，猪来买单” 的商业逻辑，该视频解释了这一盈利逻辑。 4、电脑长久不关机会缩短电脑寿命吗？ 答案是当然会，只不过这篇文章给了详细的理由。 5、熬夜快感的本质是什么？ 睡前拖延的本质是什么？这篇文章给出了答案以及一些可能起作用的干预策略。 言论1、 我发现一个现象，“简单”这个词的词性在这短短十几年中从一个中性词变成褒义词。 原本“简单”在形容人或生活时经常指单纯、不复杂，平凡、一般、普通等等，而现在，它往往代表一种美好的远景，“简单的生活方式”备受推崇。 –余果 2、 加班猛的公司，人力成本有时候能直接压缩一半以上。 –抖音 | @温义飞的急救财经 3、 讽刺的是，当口罩成为人类的救星之时，却也成了其他物种的杀手。 –公众号 | @INSIGHT视界 4、 我们求而不得的生活意义感，首先是通过这样真实地投入生活开始的。只有当你“真实地存在”的时候，你和生活才建立了足够深入和真诚的链接。 –公众号 | @KnowYourself 5、 对于酷狗“山寨办”所作所为，我们不是不自豪、骄傲、欢喜、炫耀和感动的。千言万语一句话，对于酷狗对网易云音乐的肯定，我们也表示充分的肯定。 祝酷狗音乐狗年快乐。 –网易云音乐产品团队 订阅这个周刊每个礼拜天发布，同步更新在个人博客和微信公众号 微信搜索”我没有三颗心脏”或者扫描二维码，即可订阅。 （完）","categories":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"}],"author":"我没有三颗心脏"},{"title":"28张图解 | 互联网究竟是「如何连接，如何进行通信」的？","slug":"网络2","date":"2021-02-01T02:55:23.000Z","updated":"2021-02-01T02:57:51.474Z","comments":true,"path":"2021/02/01/wang-luo-2/","link":"","permalink":"http://www.wmyskxz.com/2021/02/01/wang-luo-2/","excerpt":"","text":"前言 在上一篇中，我们讲解了网络是靠跨洋的海底电缆以及各大互联网组织制定的规则、协议来进行连接运作的。 但是具体是怎么进行连接的？ 没有说明得很清楚，今天就让我们一起来探索探索。 一个简单的网络当两台计算机需要通信时，您必须物理的 (通常使用网线) 或无线的 (例如 Wifi 或蓝牙) 链接它们，所有现代计算机都可以维持这样的链接。 这样的网络不限于两台计算机之间，你可以接入任意数量的计算机，但很快也会变得复杂起来： 例如，如果要连接 6 台设备，则需要 15 根网线，每台计算机需要连接 5 根网线！ 为了解决这样的问题，我们需要一个中间设备，让所有计算机接入它，由这个中间设备做转发，这样就能有效的减少网线的数量了： 这样一来，虽然减少了网线的数量，但同时也增加了要求。 最初我只需要把信息通过合适的网线传送出去就可以了，但现在，所有的信息都统一发到中间设备那里，谁发给谁的，还必须计算机设备自己说清楚。(就像写邮件一样的) 另一点要求是这个中间设备不能进行广播。 如果我们只是无脑的做转发，让所有其他计算机都接受到，把是否要接受信息的权利和判断交给接受的计算机，这既不安全也极大的浪费了网络资源。 (当然自主搭建较为安全的网络环境中，我们可以使用只是无脑转发的集线器来完成这一工作) 所以我们中间设备需要更加智能一些，只转发给需要信息的人就好了： 要做到这一点，首先我们每台设备都需要一个唯一的标识 (名字) 才行，这在每一个网络设备出厂之前，生产它的厂家就已经给它赋予一个全球唯一的 MAC 地址。 形象地说，这就像我们的身份证号码一样，具有唯一性。 另一点就是我们需要一个地方记录，哪一个 MAC 地址的设备对应着中间设备的物理连接的哪一个端口： 实际上，这就是交换机干的事情。(注意这是交换机不是路由器) 可是这张表是如何建立的呢？ 最开始启动的时候，这张表是空白的。 当有数据交换发生时，交换机通过源 MAC 地址不断进行学习到 MAC 地址表中，并与端口进行关联： 交换机在 MAC 地址表中并未查询到目标 MAC 地址，因此该数据将从出了其入口接口之外所有的接口泛洪出去： C、D 机器在收到数据后就将数据丢弃了——因为并不是发给自己的——相反 B 机器因为 MAC 地址符合，就收下了，并且需要回复数据给 A 机器。 好了，此时对于交换机来说，又是一个新的源 MAC 地址的数据发来了，记录学习的同时也查询到要去往 A 机器的目标 MAC 地址已经存在了，于是直接转发到 01 端口就好了： 就在这样不断的数据交换中，交换机不断更新维护着自己的 MAC 地址表。 好了，现在总算有了一个由交换机组建的简单网络了： 更大的网络到目前为止，运行一切良好，可是如果是连接成千上万亿台计算机呢？ 我们很容易想到，理论上，可以通过多个交换机互联来进行无限的扩展： 但是由于交换机本身没有 MAC 地址，所以数量超过一定时，每台交换机维护的 MAC 地址表将会变得无法维护——事实上也无法存储这么大数据的 MAC 地址表。 所以我们需要一种拥有独立 MAC 地址，帮助我们做转发的设备——路由器由此诞生。 路由器的每一个端口，都有一个独立的 MAC 地址。 这样就有效减少了每台设备需要维护的 MAC 地址表的数量，但同时随着网络的扩展，新的问题又出现了。 上面说到，MAC 地址就像我们的身份证一样，虽然具有唯一性，但就像人和身份证的关系一样，小范围内，我能轻易的找到你，一旦范围扩大 (或者说环境变复杂)，身份证这样的信息似乎对于「快速找到你」这件事来说，帮助很小。 我们需要另外一种信息，来帮助定位——这就是 IP 地址，类似于你写在快递单上的地址一样，它能帮助我们在网络中定位到你的终端。 为了适应这一改变，我们发送的数据需要添加上更多的信息： 同样的，路由器也对应需要额外的记录 IP 地址与 MAC 地址的对应关系： IP 地址的发明把纷繁复杂的网络世界 (主要是不同网络硬件设备) 统一规划到了一个整齐的网络中。 由于 IP 地址是跟地域挂钩的，所以在网络中找到你的设备就容易多了 (就像你买淘宝需要先填写自己的收货地址一样)，我们也能够使用路由器搭建起更大的网络： 互联网上面的网络非常接近我们所谓的 Internet，但是我们缺少一些东西。 我们不太可能在世界的每个地方之间都铺设上电缆，事实上，电话基础设施已经先于网络基础设施连接起了全世界，这是我们需要完美的电线。 为了将我们的网络连接到电话基础设施，我们需要一种称为调制解调器 (俗称”猫”) 的特殊设备，这个设备可以将来自我们网络的信息转换为可由电话基础架构管理的信息，反之亦然。 (相信不少小伙伴都还记得需要「拨号上网」的日子，这就是把网络接入电话基础设施的过程，现在已经优化了) 到此，我们的网络已经连上了电话基础架构。 但我们的目的是把消息发送给我们要到达的其他网络——目前为止，这一整套网络都是基于自己的目的搭建的——为此，我们还需要把网络连接到 Internet 服务提供商（ISP）。 ISP 是管理一些特殊路由器的公司，这些路由器都链接在一起，并且还可以访问其他 ISP 的路由器。 (中国的 ISP 服务商耳熟能详：电信、网通、移动、联通、铁通等。) 因此，来自我们网络的消息将通过这么多 ISP 网络搭建的基础网络架构来传送到目标网络——互联网的基础结构也由这个网络组成。 现在经过一系列的发展，已经形成了三层 ISP 结构的因特网了： 由此，整个互联网基础架构就搭设好了。(实际更复杂) 寻找目标终端如果要把消息发送到计算机，则必须要指定 IP 地址，它是由一系列由点分割的四个数字组成，例如：192.168.2.10。 这对于计算机来说完全是可以的，但我们人类却很难记住这种地址。 于是我们给 IP 地址加上了一个易于理解的名字，即 域名 domain name。 例如 google.com 是作为 IP 地址 173.194.121.32 的域名使用，访问这两个地址是访问的同一服务器，这也是我们访问 Internet 的简便方法。 虽然我们通常使用域名来访问网站，但 Internet 和 Web 却并不等同，网络是基础设施，在互联网之上还有许多不同于 Web 的其他服务，例如电子邮件。 这两者的转换需要互联网的域名系统服务来支撑，我们会在后续详细说到。 另外我们可以给微信好友发送消息，也是因为我们通过微信 App 连入了腾讯的服务器，以此为桥梁互相知道了 IP 地址。 总之，我们通信必须指定 IP 地址。 后记本篇文章，我们从最初两台互连的计算机一步一步发展到搭建起了整个互联网的基础通信架构： 通过交换机、路由器、调制解调器、ISP、跨洋电缆物理桥接； 通过 MAC 地址、IP 地址的发展让整个网络的网络设备逻辑互连； 至少对于这个复杂的 Internet 黑盒有了一定的了解和认识。 这其中涉及到很多复杂的协议 (例如保证可靠通信的 TCP/IP 协议) 和算法 (查找 IP 位置最佳路径的路由算法) 等都没有提及，本篇的重点还是网络世界中的设备是如何进行链接的。 也是使用了 PPT 制作了动图帮助大家理解，希望大家能够有所收获。 后续也会继续跟大家一起学习计算机网络的基础知识，也会尝试着跟着后端学习路线图的脚步跟着大家一起学习进阶。 （完） 参考资料 这就是网络吗？|闪客sun - https://mp.weixin.qq.com/s/9frk_VS8Vh0mY-rXnitKFw How does the Internet work? - https://developer.mozilla.org/en-US/docs/Learn/Common_questions/How_does_the_Internet_work 知乎 | 交换机 MAC 表的获取？ - https://www.zhihu.com/question/58187639 百度百科|MAC地址 - https://baike.baidu.com/item/MAC%E5%9C%B0%E5%9D%80 为什么有 MAC 地址还要有 IP 地址？ - https://blog.csdn.net/qq_15760109/article/details/78210151","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络","slug":"基础知识/网络","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"图解|网络究竟是如何运作的？","slug":"图解-网络究竟是如何运作的？","date":"2021-01-30T01:09:34.000Z","updated":"2021-01-30T01:16:07.283Z","comments":true,"path":"2021/01/30/tu-jie-wang-luo-jiu-jing-shi-ru-he-yun-zuo-de/","link":"","permalink":"http://www.wmyskxz.com/2021/01/30/tu-jie-wang-luo-jiu-jing-shi-ru-he-yun-zuo-de/","excerpt":"前言 毫无疑问，互联网已经彻底改变了人们的生活，不管怎样，它或许是我们建造的最伟大的工具。 但它是怎么工作的？它属于谁？它身在何方？又是谁来保证它持续运转呢？ (参考视频) 今天就让我们一起来探索探索。","text":"前言 毫无疑问，互联网已经彻底改变了人们的生活，不管怎样，它或许是我们建造的最伟大的工具。 但它是怎么工作的？它属于谁？它身在何方？又是谁来保证它持续运转呢？ (参考视频) 今天就让我们一起来探索探索。 互联网简史ARPA 成立1957 年，正值冷战期间，苏联人发射了世界上第一颗人造卫星，代号 SPUTNIK。 当卫星进入行星轨道后，美国人感觉自己技术落后的同时又开始了瞎想：苏联人既然有能力能将卫星正确发射到轨道，那么同样的原子弹也可以精准地丢到美国来。 作为响应，美国国防部组建了研究计划局 (Advanced Research Projects Agency，ARPA)，并开始琢磨着将科学的技术运用于军事领域当中。 分布式通讯网络兰德公司成立于 1946 年，总部位于加利福尼亚州圣莫尼卡，目前是一家非营利性机构，旨在帮助制定公共政策和改善决策过程。 在冷战时期，兰德研究人员设想了 「如果美国突然遭遇核袭击」 这样的可能战争场景时发现：如果突然爆发核冲突，通讯系统将受到严重威胁，指挥系统可能会停电。 1964 年，一个名叫 保罗·巴兰(Paul Baran) 的兰德主要研究人员发表了一篇名为《分布式通信》的论文，其中概述了一种足以抵抗核袭击的弹性通信系统。 尽管不可能建立一个保证所有单点可用的通信系统，但巴兰认为，可以想象有一个系统可以迫使敌人摧毁 “n 个站点” 才能让系统瘫痪——只要 n 足够大，即使在热核时代，也可以构建高度可用的系统结构。 巴兰率先提出通信网络只能围绕两个核心结构构建：「集中式」和「分布式」。 在由此得出的三种可能网络类型中：A）集中式；B）分散式；C）分布式，发现分布式分布在发生军事打击时更可靠。 但不幸的是，巴兰的理想网络太领先于时代，最终被困在了模拟阶段。 第一代互联网——阿帕网(ARPANET)直到 1969 年，在 加州大学洛杉矶分校 UCLA，才终于奠定了互联网的第一个基石，并建立了第一代计算机网络 ARPANET——一个由美国国防部高级研究计划局 (Advanced Research Projects Agency，ARPA) 开发的第一代互联网。 矛盾的是，十年前作为军事手段应对冷战威胁的方式开始变成了一种完全不同的网络。 在 1967 年 10 月于盖特林堡 CM 研讨会上提出的 ARPANET 最初计划中，项目负责人 Larry Roberts 列举了建立该网络的一系列原因。 他们都不关心军事问题——相反，他们着眼于在计算机之间共享数据负载、提供电子邮件服务、共享数据和程序，并着眼于提供一种用于远程登录和使用计算机的服务。 在一年后（1968 年 6 月 3 日）发布的最初的 ARPANET 计划计划中，Roberts 写道： 该计划的目标是双重的： 1）开发技术并获得互连计算机的经验，使得可以进行非常广泛的交互； 2）通过资源共享来提高和提高计算机研究的效率。 (历史趣闻：1969 年 10 月 29 日 UCLA 与斯坦福研究所（SRI）之间成功发出了第一个信号。在网络上发送的第一条消息应该是「Login」，但在发送字母「g」的时候，连接崩溃了。) ARPANET 发展 在随后的几年中，ARPANET 进行了合并和扩展，而公众对这几乎一无所知。 1971 年，阿帕网扩充到 15 个节点，历经几年成功运行后，已发展成为连接许多大学、研究所和公司的遍及美国领土的计算机网，并能通过卫星通信与相距较远的夏威夷州、英国的伦敦和北欧的挪威连接，使欧洲用户也能通过英国和挪威的节点接入网络。 后来效仿阿帕网出现了很多不同的网络，由于阿帕网无法做到与其它类计算机网络交流，1973 年春，文顿·瑟夫（Vinton Cerf）和鲍勃·康（Bob Kahn）开始研究如何将阿帕网和另外两个已有的网络相连接。 尤其是连接卫星网络（SAT NET）和基于夏威夷的分组业务的 ALOHA 网（ALOHA NET），瑟夫设计了新的计算机交流协议，最后被称为传送控制协议/互联网协议（TCP/IP）。 在接下来的时间里，ARPA 网不断发展，联入了越来越多的电脑，并最终促生了现代互联网。 万维网的发明 二十年后，英国计算机科学家 Sir Tim Berners-Lee 在日内瓦的欧洲核子研究组织 CERN 工作，工作内容为修复 CERN 系统中因不同网络不兼容而造成的混乱。 他给出的解决方案是：创建万维网（World Wide Web）。(标准化服务器和客户端之间的通信) 虽然「互联网」和「网站」常被当做同义词使用，但它们不是同一个东西。 互联网是网络的基础结构，而网站存在于互联网之上，本质上网站是利用互联网来获取信息的途径。 互联网是如何将我们联系起来的？ 如今互联网已成了跨越全球的互联化点阵，因此我们不得不问：「互联网是如何将我们所有人联系起来的？」。 跨洋光缆光缆跨越海洋连接起了各国，这已经不是什么新鲜事。 早在 1854 年第一条跨大西洋的电报电缆就已经开始施工了。 相较于超复杂的跨洋光缆铺设技术，施工过程却出人意料的简单。(了解更多关于海底光缆) 海面上，轮船在放出光缆。 海底下，电缆犁在把光缆固定到海底。 每隔 40km~60km 还得有个中继器来保证信号。 光缆里面只有光导纤维，外面包裹着厚厚几层保护壳——抵御海水腐蚀和偶尔的鲨鱼攻击等。 在海床上，光缆被铺设在由缆线埋设机在海底冲出的一条光缆沟内，最后借由海流让砂自然覆盖住电缆。 如果海底地面不平，光缆就容易暴露，就容易收到船锚或其他自然灾害的损害。 2008 年就发生了一场因为光缆受损而造成的事故，导致印度约 60％ 和埃及约 70％ 的互联网服务临时瘫痪。 即使是在现在，光缆受损依然很常见，世界各地的破损光缆要不断进行维修。 当然，还有很多其他通讯线路，仅切断一根光缆是不可能完全断网的。 尤其是在近现代，因为卫星时刻环绕地球，并从空中与互联网对接。 当整个海底光缆铺设完成之后，将有一系列光缆铺满整个国家，直接连至你的家。 互联网到底归谁所有？总的来说，互联网仍然在成长，地球上大约有一半的人可以使用它，所以直到大规模使用达到饱和时，我们才能看到互联网真正的潜力。 那么互联网到底归谁所有？ 严格来说，它不属于任何人。 互联网本身就是多种公共网络的自主互联，它是分散的，因此没有任何政府或机构拥有或控制互联网。 但是政府有权利通过影响改过互联网服务提供商（ISPs）的法律，来控制其公民访问互联网的权限。 例如，中国限制其公民访问油管（Youtube）等外国网站。(深度分析|为什么我们不能访问谷歌？) ICANN 机构 2016 年，美国政府正式交出数据库所有权，将互联网域名管理权交给 ICANN 这个组织——这意味着互联网所有权重新回归到人民大众手里。 ICAAN 是一个独立机构，由多个利益相关的社群组成——这表明 ICAAN 会向网络大众征集意见，并最大可能保持开放和透明。 所以你可能没有听过 ICAAN，但该非盈利组织有一项重要举措，以维持互联网安全——他们管理域名系统（DNS)，主要任务是分配网址。 即当你输入网址 www.google.com 时，需要保证你接收到的响应来自谷歌，而不是其他伪造的盗版谷歌。 其他互联网组织ICANN 只是确保互联网正常运行的一个组织，但不是唯一一个，还有很多其他组织。 比如互联网工程任务组（Internet Engineering Task Force）和由蒂姆·伯纳斯·李掌管的万维网联合会（The World Wide Web Consortium）。 这些组织设置标准、制定协议，并确保互联网的安全性和开放性。 小结所以互联网是如何运行的呢？大概总结起来就是： 通过海底光缆实现全球的物理连接； 通过各种互联网组织制定的协议、规则互通互信； 不可争辩的是，互联网已经彻底改变了我们的生活，它渗入到我们生活的方方面面。 人们可以仅通过一部手机，就可以浏览全世界的百科全书，使用搜索引擎解决问题的人也不在少数。 这些巨量的信息也参杂了巨量的误导信息，在互联网时代，人们更容易用确认偏误来验证自己的观点，从而导致了臭名昭著的回声室效应。 我们需要警醒的是互联网不仅仅有积极的一面，也有消极的一面。 几乎任何技术都有这样的问题，人性使然，我们总是会抱怨人造工具的使用方式，而不是工具本身。 尽管如此，互联网总归是一个非常强大的工具，但是我们应该正确的使用它。 希望你对互联网如何工作，谁控制它有了一定的了解，感谢阅读。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络","slug":"基础知识/网络","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"公众号终于开通留言了，说点心里话","slug":"公众号终于开通留言了，说点心里话","date":"2021-01-25T04:24:31.000Z","updated":"2021-01-25T04:25:46.227Z","comments":true,"path":"2021/01/25/gong-zhong-hao-zhong-yu-kai-tong-liu-yan-liao-shuo-dian-xin-li-hua/","link":"","permalink":"http://www.wmyskxz.com/2021/01/25/gong-zhong-hao-zhong-yu-kai-tong-liu-yan-liao-shuo-dian-xin-li-hua/","excerpt":"","text":"初心2017 年，那个时候我还在念大学，刚接触 Java 系列的课程。 在自我学习的过程中，在简书上无意看到一位博主分享的关于他重学 Java 的系列文章，相比书本系统死板的体系，以及对 Java 宛如一张白纸的我来说，博主生动的文笔让我有醍醐灌顶的感觉，即使寝室在晚上 11 点就断电了，但我仍用手机看到了凌晨 2 点。 那种能疯狂获取新知的感觉和回顾总结自己的所学和积累，也正是我想带给读者朋友们的。 很庆幸，一路走来，初心一直没变。 这一路走来回顾一下这一路走来自己的积累吧，这一路也就是这么成长起来的。 第一阶段：Java 基础刚学 Java 课程，那时候看着网易云课堂的免费视频教程，还有一堆参考书和课本，就这么学了起来： Java学习笔记(0)——了解Java Java学习笔记(1)——搭建好所需要的环境 Java学习笔记(2)——数据类型 …. 第二阶段：Java 进阶基础的知识学完了，在学校图书馆左翻右翻到了一些进阶的书，也饶有兴致的看了起来： 《编写高质量代码》学习笔记(1) 《编写高质量代码》学习笔记(2) 《编写高质量代码》学习笔记(3) … 第三阶段：Java Web然后就跟着开始学习 Java Web 和 Spring 等主流框架了： 初学Java Web(1)——Web概述 Spring学习(1)——快速入门 SpringBoot【快速入门】 … 第四阶段：算法、准备秋招暑假也没有回家，在学校实验室准备秋招，补了一下自己最薄弱的算法和数据结构、还有一些基础的东西： 数据结构与算法(1)——数组与链表 Java I/O不迷茫，一文为您导航！ 【面试必备】手撕代码，你怕不怕？ … 由于秋招不太理想，也渐渐觉得自己想要学习和感兴趣的东西还太多，想要继续学习，于是都快 10 月份了，才 “临时”决定要考研… 第五阶段：工作学习考研遗憾差 2 分，也不愿意调剂，没有缘分就找工作吧，幸好如愿找到了自己满意的工作，自己也为之奋斗了 7 个月，以 “被裁” 告终： Java转Ruby【快速入门】 【吐血推荐】领域驱动设计学习输出 应届生毕业工作 7 个月小结 … 第六阶段：兴趣学习出来之后，基于对”自由”的向往以及对技术”纯粹”的热爱，干脆就自己出来自己干了，也是基于兴趣和爱好学习和输出了起来： 妈妈再也不担心我面试被Redis问得脸都绿了 「MoreThanJava」计算机发展史——从织布机到IBM 《Offer一箩筐》2W字总结面试套路14问——不给例子的教程都是耍流氓！！ … 小结&amp;&amp;收获这一路走来，自己写文章从来都是为了分享知识，希望读者们收获满满的同时，也能够让自己理解的更加深入。 从 18 年开通公众号以来，写文 142 篇，总共收获的粉丝数 6100+： 对比各大快速成长起来的公众号主，我算是末流。 没有特别的运营，也没有很努力的”肝”文章，一切都是兴趣和爱好，虽然有时候也会”眼红”，但这一路以来自己的收获 (粉丝、工作、写书邀约) 已经足够自己开心和满足了。 想说的话文章越来越难写了前一段时间看万维钢老师的《你有你的计划，世界另有计划》，里面有一个关于信息论的讨论： 第一条消息是我胡乱打出来的，第二条则是2017年获得诺贝尔文学奖的石黑一雄的小说《被掩埋的巨人》中的一句话。 请问，哪条消息的“信息量”更大？ 直觉上来说，第二条的信息量更大，因为它好歹是一条信息，而第一条则完全是乱码。 但第二条消息只不过是看起来更有意义而已——信息量更大的其实是第一条。 上面的句子我想你一猜就能知道这句话是“星期天是休息的日子”，这就是说，第二条消息是可压缩的。 第一条消息，哪怕拿掉任何一个字，你都猜不出它是哪个字。 也就是说，一段消息所包含的信息量，并不仅仅由这条消息的长短决定。 这对我「如何写好一篇文章」以及「如何过好这一生」有了一些启迪，特别是我还想为这个世界留下更多的信息。 有一个比较好帮助我做到这一点的观点是：信息就是意外。 譬如如果我在写「MoreThanJava」文集的时候，如果就只是像《xx天快速入门Java》一样，快速的过一遍 Java 的基础语法点，我会觉得我没有做过这件事。 相反我做了一块「编码之前必须了解的东西」这一 part，让读者朋友们能了解计算机一些基础但必要的知识，我觉得这就是意外。 另外，更详细更形象我觉得也是一种”信息意外”。 譬如，在介绍变量的时候，借鉴引入了一张”被撕碎的纸片”，这就使得变量这个”形象”更具体了： 制造这样的”意外”不仅仅需要更加细致的思考，当然也需要更多知识的摄入，越思考这样的事情，我就越难以下笔，写出来的东西也总觉得”差点儿意思”。 所以，对于我来说，有点儿越来越难写文章了。 成体系的知识才有价值假设，两位医生，分别接诊了两个大腿中间的士兵，因为知识体系的分别结果完全不同 (参考出处)： D1 缺乏诊治箭伤的知识体系，脑中只有几点零散的知识，只会头痛医头脚痛医脚，想不到感染、发烧、饮食禁忌等事情，结果他的病人回去后，伤口感染、化脓，引起各种并发症，后来救治无效，含恨离世。 反观 D2，因为有知识体系，能够系统的、多维度的、多环节的考虑各种问题，妥善制定箭伤医治策略，他的病人得到了很好的诊治，很快就痊愈了。 医疗领域的知识体系，可以治病救人，效用立竿见影，其他领域的知识体系同样有这样的效果。 为什么我们看书会觉得有收获，是因为它对某一领域的知识有一个系统的成体系的介绍。 成体系的知识才有价值。 所以反思自己，总是以兴趣为起点写文总是缺乏一些”价值”，对比 JavaGuide、小林Coding、敖丙、帅地 这些吾辈楷模来说，自己的输出缺乏体系。 关于这一点自己也有了一些方向和打算了： 基础是永不过时的，打算自己补一下，也打算肝一下；（Linux/ 操作系统/ 网络/ 编译原理等.. 到时候看什么有意思吧..） 项目也是练手神奇，特别是有一些特别好玩的； (比如上一次在 B 站看到一个一键生成半佛仙人风格视频的脚本) 总之，2021 年，一起 Be Better 吧~","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"程序员考公指南大火？工资和生活，你怎么选？","slug":"程序员考公指南大火？工资和生活，你怎么选？","date":"2021-01-17T09:47:21.000Z","updated":"2021-01-18T02:17:50.607Z","comments":true,"path":"2021/01/17/cheng-xu-yuan-kao-gong-zhi-nan-da-huo-gong-zi-he-sheng-huo-ni-zen-me-xuan/","link":"","permalink":"http://www.wmyskxz.com/2021/01/17/cheng-xu-yuan-kao-gong-zhi-nan-da-huo-gong-zi-he-sheng-huo-ni-zen-me-xuan/","excerpt":"","text":"前言最近拼夕夕接二连三的操作又把互联网打工人 996 的日常推上了风口浪尖之上。 尽管互联网行业仍然是炙手可热、回报颇丰的热门行业，但由于经常熬夜、工作强度大的 BUG 般的生活方式，不少互联网人已经开始寻找新的出路。 近日，在 Github 上就有一份程序员考公指南已冲上热榜，自 1 月 2 日创建仓库以来，已收获 7.7k 的 star。 为什么这届年轻人都去考公务员了？标题取自同名公众号文章 墙里墙外近日，央视发布了 2020 年高考搜索大数据报告，报告显示：10 大热搜专业 8 个跟计算机相关。 一方面是 IT 行业“高薪资，新技术，不拼爹”带来日益激烈的竞争，另一方面是时代环境动荡带来的就业环境的严峻。 2019 年互联网公司迎来一波裁员潮。 据不完全统计，2019 年，京东裁员 8%、滴滴裁员 15%、腾讯裁员 10%、华为停止社招、阿里裁员优酷团队、联通强制提前退休、美团（上海点评技术部）裁员 50%….. 随之而来爆发的疫情更是加剧了互联网的寒冬。(不光是互联网行业) 想要在互联网行业安身的互联网人们似乎除了 “卷”，没有别的选择。 与此同时，体制内的稳定和日益提高的待遇与之形成鲜明的对比：互联网越来越”卷”，公务员越来越”铁”，体制在两者之间横竖了一道显眼的高墙。 “年轻时等着被内卷，年纪大了等着被一脚踢出去，我不想做这样的工具人。” “如果我要在这里安家，就必须维持现在的收入，但，35岁以后怎么办？” 越来越多的不确定性和不安，让越来越多的年轻人又把「公务员」选择在了毕业后的第一份职业。 墙里墙外，风景鲜明。 普通年轻人的希望之前在知乎上看到过一个关于00 后比 90 后少了 4700 万的讨论，里面一个关于普通人的模板令人深刻：(下方是精简版本) 从小到大，标标准准的上学读书，小学、初中、高中到大学毕业，工作生活。 完完全全按照这个社会给年轻人的路，一步一步走过来。 也许是不够努力，也可能天赋不行，考不上双一流，工作普普通通，薪水更是远远不及知乎平均。 但是扪心自问，从小到大，我真没犯什么大错，也没走歪路，就是老师眼中的中等生，家长眼中的乖孩子，典型的普通人模板。 可惜的是，如果只是普通人模板的话，要成家生孩子，压力不是一般的大。 …..(关于房价和孩子的讨论) 说白了，现在的年轻人，都不说孝顺，反哺父母了，能不拖累他们就已经很成功了。(这里说得是没有家人的帮助房价是一道很难靠自己迈过去的坎儿) 很真实也很让人心疼，不说大富大贵，就只是按照社会给普通人的模板活一次，就已经压力这么大这么累了，不禁让我们思考。 为什么人生的道路越走越累呢？ 相比互联网大厂提供可观收入但牺牲个人生活的选择，在国家羽翼的庇护下稳定的工作和生活，似乎又点燃了年轻人的希望。 结尾不得不承认的是，我们身处的时代已然发生了巨变，相比职场上的稳定，更重要的还是找到内心的稳定。 如果是你，你会怎么选择呢？ (本来还想再分享一些观点的，但是一直写感觉写不好就整段删掉了…)","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"理解比特币(4)——实现原理","slug":"理解比特币4","date":"2021-01-05T07:02:12.000Z","updated":"2021-01-05T07:06:29.732Z","comments":true,"path":"2021/01/05/li-jie-bi-te-bi-4/","link":"","permalink":"http://www.wmyskxz.com/2021/01/05/li-jie-bi-te-bi-4/","excerpt":"","text":"Part 0. 前言在前面我们已经了解到了： 比特币 代表了诞生于数字时代的对 货币问题 新的 技术解决方案； 比特币 最大的价值在于 价值存储，是拥有极高存量-增量比的 健全货币； …. 可是这一切是如何通过技术实现的呢？这一篇文章就将 尽可能通俗 地解答这一问题。 Part 1. 从一个例子入手现在假设 A、B、C、D 四个人合租一套房子，因为时常有金钱上的往来，为了省事，他们选择使用客厅的一块白板 用来记账，到月底一起结清： 如果有人调皮，往白板上 凭空写一条记录，例如：A 需要向 C 支付 50，那么月底 A 就会多支付 50，为了避免这样的情况发生，每一条记录后面都需要 本人确认签字： 后来由于账目过多，于是大家决定 转用电脑 来记录，但这样一来 签名成了问题。 一方面在电脑上不方便手写签名，另一方面手写签名也很容易被复制，所以我们需要转换成专门用于电脑的 数字签名。 Part 2. 哈希(hash)算法使用数字签名，我们需要考虑严格的 对应性，也就是说一条签名只能用于指定的记录才行： 例如这里的第一条记录 （A→C 转账 50） 需要严格对应 数字签名 1，不能对应第二条，也不能允许金额变更 (如果金额更改应该是其他的数字签名)。 这样才能对记录的正确性有保证。 可是数字签名如何生成呢？ 这里需要介绍一种被称为 哈希(hash)算法 的工具。 它的作用是能把 任意长度的输入 变成 固定长度的二进制输出。 在比特币的世界中，采用了 SHA-256 算法 来生成数字签名，其中 SHA 是 Secure Hash Algorithm (安全哈希算法) 的简写，256 表示无论输入什么值都会生成一个 256 位的二进制数 (由 0/1 组成)。 并且 相同的输入，总会得到 相同的结果，结果又不能倒推回输入，所以我们可以使用 SHA-256 作为我们的数字签名。 例如，我们把第一条记录用 SHA-256 算法对应生成一条数字签名： 即使是相差一个字、一个点，都会造成最终通过 SHA-256 生成的签名完全不一样，且毫无规律可寻：(这样就能满足一一对应) 所以我们算是解决了对应性的难题： Part 3. 非对称加密但是这样还远远不够，即使一一对应，也不能证明像上述这样生成的数字签名是 本人生成 的，因为 SHA-256 是公开的算法，任何人都能通过它生成数字签名。 如何才能验证是 A 生成的签名而不是 B 生成的呢？ 于是想出了一个办法，这个办法叫 非对称加密。 加密和解密先来解释一下什么叫加密，用大家平时比较喜欢的一串数字来举例： 5201314 是大家比较能知道的意思，但是把每一位数字都 +2 之后变成 7423536 就不那么容易明白了，这个过程就叫 加密，还原的过程则叫 解密。 对称加密和非对称加密像上面例子中那样加密和解密过程一样的 (±2)，我们称之为 对称加密，加密和解密过程不一样的则称之为 非对称加密。 举个例子，假设我们现在需要加密的字符是 520，我们 加密 的方法是把这个数乘以 91，并把结果的最后三位公布出来： 解密 我们当然不能通过除以 91 来完成，而是通过 x11，取出结果后三位来还原： 这是因为 91*11=1001，任何一个三位数乘以 1001 显然后三位是不会变的。 这大概就是 非对称加密的原理 了，只是可能原理更为复杂。 通常，在这个原理被保密的情况下，我们把解密的方法公布到网上，数字 11 就被我们称为 公钥，人人都能知道，人人都能对应还原。 这个用来加密的数字 91 我们称之为 私钥，只有你自己知道。 一组配对的公钥和私钥，也就能解决 可验证 的问题了，因为私钥有且仅有一个与之配对的公钥。 他人可以使用你的公钥加密信息，然后发送给你，你用私钥解密，取出信息。反过来，你也可以用私钥加密信息，别人用你的公钥解开，从而证明这个信息确实是你发出的，且未被篡改，这也就是 数字签名 了。（更详细的介绍请看《什么是数字签名》）。 于是我们又解决了 可验证 问题： Part 4. 去中心化好了，目前我们的账本已经算是可用了，但是整个过程我们是信赖 “电脑” 这个 第三方 的，如果出现什么问题 (比如中毒了)，那就是无可避免的损失。 现在我们的交易大部分都依赖于这样的 第三方，比如银行、支付宝，面对高昂的手续费、繁琐流程以及监管的问题，比特币给出的答案是：去中心化。 在比特币提出时，就说明了比特币是一种完全 点对点 的电子货币系统，也就是说交易就像给某人发电子邮件一样简单，完全不需要借助任何第三方。 (这当然也有缺点在上一篇中我们提到一些——比如违法活动的进行更难追溯和查找) 每一个人 都拥有一个 完整的账本，每个人都是中心，这样即使部分账本存在问题也不会影响。 每一次交易的发生都会把这一次交易的信息公布到网上，每个人 验证成功 之后都会记录到自己的账本中。 比如，A 向 B 支付了 50，那么 A 就会使用自己的 私钥 进行加密然后 广播 到每一个人告诉他们这一消息： 每一个收到的人再使用 A 的 公钥 进行解密验证确实是 A 向 B 支付了 50，并且开始检查自己的账本，开始回溯检查 确保 A 的账户上有 50 用于支付给 B。 如果一切 OK，那么每个人的账本上都记录上了这一条消息。 三个一致性问题每个人都存储 所有 的转账记录，这会存在三个关于 一致性 的问题。 第一个问题是：如何进行同步？ 因为整个系统运行在网络，有的计算机可能会处于 “离线” 的状态，但交易时刻都在发生，这就会出现账本不一致的情况，如何才能保证不同计算机之间数据之间的数据同步问题呢？ 第二个问题是：如何防止记录被篡改？ 例如黑客可能篡改网络中某些账本中的部分数据，导致账目不一致甚至冲突的情况发生，最终比特币网络崩坏，如何才能保证数据不会被恶意篡改呢？ 第三个问题是：如何防止同一笔比特币收入被重复使用？ 之前看到有人问：如果在 ATM 机跟支付宝中同时转走账户剩余的钱，那么是不是会凭空多出一笔？ 当然不会，因为 银行 这样的 第三方机构 会帮你做出决定：先转走哪一笔那么另一笔就会失效。 可是比特币网络中，由于有些人先收到消息有些人后收到消息，那么究竟使用哪一条消息为准，又如何防止 “凭空多出一笔” 这样的事情发生呢？ Part 5. 区块链上述的一致性问题，比特币世界采用 区块链 的方式来解决。 区块链 = 区块 + 链在比特币世界中，大约每 10 分钟会结算一次这 10 分钟以来的交易记录并输出一个新的 “账本”： 这些 “账本” 当然不是交易记录的 简单复合，而是包括了：前一个 “账本” 是哪一个、前一个 “账本” 所有数据计算出的 Hash 值等等信息的 复杂数据体。 这样我们既能通过简单的验证保证 数据的正确性，又能把所有的 “账本” 都 串联 起来： 好了，换个名字，区块链有了： 辽宁沈阳一小区大门上，66 把锁串联在一起，被誉为 “最便宜的门禁系统”，也号称 “区块链实体化” 技术… 新区块由 “矿工” 生成比特币网络中每一个新区块都由 “矿工” 生成，它们会 逐条检查每一条记录 是否符合要求，例如每一条记录是否有正确的数字签名、支付是否合理等。 然后将验证完之后的比特币交易记录添加到自己正在制作的 新区块 中，制作完成就马上发送到比特币网络中的每一个节点。 节点收到这个新区块的信息，如果验证之后符合要求，就添加到目前 区块链的末尾。 那么问题来了，比特币网络有许许多多的 “矿工”，这也意味着这可能会 同一时间 内能生成很多 基本信息大致相同 的 “新区块”。 虽然这些 “新区块” 中大致都是近期内验证好的交易记录，但是每个区块具体包含哪些交易记录，可能各不相同。 比特币网络只能认可维护 同一条区块链，比特币网络上的 每个节点 都必须选择 同一个新区块 添加到末尾，但是这又很难制定一个统一的选择标准。 POW(Proof Of Work)工作量证明比特币世界解决方法是：采用一个巧妙的方法限制单位时间内生成的新区块的数量。 如果每过 10 分钟左右的时间，整个比特币世界只有 一个 “矿工” 能够生成 一个 新区块，那么也就不用再进行选择，区块链也将添加唯一一个新区块到末尾。 这个巧妙的方法就是：当 “矿工” 完成新区块的验证打包之后，还需要做一个 额外的工作 才能把生成的区块发布到网络上。 额外工作的整个过程可以分为 2 步： 将新制作区块所包含的 内容（前一个区块所有内容的 SHA-256 函数值 + 新区块基本信息 + 新区块所包含所有交易记录）组合成一个 字符串； 在这个字符串的末尾添加一个 随机数，组成新字符串； 只有当这个新组成的字符串通过 SHA-256 算法得到的 256 位二进制数的前 72 位 全是 0，才算成功完成了这个额外的工作。 这个额外工作的难度非常高 (前 72 位为 0 的概率为 1 / 272)，高到整个比特币网络大约 10 分钟时间也只有一个 “矿工” 能够 找到这个随机数。 原因就在于 SHA-256 函数的特点是：虽然每个输入值都对应一个输出值，但是这 256 位二进制数完全随机没有规律。 找到这个满足条件的随机数的 唯一方法 就是 以最快的速度输入不同的随机数不停地试。 当 “矿工” 找到这个随机数之后，会将这个 随机数打包进当前区块 然后打包发布到比特币网络，所有节点就可以根据这个随机数和新区块的基本信息 快速验证 是否符合要求。 虽然找到这个 随机数 完全靠运气，但矿工的运算能力越强，这个运气就会越好，这也是 “矿工” 们不断升级设备的原因。 矿工激励机制是什么支持着 “矿工” 们不停升级自己的设备去打包新的区块呢？ 在比特币世界里，每成功打包一个新区块，就会奖励给 “矿工” 一定数量的比特币，最初是 50 个，每产生 21 万区块 (也就是大约 4 年时间)，奖励就会减半，2020 年这一奖励已降至 6.25 比特币。 另外当前区块中所有交易产生的交易费也归 “矿工” 所有。 拿 2017 年举例，每打包一个区块会得到 12.5 比特币的奖励，交易产生的交易费大约是 2 比特币 (参照上图)，也就是总收入约 14.5 比特币。 按照 2017 年 12 月 16 日的行情，这大约值 26 万美元，即 170 万人民币。 换句话说，一个运气好的矿工，10 分钟左右，就能产生 170 万的收入。 工作难度调整 巨大的经济利益带来的是挖矿设备的不断升级，这也导致了整个比特币网络计算能力的提高。 为了维持平均 10 分钟生成一个区块的速度，比特币网络会每 2 个星期调整一次工作难度。 例如从前 72 位为 0 调整为前 73 位，难度也是几何级的增加。 一致性问题回顾好了，我们来回顾一下区块链是如何解决上面提到过的一致性问题的。 如何进行同步？比特币网络仅仅维护网络中唯一一条 最长的区块链，所以不论是新加入的节点还是需要同步的节点，都以此为准。 很容易知道，即使 “矿工” 有了 额外的工作 需要做，但仍然会发生 两个区块同时发布 到网络上的情况。 此时网络上一部分节点先接受到 A 的区块，另一部分接受到 B 的区块。 此时两个区块都不丢弃，直到下一个区块 C 产生，由于 额外的工作 不会凑巧得又有两个新区块同时产生，此时 C 区块前面的区块是 A 那么整个区块链网络就接受 A 这一条，反之则接受 B。 这时候 A 区块中未被打包的交易记录又会被丢到网络中等待打包。 就算很凑巧仍然有区块同时被打包在 A 和 B 区块的后面，那么继续等待 最长链 的产生就好了。 通常来说，正常的交易被区块链接受后，后面再接上 2-3 个区块就能确保已经被区块链完全接受了，大一点的交易则等待 3-6 个区块。 如此就保证了网络中 仅有一条唯一的长链 产生，所有的节点都以此为准。 如何防止篡改在 额外工作 中我们提及到，每一个区块都带有 上一个区块所有交易信息 的 SHA-256 的值，区块由此链接起来： 即使是很微小的改动，也会导致该区块的 SHA-256 值不一致，导致后续链接的区块断裂： 由于区块链只维护一条最长链，所以只有当篡改者拥有的计算能力超过 整个网络中其他节点的计算能力的总和 时，才能通过不断完成 额外工作 添加新区块的方式，使当前修改的区块成为最长链。 区块链的参与者越多，这一难度越大。 就算有人成功地篡改了交易记录，他也不大可能得到任何好处，因为由于他的攻击，比特币网络的价值会大幅下跌，乃至归零。 换句话说，为了摧毁比特币，攻击者需要付出极大的成本，却不会得到任何回报。 算力的分散、代码的强抗更改性、稳如山的货币政策，是比特币存活下来并成长到今天这个规模的原因。 如何防止同一笔比特币收入被重复使用区块链中的每一条交易记录都记录了完整的 代码可追溯 的流转信息。 在打包新区块的时候，如果发现交易记录的 上一笔交易 已经出现在了 之前的区块 中，那么就会 放弃掉 该记录； 如果 同一个区块 中出现了 两笔来源相同 的记录，那么也只会 选择其中一条 进行记录。 总结好了，到目前为止我们已经把比特币使用的技术和相关知识都通俗的讲述了一遍，不知道小伙伴们有没有真的理解比特币呢？ 现在来对主要技术和特点做一下总结： 利用 SHA-256 算法 和 非对称加密 来制作 数字签名； 利用 区块链 中的区块存储比特币交易记录； 设置 额外工作 从而控制单位时间内生成区块的个数，同时保护比特币网络； 将一定数额的比特币和区块内的所有交易费奖励，用于成功生成该区块的矿工奖励，激励 更多矿工加入比特币网络，促使比特币网络茁壮成长； 比忒不转账不依赖银行或其他金融机构； 比特币网络内比特币的总量不会超过 2100 万。 （完）","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://www.wmyskxz.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"}],"author":"我没有三颗心脏"},{"title":"理解比特币(3)——其他优势","slug":"理解比特币3","date":"2021-01-03T23:24:40.000Z","updated":"2021-01-03T23:36:30.302Z","comments":true,"path":"2021/01/04/li-jie-bi-te-bi-3/","link":"","permalink":"http://www.wmyskxz.com/2021/01/04/li-jie-bi-te-bi-3/","excerpt":"","text":"优势一：个体主权上一篇我们说明了比特币的最大优势是 价值存储，比特币严格的数字稀缺性既体现了实物货币的优点，又没有实物货币难以移动和运输的缺陷。 所以或许可以说，比特币是有史以来人类发明的最好的价值存储技术。 作为首个 电子现金，比特币最重要的 价值主张 是，让 每个人 都获得对自己货币的 绝对主权。 换句话说也就是 没有任何组织和政府 能够创造更多的比特币，对”比特币世界”横加干预。 在 20 世纪，政府可以通过中央银行 肆意创造货币，从而使个人的生存和幸福完全依赖政府，比特币孜孜以求的就是纠正这种 权力失衡。 历史上的健全货币——黄金，无法做到这一点，黄金的物质性使其易受政府控制。 黄金无法轻易转移，意味着使用黄金的支付行为不得不通过银行和中央银行集中完成，也意味着政府容易将其没收征用。 与黄金不同，任何人都可以通过任何联网设备免费访问比特币交易账本，验证比特币交易是件区区小事而且几乎没有成本。 并且比特币的价值不依赖于任何地方的任何实体，因此永远不会被任何实体力量完全阻碍、摧毁或没收。 对于 21 世纪的政治现实来说，这项发明的 意义 在于，自现代国家诞生以来，个体第一次 拥有了清晰可行的技术工具，可以 摆脱政府 对 个人生活 施加的 金融影响。 优势二：国际和网上清算 随着各国政府 没收黄金 并 发行各自的货币，个人之间 和 银行之间 的 全球结算 不再可能通过黄金来完成，转而通过价值不停波动的 国家货币 来完成，造成了严重的 国际贸易问题。 比特币的发明 从根本上 创造了一种新的独立的国际结算替代机制，它不依赖于任何中介，可以完全独立于现有的金融基础设施运行。 任何人都可以在不经他人的许可、不暴露自己身份的情况下，运行节点，发送自己的比特币，这是 黄金 和 比特币 之间的 重大区别。 比特币并非只能存储在电脑上——某人的比特币对应的私钥是他记下来的一串字符或一串单词。带着比特币私钥四处走动要比带着一堆黄金容易得多，将它发送到全世界也容易得多，而且还没有被盗或被没收的风险。 使用黄金的时候，政府可以没收人们的黄金储蓄，迫使人们用据称是由黄金背书的纸币，若是使用比特币，人们能够将自己的大部分比特币储蓄存放在不受政府控制的地方，只留下少量的钱用于中介支付。 不过也正是因为比特币 匿名、不受政府管控 的特点，也造成了比特币被用来进行一些非法活动——例如洗黑钱 另外，由于数字现金的特性，比特币的 相对优势 可能不在于 取代现金支付，而在于允许在 超远距离 上实现现金支付。 小额的个人支付可以通过多种方式进行：实物现金、以货易货、互助减免、信用卡、银行支票等。目前的支付结算技术已经为小额支付提供了多种低成本的选择。 比特币的优势可能不在于与这些小额、短距离的支付方式竞争。 更确切地说，比特币的 优势 在于，它将现金结算带入了数字世界，为 跨境、长距离的大额支付 创造了最快的最终结算方式。这种场景下比特币的优势是最为显著的。 优势三：全球记账单位 尽管比特币的野心不太可能在短期内尽数实现，但它特殊的性质还是令人着迷。 自金本位时代结束以来，全球贸易一直由于不同国家货币的价值不同而备受阻碍，这破坏了人们使用 单一交易中介 进行间接交换的能力。 相反，庞杂的政府货币体系创造了这样的世界：若要 跨境 购买商品，必须事先购入生产者的货币。 几乎是在 模拟以物易物，这严重阻碍了人们进行经济核算的能力，并催生了一个庞大的 外汇行业——该行业除了缓和货币国家主义带来的可怕后果之外，几乎没有任何价值。 金本位制 曾是这个问题的解决方案，在金本位制下，有一个独立于任何政府或当局控制的单一货币形式，它是全世界的货币标准。 全世界的价格都根据 黄金 进行校准，并用黄金表示，从而可以很方便地进行跨境经济核算。 然而，黄金的物理性质意味着它只能集中在一起，在中央银行之间进行结算。一旦黄金被集中托管，对于控制了黄金的政府来说，就成了不可抗拒的诱惑。 最终，政府法定货币取代了黄金，健全货币变得不健全。 比特币是否会成为全球贸易和经济活动的记账单位，目前还是一个有争议的话题。实现这一点的前提是，比特币被 非常非常多 的人接受。 虽然随着比特币的市场价值和交易费用的持续增长，它开始变得越来越像 储备货币，而不是日常使用和交易的货币，购买比特币也通常被视为一种 投资。 但是如果比特币占据了全球市场货币供给和国际结算交易的主要份额，那么比特币的需求水平将变得更加稳定和可预测，从而导致比特币的价值趋于稳定。 一旦达成某种形式的价值稳定，比特币就将在全球支付清算方面优于国家货币。 今天，国家货币的价值会因为不同国家和政府的状况发生波动，将某种国家货币广泛用作全球储备货币，导致的结果是，发行储备货币的国家拥有“过度特权”。 国际结算货币 应该 中立 于各国的货币政策，黄金在国际金本位时期就出色地扮演了这个角色。 要扮演这一角色，比特币比黄金更有优势，因为它的结算可以在几分钟内完成，而且交易的真实性可以被任何人通过互联网轻松验证，几乎没有成本。 而且黄金转移需要更长的时间，清算依赖负责结算和转移黄金的不同信任程度的中介机构。 因此，在面对面 现金交易 的场景中，黄金的货币角色或许尚能保留，而在 国际结算 场景中，比特币将独领风骚。 End好了，关于比特币的优势，我们几乎已经阐述得很清楚了，总结起来大概就是： 价值存储 个体主权 国际和网上清算 全球记账单位 事实上，比特币也拥有非比寻常的 安全性，我们将在下一篇讲解具体的原理的时候，更能看到这一点。 不知道您对于 比特币为什么如此大涨 这个问题的答案是否有一定见解了呢。 就这个问题我给出一下自己的答案 作为参考 吧： 比特币是一种能够 真实进行交易 的数字货币；(这很重要) 比特币拥有独有的 数字稀缺性 和 跨境支付便利性；(对比黄金) 比特币是一种通货紧缩的电子货币，是一种很好的 储存价值 工具，用作投资或对抗通过膨胀；(这一点有点儿类似于茅台股票) ….. (说明：本篇大部分内容摘录自《货币未来：从金本位到区块链》) (END)","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://www.wmyskxz.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"}],"author":"我没有三颗心脏"},{"title":"2020年终总结","slug":"2020年终总结","date":"2020-12-31T13:12:11.000Z","updated":"2020-12-31T13:12:58.328Z","comments":true,"path":"2020/12/31/2020-nian-zhong-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/12/31/2020-nian-zhong-zong-jie/","excerpt":"","text":"Part 1. 回顾还记得新年第一天，我在刚租的房子给自己做了一顿咖喱饭🍛 (不好意思放照片…)，然后回顾并展望了一下自己的 2020。 转眼间，2020 就过去了。 总的来说，今年小目标 (比如博客 10 w 访问量) 完成得不错，但大方向上因为自己的 “贪玩” 有些没跟上。 如果给今年一个 关键词 的话，那么就是：迷茫。 今年我没有工作，当着 MC 的自由开发者，开发着 自己的组件。 一点一点看着自己的想法在另一个”平行世界”实现，还是挺有成就感的，特别是还有人愿意为此”买单”。 有一天迸发了一个灵感，我花了 两个小时 实现了 (特别简单一个东西)，后来靠着这个组件陆续进账了快 2w (这比我花一个月制作的大型组件还卖得好)。 这让我明白了两件事，一是我进入了一个 创意优先 的环境，努力和技术都显得不那么重要；二是这个完全不同的赛道让我第一次感知到了 世界的多样性，让我开始重新审视起自己过去的工作和生活，追求和选择，我感到前所未有的迷茫。 跨越了生存问题，没有工作和生活各方面的束缚，我开始思考自己真正享受什么，喜欢什么，究竟想要怎么样活。 享受写完文章发表的舒心就认真交付每一篇文章，不喜欢假装热闹的聚会就礼貌拒绝每一次邀约。 坦诚的面对自己内心的声音，开始学着接受自己，有被讨厌的勇气，大概是今年最主要的 成长 吧。 但 遗憾 的是，今年 “得” 的很多时间，我也没有很好的利用起来 (特别是后两个月，几乎都在玩儿..)，自己的生活也没有照顾得很满意。 生活实录 从 1 月 1 日起，有记录的日子有 179 天，其中仅仅早起 (6 点之前起床) 了 84 天，但晚睡 (超过 12 点) 却不仅仅记录的 77 天。 只有 年中稍微自律些。 心情实录 大部分的日子都是挺开心的 (没心没肺地开心)，也有一些颓废的时候，也有一些伤心的时候 (塞班——领养的猫——去喵星了)。 看过的书 今年 最成功 的就是养成了 阅读的习惯，以前书对我来说是奢侈品，买来几乎就给 “供” 起来了，到今天整理也才发现我居然一年也能看 20+ 了。 最开始看书是觉得自己浅薄应该看点儿书，现在越来越多的是带着问题和兴趣去看。 不得不说 得到电子书会员 是一个很好的 找答案 的工具，特别安利一下。 最近看到杨绛先生说的一句话也分享一下： 年轻的时候以为不读书不足以了解人生，直到后来才发现，如果不了解人生，是读不懂书的。读书的意义大概就是用生活所感去读书，用读书所得去生活吧。 写过的字 “学而不思则罔，思而不学则殆”，所以也尝试着把自己的所思所想输出了一些： 【人类观察所】”当代人”正经历的生活 - 02/22 “长辈牌”电子产品：有一种评论朋友圈叫给你打电话 - 03/10 96年/离职8个月/拒绝华为offer/目前自由职业-记这大半年来的挣扎与迷茫 - 07/26 你记笔记吗？关于最近知识管理工具革新潮心脏有话要说 - 08/16 谈谈近况，谈谈自由职业，谈谈”金饭碗” - 12/09 理解比特币(1)——货币以及货币发展史 - 12/18 理解比特币(2)——最大优势是价值存储 - 12/23 技术方面因为逃离了一线的开发环境，所以也只有尝试输出一些自己觉得有帮助的文章： 《Offer一箩筐》2W字总结面试套路14问——不给例子的教程都是耍流氓！！ - 12/09 一文带你深扒ClassLoader内核，揭开它的神秘面纱！ - 08/28 计算机发展史—从织布机到IBM - 04/07 …. 好的方面 是自己没有「为了输出而输出」，写的都是自己想写的，也没有水文，保证了每一篇的质量。 坏的方面 是没有「认真地输出」，10 月份开始自己就松懈了下来，并且形成了一种惯性。 走过的路前半年的总结基本上都写在了这里：传送门，简单回顾一下今年走过的路吧： 1 月，拒绝薪资翻倍的华为第三方 Offer，选择当一名 MC (我的世界) 开发者； 2 月，疫情在家，接了一个小程序外包项目； 3 月，学习 Redis 和 Python，参与 MC (我的世界) 季度 Mod 开发； 4 月，MoreThanJava 系列开篇； 5 月，全身心投入开发自认为卖爆的组件； 6 月，组件平平淡淡，恢复了博客输出； 7 月，参加了 MC 创作大师赛； 8 月，怼文章跟尝试不同方向的组件，初有成就； 9 月，做了两个大组件，挣了些钱，想要休息一段时间； 10 月，旅游了两次，参加了 MC 开发者大会； 11 月，休息成了惯性； 12 月，做了一个大组件，惯性 x2； Part 2. 展望 如果 100 是满分，我给自己的 2020 打 60 及格分吧。 今年能够平稳跨越生存难题，并且在这一年的迷茫和挣扎中渐渐有了一些自己想要去做的事情，我觉得还挺成功的。 明年想要做更多自己觉得有价值的事：比如输出一系列成体系的文章 (我越发觉得成体系的知识才能发挥更大价值)。 (其实有很多聊的想说的，但是怕聊不清楚都删了..就到这里吧..) 最后用一个心血来潮写的歌曲来做个结尾吧：(见笑啦…) 链接戳这里 希望你我都能够奔赴在路上吧… (END)","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"理解比特币(2)——最大优势是价值存储","slug":"理解比特币2","date":"2020-12-23T05:58:41.000Z","updated":"2021-01-03T23:36:22.565Z","comments":true,"path":"2020/12/23/li-jie-bi-te-bi-2/","link":"","permalink":"http://www.wmyskxz.com/2020/12/23/li-jie-bi-te-bi-2/","excerpt":"","text":"最大优势：价值存储在上一篇我们讲到了货币的一些基本职能以及整个货币的发展史。 几乎全世界的法币都与”美元”——这个用美国国家信誉做担保的法币——绑定在了一起。 自 2020 年 2 月份 COVID-19 疫情在全球爆发以来，世界主要国家几乎都开始了印钞比赛，当然谁也比不上美国 为什么美国一印钞其他国家必须跟着印呢？从 1 月底到现在，美联储的资产负债表扩张了超过 3 万亿美元，看看美联储资产负债表扩张的速度，就知道印钞的速度有多吓人了。 因为美元是世界货币，这种印钞方式，差不多相当于让全世界 75 亿人每人都必须出血 400 美元，来救助疫情中的美国企业和个人。 全世界的羊毛是怎样被薅下来的呢？ 假设全世界实物商品的产能是 50 个蛋糕，对应市面上的货币是 50 美元。 50 个蛋糕对应 50 美元，自然每个蛋糕价值就是 1 美元。 后来通过国际贸易往来，各国也开始拥有自己的外汇储备，那么市面上的 50 美元就差不多分散到各国。 这时候 假设中国、法国、德国、英国、美国各有 10 美元，总数依然是 50 美元。 如果美国突然又印了 50 美元，等于全球美元总量突然翻倍了，实物商品产能却没变化。 50 个蛋糕对应市面上的 100 美元，美元的 购买力自然会下降 了，等于 2 美元才能买到 1 个市面上的蛋糕。 蛋糕涨价了，之前各国能买 10 个蛋糕的外汇储备现在只能买到 5 个，这等于通过印钞直接从其他 4 个国家分别掠夺了 5 个蛋糕，凭空抢走 了 20 个 蛋糕的实物资产，羊毛就这么被薅走了。 所以我们也就不得不跟着印钞——你给货币注水那我也注水，大家都注水损失相对少一点。 中国房地产为何”疯涨”又停上面的例子说明了很多方面的问题，但是对于个人而言的启发是：如果你有钱，最好别只是”有钱”。 (30 年前你可以靠大量现金存银行收利息过得很好，可是 30 年后你会非常惨——因为钱越来越不值钱) 中国人在这方面一直做得不错，事实上，国家掌握货币发行权以来，政府的能力 被 无限放大 了。 无论是贪污浪费、银行不良贷款、地方政府债务、养老金黑洞等等一切问题，只需要多印钞票就好了。 按常理来说，大幅度印钞最大的顾忌就是会产生 通货膨胀。 中国过往如此多的货币发行，为什么还是没看到国内出现严重的通货膨胀呢？ 关键的所在是房地产。 我们只要印出一块钱来，无论这个钱是首先流到老百姓还是政府贪官手上，都被用来推高房地产价格了。 买房买安全感买保障的习惯，也很大程度上 延迟了 中国通货膨胀的速度——买房能固化一部分资产并弱化负债。 但是现在随着房子不再”稀缺”，以及国家的调控，连 36氪 也出过一期视频介绍说明现在房子已经错过了投资的最佳时机——可能还不如买基金收益高。 作为一个普通人，我们也不能完全依赖现有的银行体系，我们需要保持资产的多样化。 如何跨越时间存储自己生产出来的价值面对时间，人类的永恒困境是，如何存储自己生产出来的价值。 无论是购房 (刚需房除外) 还是购买理财产品，我们都希望能最大程度的固化自己的资产——至少不至于贬值。 在现代经济中，随着货币通胀不断发展，很多经济泡沫都可以理解为，人们为了寻找更好的价值存储载体，病急乱投医。 由于黄金独特的化学属性，没有人能够 随意增加 黄金的 供给，因此在人类历史上，只有黄金近似地解决了 价值存储 的问题，也给人类带来了一段黄金时代。 但是，随着政府对黄金的控制，黄金的货币角色很快受到限制，政府代之以自己发行的纸币，这种纸币的表现记录非常糟糕。 以上讨论反射出比特币这项技术成就惊人的光彩。人类有史以来 第一次 拥有了一种 供给受到严格限制 的 商品。 无论多少人使用这个网络，无论币价上涨多高，无论矿机如何进步，比特币的总量都永远是 2100 万。 需求增加的时候，不可能额外增加任何供给。如果有更多的人想持有比特币，唯一的办法就是让比特币升值，刺激现在的持币者出售一些。 由于每个比特币可以被分成 1 亿聪，随着比特币的升值，人们有足够的空间采用更小的记账单位。 因此，比特币是非常适合承担价值存储角色的新型资产。 在比特币发明以前，对所有的货币形式来说，它们的数量都是无限的，因此，长期保值方面都不完美。 比特币不可更改的货币供给政策使它成为储存有限人类时间创造的财富的最佳载体，也可以说，比特币是人类有史以来发明的最好的价值存储工具。 换句话说，比特币是购买未来的最好方式，因为无论未来升值多少，只有比特币拥有不被劣化的保证。 从上图我们可以看出，在 2025 年比特币的存量/年产量将是黄金的差不多两倍——这意味着届时比特币将会是比黄金”硬”两倍的货币，并且随着比特币开采难度不断增加，比特币将会越来越”硬”。 并且与其他 供给容易增加的货币 更加不同的是，作为一种 货币媒介，比特币只会吸引相对较少的人类时间和努力，更多的人类时间和努力会转而从事更有用的经济生产活动，这些经济生产活动创造的价值可用于兑换比特币。 在绝大多数人类历史上，被用作价值存储载体的都是一些实物。 价值存储本身并不一定依赖实体，但实体可以增加供给膨胀的难度。比特币纯粹以数字形态存在，达成了 严格的稀缺性。 在此之前，任何货币的可分割性和便携性都未曾达到比特币的水平。 比特币让人类能够以数字的形式转移价值，完全不依赖于物理世界，这样，世界各地的大额价值传递可以在几分钟内完成。 总结从上面我们了解到，比特币严格的数字稀缺性既体现了实物货币的优点，又没有实物货币难以移动和运输的缺陷。 或许可以说，比特币是有史以来人类发明的最好的价值存储技术。 但是我们也发现，在比特币的世界根本不存在通货膨胀，当你拥有比特币你会去把它当成货币使用吗？这也正是阮一峰大大提出的：没有人会使用比特币！因为持有者只要一直持有，就能享受价格的不断上涨。 关于比特币不可扩展的缺点，也是争论最多的。 好了，本篇已经够长了，比特币其他的优势我们下一篇再讲。","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://www.wmyskxz.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"}],"author":"我没有三颗心脏"},{"title":"理解比特币(1)——货币以及货币发展史","slug":"理解比特币1","date":"2020-12-18T11:33:45.000Z","updated":"2021-01-03T23:36:17.724Z","comments":true,"path":"2020/12/18/li-jie-bi-te-bi-1/","link":"","permalink":"http://www.wmyskxz.com/2020/12/18/li-jie-bi-te-bi-1/","excerpt":"","text":"Part 1. 比特币简介比特币的诞生2008 年爆发全球金融危机。 图片来源：http://cnpolitics.org/2014/12/capitalizing-on-crisis/ 同年的 11 月 1 日，一个自称 中本聪 的人在 P2P foundation 网站上发布了比特币白皮书《比特币：一种点对点的电子现金系统》，陈述了他对电子货币的新设想——比特币就此面世。 从 2009 年 1 月 3 日正式运行起，从最开始只有少数几个人参与的小项目，到如今 市值 2 万 3 千亿人民币，也仅仅过去 11 年。 有人说，如果在 10 年前花 10 万购买比特币，那么现在也有千亿资产了，都能把马云、王健林、马化腾等一众富豪抛之脑后。 为什么现在比特币这么值钱？这短短十一年间到底发生了什么？ 这些问题的答案无不回到一个最基础最根本的问题上——比特币是什么？ 比特币是什么？ 简单来说，比特币是一种 虚拟货币。 从另一个角度来说，比特币也是一种数字时代的 新技术，它同车轮、电话或者任何技术存在的原因相同：能够让它的用户受益。 (简单来说) 它解决的是人类社会亘古存在的老问题：如何让经济价值跨越时间和空间流动。 要想彻底理解比特币，我们需要从源头开始——理解什么是「货币」。 Part 2. 理解货币第一职能——交易中介最简单的价值交换方式就是 “以物易物”。 但这仅仅在 产品和服务都很有限 的 小群体 之间，是可行的。 一旦经济体超过一定复杂度，专业化的分工以及庞大的市场，会让 需求耦合 的问题暴露得更加彻底——可能你需要对方的东西，但对方不需要你的东西。 这个问题不仅仅是商品需求不匹配这么简单，它有三个层次。 第一是 价值尺度 上不匹配，想象一下用鞋换房子，你既不可能只换取房子中的一块砖，房主也很难收下与整个房子价值相匹配的一大堆鞋子。 第二是 时间 上不匹配，譬如你很难攒够足够的苹果去换一辆车子——因为苹果在交易完成前可能就该腐烂了。 第三是 空间 上不匹配，你可能想在一个地方售出房子而在另一个地方购买房子，但是房子根本没有便携性。 解决上述问题的唯一办法就是间接地以物易物：使用人们 广泛接受 的单一的 (或少数几种) 用作 交易中介 的 商品。 交易中介 是货币之所以成为货币最重要的功能。 也并没有什么原则来界定什么可以什么不可以称为货币。 在人类的历史上，很多东西都承担过货币的角色，除了最著名的 黄金 和 白银，还有铜、贝壳、大石头、盐、牲畜、政府债券、宝石等等… 甚至在某些特定的环境下，酒精和香烟 (例如监狱) 都可以充当货币来使用。 能够在交易中充当中间介质的东西，就是货币。 第二职能——价值存储货币除了能够充当交易的中间介质，还需要有 价值存储 的功能——对应上面说的时间上的适销性——也就是能够帮助人们存储财富。 假设我是一个偏僻小岛的果农，这个小岛与世隔绝，贝壳是小岛上少有固定的材料，于是我们约定使用贝壳作为货币。 假设正常情况下，我每一年的收成大概能够换到 200 个贝壳。 可是今年当我换了 200 个贝壳之后，人们发现邻边的小岛上能够有几率找到贝壳，这相当于是在 “捡钱” 啊！ 于是越来越多人加入了这个 “出海” 的行列，于是市面上的贝壳就变多了， 所以物品交易时，贝壳的价值变低了——因为大家都知道贝壳来得相对容易了一些，之前卖 2 个贝壳的现在可能就要 5 个。 所以表面上看是 物价上涨 了，但其实是贝壳的价值变低了——而对于我这个已经用劳动换取贝壳的人来说，我的 财富缩水 了。 这一现象叫做 “软通货陷阱”：任何物品，一旦被用作价值存储的载体，都会带来供给的增加；任何供给可以轻易大量增加的物品，一旦被选择成为价值存储的载体，都会毁灭存储者的财富。 (软通货：增加供给难度不那么高的货币) 一切都是因为获取贝壳太容易了——开条船出去找就行了。 因此，任何物品要 承担货币 的角色，它的 生产成本 必须 很高，否则生产者赚快钱的诱惑将摧毁储蓄者的财富，人们在这种货币环境中，存储的动机也会被摧毁殆尽。 而一旦这些充当货币的贝壳失去了本该有的硬度，它们的持有者就会遭受严重的财产蒸发，整个社会结构也会因此分崩离析。 于是，随着人类生产的技术能力不断进步，金属和商品的使用也开始不断增加，在长期的货币竞争中，黄金凭借其 稳定的物理和化学特性，以及 稳定 的 低供给率，在货币市场中终于是拔得头筹。(下面会详细说) 第三职能——记账单位在最开始我们的小岛上，大家都是能认同贝壳作为货币的，这并不是因为贝壳本身的性质，而是因为它的 适销性。 只有用 统一的交易中介 做 记账单位，复杂的经济核算才有可能实现，才会有随之而来的复杂生产的专业化分工、资本积累和大型市场的形成。 市场经济的运作依赖于价格。 准确地说，价格依赖于一种共同的交易中介，反映不同商品的 相对稀缺性。 如果是在一个没有公认的交易中介的经济环境中，那么每一次交易的商品都不得不以彼此的价格来定价，这就将出现海量的价格，导致经济核算困难。 所以作为货币的物品需要有广泛的接受度才行。 Part 3. 从贝壳到政府货币上面👆，我们简单理解了作为货币需要： 能够承担 交易中介； 能够 存储价值； 能够作为统一的 记账单位； 货币发展简史在货币发展史上，多种商品扮演过货币的角色，它们的 硬度 和 健全程度 各不相同，这取决于每个时代的技术能力。 比如最早开始的贝壳，海边的人明显比内陆的人更容易获得，所以很快，贝壳以及使用类似软通货作为货币的金融体系就崩溃了。 随着生产力的发展，人们急需一种能够通用的货币，并且这种货币必须难以获得、不容易损坏腐烂、能够易于分割便于支付各种大小金额的支付。 经过多次尝试之后，最后全世界几乎所有的文明都不约而同地选择了两种金属作为货币：黄金 和 白银。 但是黄金和白银的数量毕竟稀少，随着生产力的不断发展，物资越来越丰富，黄金和白银不够使用，人类历史上第一次通货紧缩，钱不够了！——于是由政府出面，用其他金属铸造货币，铜钱出现。 铜钱是人类历史上的第一次代币，永恒的货币只有黄金和白银。 后来随着生产力的持续发达，人们进行交易的时候需要大量的铜钱，特别是远程交易的时候。 比如，内陆的人去海边买盐，西北的人去江南买茶，都需要带大量货币前往，既辛苦又不安全，于是出现了最早的纸币——交子。 最早的纸币并不是政府 (中央银行) 发行的，而是由钱庄发行的，也就是早期的商业银行，你要带货币去远方，那么把货币存在当地的钱庄，钱庄给你一张凭证，你拿着凭证去目的地换成货币。 人们很快发现，其实也不需要换成货币，只要拿着凭证就可以交易了，对方拿着凭证去钱庄换钱也是一样的，而对方也是要拿着货币交易，所以也可以不用去兑换货币，于是市面上就流通了大量的钱庄的凭证。 后来政府发现，既然钱庄可以印凭证，我也可以，我比钱庄还有信誉，于是政府开始印制凭证，于是人类最早的纸币出现，时间是一千多年前，中国宋朝。 纸币是人类历史上的第二次代币。 人们之所以相信 纸币，是因为相信手里的纸币 对应 着 国库里的金银，然而政府发现，只要自己不断印刷纸币，自己就有源源不断的钱可以花，于是就失去控制了。 人类历史上第一次出现了 通货膨胀，纸币崩溃了。 二次大战后，各国政府为了保证纸币不崩溃，基本都跟黄金挂钩，国库有多少黄金，就印刷多少纸币，于是跟原始社会一样，又出现 通货紧缩，钱不够用了。 上世纪 50 年代，美国政府决定，纸币和黄金脱钩，美联储根据市场需求决定印刷多少纸币。美国政府用自己的的经济、军事、政治实力为美元做保证。 其他国家也纷纷宣布纸币和黄金脱钩，但是如何保证自己印刷的纸币值得信赖呢，于是又纷纷和美元挂钩，和美元保持一个稳定的汇率，比如人民币，最近几十年和美元的汇率基本上在 6 左右波动。 于是现在全世界的货币就都和美国的印钞机连在了一起，全世界人民的劳动和财产的价值都是美联储说了算。 货币就这样从贝壳到食盐、牲畜、白银、黄金和以黄金背书的政府货币，终于发展到了目前几乎全球统一的货币形态——政府发行的法定货币 (也称为 “法币”)。 政府货币的历年表现从理论上讲，创造一种 人为稀缺 的资产并赋予它货币的角色，是可能的。 世界各国政府在放弃金本位后就这么做了，比特币的创造者也这么做了，但结果却截然相反。 在法定货币不再和黄金挂钩之后，纸币的供给量增速高于黄金，因此大家看到的结果就是纸币的价值相对黄金大幅下跌。 整体看来，各国货币供应量平均每年增长 32.16%。 这是一个相当可怕的数字。这也正是白银在货币竞争中输给黄金的原因——黄金的供给增长率较低，意味着 购买力 下降的速度比白银慢得多。 恶性通货膨胀的坏处远远不只是很多人失去了很多钱，它是社会经过几百上千年才建立的经济生产结构的彻底崩溃。 政府负责货币供给的 问题 在于，通货的硬度 完全取决 于那些主张不扩大货币供给的人的政治实力。 货币硬度只来自政治约束，而在物理上、经济上或自然上，政府生产多少货币完全没有任何限制。 牲畜、白银、黄金和贝壳的生产都需要付出大量劳动，且不可能一下子大量生产，但是政府货币的生产只需要政府的法令就够了。 不断增加的货币供应量意味着货币不断贬值，使货币的持有者财富受损，使货币的生产者和最早获得货币的人受益。 历史无数次地表明，政府将不可避免地屈服于货币供给膨胀的诱惑。 无论是纯粹的因为贪污腐败，还是因为“国家紧急状态”，又或者是受到通货膨胀学派泛滥的蛊惑，政府总会找到一个理由和方法来增加货币供给，扩大政府权力，同时稀释货币持有者的财富。 这与铜生产商为了应对铜的货币需求而开采更多铜没有什么不同——它奖励货币的生产者，但惩罚那些选择用铜来储备财富的人。 在如今，政治进程使货币理智越来越成为一个幻想。正如弗里德里希·哈耶克（Friedrich Hayek）所言： 在将货币从把持它们的政府手中解放出来之前，我相信我们再也不可能重新获得良好的货币。现在的情况是，我们能做的，只是以聪明迂回的方式引入一些它们无法阻止的东西。 小结好了，本篇已经够长了，我们也基本理解了 货币 以及它简要的 发展历程，发现政府货币发布以来的表现一直是 “差强人意”。 我想你对比特币为什么会 “大火” 已经有了初步的猜想，我们在下篇再来继续详细讲讲。","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"}],"tags":[{"name":"比特币","slug":"比特币","permalink":"http://www.wmyskxz.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"}],"author":"我没有三颗心脏"},{"title":"谈谈近况，谈谈自由职业，谈谈“金饭碗”","slug":"谈谈近况，谈谈自由职业，谈谈“金饭碗”","date":"2020-11-11T02:35:41.000Z","updated":"2021-01-03T23:29:03.282Z","comments":true,"path":"2020/11/11/tan-tan-jin-kuang-tan-tan-zi-you-zhi-ye-tan-tan-jin-fan-wan/","link":"","permalink":"http://www.wmyskxz.com/2020/11/11/tan-tan-jin-kuang-tan-tan-zi-you-zhi-ye-tan-tan-jin-fan-wan/","excerpt":"","text":"Part 0. 近况Hi，这里是摸鱼不止一个月的 我没有三颗心脏。 这一个月以来 一直 在 休息（摸鱼），中途去了一趟广州，参加了 MC 开发者周年的 节目录制（摄影棚露脸拍摄..）。 包了机票酒店不说，还见识了其他开发者的风采，也算是一次 别样的体验 吧。 中途也出去跟着家里人旅游了一下，其余时间就是在 摸鱼 了。 不过还好每天也尽量有坚持 看点书，摸鱼的期间也断断续续看完了大概 9 本书 (其实有点被自己吓到..)，也越发觉得世界魔幻了起来，自己也浅薄了些。 收入方面也是已经越来越好了，9 月份光是交税就光荣的上缴了快小 5k，10 月份也差不多。 鉴于已经摸鱼这么久了，就认真谈一谈最近自己思考的一些问题吧，也算是给自己反思反思，给收收心了 （毕竟玩儿得太久了..）。 Part 1. 自由职业为什么这么吸引人？如果问：你有什么梦想？那 躺着数钱 绝对能算得上热门的选项。 这就有点儿类似于大众对于「自由职业者」的 普遍想象——有钱又有闲（毕竟还有时间数钱） 什么早晨坐对洱海的朝霞写代码，晚上对着三亚的海风说晚安…. 什么每天只用工作 4 小时，然而收入还能翻倍…. 试问谁不想过这样的生活呢？自由职业者里蕴藏的 “自由” 太吸引人了…. 可是你稍微观察和了解一下那些真正的自由职业者就会发现：理想很丰满，现实却很骨感。 撇开那些真正因为「有钱」而自由的所谓「自由职业者」(这也是经常被我们看到的一类)，还有少部分因为好奇部分参与的，那些真正自由了的职业者们其实都要 *比之前忙多了**。(我属于另一类…)* 就拿 技术人员 来说，上班的时候我们只需要按部就班的完成好自己的任务就有工资按时到账。 但是 脱离了公司脱离了组织，你参与的项目、你编写的软件是否盈利、怎么盈利，怎样开拓市场诸如此类的问题，都需要你全部过问的时候，你是否有能力喝下这一杯叫做自由的酒呢。 (疫情期间我们也都体验了一把「自由」的味道了，感觉如何呢？) 换句话说，你拥有脱离了组织挣钱的能力吗？ 所以，是 自由 吸引了我们吗？ 不用按部就班地打卡、不用早起挤地铁、不用每天上下班通勤、在家办公、不用看老板脸色就是自由吗？ 并不是。 说到底，让你不自由的，不是打卡也不是老板，不是不够专业，而是你缺少能力。 否则，就算你辞职到了云南、到了三亚、到了珠穆朗玛峰你也是不自由的。 自由职业的核心是职业，而不是自由。 如果自由职业本身做为一种职业，这种职业 最大的特征 是：你一个人走通了专业能力出售的全产品链——专业能力封装、定价、宣传、销售、升级、财务保障……自由职业说到底是一个人的创业。 自由职业里的「自由」，不是 辞职的自由，而是 选择 的自由，这个选择背后，是 能力 的自由。 所以我们吸引我们的不是自由，而是这种自由职业的状态——能够以自身能力为产品，自己构成一个完整的商业闭环的能力。 这也给我们警醒，我们要时刻提高脱离平台之外的能力。(有许多人会错把平台的能力当成自己的能力，这是不可取的) (虽然目前来讲，我算是调研、策划、开发、测试、UI 等全环节参与，借助 MC 的平台自己开发「游戏」自己卖，但我仍然离「职业」差得很远…我属于偏「幸运」的那一拨人…假借了平台变相实现了自由…) 在我的心里，那些真正的自由职业者都是勇敢追求自我超越、准备全力以赴以自己的手艺与天赋为生，相忘于江湖的勇士。 我也希望自己能在路上。🙏 Part 2. “金饭碗”也只是饭碗而已我发现一个有意思的事，那就是 上一辈人 大概率觉得 好工作的天花板 就是 「公务员」。 不知道你们的环境是怎样的，至少我时常还是会听见或看见： 不知道做什么工作？考个公务员吧？ 干得不开心了？回家考公务员吧？ 工作很辛苦？要不回家考个公务员算了？ …. 好像 「公务员」 是一把开启人生答案的 「万能钥匙」，最近正好在看《精进2》，里面有一段话瞬间在我心里激起一层一层的涟漪。 大概意思就是：如果有人告诉你有一种包治百病的药，那么你可能会觉得对方有病。 这是当然，因为病跟病不一样，这意味着治愈病要满足的限制也不一样，根本就不存在所谓的「万能药」。 但是这事儿放在「找工作」上，特别是 当「公务员」 上，我发现人们没有像「万能药」那般持有怀疑态度，反而有些深信的意味。 这是为什么呢？ 目的不明确 我觉得占有相当大一部分的原因。 我们生病了当然要 治病，这个 目的很明确，什么病应该吃什么药也非常的明确清晰。 但是我们找工作是为了什么呢？又或者为什么我们需要找工作呢？这本身就 非常难描述目的非常模糊。（并且带有哲学的意味） 本身 目的的不明确，加上现有教育体系所没有培养的 自主性，就很容易让公务员这样的 「金饭碗」 成为 主流。 建筑家保罗·谢菲尔德（Paul Shepheard）说：“主流是一种非常强大的潮流，人在其中无法思考。” 每个人的境遇、爱好、性格、志向、资源都各有差异，像 「公务员」 这样的 「万能钥匙」 明显是存在 「欺骗性」 的。 人都需要为自己寻找答案，为自己开出药方，一个人的成就也一定是建立在他的 独特性 之上。 换个角度思考，”金饭碗”也只是饭碗而已，对吗？ End“自由职业” 之后自己的想法和生活都发生了很多变化，也面对着更多的不确定性。 上一周在 阮一峰 大大的博客里看到一个有意思的 话题讨论：你的头脑是二值逻辑，还是三值逻辑？ 譬如抛硬币，如果你认为抛硬币的结果只有正面反面两种结果，那么就是 二值逻辑；但如果你认为它可能存在一种既不是正面也不是反面的状态，那么你就是 三值逻辑。 这两种思维方式会让我们看待世界的方式和心态完全不一样。 我们平时学习、积累经验，应该是对这个世界 越来越不确定，而不是越来越确定。 (这个过程我们也应该竭力避免 “应该” 这个词——常常是这一张张一种种的标签，把人的想法限制住，行动束缚住，让人没有勇气去想、去做与众不同的事。) 很多问题的答案我们都需要自己去找寻，而且答案不唯一。 近期可能会想要分享非技术的东西多一些吧..很久不写博客了感觉都不知道怎么写了..今天就唠到这儿吧.. （END） 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"《Offer一箩筐》2W字总结面试套路14问——不给例子的教程都是耍流氓！！","slug":"《Offer一箩筐》2W字总结面试套路14问——不给例子的教程都是耍流氓！！","date":"2020-09-16T07:03:05.000Z","updated":"2020-12-09T04:45:37.555Z","comments":true,"path":"2020/09/16/offer-yi-luo-kuang-2w-zi-zong-jie-mian-shi-tao-lu-14-wen-bu-gei-li-zi-de-jiao-cheng-du-shi-shua-liu-mang/","link":"","permalink":"http://www.wmyskxz.com/2020/09/16/offer-yi-luo-kuang-2w-zi-zong-jie-mian-shi-tao-lu-14-wen-bu-gei-li-zi-de-jiao-cheng-du-shi-shua-liu-mang/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」。 如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Hi~ 这里是 我没有三颗心脏，一个兴趣爱好广泛的 96 年 自由技术人。 都说九月十月是跳槽的高峰期 （也有金九银十的说法），所以 *近期** 计划出一些 面试求职 相关的文章，这里是系列的第三篇「面试中的棘手问题」，硬核实力讲解 *(搭配可直接食用的例子) 如何回答面试中的那些难啃、套路的问题，也算是学习分享，真心的希望对大家有所帮助，如果 觉得不错，请点赞/留言，莫要白嫖~ 至此，关于求职面试相关问题已经解决了 大方向 的东西了，只剩下一些细枝末节的地方以及技术面试相关了，请继续关注 wmyskxz，后续会持续整理输出一些技术面试相关的内容~ 01. 面试前的准备1 准备好自我介绍提前准备自我介绍非常有必要，这几乎是每场面试的“开场白问题”。特别是受疫情影响的现在，在线面试更是绕不开这个问题。 ⚠️ 自我介绍三大雷区1、介绍得又全又广，没有重点，就像在复述简历一样； ❌ 错误示例：面试官好，我叫 XX，我是 1996 年出生，我在某某大学某某专业，我毕业之后从事过两份工作，第一份叫什么公司，我做什么样的职位，具体工作内容是什么什么样的，第二份又是什么样的，我的性格是什么，我的爱好是什么，以此类推。 📝 点评：听你背诵一遍简历没有任何意义，因为简历已经在面试人员的手上了。 2、假、大、空，喊口号式自我介绍； ❌ 错误示例：面试官好，我叫 XX，我是应届生，虽然我没有什么相关工作经验，但是我对于从事 Java 开发的工作非常感兴趣，我一定会努力工作的，请您给我一个机会。 📝 点评：HR 内心 OS（努力工作？那你为什么之前不努力做出一些东西呢？诸如此类…） 3、与岗位毫无关联； 上面👆两种自我介绍都没有突出自己与所应聘岗位的 匹配度，这也是 HR 关注的一点。如果你能在自我介绍当中说出你与当前应聘岗位有什么样的 匹配度，那么 HR 就会眼前一亮✨。 另外也要注意不要把自我介绍搞得像是 生平介绍，不要包含太多的细节，请确保在 1、2 分钟内能够说完。 ❗️自我介绍 4 招制胜 简单介绍工作经验； 找到与岗位匹配优势； 应聘该岗位的理由； 应聘公司、行业的理由；（可以删减） 以下是一些演示，语言和内容都比较空泛、不太精炼，但 重在思路： ✅ 简单示例： 你好，我叫 XX，我是一位具有创新精神的软件工程师，拥有 20 年管理中小型公司开发过程各个方面的经验。我的上一份工作是在 XXX，负责 XXX。（简单介绍工作经验） 我们从市场调研阶段就开始设计吸引和留住客户的方案，我们 2017 年的木啊比偶是收入比 2016 年增长 2%，现在我们实现了 3% 的增长。（找到与岗位匹配的优势） 我很喜欢高级项目经理这个职位，因为我知道我有能力管理复杂的项目，我也愿意为贵公司做这项工作。（应聘该岗位的理由） ✅ 完整示例：（假设这是一个销售转岗互联网用户运营的童鞋） 你好，我叫 XX。我之前的工作做了三份销售的工作，都是在房地产做销售的，工作当中，我会涉及到市场的拓展、用户的沟通、促成交易，包括配合一些线上线下的活动。（简单介绍工作经验） 在之前的工作当中，因为我做市场拓展，所以我对房地产行业的竞品行业发展政策（之类的）都非常了解，我也会一些行业调研的方式和方法；同时因为我跟客户沟通，所以我对客户心理的把握、客户需求的了解；包括我还会做一些客户的调查，各种调查手段我也非常熟悉；因为有配合一些活动，所以我对活动这个方面也有一定经验。（找到与岗位匹配的优势） 其实我在活动策划、用户沟通、了解客户这种能力是比较强的，用户运营其实跟我之前的工作，有非常大的相关度，同时因为用户运营跟销售相比，我会觉得这个岗位的未来会更有发展前景一些，所以我其实现在算是一个转行的过程，但是我之前的能力并没有抛弃掉，还是有很大一个迁移度的，所以我选择这个岗位。（应聘该岗位的理由） 之前是做房地产行业的销售，贵公司所属的行业，也是房地产，所以我之前的经验和一些对客户的了解、对竞品的了解、对同行业务的了解，都是可以迁移过来的，同时房地产互联网，现在也是一个比较有发展的市场，所以我选择这个行业。（选择该行业的理由） 我入职之前，我对贵公司的产品、业务、公众号、社群等，都有很丰富的了解了，贵公司的价值观是什么样的，对客户的态度是什么样的，同时这个岗位他的工作内容很丰富，跟我之前的工作内容也高度契合，所以我相信，贵公司是一个特别能够让员工发展的，然后对客户负责人的价值观我也非常认同，同时这个岗位的工作内容也能够让我的能力有充分的发挥，相信也能为公司带来很高的价值。（选择公司的理由） 总结一下1、不要太长，要有重点； 2、不要喊口号，真正拿出你的技能和能力来； 3、一定要去契合岗位； 2 准备好时间请将面试当作生命中 唯一重要 的事情来对待，因为此时此刻，它就是唯一重要的。不要让自己在面试时还需要顾虑时间冲突，应该把时间都腾出来好让自己心无旁骛。 这不仅仅是因为不断地看表是不礼貌的表现，更是为了让你能百分百 集中精神 应对面试。 而且通常情况下，如果面试进行的时间较长，这是个好的征兆，因为这表示对方对你很感兴趣。 3 明确面试的目的面试的首要任务很简单：获得录用，或是顺利进入下一个环节之后再获得录用。 （⚠️ 另外提个醒：请注意“获得录用”并不表示“弄清楚这份工作的一切细节”。参与面试目的并不在弄清自己能挣多少钱，福利怎么样，或是工位在哪儿。这些都是等到正式得到工作后才需要考虑的问题。） 的确，你可能不会当场得到这份工作，可一旦参与面试便要 说服 其他人你就是这份工作的 最佳人选。 你希望自己的表现能给对方留下深刻的印象，好让他们在面试后几小时或几天后作出爽快的决定，给你这个工作机会。 4 准备好心态➡️ 有很多人讨厌面试，觉得自己像是在一种 接受审讯 或者是 被拷问 的状态。你害怕犯错，害怕不知道如何提问或者因为打错了问题而丢失工作的机会。 ➡️ 还有一些人对面试 漠然以对，对他们来说那只不过是一个坐着礼貌地回答问题的地方，他们总是保持着 随缘 的态度。事情该怎么着就怎么着，所以根本没什么需要担心的，不是吗？ 上面👆两种态度都不对。 请记住招聘人员是真心想招你 （但是也要警惕想要骗取你身上某些资源的情况，据我了解，比如一些设计师就会有找工作被窃取创意的情况发生）。她希望你就是那个能够帮助她解决问题的人，不然她也不会邀请你来参加这一次的面试。 面试对招聘人员来说如同对你一样，会让人筋疲力尽。每一次面试都将占用她几小时的工作时间，而且招聘也是一个费钱的过程。没人会因为单纯觉得好玩而安排面试。 不管你心里怎么想，永远都要记住面试是一次与未来雇主的商务会面。 如同简历是面向新雇主的第一份工作成果一样，面试也是你与新雇主的第一次商务会面。 这也是与你个人息息相关的，面试过程中你也在以应聘者的视角面试新雇主，了解那些对你来说最重要的信息。面试的参与双方地位都是平等的。 另外面试是一个 对话过程。不管内心怎么想，你可不是被警察审讯的嫌疑犯，只是在单纯地一问一答。 事实上，安静地坐在一边，只是老老实实地一问一答是导致面试失败的一大原因，因为这样你带给面试官的印象不是毫无己见就是胆怯得无法开口。 5 提前出门面试迟到会让你之前所有的准备都泡汤了。 对于大多数面试官来说，迟到也就意味着应聘者没法跟上工作节奏。所以请保证自己能提前到达面试场地。 在预估的花费时间之上再加 20% 至 50% 的 缓冲时间。如果旅途顺利，你可以带本书到停车场或是附近咖啡馆消磨多出的时间。当然，最好还是利用这段时间重温准备好的问题、查阅参考文件以及做好的备忘，让自己达到最充分的准备状态。 02. 准备面对棘手的问题吧~⚠️ 以下的这些问题大部分来自于《人人都有好工作：IT 行业求职面试必读》一书，另加上了自己整理的一些问题。 首先需要说明的是，下方的回答仅仅是提供一种思路参考，总体原则是 突出自己的优势，贴合企业的要求。 另外要 真诚，不要让人觉得像背书一样，最好的情况是能自己能录音听一听自己回答时的状态、语速有没有让人不适的地方。 也要试着理解每一个 问题背后隐藏的原因。 譬如招聘人员问你对于 Apache Tomcat 应用服务器的掌握情况，这并不表示他正在显摆《101个向求职者提问的热门技术词汇》的书籍中摘下的新词，这意味着他手头有一些与之相关的工作任务和问题需要你解决。 那么此时你除了如实回答问题之外，也许还可以问：“你们是在考虑改用 Tomcat 技术吗？” 如果公司不是做 Java 的，那么面试官的提问可能会有更多的原因。但关键依然是关于如何将你掌握的技术与他们需要解决的问题相结合的讨论。 下面👇就一起来看看那些棘手的问题吧！ 1 谈谈你自己吧？这是一道经典的开放式问题，给你足够的空间 阐述自己的优势。 对方会突然间询问你是怎样的人，能为他带来什么 （这跟自我介绍又有不同，主要是介绍自己的优势）。所以这个答案必须事先考虑好。 回答示例❌ 糟糕的回答 1：您想知道些什么？ 📝 点评：这个回答表现出你一无所知，或者是根本没有能力推断出面试官想要了解的信息。也从侧面表明了你在这份工作上并没有花功夫，很可能面试官就终止面试了。 ❌ 糟糕的回答 2：那么就从我小时候开始说吧··· ❌ 糟糕的回答 3：我是个程序员。今年 1 月份开始我就失业了，在家里可没什么编程机会，所以目前还不完全算是。但我还是很希望得到这份工作，因为您也知道在没有收入的情况下背负这么多贷款是一件多么艰辛的事情，对吧？ 📝 点评：你应该花大概 30s 的时间把自己 最闪光 的地方陈述一遍，你的目标是给出一系列优势，而不是让听众觉得无聊和厌烦。而且尽量应该 口语化 一些的方式叙述出来。 ✅ 恰当的回答：现在算起来我做系统管理员已经有 7 个年头了。最开始我在一家只有 10 个人的公司中维护一台 Windows NT 服务器。后来我们在一台 Windows NT 的域上建了一个 Samba 服务器，管理 150 名用户，这些用户有的使用 Windows，有的使用 Linux。同时我也做一些编程工作，以及写 shell 脚本。我还曾经为 Nagios 远程监控服务写过插件，并且为 Bugzilla 提交了几个补丁。过去我一直从事的是市场营销行业，所以我觉得是时候丰富自己的阅历了。能在 Yoyodyne 工作对我来说是个不错的转变。 📝 点评：尽量使用完整的句子，而不仅仅是摘录关键的要点。另外应该为某份工作或者某家公司量身定做。 面对不同的人员使用不同的回答💁‍♀️ 面对人力资源筛选人员：用保险的方式回答。谈谈你这些年的工作经历以及都在哪些公司供职。聊一聊你的高水平技能（数据库、Linux方面），但不要过于细化（具体到 Oracle 和 Postgres, RedHat 和 Ubuntu）。当然在提到那些招聘广告中列举的具体技能要求时可以适当细化。 👨‍💻 面对你的未来同事：尽可能细化你掌握的技术，还可以时不时地蹦几个时髦的技术词汇让你们之间的对话产生火花。 👨‍💼 面对非技术型管理层领导：强调你的成就、完成的项目以及贡献出的商业价值。尽量避免使用那些时髦技术词汇。 👨‍💻‍ 面对你的未来上司：什么内容都提一点，强调一下团队合作精神以及软技能。 你的回答应该根据应聘职位以及公司的不同而调整。 如果招聘广告中强调过某项专业技能要求，那就在你的回答中突出它。如果你有相同行业的从业经验，那么这也是你需要强调的地方。 另外，面试官提问的方式也可能各有不同，也许会采取更直接的方式，比如：“你觉得自己比起别人有哪些方面的优势？” 2 你对我们公司有什么了解？这个问题可以快速的让面试官了解到应聘者为面试做了什么样的准备。 应聘者对每个面试都是无差别对待的吗，还是他只对我们公司特别感兴趣？他已经做足了功课把公司调查清楚了吗？ 对于应聘者来说，这个话题也可以成为自我介绍的引子，并且你还能从中了解公司的需求。 回答示例❌ 糟糕的回答：那个，说实话不太了解。不过我觉得你们的网站做得不错！ 📝 点评：对公司毫无了解就去面试会在面试官心里默默掉很多分。 ✅ 恰当的回答：HoseCo 是一个专门生产工业用软管及配件的公司。公司 1954 年成立，在 70 年代时搬到目前的所在地。我想知道你们会为航空业提供材料吗？因为我曾经在波音公司的冷暖装置部门做过顾问，那对我来说是一段难忘的经历。另外，我发现你们网站使用的是 JSP 技术，但是在线产品目录似乎使用的又是 CGI。请问那是用 Perl 语言写的吗？而且我知道你们也在辛辛那提设立了第二分部，这也说明了公司运营情况不错。那么请问你们和俄亥俄分部之间是如何建立通信的呢？ 📝 点评：上述的回答不仅显示出了自己是有备而来，而且还证明了自己能用老板思维看待问题。因为你提到的个人背景正是能够为公司带来利益的。 3 你对公司的什么地方感兴趣？在其他条件都对等的情况下，没有哪个招聘经理希望录用对工作或公司毫无兴趣的员工。而且关键是，你也不应该找一份自己提不起兴趣的工作。 如果你对这个问题的答案根本毫无头绪，那么也许根本不应该申请这份工作。 回答示例❌ 糟糕的回答 1：这个，是因为离我家很近。 📝 点评：这是一个理由也不要第一个说出来，因为即使公司离家的距离很重要，那也不应该让对方觉得这是你的首要关注点。永远都要记得把公司利益放在第一位。 ❌ 糟糕的回答 2：我看上了贵公司发的薪水。 📝 点评：真诚很重要，但也不要太“实诚”。 ✅ 恰当的回答：我一直都很喜欢汽车，所以能为一家生产汽车零部件的公司工作对我来说是十分理想的选择。招聘广告上说公司使用的是 Ruby on Rails，这也正是我很愿意做的工作。因为过去我一直使用 Java Struts。另外，我在贵公司财务部门的好朋友苏西·德金斯也向我推荐这儿。她总是和我说起这个大家庭里大家相处得有多融洽，而且贵公司离我家也只有 10 分钟的路程。总而言之，这份工作对我来说十分理想。 📝 点评：这个问题也是个机会，让你提起自己和公司之间的联系，或者说起公司中熟人。 4 你最大的优势是什么？面试刚开始时，重点话题都是关乎你是谁，你有什么样的经历一类的问题，比如第一个问题「谈谈你自己」的部分。 而在面试后期，很可能话题将会转到如何 评价自己 这儿。 无论哪部分，都应该挑选自己 擅长 的内容说，同时给出支持自己说法的例子。最好能提供软技巧和硬技能各一个。 回答示例❌ 糟糕的回答 1：我工作很努力。 📝 点评：面试官当即给你一个白眼，每个人都这么说。 ❌ 糟糕的回答 2：我是一名优秀的程序员。 📝 点评：话可能不错，但是没有提供细节和案例上的支持，等同于一句废话。 ✅ 恰当的回答 1：遇到危机时我都能保持冷静并很快集中精力，很少有事情会让我感到绝望。旁人都对我处理棘手问题的能力感到惊讶。您也知道，对于我们系统管理员来说，眨眼之间就可能面临一大堆麻烦。 📝 点评：有细节上的说明，并且贴合自己的职位。 ✅ 恰当的回答 2：我对数据抽象化很有心得。建立数据库模式、编写接口这一类的事情对我来说就像是与生俱来的能力。这是工作中我最爱做的部分。 📝 点评：不用对分辨哪一项才是自己最大的优势发愁。实际上你只要选择那些对公司最有益的优势展开就可以。 5 你最大的缺点是什么？这似乎是大家最头疼的问题。面试官想让你亲口坦白自己究竟有哪些不适合这份工作的缺陷，当然事实上你根本不需要说自己不适合的地方。 请确保自己不会被突如其来的问题吓到，从而坐在位子上苦思冥想哑口无言。 ➡️ 有很多求职的书籍都会建议使用一个技巧性的回答「我工作过于拼命」，或者是「当我发现大家不如我工作努力时会很失望」。 这些回答的思路没有错，因为他们知道要把对自己不利的局面转向有利的方向。但是这样的回答 存在两方面的问题。 首先，这很可能并非你的真实情况，也就是说你在撒谎； 其次，更糟糕的是，它们完全是一通废话，而且面试官很清楚这一点。这样的回答可以明显看出求职者在刻意撒谎。 正面地处理这个问题，是把它当做是「你希望自己在哪方面得到提高？你现在提高的情况如何？」这样的问题来对待。 确保回答的语气体现了这些的确是你个人需要提高的部分，而不要表现得一切似乎都是别人的错。 选择技术方面的弱势，而非个人的失败之处或是人格上的缺陷。 回答示例❌ 糟糕的回答 1：当我发现大家不如我工作努力时会很失望。 📝 点评：不仅是个无用的回答，而且提出的还是别人的错误。 ❌ 糟糕的回答 2：我是个完美主义者。 📝 点评：不仅是个无用的回答，而且你能说出自己打算如何改进吗？另一句话，就是缺少细节和案例上的支持。 ❌ 糟糕的回答 3：我真的很讨厌测试代码。 📝 点评：这对于一名程序员来说可是个巨大的失败。切忌讲述一个对于应聘职位来说是硬伤的缺点。 ✅ 恰当的回答：我对 JavaScript 和 Ajax 了解得还不够多。我目前从事过的编程工作都是偏向服务器方面的，但是显然，Ajax 技术会继续成为主流。前阵子我买了一本 PragmaticAjax，现在正在努力学习中。 📝 点评：还是那一点建议，选择技术方面的弱势，而非个人的失败之处或是人格上的缺陷。 6 我们凭什么雇你？如果这个问题在面试最后或是与更高层的第二轮面试一开始提出，那么意味着对方正在邀请你进行自我总结。 说说一旦入职之后自己将会为公司采取哪些具体行动，比如：“您刚才提到了公司面临的数据库规范化问题，这正是我可以提供帮助的地方。去年我曾经率领一个数据库管理员团队……” 有些人会觉得这个问题是一种威胁。因为它给人的感觉就像是在问：“你究竟有什么好的，兄弟？”这感觉就好比将一个重担压在应聘者身上。 千万别这么想。就把它当成是用略带攻击性语气的“谈谈你自己”，这样你的表现会自如很多。 如果这个问题出现在面试开场，那么在回答完之后再加一句：“当然，这些并不是我能够为公司带来利益的全部，我希望了解更多公司和部门面临的挑战，这样我才能知道如何能发挥自己全部的力量。” 7 谈谈你经历过的进展不顺利的项目对于这样的问题不存在所谓的正确或错误答案。面试官希望从中了解你是如何处理问题以及如何面对逆境的。案例 在这儿非常重要。 如果你被问道“你曾经遇到过某某事件吗？”那么就把这个问题转为“给我讲一个关于某某事件的故事。” 从这个问题中能得出 两方面 的结论。 一方面，面试官想看看你究竟是如何处理日常工作中遇到的不顺，另一方面 可以了解你是否是一个抱怨者，你是会坦诚自己的错误还是将责任推卸到别人身上 （最好能从自身和他人两方面的角度来说明这个问题，但是千万不能埋怨他人）。 回答示例❌ 糟糕的回答 1：哦，好的，该讲哪一个呢？我们网络团队总要处理一些非常紧急的状况，因为市场部净安排些计划时间表非常不合理的项目。这样一来我们能腾出的时间往往不合乎他们的期望，于是他们就不停地责怪我们，搞得我们像群傻瓜一样。他们自己没能力提前安排好计划又不是我们的错。 📝 点评：接着这个问题的往往会是：“那么你从中学到了什么”或是：“那么你会从哪些方面着手来防止这样的情况发生？” （看👇） ❌ 糟糕的回答 2：（接👆） 没学到太多。我想我们只能和市场部的人讲，没法事事都按照他们的意愿进行。我真想给市场部主管上堂课，告诉他软件工程究竟是怎么进行的！ 📝 点评：每一句回答都在指责别人，而且使用的是侮辱性语言。面试官从中可以看出一旦这位应聘者入职之后她很可能也会不停地抱怨中伤团队其他人，那么就会对你说再见了！ ✅ 恰当的回答：（与👆面对的同样的情况） 近来我们和市场部之间出现了一些摩擦。新来的市场部主管对网站有一些宏伟的方案，而这些方案的完成期限不容商议，是为了即将到来的贸易展的。第一次合作时，我们就没办法按照他的预想办好事，从而引发了很多不愉快。他对我们这个网络团队很失望，而我们又觉得他的要求非常不合理。很显然，这是因为我们之间的沟通还不够。 📝 点评：这就是上面说的，最好能从自身和他人两方面的角度来说明这个问题，但是千万不能埋怨他人。 ✅ 恰当的回答：（现在，在面试官还没开口接下去提问时就主动回答） 第一次的不愉快之后，我们就主动碰头总结了这件事情。我们很高兴能看到市场部有着这样的进取心，但同时我们也商量好保证之后的项目要求合情合理。老实说一开始还很难谈拢，但是当市场部主管意识到我们其实是站在他那边后，进展便开始顺利了。 📝 点评：主动提出自己是如何处理问题以及如何面对逆境的，主动主动主动。 7 谈谈你犯过的最大错误这个问题直指 两方面 的信息。首先，它能体现出应聘者如何处理“项目进展不顺”的 指责。其次，这也展示了应聘者的 经验水平。 只有实实在在地工作过才会犯错，如果你从来没犯过错，那只能说明你并没有付出足够的努力。 除非你所在的行业绝对不允许错误发生，譬如医疗以及航空业，犯错意味着有人丢掉性命。 同时，错误也是学习与成长的过程。 挑选一个可以证明你有能力为错误承担责任的例子，并且在回答中增加说明“你从中学到了什么”。 回答示例❌ 糟糕的回答 1：我不知道，我想我没犯过什么错。 📝 点评：那也说明你没有什么实际的项目经验。 ❌ 糟糕的回答 2：我曾经有一次错误地将C盘格式化了，那简直糟透了。 📝 点评：错确实是大错，但是你并没有说明你为错误承担责任的能力。 ✅ 恰当的回答：当时我们试图更换一个新的电子邮件系统，我使用 Perl 语言从 Notes 中读取数据，并写进 Exchange 里。周一早上，用户气愤地发现他们存档文件被错误地重新分类了。所有存档文件中的邮件都被移至单一的文件夹中，而那时候已经来不及重新运行指令了。打从那以后，我就发誓今后每一个数据转移项目都必须添加转移前的确认步骤，这样可以让我在指令实施之前重复确认以保证万无一失。 📝 点评：还是上面的建议，挑选一个可以证明你有能力为错误承担责任的例子，并且在回答中增加说明 “你从中学到了什么”。 8 如果…你将怎么处理这样的问题通常建立在某个特定场景下，这个场景并没有显而易见的正确处理方式。 这时候你采取的行动能体现出 处理事务的灵活性 以及 解决问题的能力。 即使问题场景似乎与技术有关，但通常情况面试官让你做的却是非技术层面的判断。下面是可能出现的问题： 📌 可能场景 1：假设你处在代码冻结阶段，距离某个软件的发行日子只剩下最后两天，这时候你发现由同事负责编写的代码中有一个小 bug。你知道这位同事之前也出现过代码质量问题，而且他也十分担心自己在公司的业绩评估。你可以轻松地修改这个 bug 而不用告诉任何人。但是现阶段，照理说任何改动都需要经过项目经理的批准。那么这时候你该如何处理？ 📌 可能场景 2：你所在的是一个小公司，某天公司总裁找到你，表示他对公司网站极度不满。他坚持用户注册表格中应该使用单选按钮而不是现在的下拉菜单。他要求你今天就改过来。从技术上来说，你可以轻松地按照总裁的要求修改，但这样就和部门现有的流程规定不符。哦对了，你的头儿正好在度假，不在公司。这时候你该如何处理？ 上面👆提到的两个例子都没有所谓的正确答案。面试官也许只是对你的思考过程感兴趣，那么请确保回答中包含了你的思路。 这样的问题也是检验你和公司文化 是否合拍 的一种方式。你也许会发现公司总是严格按照规章制度办事，或永远都唯老总马首是瞻。 如果你和公司文化有无法融合的地方，最好趁现在赶紧发掘。请干脆地回答问题而不要过于絮叨。 回答示例✅ 恰当的回答：我会照着总裁的意思做网站调整。但同时我也会对原有的版本做好代码备份，以防头儿回来之后有不同的意见。这的确是一个两难的境地。请问是不是部门过去遇到过这样的情况呢？ 📝 点评：你不需要询问经理正确答案是什么，因为很可能自己就能挖掘出来。他也许会说：“是的，我们负责销售的副总就曾经如此利用了自己的权威。现在每个下属都会找我做决定，不管我处在什么情况下。” 10 你更喜欢团队行动还是自己单干独立完成工作与团队合作代表了一枚硬币的正反两面。 经理总是希望团队中的每个成员都能够独立完成工作而非事事都需要他的指引。但从另一方面说，不愿意或不能够和他人共事的员工，或是无法听从经理指示的员工都是团队生产力极大的阻碍。 对于经理来说，比必须手把手地指示员工干活还要浪费时间的，就是处理团队成员之间的矛盾问题了。 请注意回答这个问题的态度。 千万别 给人你只能在自己 偏好的状态 下 才能工作 的印象。而且对于大多数情况来说，答案都不应该只是简单的 A 或 B，应当给出合适的例子。 回答示例❌ 糟糕的回答 1：哦，饶了我吧，拜托还是让我自己单干吧。 📝 点评：偏向性太强，并且语气有些“偏激”。 ❌ 糟糕的回答 2：我发现最佳的工作状态就是自己单干而不加入任何人的情况。 📝 点评：答案不应该只是简单的 A 或 B，应当给出合适的例子。 ✅ 恰当的回答：一切都依项目情况而定。如果我编写的是一次性工具代码，那么一般来说还是由个人独立完成比较好，最多也就是再安排一个同事帮我把关，确保没有任何地方出错。当然，对于大型项目来说，都是需要一整个团队人员的支持，而且项目的每一个分支该以个人完成还是两人一组完成也都是依据任务的性质而定。我想我个人是更倾向于可以发挥出最佳效率的独立工作状态，但是大多数情况下，都是会要求整个团队之间合作的。 📝 点评：A 或 B 的状态都给出了合适的例子，面试官表示想给一个暴风👍。 11 你希望自己 5 年之后在做什么？这样的规划类问题确实令面试者 头疼，这个问题有点儿类似于「职业规划」，我可能就是单纯地为了生存、温饱，但你非要问我的规划 （类似于问生活的意义是什么）。 有很多招聘人员对于自己的规划也不一定清晰，所以心态要端正，他并不是为了要帮你做职业规划之类的，也对你的规划也不感兴趣，他只是关心你的 稳定性 、匹配度 （譬如是否考虑转岗） 以及 能力 （有没有真正想去沉淀之类的）。 回答示例❌ 糟糕的回答 1：我没想法。 📝 点评：那我也对你没什么想法。 ❌ 糟糕的回答 2：谁能说得准呢？这可是计算机行业，我现在说的任何回答都不会是正确的，因为技术发展日新月异。 📝 点评：似乎对公司的前景、团队中的发展毫不关心，这样的回答会让面试官在心里留下一个大问号「这是我希望找到的人吗？」 ✅ 恰当的回答 1：就我目前的职业发展来看，我希望自己到时候能处在团队领导的位置，但是我还并不确定管理层的位置是否适合自己。从技术方面说，当然我很难给一个具体的回答，但是未来我主要感兴趣的两个大方向是社交网络以及大型数据库。一直以来我都对大型数据库兴趣盎然，另外像 Facebook 这样的社交网站的兴盛也让我觉得从事这方面的业务是不错的选择。请问 Yoyodyne 公司目前是否在做社交网络的内容？ 📝 点评：回答你所知的内容，而非猜测他们想听的。没有所谓的正确或错误的回答。如果你对领导位置没有兴趣，那么就别想着“我希望担任程序员团队的领导”或者其他可能会让你被贴上懒鬼标签的回答。而且，万一面试官根本不想找一个做领导位置的人呢？ ✅ 恰当的回答 2：我希望自己能做一些和今天所应征的职位不同的工作，当然还是在这家公司。我发现自己与其说是一个专才不如说是一个通才，这个特点让我一直不断地追求新技术，也希望每两三年都能迎接全新的挑战。 📝 点评：即使只有很少甚至根本没有工作经历，你也依然得拥有放眼未来的视角。 ✅ 恰当的回答 3：因为这是我的第一份全职工作，所以很难讲未来的具体计划是什么。我希望到时候自己在这家公司已经完成一些出色的项目，有过一两级的晋升，并且在工作过程中对系统管理员方面的知识有更深入的了解。 📝 点评：最重要的是，你必须在参加面试之前主动考虑清楚这个 5 年后的计划 （其实这事儿挺虚的.. 很难有人能想清楚这事儿），因为如果申请的这份工作根本不符合你的 5 年计划，那么从事这份工作只会将你引向一条死路。 12 为什么你想加入我们这根本不应该是个问题，如果你是有选择地参加面试的话。参加面试之前你就应该清楚这个问题的答案。 请确保 首要理由是 和公司有关。陈述完这个理由之后，才可以聊聊关于你个人的考虑。 和之前说的一样，公司利益永远应该是你的第一考虑。 回答示例❌ 糟糕的回答 1：不知道，只是觉得这份工作很酷。 📝 点评：我也觉得拒绝你的我应该也蛮酷的吧👿。 ❌ 糟糕的回答 2：因为我一直都很喜欢编程。 📝 点评：这并没有体现这家公司与其他公司之间的区别。 ✅ 恰当的回答：能够管理像贵公司那么大的网络系统是促进我个人技能提高的好机会，我相信自己能从中学到很多东西。另外，打从小时候我就对飞机非常喜爱，所以航空业也是我的理想行业。 📝 点评：针对性地对公司进行回答，并贴合自己的应聘职位来叙述会是更恰当的选择。 13 为什么你要离开原来的公司⚠️ 雷区警告。 你将要说明的是自己对某个处境不愉快的原因，而 不是抱怨。无论如何，千万不能将不愉快都归咎于他人身上。 回答示例❌ 糟糕的回答 1：我的老板就是个傻x，而且那些团队伙伴根本就是一帮无能的白痴。 📝 点评：哇哦，再见吧~ ❌ 糟糕的回答 2：那个，只能说老板和我有一些分歧。倒不是说他做人方面有问题，只是我们之间存在很多冲突。虽然我很不愿意这么说，但是他真的没招到什么好程序员。我很喜欢我的同事们，但是跟一帮成天无所事事的人一起工作的确也是件令人沮丧的事。 📝 点评：温和的用词也无法掩盖你的抱怨行为。因为你依然在表达自己的不愉快都是由他人造成的。也就是说你是个不折不扣的抱怨者。 ✅ 恰当的回答 1：我觉得在 Yoyodyne 没什么发展前景。我们所做的所有工作项目，都是对于现有系统的维护，没什么新的项目计划。我喜欢每一天的工作都充满挑战。我曾经就这个问题和我的头儿讨论过，但是他也说自己对此无能为力。我在家自学了 Ruby，但是公司也没有适合我进步提高的空间。 ✅ 恰当的回答 2：我需要找一份离家近的工作。当三年前我刚进那家公司时，一个半小时的上班路程对我来说也不算什么问题。但现在我发现路上花费大量的时间将和家庭生活起冲突，而且路上的花费也越来越高。当然，尽管距离并不是唯一的原因，但发现 Yoyodyne 公司有如此适合我的工作而且车程也只有 15 分钟，我真的很兴奋。 ✅ 恰当的回答 3：我和之前公司的合同 6 月底就到期了。我也试图在公司中寻找过别的工作机会，但是现在似乎没有适合我的技能与背景的职位空缺。 ✅ 恰当的回答 4：上一家公司的收入完全不符合我的技能水平和个人背景。我曾经看过许多关于收入的调查，也和一些公布的生活消费指标进行过比对。我喜欢之前的工作，但是上司跟我说公司的薪酬体系很难再做改变。（但请准备好应对面试官的下一个问题：“那你一开始怎么会接受这份工作呢？”） 📝 点评：最后的例子倒是一个可以放心地讨论收入问题的样板，因为这只是在正面回答面试官的提问。但请注意千万别自行踏入下一个问题，询问面试官：“那么告诉我，这份工作的收入是多少？” 在所有情况下，你的回答都应该只是 陈述事实，而不加以任何憎恨或责备的情绪。对于合同到期的情况，你也无需进行太多的解释：只是没有更合适的工作而已。 14 你有什么问题要问我的吗？由于 面试是双向 的，所以你也需要准备一些问题询问面试官以及参与到面试中的其他相关人士，尽管他们并不会成为你的未来上司。 事实上，应聘者在提问环节的沉默只会引发面试官更多的疑问：他是不是根本不关心这份工作究竟会怎样？他是不是压根就对这份工作不感兴趣？也许对他来说这份工作只是通往其他目标的踏脚石？看起来他根本就懒得思考这份工作该如何开展？ 提问表示你对这个职位感兴趣，同时也意味着你不只是在广撒网地找工作而已。 面试官为了把你请到面试中是花费了时间和精力的，所以一旦给他们留下印象以为你对自己申请的工作根本不感兴趣，那就糟了。 另外别准备那些对任意面试都通用的问题。 你需要反映出自己对于这家公司的兴趣、所进行过的调查以及加入的独立思考。 譬如，你可以问：“对于那些可以在开源项目中得到的产品，你们在销售时会面临怎样的挑战呢？”或是：“既然大家都知道亚马逊网站，那么你们又是如何将书籍销售给校园市场的呢？” 你当然可以询问一些关乎自身的问题，但是在提问的同时也别忘了展示自己时刻在考虑能为公司带来的利益。 🙋‍♂️Q1：每天的工作流程是怎样的？如果你希望了解每天的工作对员工有哪些要求，那么就可以询问这个问题，比如有没有早会、例会、立会、饭点时间、休息时间之类的。 🙋‍♂️Q2：上班时间有严格规定吗？加班频率高吗？会在周末安排加班吗？这个问题其实是比较敏感的，因为你肯定不希望自己被面试官当成是一个懒惰、自我的家伙。 但是，想了解自己未来的工作有哪些要求的心情也是可以理解的。 最好的方法就是单纯地倾听对方的回答并做好记录，而不对此作任何评论。对这份工作的不尽人意之处讨价还价是得到工作之后的事，而不是之前。 千万记得你不是去给面试官出难题的，所以请避免类似下面的谈话。 🙋‍♂️ 你：请问一下加班的频率有多高？我每周三都会跟小伙伴们约球，而且有时候周六上午我还得接女儿去补习班。 🙋‍♂️Q3：安排我做哪类项目？您看上班第一周我该干些什么？第一个月呢？第一年呢？你需要了解工作对你的要求有哪些，进而评判这是否符合自己的工作风格。 如果面试经理没有给出答案，那么你可得自己敲警钟。请看下面这位招聘系统管理员的经理给出的回答。 💁‍♀️ 招聘人员：我现在还不确定。我知道我们的项目需要一些数据库日常操作方面的帮手，但是我还不确定具体是哪方面的工作。目前在做的是 Oracle 的项目，也可能是 DB2 的。 如果招聘人员能够给出更多的信息，那么说明她对公司 IT 需求有着相当的了解，并且她还对未来的工作定制了计划。 最重要的是，这意味着你上班第一天不用呆坐在位子上玩弄手指了。她也许是一位不错的工作伙伴。 🙋‍♂️Q4：这是一个新增的职位吗？还是说我是来替换上一位员工的？如果说职位是新增的，那就表示部门正在扩大规模，那么继续就扩大规模的程度进行提问。 如果你是来替换上一位员工，那么就问问这位的情况，譬如：“跟我讲讲xxx吧，他都为公司做了什么？” 这些问题的答案应该会给你一些思路，如果公司对上一位员工的评价很高，那么你就知道今后自己需要在工作中达到怎样的表现才行，如果评价不高，那么你也了解到自己该避免怎样的表现。 请注意你可不允许询问xxx离开公司的内幕，而要给面试官一点余地，看他是否愿意告诉你。 🙋‍♂️Q5：跟我谈谈即将加入的团队吧这个问题表现出你对于和他人相处的重视，而且能得到一些背景情况有助于你决定这个团队是否值得加入。 如果招聘经理对于团队成员之间的交往只是了了作答，那么可以用这样的问题来深入提问：“大家都在一起吃午饭吗？”或是：“团队成员会在下班后一起出去玩吗？” 从面试官那儿打听到的答案无所谓正确或错误，但你可能从上面这两个问题中得出自己侧重关心的信息。 🙋‍♂️ 其他你也许愿意了解的问题Github 上有一个 star 超过 6k 的 反向面试 项目，里面详细记录了 技术面试 最后反问面试官的话 （事实上也不仅仅适用于技术面试），项目地址：https://github.com/yifeikong/reverse-interview-zh 随便摘录一些吧： ➡️ 职责： On-call (电话值班)的计划或者规定是什么？值班或者遇到问题加班时候有加班费吗？ 我的日常工作是什么？ 团队里面初级和高级工程师的比例是多少？（有计划改变吗） 在你看来，这个工作做到什么程度算成功？ 入职之后在哪个项目组，项目是新成立还是已有的？(zh) ➡️ 技术： 你们怎么测试代码？ 有标准的开发环境吗？是强制的吗？ 公司是否有技术分享交流活动？有的话，多久一次呢？(zh) 业务需求有没有文档记录？是如何记录的？(zh) ➡️ 团队： 晋升流程是怎样的？要求/预期是怎样沟通的？ 我可以为开源项目做贡献吗？是否需要审批？ 技术和管理两条职业路径是分开的吗？ 有公司级别的学习资源吗？比如电子书订阅或者在线课程？ ➡️ And More…. 但也请避免询问一些比较不那么有价值的一些问题： 贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？） 贵公司的男女比例如何？（考虑脱单？记住你是来工作的！） 贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！） …… 03. 技术面试技巧干货1 主动提起最能展示你技能的话题别以为简历上列举的技能面试官都会主动提出来。 要知道不管对你有多感兴趣，面试官也许根本记不住你的全部技能。实际上能留在她脑海中的只会是她个人觉得重要的内容，所以你可以提起其他方面的优势来引起她的注意。 最佳的推销方式就是讲故事，可以讲一些也许并不适合在简历中详细列举的可用数据量化的例子。 比如： 💁‍♀️ 招聘人员：你会使用 Perl 测试框架吗？ ❌ 糟糕的回答：当然，我们一直都在用这个。 ✅ 恰当的回答：是的，非常了解。从开始编写 CPAN 模块开始我就使用 Test::More 了，尽管当时只是用于测试自己写的模块。后来我编写了自己的测试插件 Test::Wango。现在我们会使用 Test::More 框架以及 TAP 协议来测试公司三分之一的内部应用程序，而且计划在年底之前将使用率升至 100%。 📝 点评：后面的回答显示了掌握知识的深度，并且打开了一扇深入讨论的大门。还有可能，这告诉了面试官一些他本身并不了解的内容。也许他从未听说过TAP，也根本不知道你不止能利用Test::More测试模块。 2 使用故事推销自己面试中最有可能出现的就是技术类问题，因为这些问题你最容易回答。 无论你是否知道问题的答案，当被问及技术问题时，你不应该仅仅以简单的“是”或“不是”来作答，因为这样的答案并不是面试官所期待的。 相反，应该多花一点时间讲故事，借机推销自己。 比如： 💁‍♀️ 招聘人员：你会使用 Ruby 语言吗？ ❌ 糟糕的回答：是的，会一点。 ✅ 恰当的回答：会一点。当我还在 Peekax 研究公司工作时，我们有个小项目为 Web 框架选型。我当时负责研究 Rails，研究的过程中我也发现了 Ruby 语言的一些不尽人意之处。虽然我们最终还是选择了 J2EE，但是老实说我打心眼里希望能马上开展 Ruby 的工作。 📝 点评：从上面例子中可以看到具体详细的回答能避免歧义，而不加例证的简单答案容易产生误解。可能你所谓的 “会一点” Ruby 语言和面试官心目中的掌握程度有差别。 3 强调自己在工作中承担的任务在讲述过去的工作经历时，把重点放在你做过什么上。 别对你实际做过的工作和起到的作用一句话带过。要知道你特别推销的是自己的才能，而不是当初的工作岗位。 比如： 💁‍♀️ 招聘人员：你使用 Ruby 做过什么项目？ ❌ 糟糕的回答：我现在的工作是使用 Ruby On Rails 框架开发 4 种基础的内部 CRUD 应用程序，除此之外，团队还在 RubyForge 发布过一个数学函数包。 ✅ 恰当的回答：我之前所在的团队由3位开发人员组成，我们使用 Rails 框架开发了 4 个 CRUD 应用程序。公司原计划是想使用 .NET 框架，但是我最终还是说服上司同意我们尝试了 Ruby。同时，我还努力征得公司管理层的批准，在 RubyForge 上发布了其中一个函数库。这个函数库的名字叫做 Arithmegoo，目前已经拥有数百次的下载量了。 📝 点评：请注意强调自己在工作中承担的任务，使用这样的句式：“我做了什么。”即使只是团队中的一员，也不代表你只能成为碌碌无为的无名氏。因为你肯定做出过一些贡献。 另外也不要使用模糊的总结，要给出具体的实例。 参考资料 《人人都有好工作：IT 行业求职面试必读》 - https://book.douban.com/subject/5998157/ 做好面试自我介绍，你需要知道这几点 - https://www.bilibili.com/video/BV1mJ411X776?from=search&amp;seid=9234043315787537135 如果面试官问你“你有什么问题问我嘛？”时，你该如何回答 | JavaGuide - https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/PreparingForInterview/面试官-你有什么问题要问我.md 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ （END） 历史好文推荐： 《Offer一箩筐》一份高质量「简历」撰写指南，望打扰！！ 《Offer一箩筐》求职之前你必须知道的 4 件事！！ 一文带你深扒ClassLoader内核，揭开它的神秘面纱！ 全网最通透的Java8版本特性讲解 And More… Hi，这里是 我没有三颗心脏，一个兴趣爱好广泛的 96 年 自由技术人，在公众号 wmyskxz 分享 「MoreThanCode」 的 知识/技术/成长/思考，2020，与您在 Be Better 的路上共同成长！ 非常感谢各位人才能 看到这里，创作不易，文章有帮助可以点个 「在看」 或 「分享」，都是支持（莫要白嫖）！ Somewhere not here，愿你我都能奔赴在各自想去的路上，我们下篇文章见！","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Offer一箩筐","slug":"Offer一箩筐","permalink":"http://www.wmyskxz.com/tags/Offer%E4%B8%80%E7%AE%A9%E7%AD%90/"}],"author":"我没有三颗心脏"},{"title":"《Offer一箩筐》一份高质量「简历」撰写指南，望打扰！！","slug":"《Offer一箩筐》一份高质量「简历」撰写指南，望打扰！！","date":"2020-09-14T01:05:17.000Z","updated":"2020-12-09T04:34:28.222Z","comments":true,"path":"2020/09/14/offer-yi-luo-kuang-yi-fen-gao-zhi-liang-jian-li-zhuan-xie-zhi-nan-wang-da-rao/","link":"","permalink":"http://www.wmyskxz.com/2020/09/14/offer-yi-luo-kuang-yi-fen-gao-zhi-liang-jian-li-zhuan-xie-zhi-nan-wang-da-rao/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」。 如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Hi~ 这里是 我没有三颗心脏，一个兴趣爱好广泛的 96 年 自由技术人。 都说九月十月是跳槽的高峰期 （也有金九银十的说法），所以 近期 计划出一些 面试求职 相关的文章，这里是系列的第二篇「高质量撰写简历指南」，手把手地说明了如何来编写一个高质量的简历，也算是学习分享，真心的希望对大家有所帮助，如果 觉得不错，请点赞/留言，莫要白嫖~ 另外可以持续关注一下《Offer一箩筐》系列，后续会跟大家一起品一品 面试 过程中的那些 「难啃」 、「套路」 的问题 （我觉得蛮有意思的一部分，真的是城市套路深~），还会分享一些现成实用的方法论给大家。再次感谢大家的支持和喜爱！ 01. 简历是什么我们在 上一篇文章 有过 「简历是一份工作成果」 的总结，确实，从某种意义上来说它就是你为 新公司 所做的 第一件 工作成果 （成功推销自己）。 从更广泛的意义上来说，简历不仅仅是你叩开企业大门的 敲门砖，也是你 职业生涯 和 个人 的一个 精要总结。 为什么需要简历今天的简历已经是招聘过程中 不可或缺 的一部分。 它的 起源 可以追溯到达芬奇和中世纪的熟练技术工人和工匠协会。因为 有经验的专业人士 总是需要一种方法来 突显他们的能力。 随着纸张的发明，为个人的技能和能力做广告就变得更加容易。而如今的互联网上，只需要动动鼠标就能够提交一份简历。 纵观历史，人们一直在寻找 获得就业 的途径。尽管经历了很大的变化，但简历已经成为了企业的 第一要求，没有简历，您甚至都无法开始竞争。 简历的目的是什么大多数人认为，一份好的简历能让他们获得一份工作，这是错误的。 在当今的市场中，很少有 仅仅 根据简历的内容就让公司雇佣你的情况，在真正雇佣你之前，公司都会对你这个人进行实际的考察 （面试），他们希望证实您的简历的真实性并查看你是否具有他们所寻找的个性。 所以，事实上，是面试最终帮你找到了工作，而 简历 的作用某种意义上则是通过层层筛选 获取面试的机会 （这就需要您很好地标准化地展示自己的经验和能力）。 （注意👆说的「筛选」不仅仅是 HR，也可能是 机器——特别是招聘网站上，招聘人员可以根据关键词进行筛选） 02. 企业如何筛选简历上面👆说到简历的作用其实是帮助我们 获取面试的机会。 那么什么样的简历有机会入选呢？不如我们直接从 HR 的角度 来学习一下，如何从每天大量的简历中找到适合岗位的候选人吧。 基础了解筛选简历的目的是，确定求职者与公司招聘职位的匹配程度。记住，这里指的是 匹配程度，而不是选出最优秀的人才。 这里的「匹配」不仅仅体现在工作能力上，更多 地体现在个人性格、三观、工作稳定性、职业追求和人生愿景上。 充分认识和了解招聘岗位的职责、任职资格受时间和方法的限制，HR 一般只通过简历对候选人的 任职资格 做初步推断。 基本上也就是对候选人的知识、经验、技能做一个最初步的总结要求。但在真正执行筛选这一步之前，需要先了解清楚岗位的职责、任职资格。 认识和了解岗位的方式有三种。 一是岗位说明书。公司的每个岗位都有明确的岗位说明书，主要包含两个部分：①职位描述 （职位设置的目的、基本职责、组织结构图、业绩标准、工作权限等）；②职位的任职资格要求 （工作标准、胜任职位所需的知识、技能、能力、个性特征等）； 二是用人部门负责人。用人部门负责人是对招聘岗位最了解的人，他们清楚地知道招聘岗位需要什么类型的人才。 三是同岗位的工作人员。同岗位的工作人员也是对工作流程和工作任务比较熟悉的人，招聘官可以通过这些工作人员，大致的了解他们这个岗位需要的技能、能力、知识等。 以上三种方法最好相结合，这样才能更加全面、深入地了解岗位，进而能够深入了解用人部门对人才的需求。 招聘官需要注意的是，认识和了解岗位的重点是 明确岗位的任职要求，如学历、年龄、专业等。这些任职的 硬性要求，也是筛选简历的关键。 明确什么是合格的简历一份合格的简历，里面的 信息一定是完整的。 一般情况下，简历的基本信息应该包含个人信息、教育背景、工作经历、求职意向、获奖情况、项目经历等。 简历信息的完整性，能够体现一个人的 求职态度。试想一下，如果一个人连简历都不认真做，他会认真对待工作吗？显然不会。 什么是不合格的简历有时候 HR 在招聘工作中可能会遇到这样的情形： 遇到一个求职者，从学历、履历、经验各方面来看，都非常符合公司的用人标准。但是用人部门看不上，认为不合适。 更让你不能理解的是，求职者来公司面试了，双方交流得也非常愉快，求职者也有意向加入公司，但是用人部门的最终决定是不予录用，理由是：不适合公司目前的发展需求。 这里的要点是：不要忽略求职者的需求。 招聘本身就是一个 双向选择 的过程，你在选择人才的时候，人才也在考察和选择着你。只有同时满足双方的需求，企业才有可能招到合适的人才。 因此，在筛选简历的时候，招聘官不仅仅需要关注 企业的需求，更要根据求职者过往工作平台、薪资、履历、期望等挖掘 求职者的潜在需求。 如果 双方需求 能够匹配，就可以通知匹配。否则，即使再优秀，也要果断放弃。 筛选简历的技巧硬性指标不达标，Pass！许多岗位在设立之初就会专业能力的要求。 比如程序员，一般要求有更高的学历或对口的专业，或者要有相关的从业经验；行政类、财务类工作多选择女生；有些企业，则只招本科及以上学历的求职者。 对于求职者的性别、学历、专业、工作经验、工作时间等基本信息，不符合硬性指标的简历就可以直接淘汰掉。 学会识别简历中的虚假信息 简历中常见的虚假信息有以下 4 种。 第一种，工作时间衔接前后矛盾。例如，同一时间在两个企业工作，或者在校上学期间在一家企业全职。这就明显是求职者“作假”不用心了。 第二种，夸大公司规模。明明只有十几个人的小公司却要夸大成几千人的大公司，以提高自己的含金量。要快速识别这种虚假信息，招聘官就要多收集信息，关注相关行业内中大型规模的企业。 第三种，不符合正常逻辑。如果一个求职者在工作履历中写的是曾经任职主管、经理，而现在的任职意向却是一名行政，那么这种信息很大可能是虚假信息。 第四种，全能冠军。比如明明只在一家企业担任过行政，对自己的能力描述却是各方面能力都具备。这种“全能冠军”的简历，一定是虚假的。 一定认真查看模糊字眼 大部分企业在筛选简历的时候，对候选人的工作经历、工作表现以及学历的真实性尤为重视。 而恰恰在这几个方面，求职者会用 模糊的字眼描述。 他们之所以这么做，无非是想提高自己的含金量，让自己的简历能够顺利通过。但是这种不诚信的行为，是不值得提倡的，企业也绝不会允许这种不诚信的人加入。 因此，招聘官在筛选简历的时候，一定要认真看那些模糊的字眼。 第一种，“工作经历”中的模糊字眼。 最常见的是工作的起止时间与实际不符。比如，求职者是 2019 年 7 月毕业，但实际参加工作是 2019 年 12 月，而建立中写的确是从 7 月开始工作，这无形增加了 5 个月的工作经历。 或者是把时间较短的工作经历拼凑在一起。这样就看不出来一年换了三家公司的真实情况。 面试官在看到此类信息时，一定要认真审查： 在原来公司工作的时间要明确，一定要精确到月份而不是年； 原来的公司要有全称； 在原来公司担任的职位以及职位描述； 第二种，“学历”中的模糊字眼。 比如，简历上写的毕业时间是 2019 年 7 月份，但是大学教育背景的起止时间是 2017 年 9 月— 2019 年 7 月。按照一般本科来说，全日制本科要读 4 年。 第三种，“工作表现”中的模糊字眼。 很多求职者在填写这一栏的时候，会写“表现非常出色”“为企业做出了很大贡献”等。 虽然这些主观信息不存在真假，但是这种盲目自夸、虚夸的信息从侧面反映出求职者有点自视甚高。 一般情况下，认真、诚信的求职者写“工作表现”的时候会尽量量化自己的表现，比如获得了多少次奖励、得到了多少证书等。 审查求职者的稳定性跳槽职位的连贯性，远比名校背景更重要。 为了追求更好的发展，频繁跳槽对一些职场人士来说是司空见惯的事情。但是，招聘官一定要对跳槽职位的连续性重点关注，因为这对筛选简历而言，远比名校背景更重要。 学历代表的是过去，而职位的连贯性代表的是未来。 例如，求职者在上一家公司担任的职位是运营部经理，跳槽之后到下一家公司是高级经理或运营总监，那说明跳槽职位连贯性比较高，这类求职者在该领域的专业技能和知识都有保证； 如果求职者在上一家公司担任的职位是运营部经理，跳槽到下一家公司的职位是销售，再跳槽到下一家公司的职位是财务，那说明跳槽职位的连贯性比较低，这类员工看上去拥有很多技能，但是每一个技能都不精通，而且对工作没有耐心。 一般情况下，猎头顾问就会直接剔除这类简历。 另外一方面，如果求职者的工作经验是 横跨 几个行业的，证明求职者对未来缺乏明确的工作规划和职业发展规划。 拒绝一切花里胡哨有一些所谓的经典简历模板真的是堪称「经典」： 也有一些堪称「魔幻」： 简历应该是 重点突出、内容清晰 的 有效信息，而不是影响心情的「视觉噪音」或者「视觉垃圾」。 03. 如何写一份高质量的简历一份高质量的简历本质上还是自己突出的 核心竞争力。 在了解了企业是如何筛选简历之后，我们来学习一下如何针对性地撰写一份高质量的简历。 第一步：两个重要的问题在我们开始撰写我们的简历之前，我们需要细致地梳理工作要求，并且询问自己两个重要的问题： 1 我能胜任这个工作吗？有抱负当然是好事情，但是申请一个自己 高不可攀 的工作只会让自己失望。因此，诚实地面对自己的技能和资质 很重要。 如果你符合其中 3/4 左右的工作要求，那么这份工作还是很值得 尝试 一下的。 但如果目标公司寻找的是远高于自身条件的员工的话，你还是最好把眼光放低一点儿。 2 这家公司到底在寻找什么样的人才？比如，我们在前程无忧上看到一条招聘信息，招新媒体运营主管，地点在上海。 我们先把 JD （Job Description，职位描述） 中反复出现的词语圈出来。 发现 “策划/运营” 和 “数据分析” 是重要能力，而全篇里提到的软件技能只有 “H5”，说明这是关键技能。 那么，如果你工作经验有优势，就用它证明你的策划和运营能力；如果你技能上有优势，就说清楚你的 H5 和数据分析是个什么水平。 重点是记下他们正在寻找的技能和资质，这样你就可以确保自己的简历符合那些要求。 第二步：基础信息尽管写简历并没有所谓的 “标准” 公式，但是阅读简历的人一定希望从你的简历中得到关于你的某些 特定信息。因此，你的简历 至少 得包含以下的内容： 联系方式； 工作经验； 教育背景； 工作之外的其他相关成就 （如果你觉得自己的经历还不够丰富）； 关键词以及技能列表； 联系方式 姓名、电话号码和电子邮箱地址是简历的最基本内容 （通常也会放在最醒目的位置——简历开头），不然 HR 想要找到你可太难了。 当然，你也可以增加一些链接到其他专业的社交媒体，比如个人博客、领英等。 ⚠️ 但是注意 不要 把 当前的工作电话 写进联系电话栏中。 关于照片要不要贴，建议是：形象优秀的可以贴。（互联网行业没有严格的要求） 关于简历上有没有照片的区别大吗这个问题，答案一定是肯定的。 HR 每天要查看成百上千份简历，成百上千，密密麻麻的都是字啊！如果这个时候出现了一份带照片的简历，恰好来人面容清秀干净正直，多么让人眼前一亮感激涕零啊。 如果一定要贴照片，最好是 PS 过的证件照。但也请一定避免以下的“自杀式”照片： 图片来源：「知乎问答」简历里有照片好还是没有好？ | @前程无忧51job招聘小助手 （下方有链接） 工作经验 过去的工作及你能很好地预示你在今后工作中的表现，所以工作经历应该是占简历篇幅最大的部分，除非你没有相关的工作经历。 这通常应该以 倒叙 排列，将最近的经历放在第一位。 如果是刚毕业的应届生，没有工作经历，也可以把在校的项目经历写上。 另外工作经历应该凸显的是在职的职责以及给公司带来了什么效益，不需要详细写技术栈和项目细节，例如： 作为组长负责设计和开发 分布式网络爬虫系统，优化爬虫策略和防屏蔽规则，提升网页抓取的效率和质量。 根据行业需求分析设计方案可行性，对项目代码进行测试优化，协助持续集成与自动化部署，提高系统可用性。 负责 EngineGo 爬虫系统技术文档的编写以及维护，定期 review 团队的代码，定期组织团队技术分享。 另外也请 避免无意义的描述，这一点是说：适用于所有人的信息无用，以及量化的信息更具有价值。 在 Github 的 awesome-resume 项目中，也有一些在写 简介/工作经历/项目经验 时常用的一些例句，大家可以拿来参考：（项目地址：https://github.com/resumejob/awesome-resume） 有良好的代码风格，通过添加注释提高代码可读性，注重代码质量，研读多个开源项目，学习改善代码的健壮性与扩展性。 有良好的代码编写习惯，具有良好的沟通、协作能力能力，有良好的职业道德和较强的工作责任感。 理解操作系统中 进程、线程、死锁、虚拟化、文件系统 等原理和简单实现。 有 大型互联网分布式系统 的架构设计和开发经验，拥抱新技术，有很强的学习能力。 有扎实的计算机理论基础，良好的算法与数据结构基础，了解计算机基本原理与常见机制。 ……. 工作经验写作 Tips： 1、简历并不是你的记录档案。除了注意不要把原先工作的电话号码、地址或者任何联系方式写进简历外，任何对你能力体现无用的你都可以略去（如果面试官想知道你离职的原因，她自然会开口问）。 2、开源项目为职业生涯灌注力量。着手一个开源软件（OSS）项目，无论这个项目是你自主开发的还是原本已有的，对你来说都是一份实实在在的工作经验。这既能显示你有编写代码的能力，又表明你能很好地和团队合作、与他人相处。而且，这些工作经历是雇主可以找到和验证的。 3、列出不同阶段的职位凸显进阶。 4、把重点放在陈述的事实上，而不是花哨的词汇上。有时候确实使用一些漂亮的主动动词会起到一定效果，但能在内容上多下功夫更为重要，更细致更丰满的描述才能更加打动人。（比如：「在 6 个月之内使网站流量增加 50%」——同时列举你为此采取的行动） 5、可量化的信息更有说服力。例如 「将每日网站流量增加 10000 次」 并不能让读者形成一个明确的概念，而 「将网站流量增加 40%」 就做到了。此外，还应该将时间跨度也说明清楚。「将网站流量增加 40%」 并没有说明这个变化是花了多少时间做到的，加上一个时间跨度的说明就清楚多了。 6、强调对雇主的价值。在为以前每个岗位添加要点条目时，需要强调你或独立完成或参与完成的工作成果，强调你为公司、为部门或者为了某个产品的提高作出了怎样的贡献。即使身处最普通的岗位，你也可能为公司的发展做了一些事。 （另外下方👇介绍的 STAR 法则也是优化简历的一把好手） 教育背景 教育背景的部分的基本内容就是要将你所完成的 高等教育 机构名称以及你所获得的学位分别列举出来 （请注意我们说的是高等教育，意思就是高中就没必要写了）。 如果你是学霸，那么 高绩点/高专业课分数/奖学金/比赛获奖 这些都可以选重要的加上 （例如 xxx竞赛一等奖、国家一等奖学金）。 跟 岗位相关 的事情也可以写上。比如你目标职位是 平面设计师，那么大学期间参加了 XXX设计比赛，没得奖都没关系，都可以写上，但是当过什么班干部之类跟岗位没什么关系的事情，意义就显得没那么大了。 技能列表 一个典型的错误表现就是技能列表 信息过多，缺乏重点 的情况： 求职者希望尽可能多地展示自己的经验和能力，但结果却适得其反。（大部分人阅读大段文字是跳读的，不信你看第 3 点和第 14 是一样的，不知道你有没有发现） 技能列表应该遵从 简短清晰 的原则，尽可能地让外行人也能快速定位技能。 以下是比较推荐的排列方式： 后端框架：Spring/ SpringBoot/ Django/ Flask 前端框架：Vue/ React/ jQuery 数据库：Redis/ MySQL 关于技能的 熟练程度，这确实是 仁者见仁，智者见智 的事情，首先很可能面试者不能正确评估自己的技能程度，其次 HR 对于程度词的理解不一样，所以也有建议说就 不要写熟练程度 了的建议，关于这一点我没有很好的建议。 不过倒是很有必要地认识到，这一 Part 的作用有点类似于 “关键词”。 （特别提醒注意一下技能的拼写和完整程度，这有助于筛选简历时能够进入到搜索结果中） 其他成就比如你对开源社区作出过杰出贡献、拥有个人开源项目 （能拿出手的）、拥有个人博客等等，都可以作为加分项加入简历。 第三步：修改简历现在你已经有一份基础的简历了，在把你的劳动成果发送出去等待招聘官审阅之前，你还要确保完成 修改 的步骤。 避免粗心的错误通过前面的几个步骤，你已经完成了简历内容，还要修改一下你可能没注意的一些问题，像 错别字、语法错误和格式错误 等这些由于粗心造成的错误。 不管你的成就多么令人印象深刻，如果你的简历充满了因粗心而造成的错误，你将很难说服任何一个招聘经理，并让他相信你在工作中不会这么粗心。 另外 拼写方面 的细节也需要额外注意，iPhone 不要写成 IPone，macOS 不要写成 MacOS 之类的。 确保简历读起来流畅下面👇是一些确保简历可读性的几种方法： 将简历缩短至一页。以前我还蛮信奉“一页纸”简历的，但是看过一些简历之后，发现确实一页纸没办法满足所有人的需求，总之总体原则就是要精简。 要有页边距。没有人愿意看满满一页都是字的简历，你需要给简历的内容保留一点“阅读空间感”（每一段的内容同样适用）。 不要在字体上玩儿创意。使用常见的字体就可以了，可以用黑体字和斜体字标出关键信息，如公司或者岗位。但是不要太“过分”，当简历的阅读者弹出“无法找到xxx字体”时，可能情况就不那么酷了。 去掉口语化叙述。一份优秀的个人简历，基本上都不会在文字中出现“我”，并且尽量都是，使用动词开篇的祈使句，例如：「使用 Scrapy 开发异步爬虫系统，构建 IP 代理池，优化爬虫策略和防屏蔽规则，提升 200% 网页抓取速度」。 针对性的突出优势就像我们👆写简历之前问的「这家公司到底在寻找什么样的人才？」这个问题里面回答的，要根据招聘要求突出自己的优势和能力，尽可能的让自己与岗位 匹配。 另外一点提醒是，求职者经常过分强调自己需要得到某一具体职位，但是招聘经理知道你想得到这个工作，他要招聘最适合这个岗位的人，而不是最需要这个工作的人。 所以，你一定要 强调自己的优势，无须过多地解释你是多么热爱这个工作。 优秀工具推荐在线写简历神器：超级简历 官方网址：https://www.wondercv.com/ 不仅仅拥有海量的 简历模板，并且还有自动一页纸（自动排版）、一键优化、引导示例等功能，结合我们👆提到的方法，非常轻松地就能够写出非常 专业的简历。 简历优化神器：STAR 法则这应该是求职面试里，提及最多的一条规则了，甚至是面试官，在收集面试者与工作相关的具体信息和能力的时候，都离不开这个法则。 简而言之，STAR 法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的逻辑模板。 通过 STAR 法则，能够高效快速地让对方了解到，一件事情的来龙去脉，以及最终成果。 （⚠️注意，STAR 能够保证大体方向不错，但也要活学活用，例如上图中写在简历中的可能就是最上面的一句话——不要让简历显得过分臃肿——但是展开了说可能就是下方 STAR 原则分析的内容） 04. 高质量简历 “味道”大神们的简历乔布斯乔布斯 40 年前的求职信在 2018 年的某拍卖行上，被拍出了 17.4 万美元的高价，不过这份简历似乎根本入不了当今的 HR 们的法眼： “Steve Jobs” 中的字母 “J” 没大写就算了，居然连应聘公司惠普的名字都写错了。 最搞笑的是，日后把智能手机卖给全世界的乔布斯大神，在电话号码一栏写了 “无”。 达·芬奇相比之下，达·芬奇在 450 年前写的简历就让他成功获得了米兰伯爵的垂青。 达·芬奇是真心想要去米兰，所以对求职的认真度会 100% 体现在你的简历上，根本造不了假。 与乔布斯的 “随便写写” 相比，达·芬奇的态度是很直观的。 达·芬奇求职信来自于知乎答主 @warflcon 的翻译： 罗永浩无独有偶。近几年，锤子科技创始人罗永浩卖手机讲段子，几乎让人忘了 2000 年时，他还曾经是新东方学校的任课教师。 当时罗永浩给北京新东方学校校长俞敏洪写了一封求职信，在两次试讲失败后，给了他第三次试讲的机会，终于成功。 当时罗永浩写给俞敏洪的求职信也可圈可点： 针对雇主的招聘需求，有的放矢；风趣跃然纸上，实力诠释“幽默感”；生动有个性，容易脱颖而出。 从大神身上学到的经验好的简历不是赢在字多，而是能够找准公司的需求，言简意赅地说明能力。 而简历的范本还可以追溯到战国时代，看看大诗人屈原是如何用文言文完爆职场的。 能把简历写成楚辞，也算是一代风流名士。 当然了，也不是所有大佬的简历都是正确的示范。 一份优秀的简历一份优秀的简历看起来应该是这样的，排版整洁，重点突出： 脱颖而出靠的不是设计，不是颜色，也不是可视化图表，最能够打动 HR 和让他们眼前一亮的是，干净有序的模块 和 扎实的描述，每段经历都能看出来你确实做了很多事情，有能力有价值。 总结 总的来说，你可以把简历当成一款产品来打磨，一切都是 针对性 地突出自己的优势，以此来获取面试机会以达到最终求职的目的。 另外公司和求职者应该如同所有好的关系一样：互相成就。 至少我们完成了建立这个友好战略合作关系的第一步：写一份高质量的简历。 下一步我们将进一步揭开面试过程中的那些「套路」和「难啃」的面试问题，请关注 wmyskxz 公众号进一步关注《Offer一箩筐》的后续内容！另外 公众号后台 回复 【简历模板】 （不带【】） 可以获取 程序员专用简历模板 哦！ 真诚地希望对大家有帮助！觉得有用的麻烦动动小手 点赞/留言 吧，创作不易，切莫白嫖~ 参考资料 《人人都有好工作：IT 行业求职面试必读》 - https://book.douban.com/subject/5998157/ Why You Need a Resume - https://www.roguecc.edu/emp/Resources/resume.asp The World’s First Resume is 500-years Old and Still Can Teach You a Lesson or Two - https://business.linkedin.com/talent-solutions/blog/recruiting-humor-and-fun/2015/the-worlds-first-resume-is-500-years-old The History of the Resume - https://www.davron.net/history-of-the-resume/ 《深度成长：有效调用你的每一分潜力》 - https://book.douban.com/subject/33393450/ 「知乎问答」简历里有照片好还是没有好？ | @前程无忧51job招聘小助手 - https://www.zhihu.com/question/19761379 「知乎问答」HR 怎样筛选简历并安排面试比较高效 | @人事星球 - https://www.zhihu.com/question/26477466 「知乎问答」如何制作高水平简历 | @小红拖拉机 | @王释易 - https://www.zhihu.com/question/21187514/answer/137107187 程序员如何写一份更好的简历 - https://zhuanlan.zhihu.com/p/38431524 面试官到底想看什么样的简历？ - https://juejin.im/post/6844903879973273607 乔布斯的简历 17.4 万拍卖，HR 看了想打人.. - https://zhuanlan.zhihu.com/p/35865680 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ Hi，这里是 我没有三颗心脏，一个兴趣爱好广泛的 96 年 自由技术人，在公众号 wmyskxz 分享 「MoreThanCode」 的 知识/技术/成长/思考，2020，与您在 Be Better 的路上共同成长！ 非常感谢各位人才能 看到这里，创作不易，文章有帮助可以点个 「在看」 或 「分享」，都是支持（莫要白嫖）！ Somewhere not here，愿你我都能奔赴在各自想去的路上，我们下篇文章见！","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Offer一箩筐","slug":"Offer一箩筐","permalink":"http://www.wmyskxz.com/tags/Offer%E4%B8%80%E7%AE%A9%E7%AD%90/"}],"author":"我没有三颗心脏"},{"title":"《Offer一箩筐》求职之前你必须知道的 4 件事！！","slug":"《Offer一箩筐》求职之前你必须知道的-4-件事！！","date":"2020-09-07T23:49:00.000Z","updated":"2020-12-09T04:34:24.294Z","comments":true,"path":"2020/09/08/offer-yi-luo-kuang-qiu-zhi-zhi-qian-ni-bi-xu-zhi-dao-de-4-jian-shi/","link":"","permalink":"http://www.wmyskxz.com/2020/09/08/offer-yi-luo-kuang-qiu-zhi-zhi-qian-ni-bi-xu-zhi-dao-de-4-jian-shi/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」。 如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Hi~ 这里是 我没有三颗心脏，一个兴趣爱好广泛的 96 年 自由技术人。 都说九月十月是跳槽的高峰期 （也有金九银十的说法），所以 近期 计划出一些 面试求职 相关的文章，这里是系列的第一篇「求职之前需要知道的 xxx 件事」，盘点了求职过程中比较重要的一些事情，也算是学习分享，真心的希望对大家有所帮助，如果 觉得不错，请点赞/留言，莫要白嫖~ 另外《Offer一箩筐》这个系列打算做的稍微深入一点儿，自己甚至偷偷学了几天怎么当 HR… 果然是每一行有每一行的门道… 套路太多了，也发现了很多现成的很好的 方法论，后续都会整理跟大家分享 （特别是我觉得那些面试套路问题挺有意思的），大家可以关注一下 wmyskxz 公众号来持续关注一下！再次感谢大家的支持和喜爱！ 第一件事：贯彻职业生涯的 7 个基本原则在求职的过程中，下面所列举的这些基本原则必须贯彻始终，并延续至你的整个职业生涯。 上面这些基本原则相互关联，互相依存，并贯彻你的整个求职过程。也就是说，作为一个问题解决专家，你得懂得如何推销自己，因为你知道那正是老板想要的，然后通过讲故事举实例的方式让他知道你绝对能胜任这份工作。 1 - 诚实对己这世上没有什么比欺骗自己所带来的结局更悲惨的了。 所以你需要问问自己，到底想要的是什么？你的技能有哪些？你想从工作中获得什么？你在逃避什么？哪些对你来说是首要的？你真的只是想要给别人打工吗？你是否真的能胜任眼前的工作？ 当然，你心底很清楚这些问题的答案，但同时也渴望着一份新工作，因此你往往用谎言来欺骗自己。 世上有很多人每日将自己痛苦地置身于烦心的工作中，这都是由于他们在什么是重要的以及自己的能力水平方面自欺欺人所造成的。 例如，如果你真的很讨厌 Java 方面的工作，面对近在眼前的工作截止日期，不断催眠自己「Java 也许没那么糟」，这对项目的完成是不会有任何帮助的。当初你假装自己是个 Javaer 而得到的这份工作，注定也不会有一个好结果。 2 - 诚信待人在任何时候你都不能对他人说谎。 注意这里并不想讨论关于善意的谎言或者其他关于谎言的任何观点，这里只是从求职的过程中出发。这里想说明的是：别对你究竟能做什么、懂些什么、过去做过些什么含糊其辞。 赤裸裸的谎话当然容易避免，但正是那些模棱两可的说辞才是最难以抗拒的。 比如当别人问你「你了解 XXX 吗？」，别以为你因为有过类似的经历，或者说回家路上刚好买过一本《XXX 入门指南》就能够轻易的回答「是」。 在这里，我们姑且先撇开道德层面的论调，这类含混其辞的谎言，其直接后果就是：你总会被揭穿的。 谎言埋下的隐患永远不会消失。 有时应聘者会习惯于隐瞒过去的一些不愉快。比方说你在简历上写着上一份工作时间是从 2017 年至 2019 年，而实际上那份工作只做到 2018 年。 当面试中你被问到「是否被开除过」的问题时，你回答「没有」，暗想老板应该不会发现。 但你不知道，这些欺瞒都会埋下隐患，像个定时炸弹一样时刻相伴着你。假设你得到了这份工作，已经顺利干了一年。某天你和同事吃午饭的时候无意聊起自己曾被开除的事情，刚巧那个同事又和你的老板说起这事，得，这下可好，老板发现你撒谎，他要么马上开除你，要么再也不相信你。 现在看看到底谁最吃亏。 3 - 像老板一样思考学会模仿老板、面试官或者是 有权决定 雇你的那个人的 思维方式，他们必定是你将长期一起工作的人。用她的思路想问题绝对是有好处的。 要试着了解，她想要的是一个怎样的员工？你如何才能减轻她的负担？怎样做能让她高兴？是的，你的工作就是让她高兴。 “让你的老板高兴”，这听起来很荒谬、很势利、充满了政治目的，但实际上完全没那么阴暗。 “让你的老板高兴” 是通往更高目标的一个心理上的捷径。表面上你的工作只是写代码、设计网页，或者是做网管，但实际上所有这些工作都是为了让你的部门顺利达到预期目标。 事实是，如果每一个人都能达到他们的上级新设定的目标，那么整个公司的目标便随之达成了。这是所有拥有等级制度的公司都将遵循的工作基本原则。不管这个公司分两个等级还是十个等级，这个基本原则是不变的。 这也就清楚地告诉了你在求职过程中该如何处理和公司、面试官的关系。 你可以先准确弄明白你的面试官对你有什么需求，又希望你如何满足这些需求。当然，你还可以进一步扩大视野范围，去弄清整个公司的需求，但是最好还是先把重点放在面试官上。 当你准备为此公司准备简历和面试时，首先就需要知道这一切。 4 - 做一个问题解决专家要知道，你未来的老板愿意录用你只会出于一个原因，那就是 帮他解决问题。 老板真正需要的是一个能帮助他 主动完成工作任务，并能 主动解决随之产生的问题 的人。他雇你可不是想听你说：“老板，那儿有堵墙挡着，我穿不过去网线，你说该怎么办？”他想听的是：“我已经布置完网线了，刚才遇到了点小麻烦，不过已经顺利解决啦。” 比起写代码的水平，未来的老板更关心你如何将这一技能应用到一个高难度的项目中。 比起你网络维护的水平，未来的老板更关心你如何建立一个备份系统，为将来可能发生的问题制定一系列应对方案。 按部就班地完成一个项目是一种技能，但在遇上危机时懂得怎么让项目重回正轨，要求的又是另一种更高的技能。 5 - 推销你自己推销你自己并不代表你得伪装成另一个人，也不代表你得去争取一份并不能胜任的工作。 的确，推销自己看起来似乎违背了之前说的两个原则，「诚实对己」和「诚信待人」。 但事实上这里说的推销自己，是让你学会 尽可能最全面地展现自我，包括展现那些你感兴趣的公司或个人并不一定能立刻发现的能力。 通过推销自己，你才能让人们意识到你想让他们知道的东西。 在工作中，在这个资源共享的世界中，你可以通过提出自己的主张，然后把这个主张推销给周遭的人来达到目的。 相应的，在 投简历 的时候，你的主张就只有一点，那就是「我认为您应该雇我」。 所以关键是，你需要 积极主动 地展示你的才能、证明你的资质，而不是 等着别人来要求你展示。同时你也可以展示一些公司没有明确要求的能力，只要这些能力有可能为公司带来利益。 6 - 讲故事，举例子推销自己最佳的方法就是学会讲故事。这些故事可以向大家证明你究竟是怎样的人，你有哪些能力，以及你在过去是如何为人处世的。 工作中的小案例可以强有力地说明你的执行能力。最重要的是，听者可以根据这些小故事和小案例对你做出评判。 请一定避免以下这些十分常见却又毫无意义的句子： 对每个人都适用的自我描述是毫无意义的。 与其简单地定义自己十分“努力工作”，不如举一些 具体的实例，让面试官自己做评判。要用过去的行动证明你一直在努力工作着，而不是单纯地说 “我工作很努力”。 🙋‍♂️ 例如你可以说：“我最近完成了一个历时 5 个月、长达 5 万行的代码转换项目。尽管在完成限期到来的三周前，原本的四人团队中有一位重要成员离职，但是我们依然拼尽全力按时完成了这个项目。” 💁‍♀️ 面试官听到这些就会自己在心里评评看：大项目、努力完成工作、没有掺杂自我评价、呈现的都是铁铮铮的事实，是个好同志！ 那么“强烈的职业精神”又该怎么陈述呢？ 🙋‍♂️ 试试看这么说：“几个星期前，我所在的团队要为公司 300 台电脑的 Office 软件升级。为了不影响大家平时的正常工作，我们利用了自己的周末休息时间。直到周日晚上我们仍马不停蹄地工作着，饿了就叫点比萨外卖。最终保证了公司同事都能在周一早晨一如往常地准时开工。” 上面提到的那些例子都是在说面试，但其实这些对于书面的阐述同样有效。 尽管简历中你没办法在有限的页面里如同口头陈述般生动地说明，但你绝对可以用一句 「按时完成 90% 的参与项目，所用花费未超过预算 10%」 来代替你那句生硬的 「我十分值得信赖」。 7 - 保持积极心态永远不要说上一任老板的坏话。 如果应聘者不停地抱怨他刚离开的地方有多糟糕，那么面试官不禁会想，要是让这个人加入自己的团队他又会生出怎样的抱怨。 不说坏话这个建议很好，但是对于应聘者来说还 远远不够。你同时还需要保持一份积极的心态，并体现在一切为人处世中。 没人喜欢爱抱怨的人，和爱抱怨的人一块儿工作毫无乐趣可言。爱抱怨的人只会告诉全世界：“我对自己的人生束手无策。” 爱抱怨的人给人的感觉就是对任何问题都没有能力掌控。他们总是被世事所击倒，而永无回天之力。爱指责别人的人总觉得出了问题与他们无关，责任永远都在别人身上。所以大家最不愿与之共事的就是这样的人。 让心态积极向上的 最佳方法 就是 避免讨论 和你 无直接关联 的问题，或者是那些你 永远也没法解决 的问题。说实话你也没必要为了别人的问题瞎操心。 “保持积极的心态” 除了能让你求职成功的机会大大增加之外，还能让你的人生更快乐。 第二件事：了解招聘的 7 步全流程除了了解老板的高层级目标之外，你还需要了解整个招聘过程。 要知道，公司招一个人是需要成本的，而且 成本不低！员工的劳动报酬支出占了公司总支出相当大的部分，而且对于经理来说，招聘要得到批准也是需要花费很多时间和精力的。 一般说来，在明确招聘需求后，部门经理需要先向上级提出为本部门增加人力的申请。她需要保证增加人员之后，公司生产力提高带来的收益将高过公司所要增加的薪酬支出、器材消耗与空间占用。 通常，公司某方面的短缺是决定招聘的关键。 也许这一次招聘，是由于程序员花费在维护数据库的时间过多导致项目进度缓慢，因此负责招聘的经理觉得有必要招一个专门的数据库管理员。 或许是技术支持的缓慢响应令人难以忍受，导致公司需要引进新人才。 所以，如果你能了解到是什么原因导致公司急于招人，就有办法调整你的工作方向去迎合公司这些需求。 在多数情况下，公司招人的目的并不是为了设立一个新增岗位，而是为了填补一个旧员工离去后的空缺。这个旧员工要么是已经另谋高就，要么是能力不足被炒了。 能打听到这些方面的背景资料也能在一定程度上帮助你调整工作目标与求职过程，以最大程度发挥你的优势。 招聘也并不是随便一个人就可以说了算的 （至少在一些拥有良性运作机制的公司中不是），你需要清楚了解招聘的全过程，然后再把这些信息有效地应用到你的求职中。 另外，当你艰难完成整个招聘过程，可不要忘了这个过程无论是对于你，还是对于你的经理而言，同样都是费时又费神的。 招聘经理所做的这一切努力，都是为了同一个心愿：「但愿这人是我真正想要的。」那么，现在就请你满足她这个心愿吧~ 第三件事：关于简历必须知道的7点总结1 - 简历是写给特定读者看的有一种说法是：简历是写给 HR 看的。 这当然显得 片面 了些，但反应的核心值得我们考量：公司最先 接收并查阅简历 的人大概率就是 HR （部分小型企业或许会是对应需求部门的领导），这直接 决定 了你是否有 资格 过去 面试。 又由于招聘人员每天要浏览大量的简历，而且又可能随时被打扰 （用户场景）。因此你的简历应该 结构性 地，言简意赅 地，直接 地表达你的 工作价值。 其实简历就像产品一样，你只有明确了以上的问题，你才知道简历上应该放什么，该放多少； 只有明确了对方需要什么样的人，才能有 针对性 的体现自己的优势。 2 - 写简历没有所谓的“标准”方法求职者往往会假想一个简历审查官的存在。 这些审查官手握警棍阔斧，神通广大地审阅每一份还在编写中的简历。他们会进行严格的审核，随时准备把那些没有遵守「简历黄金法则」的人狠狠惩罚一顿。 “我的工作履历应该以怎样的顺序排列？”“简历超过两页到底行不行？”“我是不是得加一个‘教育背景’的部分？” ⚠️ 写简历没有所谓的“标准”方法。 尽管简历确实有着一些 约定俗成 的 惯例，而且阅读简历的人也的确会希望能从你的简历中找到一些 固有的内容，但是确实没有必要担心 HR 一怒之下就给你的简历画红叉。 永远 带着疑问 去看待你的简历，审视 它的 结构，并带着批判的眼光去学习简历指南书籍传播的内容，包括本文的观点。用你自己的判断来做最终的指导。 3 - 把简历当成一个花园要把简历当成是一个花园，栽种 新鲜 的植物，铲除那些 枯萎 的。 打理好花园的另一个关键是：定期打扫。 这样做的好处有很多，比如让自己保持危机意识、减少记忆负担、让猎头发现你、温习技能等等.. 4 - 没有人会一字一句读你的简历没人会一字一句地读你的简历，除非他有不得不那么做的理由。 你也许的确是一片非常美丽的雪花，但是要知道招聘经理面对的可是一场暴风雪，所有的雪花对他来说都没什么区别。 所以你的 首要任务 就是吸引他的眼球。这就是为什么你需要在简历最前端呈现一份 简明扼要 的陈述，来说明你是什么人以及能为公司带来什么 独特价值，因为这样才能让他一眼就能看到。 时刻谨记你是在向谁推销自己。 即便只是像工作经历那么基础的部分，也要随着你的应聘对象的不同而有所调整。简历中一位招聘经理不感兴趣的部分也许是另一位招聘经理最关注的地方。所以你必须清楚了解你的目标对象才行。 5 - 简历不是纪录档案请注意，千万 别把在原先公司的电话号码、地址或者任何联系方式写进简历。别让你的简历又成为档案记录。当然，在与求职过程相关的情况下，你可以把原公司的网址加上。但要是旧东家是特别知名的公司，那连加网址也没必要了。 另外，有一个 非常普遍 的 错误认识 就是万不能在简历中留有 失业空隙。 在《人人都有好工作》一书中有这样一个例子： “我曾经收到过一份简历，上面写有一行篇幅很短但是足以吸引眼球的工作经历，那就是应聘者曾担任镇上的喷药车司机。这位应聘者有着10多年的编程经验，但是很显然他曾经有2年没法找到相关的工作。我猜他担心留着这2年的职业空缺对自己的求职不利，所以就加上了这份喷药车司机的工作。” 事实上，你根本不需要在简历中解释你的职业空白期。如果面试官对这些具体的细节好奇，她自己会在面试中开口问的。 6 - 可量化的信息更有说服力可量化 的信息对于面试官来说是非常具有 吸引力 的，他们也十分有可能在面试过程中与你讨论这些信息。 请确保你能在面试时将写在简历中的数据流畅地说出来，而不是支支吾吾。 如果你不得不使用估计的数据，那么一定要说清楚这只是一个估计值，并准确地提供这些估计的来源：「创建全新资产跟踪系统。据仓库经理估计，此举将纸面报表减少了 75%。」 如果可以的话，尽量将一些具体的数字改用 百分比以及走势 来说明。说 「将每日网站流量增加 10000 次」 并不能让读者形成一个明确的概念，而 「将网站流量增加 40%」 就做到了。 此外，还应该将 时间跨度 也说明清楚。「将网站流量增加 40%」并没有说明这个变化是花了多少时间做到的，这会让读者猜测究竟是一周还是一年。加上一个时间跨度的说明就清楚多了。 ❓ 如果你不知道具体的数字怎么办？ 那么只好不添加数据，但这样一来你的说服力就小很多。所以你需要从现在开始经常 留意用数据衡量工作，以便随时完善简历。 7 - 简历是一份工作成果从某种意义上来说，简历是你为新公司所做的第一件工作成果。 阅读这份简历的人比你想象的可能会多那么一些，所以它必须尽可能地完美！ 简历让每一个读这份简历的人对你的工作能力与工作自豪感留下印象。若对自己的工作缺乏自豪感，这也会在简历中体现出来。 如果你所在的是一个 关注细节 的技术行业，那么你的简历与你对于细节的态度一定也要反映出你是一个关注细节的人。 另外，如果你是那种觉得 「内容」 和 「表现形式」 纯属两码事的人，那么为了你的简历与今后的职业生涯着想，是时候改变这种 错误观念 了。 千万别认为自己关注的是编程工作，视觉设计就完全无关紧要了。要知道表现形式也是简历内容的一部分，简历并不只是简单的文字堆砌。 如果表现形式不属于内容的一部分，那么杂志都该用等宽字体！ 即使简历中的内容完美无瑕，但要是它的表现形式对读者完全没有吸引力，那么阅读它的兴趣自然也会大打折扣。 第四件事：求职过程 8 不要1 - 不要让自己的面试时间有冲突⚠️ 下面的场景会让求职前景 付诸东流水：面试进行得很顺利，招聘经理看起来对你的表现也很满意，双方都对对方表现出强烈的兴趣，可这时候你却说：“哎呀，我倒是很乐意和总裁见面，但是今天家里看孩子的保姆只能待到 5 点钟。” 请将面试当作生命中唯一重要的事情来对待，因为此时此刻，它就是唯一重要的。 不要让自己在面试时还需要顾虑时间冲突，应该把时间都腾出来好让自己 心无旁骛。 这不仅仅是因为不断地看表是不礼貌的表现，更是为了让你能百分百集中精神应对面试。而且通常情况下，如果面试进行的时间较长，这是个好的征兆，因为这表示对方对你很感兴趣。 2 - 不要面试迟到对于大多数面试官来说，迟到也就意味着应聘者没法跟上工作节奏。所以请保证自己能提前到达面试场地。 在预估的花费时间之上再加 20% 至 50% 的 缓冲时间。如果旅途顺利，你可以带本书到停车场或是附近咖啡馆消磨多出的时间。当然，最好还是利用这段时间重温准备好的问题、查阅参考文件以及做好的备忘，让自己达到最充分的准备状态。 3 - 不要把简历当记录档案上面我们也提过了，千万 别把在原先公司的电话号码、地址或者任何联系方式写进简历。 别让你的简历又成为档案记录。请记住，你是在推销自己，而简历是推销的第一关键工具！ 事实上，任何面试中不可能被问及的内容都不需要出现，比如照片（长得精神可以贴一下）、职业目标、兴趣爱好、无关的工作经验等。 4 - 不要透露你过去的薪水有些时候你会被问到上一份工作的薪水，这时千万别透露这方面的信息。 当招聘公司询问你的过去薪酬时，他们只想根据你提供的信息做一些对他们有利的决定，而这些决定绝不会为你带来任何好处。 用你的期望薪酬水平来回答公司对过往薪酬的疑问是个好办法。 不用为拒绝告诉招聘方过去的薪酬而感到不安，因为你根本 没有义务 这么做。有时招聘公司会说：“我们只想大致了解应该支付你多少薪水。”但这根本就是瞎说。下面这些就是理由。 你能为公司带来的价值并不能通过其他公司支付的薪水来决定。 过去的薪酬水平会成为今后这份工作的薪水最可怕的指标。 你在过去的工作中所得到的也许并不止单纯的薪水。 上一份工作的薪水也许是少于或多于你应得的水平。 想改变收入是你自己的事，与他人无关。 提供自己的过往薪酬将诱使你虚报真实薪酬。 避免这些麻烦有一个很好的方法，那就是告诉问这个问题的人：“对不起，这是保密的。” “保密” 这个词最合适用来应对那些不愿意回答的问题。如果对方问起保密的原因，你只需要说：“我从不和别人谈论这个问题。”这绝对是礼貌的回答，你也得坚定自己的立场。 如有必要你可以对此进行练习。因为你很有可能会被问到这个问题，那么就要提前准备妥当。透露过往薪酬对自己绝没有好处，所以当问题抛过来时一定要表明立场。 5 - 不要抱怨以及不尊重他人不管在面试中发生了什么，都不允许有抱怨以及不尊重他人的表现。 如果你说上司的坏话，那么面试官同样会觉得过不了多久你也将开始说她的坏话。即使你只是针对现在的同事，这样的表现也只会让自己被贴上抱怨者的标签。 当你在回答一些负面的问题时 （例如你最大的缺点，一个失败的项目，团队中的某个讨厌鬼），你都需要在后面加上一个解释，说明自己是如何处理最终让情况有所改善的。 6 - 不要用讽刺的口吻说话可能在求职过程中会遇到对方询问禁忌问题或者其他不合时宜的问题。这时候请用宽容的心面对面试官的疑问。 千万别用讽刺的口吻说话。不要让自己听起来充满了侵略性或是把面试官置于一个下不来台的境地。 如果他意识到自己的错误，那么此刻他自己就会觉得尴尬。 7 - 不要草率地把自己安顿下来求职的第一个问题是：你是否确认这家公司真的值得你追求。 如果你根本没觉得自己想要从事这份工作，那就别浪费时间和精力在那上面了。 除非你为自己定的标准极低，可话说回来 毕竟不可能有 100 份适合你的工作，所以只需将精力集中在有申请价值的那几份上即可。 宁可花大把时间在某份你十分合适的工作上，也不要同时对三四份并不怎么样的工作浪费精力。预先多花几小时进行细致的调查工作比浪费几天准备各种各样的面试强多了。 最糟糕的是，好不容易找到一份自己当时很满意的工作，结果却在一两个月后不得不离开。 千万不要为那些达不到热爱程度的工作草率地把自己安顿下来。 理想情况 是将职业生涯视为一条执着的 技术攻关路，就好比总能有一个等待开发的超酷程序，总能学到一个充满了网络魔法的技艺，或是总能去实现一个更出色的技巧。 作为技术专业人士，老天赐予了我们优秀的技能，凭借它我们可以找到一份高收入而且自己热爱的工作。 请记住是热爱，而不仅仅是喜欢。 8 - 不要被动地等着回复好了，当你已经向有意向的公司发送了简历，那么现在该做一点什么呢？ 当然是继续寻找！ 在接到面试通知、收到聘用书以及接受一份新工作之前，一切都没有改变。 不要呆坐在日历边，数着距离自己发出那封神奇的求职邮件已经过了多少日子，想象着还有多久公司才会给你答复。你需要做的是继续全力寻找新工作。 如果在一两个星期之后，公司依旧没有对你发出的简历与求职信回应，那么你可以接着发送一封请求对方确认是否收到的邮件。 但是，一旦你得到的答复是简历已收到，那么就别再回复了。 如果人家要你，他们自然会联系你的。没有得到招聘公司的答复也许是因为他们对你不感兴趣或者是他们还没来得及看简历。无论是哪一种情况，你只需顺其自然。 参考资料 《人人都有好工作：IT 行业求职面试必读》 如何用产品思维自检简历？助力设计师高薪跳槽 - https://www.zcool.com.cn/article/ZMTEwMjY0MA==.html 听君一席话，简历不会挂~ - https://www.zcool.com.cn/article/ZMTQ1Mjk2.html 设计师，如何运用产品思维制作「个人简历」。 - https://www.zcool.com.cn/article/ZNTY0MTE2.html 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ Hi，这里是 我没有三颗心脏，一个兴趣爱好广泛的 96 年 自由技术人，在公众号 wmyskxz 分享 「MoreThanCode」 的 知识/技术/成长/思考，2020，与您在 Be Better 的路上共同成长！ 非常感谢各位人才能 看到这里，创作不易，文章有帮助可以点个 「在看」 或 「分享」，都是支持（莫要白嫖）！ Somewhere not here，愿你我都能奔赴在各自想去的路上，我们下篇文章见！","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Offer一箩筐","slug":"Offer一箩筐","permalink":"http://www.wmyskxz.com/tags/Offer%E4%B8%80%E7%AE%A9%E7%AD%90/"}],"author":"我没有三颗心脏"},{"title":"一文带你深扒ClassLoader内核，揭开它的神秘面纱！","slug":"一文带你深扒ClassLoader内核，揭开它的神秘面纱！","date":"2020-08-27T22:42:11.000Z","updated":"2020-12-09T05:01:25.993Z","comments":true,"path":"2020/08/28/yi-wen-dai-ni-shen-ba-classloader-nei-he-jie-kai-ta-de-shen-mi-mian-sha/","link":"","permalink":"http://www.wmyskxz.com/2020/08/28/yi-wen-dai-ni-shen-ba-classloader-nei-he-jie-kai-ta-de-shen-mi-mian-sha/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」。 如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 前言ClassLoader 可以说是 Java 最为神秘的功能之一了，好像大家都知道怎么回事儿 (双亲委派模型好像都都能说得出来…)，又都说不清楚具体是怎么一回事 (为什么需要需要有什么实际用途就很模糊了…)。 今天，我们就来深度扒一扒，揭开它神秘的面纱！ Part 1. 类加载是做什么的？首先，我们知道，Java 为了实现 「一次编译，到处运行」 的目标，采用了一种特别的方案：先 编译 为 与任何具体及其环境及操作系统环境无关的中间代码（也就是 .class 字节码文件），然后交由各个平台特定的 Java 解释器（也就是 JVM）来负责 解释 运行。 ClassLoader (顾名思义就是类加载器) 就是那个把字节码交给 JVM 的搬运工 （加载进内存）。它负责将 字节码形式 的 Class 转换成 JVM 中 内存形式 的 Class 对象。 字节码可以是来自于磁盘上的 .class 文件，也可以是 jar 包里的 *.class，甚至是来自远程服务器提供的字节流。字节码的本质其实就是一个有特定复杂格式的字节数组 byte[]。 (从后面解析 ClassLoader 类中的方法时更能体会) 另外，类加载器不光可以把 Class 加载到 JVM 之中并解析成 JVM 统一要求的对象格式，还有一个重要的作用就是 审查每个类应该由谁加载。 而且，这些 Java 类不会一次全部加载到内存，而是在应用程序需要时加载，这也是需要类加载器的地方。 Part 2. ClassLoader 类结构分析以下就是 ClassLoader 的主要方法了： defineClass() 用于将 byte 字节流解析成 JVM 能够识别的 Class 对象。有了这个方法意味着我们不仅可以通过 .class 文件实例化对象，还可以通过其他方式实例化对象，例如通过网络接收到一个类的字节码。 （注意，如果直接调用这个方法生成类的 Class 对象，这个类的 Class 对象还没有 resolve，JVM 会在这个对象真正实例化时才调用 resolveClass() 进行链接） findClass() 通常和 defineClass() 一起使用，我们需要直接覆盖 ClassLoader 父类的 findClass() 方法来实现类的加载规则，从而取得要加载类的字节码。(以下是 ClassLoader 源码) protected Class&lt;?> findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } 如果你不想重新定义加载类的规则，也没有复杂的处理逻辑，只想在运行时能够加载自己制定的一个类，那么你可以用 this.getClass().getClassLoader().loadClass(&quot;class&quot;) 调用 ClassLoader 的 loadClass() 方法来获取这个类的 Class 对象，这个 loadClass() 还有重载方法，你同样可以决定再什么时候解析这个类。 loadClass() 用于接受一个全类名，然后返回一个 Class 类型的对象。（该方法源码蕴含了著名的双亲委派模型） resolveClass() 用于对 Class 进行 链接，也就是把单一的 Class 加入到有继承关系的类树中。如果你想在类被加载到 JVM 中时就被链接（Link），那么可以在调用 defineClass() 之后紧接着调用一个 resolveClass() 方法，当然你也可以选择让 JVM 来解决什么时候才链接这个类（通常是真正被实实例化的时候）。 ClassLoader 是个抽象类，它还有很多子类，如果我们要实现自己的 ClassLoader，一般都会继承 URLClassLoader 这个子类，因为这个类已经帮我们实现了大部分工作。 例如，我们来看一下 java.net.URLClassLoader.findClass() 方法的实现： // 入参为 Class 的 binary name，如 java.lang.String protected Class&lt;?> findClass(final String name) throws ClassNotFoundException { // 以上代码省略 // 通过 binary name 生成包路径，如 java.lang.String -> java/lang/String.class String path = name.replace('.', '/').concat(\".class\"); // 根据包路径，找到该 Class 的文件资源 Resource res = ucp.getResource(path, false); if (res != null) { try { // 调用 defineClass 生成 java.lang.Class 对象 return defineClass(name, res); } catch (IOException e) { throw new ClassNotFoundException(name, e); } } else { return null; } // 以下代码省略 } Part 3. Java 类加载流程详解以下就是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤。 事实上，我们每一次在 IDEA 中点击运行时，IDE 都会默认替我们执行以下的命令： javac Xxxx.java ➡️ 找到源文件中的 public class，再找 public class 引用的其他类，Java 编译器会根据每一个类生成一个字节码文件； java Xxxx ➡️ 找到文件中的唯一主类 public class，并根据 public static 关键字找到跟主类关联可执行的 main 方法 （这也是为什么 main 方法需要被定义为 public static void 的原因了——我们需要在类没有加载时访问），开始执行。 在真正的运行 main 方法之前，JVM 需要 加载、链接 以及 初始化 上述的 Xxxx 类。 第一步：加载（Loading）这一步是读取到类文件产生的二进制流（findClass()），并转换为特定的数据结构（defineClass()），初步校验 cafe babe 魔法数 （二进制中前四个字节为 0xCAFEBABE 用来标识该文件是 Java 文件，这是很多软件的做法，比如 zip压缩文件）、常量池、文件长度、是否有父类等，然后在 Java 堆 中创建对应类的 java.lang.Class 实例，类中存储的各部分信息也需要对应放入 运行时数据区 中（例如静态变量、类信息等放入方法区）。 以下是一个 Class 文件具有的基本结构的简单图示： 如果对 Class 文件更多细节感兴趣的可以进一步阅读：https://juejin.im/post/6844904199617003528 这里我们可能会有一个疑问，为什么 JVM 允许还没有进行验证、准备和解析的类信息放入方法区呢？ 答案是加载阶段和链接阶段的部分动作（比如一部分字节码文件格式验证动作）是 交叉进行 的，也就是说 加载阶段还没完成，链接阶段可能已经开始了。但这些夹杂在加载阶段的动作（验证文件格式等）仍然属于链接操作。 第二步：链接（Linking）Link 阶段包括验证、准备、解析三个步骤。下面👇我们来详细说说。 验证：确保被加载的类的正确性验证是连接阶段的第一步，这一阶段的目的是 为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成 4 个阶段的检验动作： 文件格式验证： 验证字节流是否符合 Class 文件格式的规范；例如：是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证： 对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。 字节码验证： 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证： 确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在 方法区 中分配。对于该阶段有以下几点需要注意： 1️⃣ 这时候进行内存分配的 仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。 2️⃣ 这里所设置的 初始值通常情况下是数据类型默认的零值（如 0、0L、null、false等），而不是被在 Java 代码中被显式地赋予的值。 3️⃣ 如果类字段的字段属性表中存在 ConstantValue 属性，即 同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。 ➡️ 例如，假设这里有一个类变量 public static int value = 666;，在准备阶段时初始值是 0 而不是 666，在 初始化阶段 才会被真正赋值为 666。 ➡️ 假设是一个静态类变量 public static final int value = 666;，则再准备阶段 JVM 就已经赋值为 666 了。 解析：把类中的符号引用转换为直接引用（重要）解析阶段是虚拟机将常量池内的 符号引用 替换为 直接引用 的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。 ➡️ 符号引用 的作用是在编译的过程中，JVM 并不知道引用的具体地址，所以用符号引用进行代替，而在解析阶段将会将这个符号引用转换为真正的内存地址。 ➡️ 直接引用 可以理解为指向 类、变量、方法 的指针，指向 实例 的指针和一个 间接定位 到对象的对象句柄。 为了理解👆上面两种概念的区别，来看一个实际的例子吧： public class Tester { public static void main(String[] args) { String str = \"关注【我没有三颗心脏】，关注更多精彩\"; System.out.println(str); } } 我们先在该类同级目录下运行 javac Tester 编译成 .class 文件然后再利用 javap -verbose Tester 查看类的详细信息 （为了节省篇幅只截取了 main 方法反编译后的代码）： // 上面是类的详细信息省略... { // ..... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 0: ldc #7 // String 关注【我没有三颗心脏】，关注更多精彩 2: astore_1 3: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 6: aload_1 7: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 10: return LineNumberTable: line 4: 0 line 5: 3 line 6: 10 } SourceFile: \"Tester.java\" 可以看到，上面👆定义的 str 变量在编译阶段会被解析称为 符号引用，符号引用的标志是 astore_&lt;n&gt;，这里就是 astore_1。 store_1的含义是将操作数栈顶的 关注【我没有三颗心脏】，关注更多精彩 保存回索引为 1 的局部变量表中，此时访问变量 str 就会读取局部变量表索引值为 1 中的数据。所以局部变量 str 就是一个符号引用。 再来看另外一个例子： public class Tester { public static void main(String[] args) { System.out.println(\"关注【我没有三颗心脏】，关注更多精彩\"); } } 这一段代码反编译之后得到如下的代码： // 上面是类的详细信息省略... { // ...... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #13 // String 关注【我没有三颗心脏】，关注更多精彩 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 4: 0 line 5: 8 } SourceFile: \"Tester.java\" 我们可以看到这里直接使用了 ldc 指令将 关注【我没有三颗心脏】，关注更多精彩 推送到了栈，紧接着就是调用指令 invokevirtual，并没有将字符串存入局部变量表中，这里的字符串就是一个 直接引用。 第三步：初始化（Initialization）初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式： 1️⃣ 声明类变量是指定初始值； 2️⃣ 使用静态代码块为类变量指定初始值； JVM 初始化步骤： 1️⃣ 假如这个类还没有被加载和连接，则程序先加载并连接该类 2️⃣ 假如该类的直接父类还没有被初始化，则先初始化其直接父类 3️⃣ 假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下几种： 创建类的实例，也就是 new 的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(&quot;com.wmyskxz.Tester&quot;)） 初始化某个类的子类，则其父类也会被初始化 Java 虚拟机启动时被标明为启动类的类，直接使用 java.exe 命令来运行某个主类 使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHanlde 实例最后的解析结果为 REF_getstatic、REF_putstatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄时，都需要先初始化该句柄对应的类 接口中定义了 JDK 8 新加入的默认方法（default修饰符），实现类在初始化之前需要先初始化其接口 Part 4. 深入理解双亲委派模型我们在上面👆已经了解了一个类是如何被加载进 JVM 的——依靠类加载器——在 Java 语言中自带有三个类加载器： Bootstrap ClassLoader 最顶层的加载类，主要加载 核心类库，%JRE_HOME%\\lib 下的rt.jar、resources.jar、charsets.jar 和 class 等。 Extention ClassLoader 扩展的类加载器，加载目录 %JRE_HOME%\\lib\\ext 目录下的 jar 包和 class 文件。 Appclass Loader 也称为 SystemAppClass 加载当前应用的 classpath 的所有类。 我们可以通过一个简单的例子来简单了解 Java 中这些自带的类加载器： public class PrintClassLoader { public static void main(String[] args) { printClassLoaders(); } public static void printClassLoaders() { System.out.println(\"Classloader of this class:\" + PrintClassLoader.class.getClassLoader()); System.out.println(\"Classloader of Logging:\" + com.sun.javafx.util.Logging.class.getClassLoader()); System.out.println(\"Classloader of ArrayList:\" + java.util.ArrayList.class.getClassLoader()); } } 上方程序打印输出如下： Classloader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2 Classloader of Logging:sun.misc.Launcher$ExtClassLoader@60e53b93 Classloader of ArrayList:null 如我们所见，这里分别对应三种不同类型的类加载器：AppClassLoader、ExtClassLoader 和 BootstrapClassLoader（显示为 null）。 一个很好的问题是：Java 类是由 java.lang.ClassLoader 实例加载的，但类加载器本身也是类，那么谁来加载类加载器呢？ 我们假装不知道，先来跟着源码一步一步来看。 先来看看 Java 虚拟机入口代码在 JDK 源码 sun.misc.Launcher 中，蕴含了 Java 虚拟机的入口方法： public class Launcher { private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\"sun.boot.class.path\"); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \"Could not create extension class loader\", e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \"Could not create application class loader\", e); } // 设置 AppClassLoader 为线程上下文类加载器，这个文章后面部分讲解 Thread.currentThread().setContextClassLoader(loader); } /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() { return loader; } /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader {} /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader {} } 源码有精简，但是我们可以得到以下信息： 1️⃣ Launcher 初始化了 ExtClassLoader 和 AppClassLoader。 2️⃣ Launcher 没有看到 Bootstrap ClassLoader 的影子，但是有一个叫做 bootClassPath 的变量，大胆一猜就是 Bootstrap ClassLoader 加载的 jar 包的路径。 (ps: 可以自己尝试输出一下 System.getProperty(&quot;sun.boot.class.path&quot;) 的内容，它正好对应了 JDK 目录 lib 和 classes 目录下的 jar 包——也就是通常你配置环境变量时设置的 %JAVA_HOME/lib 的目录了——同样的方式你也可以看看 Ext 和 App 的源码) 3️⃣ ExtClassLoader 和 AppClassLoader 都继承自 URLClassLoader，进一步查看 ClassLoader 的继承树，传说中的双亲委派模型也并没有出现。（甚至看不到 Bootstrap ClassLoader 的影子，Ext 也没有直接继承自 App 类加载器） （⚠️注意，这里可以明确看到每一个 ClassLoader 都有一个 parent 变量，用于标识自己的父类，下面👇详细说） 4️⃣ 注意以下代码： ClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader(); loader = AppClassLoader.getAppClassLoader(extcl); 分别跟踪查看到这两个 ClassLoader 初始化时的代码： // 一直追踪到最顶层的 ClassLoader 定义，构造器的第二个参数标识了类加载器的父类 private ClassLoader(Void unused, ClassLoader parent) { this.parent = parent; // 代码省略..... } // Ext 设置自己的父类为 null public ExtClassLoader(File[] var1) throws IOException { super(getExtURLs(var1), (ClassLoader)null, Launcher.factory); SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this); } // 手动把 Ext 设置为 App 的 parent（这里的 var2 是传进来的 extc1） AppClassLoader(URL[] var1, ClassLoader var2) { super(var1, var2, Launcher.factory); this.ucp.initLookupCache(this); } 由此，我们得到了这样一个类加载器的关系图： 类加载器的父类都来自哪里？奇怪，为什么 ExtClassLoader 的 parent 明明是 null，我们却一般地认为 Bootstrap ClassLoader 才是 ExtClassLoader 的父加载器呢？ 答案的一部分就藏在 java.lang.ClassLoader.loadClass() 方法里面：（这也就是著名的「双亲委派模型」现场了） protected Class&lt;?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先检查是否已经加载过了 Class&lt;?> c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { // 父加载器不为空则调用父加载器的 loadClass 方法 c = parent.loadClass(name, false); } else { // 父加载器为空则调用 Bootstrap ClassLoader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); // 父加载器没有找到，则调用 findclass c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { // 调用 resolveClass() resolveClass(c); } return c; } } 代码逻辑很好地解释了双亲委派的原理。 1️⃣ 当前 ClassLoader 首先从 自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。(每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。) 2️⃣ 当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 Bootstrap ClassLoader。（当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。） 所以，答案的另一部分是因为最高一层的类加载器 Bootstrap 是通过 C/C++ 实现的，并不存在于 JVM 体系内 （不是一个 Java 类，没办法直接表示为 ExtClassLoader 的父加载器），所以输出为 null。 （我们可以很轻易跟踪到 findBootstrapClass() 方法被 native 修饰：private native Class&lt;?&gt; findBootstrapClass(String name);） ➡️ OK，我们理解了为什么 ExtClassLoader 的父加载器为什么是表示为 null 的 Bootstrap 加载器，那我们 自己实现的 ClassLoader 父加载器应该是谁呢？ 观察一下 ClassLoader 的源码就知道了： protected ClassLoader(ClassLoader parent) { this(checkCreateClassLoader(), parent); } protected ClassLoader() { this(checkCreateClassLoader(), getSystemClassLoader()); } 类加载器的 parent 的赋值是在 ClassLoader 对象的构造方法中，它有两个情况： 1️⃣ 由外部类创建 ClassLoader 时直接指定一个 ClassLoader 为 parent； 2️⃣ 由 getSystemClassLoader() 方法生成，也就是在 sun.misc.Laucher 通过 getClassLoader() 获取，也就是 AppClassLoader。直白的说，一个 ClassLoader 创建时如果没有指定 parent，那么它的 parent 默认就是 AppClassLoader。（建议去看一下源码） 为什么这样设计呢？简单来说，主要是为了 安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也 避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException。 如果我们要实现自己的类加载器，不管你是直接实现抽象类 ClassLoader，还是继承 URLClassLoader 类，或者其他子类，它的父加载器都是 AppClassLoader。 因为不管调用哪个父类构造器，创建的对象都必须最终调用 getSystemClassLoader() 作为父加载器 （我们已经从上面👆的源码中看到了）。而该方法最终获取到的正是 AppClassLoader （别称 SystemClassLoader）。 这也就是我们熟知的最终的双亲委派模型了。 Part 5. 实现自己的类加载器什么情况下需要自定义类加载器在学习了类加载器的实现机制之后，我们知道了双亲委派模型并非强制模型，用户可以自定义类加载器，在什么情况下需要自定义类加载器呢？ 1️⃣ 隔离加载类。在某些框架内进行中间件与应用的模块隔离，把类加载器到不同的环境。比如，阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。 2️⃣ 修改类加载方式。类的加载模型并非强制，除了 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需的动态加载。 3️⃣ 扩展加载源。比如从数据库、网络，甚至是电视机顶盒进行加载。（下面👇我们会编写一个从网络加载类的例子） 4️⃣ 防止源码泄露。Java 代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。 一个常规的例子实现一个自定义的类加载器比较简单：继承 ClassLoader，重写 findClass() 方法，调用 defineClass() 方法，就差不多行了。 Tester.java我们先来编写一个测试用的类文件： public class Tester { public void say() { System.out.println(\"关注【我没有三颗心脏】，解锁更多精彩！\"); } } 在同级目录下执行 javac Tester.java 命令，并把编译后的 Tester.class 放到指定的目录下（我这边为了方便就放在桌面上啦 /Users/wmyskxz/Desktop） MyClassLoader.java我们编写自定义 ClassLoader 代码： import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class MyClassLoader extends ClassLoader { private final String mLibPath; public MyClassLoader(String path) { // TODO Auto-generated constructor stub mLibPath = path; } @Override protected Class&lt;?> findClass(String name) throws ClassNotFoundException { // TODO Auto-generated method stub String fileName = getFileName(name); File file = new File(mLibPath, fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try { while ((len = is.read()) != -1) { bos.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name, data, 0, data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return super.findClass(name); } // 获取要加载的 class 文件名 private String getFileName(String name) { // TODO Auto-generated method stub int index = name.lastIndexOf('.'); if (index == -1) { return name + \".class\"; } else { return name.substring(index + 1) + \".class\"; } } } 我们在 findClass() 方法中定义了查找 class 的方法，然后数据通过 defineClass() 生成了 Class 对象。 ClassLoaderTester 测试类我们需要删除刚才在项目目录创建的 Tester.java 和编译后的 Tester.class 文件来观察效果： import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ClassLoaderTester { public static void main(String[] args) { // 创建自定义的 ClassLoader 对象 MyClassLoader myClassLoader = new MyClassLoader(\"/Users/wmyskxz/Desktop\"); try { // 加载class文件 Class&lt;?> c = myClassLoader.loadClass(\"Tester\"); if(c != null){ try { Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\"say\",null); //通过反射调用Test类的say方法 method.invoke(obj, null); } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 运行测试，正常输出： 关注【我没有三颗心脏】，解锁更多精彩！ 加密解密类加载器突破了 JDK 系统内置加载路径的限制之后，我们就可以编写自定义的 ClassLoader。你完全可以按照自己的意愿进行业务的定制，将 ClassLoader 玩出花样来。 例如，一个加密解密的类加载器。（不涉及完整代码，我们可以来说一下思路和关键代码） 首先，在编译之后的字节码文件中动一动手脚，例如，给文件每一个 byte 异或一个数字 2：（这就算是模拟加密过程） File file = new File(path); try { FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(path+\"en\"); int b = 0; int b1 = 0; try { while((b = fis.read()) != -1){ // 每一个 byte 异或一个数字 2 fos.write(b ^ 2); } fos.close(); fis.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } 然后我们再在 findClass() 中自己解密： File file = new File(mLibPath,fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; byte b = 0; try { while ((len = is.read()) != -1) { // 将数据异或一个数字 2 进行解密 b = (byte) (len ^ 2); bos.write(b); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name,data,0,data.length); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } （代码几乎与上面👆一个例子等同，所以只说一下思路和完整代码） 网络类加载器其实非常类似，也不做过多讲解，直接上代码： import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.net.URL; public class NetworkClassLoader extends ClassLoader { private String rootUrl; public NetworkClassLoader(String rootUrl) { // 指定URL this.rootUrl = rootUrl; } // 获取类的字节码 @Override protected Class&lt;?> findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { // 从网络上读取的类的字节 String path = classNameToPath(className); try { URL url = new URL(path); InputStream ins = url.openStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; // 读取类文件的字节 while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (Exception e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { // 得到类文件的URL return rootUrl + \"/\" + className.replace('.', '/') + \".class\"; } } (代码来自：https://blog.csdn.net/justloveyou_/article/details/72217806) Part 6. 必要的扩展阅读学习到这里，我们对 ClassLoader 已经不再陌生了，但是仍然有一些必要的知识点需要去掌握 （限于篇幅和能力这里不扩展了），希望您能认真阅读以下的材料：（可能排版上面层次不齐，但内容都是有质量的，并用 ♨️ 标注了更加重点一些的内容） 1️⃣ ♨️能不能自己写一个类叫 java.lang.System 或者 java.lang.String？ - https://blog.csdn.net/tang9140/article/details/42738433 2️⃣ 深入理解 Java 之 JVM 启动流程 - https://cloud.tencent.com/developer/article/1038435 3️⃣ ♨️真正理解线程上下文类加载器（多案例分析） - https://blog.csdn.net/yangcheng33/article/details/52631940 4️⃣ ♨️曹工杂谈：Java 类加载器还会死锁？这是什么情况？ - https://www.cnblogs.com/grey-wolf/p/11378747.html#_label2 5️⃣ 谨防JDK8重复类定义造成的内存泄漏 - https://segmentfault.com/a/1190000022837543 7️⃣ ♨️Tomcat 类加载器的实现 - https://juejin.im/post/6844903945496690695 8️⃣ ♨️Spring 中的类加载机制 - https://www.shuzhiduo.com/A/gVdnwgAlzW/ 参考资料 《深入分析 Java Web 技术内幕》 | 许令波 著 Java 类加载机制分析 - https://www.jianshu.com/p/3615403c7c84 Class 文件解析实战 - https://juejin.im/post/6844904199617003528 图文兼备看懂类加载机制的各个阶段，就差你了！ - https://juejin.im/post/6844904119258316814 Java面试知识点解析（三）——JVM篇 - https://www.wmyskxz.com/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/ 一看你就懂，超详细Java中的ClassLoader详解 - https://blog.csdn.net/briblue/article/details/54973413 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java14版本特性详解","slug":"Java14版本特性详解","date":"2020-08-22T12:58:03.000Z","updated":"2020-12-09T05:05:05.555Z","comments":true,"path":"2020/08/22/java14-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/22/java14-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 14 中的引入的部分新特性。关于 Java 14 新特性更详细的介绍可参考这里。 语言及特性更改： Switch 表达式-标准（JEP 361） instanceof 的模式匹配-预览（JEP 305） 有用的 NullPointerExceptions（JEP 358） record-预览（JEP 359） 文本块-预览（JEP 368） JVM 更改： 针对 G1 NUMA 感知内存分配的优化（JEP 345） 删除并发标记扫描(CMS)垃圾收集器（JEP 363） JFR 事件流（JEP 349） macOS 上的 ZGC-实验性（JEP 364） Windows 上的 ZGC-实验性（JEP 365） 弃用 ParallelScavenge + SerialOld 的 GC 组合（JEP 366） 其他特性： 打包工具（JEP 343） 非易失性映射字节缓冲区（JEP 352） 弃用 Solaris 和 SPARC 端口（JEP 362） 删除 Pack200 工具和 API（JEP 367） 外部存储器访问 API（JEP 370） 一. Switch 表达式-标准（JEP 361）在上两个版本中保留的预留功能，如今终于在 Java 14 中获得了永久性的地位。 Java 12 为表达是引入了 Lambda 语法，从而允许使用多个大小写标签进行模式匹配，并防止出现导致冗长代码的错误。它还强制执行穷尽情况，如果没有涵盖所有输入情况，则会抛出编译错误。 Java 13 在第二个预览版本使用了 yield 替代了原有的 break 关键字来返回表达式的返回值。 Java 14 现在终于使这些功能成为了标准： String result = switch (day) { case \"M\", \"W\", \"F\" -> \"MWF\"; case \"T\", \"TH\", \"S\" -> \"TTS\"; default -> { if (day.isEmpty()) { yield \"Please insert a valid day.\"; } else { yield \"Looks like a Sunday.\"; } } }; System.out.println(result); 注意，yield 不是 Java 中的新关键字，它仅用于 Switch 表达式中。 二. instanceof 的模式匹配-预览（JEP 305）在 Java 14 之前，我们用于 instanceof-and-cast 检查对象的类型并将其转换为变量。 if (obj instanceof String) { // instanceof String s = (String) obj; // cast if(\"jdk14\".equalsIgnoreCase(s)){ //... } }else { System.out.println(\"not a string\"); } 现在，在 Java 14 中，我们可以像这样重构上面的代码： if (obj instanceof String s) { // instanceof, cast and bind variable in one line. if(\"jdk4\".equalsIgnoreCase(s)){ //... } }else { System.out.println(\"not a string\"); } 如果 obj 是的实例 String，则将其 String 强制转换为绑定变量并分配给该绑定变量 s。 三. 有用的 NullPointerExceptions（JEP 358）空指针异常是任何开发人员的噩梦。以前，直到 Java 13 为止，调试臭名昭著的 NPE 都很棘手。开发人员不得不依靠其他调试工具，或者手动计算为空的变量/ 方法，因为堆栈跟踪只会显示行号。 在 Java 14 之前： String name = jd.getBlog().getAuthor() //Stacktrace Exception in thread \"main\" java.lang.NullPointerException at NullPointerExample.main(NullPointerExample.java:5) Java 14 引入了新的 JVM 功能（带-XX:+ShowCodeDetailsInExceptionMessages选项），它通过更具描述性的堆栈提供了更好的见解，如下所示： Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"Blog.getAuthor()\" because the return value of \"Journaldev.getBlog()\" is null at NullPointerExample.main(NullPointerExample.java:4) 注意：以上功能不是语言功能。这是对运行时环境的增强。 四. record-预览（JEP 359）record 是存储纯数据的数据类型。引入 record 背后的想法是快速创建没有样板代码的简单简洁类。（这有点类似 Kotlin 中的数据类型，这也是为什么有言论说 Java 逐渐 “Kotlin 化” 的原因之一） 通常，Java 中的类需要您实现 equals()、hashCode()、getters 和 setters 方法。虽然某些 IDE 支持此类的自动生成，但是代码仍然很冗长。使用 record 您只需按照以下方式定义一个类。 record Author(){} //or record Author (String name, String topic) {} Java 编译器将自动生成一个带有构造函数、私有 final 字段、访问器和 equals、 hashCode和 toString 方法的类。上一类的自动生成的 getter 方法是 name() 和 topic()。 编译之后，我们可以查看上面 record Author (String name, String topic){} 语句，编译器为我们自动生成的类： final class Author extends java.lang.Record { private final java.lang.String name; private final java.lang.String topic; public Author(java.lang.String name, java.lang.String topic) { /* compiled code */ } public java.lang.String toString() { /* compiled code */ } public final int hashCode() { /* compiled code */ } public final boolean equals(java.lang.Object o) { /* compiled code */ } public java.lang.String name() { /* compiled code */ } public java.lang.String topic() { /* compiled code */ } } 此外，我们可以通过以下方式向记录添加其他字段，方法和构造函数： record Author (int id, String name, String topic) { static int followers; public static String followerCount() { return \"Followers are \"+ followers; } public String description(){ return \"Author \"+ name + \" writes on \"+ topic; } public Author{ if (id &lt; 0) { throw new IllegalArgumentException( \"id must be greater than 0.\"); } } } record 内定义的其他构造函数称为 Compact 构造函数。它不包含任何参数，只是规范本身构造函数的参数。 关于 record 需要注意的几件事： record 既不能扩展一个类，也不能被另一个类扩展。这是一个 final class。 record 不能是抽象的。 record 不能扩展任何其他类，也不能在主体内定义实例字段。实例字段只能在状态描述中定义。 声明的字段是私有字段和 final 字段。 record 定义中允许使用静态字段和方法。 record 类的引用字段内的值可以被改变值得注意的是，对于定义为对象的字段，只有引用是不可变的。底层值可以修改。 下面显示了修改 ArrayList 的一条记录。可以看到，每当 ArrayList 被更改时，该值都会被修改。 jshell> record Author(String name, List&lt;String> topics){} | 已创建 记录 Author jshell> var topicList = new ArrayList&lt;String>(Arrays.asList(\"Java\")); topicList ==> [Java] jshell> var author = new Author(\"Wmyskxz\", topicList); author ==> Author[name=Wmyskxz, topics=[Java]] jshell> topicList.add(\"Python\"); $6 ==> true jshell> author.topics(); $7 ==> [Java, Python] jshell> record 能实现接口下面的代码显示了一个实现有记录接口的示例: interface Information { String getFullName(); } record Author(String name, String topic) implements Information { public String getFullName() { return \"Author \"+ name + \" writes on \" + topic; } } record 支持多个构造函数记录允许声明多个有或没有参数的构造函数，如下所示: record Author(String name, String topic) { public Author() { this(\"NA\", \"NA\"); } public Author(String name) { this(name, \"NA\"); } } record 允许修改访问器方法虽然 record 为状态描述中定义的字段生成公共访问方法，但它们也允许您在主体中重新定义访问方法，如下所示： record Author(String name, String topic) { public String name() { return \"This article was written by \" + this.name; } } 在运行时检查 record 及其组件record 为我们提供了 isRecord() 和 getRecordComponents() 来检查类是否是一条记录，并查看它的字段和类型。下面展示了它是如何做到的： jshell> record Author(String name, String topic){} | 已创建 记录 Author jshell> var author = new Author(\"Wmyskxz\", \"MoreThanJava\"); author ==> Author[name=Wmyskxz, topic=MoreThanJava] jshell> author.getClass().isRecord(); $3 ==> true jshell> author.getClass().getRecordComponents(); $4 ==> RecordComponent[2] { java.lang.String name, java.lang.String topic } jshell> Tips：虽然我们在上面的代码示例中向记录添加了额外的字段和方法，但请确保不要做得过火。记录被设计为普通的数据载体，如果您想实现许多其他方法，最好回到常规类。 五. 文本块-预览（JEP 368）文本块是 Java 13 中的预览功能，其目的是允许轻松创建多行字符串文字。在轻松创建 HTML 和 JSON 或 SQL 查询字符串时很有用。 在 Java 14 中，文本块仍在预览中，并增加了一些新功能。我们现在可以使用： \\ 反斜杠用于显示美观的多行字符串块。 \\s 用于考虑尾随空格，默认情况下编译器会忽略它们。它保留了前面的所有空间。 String text = \"\"\" Did you know \\ Java 14 \\ has the most features among\\ all non-LTS versions so far\\ \"\"\"; String text2 = \"\"\" line1 line2 \\s line3 \"\"\"; String text3 = \"line1\\nline2 \\nline3\\n\" //text2 and text3 are equal. 六. 针对 G1 NUMA 感知内存分配的优化（JEP 345）新的 NUMA感知内存 分配模式提高了大型计算机上的 G1 性能。添加 +XX:+UseNUMA 选项以启用它。 七. 删除并发标记扫描(CMS)垃圾收集器（JEP 363）Java 9 – JEP 291 已弃用此并发标记扫描（CMS）垃圾收集器，现在正式将其删除。 /usr/lib/jvm/jdk-14/bin/java -XX:+UseConcMarkSweepGC Test OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC; support was removed in 14.0 八. JFR 事件流（JEP 349）JDK Flight Recorder（JFR）是用于收集有关正在运行的 Java 应用程序的诊断和性能分析数据的工具。通常，我们开始记录，停止记录，然后将记录的事件转储到磁盘以进行分析，它可以很好地进行概要分析，分析或调试。 该 JEP 改进了现有的 JFR 以支持事件流，这意味着现在我们可以实时传输 JFR 事件，而无需将记录的事件转储到磁盘并手动解析它。 九. macOS 上的 ZGC-实验性（JEP 364）Java 11 – JEP 333 在 Linux 上引入了 Z 垃圾收集器（ZGC），现在可移植到 macOS。 十. Windows 上的 ZGC-实验性（JEP 365）Java 11 – JEP 333 在 Linux 上引入了 Z 垃圾收集器（ZGC），现在可移植到 Windows版本 &gt;= 1803 的机器上。 十一. 弃用 ParallelScavenge + SerialOld 的 GC 组合（JEP 366）由于较少的使用和大量的维护工作，Java 14 不赞成使用并行年轻代和串行老一代 GC 算法的组合。 /usr/lib/jvm/jdk-14/bin/java -XX:-UseParallelOldGC Test OpenJDK 64-Bit Server VM warning: Option UseParallelOldGC was deprecated in version 14.0 and will likely be removed in a future release. 十二. 其他特性打包工具（JEP 343）jpackage是将 Java 应用程序打包到特定于平台的程序包中的新工具。 Linux：deb 和 rpm macOS：pkg 和 dmg Windows：MSI 和 EXE 例如，将 JAR 文件打包到支持 exe 的 Windows 平台上。 非易失性映射字节缓冲区（JEP 352）改进的 FileChannel API 可创建 MappedByteBuffer 对 非易失性存储器（NVM）的 访问，该存储器即使在关闭电源后也可以检索存储的数据。例如，此功能可确保将可能仍在高速缓存中的所有更改写回到内存中。 ps：仅 Linux / x64 和 Linux / AArch64 OS 支持此功能！ 弃用 Solaris 和 SPARC 端口（JEP 362）不再支持 Solaris / SPARC，Solaris / x64 和 Linux / SPARC 端口，更少的平台支持意味着更快地交付新功能。 删除 Pack200 工具和 API（JEP 367）Java 11 – JEP 336 不赞成使用 pack200 和 unpack200 工具，以及软件包中的 Pack200 API java.util.jar，现在正式将其删除。 外部存储器访问 API（JEP 370）孵化器模块，允许 Java API 访问 Java 堆外部的外部内存。 外部存储器访问 API 引入了三个主要抽象： MemorySegment：提供对具有给定范围的连续内存区域的访问。 MemoryAddress：提供到 MemorySegment 的偏移量（基本上是一个指针）。 MemoryLayout：提供一种描述内存段布局的方法，该方法大大简化了使用 var 句柄访问 MemorySegment 的过程。使用此方法，不必根据内存的使用方式来计算偏移量。例如，一个整数或长整数数组的偏移量将有所不同，但将使用 MemoryLayout 透明地对其进行处理。 下面是一个例子： import jdk.incubator.foreign.*; import java.lang.invoke.VarHandle; import java.nio.ByteOrder; public class Test { public static void main(String[] args) { VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()); try (MemorySegment segment = MemorySegment.allocateNative(1024)) { MemoryAddress base = segment.baseAddress(); System.out.println(base); // print memory address intHandle.set(base, 999); // set value 999 into the foreign memory System.out.println(intHandle.get(base)); // get the value from foreign memory } } } 编译并使用孵化器模块运行 jdk.incubator.foreign。 $ /usr/lib/jvm/jdk-14/bin/javac --add-modules jdk.incubator.foreign Test.java warning: using incubating module(s): jdk.incubator.foreign 1 warning $ /usr/lib/jvm/jdk-14/bin/java --add-modules jdk.incubator.foreign Test WARNING: Using incubator modules: jdk.incubator.foreign MemoryAddress{ region: MemorySegment{ id=0x4aac6dca limit: 1024 } offset=0x0 } 999 进一步阅读：官方文档 - https://download.java.net/java/GA/jdk14/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/package-summary.html 参考资料 OpenJDK 官方说明 - http://openjdk.java.net/projects/jdk/14/ What is new in Java 14 - https://mkyong.com/java/what-is-new-in-java-14/ Java 14 Features | JournalDev - https://www.journaldev.com/37273/java-14-features 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 全网最通透的 Java 8 版本特性讲解 - https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/ Java9的这些史诗级更新你都不知道？ - https://www.wmyskxz.com/2020/08/20/java9-ban-ben-te-xing-xiang-jie/ 你想了解的 JDK 10 版本更新都在这里 - https://www.wmyskxz.com/2020/08/21/java10-ban-ben-te-xing-xiang-jie/ 这里有你不得不了解的 Java 11 特性 - https://www.wmyskxz.com/2020/08/22/java11-ban-ben-te-xing-xiang-jie/ Java 12 版本特性【一文了解】 - https://www.wmyskxz.com/2020/08/22/java12-ban-ben-te-xing-xiang-jie/ Java 13 版本特性【一文了解】 - https://www.wmyskxz.com/2020/08/22/java13-ban-ben-te-xing-xiang-jie/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java13版本特性详解","slug":"Java13版本特性详解","date":"2020-08-22T12:57:00.000Z","updated":"2020-12-09T05:05:08.742Z","comments":true,"path":"2020/08/22/java13-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/22/java13-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 13 中的引入的部分新特性。关于 Java 13 新特性更详细的介绍可参考这里。 文本块-预览（JEP 355） 文本块的字符串类新方法 开关表达式-预览（JEP 354） 重新实现旧版套接字 API（JEP 353） 动态 CDS 存档（JEP 350） ZGC：取消提交未使用的内存（JEP 351） FileSystems.newFileSystem() 方法 具有命名空间支持的 DOM 和 SAX 工厂 一. 文本块-预览（JEP 355）这是预览功能。它使我们能够轻松地创建多行字符串。多行字符串必须写在一对三重双引号内。 使用文本块创建的字符串对象没有其他属性。这是创建多行字符串的简便方法。我们不能使用文本块来创建单行字符串。另外，开头的三重双引号后必须跟一个行终止符。 在 Java 13 之前： String html =\"&lt;html>\\n\" + \" &lt;body>\\n\" + \" &lt;p>Hello, World&lt;/p>\\n\" + \" &lt;/body>\\n\" + \"&lt;/html>\\n\"; String json =\"{\\n\" + \" \\\"name\\\":\\\"mkyong\\\",\\n\" + \" \\\"age\\\":38\\n\" + \"}\\n\"; Java 13： String html = \"\"\" &lt;html> &lt;body> &lt;p>Hello, World&lt;/p> &lt;/body> &lt;/html> \"\"\"; String json = \"\"\" { \"name\":\"mkyong\", \"age\":38 } \"\"\"; 二. 文本块的字符串类新方法String 类中有三个与文本块功能关联的新方法。 formatted(Object…args)：它类似于 String format() 方法。添加它是为了支持文本块的格式化。 stripIndent()：用于从文本块中的每一行的开头和结尾删除附带的空格字符。文本块使用此方法，并保留内容的相对缩进。 translateEscapes()：返回一个值为该字符串的字符串，其转义序列就像在字符串文字中一样进行翻译。 package com.journaldev.java13.examples; public class StringNewMethods { /*** * New methods are to be used with Text Block Strings * @param args */ @SuppressWarnings(\"preview\") public static void main(String[] args) { String output = \"\"\" Name: %s Phone: %d Salary: $%.2f \"\"\".formatted(\"Pankaj\", 123456789, 2000.5555); System.out.println(output); String htmlTextBlock = \"&lt;html> \\n\"+ \"\\t&lt;body>\\t\\t \\n\"+ \"\\t\\t&lt;p>Hello&lt;/p> \\t \\n\"+ \"\\t&lt;/body> \\n\"+ \"&lt;/html>\"; System.out.println(htmlTextBlock.replace(\" \", \"*\")); System.out.println(htmlTextBlock.stripIndent().replace(\" \", \"*\")); String str1 = \"Hi\\t\\nHello' \\\" /u0022 Pankaj\\r\"; System.out.println(str1); System.out.println(str1.translateEscapes()); } } 输出： Name: Pankaj Phone: 123456789 Salary: $2000.56 &lt;html>*** &lt;body> * &lt;p>Hello&lt;/p>** * &lt;/body>* &lt;/html> &lt;html> &lt;body> &lt;p>Hello&lt;/p> &lt;/body> &lt;/html> Hi Hello' \" /u0022 Pankaj Hi Hello' \" /u0022 Pankaj 三. 开关表达式-预览（JEP 354）Java 12 引入了JEP 325 Switch表达式。该 JEP 放弃brea 关键字而改用 yield 关键字从 switch 表达式返回值。（其他均与 Java 12 没区别） // switch expressions, use yield to return, in Java 12 it was break int x = switch (choice) { case 1, 2, 3: yield choice; default: yield -1; }; （ps：这会在 Java 14 - JEP 361 中成为标准功能） 四. 重新实现旧版套接字 API（JEP 353）java.net.Socket 和 java.net.ServerSocket 的底层实现都很古老，可以追溯到 JDK 1.0，它混合了遗留的 Java 和 C 代码，很难维护和调试。这个 JEP 为套接字 API 引入了新的底层实现，这是 Java 13 中的默认实现。 在 Java 13 之前，SocketImpl 使用 PlainSocketImpl： public class ServerSocket implements java.io.Closeable { /** * The implementation of this Socket. */ private SocketImpl impl; } Java 13 引入了一个新的 NioSocketImpl 类，作为对 PlainSocketImpl 的临时替换。但是，如果出现错误，我们仍然可以通过设置 jdk.net.usePlainSocketImpl 系统属性切换回旧的实现 PlainSocketImpl。 下面👇是一个简单的套接字示例。 import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class JEP353 { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8888)){ boolean running = true; while(running){ Socket clientSocket = serverSocket.accept(); //do something with clientSocket } } catch (IOException e) { e.printStackTrace(); } } } 在 Java 13 中，默认实现是 NioSocketImpl D:\\test>javac JEP353.java D:\\test>java JEP353 D:\\test>java -XX:+TraceClassLoading JEP353 | findStr Socket [0.040s][info ][class,load] java.net.ServerSocket source: jrt:/java.base [0.040s][info ][class,load] jdk.internal.access.JavaNetSocketAccess source: jrt:/java.base [0.040s][info ][class,load] java.net.ServerSocket$1 source: jrt:/java.base [0.040s][info ][class,load] java.net.SocketOptions source: jrt:/java.base [0.040s][info ][class,load] java.net.SocketImpl source: jrt:/java.base [0.044s][info ][class,load] java.net.SocketImpl$$Lambda$1/0x0000000800ba0840 source: java.net.SocketImpl [0.047s][info ][class,load] sun.net.PlatformSocketImpl source: jrt:/java.base [0.047s][info ][class,load] sun.nio.ch.NioSocketImpl source: jrt:/java.base [0.047s][info ][class,load] sun.nio.ch.SocketDispatcher source: jrt:/java.base [0.052s][info ][class,load] java.net.SocketAddress source: jrt:/java.base [0.052s][info ][class,load] java.net.InetSocketAddress source: jrt:/java.base [0.052s][info ][class,load] java.net.InetSocketAddress$InetSocketAddressHolder source: jrt:/java.base [0.053s][info ][class,load] sun.net.ext.ExtendedSocketOptions source: jrt:/java.base [0.053s][info ][class,load] jdk.net.ExtendedSocketOptions source: jrt:/jdk.net [0.053s][info ][class,load] java.net.SocketOption source: jrt:/java.base [0.053s][info ][class,load] jdk.net.ExtendedSocketOptions$ExtSocketOption source: jrt:/jdk.net [0.053s][info ][class,load] jdk.net.SocketFlow source: jrt:/jdk.net [0.053s][info ][class,load] jdk.net.ExtendedSocketOptions$PlatformSocketOptions source: jrt:/jdk.net [0.053s][info ][class,load] jdk.net.ExtendedSocketOptions$PlatformSocketOptions$1 source: jrt:/jdk.net [0.054s][info ][class,load] jdk.net.ExtendedSocketOptions$1 source: jrt:/jdk.net [0.054s][info ][class,load] sun.nio.ch.NioSocketImpl$FileDescriptorCloser source: jrt:/java.base [0.055s][info ][class,load] java.net.Socket source: jrt:/java.base 五. 动态 CDS 存档（JEP 350）该 JEP 扩展了 Java 10 中引入的类数据共享功能。现在，创建 CDS 存档并使用它要容易得多。 $ java -XX:ArchiveClassesAtExit=my_app_cds.jsa -cp my_app.jar $ java -XX:SharedArchiveFile=my_app_cds.jsa -cp my_app.jar六. ZGC：取消提交未使用的内存（JEP 351）该 JEP 增强了ZGC，可以将未使用的堆内存返回给操作系统。Z垃圾收集器是 Java 11 中引入的。它会在堆内存清理之前增加一个短暂的暂停时间。但是，未使用的内存没有返回给操作系统。对于诸如 IoT 和微芯片等内存占用较小的设备，这是一个问题。 现在，它已得到增强，可以将未使用的内存返回给操作系统。 七. FileSystems.newFileSystem() 方法在 FileSystems 类中添加了三种新方法，以便更容易地使用文件系统提供程序，这些提供程序将文件的内容视为文件系统。 newFileSystem(Path) newFileSystem(Path, Map&lt;String, ?&gt;) newFileSystem(Path, Map&lt;String, ?&gt;, ClassLoader) 八. 具有命名空间支持的 DOM 和 SAX 工厂有一些新方法可以实例化支持名称空间的 DOM 和 SAX 工厂。 newDefaultNSInstance() newNSInstance() newNSInstance(String factoryClassName, ClassLoader classLoader) //java 13 onwards DocumentBuilder db = DocumentBuilderFactory.newDefaultNSInstance().newDocumentBuilder(); // before java 13 DocumentBuilderFactory dbf = DocumentBuilderFactory.newDefaultInstance(); dbf.setNamespaceAware(true); DocumentBuilder db = dbf.newDocumentBuilder(); 参考资料 OpenJDK 官方说明 - http://openjdk.java.net/projects/jdk/13/ What is new in Java 13 - https://mkyong.com/java/what-is-new-in-java-13/ Java 13 Features | JournalDev - https://www.journaldev.com/33204/java-13-features 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 全网最通透的 Java 8 版本特性讲解 - https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/ Java9的这些史诗级更新你都不知道？ - https://www.wmyskxz.com/2020/08/20/java9-ban-ben-te-xing-xiang-jie/ 你想了解的 JDK 10 版本更新都在这里 - https://www.wmyskxz.com/2020/08/21/java10-ban-ben-te-xing-xiang-jie/ 这里有你不得不了解的 Java 11 特性 - https://www.wmyskxz.com/2020/08/22/java11-ban-ben-te-xing-xiang-jie/ Java12版本特性【一文了解】 - https://www.wmyskxz.com/2020/08/22/java12-ban-ben-te-xing-xiang-jie/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java12版本特性详解","slug":"Java12版本特性详解","date":"2020-08-22T12:56:00.000Z","updated":"2020-12-09T05:05:02.776Z","comments":true,"path":"2020/08/22/java12-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/22/java12-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 12 中的引入的部分新特性。关于 Java 12 新特性更详细的介绍可参考这里。 JVM 更改： Shenandoah：低暂停时间的垃圾收集器-实验性（JEP 189） 及时从 G1 返回未使用的已提交内存（JEP 346） 可中止的 G1 混合收集（JEP 344） Mincrobenchmark 套件（JEP 230） 一个 AArch64 端口，而不是两个（JEP 340） 默认 CDS 存档（JEP 341） 语言更改和特性： Switch 表达式-预览（JEP 325） Teeing Collectors 字符串新方法 JVM 常量 API（JEP 334） instanceof 的模式匹配-预览（JEP 305） File.mismatch 方法 紧凑的数字格式 一. Shenandoah:低暂停时间垃圾收集器-实验性（JEP 189）Shenandoah 是一种新的低暂停和并发垃圾回收器，它减少了GC暂停时间，并且与 Java 堆大小无关（5M 或 5G 的堆大小具有相同的暂停时间，对于大型堆应用程序很有用，请阅读此 研究论文）。 该 GC 是一项实验性功能，我们需要使用以下选项来启用新的 Shenandoah GC。 -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC 但是，Oracle JDK 和 OpenJDK 均不包含此新的 Shenandoah GC。 C:\\Users\\wmyskxz> java -version java version \"12\" 2019-03-19 Java(TM) SE Runtime Environment (build 12+33) Java HotSpot(TM) 64-Bit Server VM (build 12+33, mixed mode, sharing) C:\\Users\\wmyskxz> java -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC Error occurred during initialization of VM Option -XX:+UseShenandoahGC not supported AdoptOpenJDK 12 可能包含这种新型的 GC，感兴趣的童鞋可以自行下载体验。 进一步阅读：Shenandoah OpenJDK 主页 - https://openjdk.java.net/projects/shenandoah/ 二. 及时从 G1 返回未使用的已提交内存（JEP 346）该 JEP 提高了垃圾优先（G1）收集器的性能。如果应用程序的活动少或处于空闲状态，则 G1 定期触发并发周期，以确定总体 Java 堆使用情况，并将未使用的 Java 堆内存返回给操作系统。 三. 可中止的G1混合收集（JEP 344）G1 效率的提高包括：如果 G1 混合收集可能超出定义的暂停目标，则可以将其中止。这是通过将混合集合划分为强制性和可选性来实现的。 因此，G1 收集器可以优先考虑首先收集强制性集合，以满足暂停时间目标。 四. Mincrobenchmark 套件（JEP 230）JDK 源代码中添加了一系列 Java Microbenchmark Harness（JMH）基准测试，对于那些有兴趣添加或修改 JDK 源代码本身的用户，现在他们可以比较性能了。 五. 一个 AArch64 端口，而不是两个（JEP 340）在 Java 12 之前，64 位 ARM体系结构 有两个不同的源代码或端口。 Oracle– src/hotspot/cpu/arm Red Hat？– src/hotspot/cpu/aarch64 Java 12 删除了 Oracle src/hotspot/cpu/arm 端口，仅保留了一个端口 src/hotspot/cpu/aarch64，并将 aarch64 其作为 64 位 ARM 体系结构的默认构建。 六. 默认 CDS 存档（JEP 341）类数据共享（Class-Data-Sharing）是在 JDK 5 引入的，允许将一组类预处理成共享的归档文件，然后在运行时对其进行内存映射，以减少启动时间，这还可以在多个 JVM 共享相同的归档文件时减少动态内存占用的功能。 在 Java 12 之前，我们需要 -Xshare: dump 用于为 JDK 类生成 CDS 存档文件。在 Java 12 中，目录中有一个新 classes.jsa 文件，这是 /bin/server/ JDK类的默认 CDS 存档文件。 从 Java 12 开始，默认情况下 CSD 为 ON。要在CDS关闭的情况下运行程序，请执行以下操作： java -Xshare:off HelloWorld.java 七. Switch 表达式-预览（JEP 325）传统的 switch 语句，我们可以通过将值分配给变量来返回值： private static String getText(int number) { String result = \"\"; switch (number) { case 1, 2: result = \"one or two\"; break; case 3: result = \"three\"; break; case 4, 5, 6: result = \"four or five or six\"; break; default: result = \"unknown\"; break; }; return result; } 在 Java 12 中，我们可以使用 break 或 case L -&gt; 从开关返回值。 private static String getText(int number) { String result = switch (number) { case 1, 2: break \"one or two\"; case 3: break \"three\"; case 4, 5, 6: break \"four or five or six\"; default: break \"unknown\"; }; return result; } case L -&gt; 语法： private static String getText(int number) { return switch (number) { case 1, 2 -> \"one or two\"; case 3 -> \"three\"; case 4, 5, 6 -> \"four or five or six\"; default -> \"unknown\"; }; } 要启用 Java 12 预览功能需要按以下操作进行： javac --enable-preview --release 12 Example.java java --enable-preview Example 注意：此开关表达式 Java 13 中具有第二个预览（break 改成 yield），并在 Java 14 中成为标准功能； 八. Teeing CollectorsTeeing Collector 是 Streams API 中引入的新的收集器实用程序。 该收集器具有三个参数——两个收集器和一个 Bi 函数。所有输入值都传递给每个收集器，结果交给 Bi 函数使用。（为了大家便于理解，我画了一个图👇） 典型的例子就是求取一个平均值：(当然对于这个例子，我们可以使用 averagingInt() 来完成…) double average = Stream.of(1, 2, 3, 4, 5) .collect(Collectors.teeing( summingDouble(i -> i), counting(), (sum, n) -> sum / n)); System.out.println(average); // 输出 3.0 九. 字符串新方法indent(int)-缩进此方法根据输入参数 &#39;n&#39; 的值调整字符串中每行的缩进量，并规范行终止符。 如果 n &gt; 0，则在每行的开头插入 n 个空格（U + 0020）。 如果 n &lt; 0，则从每行开头最多删除 n 个空格字符。如果给定的行没有足够的空格，那么将删除所有前导空格字符。制表符也被视为单个字符。 如果 n = 0，则该行保持不变。但是，行终止符仍被标准化。 下面是使用 JShell 调用的演示： jshell> String str = \"******\\n Hi\\n How are you?\\n******\" str ==> \"******\\n Hi\\n How are you?\\n******\" jshell> str.indent(0) $23 ==> \"******\\n Hi\\n How are you?\\n******\\n\" jshell> str.indent(3) $24 ==> \" ******\\n Hi\\n How are you?\\n ******\\n\" jshell> str.indent(-2) $25 ==> \"******\\n Hi\\nHow are you?\\n******\\n\" jshell> 注意，使用 indent() 方法时，\\r 会被转化为 \\n。 transform(Function&lt;? super String,? extends R&gt; f)此方法使我们可以在给定的字符串上调用函数。该函数应该期望一个 String 参数，并产生一个 R 结果。 下面是使用 transform() 方法把 CSV 字符串转换为字符串列表的演示： jshell> String str = \"Hi,Hello,Wmyskxz\"; str ==> \"Hi,Hello,Wmyskxz\" jshell> var strList = str.transform(s -> {return Arrays.asList(s.split(\",\"));}); strList ==> [Hi, Hello, Wmyskxz] jshell> Optional describeConstable()Java 12 在 JEP 334 中 引入了 Constants API 。如果您查看 String 类文档，它将实现 Constants API 的两个新接口——Constable 和 ConstantDesc。此方法在 Constable 接口中声明，并在 String 类中实现。 此方法返回一个 Optional，其中包含该实例的名义描述符，即实例本身。 jshell> String str = \"wmyskxz\"; str ==> \"wmyskxz\" jshell> var s = str.describeConstable(); s ==> Optional[wmyskxz] jshell> s.get() $30 ==> \"wmyskxz\" jshell> String resolveConstantDesc(MethodHandles.Lookup lookup)此方法是 Constants API 的一部分，并在 ConstantDesc 接口中声明。它将实例解析为 ConstantDesc，其结果就是实例本身。 shell> import java.lang.invoke.MethodHandles; jshell> String str = \"Hello\"; str ==> \"Hello\" jshell> str.resolveConstantDesc(MethodHandles.lookup()); $18 ==> \"Hello\" jshell> 十. JVM 常量 API（JEP 334）此 JEP 引入了一个新软件包 java.lang.constant。对于不使用常量池的开发人员来说，这没什么用。 进一步阅读：官方文档 - https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/constant/package-summary.html 十一. instanceof 的模式匹配-预览（JEP 305）另一个预览语言功能。将一个类型转换为另一种类型的旧方法是： if (obj instanceof String) { String s = (String) obj; // use s in your code from here } 新方法是： if (obj instanceof String s) { // can use s directly here } 这为我们节省了一些不必要的类型转换。 十二. File.mismatch 方法Java 12 添加了以下方法来比较两个文件： public static long mismatch(Path path, Path path2) throws IOException 此方法返回第一个不匹配的位置，如果没有不匹配，则返回 -1L。 在以下情况下，两个文件可能不匹配： 如果字节不相同。在这种情况下，将返回第一个不匹配字节的位置。 文件大小不相同。在这种情况下，将返回较小文件的大小。 下面给出了示例代码片段：（摘录自 JournalDev） import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; public class FileMismatchExample { public static void main(String[] args) throws IOException { Path filePath1 = Files.createTempFile(\"file1\", \".txt\"); Path filePath2 = Files.createTempFile(\"file2\", \".txt\"); Files.writeString(filePath1,\"JournalDev Test String\"); Files.writeString(filePath2,\"JournalDev Test String\"); long mismatch = Files.mismatch(filePath1, filePath2); System.out.println(\"File Mismatch position... It returns -1 if there is no mismatch\"); System.out.println(\"Mismatch position in file1 and file2 is >>>>\"); System.out.println(mismatch); filePath1.toFile().deleteOnExit(); filePath2.toFile().deleteOnExit(); System.out.println(); Path filePath3 = Files.createTempFile(\"file3\", \".txt\"); Path filePath4 = Files.createTempFile(\"file4\", \".txt\"); Files.writeString(filePath3,\"JournalDev Test String\"); Files.writeString(filePath4,\"JournalDev.com Test String\"); long mismatch2 = Files.mismatch(filePath3, filePath4); System.out.println(\"Mismatch position in file3 and file4 is >>>>\"); System.out.println(mismatch2); filePath3.toFile().deleteOnExit(); filePath4.toFile().deleteOnExit(); } } 编译并运行上述 Java 程序时，输出为： 十三. 紧凑的数字格式实例代码： import java.text.NumberFormat; import java.util.Locale; public class CompactNumberFormatting { public static void main(String[] args) { System.out.println(\"Compact Formatting is:\"); NumberFormat upvotes = NumberFormat .getCompactNumberInstance(new Locale(\"en\", \"US\"), NumberFormat.Style.SHORT); upvotes.setMaximumFractionDigits(1); System.out.println(upvotes.format(2592) + \" upvotes\"); NumberFormat upvotes2 = NumberFormat .getCompactNumberInstance(new Locale(\"en\", \"US\"), NumberFormat.Style.LONG); upvotes2.setMaximumFractionDigits(2); System.out.println(upvotes2.format(2011) + \" upvotes\"); } } 输出： Compact Formatting is: 2.6k upvotes 2.01 thousand upvotes 参考资料 OpenJDK 官方说明 - http://openjdk.java.net/projects/jdk/12/ What is new in Java 12 - https://mkyong.com/java/what-is-new-in-java-12/ Java 12 Features | JournalDev - https://www.journaldev.com/28666/java-12-features 39 New Features（and APIs） in JDK 12 - https://dzone.com/articles/39-new-features-and-apis-in-jdk-12 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 全网最通透的 Java 8 版本特性讲解 - https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/ Java9的这些史诗级更新你都不知道？ - https://www.wmyskxz.com/2020/08/20/java9-ban-ben-te-xing-xiang-jie/ 你想了解的 JDK 10 版本更新都在这里 - https://www.wmyskxz.com/2020/08/21/java10-ban-ben-te-xing-xiang-jie/ 这里有你不得不了解的 Java 11 特性 - https://www.wmyskxz.com/2020/08/22/java11-ban-ben-te-xing-xiang-jie/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java11版本特性详解","slug":"Java11版本特性详解","date":"2020-08-22T02:42:00.000Z","updated":"2020-12-09T05:05:00.021Z","comments":true,"path":"2020/08/22/java11-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/22/java11-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Java 11 为什么重要？Java 11 是继 Java 8 之后的第二个 LTS（long-term support）版本。自 Java 11 起，Oracle JDK 将不再免费提供商业用途。 您可以在开发阶段使用它，但要在商业上使用它，则需要购买许可证。 Java 10 是最后一个可以下载的免费 Oracle JDK。 Oracle 从 2019 年 1 月开始就停止了对 Java 8 的支持。您需要支付更多的支持费用。 如果不这样做，虽然您可以继续使用它，但不会获得任何补丁/ 安全更新。 自 Java 11 起，Oracle 将不再为任何单个 Java 版本提供免费的长期支持（LTS）。 尽管 Oracle JDK 不再免费，但是您始终可以从 Oracle 或其他提供商（例如 AdoptOpenJDK，Azul，IBM，Red Hat 等..）下载 Open JDK 构建。 什么是 LTS Module从 2017 年开始，Oracle 和 Java 社区宣布了向 Java 的新 6 个月节奏的转变。它已迁移到 Oracle Java SE 产品的长期支持（LTS）模型。 LTS 版本的产品将提供 Oracle 的首要和持续的支持，目标是每三年一次。 每个 Java 版本都以一两个主要特性为模型，这些特性驱动了版本的发布。任何障碍都会推迟发布和上市时间。Jigsaw 项目就是 Java 9 的一个主要特性，它多次推迟了发布日期，并且发布时间被推迟了超过 1.5 年。6 个月一版的发车节奏将让特性紧随。发布的列车每 6 个月有一个时间表。赶上这列火车的特征会被留下，否则他们就等下一班火车。 Oracle JDK 与 Open JDK为了对开发人员更加友好，Oracle &amp; Java 社区现在将 OpenJDK 二进制文件作为主要 JDK 进行推广。 这与早期的 JDK 二进制文件是由 Oracle 专有并由 Oracle 许可的模式相比，很大程度上减轻了人们的负担，因为 Oracle 对重新发布有各种限制。 然而，Oracle 将继续生产他们的 JDK，但仅限于长期支持版本。这是朝着对云和容器更友好的方向迈出的一步，因为开放 JDK 二进制文件可以作为容器的一部分分发。 Open JDK 的二进制文件每 6 个月发布一次，而 Oracle JDK 的二进制文件每 3 年发布一次（LTS版本）。 特性总览在了解完了 Java 11 附带的负担之后，现在让我们作为开发人员分析 Java 11 中的重要功能。 以下是 Java 11 中的引入的部分新特性。关于 Java 11 新特性更详细的介绍可参考这里。 基于嵌套的访问控制（JEP 181） 使用单个命令运行Java文件（JEP 330） Lambda 参数的局部变量语法（JEP 323） 动态类文件常量（JEP 309） HTTP 客户端（JEP 321） Epsilon-无操作垃圾收集器（JEP 318） 可扩展的低延迟垃圾收集器-ZGC（JEP 333） Unicode 10（JEP 327） 低开销堆分析（JEP 331） API 变更 其他变更 删除 Java EE 和 CORBA 模块（JEP 320） 飞行记录器（JEP 328） ChaCha20 和 Poly1305 加密算法（JEP 329） 改进 Aarch64 内部特征（JEP 315） 弃用 Nashorn JavaScript 引擎（JEP 335） 传输层安全性（TLS）1.3（JEP 332） 弃用 Pack200 工具和 API（JEP 336） 一. 基于嵌套的访问控制（JEP 181）在 Java 11 之前，从嵌套类访问主类的 private 方法是可能的： public class Main { public void myPublic() { } private void myPrivate() { } class Nested { public void nestedPublic() { myPrivate(); } } } 但是，如果我们使用反射，它就会给出一个 IllegalStateException： jshell> Main ob = new Main(); ob ==> Main@533ddba jshell> import java.lang.reflect.Method; jshell> Method method = ob.getClass().getDeclaredMethod(\"myPrivate\"); method ==> private void Main.myPrivate() jshell> method.invoke(ob); | 异常错误 java.lang.IllegalAccessException：class REPL.$JShell$15 cannot access a member of class REPL.$JShell$11$Main with modifiers \"private\" | at Reflection.newIllegalAccessException (Reflection.java:376) | at AccessibleObject.checkAccess (AccessibleObject.java:647) | at Method.invoke (Method.java:556) | at (#5:1) jshell> 这是因为 JVM 访问规则不允许嵌套类之间进行私有访问。我们能通过第一种方式访问是因为 JVM 在编译时为我们隐式地创建了私有的 桥接方法。 而且这发生在幕后。这种桥接方法会稍微增加已部署应用程序的大小，并可能使用户和工具感到困惑。 Java 11 引入嵌套访问控制解决了这一问题。 Java 11 将嵌套的概念和相关的访问规则引入了JVM。这简化了 Java 源代码编译器的工作。 为此，类文件格式现在包含两个新属性： 一个嵌套成员（通常是顶级类）被指定为嵌套主类。它包含一个属性（NestMembers）来标识其他静态已知的嵌套成员。 其他每个嵌套成员都有一个属性（NestHost）来标识其嵌套主类。 因此，要使类型 C 和 D 成为嵌套伙伴，它们必须具有相同的嵌套主类。如果类型 C 在其 NestHost 属性中列出 D，则它声称是 D 托管的嵌套的成员。如果 D 还在其 NestMembers 属性中列出 C ，则将验证成员资格。另外，类型 D 隐式为其所托管的嵌套成员。 现在，编译器无需生成桥接方法。 java.lang.Class 在反射 API 中介绍了三种方法：getNestHost()，getNestMembers()，和isNestmateOf()，用于支持上述的工作。 更多请阅读：https://www.baeldung.com/java-nest-based-access-control 二. 使用单个命令运行Java文件（JEP 330）该 JEP 是在学习 Java 早期阶段的一个友好功能，但是在实际的 Java 开发中没有太大的用处，我们都使用 IDE。 假设我们现在有以下的源代码（.java 文件）： public class HelloJava { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在 Java 11 编译运行需要： $ javac HelloJava.java $ java HelloJava Hello World! 在 Java 11 中： $ java HelloJava.java Hello World! 另外，我们也可以使用 Linux Shebang 运行单个的 Java 程序： #!/opt/java/openjdk/bin/java --source 11 public class SheBang { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 这里是在 Docker 中如此使用 Linux Shebang 运行 Java 的例子：https://mkyong.com/java/java-11-shebang-example-in-docker/ 三. Lambda 参数的局部变量语法（JEP 323）该 JEP 是 Java 11 中唯一的语言功能的加强。 我们知道，在 Java 10 中，引入了局部变量类型推断。因此，我们可以从 RHS 推断出变量的类型：var list = new ArrayList&lt;String&gt;(); JEP 323 允许 var 用于声明隐式类型的 Lambda 表达式的形式参数： List&lt;String> list = Arrays.asList(\"关注\", \"我没有三颗心脏\", \"更多精彩内容分享\"); String result = list.stream() .map((var x) -> x.toUpperCase()) .collect(Collectors.joining(\",\")); System.out.println(result2); 上面与下面这个等效： List&lt;String> list = Arrays.asList(\"关注\", \"我没有三颗心脏\", \"更多精彩内容分享\"); String result = list.stream() .map(x -> x.toUpperCase()) .collect(Collectors.joining(\",\")); 这（省略类型声明的形式）在 Java 8 中也是允许的，但是在 Java 10 中删除了。现在，它又回到 Java 11 中以保持一致。 为什么支持 var 来声明隐式的 Lambda 参数呢？（特别是当我们只需跳过 Lambda 类型时） 答案是如果您想要像 @NotNull 一样 注释参数 时，则不能在不定义类型的情况下这样做： import org.jetbrains.annotations.NotNull; List&lt;String> list = Arrays.asList(\"关注\", \"我没有三颗心脏\", \"更多精彩内容分享\", null); String result = list.stream() .map((@NotNull var x) -> x.toUpperCase()) .collect(Collectors.joining(\",\")); System.out.println(result3); 此功能也有一定的 局限性——您必须在所有参数上指定 var 类型，或者不指定任何类型。 在用于 Lambda 内部的参数声明中，不可能出现以下这几种情况： (var s1, s2) -> s1 + s2 //no skipping allowed (var s1, String y) -> s1 + y //no mixing allowed var s1 -> s1 //not allowed. Need parentheses if you use var in lambda. 四. 动态类文件常量（JEP 309）为了使 JVM 对动态语言更具吸引力，Java SE 7 已将 invokedynamic 引入了其指令集。Java 开发人员通常不会注意到此功能，因为它隐藏在 Java 字节码中。 简而言之，通过使用 invokedynamic，可以将方法调用的绑定延迟到第一次调用之前。 例如，Java 语言使用此技术来实现 Lambda 表达式，这些表达式仅在首次使用时才需要出现。 如此，invokedynamic 已发展成为一种基本的语言功能。在 constantdynamic 中，Java 11 引入了一种类似的机制，只是它延迟的是常数值的创建。 但 Java 11 本身缺少对 constantdynamic 的支持，所以这里不做详细赘述。 这篇文章详细讨论了该特性的目的和内部工作原理，并展示了如何使用 Byte Buddy 库生成使用此新指令的代码，感兴趣的可以阅读一下：https://mydailyjava.blogspot.com/2018/08/hands-on-constantdynamic-class-file.html 五. HTTP 客户端（JEP 321）Java 11 标准化了 Http CLient API。 新的 API 支持 HTTP / 1.1 和 HTTP / 2。它旨在提高客户端发送请求和从服务器接收响应的整体性能。它还原生支持 WebSockets。 下面是一个使用 Java 11 HttpClient 发送一个简单 GET 请求的例子： HttpClient httpClient = HttpClient.newBuilder() .version(HttpClient.Version.HTTP_1_1) .connectTimeout(Duration.ofSeconds(10)) .build(); HttpRequest request = HttpRequest.newBuilder() .GET() .uri(URI.create(\"https://www.wmyskxz.com\")) .setHeader(\"User-Agent\", \"Java 11 HttpClient Bot\") .build(); HttpResponse&lt;String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString()); HttpHeaders headers = response.headers(); headers.map().forEach((k, v) -> System.out.println(k + \":\" + v)); System.out.println(response.statusCode()); System.out.println(response.body()); 关于 HttpClient 更多内容请阅读：https://mkyong.com/java/java-11-httpclient-examples/ 六. Epsilon-无操作垃圾收集器（JEP 318）与负责分配内存并释放内存的 JVM GC 不同，Epsilon 仅分配内存。 它为以下内容分配内存： 性能测试。 内存压力测试。 VM 接口测试。 寿命极短的工作。 最后一滴延迟改进。（Last-drop latency improvements.） 最终吞吐量提高。 现在，Elipson 仅适用于测试环境。这将导致生产中的 OutOfMemoryError 并使应用程序崩溃。 Elipson 的好处是没有内存清除开销。因此，它将给出准确的性能测试结果，我们不再可以通过 GC 来停止它。 注意：这是一项实验性功能。 七. 可扩展的低延迟垃圾收集器-ZGC（JEP 333）Z垃圾收集器（ZGC）是可伸缩的低延迟垃圾收集器。ZGC 可以同时执行所有昂贵的工作，而不会将应用程序线程的执行停止超过 10 毫秒，这使得它们适合于要求低延迟和/或使用非常大的堆（数TB）的应用程序。 Z 垃圾收集器可作为实验功能使用，可以通过命令行选项启用-XX:+UnlockExperimentalVMOptions -XX:+UseZGC。 (ps：该垃圾收集器在 JDK 15 才生产准备就绪——JEP 377——所以可以不怎么关注它，因为我们大概率很长一段时间都不会用上) OpenJDK-wiki：https://wiki.openjdk.java.net/display/zgc/Main 八. Unicode 10（JEP 327）以下是 Unicode 10.0 发行版中可用的新表情符号： 关于 Unicode 10.0 的更新，你可以在 这里 看到详细的内容，概括起来就是： “ Unicode 10.0增加了8,518个字符，总共136,690个字符。这些增加包括4个新脚本，总共139个脚本，以及56个新表情符号字符。” 代码演示： public class PrintUnicode { public static void main(String[] args) { String codepoint = \"U+1F92A\"; // crazy face System.out.println(convertCodePoints(codepoint)); } // Java, UTF-16 // Convert code point to unicode static char[] convertCodePoints(String codePoint) { Integer i = Integer.valueOf(codePoint.substring(2), 16); char[] chars = Character.toChars(i); return chars; } } 好文推荐： 在 Java 中使用 Unicode 的乐趣：https://www.codetab.org/post/java-unicode-basics/ 该文章详细介绍了编码和解码以及 Unicode 的基础知识，并通过 Java 编程详细的展示了 Unicode 在 Java 中的使用例子。 九. 低开销堆分析（JEP 331）Java 虚拟机工具接口（JVM TI）是在 Java SE 5 引入的，它可以监控 JVM 内部事件的执行，也可以控制 JVM 的某些行为，可以实现调试、监控、线程分析、覆盖率分析工具等。 该 JEP 在 JVM TI 中添加了新的低开销的堆分析 API。 进一步阅读：Oracle 官方 JVM TI 文档 - https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html 十. API 变更字符串新增方法isBlank()isBlank() ——此实例方法返回一个布尔值。空字符串和仅包含空格的字符串将被视为空。 import java.util.*; public class Main { public static void main(String[] args) throws Exception { System.out.println(\" \".isBlank()); //true String s = \"wmyskxz\"; System.out.println(s.isBlank()); //false String s1 = \"\"; System.out.println(s1.isBlank()); //true } } lines()此方法返回字符串流，它是按行分割的所有子字符串的集合。 jshell> import java.util.stream.Collectors; jshell> String str = \"JD\\nJD\\nJD\"; str ==> \"JD\\nJD\\nJD\" jshell> System.out.println(str); JD JD JD jshell> System.out.println(str.lines().collect(Collectors.toList())); [JD, JD, JD] jshell> strip() / stripLeading() / stripTrailing()strip()——删除字符串开头和结尾的空格。 stripLeading()——删除字符串开头的空格。 stripTrailing()——删除字符串结尾的空格。 jshell> String str = \" 我没有三颗心脏 \"; str ==> \" 我没有三颗心脏 \" jshell> System.out.print(\"关注\" + str.strip() + \"更多精彩内容\"); 关注我没有三颗心脏更多精彩内容 jshell> System.out.print(\"关注\" + str.stripLeading() + \"更多精彩内容\"); 关注我没有三颗心脏 更多精彩内容 jshell> System.out.print(\"关注\" + str.stripTrailing() + \"更多精彩内容\"); 关注 我没有三颗心脏更多精彩内容 jshell> repeat(int)repeat 方法简单地以 int 形式将字符串重复多次。 jshell> String str = \"关注【我没有三颗心脏】获取更多精彩内容!\".repeat(3); str ==> \"关注【我没有三颗心脏】获取更多精彩内容!关注【我没有三颗心脏】获取更多精彩内容!关注【我没有三颗心脏】获取更多精彩内容!\" jshell> 文件读写字符串Java 11 致力于 String 的读写变得方便。它引入了以下用于读写文件的方法： readString(); writeString(); 以下是代码示例： Path path = Files.writeString(Files.createTempFile(\"test\", \".txt\"), \"This was posted on wmyskxz.com\"); System.out.println(path); String s = Files.readString(path); System.out.println(s); //This was posted on wmyskxz.com 十一. 其他变更删除 Java EE 和 CORBA 模块（JEP 320）Java 9 中已经弃用了这些模块，现在将它们完全删除。 下面的包被删除：java.xml.ws，java.xml.bind，java.activation，java.xml.ws.annotation，java.corba，java.transaction，java.se.ee，jdk.xml.ws，jdk.xml.bind 飞行记录器（JEP 328）Flight Recorder 以前是 Oracle JDK 中的商业附加组件，现已开放源代码，因为 Oracle JDK 本身已不再免费。 JFR 是一种分析工具，用于从正在运行的 Java 应用程序中收集诊断信息和分析数据。它的性能开销可以忽略不计，通常低于 1％。因此，它可以用于生产应用。 默认情况下，JVM 禁用了 JFR，要启动 JFR，必须使用 -XX:+FlightRecorder 选项启动。例如，我们要启动名为 MyApp 的应用程序： java -XX：+ UnlockCommercialFeatures -XX：+ FlightRecorder MyApp Java Fliight Recorder 小试牛刀 - https://juejin.im/post/6844903684912988167 ChaCha20 和 Poly1305 加密算法（JEP 329）Java 11 提供了 ChaCha20 和 ChaCha20-Poly1305 密码实现。这些算法将在 SunJCE 提供程序中实现。 有详细了解需求的朋友可以参看：https://mkyong.com/java/java-11-chacha20-poly1305-encryption-examples/ 改进 Aarch64 内部特征（JEP 315）改进现有的字符串和数组内在函数，并在 AArch64 处理器上为 java.lang.Math 包下的 sin，cos 和 log 函数实现新的内在函数。 弃用 Nashorn JavaScript 引擎（JEP 335)Nashorn JavaScript脚本引擎和jjs工具已被弃用，将来的发行版中可能会删除它。 (ps：Nashorn 是在 Java 8 JEP 174 中引入，以代替 Rhino Javascript 引擎。) 传输层安全性（TLS）1.3（JEP 332）Java 11 支持 RFC 8446 传输层安全性（TLS）1.3协议。但是，并非所有TLS 1.3功能都已实现，有关详细信息，请参考此 JEP 332。 Java 安全套接字扩展（JSSE）+ TLS 1.3 示例。 import javax.net.ssl.SSLSocket; import javax.net.ssl.SSLSocketFactory; SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault(); socket = (SSLSocket) factory.createSocket(\"google.com\", 443); socket.setEnabledProtocols(new String[]{\"TLSv1.3\"}); socket.setEnabledCipherSuites(new String[]{\"TLS_AES_128_GCM_SHA256\"}); 弃用 Pack200 工具和 API（JEP 336）该 JEP 不推荐 pack200 和 unpack200 工具以及软件包中的 Pack200 API java.util.jar，并且可能会在将来的版本中删除。 （ps：Java 14 JEP 367 中删除了 Pack200 工具和 API 。） 参考资料 OpenJDK 官方说明 - http://openjdk.java.net/projects/jdk/10/ Java 11 Features - https://www.journaldev.com/24601/java-11-features What is new in Java 11 - https://mkyong.com/java/what-is-new-in-java-11/ Java 11 Nest Based Access Control | Baeldung - https://www.baeldung.com/java-nest-based-access-control 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 全网最通透的 Java 8 版本特性讲解 - https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/ Java9的这些史诗级更新你都不知道？ - https://www.wmyskxz.com/2020/08/20/java9-ban-ben-te-xing-xiang-jie/ 你想了解的 JDK 10 版本更新都在这里 - https://www.wmyskxz.com/2020/08/21/java10-ban-ben-te-xing-xiang-jie/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java10版本特性详解","slug":"Java10版本特性详解","date":"2020-08-21T01:42:00.000Z","updated":"2020-12-09T05:04:55.809Z","comments":true,"path":"2020/08/21/java10-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/21/java10-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 10 中的引入的部分新特性。关于 Java 10 新特性更详细的介绍可参考这里。 基于时间的发行版本控制（JEP 322） 局部变量类型推断（JEP 286） 试验性 JIT 编译器（JEP 317） 应用程序类数据共享（JEP 310） 用于 G1 的并行 Full GC（JEP 307） 清理垃圾收集器接口（JEP 304） 其他 Unicode 语言标签扩展（JEP 314） 根证书（JEP 319） 线程本地握手（JEP 312） 备用存储设备上的堆分配（JEP 316） 删除本机头生成工具——javah（JEP 313） 将JDK森林合并到单个存储库中（JEP 296） API 变更 一. 基于时间的发行版本控制（JEP 322）发行版本号的前世今生自 Java 江山易主，JDK 发行版本的字符串命名方式一直是一个耐人寻味的话题。 单就下载 JDK 时，所看到的简短版本字符串形式来说，在 7u40 版本之前，u 之后的数字，代表了 JDK 发布以来的第几个修正版本，然而 Oracle 改变规则，为了彰显出安全之类的重大 修补（Cirtical Patch Updates）版本，采用 奇数 命名，而 Bug 修复、API 修改之类的 维护版本，则采用 偶数。（另有版本号 $MAJOR.$MINOR.$SECURITY 的格式来区分 Bug 修正和 API 修改） 为此，之前既有的 JDK 6/7 发布版本，还被重新命名。（下方演示） Actual Hypothetical Release Type long short ------------ ------------------------ Security 2013/06 1.7.0_25-b15 7u25 Minor 2013/09 1.7.0_40-b43 7u40 Security 2013/10 1.7.0_45-b18 7u45 Security 2014/01 1.7.0_51-b13 7u51 Minor 2014/05 1.7.0_60-b19 7u60 就结论而言，重新命名之后，从 7u9、6u37 开始，就可以从奇偶数来判别是否为重大修补版本；至于 7u40 之后的版本，重大修补版本 是基于 5 的倍数，遇偶数加一，而 维护版本 则会是 20 的倍数。如此（不直观）的命名方式，被规范在了 JEP223 中。（随着 JDK 9 一起发布的） 然而，自 JDK 8 发布之后，Oracle 的 Java 架构师 Mark Reinhold 就希望，未来 Java 发布可以基于时间，以半年为周期，持续发布新版本，让一些有用的小特性，也能被开发者使用，因此，JEP 223 的规范就不再适用了，而在 JDK 9 发布后，他们针对新版本曾经提出过基于 $YEAR.$MONTH 格式，然而收到了社区极大的反对，为此，还提出了三个替代方案，收集各方的意见。（https://goo.gl/7CA8B3) 那么，Java 下一个特性版本是 8.3？1803？还是 10？调查结果显示，社群大多数都支持 10，Stephen Colebourne 也发出请求（https://goo.gl/i5J44T），并表示 Java 不像 Ubuntu 这类操作系统，基于 $YEAR.$MONTH 并不合适。 最终，Oracle 采用了 $FEATURE.$INTERIM.$UPDATE.$PATCH 这样的方案，并规定在了 JEP 322 中。 JEP 322 新模式解读通过采用基于时间的发行周期，Oracle 更改了 Java SE 平台和 JDK 的版本字符串方案以及相关的版本信息，以适用于当前和将来的基于时间的发行模型。 版本号的新模式是： $FEATURE.$INTERIM.$UPDATE.$PATCH $ FEATURE：计数器将每 6 个月递增一次，并基于功能发布版本，例如：JDK 10，JDK 11。 $ INTERIM：对于包含兼容错误修复和增强功能但没有不兼容更改的非功能版本，计数器将增加。通常，这将是零，因为六个月内不会有任何临时发布。这保留了对发布模型的将来修订。 $ UPDATE：计数器将增加，用于解决安全问题，回归和较新功能中的错误的兼容更新版本。此功能会在功能发布后一个月更新，此后每三个月更新一次。2018 年 4 月版本是 JDK 10.0.1，7 月版本是 JDK 10.0.2，依此类推 $ PATCH：计数器将增加以用于紧急释放以解决严重问题。 并添加了新的 API 以通过编程的方式获取这些计数器： Version version = Runtime.version(); version.feature(); version.interim(); version.update(); version.patch(); 现在，让我们来看一下返回版本信息的 Java 启动器： $ java -version java version \"10\" 2018-03-20 Java(TM) SE Runtime Environment 18.3 (build 10+46) Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10+46, mixed mode) 版本号格式为 10，因为没有其他计数器为零。发布日期已添加。可以将 18.3 理解为 Year 2018＆3rd Month，版本 10 + 46 是版本 10 的 46 版本。对于 JDK 10.0.1 的假设版本 93，版本将为 10.0.1 + 93。 因此，对于 Java 9 来说，目前可以看到的版本，会是 9.0.4 这样的格式，至于 2018 年 3 月发布的特性版本为 10，到了 9 月提供的新版本，就是 11，JDK 11 预计会是长期支援版本，所以，在版本字串上，也会特别显示 LTS（long-term support）。 二. 局部变量类型推断（JEP 286）概述JDK 10 中最明显的增强功能之一是使用初始化程序对局部变量进行类型推断。 在 Java 9 之前，我们必须明确写出局部变量的类型，并确保它与用于初始化它的初始化程序兼容： String message = \"Good bye, Java 9\"; 在 Java 10 中，这是我们可以声明局部变量的方式： @Test public void whenVarInitWithString_thenGetStringTypeVar() { var message = \"Hello, Java 10\"; assertTrue(message instanceof String); } 我们没有提供 message 的具体类型，相反，我们把 message 标记为了 var，编译器将从右侧的初始化程序的类型推断出 message 的类型。（上面的例子中 message 为 String 类型） 请注意，此功能仅适用于带有初始化程序的局部变量。它不能用于成员变量、方法参数、返回类型等——初始化程序是必须的，否则，编译器无法推断出其类型。 这个功能有助于我们减少样板式的代码，例如： Map&lt;Integer, String> map = new HashMap&lt;>(); 现在可以改写为： var idToNameMap = new HashMap&lt;Integer, String>(); 这也有助于我们把重点放在变量名，而不是变量类型上。 要注意的另一件事是 var 不是关键字——这确保了使用 var 作为函数或变量名的程序的向后兼容性。var 是一个保留类型名，就像 int 一样。 最后，使用 var 不会增加运行时的开销，也不会使 Java 称为动态类型的语言。变量的类型仍然是在编译时进行判断，以后也无法更改。 非法使用 var 的情况解析1、如果没有初始化程序，var 将无法工作： var n; // error: cannot use 'var' on variable without initializer 2、如果将其初始化为 null，也不会起作用： var emptyList = null; // error: variable initializer is 'null' 3、不适用于非局部变量： public var word = \"hello\"; // error: 'var' is not allowed here 4、Lambda 表达式需要显式的类型，因此无法使用 var： var p = (String s) -> s.length() > 10; // error: lambda expression needs an explicit target-type 5、数组初始化程序也不支持： var arr = { 1, 2, 3 }; // error: array initializer needs an explicit target-type 使用 var 的准则在某些情况下，我们可以合法使用 var，但这样做并不是一个好主意。 例如，在代码的可读性降低的情况下： var result = obj.prcoess(); 在这里，尽管可以合法使用 var，但很难理解 process() 返回的类型，从而让代码的可读性降低。 java.net(OpenJDK 官网)上专门有一篇文章介绍了 Java 中的局部变量类型推断的书写准则，该文章讨论了在使用此功能时应该注意的姿势和如何使用的一些良好建议。 另外，最好避免使用 var 的另一种情况是在流水线较长的流中： var x = emp.getProjects.stream() .findFirst() .map(String::length) .orElse(0); 另外，将 var 与不可引用类型一起使用可能会导致意外错误。 比如，如果我们将 var 与匿名类实例一起使用： @Test public void whenVarInitWithAnonymous_thenGetAnonymousType() { var obj = new Object() {}; assertFalse(obj.getClass().equals(Object.class)); } 现在，如果我们尝试将另一个 Object 分配给 obj，则会出现编译错误： obj = new Object(); // error: Object cannot be converted to &lt;anonymous Object> 这是因为 obj 的推断类型不是 Object。 三. 试验性 JIT 编译器（JEP 317）Graal 是用Java编写的，与 HotSpot JVM 集成的动态编译器。它专注于高性能和可扩展性。它也是 JDK 9 中引入的实验性 Ahead-of-Time（AOT）编译器的基础。 JDK 10 使 Graal 编译器可以用作 Linux / x64 平台上的实验性 JIT 编译器。 要将 Graal 用作 JIT 编译器，请在 Java 命令行上使用以下选项： -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler 请注意，这是一个实验性功能，我们不一定会获得比现有JIT编译器更好的性能。 想要了解更多内容的童鞋请参考 Chris Seaton 的演讲：https://chrisseaton.com/truffleruby/jokerconf17/ （ps：长文 + 特别底层警告..） 四. 应用程序类数据共享(JEP 310)JDK 5 中引入的类数据共享允许将一组类预处理成共享的归档文件，然后在运行时对其进行内存映射，以减少启动时间，这还可以在多个 JVM 共享相同的归档文件时减少动态内存占用。 CDS 只允许引导类装入器，将该特性限制为系统类。应用程序 CDS (AppCDS）扩展了 CDS 以允许内置的系统类装入器。内置的平台类装入器和用于装入归档类的自定义类装入器。这使得对应用程序类使用该特性成为可能。 我们可以使用以下步骤来使用这个功能： 1、获取要存档的类列表 以下命令会将HelloWorld 应用程序加载的类转储到hello.lst中： $ java -Xshare:off -XX:+UseAppCDS -XX:DumpLoadedClassList=hello.lst \\ -cp hello.jar HelloWorld 2、创建 AppCDS 存档 以下命令使用hello.lst 作为输入创建hello.js a ： $ java -Xshare:dump -XX:+UseAppCDS -XX:SharedClassListFile=hello.lst \\ -XX:SharedArchiveFile=hello.jsa -cp hello.jar 3、使用 AppCDS 存档 以下命令以hello.jsa 作为输入启动HelloWorld 应用程序： $ java -Xshare:on -XX:+UseAppCDS -XX:SharedArchiveFile=hello.jsa \\ -cp hello.jar HelloWorld AppCDS 是用于 JDK 8 和 JDK 9 的 Oracle JDK 中的一项商业功能。现在它是开源的，并且可以公开使用。 五. 用于 G1 的并行 Full GC(JEP 307)G1 垃圾收集器是自 JDK 9 以来的默认垃圾收集器。但是，G1 的 Full GC 使用了单线程的 mark-sweep-compact 算法。 它已 更改为 Java 10 中 的并行mark-sweep-compact算法 ，有效地减少了 Full GC 期间的停滞时间。 六. 清理垃圾收集器接口（JEP 304）这个 JEP 是未来的变化。通过引入公共垃圾收集器接口，它改善了不同垃圾收集器的代码隔离。 次更改为内部 GC 代码提供了更好的模块化。将来将有助于在不更改现有代码库的情况下添加新 GC，还有助于删除或保留以前的 GC。 官方的动机解释： （传送门） 当前，每个垃圾收集器实现都由其 src/hotspot/share/gc/$NAME 目录内的源文件组成，例如 G1 在中 src/hotspot/share/gc/g1，CMS 在 src/hotspot/share/gc/cms 等中。但是，在 HotSpot 中散布着一些零散的信息。例如，大多数 GC 需要某些障碍，这些障碍需要在运行时，解释器 C1 和 C2 中实现。这些障碍并不包含在 GC 的具体目录，但在共享解释器，而不是实施，C1 和 C2 的源代码（通常由长守卫if- else-chains）。同样的问题也适用于诊断代码，例如 MemoryMXBeans。此源代码布局有几个缺点： 对于GC开发人员，实施新的垃圾收集器需要有关所有这些地方的知识，以及如何扩展它们以满足其特定需求的知识。 对于不是 GC 开发人员的 HotSpot 开发人员，在哪里为给定 GC 找到特定的代码段会造成混乱。 在构建时很难排除特定的垃圾收集器。该#define INCLUD E_ALL_GCS长期以来建立与唯一内置串行收集JVM的一种方式，但这种机制变得过于呆板。 较干净的 GC 接口将使实现新的收集器更加容易，使代码更加清洁，并且在构建时排除一个或多个收集器也更加容易。添加一个新的垃圾收集器应该是实现一组有据可查的接口，而不是弄清 HotSpot 中所有需要更改的地方。 七. 其他Unicode语言标签扩展（JEP 314）此功能增强了 java.util.Locale 和相关 API，以实现 BCP 47 语言标签的其他 Unicode 扩展。从 Java SE 9 开始，受支持的 BCP 47 U 语言扩展名是 “ca” 和 “nu”。该 JEP 将增加对以下附加扩展的支持： cu（货币类型） fw（一周的第一天） rg（区域覆盖） tz（时区） 为了支持这些附加扩展，对以下各种 API 进行了更改以提供基于 U 或附加扩展的信息： java.text.DateFormat::get*Instance java.text.DateFormatSymbols::getInstance java.text.DecimalFormatSymbols::getInstance java.text.NumberFormat::get*Instance java.time.format.DateTimeFormatter::localizedBy java.time.format.DateTimeFormatterBuilder::getLocalizedDateTimePattern java.time.format.DecimalStyle::of java.time.temporal.WeekFields::of java.util.Calendar::{getFirstDayOfWeek,getMinimalDaysInWeek} java.util.Currency::getInstance java.util.Locale::getDisplayName java.util.spi.LocaleNameProvider 八. 根证书（JEP 319）cacerts 密钥库（迄今为止到目前为止是空的）旨在包含一组根证书，这些根证书可用于建立对各种安全协议所使用的证书链的信任。 结果，在 OpenJDK 构建中，诸如 TLS 之类的关键安全组件默认情况下不起作用。 借助 Java 10，Oracle 将 Oracle Java SE Root CA 程序中 的根证书开源了 ，以使 OpenJDK 构建对开发人员更具吸引力，并减少了这些构建与 Oracle JDK 构建之间的差异。 九. 线程本地握手（JEP 312）这是用于提高 JVM 性能的内部特性。 握手操作是在线程处于安全点状态时为每个 JavaThread 执行的回调。回调由线程本身或 VM 线程执行，同时保持线程处于阻塞状态。 这个特性提供了一种无需执行全局 VM 安全点即可在线程上执行回调的方法。使停止单个线程，而不是停止所有线程或不停止线程成为可能，而且代价低廉。 十. 备用存储设备上的堆分配(JEP 316)应用程序的内存消耗越来越大，本地云应用程序、内存中的数据库、流应用程序都在增加。为了满足这些服务，有各种可用的内存架构。这个特性增强了 HotSpot VM 在用户指定的备用内存设备(比如NV-DIMM)上分配 Java 对象堆的能力。 这个 JEP 的目标是具有与 DRAM 相同语义(包括原子操作的语义)的可选内存设备，因此，可以在不更改现有应用程序代码的情况下，将其用于对象堆，而不是用于 DRAM。 十一. 删除本机头生成工具—javah (JEP 313)这是一个从 JDK 中删除 javah 工具的常规更改。工具功能是作为 JDK 8 的一部分在 javac 中添加的，它提供了在编译时编写使 javah 无用的本机头文件的能力。 十二. 将JDK森林合并到单个存储库中(JEP 296)多年来，有各种各样的 Mercurial 存储库用于 JDK 代码基。不同的存储库确实提供了一些优势，但它们也有各种操作上的缺点。作为这个变化的一部分，JDK 森林的许多存储库被合并到一个存储库中，以简化和简化开发。 十三. API 变更Java 10 添加和删除了 API。Java 9 引入了增强的弃用，其中某些 API 被标记为将在未来的版本中删除。 于是这些 API 被删除了：你可以在 这里 找到被删除的 API。 新增API: Java 10 中新增 73 个API。您可以在 这里 找到添加的 API 并进行比较。 让我们来看看对我们直接有用的部分。 不可修改集合的改进Java 10 中有一些与不可修改集合相关的更改 copyOf()java.util.List、java.util.Map 和 java.util.Set 都有了一个新的静态方法 copyOf(Collection)。 它返回给定 Collection 的不可修改的副本： jshell> var originList = new ArrayList&lt;String>(); originList ==> [] jshell> originList.add(\"欢迎关注公众号：\"); $2 ==> true jshell> originList.add(\"我没有三颗心脏\"); $3 ==> true jshell> var copyList = List.copyOf(originList) copyList ==> [欢迎关注公众号：, 我没有三颗心脏] jshell> originList.add(\"获取更多精彩内容\") $5 ==> true jshell> System.out.println(copyList) [欢迎关注公众号：, 我没有三颗心脏] jshell> copyList.add(\"获取更多精彩内容\") | 异常错误 java.lang.UnsupportedOperationException | at ImmutableCollections.uoe (ImmutableCollections.java:73) | at ImmutableCollections$AbstractImmutableCollection.add (ImmutableCollections.java:77) | at (#7:1) jshell> toUnmodifiable()java.util.Collectors 获得其他方法来将 Stream 收集到不可修改的 List、Map 或 Set 中： @Test(expected = UnsupportedOperationException.class) public void whenModifyToUnmodifiableList_thenThrowsException() { List&lt;Integer> evenList = someIntList.stream() .filter(i -> i % 2 == 0) .collect(Collectors.toUnmodifiableList()); evenList.add(4); } 任何尝试修改此类集合的尝试都会导致 java.lang.UnsupportedOperationException 运行时异常。 Optinal 新增方法 orElseThrow()java.util.Optional，java.util.OptionalDouble，java.util.OptionalInt 和 java.util.OptionalLong 都有一个新方法 orElseThrow()，它不接受任何参数，如果不存在任何值，则抛出 NoSuchElementException： @Test public void whenListContainsInteger_OrElseThrowReturnsInteger() { Integer firstEven = someIntList.stream() .filter(i -> i % 2 == 0) .findFirst() .orElseThrow(); is(firstEven).equals(Integer.valueOf(2)); } 它与现有的 get() 方法同义，并且现在是它的首选替代方法。 参考资料 OpenJDK 官方说明 - http://openjdk.java.net/projects/jdk/10/ Java 10 Features | JournalDev - https://www.journaldev.com/20395/java-10-features 想跳舞的 Java | 林信良 - https://www.ithome.com.tw/voice/122249 Java 10 Performance Improvements | Baeldung - https://www.baeldung.com/java-10-performance-improvements 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 全网最通透的 Java 8 版本特性讲解 - https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/ Java9的这些史诗级更新你都不知道？ - https://www.wmyskxz.com/2020/08/20/java9-ban-ben-te-xing-xiang-jie/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java9版本特性详解","slug":"Java9版本特性详解","date":"2020-08-20T03:22:00.000Z","updated":"2020-12-09T05:04:53.096Z","comments":true,"path":"2020/08/20/java9-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/20/java9-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 9 中的引入的部分新特性。关于 Java 9 新特性更详细的介绍可参考这里。 REPL（JShell） 不可变集合的工厂方法 模块系统 接口支持私有化 钻石操作符升级 Optional 改进 Stream API 改进 反应式流（Reactive Streams） 进程 API 升级的 Try-With-Resources HTTP / 2 多版本兼容 Jar 包 其他 改进应用安全性能 统一 JVM 日志 G1 设为默认垃圾回收器 String 底层存储结构更改 CompletableFuture API 改进 I/O 流新特性 JavaScript 引擎 Nashorn 改进 标识符增加限制 改进的 Javadoc 改进的 @Deprectaed 注解 多分辨率图像 API 变量句柄 改进方法句柄（Method Handle） 提前编译 AOT 一. Java 9 REPL（JShell）什么是 REPL 以及为什么引入REPL，即 Read-Evaluate-Print-Loop 的简称。由于 Scala 语言的特性和优势在小型应用程序到大型应用程序市场大受追捧，于是引来 Oracle 的关注，并尝试将大多数 Scala 功能集成到 Java 中。这在 Java 8 中已经完成一部分，比如 Lambda 表达式。 Scala 的最佳功能之一就是 REPL，这是一个命令行界面和 Scala 解释器，用于执行 Scala 程序。由于并不需要开启额外的 IDE (就是一个命令行)，它在减少学习曲线和简化运行测试代码方面有独特的优势。 于是在 Java 9 中引入了 Java REPL，也称为 JShell。 JShell 基础打开命令提示符，确保您具有 Java 9 或更高版本，键入 jshell，然后我们就可以开心的使用了。 下面是简单示范： wmyskxz:~ wmyskxz$ jshell | Welcome to JShell -- Version 9 | For an introduction type: /help intro jshell> jshell> System.out.println(\"Hello World\"); Hello World jshell> String str = \"Hello JShell!\" str ==> \"Hello JShell!\" jshell> str str ==> \"Hello JShell!\" jshell> System.out.println(str) Hello JShell! jshell> int counter = 0 counter ==> 0 jshell> counter++ $6 ==> 0 jshell> counter counter ==> 1 jshell> counter+5 $8 ==> 6 也可以在 Java Shell 中定义和执行类方法： jshell> class Hello { ...> public static void sayHello() { ...> System.out.print(\"Hello\"); ...> } ...> } | created class Hello jshell> Hello.sayHello() Hello jshell> Java REPL - 帮助和退出要获得 jshell 工具的帮助部分，请使用/help命令。要从 jshell 退出，请使用 /exit 命令 (或者直接使用 Ctrl + D 命令退出)。 jshell> /help | Type a Java language expression, statement, or declaration. | Or type one of the following commands: | /list [&lt;name or id>|-all|-start] | list the source you have typed | /edit &lt;name or id> ... jshell> /exit | Goodbye wmyskxz:~ wmyskxz$ 二. 不可变集合的工厂方法Java 9 中增加了一些便捷的工厂方法用于创建 不可变 List、Set、Map 以及 Map.Entry 对象。 在 Java SE 8 和更早的版本中，如果我们要创建一个空的 不可变 或 不可修改 的列表，需要借助 Collections 类的 unmodifiableList() 方法才可以： List&lt;String> list = new ArrayList&lt;>(); list.add(\"公众号\"); list.add(\"我没有三颗心脏\"); list.add(\"关注走起来\"); List&lt;String> immutableList = Collections.unmodifiableList(list); 可以看到，为了创建一个非空的不可变列表，我们需要经历很多繁琐和冗长的步骤。为了克服这一点，Java 9 在 List 接口中引入了以下有用的重载方法： static &lt;E> List&lt;E> of(E e1) static &lt;E> List&lt;E> of(E e1,E e2) static &lt;E> List&lt;E> of(E e1,E e2,E e3) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4,E e5) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4,E e5,E e6) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4,E e5,E e6,E e7) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9) static &lt;E> List&lt;E> of(E e1,E e2,E e3,E e4,E e5,E e6,E e7,E e8,E e9,E e10) 以及可变参数数目的方法： static &lt;E> List&lt;E> of(E... elements) 可以看到 Java 9 前后的对比： // Java 9 之前 List&lt;String> list = new ArrayList&lt;>(); list.add(\"公众号\"); list.add(\"我没有三颗心脏\"); list.add(\"关注走起来\"); List&lt;String> unmodifiableList = Collections.unmodifiableList(list); // 或者使用 {{}} 的形式 List&lt;String> list = new ArrayList&lt;>() {{ add(\"公众号\"); add(\"我没有三颗心脏\"); add(\"关注走起来\"); }}; List&lt;String> unmodifiableList = Collections.unmodifiableList(list); // Java 9 便捷的工厂方法 List&lt;String> unmodifiableList = List.of(\"公众号\", \"我没有三颗心脏\", \"关注走起来\"); (ps: Set、Map 类似，Map 有两组方法：of() 和 ofEntries() 分别用于创建 Immutable Map 对象和 Immutable Map.Entry 对象) 另外 Java 9 可以直接输出集合的内容，在此之前必须遍历集合才能全部获取里面的元素，这是一个很大的改进。 不可变集合的特征不可变即不可修改。它们通常具有以下几个特征： 1、我们无法添加、修改和删除其元素； 2、如果尝试对它们执行添加/删除/更新操作，将会得到 UnsupportedOperationException 异常，如下所示： jshell> immutableList.add(\"Test\") | java.lang.UnsupportedOperationException thrown: | at ImmutableCollections.uoe (ImmutableCollections.java:68) | at ImmutableCollections$AbstractImmutableList.add (ImmutableCollections.java:74) | at (#2:1) 3、不可变集合不允许 null 元素； 4、如果尝试使用 null 元素创建，则会报出 NullPointerException 异常，如下所示： jshell> List>String> immutableList = List.of(\"公众号\",\"我没有三颗心脏\",\"关注走起来\", null) | java.lang.NullPointerException thrown: | at Objects.requireNonNull (Objects.java:221) | at ImmutableCollections$ListN. (ImmutableCollections.java:179) | at List.of (List.java:859) | at (#4:1) 5、如果尝试添加 null 元素，则会得到 UnsupportedOperationException 异常，如下所示： jshell> immutableList.add(null) | java.lang.UnsupportedOperationException thrown: | at ImmutableCollections.uoe (ImmutableCollections.java:68) | at ImmutableCollections$AbstractImmutableList.add (ImmutableCollections.java:74) | at (#3:1) 6、如果所有元素都是可序列化的，那么集合是可以序列化的； 三. 模块系统Java 模块系统是 Oracle 在 Java 9 引入的全新概念。最初，它作为 Java SE 7 Release 的一部分启动了该项目，但是由于进行了很大的更改，它被推迟到了 Java SE 8，然后又被推迟了。最终随着 2017 年 9 月发布的 Java SE 9 一起发布。 为什么需要模块系统？当代码库变得更大时，创建复杂、纠结的 “意大利面条代码” 的几率成倍增加。在 Java 8 或更早版本交付 Java 应用时存在几个基本问题： 难以真正封装代码，并且在系统的不同部分（JAR 文件）之间没有显式依赖关系的概念。每个公共类都可以由 classpath 上的任何其他公共类访问，从而导致无意中使用了本不应该是公共 API 的类。 再者，类路径本身是有问题的：您如何知道是否所有必需的 JAR 都存在，或者是否存在重复的条目？ 另外，JDK 太大了，rt.jar （rt.jar 就是 Java 基础类库——也就是 Java Doc 里面看到的所有类的 class 文件）等 JAR 文件甚至无法在小型设备和应用程序中使用：因此我们的应用程序和设备无法支持更好的性能——打包之后的应用程序太大了——也很难测试和维护应用程序。 模块系统解决了这几个问题。 什么是 Java 9 模块系统？模块就是代码、数据和一些资源的自描述集合。它是一组与代码、数据和资源相关的包。 每个模块仅包含一组相关的代码和数据，以支持单一职责原则（SRP)。 Java 9 模块系统的主要目标就是支持 Java 模块化编程。（我们将在下面👇体验一下模块化编程） 比较 JDK 8 和 JDK 9我们知道 JDK 软件包含什么。安装 JDK 8 软件后，我们可以在 Java Home 文件夹中看到几个目录，例如 bin，jre，lib 等。 但是，Oracle 在 Java 9 中对该文件夹结构的更改有些不同，如下所示。 这里的 JDK 9 不包含 JRE。在 JDK 9 中，JRE 分为一个单独的分发文件夹。JDK 9 软件包含一个新文件夹 “ jmods”，它包含一组 Java 9 模块。在 JDK 9 中，没有 rt.jar 和 tools.jar。（如下所示） 注意： 截止今天， jmods 包含了 95 个模块。（最终版可能更多） 比较 Java 8 和 Java 9 应用程序我们已经使用 Java 5、Java 6、Java 7 或 Java 8 开发了许多 Java 应用程序了，我们知道 Java 8 或更早版本的应用程序，顶级组件是 Package： Java 9 应用程序与此没有太大的区别。它刚刚引入了称为 “模块” 和称为模块描述符（module-info.java）的新组件： 像 Java 8 应用程序将 Packages 作为顶级组件一样，Java 9 应用程序将 Module 作为顶级组件。 注意：每个 Java 9 模块只有一个模块和一个模块描述符。与 Java 8 包不同，我们不能在一个模块中创建多个模块。 HelloModule 示例程序作为开发人员，我们首先从 “HelloWorld” 程序开始学习新的概念或编程语言。以同样的方式，我们开始通过 “ HelloModule” 模块开发来学习 Java 9 新概念“ 模块化编程 ”。 第一步：创建一个空的 Java 项目如果不想额外命名的话一路 Next 就好了： 第二步：创建 HelloModule 模块右键项目，创建一个新的【Module】，命名为：com.wmyskxz.core 并在新 Module 的 src 文件夹下新建包 module.hello，此时项目结构： . └── com.wmyskxz.core └── src └── module └── hello 第三步：编写 HelloModule.java在刚才创建的包下新建 HelloModule 文件，并编写测试用的代码： package module.hello; public class HelloModule { public void sayHello() { System.out.println(\"Hello Module!\"); } } 第四步：为 Module 编写模块描述符在 IDEA 中，我们可以直接右键 src 文件夹，快捷创建 module-info.java 文件： 编写 module-info.java 文件，将我们刚才的包 module.hello 里面的内容暴露出去（给其他 Module 使用）： module com.wmyskxz.core { exports module.hello; } module 关键字后面是我们的模块名称，里面的 exports 写明了我们想要暴露出去的包。此时的文件目录结构： . └── com.wmyskxz.core └── src ├── module │ └── hello │ └── HelloModule.java └── module-info.java 第五步：同样的方法编写客户端用上面同样的方法，我们在项目根目录创建一个 com.wmyskxz.client 的 Module，并新建 module.client 包目录，并创建好我们的 HelloModuleClient 文件的大概样子： // HelloModuleClient.java package module.client; public class HelloModuleClient { public static void main(String[] args) { } } 如果我们想要直接调用 HelloModule 类，会发现 IDEA 并没有提示信息，也就是说我们无法直接引用了.. 我们需要先在模块描述符（同样需要在 src 目录创建 module-info.java 文件）中显式的引入我们刚才暴露出来的 com.wmyskxz.core 模块： module com.wmyskxz.client { requires com.wmyskxz.core; } （ps：在 IDEA 中编写完成之后需要手动 alt + enter 引入模块依赖） 这一步完成之后，我们就可以在刚才的 HelloModuleClient 中愉快的使用 HelloModule 文件了： package module.client; import module.hello.HelloModule; public class HelloModuleClient { public static void main(String[] args) { HelloModule helloModule = new HelloModule(); helloModule.sayHello(); } } 此时的项目结构： . ├── com.wmyskxz.client │ └── src │ ├── module │ │ └── client │ │ └── HelloModuleClient.java │ └── module-info.java └── com.wmyskxz.core └── src ├── module │ └── hello │ └── HelloModule.java └── module-info.java 第六步：运行测试运行代码： Hello Module! 成功！ 模块系统小结我们从上面的例子中可以看到，我们可以指定我们想要导出和引用的软件包，没有人可以不小心地使用那些不想被导出的软件包中的类。 Java 平台本身也已经使用其自己的模块系统对 JDK 进行了模块化。启动模块化应用程序时，JVM 会根据 requires 语句验证是否可以解析所有模块，这比脆弱的类路径要安全得多。模块使您能够通过强力执行封装和显式依赖来更好地构建应用程序。 四. 接口支持私有方法在 Java 8 中，我们可以使用 default 和 static 方法在 Interfaces 中提供方法实现。但是，我们不能在接口中创建私有方法。 为了避免冗余代码和提高重用性，Oracle Corp 将在 Java SE 9 接口中引入私有方法。从 Java SE 9 开始，我们就可以使用 private 关键字在接口中编写私有和私有静态方法。 这些私有方法仅与其他类私有方法一样，它们之间没有区别。以下是演示： public interface FilterProcess&lt;T> { // java 7 及以前 特性 全局常量 和抽象方法 public static final String a =\"22\"; boolean process(T t); // java 8 特性 静态方法和默认方法 default void love(){ System.out.println(\"java8 特性默认方法\"); } static void haha(){ System.out.println(\"java8 特性静态方法\"); } // java 9 特性 支持私有方法 private void java9(){} } 五. 钻石操作符升级我们知道，Java SE 7 引入了一项新功能：Diamond 运算符可避免多余的代码和冗长的内容，从而提高了可读性。但是，在 Java SE 8 中，Oracle Corp（Java库开发人员）发现将 Diamond 运算符与匿名内部类一起使用时存在一些限制。他们已解决了这些问题，并将其作为 Java 9 的一部分发布。 // java6 及以前 Map&lt;String,String> map7 = new HashMap&lt;String,String>(); // java7 和 8 &lt;> 没有了数据类型 Map&lt;String,String> map8 = new HashMap&lt;>(); // java9 添加了匿名内部类的功能 后面添加了大括号 {} 可以做一些细节的操作 Map&lt;String,String> map9 = new HashMap&lt;>(){}; 六. Optional 改进在 Java SE 9 中，Oracle Corp 引入了以下三种方法来改进 Optional 功能。 stream()； ifPresentOrElse()； or() 可选 stream() 方法如果给定的 Optional 对象中存在一个值，则此 stream() 方法将返回一个具有该值的顺序 Stream。否则，它将返回一个空流。 Java 9 中添加的stream() 方法允许我们延迟地处理可选对象，下面是演示： jshell> long count = Stream.of( ...> Optional.of(1), ...> Optional.empty(), ...> Optional.of(2) ...> ).flatMap(Optional::stream) ...> .count(); ...> System.out.println(count); ...> count ==> 2 2 (Optiona l 流中包含 3 个 元素，其中只有 2 个有值。在使用 flatMap 之后，结果流中包含了 2 个值。) 可选 ifPresentOrElse() 方法我们知道，在 Java SE 8 中，我们可以使用 ifPresent()、isPresent() 和 orElse() 方法来检查 Optional 对象并对其执行功能。这个过程有些繁琐，Java SE 9 引入了一种新的方法来克服此问题。 下面是示例： jshell> Optional&lt;Integer> opt1 = Optional.of(4) opt1 ==> Optional[4] jshell> opt1.ifPresentOrElse( x -> System.out.println(\"Result found: \" + x), () -> System.out.println(\"Not Found.\")) Result found: 4 jshell> Optional&lt;Integer> opt2 = Optional.empty() opt2 ==> Optional.empty jshell> opt2.ifPresentOrElse( x -> System.out.println(\"Result found: \" + x), () -> System.out.println(\"Not Found.\")) Not Found. 可选 or() 方法在 Java SE 9 中，使用 or() 方法便捷的返回值。如果 Optional 包含值，则直接返回原值，否则就返回指定的值。or() 方法将 Supplier 作为参数指定默认值。下面是 API 的定义： public Optional&lt;T> or(Supplier&lt;? extends Optional&lt;? extends T>> supplier) 下面是有值情况的演示： jshell> Optional&lt;String> opStr = Optional.of(\"Rams\") opStr ==> Optional[Rams] jshell> import java.util.function.* jshell> Supplier&lt;Optional&lt;String>> supStr = () -> Optional.of(\"No Name\") supStr ==> $Lambda$67/222624801@23faf8f2 jshell> opStr.or(supStr) $5 ==> Optional[Rams] 下面是为空情况的演示： jshell> Optional&lt;String> opStr = Optional.empty() opStr ==> Optional.empty jshell> Supplier&lt;Optional&lt;String>> supStr = () -> Optional.of(\"No Name\") supStr ==> $Lambda$67/222624801@23faf8f2 jshell> opStr.or(supStr) $7 ==> Optional[No Name] 七. Stream API 改进长期以来，Streams API 可以说是对 Java 标准库的最佳改进之一。在 Java 9 中，Stream 接口新增加了四个有用的方法：dropWhile、takeWhile、ofNullable 和 iterate。下面我们来分别演示一下。 takeWhile() 方法在 Stream API 中，takeWhile() 方法返回与 Predicate 条件匹配的最长前缀元素。 它以 Predicate 接口作为参数。Predicate 是布尔表达式，它返回 true 或 false。对于有序和无序流，其行为有所不同。让我们通过下面的一些简单示例对其进行探讨。 Stream API 定义： default Stream&lt;T> takeWhile(Predicate&lt;? super T> predicate) 有序流示例： - jshell> Stream&lt;Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9,10) stream ==> java.util.stream.ReferencePipeline$Head@55d56113 jshell> stream.takeWhile(x -> x &lt; 4).forEach(a -> System.out.println(a)) 1 2 3 无序流示例： - jshell> Stream&lt;Integer> stream = Stream.of(1,2,4,5,3,6,7,8,9,10) stream ==> java.util.stream.ReferencePipeline$Head@55d56113 jshell> stream.takeWhile(x -> x &lt; 4).forEach(a -> System.out.println(a)) 1 2 从上面的例子中我们可以看出，takeWhile() 方法在遇到第一个返回 false 的元素时，它将停止向下遍历。 dropWhile() 方法与 takeWhile() 相对应，dropWhile() 用于删除与条件匹配的最长前缀元素，并返回其余元素。 Stream API 定义： default Stream&lt;T> dropWhile(Predicate&lt;? super T> predicate) 有序流示例： - jshell> Stream&lt;Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9,10) stream ==> java.util.stream.ReferencePipeline$Head@55d56113 jshell> stream.dropWhile(x -> x &lt; 4).forEach(a -> System.out.println(a)) 4 5 6 7 8 9 10 无序流示例： - jshell> Stream&lt;Integer> stream = Stream.of(1,2,4,5,3,6,7,8,9,10) stream ==> java.util.stream.ReferencePipeline$Head@55d56113 jshell> stream.dropWhile(x -> x &lt; 4).forEach(a -> System.out.println(a)) 4 5 3 6 7 8 9 10 iterate() 方法在 Stream API 中，iterate() 方法能够返回以 initialValue（第一个参数）开头，匹配 Predicate（第二个参数），并使用第三个参数生成下一个元素的元素流。 Stream API 定义： static &lt;T> Stream&lt;T> iterate(T seed, Predicate&lt;? super T> hasNext, UnaryOperator&lt;T> next) IntStream 迭代示例： - jshell> IntStream.iterate(2, x -> x &lt; 20, x -> x * x).forEach(System.out::println) 2 4 16 这里，整个元素流以数字 2 开始，结束条件是 &lt; 20，并且在下一次迭代中，递增值是自身值的平方。 而这在 Java SE 8 中需要辅助 filter 条件才能完成： jshell> IntStream.iterate(2, x -> x * x).filter(x -> x &lt; 20).forEach(System.out::println) 2 4 16 ofNullable() 方法在 Stream API 中，ofNullable() 返回包含单个元素的顺序 Stream（如果非null），否则返回空 Stream。 Java SE 9 示例： - jshell> Stream&lt;Integer> s = Stream.ofNullable(1) s ==> java.util.stream.ReferencePipeline$Head@1e965684 jshell> s.forEach(System.out::println) 1 jshell> Stream&lt;Integer> s = Stream.ofNullable(null) s ==> java.util.stream.ReferencePipeline$Head@3b088d51 jshell> s.forEach(System.out::println) jshell> 注意：Stream 的子接口（如 IntStream、LongStream 等..）都继承了上述的 4 种方法。 八. 反应式流（Reactive Streams）反应式编程的思想最近得到了广泛的流行。在 Java 平台上有流行的反应式库 RxJava 和 Reactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。 Java SE 9 Reactive Streams API 是一个发布/订阅框架，用于实现 Java 语言非常轻松地实现异步操作，可伸缩和并行应用程序。 （从上图中可以很清楚地看到，Processor既可以作为订阅服务器，也可以作为发布服务器。） 反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。 反应流示例让我们从一个简单的示例开始，在该示例中，我们将实现 Flow API Subscriber 接口并使用 SubmissionPublisher 创建发布者并发送消息。 流数据假设我们有一个 Employee 类，它将用于创建要从发布者发送到订阅者的流消息。 package com.wmyskxz.reactive.beans; public class Employee { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Employee(int i, String s) { this.id = i; this.name = s; } public Employee() { } @Override public String toString() { return \"[id=\" + id + \",name=\" + name + \"]\"; } } 我们还有一个实用的工具类，可以为我们创建一个雇员列表： package com.wmyskxz.reactive.streams; import com.wmyskxz.reactive.beans.Employee; import java.util.List; public class EmpHelper { public static List&lt;Employee> getEmps() { return List.of( new Employee(1, \"我没有三颗心脏\"), new Employee(2, \"三颗心脏\"), new Employee(3, \"心脏\") ); } } 订阅者package com.wmyskxz.reactive.streams; import com.wmyskxz.reactive.beans.Employee; import java.util.concurrent.Flow.Subscriber; import java.util.concurrent.Flow.Subscription; public class MySubscriber implements Subscriber&lt;Employee> { private Subscription subscription; private int counter = 0; @Override public void onSubscribe(Subscription subscription) { System.out.println(\"Subscribed\"); this.subscription = subscription; this.subscription.request(1); // requesting data from publisher System.out.println(\"onSubscribe requested 1 item\"); } @Override public void onNext(Employee item) { System.out.println(\"Processing Employee \" + item); counter++; this.subscription.request(1); } @Override public void onError(Throwable e) { System.out.println(\"Some error happened\"); e.printStackTrace(); } @Override public void onComplete() { System.out.println(\"All Processing Done\"); } public int getCounter() { return counter; } } Subscription变量以保留引用，以便可以在onNext方法中提出请求。 counter变量以保持已处理项目数的计数，请注意，其值在 onNext 方法中增加了。在我们的 main 方法中将使用它来等待执行完成，然后再结束主线程。 在onSubscribe方法中调用订阅请求以开始处理。还要注意，onNext在处理完项目后再次调用该方法，要求发布者处理下一个项目。 onError并onComplete在这里没有太多作用，但在现实世界中的场景，他们应该被使用时出现的错误或资源的清理成功处理完成时进行纠正措施。 反应式流测试程序 我们将SubmissionPublisher作为示例使用 Publisher，因此让我们看一下反应流实现的测试程序： package com.wmyskxz.reactive.streams; import com.wmyskxz.reactive.beans.Employee; import java.util.List; import java.util.concurrent.SubmissionPublisher; public class MyReactiveApp { public static void main(String[] args) throws InterruptedException { // Create Publisher SubmissionPublisher&lt;Employee> publisher = new SubmissionPublisher&lt;>(); // Register Subscriber MySubscriber subs = new MySubscriber(); publisher.subscribe(subs); List&lt;Employee> emps = EmpHelper.getEmps(); // Publish items System.out.println(\"Publishing Items to Subscriber\"); for (Employee employee : emps) { publisher.submit(employee); Thread.sleep(1000);// simulate true environment } // logic to wait till processing of all messages are over while (emps.size() != subs.getCounter()) { Thread.sleep(10); } // close the Publisher publisher.close(); System.out.println(\"Exiting the app\"); } } 上面代码中最重要的部分就是 subscribe 和 submit 方法的调用了。另外，我们应该在使用完之后关闭发布者，以避免任何内存泄漏。 当执行上述程序时，我们将得到以下输出： Subscribed onSubscribe requested 1 item Publishing Items to Subscriber Processing Employee [id=1,name=我没有三颗心脏] Processing Employee [id=2,name=三颗心脏] Processing Employee [id=3,name=心脏] Exiting the app All Processing Done 以上所有代码均可以在「MoreThanJava」项目下的 demo-project 下找到：传送门 另外，如果您想了解更多内容请访问：https://www.journaldev.com/20723/java-9-reactive-streams 九. 进程 APIJava 9 增加了 ProcessHandle 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。 在使用 ProcessBuilder 来启动一个进程之后，可以通过 Process.toHandle() 方法来得到一个 ProcessHandle 对象的实例。通过 ProcessHandle 可以获取到由 ProcessHandle.Info 表示的进程的基本信息，如命令行参数、可执行文件路径和启动时间等。ProcessHandle 的 onExit() 方法返回一个 CompletableFuture 对象，可以在进程结束时执行自定义的动作。 下面是进程 API 的使用示例： final ProcessBuilder processBuilder = new ProcessBuilder(\"top\") .inheritIO(); final ProcessHandle processHandle = processBuilder.start().toHandle(); processHandle.onExit().whenCompleteAsync((handle, throwable) -> { if (throwable == null) { System.out.println(handle.pid()); } else { throwable.printStackTrace(); } }); 十. 升级的 Try-With-Resources我们知道，Java SE 7 引入了一种新的异常处理结构：Try-With-Resources 以自动管理资源。这一新声明的主要目标是 “自动的更好的资源管理”。 Java SE 9 将对该语句进行一些改进，以避免更多的冗长和提高可读性。 Java SE 7示例 void testARM_Before_Java9() throws IOException{ BufferedReader reader1 = new BufferedReader(new FileReader(\"journaldev.txt\")); try (BufferedReader reader2 = reader1) { System.out.println(reader2.readLine()); } } Java SE 9示例： void testARM_Java9() throws IOException{ BufferedReader reader1 = new BufferedReader(new FileReader(\"journaldev.txt\")); try (reader1) { System.out.println(reader1.readLine()); } } 十一. HTTP / 2Java 9 提供了一种执行 HTTP 调用的新方法。这种过期过期的替代方法是旧的HttpURLConnection。API 也支持 WebSockets 和 HTTP / 2。需要注意的是：新的 HttpClient API 在 Java 9 中以所谓的 incubator module 的形式提供。这意味着该API尚不能保证最终实现 100％。尽管如此，随着Java 9的到来，您已经可以开始使用此API： HttpClient client = HttpClient.newHttpClient(); HttpRequest req = HttpRequest.newBuilder(URI.create(\"http://www.google.com\")) .header(\"User-Agent\",\"Java\") .GET() .build(); HttpResponse&lt;String> resp = client.send(req, HttpResponse.BodyHandler.asString()); 十二. 多版本兼容 Jar 包多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。 通过 –release 参数指定编译版本。 具体的变化就是 META-INF 目录下 MANIFEST.MF 文件新增了一个属性： Multi-Release: true 然后 META-INF 目录下还新增了一个 versions 目录，如果是要支持 Java 9，则在 versions 目录下有 9 的目录。 multirelease.jar ├── META-INF │ └── versions │ └── 9 │ └── multirelease │ └── Helper.class ├── multirelease ├── Helper.class └── Main.class 具体的例子可以在这里查看到：https://www.runoob.com/java/java9-multirelease-jar.html，这里不做赘述。 其他更新改进应用安全性能Java 9 新增了 4 个 SHA-3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512。另外也增加了通过 java.security.SecureRandom 生成使用 DRBG 算法的强随机数。下面给出了 SHA-3 哈希算法的使用示例： final MessageDigest instance = MessageDigest.getInstance(\"SHA3-224\"); final byte[] digest = instance.digest(\"\".getBytes()); System.out.println(Hex.encodeHexString(digest)); 统一 JVM 日志Java 9 中 ，JVM 有了统一的日志记录系统，可以使用新的命令行选项 -Xlog 来控制 JVM 上所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。 G1 设为默认回收器实现Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合（比如 ParNew + SerialOld），同时把 G1 设为默认的垃圾回收器实现（32 位和 64 位系统都是）。 另外，CMS 垃圾回收器已经被声明为废弃。Java 9 也增加了很多可以通过 jcmd 调用的诊断命令。 String 底层存储结构更改 为了对字符串采用更节省空间的内部表示，String类的内部表示形式从 UTF-16 char数组更改为byte带有编码标记字段的数组。新String类将存储基于字符串内容编码为 ISO-8859-1 / Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的字符。编码标志将指示使用哪种编码。 (ps: 另外内部大部分方法也多了字符编码的判断) CompletableFuture API 的改进在 Java SE 9 中，Oracle Corp 将改进 CompletableFuture API，以解决 Java SE 8 中提出的一些问题。它们将被添加以支持某些延迟和超时，某些实用程序方法以及更好的子类化。 Executor exe = CompletableFuture.delayedExecutor(50L, TimeUnit.SECONDS); 这里的 delayExecutor() 是一种静态实用程序方法，用于返回新的 Executor，该 Executor 在给定的延迟后将任务提交给默认的执行程序。 I/O 流新特性类 java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。 readAllBytes：读取 InputStream 中的所有剩余字节。 readNBytes： 从 InputStream 中读取指定数量的字节到数组中。 transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。 下面是新方法的使用示例： public class TestInputStream { private InputStream inputStream; private static final String CONTENT = \"Hello World\"; @Before public void setUp() throws Exception { this.inputStream = TestInputStream.class.getResourceAsStream(\"/input.txt\"); } @Test public void testReadAllBytes() throws Exception { final String content = new String(this.inputStream.readAllBytes()); assertEquals(CONTENT, content); } @Test public void testReadNBytes() throws Exception { final byte[] data = new byte[5]; this.inputStream.readNBytes(data, 0, 5); assertEquals(\"Hello\", new String(data)); } @Test public void testTransferTo() throws Exception { final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); this.inputStream.transferTo(outputStream); assertEquals(CONTENT, outputStream.toString()); } } JavaScript 引擎 Nashorn 改进Nashorn 是 Java 8 中引入的新的 JavaScript 引擎。Java 9 中的 Nashorn 已经实现了一些 ECMAScript 6 规范中的新特性，包括模板字符串、二进制和八进制字面量、迭代器 和 for..of 循环和箭头函数等。Nashorn 还提供了 API 把 ECMAScript 源代码解析成抽象语法树（ Abstract Syntax Tree，AST ） ，可以用来对 ECMAScript 源代码进行分析。 标识符增加限制JDK 8 之前 String _ = &quot;hello; 这样的标识符可以使用，JDK 9 之后就不允许使用了。 改进的 Javadoc有时候，微小的事情会带来很大的不同。您是否之前一直像我一样一直使用 Google 查找正确的 Javadoc 页面？现在将不再需要。Javadoc 现在在 API 文档本身中包含了搜索功能。另外，Javadoc 输出现在兼容 HTML 5。另外，您会注意到每个 Javadoc 页面都包含有关类或接口来自哪个 JDK 模块的信息。 改进的 @Deprecated 注解注解 @Deprecated 可以标记 Java API 状态，可以是以下几种： 使用它存在风险，可能导致错误 可能在未来版本中不兼容 可能在未来版本中删除 一个更好和更高效的方案已经取代它。 Java 9 中注解增加了两个新元素：since 和 forRemoval。 since: 元素指定已注解的API元素已被弃用的版本。 forRemoval: 元素表示注解的 API 元素在将来的版本中被删除，应该迁移 API。 以下实例为 Java 9 中关于 Boolean 类的说明文档，文档中 @Deprecated 注解使用了 since 属性：Boolean Class。 多分辨率图像 API在 Java SE 9 中，Oracle Corp 将引入一个新的 Multi-Resolution Image API。此 API 中的重要接口是MultiResolutionImage。在 java.awt.image 包中可用。 MultiResolutionImage 封装了一组具有不同高度和宽度（即不同分辨率）的图像，并允许我们根据需求查询它们。 变量句柄变量句柄（VarHandle）是对于一个变量的强类型引用，或者是一组参数化定义的变量族，包括了静态字段、非静态字段、数组元素等，VarHandle 支持不同访问模型下对于变量的访问，包括简单的 read/write 访问，volatile read/write 访问，以及 CAS 访问。 VarHandle 相比于传统的对于变量的并发操作具有巨大的优势，在 JDK 9 引入了 VarHandle 之后，JUC 包中对于变量的访问基本上都使用 VarHandle，比如 AQS 中的 CLH 队列中使用到的变量等。 了解更多戳这里：https://kknews.cc/code/amqz5on.html 改进方法句柄（Method Handle）类 java.lang.invoke.MethodHandles 增加了更多的静态方法来创建不同类型的方法句柄： arrayConstructor： 创建指定类型的数组。 arrayLength： 获取指定类型的数组的大小。 varHandleInvoker 和 varHandleExactInvoker： 调用 VarHandle 中的访问模式方法。 zero： 返回一个类型的默认值。 empty： 返回 MethodType 的返回值类型的默认值。 loop、countedLoop、iteratedLoop、whileLoop 和 doWhileLoop： 创建不同类型的循环，包括 for 循环、while 循环 和 do-while 循环。 tryFinally： 把对方法句柄的调用封装在 try-finally 语句中。 提前编译 AOT借助 Java 9，特别是JEP 295，JDK 获得了提前（ahead-of-time，AOT） 编译器 jaotc。该编译器使用 OpenJDK 项目 Graal 进行后端代码生成，这样做的原因如下： JIT 编译器速度很快，但是Java程序可能非常庞大，以至于JIT完全预热需要很长时间。很少使用的Java方法可能根本不会被编译，由于重复的解释调用可能会导致性能下降 原文链接：openjdk.java.net/jeps/295 Graal OpenJDK 项目 演示了用纯 Java 编写的编译器可以生成高度优化的代码。使用此 AOT 编译器和 Java 9，您可以提前手动编译 Java 代码。这意味着在执行之前生成机器代码，而不是像 JIT 编译器那样在运行时生成代码，这是第一种实验性的方法。 # using the new AOT compiler (jaotc is bundeled within JDK 9 and above) jaotc --output libHelloWorld.so HelloWorld.class jaotc --output libjava.base.so --module java.base # with Java 9 you have to manually specify the location of the native code java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld 这将改善启动时间，因为 JIT 编译器不必拦截程序的执行。这种方法的主要缺点是生成的机器代码依赖于程序所在的平台（Linux，MacOS，windows…）。这可能导致 AOT 编译代码与特定平台绑定。 了解更多戳这里：https://juejin.im/post/6850418120570437646 更多…完整特性列表：https://openjdk.java.net/projects/jdk9/ 参考资料 OpenJDK 官方文档 - https://openjdk.java.net/projects/jdk9/ Java 9 Modules | JournalDev - https://www.journaldev.com/13106/java-9-modules JDK 9 新特性详解 - https://my.oschina.net/mdxlcj/blog/1622984 Java SE 9:Stream API Improvements - https://www.journaldev.com/13204/javase9-stream-api-improvements 9 NEW FEATURES IN JAVA 9 - https://www.pluralsight.com/blog/software-development/java-9-new-features Java 9 新特性概述 | IBM - https://developer.ibm.com/zh/articles/the-new-features-of-Java-9/ Java 9 多版本兼容 jar 包 | 菜鸟教程 - https://www.runoob.com/java/java9-multirelease-jar.html 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 全网最通透的 Java 8 版本特性讲解 - https://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/ 你记笔记吗？关于最近知识管理工具革新潮心脏有话要说 - https://www.wmyskxz.com/2020/08/16/ni-ji-bi-ji-ma-guan-yu-zui-jin-zhi-shi-guan-li-gong-ju-ge-xin-chao-xin-zang-you-hua-yao-shuo/ 黑莓OS手册是如何详细阐述底层的进程和线程模型的？ - https://www.wmyskxz.com/2020/07/31/hao-wen-tui-jian-hei-mei-os-shou-ce-shi-ru-he-xiang-xi-chan-shu-di-ceng-de-jin-cheng-he-xian-cheng-mo-xing-de/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java8版本特性详解","slug":"Java8版本特性详解","date":"2020-08-19T01:52:00.000Z","updated":"2020-12-09T05:04:42.740Z","comments":true,"path":"2020/08/19/java8-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/19/java8-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 8 中的引入的部分新特性。关于 Java 8 新特性更详细的介绍可参考这里。 接口默认方法和静态方法 Lambda 表达式 函数式接口 方法引用 Stream Optional Date/Time API 重复注解 扩展注解的支持 Base64 JavaFX 其它 JDBC 4.2 规范 更好的类型推测机制 HashMap 性能提升 IO/NIO 的改进 JavaScript 引擎 Nashorn 并发（Concurrency） 类依赖分析器 jdeps JVM 的 PermGen 空间被移除 一. 接口默认方法和静态方法接口默认方法在 Java 8 中，允许为接口方法提供一个默认的实现。必须用 default 修饰符标记这样一个方法，例如 JDK 中的 Iterator 接口： public interface Iterator&lt;E> { boolean hasNext(); E next(); default void remove() { throw new UnsupportedOperationExceition(\"remove\"); } } 这将非常有用！如果你要实现一个迭代器，就需要提供 hasNext() 和 next() 方法。这些方法没有默认实现——它们依赖于你要遍历访问的数据结构。不过，如果你的迭代器是 只读 的，那么就不用操心实现 remove() 方法。 默认方法也可以调用其他方法，例如，我们可以改造 Collection 接口，定义一个方便的 isEmpty() 方法： public interface Collection { int size(); // an abstract method default boolean isEmpty() { return size() == 0; } } 这样，实现 Collection 的程序员就不用再操心实现 isEmpty() 方法了。 在 JVM 中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的 Java 接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在类或另一个接口中定义同样的方法，会发生什么？ // 测试接口 1 public interface TestInterface1 { default void sameMethod() { System.out.println(\"Invoke TestInterface1 method！\"); } } // 测试接口 2 public interface TestInterface2 { default void sameMethod() { System.out.println(\"Invoke TestInterface2 method！\"); } } // 继承两个接口的测试类 public class TestObject implements TestInterface1, TestInterface2 { @Override public void sameMethod() { // 这里也可以选择两个接口中的一个默认实现 // 如： TestInterface1.super.sameMethod(); System.out.println(\"Invoke Object method！\"); } } // 测试类 public class Tester { public static void main(String[] args) { TestObject testObject = new TestObject(); testObject.sameMethod(); } } 测试输出： Invoke Object method！ ➡️ 对于 Scale 或者 C++ 这些语言来说，解决这种具有 二义性 的情况规则会很复杂，Java 的规则则简单得多： 类优先。如果本类中提供了一个具体方法符合签名，则同名且具有相同参数列表的接口中的默认方法会被忽略； 接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了一个同名且参数列表相同的方法 (顺序和类型都相同) ，则必须覆盖这个方法来解决冲突 (就是👆代码的情况，不覆盖编译器不会编译..)； Java 设计者更强调一致性，让程序员自己来解决这样的二义性似乎也显得很合理。如果至少有一个接口提供了一个实现，编译器就会报告错误，程序员就必须解决这个二义性。(如果两个接口都没有为共享方法提供默认实现，则不存在冲突，要么实现，要么不实现..) ➡️ 我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，一个类继承自一个类，同时实现了一个接口，从父类继承的方法和接口拥有同样的方法签名，又将怎么办呢？ // 测试接口 public interface TestInterface { default void sameMethod() { System.out.println(\"Invoke TestInterface Method！\"); } } // 父类 public class Father { void sameMethod() { System.out.println(\"Invoke Father Method！\"); } } // 子类 public class Son extends Father implements TestInterface { @Override public void sameMethod() { System.out.println(\"Invoke Son Method！\"); } } // 测试类 public class Tester { public static void main(String[] args) { new Son().sameMethod(); } } 程序输出： COPYInvoke Son Method！ 还记得我们说过的方法调用的过程吗 (先找本类的方法找不到再从父类找)？加上这里提到的 “类优先” 原则 (本类中有方法则直接调用)，这很容易理解！ 千万不要让一个默认方法重新定义 Object 类中的某个方法。例如，不能为 toString() 或 equals() 定义默认方法，尽管对于 List 之类的接口这可能很有吸引力，但由于 类优先原则，这样的方法绝对无法超越 Object.toString() 或者 Object.equals()。 接口静态方法在 Java 8 中，允许在接口中增加静态方法 (允许不构建对象而直接使用的具体方法)。理论上讲，没有任何理由认为这是不合法的，只是这有违将接口作为抽象规范的初衷。 例子： public interface StaticInterface { static void method() { System.out.println(\"这是Java8接口中的静态方法!\"); } } 调用： public class Main { public static void main(String[] args) { StaticInterface.method(); // 输出 这是Java8接口中的静态方法! } } 目前为止，通常的做法都是将静态方法放在 伴随类 (可以理解为操作继承接口的实用工具类) 中。在标准库中，你可以看到成对出现的接口和实用工具类，如 Collection/ Collections 或 Path/ Paths。 在 Java 11 中，Path 接口就提供了一个与之工具类 Paths.get() 等价的方法 (该方法用于将一个 URI 或者字符串序列构造成一个文件或目录的路径)： COPYpublic interface Path { public static Path of(String first, String... more) { ... } public static Path of(URI uri) { ... } } 这样一来，Paths 类就不再是必要的了。类似地，如果实现你自己的接口时，没有理由再额外提供一个带有实用方法的工具类。 ➡️ 另外，在 Java 9 中，接口中的方法可以是 private。private 方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以它们的用法很有限，只能作为接口中其他方法的辅助方法。 二. Lambda 表达式Lambda表达式 (也称为闭包) 是整个 Java 8 发行版中最受期待的在 Java 语言层面上的改变，Lambda 允许把函数作为一个方法的参数，即 行为参数化，函数作为参数传递进方法中。 什么是 Lambda 表达式我们知道，对于一个 Java 变量，我们可以赋给一个 「值」。 如果你想把 「一块代码」 赋给一个 Java 变量，应该怎么做呢？ 比如，我想把右边的代码块，赋值给一个叫做 blockOfCode 的 Java 变量： 在 Java 8 之前，这个是做不到的，但是 Java 8 问世之后，利用 Lambda 特性，就可以做到了。 当然，这个并不是一个很简洁的写法，所以为了让这个赋值操作变得更加优雅，我们可以移除一些没有必要的声明。 这样，我们就成功的非常优雅的把「一块代码」赋给了一个变量。而「这块代码」，或者说「这个被赋给一个变量的函数」，就是一个 Lambda 表达式。 但是这里仍然有一个问题，就是变量 blockOfCode 的类型应该是什么？ 在 Java 8 里面，所有的 Lambda 的类型都是一个接口，而 Lambda 表达式本身，也就是「那段代码」，需要是这个接口的实现。这是理解 Lambda 的一个关键所在，简而言之就是，Lambda 表达式本身就是一个接口的实现。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的 blockOfCode 加上一个类型： 这种只有一个接口函数需要被实现的接口类型，我们叫它「函数式接口」。 为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成「非函数接口」，我们可以在这个上面加上一个声明 @FunctionalInterface, 这样别人就无法在里面添加新的接口函数了： 这样，我们就得到了一个完整的 Lambda 表达式声明： Lambda 表达式的作用Lambda 最直观的作用就是使代码变得整洁.。 我们可以对比一下 Lambda 表达式和传统的 Java 对同一个接口的实现： 这两种写法本质上是等价的。但是显然，Java 8 中的写法更加优雅简洁。并且，由于 Lambda 可以直接赋值给一个变量，我们就可以直接把 Lambda 作为参数传给函数, 而传统的 Java 必须有明确的接口实现的定义，初始化才行。 有些情况下，这个接口实现只需要用到一次。传统的 Java 7 必须要求你定义一个“污染环境”的接口实现 MyInterfaceImpl，而相较之下 Java 8 的 Lambda, 就显得干净很多。 三. 函数式接口上面我们说到，只有一个接口函数需要被实现的接口类型，我们叫它「函数式接口」。Lambda 表达式配合函数式接口能让我们代码变得干净许多。 Java 8 API 包含了很多内建的函数式接口，在老 Java 中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在Lambda上。 Java 8 API 同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自 Google Guava 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到 Lambda 上使用的。 1 - Comparator（比较器接口）Comparator是老Java中的经典接口， Java 8 在此之上添加了多种默认方法。源代码及使用示例如下: @FunctionalInterface public interface Comparator&lt;T> { int compare(T o1, T o2); } Comparator&lt;Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName); Person p1 = new Person(\"John\", \"Doe\"); Person p2 = new Person(\"Alice\", \"Wonderland\"); comparator.compare(p1, p2); // > 0 comparator.reversed().compare(p1, p2); // &lt; 0 2 - Consumer（消费型接口）Consumer 接口表示执行在单个参数上的操作。源代码及使用示例如下: @FunctionalInterface public interface Consumer&lt;T> { void accept(T t); } Consumer&lt;Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName); greeter.accept(new Person(\"Luke\", \"Skywalker\")); 更多的Consumer接口 BiConsumer：void accept(T t, U u);: 接受两个参数的二元函数 DoubleConsumer：void accept(double value);: 接受一个double参数的一元函数 IntConsumer：void accept(int value);: 接受一个int参数的一元函数 LongConsumer：void accept(long value);: 接受一个long参数的一元函数 ObjDoubleConsumer：void accept(T t, double value);: 接受一个泛型参数一个double参数的二元函数 ObjIntConsumer：void accept(T t, int value);: 接受一个泛型参数一个int参数的二元函数 ObjLongConsumer：void accept(T t, long value);: 接受一个泛型参数一个long参数的二元函数 3 - Supplier（供应型接口）Supplier 接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同 Consumer 相反，是一个只声明了返回值，不需要参数的函数。也就是说 Supplier 其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要consume（Consumer）或者是简单的map（Function），还包括了 new 这个动作。而 Supplier 就表达了这种能力。源代码及使用示例如下: @FunctionalInterface public interface Supplier&lt;T> { T get(); } Supplier&lt;Person> personSupplier = Person::new; personSupplier.get(); // new Person 更多Supplier接口 BooleanSupplier：boolean getAsBoolean();: 返回boolean的无参函数 DoubleSupplier：double getAsDouble();: 返回double的无参函数 IntSupplier：int getAsInt();: 返回int的无参函数 LongSupplier：long getAsLong();: 返回long的无参函数 4 - Predicate（断言型接口）Predicate 接口只有一个参数，返回 boolean 类型。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。Stream 的 filter 方法就是接受 Predicate 作为入参的。这个具体在后面使用 Stream 的时候再分析深入。源代码及使用示例如下: @FunctionalInterface public interface Predicate&lt;T> { boolean test(T t); } Predicate&lt;String> predicate = (s) -> s.length() > 0; predicate.test(\"foo\"); // true predicate.negate().test(\"foo\"); // false Predicate&lt;Boolean> nonNull = Objects::nonNull; Predicate&lt;Boolean> isNull = Objects::isNull; Predicate&lt;String> isEmpty = String::isEmpty; Predicate&lt;String> isNotEmpty = isEmpty.negate(); 更多的Predicate接口 BiPredicate：boolean test(T t, U u);: 接受两个参数的二元断言函数 DoublePredicate：boolean test(double value);: 入参为double的断言函数 IntPredicate：boolean test(int value);: 入参为int的断言函数 LongPredicate：boolean test(long value);: 入参为long的断言函数 5 - Function（功能型接口）Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）。源代码及使用示例如下: @FunctionalInterface public interface Function&lt;T, R> { R apply(T t); } Function&lt;String, Integer> toInteger = Integer::valueOf; Function&lt;String, String> backToString = toInteger.andThen(String::valueOf); backToString.apply(\"123\"); // \"123\" 更多的Function接口 BiFunction ：R apply(T t, U u);: 接受两个参数，返回一个值，代表一个二元函数； DoubleFunction ：R apply(double value);: 只处理double类型的一元函数； IntFunction ：R apply(int value);: 只处理int参数的一元函数； LongFunction ：R apply(long value);: 只处理long参数的一元函数； ToDoubleFunction：double applyAsDouble(T value);: 返回double的一元函数； ToDoubleBiFunction：double applyAsDouble(T t, U u);: 返回double的二元函数； ToIntFunction：int applyAsInt(T value);: 返回int的一元函数； ToIntBiFunction：int applyAsInt(T t, U u);: 返回int的二元函数； ToLongFunction：long applyAsLong(T value);: 返回long的一元函数； ToLongBiFunction：long applyAsLong(T t, U u);: 返回long的二元函数； DoubleToIntFunction：int applyAsInt(double value);: 接受double返回int的一元函数； DoubleToLongFunction：long applyAsLong(double value);: 接受double返回long的一元函数； IntToDoubleFunction：double applyAsDouble(int value);: 接受int返回double的一元函数； IntToLongFunction：long applyAsLong(int value);: 接受int返回long的一元函数； LongToDoubleFunction：double applyAsDouble(long value);: 接受long返回double的一元函数； LongToIntFunction：int applyAsInt(long value);: 接受long返回int的一元函数； 6 - OperatorOperator 其实就是 Function，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子 Operator 包括：UnaryOperator 和 BinaryOperator。分别对应单（一）元算子和二元算子。 算子的接口声明如下： @FunctionalInterface public interface UnaryOperator&lt;T> extends Function&lt;T, T> { static &lt;T> UnaryOperator&lt;T> identity() { return t -> t; } } @FunctionalInterface public interface BinaryOperator&lt;T> extends BiFunction&lt;T,T,T> { public static &lt;T> BinaryOperator&lt;T> minBy(Comparator&lt;? super T> comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) &lt;= 0 ? a : b; } public static &lt;T> BinaryOperator&lt;T> maxBy(Comparator&lt;? super T> comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) >= 0 ? a : b; } } Operator只需声明一个泛型参数 T 即可。对应的使用示例如下： UnaryOperator&lt;Integer> increment = x -> x + 1; System.out.println(\"递增:\" + increment.apply(2)); // 输出 递增:3 BinaryOperator&lt;Integer> add = (x, y) -> x + y; System.out.println(\"相加:\" + add.apply(2, 3)); // 输出 相加:5 BinaryOperator&lt;Integer> min = BinaryOperator.minBy((o1, o2) -> o1 - o2); System.out.println(\"最小值:\" + min.apply(2, 3)); // 输出 最小值:2 更多的Operator接口 LongUnaryOperator：long applyAsLong(long operand);: 对long类型做操作的一元算子 IntUnaryOperator：int applyAsInt(int operand);: 对int类型做操作的一元算子 DoubleUnaryOperator：double applyAsDouble(double operand);: 对double类型做操作的一元算子 DoubleBinaryOperator：double applyAsDouble(double left, double right);: 对double类型做操作的二元算子 IntBinaryOperator：int applyAsInt(int left, int right);: 对int类型做操作的二元算子 LongBinaryOperator：long applyAsLong(long left, long right);: 对long类型做操作的二元算子 7 - 其他函数式接口 java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.io.FileFilter java.nio.file.PathMatcher java.lang.reflect.InvocationHandler java.beans.PropertyChangeListener java.awt.event.ActionListener javax.swing.event.ChangeListener 四. 方法引用1 - 概述在学习了 Lambda 表达式之后，我们通常使用 Lambda 表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下： Arrays.sort(strArray, (s1, s2) -> s1.compareToIgnoreCase(s2)); 在 Java 8 中，我们可以直接通过方法引用来简写 Lambda 表达式中已经存在的方法。 Arrays.sort(strArray, String::compareToIgnoreCase); 这种特性就叫做方法引用(Method Reference)。 方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当 Lambda 表达式中只是执行一个方法调用时，不用 Lambda 表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的 Lambda 表达式。 注意: 方法引用是一个 Lambda 表达式，其中方法引用的操作符是双冒号::。 2 - 分类方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号） 有以下四种形式的方法引用： 引用静态方法: ContainingClass::staticMethodName 引用某个对象的实例方法: containingObject::instanceMethodName 引用某个类型的任意对象的实例方法:ContainingType::methodName 引用构造方法: ClassName::new 3 - 示例使用示例如下： public class Person { String name; LocalDate birthday; public Person(String name, LocalDate birthday) { this.name = name; this.birthday = birthday; } public LocalDate getBirthday() { return birthday; } public static int compareByAge(Person a, Person b) { return a.birthday.compareTo(b.birthday); } @Override public String toString() { return this.name; } } 测试类： public class MethodReferenceTest { @Test public static void main() { Person[] pArr = new Person[] { new Person(\"003\", LocalDate.of(2016,9,1)), new Person(\"001\", LocalDate.of(2016,2,1)), new Person(\"002\", LocalDate.of(2016,3,1)), new Person(\"004\", LocalDate.of(2016,12,1)) }; // 使用匿名类 Arrays.sort(pArr, new Comparator&lt;Person>() { @Override public int compare(Person a, Person b) { return a.getBirthday().compareTo(b.getBirthday()); } }); //使用lambda表达式 Arrays.sort(pArr, (Person a, Person b) -> { return a.getBirthday().compareTo(b.getBirthday()); }); //使用方法引用，引用的是类的静态方法 Arrays.sort(pArr, Person::compareByAge); } } 五. Stream 流操作流是 Java8 中 API 的新成员，它允许你以 声明式 的方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。这有点儿像是我们操作数据库一样，例如我想要查询出热量较低的菜品名字我就可以像下面这样： COPYSELECT name FROM dishes WHERE calorie &lt; 400; 您看，我们并没有对菜品的什么属性进行筛选（比如像之前使用迭代器一样每个做判断），我们只是表达了我们想要什么。那么为什么到了 Java 的集合中，这样做就不行了呢？ 另外一点，如果我们想要处理大量的数据又该怎么办？是否是考虑使用多线程进行并发处理呢？如果是，那么可能编写的关于并发的代码比使用迭代器本身更加的复杂，而且调试起来也会变得麻烦。 基于以上的几点考虑，Java 设计者在 Java 8 版本中 (真正把函数式编程风格引入到 Java 中)，引入了流的概念，来帮助您节约时间！并且有了 Lambda 的参与，流操作的使用将更加顺畅！ 1 - 流操作特点特点一：内部迭代就现在来说，您可以把它简单的当成一种高级的迭代器（Iterator），或者是高级的 for 循环，区别在于，前面两者都是属于外部迭代，而流采用内部迭代。 上图简要说明了内部迭代与外部迭代的差异，我们再举一个生活中实际的例子（引自《Java 8 实战》），比如您想让您两岁的孩子索菲亚把她的玩具都收到盒子里面去，你们之间可能会产生如下的对话： 你：“索菲亚，我们把玩具收起来吧，地上还有玩具吗？” 索菲亚：“有，球。” 你：“好，把球放进盒子里面吧，还有吗？” 索菲亚：“有，那是我的娃娃。” 你：“好，把娃娃也放进去吧，还有吗？” 索菲亚：“有，有我的书。” 你：“好，把书也放进去，还有吗？” 索菲亚：“没有了。” 你：“好，我们收好啦。” 这正是你每天都要对 Java 集合做的事情。你外部迭代了一个集合，显式地取出每个项目再加以处理，但是如果你只是跟索菲亚说：“把地上所有玩具都放进盒子里”，那么索菲亚就可以选择一手拿娃娃一手拿球，或是选择先拿离盒子最近的那个东西，再拿其他的东西。 采用内部迭代，项目可以透明地并行处理，或者用优化的顺序进行处理，要是使用 Java 过去的外部迭代方法，这些优化都是很困难的。 这或许有点鸡蛋里挑骨头，但这差不多就是 Java 8 引入流的原因了——Streams 库的内部迭代可以自动选择一种是和你硬件的数据表示和并行实现。 特点二：只能遍历一次请注意，和迭代器一样，流只能遍历一次。当流遍历完之后，我们就说这个流已经被消费掉了，你可以从原始数据那里重新获得一条新的流，但是却不允许消费已消费掉的流。例如下面代码就会抛出一个异常，说流已被消费掉了： List&lt;String> title = Arrays.asList(\"Wmyskxz\", \"Is\", \"Learning\", \"Java8\", \"In\", \"Action\"); Stream&lt;String> s = title.stream(); s.forEach(System.out::println); s.forEach(System.out::println); // 运行上面程序会报以下错误 /* Exception in thread \"main\" java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279) at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) at Test1.main(Tester.java:17) */ 特点三：方便的并行处理Java 8 中不仅提供了方便的一些流操作（比如过滤、排序之类的），更重要的是对于并行处理有很好的支持，只需要加上 .parallel() 就行了！例如我们使用下面程序来说明一下多线程流操作的方便和快捷，并且与单线程做了一下对比： COPYpublic class StreamParallelDemo { /** 总数 */ private static int total = 100_000_000; public static void main(String[] args) { System.out.println(String.format(\"本计算机的核数：%d\", Runtime.getRuntime().availableProcessors())); // 产生1000w个随机数(1 ~ 100)，组成列表 Random random = new Random(); List&lt;Integer> list = new ArrayList&lt;>(total); for (int i = 0; i &lt; total; i++) { list.add(random.nextInt(100)); } long prevTime = getCurrentTime(); list.stream().reduce((a, b) -> a + b).ifPresent(System.out::println); System.out.println(String.format(\"单线程计算耗时：%d\", getCurrentTime() - prevTime)); prevTime = getCurrentTime(); // 只需要加上 .parallel() 就行了 list.stream().parallel().reduce((a, b) -> a + b).ifPresent(System.out::println); System.out.println(String.format(\"多线程计算耗时：%d\", getCurrentTime() - prevTime)); } private static long getCurrentTime() { return System.currentTimeMillis(); } } 以上程序分别使用了单线程流和多线程流计算了一千万个随机数的和，输出如下： 本计算机的核数：8 655028378 单线程计算耗时：4159 655028378 多线程计算耗时：540 并行流的内部使用了默认的 ForkJoinPool 分支/合并框架，它的默认线程数量就是你的处理器数量，这个值是由 Runtime.getRuntime().availableProcessors() 得到的（当然我们也可以全局设置这个值）。我们也不再去过度的操心加锁线程安全等一系列问题。 2 - 一些重要方法说明 stream: 返回数据流，集合作为其源 parallelStream: 返回并行数据流， 集合作为其源 filter: 方法用于过滤出满足条件的元素 map: 方法用于映射每个元素对应的结果 forEach: 方法遍历该流中的每个元素 limit: 方法用于减少流的大小 sorted: 方法用来对流中的元素进行排序 anyMatch: 是否存在任意一个元素满足条件（返回布尔值） allMatch: 是否所有元素都满足条件（返回布尔值） noneMatch: 是否所有元素都不满足条件（返回布尔值） collect: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束 3 - 一些使用示例Filter 过滤stringCollection .stream() .filter((s) -> s.startsWith(\"a\")) .forEach(System.out::println); Sort 排序stringCollection .stream() .sorted() .filter((s) -> s.startsWith(\"a\")) .forEach(System.out::println); Map 映射stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -> b.compareTo(a)) .forEach(System.out::println); Match 匹配boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -> s.startsWith(\"a\")); System.out.println(anyStartsWithA); // true boolean allStartsWithA = stringCollection .stream() .allMatch((s) -> s.startsWith(\"a\")); System.out.println(allStartsWithA); // false boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -> s.startsWith(\"z\")); System.out.println(noneStartsWithZ); // true Count 计数long startsWithB = stringCollection .stream() .filter((s) -> s.startsWith(\"b\")) .count(); System.out.println(startsWithB); // 3 Reduce 归约这是一个最终操作，允许通过指定的函数来将 stream 中的多个元素规约为一个元素，规越后的结果是通过 Optional 接口表示的。代码如下: Optional&lt;String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \"#\" + s2); reduced.ifPresent(System.out::println); 想了解更多请参考：https://www.wmyskxz.com/2019/08/03/java8-liu-cao-zuo-ji-ben-shi-yong-xing-neng-ce-shi/ 六. Optional到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的 Guava 项目引入了 Optional 类，Guava 通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到 Google Guava 的启发，Optional类已经成为 Java 8 类库的一部分。 Optional 实际上是个容器：它可以保存类型 T 的值，或者仅仅保存 null。Optional 提供很多有用的方法，这样我们就不用显式进行空值检测。 我们下面用两个小例子来演示如何使用 Optional 类：一个允许为空值，一个不允许为空值。 Optional&lt;String> fullName = Optional.ofNullable(null); System.out.println(\"Full Name is set? \" + fullName.isPresent()); System.out.println(\"Full Name: \" + fullName.orElseGet(() -> \"[none]\")); System.out.println(fullName.map(s -> \"Hey \" + s + \"!\").orElse(\"Hey Stranger!\")); 如果 Optional 类的实例为非空值的话，isPresent() 返回 true，否从返回 false。为了防止 Optional 为空值，orElseGet() 方法通过回调函数来产生一个默认值。map() 函数对当前 Optional 的值进行转化，然后返回一个新的 Optional 实例。orElse() 方法和 orElseGet() 方法类似，但是 orElse 接受一个默认值而不是一个回调函数。下面是这个程序的输出： Full Name is set? false Full Name: [none] Hey Stranger! 让我们来看看另一个例子： Optional&lt;String> firstName = Optional.of(\"Tom\"); System.out.println(\"First Name is set? \" + firstName.isPresent()); System.out.println(\"First Name: \" + firstName.orElseGet(() -> \"[none]\")); System.out.println(firstName.map(s -> \"Hey \" + s + \"!\").orElse(\"Hey Stranger!\")); System.out.println(); 下面是程序的输出： First Name is set? true First Name: Tom Hey Tom! Lambda 配合 Optinal 优雅解决 null这里假设我们有一个 person object，以及一个 person object 的 Optional wrapper： Optional&lt;T&gt; 如果不结合 Lambda 使用的话，并不能使原来繁琐的 null check 变的简单。 只有当 Optional&lt;T&gt; 结合 Lambda 一起使用的时候，才能发挥出其真正的威力！ 我们现在就来对比一下下面四种常见的 null 处理中，Java 8 的 Lambda + Optional&lt;T&gt; 和传统 Java 两者之间对于 null 的处理差异。 情况一：存在则继续 情况二：存在则返回，无则返回不存在 情况三：存在则返回，无则由函数产生 情况四：夺命连环 null 检查 由上述四种情况可以清楚地看到，Optional&lt;T&gt; + Lambda 可以让我们少写很多 ifElse 块。尤其是对于情况四那种夺命连环 null 检查，传统 Java 的写法显得冗长难懂，而新的 Optional&lt;T&gt; +Lambda 则清新脱俗，清楚简洁。 七. Data/Time APIJava 8 在包 java.time下包含了一组全新的时间日期API。新的日期API和开源的 Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： 1 - Clock 时钟Clock类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用 Instant 类来表示，Instant 类也可以用来创建老的 java.util.Date 对象。代码如下: Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date 2 - Timezones 时区在新 AP I中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法 of 来获取到。时区定义了到 UTS 时间的时间差，在 Instant 时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下: System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(\"Europe/Berlin\"); ZoneId zone2 = ZoneId.of(\"Brazil/East\"); System.out.println(zone1.getRules()); System.out.println(zone2.getRules()); // ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00] 3 - LocalTime 本地时间LocalTime定义了一个没有时区信息的时间，例如 晚上 10 点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下: LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下: LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter); System.out.println(leetTime); // 13:37 4 - LocalData 本地日期LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和 LocalTime 基本一致。下面的例子展示了如何给 Date 对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下: LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek(); System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单。代码如下: DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN); LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter); System.out.println(xmas); // 2014-12-24 5 - LocalDateTime 本地日期时间LocalDateTime同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。代码如下: LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。代码如下: Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下: DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\"); LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 八. 重复注解自从 Java 5 引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8 打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。 重复注解机制本身必须用 @Repeatable 注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子： import java.lang.annotation.ElementType; import java.lang.annotation.Repeatable; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class RepeatingAnnotations { @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Filters { Filter[] value(); } @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Filters.class) public @interface Filter { String value(); }; @Filter(\"filter1\") @Filter(\"filter2\") public interface Filterable { } public static void main(String[] args) { for(Filter filter: Filterable.class.getAnnotationsByType(Filter.class)) { System.out.println(filter.value()); } } } 正如我们看到的，这里有个使用 @Repeatable(Filters.class) 注解的注解类 Filter，Filters仅仅是 Filter 注解的数组，但Java编译器并不想让程序员意识到 Filters 的存在。这样，接口 Filterable 就拥有了两次 Filter（并没有提到Filter）注解。 同时，反射相关的API提供了新的函数getAnnotationsByType()来返回重复注解的类型（请注意Filterable.class.getAnnotation(Filters.class)`经编译器处理后将会返回Filters的实例）。 九. 扩展注解的支持Java 8 扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子： import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.util.ArrayList; import java.util.Collection; public class Annotations { @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.TYPE_USE, ElementType.TYPE_PARAMETER }) public @interface NonEmpty { } public static class Holder&lt;@NonEmpty T> extends @NonEmpty Object { public void method() throws @NonEmpty Exception { } } @SuppressWarnings(\"unused\") public static void main(String[] args) { final Holder&lt;String> holder = new @NonEmpty Holder&lt;String>(); @NonEmpty Collection&lt;@NonEmpty String> strings = new ArrayList&lt;>(); } } 十. Base64在 Java 8 中，Base64 编码已经成为 Java 类库的标准。它的使用十分简单，下面让我们看一个例子： import java.nio.charset.StandardCharsets; import java.util.Base64; public class Base64s { public static void main(String[] args) { final String text = \"Base64 finally in Java 8!\"; final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8)); System.out.println(encoded); final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8); System.out.println(decoded); } } 程序在控制台上输出了编码后的字符与解码后的字符： QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ== Base64 finally in Java 8! Base64 类同时还提供了对 URL、MIME 友好的编码器与解码器（Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()）。 十一. JavaFXJavaFX是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考JavaFX中文文档。 十二. 其它1. JDBC4.2规范JDBC4.2主要有以下几点改动： 增加了对REF Cursor的支持 修改返回值大小范围（update count） 增加了java.sql.DriverAction接口 增加了java.sql.SQLType接口 增加了java.sql.JDBCtype枚举 对java.time包时间类型的支持 2. 更好的类型推测机制Java 8 在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子： public class Value&lt;T> { public static&lt;T> T defaultValue() { return null; } public T getOrDefault(T value, T defaultValue) { return (value != null) ? value : defaultValue; } } 这里是Value&lt;String&gt;类型的用法。 public class TypeInference { public static void main(String[] args) { final Value&lt;String> value = new Value&lt;>(); value.getOrDefault(\"22\", Value.defaultValue()); } } Value.defaultValue()的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是Value.&lt;String&gt;defaultValue()。 3. HashMap性能提升Java 8 中，HashMap 内部实现又引入了红黑树，使得 HashMap 的总体性能相较于 Java 7 有比较明显的提升。以下是对 Hash 均匀和不均匀的情况下的性能对比 Hash较均匀的情况 Hash极不均匀的情况 想要了解更多 HashMap 的童鞋戳这里吧：传送门 4. IO/NIO 的改进Java 8 对IO/NIO也做了一些改进。主要包括：改进了java.nio.charset.Charset的实现，使编码和解码的效率得以提升，也精简了jre/lib/charsets.jar包；优化了String(byte[], *)构造方法和String.getBytes()方法的性能；还增加了一些新的IO/NIO方法，使用这些方法可以从文件或者输入流中获取流（java.util.stream.Stream），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。 新增的 API 如下： BufferedReader.line(): 返回文本行的流Stream&lt;String&gt; File.lines(Path, Charset): 返回文本行的流Stream&lt;String&gt; File.list(Path): 遍历当前目录下的文件和目录 File.walk(Path, int, FileVisitOption): 遍历某一个目录下的所有文件和指定深度的子目录 File.find(Path, int, BiPredicate, FileVisitOption...): 查找相应的文件 下面就是用流式操作列出当前目录下的所有文件和目录： Files.list(new File(\".\").toPath()).forEach(System.out::println); 5. JavaScript 引擎 NashornJava 8 提供了一个新的Nashorn javascript引擎，它允许我们在 JVM 上运行特定的 javascript 应用。Nashorn javascript 引擎只是javax.script.ScriptEngine另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子： ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName(\"JavaScript\"); System.out.println(engine.getClass().getName()); System.out.println(\"Result:\" + engine.eval(\"function f(){return 1;}; f() + 1;\")); 输出如下： jdk.nashorn.api.scripting.NashornScriptEngine Result: 2 6. 并发（Concurrency）在新增Stream机制与Lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）（请查看我们关于Java 并发的免费课程）。 新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。 在java.util.concurrent.atomic包中还增加了下面这些类： DoubleAccumulator DoubleAdder LongAccumulator LongAdder 7. 类依赖分析器jdepsJdeps是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，jdeps会输出到控制台。 作为例子，让我们看看现在很流行的 Spring 框架的库的依赖关系报告。为了让报告短一些，我们只分析一个 jar: org.springframework.core-3.0.5.RELEASE.jar. jdeps org.springframework.core-3.0.5.RELEASE.jar这个命令输出内容很多，我们只看其中的一部分，这些依赖关系根绝包来分组，如果依赖关系在classpath里找不到，就会显示 not found。 C:\\Program Files\\Java\\jdk1.8.0\\jre\\lib\\rt.jar org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar) -> java.io -> java.lang -> java.lang.annotation -> java.lang.ref -> java.lang.reflect -> java.util -> java.util.concurrent -> org.apache.commons.logging not found -> org.springframework.asm not found -> org.springframework.asm.commons not found org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar) -> java.lang -> java.lang.annotation -> java.lang.reflect -> java.util 8. JVM 的 PermGen 空间被移除PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。JVM 选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。 区别： 元空间并不在虚拟机中，而是使用本地内存 默认情况下，元空间的大小仅受本地内存限制 也可以通过-XX：MetaspaceSize指定元空间大小 参考资料 「MoreThanJava」Day 7：接口详解 - https://www.wmyskxz.com/2020/08/13/morethanjava-day-7-jie-kou-xiang-jie/ 【知乎问题】Lambda 表达式 有何用处？如何使用？ | @Mingqi - https://www.zhihu.com/question/20125256 Java8新特性及使用(一) | 闪烁之狐 - http://blinkfox.com/2018/11/13/hou-duan/java/java8-xin-te-xing-ji-shi-yong-yi/#toc-heading-21 Java8新特性及使用(二) | 闪烁之狐 - http://blinkfox.com/2018/11/14/hou-duan/java/java8-xin-te-xing-ji-shi-yong-er/ 文章推荐 这都JDK15了，JDK7还不了解？ - https://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/ 你记笔记吗？关于最近知识管理工具革新潮心脏有话要说 - https://www.wmyskxz.com/2020/08/16/ni-ji-bi-ji-ma-guan-yu-zui-jin-zhi-shi-guan-li-gong-ju-ge-xin-chao-xin-zang-you-hua-yao-shuo/ 黑莓OS手册是如何详细阐述底层的进程和线程模型的？ - https://www.wmyskxz.com/2020/07/31/hao-wen-tui-jian-hei-mei-os-shou-ce-shi-ru-he-xiang-xi-chan-shu-di-ceng-de-jin-cheng-he-xian-cheng-mo-xing-de/ 「MoreThanJava」系列文集 - https://www.wmyskxz.com/categories/MoreThanJava/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java7版本特性详解","slug":"Java7版本特性详解","date":"2020-08-18T06:32:00.000Z","updated":"2020-12-09T05:04:39.539Z","comments":true,"path":"2020/08/18/java7-ban-ben-te-xing-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/18/java7-ban-ben-te-xing-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 特性总览以下是 Java 7 中引入的部分新特性，关于 Java 7 更详细的介绍可参考官方文档。 java.lang 包 Java 7 多线程下自定义类加载器的优化 Java 语言特性 改进的类型推断； 使用 try-with-resources 进行自动资源管理 switch 支持 String； catch 多个异常； 数字格式增强（允许数字字面量下划线分割）； 二进制字面量； 增强的文件系统； Fork/Join 框架； Java 虚拟机 (JVM) 提供新的 G1 收集器； 加强对动态调用的支持； 新增分层编译支持； 压缩 Oops； 其他优化； 其他； 多线程下自定义类加载器的优化在 Java 7 之前，某些情况下的自定义类加载器容易出现死锁问题。下面👇来简单分析演示一下官方给的例子 (下面用中文伪代码还原了一下)： // 类的继承情况： class A extends B class C extends D // 类加载器： Custom Classloader CL1: 直接加载类 A 委托 CL2 加载类 B Custom Classloader CL2: 直接加载类 C 委托 CL1 加载类 D // 多线程下的情况： Thread 1: 使用 CL1 加载类 A → 定义类 A 的时候会触发 loadClass(B)，这时会尝试 锁住🔐 CL2 Thread 2： 使用 CL2 加载类 C → 定义 C 的时候会触发 loadClass(D)，这时会尝试 锁住🔐 CL1 ➡️ 造成 死锁☠️ 造成死锁的重要原因出在 JDK 默认的 java.lang.ClassLoader.loadClass() 方法上： 可以看到，JDK 6 及之前的 loadClass() 的 synchronized 关键字是加在方法级别的，那么这就意味加载类时获取到的是一个 ClassLoader 级别的锁。 我们来描述一下死锁产生的情况： 文字版的描述如下： 线程1：CL1 去 loadClass(A) 获取到了 CL1 对象锁，因为 A 继承了类 B，defineClass(A) 会触发 loadClass(B)，尝试获取 CL2 对象锁； 线程2：CL2 去 loadClass(C) 获取到了 CL2 对象锁，因为 C 继承了类 D，defineClass(C) 会触发 loadClass(D)，尝试获取 CL1 对象锁 线程1 尝试获取 CL2 对象锁的时候，CL2 对象锁已经被 线程2 拿到了，那么 线程1 等待 线程2 释放 CL2 对象锁。 线程2 尝试获取 CL1 对像锁的时候，CL1 对像锁已经被 线程1 拿到了，那么 线程2 等待 线程1 释放 CL1 对像锁。 然后两个线程一直在互相等中…从而产生了死锁现象… 究其原因就是因为 ClassLoader 的锁太粗粒度了。在 Java 7 中，在使用具有并行功能的类加载器的时候，将专门用一个带有 类加载器和类名称组合的对象 用于进行同步操作。(感兴趣可以看一下 loadClass() 内部的 getClassLoadingLock(name) 方法) Java 7 之后，之前线程死锁的情况将不存在： 线程1： 使用CL1加载类A（锁定CL1 + A） defineClass A触发 loadClass B（锁定CL2 + B） 线程2： 使用CL2加载类C（锁定CL2 + C） defineClass C触发 loadClass D（锁定CL1 + D） 改进的类型推断在 Java 7 之前，使用泛型时，您必须为变量类型及其实际类型提供类型参数： Map map = new HashMap(); 在 Java 7 之后，编译器可以通过识别空白菱形推断出在声明在左侧定义的类型： Map map = new HashMap(); 自动资源管理在 Java 7 之前，我们必须使用 finally 块来清理资源，但防止系统崩坏的清理资源的操作并不是强制性的。在 Java 7 中，我们无需显式的资源清理，它允许我们使用 try-with-resrouces 语句来借由 JVM 自动完成清理工作。 Java 7 之前： BufferedReader br = null; try { br = new BufferedReader(new FileReader(path)); return br.readLine(); } catch (Exception e) { log.error(\"BufferedReader Exception\", e); } finally { if (br != null) { try { br.close(); } catch (Exception e) { log.error(\"BufferedReader close Exception\", e); } } } Java 7 及之后的写法： try (BufferedReader br = new BufferedReader(new FileReader(path)) { return br.readLine(); } catch (Exception e) { log.error(\"BufferedReader Exception\", e); } switch 支持 Stringswitch 在 Java 7 中能够接受 String 类型的参数，实例如下： String s = ... switch(s) { case \"condition1\": processCondition1(s); break; case \"condition2\": processCondition2(s); break; default: processDefault(s); break; } catch 多个异常自Java 7开始，catch 中可以一次性捕捉多个异常做统一处理。示例如下： public void handle() { ExceptionThrower thrower = new ExceptionThrower(); try { thrower.manyExceptions(); } catch (ExceptionA | ExceptionB ab) { System.out.println(ab.getClass()); } catch (ExceptionC c) { System.out.println(c.getClass()); } } 请注意：如果 catch 块处理多个异常类型，则 catch 参数隐式为 final 类型，这意味着，您不能在 catch 块中为其分配任何值。 数字格式增强为了解决长数字可读性不好的问题，在 Java 7 中支持了使用下划线分割的数字表达形式： /** * Supported in int * */ int improvedInt = 10_00_000; /** * Supported in float * */ float improvedFloat = 10_00_000f; /** * Supported in long * */ float improvedLong = 10_00_000l; /** * Supported in double * */ float improvedDouble = 10_00_000; 二进制字面量在 Java 7 中，您可以使用整型类型 (byte、short、int、long) 并加上前缀 0b (或 0B) 来创建二进制字面量。这在 Java 7 之前，您只能使用八进制值 (前缀为 0) 或十六进制值 (前缀为 0x 或者 0X) 来创建： int sameVarOne = 0b01010000101; int sameVarTwo = 0B01_010_000_101; byte byteVar = (byte) 0b01010000101; short shortVar = (short) 0b01010000101 增强的文件系统Java 7 推出了全新的NIO 2.0 API以此改变针对文件管理的不便，使得在java.nio.file包下使用Path、Paths、Files、WatchService、FileSystem等常用类型可以很好的简化开发人员对文件管理的编码工作。 1 - Path 接口 和 Paths 类Path接口的某些功能其实可以和java.io包下的File类等价，当然这些功能仅限于只读操作。在实际开发过程中，开发人员可以联用Path接口和Paths类，从而获取文件的一系列上下文信息。 int getNameCount(): 获取当前文件节点数 Path getFileName(): 获取当前文件名称 Path getRoot(): 获取当前文件根目录 Path getParent(): 获取当前文件上级关联目录 联用Path接口和Paths类型获取文件信息： Path path = Paths.get(\"G:/test/test.xml\"); System.out.println(\"文件节点数:\" + path.getNameCount()); System.out.println(\"文件名称:\" + path.getFileName()); System.out.println(\"文件根目录:\" + path.getRoot()); System.out.println(\"文件上级关联目录:\" + path.getParent()); 2 - Files 类联用Path接口和Paths类可以很方便的访问到目标文件的上下文信息。当然这些操作全都是只读的，如果开发人员想对文件进行其它非只读操作，比如文件的创建、修改、删除等操作，则可以使用Files类型进行操作。 Files类型常用方法如下： Path createFile(): 在指定的目标目录创建新文件 void delete(): 删除指定目标路径的文件或文件夹 Path copy(): 将指定目标路径的文件拷贝到另一个文件中 Path move(): 将指定目标路径的文件转移到其他路径下，并删除源文件 使用Files类型复制、粘贴文件示例： Files.copy(Paths.get(\"/test/src.xml\"), Paths.get(\"/test/target.xml\")); 使用 Files 类型来管理文件，相对于传统的 I/O 方式来说更加方便和简单。因为具体的操作实现将全部移交给 NIO 2.0 API，开发人员则无需关注。 3 - WatchServiceJava 7 还为开发人员提供了一套全新的文件系统功能，那就是文件监测。 在此或许有很多朋友并不知晓文件监测有何意义及目，那么请大家回想下调试成热发布功能后的 Web 容器。当项目迭代后并重新部署时，开发人员无需对其进行手动重启，因为 Web 容器一旦监测到文件发生改变后，便会自动去适应这些“变化”并重新进行内部装载。Web 容器的热发布功能同样也是基于文件监测功能，所以不得不承认，文件监测功能的出现对于 Java 文件系统来说是具有重大意义的。 文件监测是基于事件驱动的，事件触发是作为监测的先决条件。开发人员可以使用java.nio.file包下的StandardWatchEventKinds类型提供的3种字面常量来定义监测事件类型，值得注意的是监测事件需要和WatchService实例一起进行注册。 StandardWatchEventKinds类型提供的监测事件： ENTRY_CREATE：文件或文件夹新建事件； ENTRY_DELETE：文件或文件夹删除事件； ENTRY_MODIFY：文件或文件夹粘贴事件； 使用WatchService类实现文件监控完整示例： public static void testWatch() { /* 监控目标路径 */ Path path = Paths.get(\"G:/\"); try { /* 创建文件监控对象. */ WatchService watchService = FileSystems.getDefault().newWatchService(); /* 注册文件监控的所有事件类型. */ path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY); /* 循环监测文件. */ while (true) { WatchKey watchKey = watchService.take(); /* 迭代触发事件的所有文件 */ for (WatchEvent event : watchKey.pollEvents()) { System.out.println(event.context().toString() + \" 事件类型：\" + event.kind()); } if (!watchKey.reset()) { return; } } } catch (Exception e) { e.printStackTrace(); } } 通过上述程序示例我们可以看出，使用WatchService接口进行文件监控非常简单和方便。首先我们需要定义好目标监控路径，然后调用FileSystems类型的newWatchService()方法创建WatchService对象。接下来我们还需使用Path接口的register()方法注册WatchService实例及监控事件。当这些基础作业层全部准备好后，我们再编写外围实时监测循环。最后迭代WatchKey来获取所有触发监控事件的文件即可。 Fork/ Join 框架1 - 什么是 Fork/ Join 框架Java 7 提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。比如我们要计算 1 + 2 + .....+ 10000，就可以分割成 10 个子任务，让每个子任务分别对 1000 个数进行运算，最终汇总这 10 个子任务的结果。 Fork/Join 的运行流程图如下： 2 - 工作窃取算法工作窃取 (work-stealing) 算法是指某个线程从其他队列里窃取任务来执行。核心思想是：自己的活干完了去看看别人有没有没有干完的活儿，如果有就拿过来帮他干。 工作窃取的运行流程图如下： 工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。 3 - 简单示例让我们通过一个简单的需求来使用下Fork／Join框架，需求是：计算1 + 2 + 3 + 4的结果。 使用Fork/Join框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1 + 2，子任务二负责计算3 + 4，然后再join两个子任务的结果。 因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下： import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.Future; import java.util.concurrent.RecursiveTask; /** * CountTask. * * @author blinkfox on 2018-01-03. * @originalRef http://blinkfox.com/2018/11/12/hou-duan/java/java7-xin-te-xing-ji-shi-yong/#toc-heading-5 */ public class CountTask extends RecursiveTask&lt;Integer> { /** 阈值. */ public static final int THRESHOLD = 2; /** 计算的开始值. */ private int start; /** 计算的结束值. */ private int end; /** * 构造方法. * * @param start 计算的开始值 * @param end 计算的结束值 */ public CountTask(int start, int end) { this.start = start; this.end = end; } /** * 执行计算的方法. * * @return int型结果 */ @Override protected Integer compute() { int sum = 0; // 如果任务足够小就计算任务. if ((end - start) &lt;= THRESHOLD) { for (int i = start; i &lt;= end; i++) { sum += i; } } else { // 如果任务大于阈值，就分裂成两个子任务来计算. int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 等待子任务执行完，并得到结果，再合并执行结果. leftTask.fork(); rightTask.fork(); sum = leftTask.join() + rightTask.join(); } return sum; } /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) throws ExecutionException, InterruptedException { ForkJoinPool fkPool = new ForkJoinPool(); CountTask task = new CountTask(1, 4); Future&lt;Integer> result = fkPool.submit(task); System.out.println(\"result:\" + result.get()); } } 虚拟机增强Oracle 官网介绍：https://docs.oracle.com/javase/7/docs/technotes/guides/vm/enhancements-7.html 1 - 提供新的 G1 收集器Java 7 引入了一个被称为 Garbage-First (G1) 的垃圾收集器。G1 是服务器式的垃圾收集器 (设计初衷是尽量缩短处理超大堆——大于 4GB——时产生的停顿)，适用于具有大内存多处理器的计算机。 与之前收集器不同的是 G1 没有使用 Java 7 之前连续的内存模型： 而是将整个 堆空间 划分为了多个大小相等的独立区域 (Region)*，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分 *(可以不连续) Region的集合： G1 完全可以预测停顿时间，并且可以为内存密集型应用程序提供更高的吞吐量。 ⚠️ 对于 G1 和垃圾收集器不熟悉的同学赶紧来这里补课啦!!! 2 - 加强对动态调用的支持Java 7 之前字节码指令集中，四条方法调用指令 (invokevirtual、invokespeicial、invokestatic、invokeinterface) 的第一个参数都是 被调用方法的符号引用，但动态类型的语言只有在 运行期 才能确定接受的参数类型。这样，在 Java 虚拟机上实现的动态类型语言就不得不使用“曲线救国”的方式 (如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配) 来实现，这样势必让动态类型语言实现的复杂度增加，也可能带来额外的性能或者内存开销。 为了从 JVM 底层解决这个问题 (早在 1997 年出版的《Java 虚拟机规范》第一版中就规划了这样一个愿景：“在未来，我们会对 Java 虚拟机进行适当的扩展，以便更好的支持其他语言运行于 Java 虚拟机之上”), Java 7 新引入了 invokedynamic 指令以及 java.lang.invoke 包。 想进一步了解可以阅读： 解析 JDK 7 的动态类型语言支持 | nfoQ - https://www.infoq.cn/article/jdk-dynamically-typed-language 动态调用 101 - https://www.infoworld.com/article/2860079/invokedynamic-101.html 官方文档 - https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/package-summary.html 3 - 分层编译Java 7 中引入的 分层编译 为服务器 VM 带来了客户端一般的启动速度。通常，服务器 VM 使用 解释器 来收集有关「提供给 编译器 的方法」的分析信息。在分层模式中，除了 解释器 之外，客户端编译器 还用于生成方法的编译版本，这些方法收集关于自身的分析信息。由于编译后的代码比 解释器 要快得多，程序在分析阶段执行时会有更好的性能。在许多情况下，可以实现比客户机 VM 更快的启动，因为服务器编译器生成的最终代码可能在应用程序初始化的早期阶段就已经可用了。分层模式还可以获得比常规服务器 VM 更好的峰值性能，因为更快的分析阶段允许更长的分析周期，这可能产生更好的优化。(ps: 官方文档如是说…) 支持 32 位和 64 位模式，以及压缩 Oops。在 java 命令中使用 -XX:+TieredCompilation 标志来启用分层编译。 (ps: 这在 Java 8 是默认开启的) 4 - 压缩 Oops (CompressOops)HotSpot JVM 使用名为 oops 或 Ordinary Object Pointers 的数据结构来表示对象。这些 oops 等同于本地C指针。 instanceOops 是一种特殊的 oop，表示 Java 中的对象实例。 在 32 位的系统中，对象头指针占 4 字节，只能引用 4 GB 的内存，在 64 位系统中，对象头指针占 8 字节。更大的指针尺寸带来了问题： 更容易 GC，因为占用空间更大了； 降低了 CPU 缓存命中率，因为一条 cache line 中能存放的指针数变少了； 为了能够保持 32 位的性能，oop 必须保留 32 位。那么，如何用 32 位 oop 来引用更大的堆内存呢？答案是——压缩指针 (CompressedOops)。JVM 被设计为硬件友好，对象都是按照 8 字节对齐填充的，这意味着使用指针时的偏移量只会是 8 的倍数，而不会是下面中的 1-7，只会是 0 或者 8： mem: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ^ ^ 这就允许了我们不再保留所有的引用，而是每隔 8 个字节保存一个引用： mem: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ^ ^ | ___________________________| | | heap: | 0 | 1 | CompressedOops，可以让跑在 64 位平台下的 JVM，不需要因为更宽的寻址，而付出 Heap 容量损失的代价 (其中还涉及零基压缩优化——Zero-Based Compressed OOPs 技术)。 不过它的实现方式是在机器码中植入压缩与解压指令，可能会给 JVM 增加额外的开销。 想要了解更多戳这里： JVM 中的压缩 OOP | Baeldung - https://www.baeldung.com/jvm-compressed-oops 官方文档 - https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html 其他优化将 interned 字符串移出 perm gen在 JDK 7 中，interned 字符串不再在 Java 堆的永久生成中分配，而是在 Java 堆的主要部分 (称为年轻代和年老代) 中分配，与应用程序创建的其他对象一起分配。这一更改将导致驻留在主 Java 堆中的数据更多，而驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用 String.intern() 方法的较大应用程序将看到更显著的差异。 (ps: String.intern() 方法是运行期扩展方法区常量池的一种手段) NUMA 收集器增强Java 7 对 Parallel Scavenger 垃圾收集器进行了扩展，以利用具有 NUMA (非统一内存访问) 体系结构的计算机的优势。大多数现代计算机都基于 NUMA 架构，在这种架构中，访问内存的不同部分需要花费不同的时间。通常，系统中的每个处理器都具有提供低访问延迟和高带宽的本地内存，以及访问速度相当慢的远程内存。 在 Java HotSpot 虚拟机中，已实现了 NUMA 感知的分配器，以利用此类系统并为 Java 应用程序提供自动内存放置优化。分配器控制堆的年轻代的 eden 空间，在其中创建大多数新对象。分配器将空间划分为多个区域，每个区域都放置在特定节点的内存中。分配器基于以下假设：分配对象的线程将最有可能使用该对象。为了确保最快地访问新对象，分配器将其放置在分配线程本地的区域中。可以动态调整区域的大小，以反映在不同节点上运行的应用程序线程的分配率。这甚至可以提高单线程应用程序的性能。另外，年轻一代，老一代和永久一代的“从”和“到”幸存者空间为其打开了页面交错。这样可以确保所有线程平均平均具有对这些空间的相等的访问延迟。 版本号大于 50 的类文件必须使用 typechecker 进行验证从 Java 6 开始，Oracle 的编译器使用 StackMapTable 制作类文件。基本思想是，编译器可以显式指定对象的类型，而不是让运行时执行此操作。这样可以在运行时提供极小的加速，以换取编译期间的一些额外时间和已编译的类文件 (前面提到的 StackMapTable) 中的某些复杂性。 作为一项实验功能，Java 6 编译器默认未启用它。 如果不存在 StackMapTable，则运行时默认会验证对象类型本身。 版本号为 51 的类文件 (也就是 Java 7 的类文件) 是使用类型检查验证程序专门验证的，因此，方法在适当时必须具有 StackMapTable 属性。对于版本 50 的类文件，如果文件中的堆栈映射丢失或不正确，则 HotSpot JVM 将故障转移到类型推断验证程序。对于版本为 51 (JDK 7 默认版本) 的类文件，不会发生此故障转移行为。 参考资料 Oracle 官方文档 - https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html 闪烁之狐 - Java7新特性及使用 - http://blinkfox.com/2018/11/12/hou-duan/java/java7-xin-te-xing-ji-shi-yong/#toc-heading-5 JVM - 指针压缩 - https://chanjarster.github.io/post/jvm/oop-compress/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"你记笔记吗？关于最近知识管理工具革新潮心脏有话要说","slug":"你记笔记吗？关于最近知识管理工具革新潮心脏有话要说","date":"2020-08-16T07:03:00.000Z","updated":"2020-12-09T04:55:53.420Z","comments":true,"path":"2020/08/16/ni-ji-bi-ji-ma-guan-yu-zui-jin-zhi-shi-guan-li-gong-ju-ge-xin-chao-xin-zang-you-hua-yao-shuo/","link":"","permalink":"http://www.wmyskxz.com/2020/08/16/ni-ji-bi-ji-ma-guan-yu-zui-jin-zhi-shi-guan-li-gong-ju-ge-xin-chao-xin-zang-you-hua-yao-shuo/","excerpt":"","text":"以下来自于知乎问题：如何评价「我来 wolai.com」这个产品？ 的回答。但更多的是分享自己关于知识管理方面的思考。 最近正好在学习产品和研究笔记类软件相关的知识，也在写「MoreThanJava」系列的过程中思考更好的知识组织方式，同时又作为 Notion、印象笔记的长期使用用户，仅以我个人的角度来对「wolai」和「更好的知识组织方式」谈谈感受、想法、期待和思考。 关于我来 「兜兜转转之后，我发现，所有的丰衣足食，最后都是自己动手。于是，便有了 “我来”」—— 来自知乎回答「如何评价wolai这款产品」马总亲自的回答 我来这个名字，多多少少蕴含着一丝个人主义的野心：活的网状系统、继承所有笔记类软件的优点、对中文极致友好、解决所有的不完美。 但是不管是官网的介绍，还是马总在知乎上的回答，都聚焦在 「这是一个更好的软件」 这个问题上，关于 「如何带来更大的价值」 这点对于大多数人却是模糊的（事实上只有少部分人能非常直观地感知到价值——坚信第二大脑和长期使用笔记类软件的用户）。 比如，相比印象笔记官网直观的价值体现： wolai 就显得含蓄许多： 先结合自己使用笔记类软件时遇到问题和学习的经历来简单说明一下其中的价值吧。 首先，记录笔记有价值首先，记录有价值，笔记有价值，记录笔记有价值。 知识大爆炸 原因之一是我们遇到了问题：信息过载，知识爆炸，同时大脑又对信息爆炸的时代适应性很差。 根据IDC发表的《数据时代 2025》的报告显示：全球每年产生的数据将从 2018 年的 33ZB 增长到 175ZB ，相当于每天产生 491EB 的数据。如果把 175ZB 全部存在 DVD 光盘中，那么 DVD 叠加起来的高度将是地球到月球距离的 23 倍（月地最近距离约 39.3 万公里），或者绕地球 222 圈（一圈约为四万公里）。以 25Mb /秒网速计算，要下载完这 175ZB 的数据，需要 18 亿年。虽然这种指数级的增长为个人和整个社会带来了巨大的机遇，但无论是人类的大脑还是目前的技术，都无法充分发挥其潜力。 Tips：Byte &lt; KB &lt; MB &lt; GB &lt; TB &lt; PB &lt; EB &lt; ZB &lt; YB 大脑并不靠谱 虽然大脑的存储量惊人（并且消耗量很少——相当于一个 5w 的灯泡），但也是出了名的不靠谱——这是因为我们的大脑并不会存储每一个细节，而是把它们存储为一个一个的「模块」，回忆发生的时候也是将各种「模块」拼接成大概的样子。 比如当你经历「2001 年那个寒冷的下雪的晚上」，你会把「寒冷」「下雪」「晚上」以及 「2001 年」这些「记忆」分别存储，等需要调用的时候再一起「拼装」出来。同样当你回忆去年很冷的晚上遇见了一个老朋友，那么这个「寒冷」的感觉就是被复用的 —— 这也是为什么我们总会有一种「此时此地此景我似乎在哪里见到过」的原因 。 另外，基于上述存储方式，我们很少能精确地进行量化 —— 我们生活中经常使用 「可能」、「肯定」、「也许」等词，在我们的直觉中，我们会感觉到类似于我们对这些信念模糊的概率，但是实际上我们经常被客观数据打脸。这也是为什么我们总强调客观，但始终还是做不到的原因，因为我们的记忆是模糊的。所以我们今天的大脑还是会有许多的认知偏差，让我们做出各种错误的决策。 这就是我们的大脑，虽然存储量很大耗能很少，但是不够精确，充满了不确定性。 互联网有害论 新的媒介会带来新的思维方式。 在书面文化出现之前的纯口头文化中，思维受制于人类的记忆能力，你的知识就是你能记住的内容，而你能记住的又受限于头脑存储容量。在没有文字记载的文化中，人类的记忆就是最重要的媒介，成语、谚语、诗歌和故事包含了世代相传的口头智慧。 当人们能够把文字书写下来时，文字就把知识从个体记忆的束缚中解放了出来，使得语言不再受到记忆和背诵所要求的诗歌韵律及公式化结构的约束，思维和表达的广阔疆域随之向大脑开放。 麦克卢汉写道：“西方世界所取得的成就，正是读写能力带来巨大价值的有力证明，这是显而易见的。” 而后沃尔特·翁在1982年出版的影响巨大的研究著作《口头文化与书面文化》（Orality and Literacy）中持有类似的观点。他评论说，“口头文化能够产生强大而优美的口头表现能力，具有很高的艺术价值和人文价值。一旦书写占据了人们的心灵，口头文化连存在的可能性都没有了”。 但关于互联计算设备带给我们人类思维方式的改变，我想每个人都深有体会，并且各种批判也已经太多了。 劣币驱逐良币的市场（个性化的无限推送、泛滥的八卦和暴戾无知的言论让绝大部分人很难聚焦到有意义的事情上）、隐私丧失带来的诚实丧失问题（在网络上我们展示的是自己希望被认同的东西，它带有一些强制的表演成分）、随便谁都能说一嘴的口头交流社会的回归，这些对于大多数人来说，和这个新媒介建立的连接，都是相当有害的。 如果说现状是计算设备作为一种新媒介，被我们人类用偏了，那么它本来能带来什么新的思维？ 计算设备里，构建世界的成本很低，互动性很好，反馈很快。 想想下棋，比如围棋。当你学习围棋时，首先要学会很多规则，来从小局部去阅读棋子的组合：黑色在这里，白色在那里，往哪里下是可以的，往哪里下是有利的。 然后，随着你的水平逐渐提高，就要学会从远处看：你不是 alpha go，无法进行全局的计算，从远处看的时候，使用的是直觉。 围棋，以及很多类似的东西，都是当思维复杂度趋于极限，我们的脑子就要开始变得紊乱的情况下，逼我们调动两种截然不同的思维方式。 离散和连续。 理性和直觉。 这种切换难度非常的大。而记录，特别是带有自己深刻思考的记录能够尽可能地把复杂度如此高的世界抽象疏解出来。只是会使用互联计算设备并不能掌握这个媒介本身，就像光是学习阅读和文字并不能写出好文章一样。 什么应该交给机器，什么应该交给直觉，是我们在当今高速发展互联网世界，需要不断需要学习的技能。 值得一提的是，许多人思考 「复利」 的时候往往只考虑了金钱的回报，却忘记了知识也是有复利的。当这样积累一段时间之后，你的知识节点越来越多，连接越来越丰富，就会产生知识的复利效应 —— 毕竟知识网络是具有极强的「梅特卡夫」效应的。 其次，传统笔记具有局限性我们处于数字世界中，几乎随时随地都能获取几乎所有的知识，甚至也有 「知识的挑战不在于获取知识，而在于知道什么知识有价值，并且建立一个系统」 的定论。但我仍觉得这是或多或少带有幸存者偏差的视角，这本质上跟谈论「飞机是相对较安全的交通工具」一样，然而事实上是中国人有 10 亿人没有坐过飞机。 对于帮助我们如何建立一个系统，我们有许多的传统工具可以选择，但他们似乎都有各自的局限性。 为什么分类是个坏主意？ 用文件或文件夹来组织笔记的方式会导致笔记形成僵硬的结构，我们只能通过书本目录组织它，或随着时间不断新增按照时间线组织。这种线性的组织方式最大的问题在于：你并不能一开始就能预见会遇到什么知识，哪怕你做了很好的学习计划，但总会邂逅一些存在你分类体系之外的、零碎的笔记。 怎么管理它们呢？新建一个「综合」或者「其他」吗？这相当于没有分类，你会毫不意外地忘掉你大部分存在于这个分类下的笔记。（这就是为什么大多数人都忘了自己还有个临时文件夹的原因） 标签的发明一部分解决了单一维度的文件夹所带来的问题，但是我们按照标签查看笔记时也很局限：我们一次只能看到几个标签内的内容，此外的内容则被遮蔽了，因此在组织信息和资料方面实用性并不很高。 另外，为了让标签系统不会过度膨胀，你还需要小心的控制标签的数量，你需要记得你曾经使用过的标签以避免歧义的标签（例如 #移动端 和 #手机端）等等。 这样做知识管理的心智负担太重了，所以更好的办法是：我们应该用网络结构（web）来组织我们的笔记 —— 不仅仅依靠标签，还要把所有笔记连接在一起。我们可以每次只关注在这张网络的某个连接点上，但更重要的是，我们同时也能看到更多的联结发生在背后。 搜索的局限性 此外，搜索也是有局限性的。蒋方舟说过，搜索永远做不到像人类的大脑一样，通过一个具体的场景，联想出无限相关、有趣的场景故事。 我们在上面论述过我们的大脑是按照 「模块」 来记忆的，并且也是按 「模块」 进行发散思考的。 例如，我此刻听到了一首古典钢琴曲，如果知道键盘乐器的历史，就很容易想起巴赫，想起巴赫，就会想起海顿以及他的老师波尔波拉。巴赫喜欢用羽管键琴，而海顿不是一位键盘音乐家，即便如此，在晚期创作中，他还是注意到了钢琴的广泛应用。如果知道巴赫和海顿通过数学和音乐来体现了神的意志，那就很容易联想到18世纪学问与神学的关系。如此下去，举一反三，浮想联翩。（ps:这一段摘录的…） 网状链接是如何破局的？我们先来尝试一下问自己几个问题： 你还记得几年前看的某一本书吗？还记得整理的笔记里写的什么吗？ 我们扔进收藏的 “有用知识” 有多少是被真正使用过的？ 是不是在重复记录一些信息，而这些信息可能前一段时间就整理过？ 为什么会这样？ 有一个观点是：人类的大脑根本就不是用来记忆的。我们的认知中有一个深层的原则：我们在认知上要比记忆上要好得多。 你可能有过这样的经历：读了一篇文章，并没有发现什么特别令人惊讶的东西。你基本上同意作者所说的一切，即使你以前从来没有完全这么想过。你可以认可他们所写的东西的有效性，因为你 “已经知道了”。但这决不意味着你可以自己回忆并写下来。 但是，如果你已经知道了，那么这些知识在哪里呢？在你能认识但不能回忆起来的广大空间里。 大脑根本不是用来记忆的。你记住了一个电话号码，几分钟后它就消失了。你的大脑中所有的功能都在不断清除旧的记忆，削弱未使用的连接。另一方面，你的大脑的识别能力是惊人的：我们可以在一瞬间认出人脸，多年后的人脸。我们只需读几句就能看出我们以前读过的内容。即使是与过去的经验只有隐约相似的情况，也会引发似曾相识的感觉。 通过依赖识别而不是回忆，我们在创造性的追求中获得了更大的带宽和记忆力。这里有一个问题：识别并不是孤立的，它需要某种外部刺激。它需要某种外部刺激来让我们认识。它需要一个具体的媒介，让我们的感官来推动。 网状链接的结构能够允许创造一个丰富触发器、提示和钩子的环境，以引发记忆、联系，甚至更多的新想法。 懂的 「跟过去的自己取经」 是非常重要和高效的方式。 法国科学家莱昂·迪蒙曾经就打过的一个比方，用水在地上的流淌来说明经验对大脑产生的影响：“水流经过的地方，会自行冲出一条不断加宽、加深的沟渠。以后再有水流的时候，水会自然沿着以前的轨迹流淌。大脑内部也是这样，外部事物在神经系统中留下的印迹会为自己塑造出越来越合适的路径。在类似的外部刺激作用下，这些极其重要的通路即使曾经中断过，此时也会重现。” 我们在使用网状笔记的时候，通过不断与之前的知识点进行碰撞（有自己的思考），又不断地产生新的链接，就可以不断强化自己的这些知识体系。 另外也引用一下@少楠在少数派说的话： 另外，不要成为工具的奴隶，重要不是记录，而是记录过程中独立的思考。在 Notion 中文社群中天天看到许多用户叫嚷着让 Notion 支持双向链接，但是不妨想想是工具不能构建网状体系，还是你大脑中根本没有对知识的体系？套用一句在张立宪文章中看到的一个故事：葛存壮对少年葛优说，要真喜欢音乐，吹口哨都行。 工具带来的思维方式的改变 工具会带来思维方式的改变，一个典型的例子就是时钟，它改变了我们看待自己的方式。 在时钟出现之前，人们经历的时间都是一种连续的周期性流动。从这个意义上说，时间是被 “记录” 下来的，比如影子围着它移动的日冕、沙子从其中流出的沙漏、水从内部躺下的漏壶。 在那个时候，精确地测量时间，或者把一天划分成细小的片段，都没有特别的必要。对大多数人来说，日月星辰的移动提供了他们所需的唯一时钟。用法国中古史学家雅克·勒高夫（Jacques Le Goff）的话说，那时的生活“由农耕节律支配，有忙有闲，有粗有细，对生产力漠不关心”。 一旦钟表把时间重新定义为一连串为期相同的单位，我们的头脑就开始重视工作中的条理和分工。 机械钟出现后，人们开始认为他们的大脑和他们的身体甚至整个宇宙都“像钟表”那样运行。在钟表内部紧密咬合的齿轮结构中，表针的转动符合物理定律，形成了一个可以追本溯源的因果长链，我们由此发现了一个机械式隐喻，似乎可以用来解释一切事物的工作方式，以及它们之间的相互关系。 对于所有的事物和现象，我们开始看到构成整体的碎片，然后又看到构成碎片的碎片。我们的思维变成了亚里士多德模式，强调通过表面现象洞悉隐藏在物质世界背后的抽象本质。在推动我们走出中世纪，进入文艺复兴时期，后来又进入启蒙运动时期的过程中，钟表都扮演了至关重要的角色。 使用网状结构的笔记又需要我们进行怎样的思维方式的改变呢？整理了一些实用的部分。 收藏无用，你需要自己整理信息 多数时候我们都会陷入 「收藏者谬误」，感觉收藏到就是学习到，但实际上「知晓某事」并不是「知道某事」。收藏更像是把信息搬运（而非加工），途中没有增加任何知识。 正确的做法应该是：Research, Read, Assimilate; rinse and repeat。没必要捕捉 100% 的信息，大脑像个过滤器，只有不断改变过滤器，才能让信息真正输入到大脑（潜意识会默认过滤掉大量无用信息，这一点很难觉察到） 信息被你的感官收集。信息不是这世间万物的属性，而是我们解释他们的一部分。所以消费信息的时候，不断的记录就是一个解释的过程，也是一个向大脑内「写入」的过程。 阅读是一种建构主义的活动：信息必须从现有的数据中创造出来。这就意味着需要一个创造者，在其中加入自己的感悟。你的工作是对文本进行意义的建构，创造信息，并将其记录下来，因为你自己的解读才是最重要的。 标准化行为，反而激发创造力 在用集装箱运输之前，全球运输的效率是很低下的，所有的配套设施都是非标准化的。全球贸易的到来是因为全部运输过程都围绕集装箱进行了设计，这样让输出和输入效率变得极高，继而带动了许多地区贸易的腾飞。 在日常的记录中也是如此。时至今日，许多人仍然以临时的、随机的方式记笔记 —— 甚至很多人不做记录。如果他们看到一个有趣的金句，他们会在下面划线。如果他们想发表评论，他们会把它写在空白处。如果他们有一个好主意，他们会把它写在手边的任何一个笔记本上（或者手机备忘录）。如果一篇文章看起来足够重要，他们可能会努力保存一个摘录。这使得他们在许多不同的地方用不同的记录方式记录了许多各种格式的内容。这也意味着，当他们开始写作的时候，他们首先得针对这些凌乱的记录，进行一个大规模的收集和整理 —— 或者直接从脑子中调取。 与其为你阅读的每一类信息「发明」一种新的记笔记的方式，不如每次都使用一种完全标准化的格式。不管这些笔记包含什么内容，它们与哪个主题有关，或者它们通过什么媒介传播——你对待每一个笔记的方式完全相同。 正是这种笔记的标准化，使得属于你的信息能够在一个地方建立起来，从量变到质变。如果没有一个标准的格式，虽然收集的数据量会增加，但整理的时间也会增加，或者最终沦为垃圾桶。通用格式消除了不必要的复杂性，也消除了混乱。就像乐高积木一样，标准化的笔记可以很容易地拼装在一起，组装成无穷无尽的形状，同时又不会丢失它们所包含的信息。 通过标准化和简化笔记的格式和处理步骤，我们可以更聚焦在下面的流程：思考、反思、写作、讨论、测试和分享。这是一项增值的工作，现在我们有时间更有效地完成它。 放下思维的包袱 我们有了快速索引知识的方法，并将其压缩成许多知识包，所以整个学习的方法就发生了变化。迅速忘掉所学的东西，或许是新的目标。我希望我的思维成为一个空的容器，能让外界的想法短暂的停留，然后驶入第二大脑。这样我既可以保持清晰地大脑，又能建立起持久的结构。 还有一个关键的是：不要按照任何时间表，或特定的顺序，或者作为工作流程的一部分来总结笔记。完全根据需要来总结它们，尤其是你已经在为其他目的复习笔记的时候。 这对大多数人来说，似乎很难理解，也很难相信。它违背某种常识 —— 知识似乎是某种可变质的商品，就像石油或大豆一样。你的第二大脑不是一个工厂，它是一个网络 —— 当地的居民区、城市中心和高速公路都在以不同的方式、不同的速度变化。 一个特定的笔记可能要到几个月或几年后才会被总结出来，当然更多笔记可能永远不会被总结出来。其实这是很常见的，因为你第一大脑的运作方式就是这样 —— 要么使用，要么失去。不应该试图像捧起沙子一样，不让任何信息从缝隙中流下。而是应该编织一个网络，当你提起来的时候，能按图索骥的找到你想要的东西，而那些没有和网络连接的东西，忘了就忘了吧。 数字笔记它永远不会忘记任何东西 —— 这是一个注意力不足的时代的诅咒。我们需要增加 “数字认知 “的遗忘机制。我认为，最好的办法就是建立注意力引导机制。但这需要注意力的引导。渐进式的总结，是现在的自我和未来的自我之间的一种微妙联系，在这个联系中，你将现在遇到的任何洞察力跃传给未来的自我，以换取你未来的自我在未来的某个时间点上利用这些洞察力。 工具与我们是双向的关系 我们和工具之间形成的紧密联系是双向的。就在技术成为我们自身的外延时，我们也成了技术的外延。木匠把锤子拿在手中的时候，他用手能做的只有锤子能做的事情。那只手变成了钉钉子和拔钉子的工具。战士把望远镜放在眼前的时候，他能看到的只有镜头允许他看到的东西。他的视野变远了，却对近处的景象视而不见了。 Alan Kay 在 2012 年的 SCIx 上提到，每当你创造一个工具的时候，你既做了一个增强器又做了一个假肢。汽车在一定程度上增强了我们，同时在另一方面弱化了我们的身体。 虽然我们通过一些工具能极大的增强我们对于「第二大脑」的建设，但是这一切的价值还是建立在「第一大脑」的背后——因为所谓的知识和智慧，目前来看，只有第一大脑才能生成。 更好的知识组织形式最近自己一直在输出「MoreThanJava」的内容，在回顾 Java 基础内容的时候，发现许多的知识点并不是线性存在的，而发散的代价就是 “文章过长”，甚至是一发不可收拾的那种。 所以我开始关注和思考 「更好的知识组织形式」，双向链接能解决绝大部分的问题（不用过多担心隐藏在表面下的暗知识中的一些思想也非常值得借鉴。我列举几个点来说明一下自己的思考。 更多的内容展示高密度高质量的内容输出，本身就给人深刻的印象，图片就是很典型的例子。制图史学家亚瑟·鲁滨逊（Arthur Robinson）解释说：“以缩小的空间来替代现实空间，这本身就会给人留下深刻的印象。” 另外人的注意力本来就是有限的，在有限的时间内不断获取有用的知识内容不仅能帮我们重新捕获注意力，也能加深我们的印象。（参照抖音） 下面我举一些我认为实用的能够展示更多内容的方法： 标题可以折叠； Tab 容器； Folding 折叠容器； 分栏显示； 例如，我想要说明用户界面设计的版式设计中常见布局形式以及适用场景，你是更喜欢不断往下拉带来的 线性阅读体验： 还是更喜欢横向分栏链接对比性更强的阅读体验呢？ 这对于需要对比阅读的内容非常实用。另外有一些不需要立马展示的内容我们也可以通过引入 Folding 容器给暂时隐藏起来，例如： 总之把我们真正关心的内容尽可能地展示出来，把我们不需要立马关心或者一些提示信息隐藏起来是非常有必要的。（这比下潜一个页面要来得高效得多） 多媒体的支持这一点不必多说，知识的形式现在多种多样（视频、音频、图片），借力于互联网的发展，多媒体的支持非常必要。 另外想多提一句的是对于超链接，是否应该摒弃掉只是字体变浅，增加下划线的传统。 把超链接编程丰富的按钮： 或是含有按钮的图标： 都是可能也值得的尝试。 另外图片和视频的展示方式也值得考量。 更加丰富实用的组件有一些组件很实用，比如时间线： 诸如此类的还有一些可以帮助我们思考，进一步完成「第二大脑」使命的工具都值得考虑。（当然，这得看我来的愿景是什么了） 几点疑问和思考❶ 分享功能该如何做？过去，在传统笔记、甚至是内容分享发生的时候，我们传递的都是一个非常确切的信息。它是一篇文章、一段视频、一首歌…. 不管这些确切信息里面发生了怎样的引用和链接，我们分享的始终是我想要分享的一个 “点” 给你。 但是当双向链接时时发生的时候，这一切都将变得有些复杂。因为没有所谓的 “点” 了，所有信息都直接或者间接地互相联系，所以问题是： 我分享的信息中存在的双向链接，都应该向被分享的人公开吗？ 如果是，那么我不想分享的信息应该如何被保护？ 如果不是，我需要设置每一个信息的公开级别吗？ ❷ 更加”智能”的双向链接这一点来自于我真实的使用场景。例如，我在阅读《互联网如何毒化了我们的大脑》时，在命名为书名的页面下摘抄了一句话（在书名的页面下摘抄语句是我认为正确的操作）： [[纽约大学]][[神经学家]][[约瑟夫·勒杜克斯]]（Joseph LeDoux）在其著作[[《通过突触看自己》]]（Synaptic Self）中解释说，天性和教养“实际上志同道合，二者都是通过形成大脑当中的突触组织，最终达到它们的精神效果和行为效果”。 很明显，我们上方出现几个希望被双向链接的概念：纽约大学、神经学家、约瑟夫·勒杜克斯、《通过突触看自己》以及以书名命名的页面本身，我们理想中的链接情况是： 然而，当我们摘抄完这句话，默认建立好的链接如下： 这意味着我们需要额外建立如下的链接： 我能想到最好的方式就是，我在「约瑟夫·杜勒克斯」这个 Page 下用双向链接的方式写明，它是一位来自于纽约大学的神经学家，并且有著作《通过突触看自己》。 这没啥问题.. 但会打断我的思考和阅读.. 所以问题是：如果让一句话里的双向链接都建立默认的链接会怎么样呢？（对应这里就是系统自动帮我们建立了额外的链接并新增了纽约大学和神经学家的链接） 额外的链接似乎并不会对我们造成负担，相反自己做额外的链接反而会增加负担，是这样的吗？ 另外，当我想要把某一个概念与知识库进行链接的时候，我期待的并不是只是链接，被链接同样是我期待的。 例如我在上面写： 原因是我们遇到了问题：信息过载，知识爆炸，同时[[大脑]]又对信息爆炸的时代适应性很差。 这句话的时候，我期待跟大脑相关的链接能从某个地方跳出来而不影响我此刻的写作。 ❸ 增加返回上一页功能or临时工作空间确实，双向链接能够触发我们场景式、概念是的发散思考，但是随着发散的进行，我们很容易就忘记了我们原本出发的位置。（这也是我使用软件常困扰的问题——跳转着跳转着发现不知道去哪儿了） 或者直接做一个临时工作空间，把需要用到的材料和链接都可以临时地扔过去保存。发现在悬浮目录的下边儿有足够的空间可以使用.. 这样跳转着跳转着就不知道去哪儿的问题就能够得到有效解决了.. Emmm… 我暂时还没有想到更好的方式… 对我来的期待限于自身的水平，写这篇回答花了不少精力.. 而且就在使用 wolai 写作的过程中（2 天），被提示要升级了两次.. 不得不佩服 wolai 更新迭代的能力。 希望马总不仅真的能够把我来打造成为 “集所有优点” 于一身的 “完美云端笔记” 吧，同时也有一些私心地希望我来能够成为 知识管理的 “布道者”（这一点可以参看印象笔记的官方博客），这样才能发挥软件的最大价值吧（因为是真的喜欢我来）。 不管我来最终定价多少，我都会支持！ （另外我还不要脸地问了一下我来招不招人.. 看到招人标准后就匿了… 捂脸🤦‍♂️逃…😸） （END） 这里是 我没有三颗心脏，一位 96 年 奋力奔跑 的 自由技术人，在这里分享 知识/技术/思考/成长，还不来关注！","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 7：接口详解","slug":"「MoreThanJava」Day-7：接口详解","date":"2020-08-13T07:26:00.000Z","updated":"2020-12-09T04:39:33.225Z","comments":true,"path":"2020/08/13/morethanjava-day-7-jie-kou-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/13/morethanjava-day-7-jie-kou-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 接口概述Java 是单继承的。这意味着子类仅从一个父类继承。通常，这就是你需要的。有时候多继承会提供方便，但也会造成混乱，例如，当继承的两个父类具有不同版本的签名相同的两个方法时该调用哪一个呢？ 接口为 Java 提供了多继承的一些优点，而没有缺点。 接口的概念在 Java 程序设计语言中，接口不是类，而是对希望符合这个接口的类的一组需求。 我们 之前 接触的 抽象类，性格偏内向，描述的是一组相对具体的特征，比如某品牌特定型号的汽车，底盘架构、控制电路、刹车系统等是抽象出来的共同特征，但根据动感型、舒适型、豪华型的区分，内饰、车头灯、显示屏等都可以存放不同版本的具体实现。 而 接口 是开放的，性格偏外向，它就像一份合同，定义了方法名、参数列表、返回值，甚至是抛出异常的类型。谁都可以实现它，但如果想实现它的类就必须遵守这份接口约定的合同。 想一想比较熟悉的 USB 接口：它不仅仅约束了 U 盘 (实现类) 的大小和形状，同样也约束了电脑插槽 (使用类)。在编程中，接口类似。 接口的定义在 Java 中使用 interface 关键字来定义接口。接口是顶级的 “类”，虽然关键字是 interface，但编译之后的字节码扩展名还是 .class。一个典型接口的结构如下： public interface InterfaceName { constant definitions method headers (without implementations). } 比如，我们在 前面文章 讨论「为什么不推荐使用继承？」中举的鸟类的例子，任何能飞的鸟都必须实现如下接口： public interface Flyable { void fly(); } 接口中的所有方法都自动是 public。因此，在接口中声明方法时，不必提供关键字 public。(在 Java 9 中允许了接口定义声明为 private 的方法，在这之前都是不允许的..) 想一想接口就像是合同一样，所以任何不清晰的细节都是不允许的。因此，接口中只允许明确的方法定义和常量出现。(下方的例子中演示了一个不被允许的接口定义 —— 因为 y 变量没有确定的值) interface ErrorInterfaceDefine { public final int x = 32; public double y; // No variables allowed public double addup(); } 这看起来有点儿像类的定义，但没有任何对象能够构建一个接口 (new一个接口.. 因为接口是绝对抽象的，不允许实现..)*，但你可以定义一个类实现 *(关键字 impelents) 接口，一旦你这么做了，你就可以构造这个 (实现接口的) 类的对象。 例如麻雀既能飞、也能叫、还能下蛋：(实现多个接口使用 , 分隔) public class Sparrow impelents Flayable, Tweetable, EggLayable {//麻雀 //... 省略其他属性和方法... @Override public void fly() { //... } @Override public void tweet() { //... } @Override public void layEgg() { //... } } 接口的属性❶ 接口不是类，不能使用 new 运算符实例化一个接口，但却可以用来引用实现了这个接口的类对象： Comparable x = new Employee(...); // OK provided Emloyee implements Comparable ❷ 与建立类的继承层次一样，也可以扩展接口！比如，假设这里有一个名为 Moveable 的接口： public interface Moveable { void move(double x, double y); } 然后，可以假设一个名为 Powered 的接口扩展了以上的 Moveable 接口： public interface Powered extends Moveable { double milesPerGallon(); } ❸ 虽然在接口中不能包含实例字段，但是可以包含常量。比如： public interface Powered extends Moveable { double SPEED_LIMIT = 95; // a public static final constant double milesPerGallon(); } ❹ 另外有一些接口之定义了常量，而没有定义方法。例如，标准库中的 SwingConstants 就是这样一个接口，其中只包含了 NORTH、SOUTH 和 HORIZONTAL 等常量。任何实现 SwingConstants 接口的类都自动地继承了这些常量，并可以在方法中引用它们，而不必采用 SwingConstants.NORTH 这样繁琐的书写形式。不过，这样使用接口更像是退化，所以建议最好不要这样使用… ➡️ 一个类只能有一个父类，但可以实现很多个接口。这就为定义类的行为提供了极大的灵活性。(我们之前也讨论过——在讨论继承的章节——这里不再赘述) 静态和私有方法➡️ 在 Java 8 中，允许在接口中增加静态方法 (允许不构建对象而直接使用的具体方法)。理论上讲，没有任何理由认为这是不合法的，只是这有违将接口作为抽象规范的初衷。 目前为止，通常的做法都是将静态方法放在 伴随类 (可以理解为操作继承接口的实用工具类) 中。在标准库中，你可以看到成对出现的接口和实用工具类，如 Collection/ Collections 或 Path/ Paths。 在 Java 11 中，Path 接口就提供了一个与之工具类 Paths.get() 等价的方法 (该方法用于将一个 URI 或者字符串序列构造成一个文件或目录的路径)： public interface Path { public static Path of(String first, String... more) { ... } public static Path of(URI uri) { ... } } 这样一来，Paths 类就不再是必要的了。类似地，如果实现你自己的接口时，没有理由再额外提供一个带有实用方法的工具类。 ➡️ 另外，在 Java 9 中，接口中的方法可以是 private。private 方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以它们的用法很有限，只能作为接口中其他方法的辅助方法。 默认方法在 Java 8 中，允许为接口方法提供一个默认的实现。必须用 default 修饰符标记这样一个方法，例如 JDK 中的 Iterator 接口： public interface Iterator&lt;E> { boolean hasNext(); E next(); default void remove() { throw new UnsupportedOperationExceition(\"remove\"); } } 这将非常有用！如果你要实现一个迭代器，就需要提供 hasNext() 和 next() 方法。这些方法没有默认实现——它们依赖于你要遍历访问的数据结构。不过，如果你的迭代器是 只读 的，那么就不用操心实现 remove() 方法。 默认方法也可以调用其他方法，例如，我们可以改造 Collection 接口，定义一个方便的 isEmpty() 方法： public interface Collection { int size(); // an abstract method default boolean isEmpty() { return size() == 0; } } 这样，实现 Collection 的程序员就不用再操心实现 isEmpty() 方法了。 (事实上这也是 AbstractCollection 抽象类的定义——所有的集合具体实现几乎都继承了 AbstractCollection抽象类——但为什么顶层的 Collection 接口不做这样的修改呢？我起初是怀疑有一些特殊的集合为空的定义有特殊性，但我没有找到..几乎所有的集合为空判定都为自身的元素等于 0。所以答案是什么呢？是解决默认方法冲突的 “类优先” 原则！👇) 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在类或另一个接口中定义同样的方法，会发生什么？ // 测试接口 1 public interface TestInterface1 { default void sameMethod() { System.out.println(\"Invoke TestInterface1 method！\"); } } // 测试接口 2 public interface TestInterface2 { default void sameMethod() { System.out.println(\"Invoke TestInterface2 method！\"); } } // 继承两个接口的测试类 public class TestObject implements TestInterface1, TestInterface2 { @Override public void sameMethod() { // 这里也可以选择两个接口中的一个默认实现 // 如： TestInterface1.super.sameMethod(); System.out.println(\"Invoke Object method！\"); } } // 测试类 public class Tester { public static void main(String[] args) { TestObject testObject = new TestObject(); testObject.sameMethod(); } } 测试输出： Invoke Object method！ ➡️ 对于 Scale 或者 C++ 这些语言来说，解决这种具有 二义性 的情况规则会很复杂，Java 的规则则简单得多： 类优先。如果本类中提供了一个具体方法符合签名，则同名且具有相同参数列表的接口中的默认方法会被忽略； 接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了一个同名且参数列表相同的方法 (顺序和类型都相同) ，则必须覆盖这个方法来解决冲突 (就是👆代码的情况，不覆盖编译器不会编译..)； Java 设计者更强调一致性，让程序员自己来解决这样的二义性似乎也显得很合理。如果至少有一个接口提供了一个实现，编译器就会报告错误，程序员就必须解决这个二义性。(如果两个接口都没有为共享方法提供默认实现，则不存在冲突，要么实现，要么不实现..) ➡️ 我们只讨论了两个接口的命名冲突。现在来考虑另一种情况，一个类继承自一个类，同时实现了一个接口，从父类继承的方法和接口拥有同样的方法签名，又将怎么办呢？ // 测试接口 public interface TestInterface { default void sameMethod() { System.out.println(\"Invoke TestInterface Method！\"); } } // 父类 public class Father { void sameMethod() { System.out.println(\"Invoke Father Method！\"); } } // 子类 public class Son extends Father implements TestInterface { @Override public void sameMethod() { System.out.println(\"Invoke Son Method！\"); } } // 测试类 public class Tester { public static void main(String[] args) { new Son().sameMethod(); } } 程序输出： Invoke Son Method！ 还记得我们说过的方法调用的过程吗 (先找本类的方法找不到再从父类找)？加上这里提到的 “类优先” 原则 (本类中有方法则直接调用)，这很容易理解！ 千万不要让一个默认方法重新定义 Object 类中的某个方法。例如，不能为 toString() 或 equals() 定义默认方法，尽管对于 List 之类的接口这可能很有吸引力，但由于 类优先原则，这样的方法绝对无法超越 Object.toString() 或者 Object.equals()。 (这里就对应上方思考为什么不在 Collection 中定义默认的 isEmpty() 方法的答案) Part 2. 接口与工厂模式 这一部分节选自 极客时间 | 设计模式之美：https://time.geekbang.org/column/article/197254 原作者：王争 接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是 工厂方法设计模式。这与直接调用构造器构造对象不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现对象。 理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。下面我们来举例演示一下。 简单工厂模式假设我们现在需要根据文件的后缀名 (json、xml、yaml) 来选择不同的解析器 (JsonRuleConfigParser、XmlRuleConfigParser)，将存储在文件中的配置解析成内存对象 RuleConfig： public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) { parser = new JsonRuleConfigParser(); } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) { parser = new XmlRuleConfigParser(); } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) { parser = new YamlRuleConfigParser(); } else { throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); } String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; } } ➡️ 为了让代码逻辑更加清晰，可读性更好，我们要善于 将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。重构之后的代码如下所示： public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = createParser(ruleConfigFileExtension); if (parser == null) { throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); } String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; } private IRuleConfigParser createParser(String configFormat) { IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(configFormat)) { parser = new JsonRuleConfigParser(); } else if (\"xml\".equalsIgnoreCase(configFormat)) { parser = new XmlRuleConfigParser(); } else if (\"yaml\".equalsIgnoreCase(configFormat)) { parser = new YamlRuleConfigParser(); } return parser; } } ➡️ 为了让类的职责更加单一、代码更加清晰，我们还可以进一步将 createParser() 函数剥离到一个单独的类中，让这个类只负责对象的创建。而这个类就是我们现在要将的 简单工厂 模式类。具体的代码如下所示： public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension); if (parser == null) { throw new InvalidRuleConfigException( \"Rule config file format is not supported: \" + ruleConfigFilePath); } String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; } } public class RuleConfigParserFactory { public static IRuleConfigParser createParser(String configFormat) { IRuleConfigParser parser = null; if (\"json\".equalsIgnoreCase(configFormat)) { parser = new JsonRuleConfigParser(); } else if (\"xml\".equalsIgnoreCase(configFormat)) { parser = new XmlRuleConfigParser(); } else if (\"yaml\".equalsIgnoreCase(configFormat)) { parser = new YamlRuleConfigParser(); } return parser; } } (这样的 Factory 代码暂称为第一种实现) 在类的命名中体现设计模式是非常好的方式 (例如这里的 RuleConfigParserFactory)。大部分工厂类都是以 “Factory” 这个单词结尾的，但也不是必须的，比如 Java 中的 DateFormat、Calender。 除此之外，工厂类中创建对象的方法一般都是 create 开头，比如代码中的 createParser()，但有的也命名为 getInstance()、createInstance()、newInstance()，有的甚至命名为 valueOf() （比如 Java String 类的 valueOf() 函数） 等等，这个我们根据具体的场景和习惯来命名就好。 ➡️ 在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用： public class RuleConfigParserFactory { private static final Map&lt;String, RuleConfigParser> cachedParsers = new HashMap&lt;>(); static { cachedParsers.put(\"json\", new JsonRuleConfigParser()); cachedParsers.put(\"xml\", new XmlRuleConfigParser()); cachedParsers.put(\"yaml\", new YamlRuleConfigParser()); } public static IRuleConfigParser createParser(String configFormat) { if (configFormat == null || configFormat.isEmpty()) { return null;//返回null还是IllegalArgumentException全凭你自己说了算 } IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); return parser; } } (这样的 Factory 代码暂称为第二种实现) 这有点类似于单例模式和简单工厂模式的结合。 但上面两种实现的简单工厂，都有违背 开闭原则 (对扩展开放，对修改关闭)。想象一下现在我们如果要新增一种 parser，那么势必会修改 RuleCOnfigParserFactory 里面的代码！但好在就日常的使用来说，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。 工厂方法回看👆我们上方的第一种实现，如果可能的话，我们的 if-else 代码会随着文件种类的增加列得越来越长，最终不仅可读性很差，也变得更加难以维护 (复杂度增加)，而且也不怎么优雅。 如果我们非得去掉 if-else 分支逻辑的话，应该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示： public interface IRuleConfigParserFactory { IRuleConfigParser createParser(); } public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new JsonRuleConfigParser(); } } public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new XmlRuleConfigParser(); } } public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory { @Override public IRuleConfigParser createParser() { return new YamlRuleConfigParser(); } } 实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。 从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示： public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParserFactory parserFactory = null; if (\"json\".equalsIgnoreCase(ruleConfigFileExtension)) { parserFactory = new JsonRuleConfigParserFactory(); } else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) { parserFactory = new XmlRuleConfigParserFactory(); } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) { parserFactory = new YamlRuleConfigParserFactory(); } else { throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath); } IRuleConfigParser parser = parserFactory.createParser(); String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; } } 从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？ 我们可以为工厂类再创建一个简单工厂，也就是 工厂的工厂，用来创建工厂类对象。这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。 public class RuleConfigSource { public RuleConfig load(String ruleConfigFilePath) { String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath); IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension); if (parserFactory == null) { throw new InvalidRuleConfigException(\"Rule config file format is not supported: \" + ruleConfigFilePath); } IRuleConfigParser parser = parserFactory.createParser(); String configText = \"\"; //从ruleConfigFilePath文件中读取配置文本到configText中 RuleConfig ruleConfig = parser.parse(configText); return ruleConfig; } private String getFileExtension(String filePath) { //...解析文件名获取扩展名，比如rule.json，返回json return \"json\"; } } //因为工厂类只包含方法，不包含成员变量，完全可以复用， //不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。 public class RuleConfigParserFactoryMap { //工厂的工厂 private static final Map&lt;String, IRuleConfigParserFactory> cachedFactories = new HashMap&lt;>(); static { cachedFactories.put(\"json\", new JsonRuleConfigParserFactory()); cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory()); cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory()); } public static IRuleConfigParserFactory getParserFactory(String type) { if (type == null || type.isEmpty()) { return null; } IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase()); return parserFactory; } } 当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。 实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单薄 （只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。 什么时候该用工厂方法模式呢？我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。 所以让我们有足够理由使用工厂方法模式的情况大概有以下两点： 当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候； 避免烦人的 if-else 分支逻辑时； 抽象工厂(Abstract Factory)在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式 (Json、Xml、Yaml……) 来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象 (Rule 规则配置还是 System 系统配置) 来分类，那就会对应下面这 6 个 parser 类。 针对规则配置的解析器：基于接口IRuleConfigParser JsonRuleConfigParser XmlRuleConfigParser YamlRuleConfigParser 针对系统配置的解析器：基于接口ISystemConfigParser JsonSystemConfigParser XmlSystemConfigParser YamlSystemConfigParser 针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个 parser 都编写一个工厂类，也就是要编写 6 个工厂类。如果我们未来还需要增加针对业务配置的解析器 (比如 IBizConfigParser)，那就要再对应地增加 4 个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？ 抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象 (IRuleConfigParser、ISystemConfigParser 等)，而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示： public interface IConfigParserFactory { IRuleConfigParser createRuleParser(); ISystemConfigParser createSystemParser(); //此处可以扩展新的parser类型，比如IBizConfigParser } public class JsonConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new JsonRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new JsonSystemConfigParser(); } } public class XmlConfigParserFactory implements IConfigParserFactory { @Override public IRuleConfigParser createRuleParser() { return new XmlRuleConfigParser(); } @Override public ISystemConfigParser createSystemParser() { return new XmlSystemConfigParser(); } } // 省略YamlConfigParserFactory代码 重点回顾 接口的概念 / 接口的定义 / 接口的实现 / 接口的属性； 接口的静态和私有方法 / 如何解决默认方法的冲突； 接口和工厂模式； 练习练习 1：实现一个图形绘制工具 创建一个可以绘制不同形状的绘图工具，可以绘制圆形、矩形、三角形，每个图形都会有一个 draw() 方法用于绘图，而绘图工具也有一个 draw() 方法，根据传入类型的不同调用不同的方法。 创建 IShape 接口： public interface IShape { void draw(); } 继承 IShape 接口创建圆形、矩形、三角形： // 圆形 public class Circle implements IShape { @Override public void draw() { System.out.println(\"Draw Circle...\"); } } // 矩形 public class Rectangle implements IShape { @Override public void draw() { System.out.println(\"Draw Rectangle...\"); } } // 三角形 public class Triangle implements IShape { @Override public void draw() { System.out.println(\"Draw Triangle...\"); } } 图形绘制工具： public class Paint { public static void draw(IShape shape) { shape.draw(); } } 测试类： public class Tester { public static void main(String[] args) { Paint.draw(new Circle()); Paint.draw(new Rectangle()); Paint.draw(new Triangle()); } } 程序输出： Draw Circle... Draw Rectangle... Draw Triangle... (ps：说实话这一篇文章虽然写了两天.. 但感觉总体质量挺差的.. 原因有许多，一来是发现存在很多知识点交叉的情况——也就是说知识是互相联系的，想要说清楚不容易——而且常常组织起来非常庞大。二来是发现光说清楚一个知识点也挺不容易的..所以在考虑新的组织形式.. 最近有接触到一些双向链接的工具.. 探索探索..) 参考资料 《Java 核心技术 卷 I》 《Java 编程思想》 Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html 极客时间 | 设计模式之美 - https://time.geekbang.org/column/article/177110 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！ (另外这些基础的知识体系我打算自己偷偷慢慢在博客搭建啦.. 等有确实的成果之后再分享吧.. 公众号还是希望分享更多能对小伙伴们有用的实际的东西.. Respect~)","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 6：面向对象进阶——多态","slug":"「MoreThanJava」Day-6：面向对象进阶——多态","date":"2020-08-10T12:30:00.000Z","updated":"2020-12-09T04:39:30.133Z","comments":true,"path":"2020/08/10/morethanjava-day-6-mian-xiang-dui-xiang-jin-jie-duo-tai/","link":"","permalink":"http://www.wmyskxz.com/2020/08/10/morethanjava-day-6-mian-xiang-dui-xiang-jin-jie-duo-tai/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 多态概述多态，简而言之就是 同一个行为 具有 多个不同表现形式 或形态的能力。在面向对象的程序设计中，多态的能力是通过数据抽象和继承之后得来的。 比如，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作 (方法)，对于不同温度的水 (运行时不同的对象类型)，就会得到不同的结果，这就是多态。 代码演示： // 基类定义 public class Water { public void showTem() { } } // 冰水 public class IceWater extends Water { @Override public void showTem() { System.out.println(\"我的温度是: 0度\"); } } // 温水 public class WarmWater extends Water { @Override public void showTem() { System.out.println(\"我的温度是: 40度\"); } } // 开水 public class HotWater extends Water { @Override public void showTem() { System.out.println(\"我的温度是: 100度\"); } } // 测试类 public class TestWater { public static void main(String[] args) { Water w = new WarmWater(); w.showTem(); w = new IceWater(); w.showTem(); w = new HotWater(); w.showTem(); } } 结果输出： 我的温度是: 40度 我的温度是: 0度 我的温度是: 100度 这里的方法 showTem() 就相当于你去摸水杯。我们定义的 Water 类型的引用变量 w 就相当于水杯，你在水杯里放了什么温度的水，那么我摸出来的感觉就是什么。就像代码中的那样，放置不同温度的水，得到的温度也就不同，但水杯是同一个。 里氏替换原则（LSP）面向对象的设计原则有一条关于多态的原则，它的描述大概是这样子的：子类对象 (object of subtype/derived class) 能够 替换 程序 (program) 中 父类对象 (object of base/parent class) 出现的 任何地方，并且 保证原来程序的逻辑行为 (behavior) 不变及正确性不被破坏。 这么说可能有点抽象，简单说就是 子类和父类的行为应该保持一致。 哪些代码明显违背了 LSP？实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是 “Design By Contract”，中文翻译就是 “按照协议来设计”。定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。 为了更好地理解这句话，我举几个违反里式替换原则的例子来解释一下。 1 - 子类违背父类声明要实现的功能父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。 2 - 子类违背父类对输入、输出、异常的约定在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。 3 - 子类违背父类注释中所罗列的任何特殊说明父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。 当然，当前的大环境下，注释的可信度还是得斟酌斟酌.. (不可尽信..) Part 2. 向上转型 &amp;&amp; 向下转型再谈向上转型在 上一篇文章 里面我们已经谈到 —— 对象既可以作为它本身的类型使用，也可以作为它基类的类型使用。而这种把对某个对象的引用视为其基类型的引用的做法被称为 向上转型 (因为在继承树的画法中，基类位于子类上方)。 语句 Water w = new WarmWater(); 就是向上转型的典型代码，这会将子类类型 WarmWater 转成父类的 Water 类型。 存在问题❶ 向上转型时，子类单独定义的方法会丢失。 例如，我们如果在温水中定义一个喝水的方法 drink()，那么当 w 引用指向 WarmWater 类实例的时候是访问不到 drink() 方法的，w.drink() 会报错。 ❷ 子类引用不能指向父类对象。 HotWater hotWater = (HotWater)new Water(); 这样是不行的。 向上转型的好处 减少重复代码，提高代码可读性； 提高系统扩展性； 举个例子，比如我现在有许多不同温度的水，如果不用向上转型，摸水杯这个动作我需要这样写： // Water 类中方法定义 public void showTem(IceWater water) { water.showTem(); } public void showTem(WarmWater water) { water.showTem(); } public void showTem(HotWater water) { water.showTem(); } // 测试类中调用 water.showTem(new IceWater()); water.showTem(new WarmWater()); water.showTem(new HotWater()); 每一种不同温度的水我都需要在 Water 中单独定义一个方法 (因为都是不同的类型)，数量一多，就会变得非常冗余和复杂。 但使用向上转型，一切就轻松多了： // Water 类中方法定义 public void showTem(Water water) { water.showTem(); } // 测试类中调用 water.showTem(new IceWater()); water.showTem(new WarmWater()); water.showTem(new HotWater()); 就算新添加一种温度的水，我也只需要继承 Water 实现 showTem() 方法就行了，原有的代码几乎不需要修改。这也体现了软件设计原则中重要的 开闭原则 —— 对扩展开放，对修改封闭。 向下转型与向上转型相对应的就是向下转型了 —— 也就是把父类对象转为子类对象。(这有大坑…) 还是用上面的摸水杯的例子来说明，我们先在温水 WarmWater 中加入一个喝水的方法： public class WarmWater extends Water { @Override public void showTem() { System.out.println(\"我的温度是: 40度\"); } // 新增加的喝水的方法 public void drink() { System.out.println(\"喝水...\"); } } 示例代码： class Tester { public static void main(String[] args) { Water water = new WarmWater();// 子类实例赋给父类引用 - 向上转型 WarmWater warmWater = (WarmWater) water;// Water向下转型为WarmWater warmWater.drink(); IceWater iceWater = (IceWater) water;// Water向下转型为IceWater iceWater.drink();// IDE 提示无法找到 drink() 方法 } } 为什么第一段代码不报错呢？因为 water 本身就是 WarmWater 类型的对象，所以它理所当然的可以向下转型为 WarmWater 类型了，也理所当然的不能转型为 IceWater，这就好像你见过 一条狗突然变成一只猫 的情况吗？ 再来看下列代码： class Tester { public static void main(String[] args) { Water water = new Water(); WarmWater warmWater = (WarmWater) water; // 下列代码报错：java.lang.ClassCastException: class Water cannot be cast to class WarmWater warmWater.drink(); } } 上面例子想要说明的是，Water 类型的对象 (父类型) 不能向下转型为任何类型的对象。这就好像你去考古，你发现了一个新生物，你知道它是一种动物，但你不能直接说它是猫或者狗… 向下转型注意事项 向下转型的前提是父类对象指向的是子类对象；(也就是对应上面实例代码中向下转型 WarmWater 的情况.. new WarmWater() 首先得完成向上的转型..) 向下转型只能转型为本类对象；(猫是不能变成狗的.. 对应上方 WamWater 类型就不能转成 IceWarm 类型的情况) 向下转型的意义有的小伙伴可能看到这里有点懵了.. 向下转型需要先向上转型，这转来转去好玩儿是吗？ 向上转型让我们有了统一处理一类抽象事物的能力，这大大减少了我们的重复代码，并增加了我们代码的可扩展性。可事实上是，尽管我们尽力抽象一类事物，让他们尽可能地保证行为的统一，但总有例外！(就像 上一次 我们讨论继承时提到的鸟类的例子，并不是所有鸟都能飞或者叫！) 所以当例外来临时，我们就可以及时判断并做对应的处理。(这也比较符合现实的情况) 最典型的例子就是 JDK 中的某一些集合类，对于集合类来说，并不需要记住存储所有存储对象的类型，而是统一抽象成了 Node 类型，就拿 HashMap 来说吧，存储一个元素 (putVal() 方法) 时就要判定当前节点时属于链表还是红黑树的部分： Part 3. 多态经典案例分析我们来看一个经典的例子： // A 类 public class A { public String show(D object) { return \"A and D\"; } public String show(A object) { return \"A and A\"; } } // B 类 public class B extends A { public String show(B object) { return \"B and B\"; } @Override public String show(A object) { return \"B and A\"; } } // C 类 public class C extends B{ } // D 类 public class D extends B{ } 测试类： public class Tester { public static void main(String[] args) { A a = new A(); A aRefB = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1-\" + a.show(b)); System.out.println(\"2-\" + a.show(c)); System.out.println(\"3-\" + a.show(d)); System.out.println(\"4-\" + aRefB.show(b)); System.out.println(\"5-\" + aRefB.show(c)); System.out.println(\"6-\" + aRefB.show(d)); System.out.println(\"7-\" + b.show(b)); System.out.println(\"8-\" + b.show(c)); System.out.println(\"9-\" + b.show(d)); } } 输出结果： 1-A and A 2-A and A 3-A and D 4-B and A 5-B and A 6-A and D 7-B and B 8-B and B 9-A and D 前三个比较容易，因为 B、C 都本质上是 A 类，所以 1 和 2 都进入了 A 类中签名为 show(A) 的方法。 但是第四个非常奇怪，A 对象类型引用了一个 B 类型的实例，输出是 B and A，而不是想象中的 B and B，为什么呢？ 这里有一个新知识点：决定调用哪个方法的是引用变量类型。 拿这里的 aRefB.show(b) 来说好了，aRefB 虽然是 A 类型的引用，但首先会查找 B 对象中的方法 (因为它实际的指向是 B)，而引用 b 正好是一个 B 类型 (实质上是 is-a A 类型)，所以符合 B 对象中签名为 show(A) 的方法，就输出了 B and A。如果 B 类型中没有符合签名的方法，那么会从父类中查找，继续这个过程直到找到或者报错。 如果你能理解这个过程，并分析其他的情况，那么说明你真的掌握了。 再来分析 b.show(d) 输出 A and D 的情况，就简单很多了：B 对象中不存在 show(D) 这样的签名，所以从父类 A 中查找，故输出了 A and D。 要点回顾 多态概述 / 里氏替换原则 / 向上向下转型； 典型多态案例分析 / 练习； 练习练习 1：工资结算系统 某公司有三种类型的员工，分别是部门经理、程序员和销售员。需要设计一个工资结算系统，根据提供的员工信息来计算月薪。 部门经理的月薪是每月固定 15000 元；程序员的月薪按每月工作时间计算，每小时 150 元；销售员的月薪是 1200 底薪加上销售额 5% 的提成； 抽象员工类： public abstract class AbstractEmployee { private String name; public AbstractEmployee(String name) { this.name = name; } // 获取工资 public abstract double getSalary(); public String getName() { return name; } public void setName(String name) { this.name = name; } } 项目经理类： public class Manager extends AbstractEmployee { public Manager(String name) { super(name); } @Override public double getSalary() { return 15000; } } 程序员类： public class Programer extends AbstractEmployee { private Integer workHours; public Programer(String name, Integer workHours) { super(name); this.workHours = workHours; } // 仅提供单独的 set 方法，工作时间理论上来说是一个私人的消息.. public void setWorkHours(Integer workHours) { this.workHours = workHours; } @Override public double getSalary() { return 150 * workHours; } } 销售员类： public class Salesman extends AbstractEmployee { private Integer salesAmount; public Salesman(String name, Integer salesAmount) { super(name); this.salesAmount = salesAmount; } // 也仅提供 set 方法，并不是所有人都能访问销售人员的销售金额 public void setSalesAmount(Integer salesAmount) { this.salesAmount = salesAmount; } @Override public double getSalary() { return 1200 + 0.05 * salesAmount; } } 测试类： import java.util.List; public class Tester { public static void main(String[] args) { // 项目经理张三、996程序员李四、月销售过万的明星销售员王五 List&lt;AbstractEmployee> employees = List .of(new Manager(\"张三\"), new Programer(\"李四\", (21 - 9) * 6), new Salesman(\"王五\", 10000)); // 发工资.. for (AbstractEmployee employee : employees) { System.out.println(employee.getName() + \"工资为：\" + employee.getSalary()); } } } 程序输出： 张三工资为：15000.0 李四工资为：10800.0 王五工资为：1700.0 (ps：有感受到来自于现实主义的正义光辉洒在你的身上吗？) 参考资料 《Java 核心技术 卷 I》 《Java 编程思想》 Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html 重新认识java（五） —- 面向对象之多态（向上转型与向下转型） - https://blog.csdn.net/qq_31655965/article/details/54746235 极客时间 | 设计模式之美 - https://time.geekbang.org/column/article/177110 Python 100 天从新手到大师 - https://github.com/jackfrued/Python-100-Days 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 5：面向对象进阶——继承详解","slug":"「MoreThanJava」Day-5：面向对象进阶——继承详解","date":"2020-08-07T08:35:00.000Z","updated":"2020-12-09T04:39:27.394Z","comments":true,"path":"2020/08/07/morethanjava-day-5-mian-xiang-dui-xiang-jin-jie-ji-cheng-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/08/07/morethanjava-day-5-mian-xiang-dui-xiang-jin-jie-ji-cheng-xiang-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 继承概述上一篇文章 中我们简单介绍了继承的作用，它允许创建 具有逻辑等级结构的类体系，形成一个继承树。 继承使您可以基于现有类定义新类。 新类与现有类相似，但是可能具有其他实例变量和方法。这使编程更加容易，因为您可以 在现有的类上构建，而不必从头开始。 继承是现代软件取得巨大成功的部分原因。 程序员能够在先前的工作基础上继续发展并不断改进和升级现有软件。 面向对象之前，写代码的一些问题如果你有一个类的源代码，你可以复制代码并改变它变成你想要的样子。在面向对象编程之前，就是这样子做的。但至少有两个问题： ❶ 很难保持仅仅有条。 假设您已经有了几十个需要的类，并且需要基于原始类创造新的一些类，再基于新的类创造出更新的类，最终您将获得数十个源文件，这些源文件都是通过其他已更改的源文件的另外版本。 假设现在在一个源文件中发现了错误，一些基于它的源文件需要进行修复，但是对于其他源文件来说，并不需要！没有细致的写代码的计划，您最终会陷入混乱…. ❷ 需要学习原始代码。 假设您有一个复杂的类，基本上可以完成所需的工作，但是您需要进行一些小的修改。如果您修改了源代码，即使是进行了很小的更改，也可能会破坏某些内容。因此，您必须研究原始代码以确保所做的更改正确，这可能并不容易。 Java 的自动继承机制极大地缓解了这两个问题。 单继承用于作为新类模板的类称为 父类 (或超类或基类)，基于父类创建的类称为 子类 (或派生类)。 就像上图中演示的那样，箭头从子类指向父类。(在上图中，云表示类，而矩形表示对象，这样的表示的方法来自于 Grady Booch 写的《面向对象的分析和设计》一书。而在官方的 UML-统一建模语言 中，类和对象都用矩形表示，请注意这一点) 在 Java 中，子类仅从一个父类继承特征，这被称为 单继承 (与人类不同)。 有些语言允许”孩子”从多个”父母”那里继承，这被称为 多继承。但由于具有多重继承，有时很难说出哪个父母为孩子贡献了哪些特征 (跟人类一样..)。 Java 通过使用单继承避免了这些问题。(意思 Java 只允许单继承) is-a 关系 上图显示了一个父类 (Video 视频类)，一个子类 (Movie 电影类)。它们之间的实线表示 “is-a” 的关系：电影是视频。 注意，继承是在类之间，而不是在对象之间。 (上图两朵云都代表类) 父类是构造对象时使用的蓝图，子类用于构造看起来像父对象的对象，但具有附加功能的对象。 类之间的关系简述简单地说，类和类之间的关系有三种：is-a、has-a 和 use-a。 is-a 关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系； has-a 关系通常称之为关联，比如部门和员工的关系、汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为 聚合关系；如果整体进一步负责了部分的生命周期 (整体和部分是不可分割的，同时同在也同时消亡)，那么这种就是最强的关联关系，我们称之为 合成 关系。 use-a 关系通常称之为依赖，比如司机有一个驾驶的行为 (方法)*，其中 *(的参数) 使用到了汽车，那么司机和汽车的关系就是依赖关系。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 层级结构 上图显示了一个父类和一个子类的 层次结构，以及从每个类构造的一些对象。这些对象用矩形表示，以表达它们比设计的类更真实。 在层次结构中，每个类最多有一个父类，但可能有几个子类。 层次结构顶部的类没有父级。此类称为层次结构的 根。 另外，一个类可以是另一个子类的父类，也可以是父类的子类。就像人类一样，一个人是某些人类的孩子，也是其他人类的父母。(但在 Java 中，一个孩子只有一个父母) Part 2. 继承的实现从父类派生子类的语法是使用 extend 关键字： class ChildClass extend ParentClass { // 子类的新成员和构造函数.... } 父类的成员 (变量和方法) 通过继承包含在子类中。其他成员将在其类定义中添加到子类。 视频观影 App 示例Java 编程是通过创建类层次结构并从中实例化对象来完成的。您可以扩展自己的类或扩展已经存在的类。Java 开发工具包 (JDK) 为您提供了丰富的基类集合，您可以根据需要扩展这些基类。 (如果某些类已经使用 final 修饰，则无法继承) 下面演示了一个使用 Video 类作为基类的视频观影 App 的程序设计： Video 基类： class Video { private String title; // name of video private int length; // number of minutes // constructor public Video(String title, int length) { this.title = title; this.length = length; } public String toString() { return \"title=\" + title + \", length=\" + length; } public String getTitle() { return title;} public void setTitle(String title) { this.title = title;} public int getLength() { return length;} public void setLength(int length) { this.length = length;} } Movie 电影类继承 Video： class Movie extends Video { private String director;// name of the director private String rating; // num of rating // constructor public Movie(String title, int length, String director, String rating) { super(title, length); this.director = director; this.rating = rating; } public String getDirector() { return director; } public String getRating() { return rating; } } 这两个类均已定义：Video 类可用于构造视频类型的对象，现在 Movie 类可用于构造电影类型的对象。 Movie 类具有在 Video 中定义的成员变量和公共方法。 使用父类的构造函数查看上方的示例，在 Movie 类的初始化构造函数中有一条 super(title, length); 的语句，是 “调用父类 Video 中带有 title、length 参数的构造器” 的简写形式。 由于 Movie 类的构造器不能访问 Video 类的私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的 super 语法调用这个构造器。 重要说明：super() 必须是子类构造函数中的第一条语句。 (这意味子类构造器总是会先调用父类的构造器) 这件事经常被忽略，导致的结果就是一些神秘的编译器错误消息。 如果子类的构造器没有显式地调用父类的构造器，将自动地调用父类的无参构造器。如果父类没有无参数的构造器，并且在子类的构造器中又没有显式地调用父类的其他构造器，Java 编译器就会报告一个错误。(在我们的例子中 Video 缺少无参数的构造函数，故👆上面图片代码会报错) 创建一个无参构造函数关于构造函数的一些细节： 您可以显式为类编写无参数的构造函数。 如果您没有为类编写任何构造函数，那么将自动提供无参数构造函数 （称为默认构造函数）。 如果为一个类编写了一个构造函数，则不会自动提供默认的构造函数。 因此：如果您为类编写了额外的构造函数，那么，则还必须编写一个无参数构造函数 (供子类调用)。 在示例程序中，类 Video 包含构造函数，因此不会自动提供默认构造函数。 所以，Movie 类 super() 函数建议默认使用的构造函数 (会自动调用无参数构造函数) 会导致语法错误。 解决方法是将无参数构造函数显式放在类中 Video ，如下所示： class Video { private String title; // name of video private int length; // number of minutes // no-argument constructor public Video() { this.title = \"unknown\"; this.length = 0; } // constructor public Video(String title, int length) { this.title = title; this.length = length; } ... } 覆盖方法让我们来实例化 Movie 对象： public class Tester { public static void main(String[] args) { Video video = new Video(\"视频1\", 90); Movie movie = new Movie(\"悟空传\", 139, \"郭子健\", \"5.9\"); System.out.println(video.toString()); System.out.println(movie.toString()); } } 程序输出： title=视频1, length=90 title=悟空传, length=139 movie.toString() 是 Movie 类直接继承自 Video 类，它并没有使用 Movie 对象具有的新变量，因此并不会打印导演和评分。 我们需要给 Movie 类添加新的 toString() 的使用方法： // 添加到 Movie 类中 public String toString() { return \"title:\" + getTitle() + \", length:\" + getLength() + \", director:\" + getDirector() + \", rating:\" + getRating(); } 现在，Movie 拥有了自己的 toString() 方法，该方法使用了继承自 Video 的变量和自己定义的变量。 即使父类有一个 toString() 方法，子类中新定义的 toString() 也会 覆盖 父类的版本。当子类方法的 签名 (就是返回值 + 方法名称 + 参数列表) 与父类相同时，子类的方法就会 覆盖 父类的方法。 现在运行程序，Movie 打印出了我们期望的完整信息： title=视频1, length=90 title:悟空传, length:139, director:郭子健, rating:5.9 有些人认为 super 与 this 引用是类似的概念，实际上，这样比较并不太恰当。这是因为 super 不是一个对象的引用，例如，不能将值 super 赋给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。 正像前面所看到的那样，在子类中可以增加字段、增加方法或覆盖父类的方法，不过，继承绝对不会删除任何字段或方法。 Part 3. 更多细节protected 关键字如果类中创建的变量或者方法使用 protected 描述，则指明了 “就类用户而言，这是 private 的，但对于任何继承于此类的导出类或者任何位于同一个 包 内的类来说，它是可以访问的”。下面我们就上面的例子来演示： public class Video { protected String title; // name of video protected int length; // number of minutes ... } public class Movie extends Video { ... public String toString() { return \"title:\" + title + \", length:\" + length + \", director:\" + director + \", rating:\" + rating; } ... } 在 protected 修饰之前，如果子类 Movie 要访问父类 Video 的 title 私有变量只能通过父类暴露出来的 getTitle() 公共方法，现在则可以直接使用。 向上转型“为新的类提供方法” 并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用 “新类是现有类的一种类型” 这句话加以概括。 由于继承可以确保基类中所有的方法在子类中也同样有效，所以能够向基类发送的所有信息也同样可以向子类发送。例如，如果 Video 类具有一个 play() 方法， 那么 Movie 类也将同样具备。这意味着我们可以准确地说 Movie 对象也是一种类型的 Video。(体现 is-a 关系) 这一概念的体现用下面的例子来说明： public class Video { ... public void play() {} public static void start(Video video) { // ... video.play(); } ... } // 测试类 public class Tester { public static void main(String[] args) { Movie movie = new Movie(\"悟空传\", 139, \"郭子健\", \"5.9\"); Video.start(movie); } } 在示例中，start() 方法可以接受 Video 类型的引用，这是在太有趣了！ 在测试类中，传递给 start() 方法的是一个 Movie 引用。鉴于 Java 是一个对类型检查十分严格的语言，接受某种类型 (上例是 Video 类型) 的方法同样可以接受另外一种类型 (上例是 Movie 类型) 就会显得很奇怪！ 除非你认识到 Movei 对象也是一种 Video 对象。 在 start() 方法中，程序代码可以对 Video 和它所有子类起作用，这种将 Movie 引用转换为 Video 引用的动作，我们称之为 向上转型 (这样称呼是因为在继承树的画法上，基类在子类的上方…)。 Object 类所有的类均具有父类，除了 Object 类。Java 类层次结构的最顶部就是 Object 类。 如果类没有显式地指明继承哪一个父类，那么它会自动地继承自 Object 类。如果一个子类继承了一个父类，那么父类要么继承它的父类，要么自动继承 Object。最终，所有的类都将 Object 作为祖先。 这意味着 Java 中的所有类都具有一些共同的特征。这些特征在被定义在 Object 中： (其中 finalize() 方法在 Java 9 之后弃用了，原因是因为它本身存在一些问题，可能导致性能问题：死锁、挂起和其他问题…) (想看源码可以打一个 Object，然后按住 Ctrl 不放，然后点击 Object 就可以进入 JDK 源码查看了，源码有十分规范的注释和结构，你有时甚至会发现一些有趣的东西…) Java 之父 Gosling 设计的 Object 类，是对万事万物的抽象，是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知道哲学的三大经典问题：我是谁？我从哪里来？我到哪里去？在 Object 类中，这些问题都可以得到隐约的解答： 我是谁？ getClass() 说明本质上是谁，而 toString() 是当前的名片； 我从哪里来？ Object() 构造方法是生产对象的基本方式，clone() 是繁殖对象的另一种方式； 我到哪里去？ finalize() 是在对象销毁时触发的方法；(Java 9 之后已移除) 另外，Object 还映射了社会科学领域的一些问题： 世界是否因你而不同？ hashCode() 和 equals() 就是判断与其他元素是否相同的一组方法； 与他人如何协调？ wait() 和 notify() 就是对象间通信与协作的一组方法； 理解方法调用准确地理解如何在对象上应用方法调用非常重要。下面假设我们要调用 x.f(args)，x 是声明为 C 的一个对象。下面是调用过程的详细描述： 编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为 f 但参数类型不一样的方法。例如，可能存在 f(int) 和 f(String)。编译器将会一一列举 C 类中所有名为 f 的方法和其父类中所有名为 f 而且可以访问的方法 (父类中的私有方法不可访问)。至此，编译器一直到所有可能被调用的候选方法。 接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为 f 的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为 重载解析 (overloading resolution)。例如，对于调用 x.f(&quot;Hello&quot;)，编译期将会挑选 f(String)，而不是 f(int)。由于允许类型转换 (例如，int 可以转换成 double)，所以情况可能会变得很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报错。至此，编译器已经知道需要调用的方法的名字和参数类型。 如果是 private 方法、static 方法、final 方法 (有关 final 修饰符会在下面讲到) 或者构造器，那么编译器将可以明确地知道应该调用哪个方法。这称为 静态绑定 (static binding)。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时 动态绑定。在我们的实例中，编译器会利用动态绑定生成一个调用 f(String) 的指令。 程序运行并且采用动态绑定调用方法时，虚拟机必须调用与 x 所引用对象的实际类型对应的那个方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了方法 f(String)，就会调用这个方法；否则，将在 D 类的父类中寻找 f(String)，以此类推。 每次调用方法都要完成这样的搜索，时间开销相当大。因此，虚拟机预先为每个类计算了一个 方法表 (method table)， 其中列出了所有方法的签名和要调用的实际方法 *(存着各个方法的实际入口地址)。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。(以下是 Video-父类 和 Movie-子类 的方法表结构演示图)* 例如我们调用上述例子 Movie 类的 play() 方法。 public void play() {}; 由于 play() 方法没有参数，因此不必担心 重载解析 的问题。又不是 private/ static/ final 方法，所以将采用 动态绑定 的方式。 在运行时，调用 object.play() 的解析过程为： 首先，虚拟机获取 object 的实际类型的方法表。这可能是 Video、Movie 的方法表，也可能是 Video 类的其他子类的方法表； 接下来，虚拟机查找定义了 play() 签名的类。此时，虚拟机已经知道应该调用哪个方法了；(这里如果 object 实际类型为 Movie 则调用 Movie.play()，为 Video 则调用 Video.play()，如果没找到才往父类去找..) 最后，虚拟机调用这个方法。 动态绑定有一个非常重要的特性：无须对现有的代码进行修改就可以对程序进行扩展。 假设现在新增一个类 ShortVideo，并且变量 object 有可能引用这个类的对象，我们不需要对包含调用 object.play() 的代码重新进行编译。如果 object 恰好引用一个 ShortVideo 类的对象，就会自动地调用 object.play() 方法。 警告：在覆盖一个方法时，子类的方法 不能低于 父类方法的 可见性 (public &gt; protected &gt; private)。特别是，如果父类方法是 public，子类方法必须也要声明为 public。 final 关键字有时候，我们可能希望组织人们利用某个类定义子类。不允许扩展 (被继承) 的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类了： public final class ShortVideo extends Video { ... } 类中的某个特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法 (final 类中的所有方法自动地称为 final 方法)。例如： public class Video { ... public final void Stop() { ... } ... } 如果一个 字段 被声明为了 final 类型，那么对于 final 字段来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为 final，只有其中的方法自动地称为 final，而不包括字段，这一点需要注意。 将方法或类声明为 final 的主要原因是：确保它们不会在子类中改变语义。 JDK 中的例子 Calendar 类 (JDK 实现的日历类) 中的 getTime 和 setTime 方法都声明为了 final，这就表明 Calendar 类的设计者负责实现 Data 类与日历状态之间的转换，而不允许子类来添乱。 同样的，String 类也是 final 类 (甚至面试中也经常出现)，这意味着不允许任何人定义 String 的子类，换而言之，如果有一个 String 引用，它引用的一定是一个 String 对象，而不可能是其他类的对象。 内联在早起的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为 内联 (inlining)。 例如，内联调用 e.getName() 会被替换为访问字段 e.name。 这是一项很有意义的改进，CPU 在处理当前指令时，分支会扰乱预取指令的策略，所以，CPU 不喜欢分支。然而，如果 getName 在另外一个类中 被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。 幸运的是，虚拟机中的 即时编译器 (JIT) 比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出是否有类确实覆盖了给定的方法。 如果方法很短、被频繁调用而且确实没有被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而这个子类覆盖了一个内联方法，那么优化器将取消对这个方法的内联。这个过程很慢，不过很少会发生这种情况。 抽象类在类的自下而上的继承层次结构中，位于上层的类更具有一般性，也更加抽象。从某种角度看，祖先类更具有一般性，人们通常只是将它作为派生其他类的基类，而不是用来构造你想使用的特定的实例。 考虑一个 Person 类的继承结构： 每个人都有一些属性，如名字。学生与员工都有名字。 现在，假设需要增加一个 getDescription() 的方法，它返回对一个人简短的描述，学生类可以返回：一个计算机在读的学生，员工可以返回 一个在阿里就职的后端工程师 之类的。这在 Student 和 Employee 类中实现很容易，但是在 Person 类中应该提供什么内容呢？ 除了姓名，Person 类对这个人一无所知。 有一个更好的方法，就是使用 abstract 关键字，把该方法定义为一个 抽象方法，这意味着你并不需要实现这个方法，只需要定义出来就好了：(以下代码为 Person 类中的抽象定义) public abstract String getDescription() {} 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的： public abstract class Person { ... public abstract String getDescription() {} ... } 《阿里Java开发规范》强制规定抽象类命名 使用 Abstract 或 Base 开头，这里只是做演示所以就简单用 Person 代替啦~ 抽象方法充当着占位方法的角色，它们在子类中被继承并实现。 扩展抽象类可以由两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未实现，这样就必须将子类标记为抽象类 (因为还有抽象方法)；另一种做法就是实现全部方法，这样一来，子类就不是抽象的了。 (即使不包含抽象方法，也可以将类声明为抽象类) 抽象类不能实例化，也就是说，如果将一个类声明为 abstract，就不能创建这个类的实例，例如：new Person(); 就是错误的，但可以创建具体子类的对象：Person p = new Student(args);，这里的 p 是一个抽象类型 Person 的变量，它引用了一个非抽象子类 Student 的实例。 Part 4. 为什么不推荐使用继承？先别急着奇怪和愤懑，刚学习完继承之后，就告诉说不推荐使用，这是 有原因的！ 在面向对象编程中，有一条非常经典的设计原则：组合优于继承。使用继承有什么问题？组合相比继承有哪些优势？如何判断该用组合还是继承？下面我们就围绕这三个问题，来详细讲解一下。 以下内容大部分引用自：https://time.geekbang.org/column/article/169593 使用继承有什么问题？上面说到，继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。我们通过一个例子来说明一下。 假设我们要设计一个关于鸟的类，我们将 “鸟类” 这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。 我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写 (override) fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示： public class AbstractBird { //...省略其他属性和方法... public void fly() { //... } } public class Ostrich extends AbstractBird { //鸵鸟 //...省略其他属性和方法... public void fly() { throw new UnSupportedMethodException(\"I can't fly.'\"); } } 这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。 这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则 (Least Knowledge Principle，也叫最少知识原则或者迪米特法则)，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。 你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示： 从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们关注更多的问题，例如 “鸟会不会叫”、”鸟会不会下单“ 等… 那这个时候，我们又该如何设计类之间的继承关系呢？ 总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？ 组合相比继承有哪些优势？实际上，我们可以利用组合 (composition)*、接口、委托 *(delegation) 三个技术手段，一块儿来解决刚刚继承存在的问题。 我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口 (相当于定义某一种行为，下方会有代码说明)，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子： public interface Flyable { void fly(); } public interface Tweetable { void tweet(); } public interface EggLayable { void layEgg(); } public class Ostrich implements Tweetable, EggLayable {//鸵鸟 //... 省略其他属性和方法... @Override public void tweet() { //... } @Override public void layEgg() { //... } } public class Sparrow impelents Flayable, Tweetable, EggLayable {//麻雀 //... 省略其他属性和方法... @Override public void fly() { //... } @Override public void tweet() { //... } @Override public void layEgg() { //... } } 不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？ 我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过 组合和委托 技术来消除代码重复。具体的代码实现如下所示： public interface Flyable { void fly()； } public class FlyAbility implements Flyable { @Override public void fly() { //... } } //省略Tweetable/TweetAbility/EggLayable/EggLayAbility public class Ostrich implements Tweetable, EggLayable {//鸵鸟 private TweetAbility tweetAbility = new TweetAbility(); //组合 private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 //... 省略其他属性和方法... @Override public void tweet() { tweetAbility.tweet(); // 委托 } @Override public void layEgg() { eggLayAbility.layEgg(); // 委托 } } 当然啦，也可以使用 JDK 1.8 之后支持的接口默认方法： public interface Flyable { default void fly() { // fly的 的默认实现 } } 我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如： is-a 关系，我们可以通过组合和接口的 has-a 关系来替代； 多态特性我们可以利用接口来实现； 代码复用我们可以通过组合和委托来实现； 所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。 如何判断该用组合还是继承？尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。 如果类之间的继承结构稳定 (不会轻易改变)，继承层次比较浅 *(比如，最多有两层继承关系)，继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。 除此之外，还有一些 设计模式 会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了 组合关系，而 模板模式（template pattern）使用了 继承关系。 前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系 (既不是父子关系，也不是兄弟关系)。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示： public class Url { //...省略属性和方法 } public class Crawler { private Url url; // 组合 public Crawler() { this.url = new Url(); } //... } public class PageAnalyzer { private Url url; // 组合 public PageAnalyzer() { this.url = new Url(); } //.. } 还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。 public class FeignClient { // Feign Client框架代码 //...省略其他代码... public void encode(String url) { //... } } public void demofunction(FeignClient feignClient) { //... feignClient.encode(url); //... } public class CustomizedFeignClient extends FeignClient { @Override public void encode(String url) { //...重写encode的实现...} } // 调用 FeignClient client = new CustomizedFeignClient(); demofunction(client); 尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以 “多用组合少用继承” 这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。 要点回顾 继承概述 / 单继承 / is-a 关系 / 类之间的关系 / 层级结构； 继承的实现 / 覆盖方法 / protedcted / 向上转型； Object 类 / 方法调用 / final / 内联 / 为什么不推荐使用继承； 练习暂无； 参考资料 《Java 核心技术 卷 I》 《Java 编程思想》 《码出高效 Java 开发手册》 设计模式之美 - 为何说要多用组合少用继承？如何决定该用组合还是继承？ - https://time.geekbang.org/column/article/169593 Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html#part02 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 4：面向对象基础","slug":"「MoreThanJava」Day-4：面向对象基础","date":"2020-08-04T04:03:00.000Z","updated":"2020-12-09T04:39:23.741Z","comments":true,"path":"2020/08/04/morethanjava-day-4-mian-xiang-dui-xiang-ji-chu/","link":"","permalink":"http://www.wmyskxz.com/2020/08/04/morethanjava-day-4-mian-xiang-dui-xiang-ji-chu/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 面向对象设计概述 面向对象程序设计 (Object-Oriented Programming, OOP) 是当今主流的程序设计范型，它取代了 20 世纪 70 年代的 “结构化” 或过程式编程技术。由于 Java 是面向对象的，所以必须熟悉 OOP 才能够很好地使用 Java。 了解抽象抽象的作用是将复杂的机制隐藏在一个对象中，仅保留我们与之交互所必须的信息。 为了说明这一点，我们可以想象平时使用 「电梯」 的场景。 如果您在办公楼工作，这可能是您日常工作的一部分。你按下向上或向下按钮，然后等待门滑开。完成操作后，您进入一个 “盒子”，该 “盒子” 的一面墙上有一个按钮面板，然后按下所需的按钮。当电梯到达您要去到的楼层后，您会挤过其他人然后走出去。 要使用电梯，您只需要了解如何按下正确的按钮就可以达到目的。 而隐藏在电梯背后的支持它工作的一系列东西 —— 滑轮系统、机械、电线、减震器、安全系统等等… 您可以完全不知道也完全不必操心… 电梯这个 “铁盒子” 以及相应的按钮面板，就是对整个「运输系统」成功的抽象 (事实上电梯背后还包含检修、维护等一系列事情…)，它隐藏了足够多的细节，也极大地方便了我们的生活。 什么是对象简单来说，对象是对现实世界的抽象。 (例如上方对整个运输系统抽象之后，就得到了「电梯」这个对象…) 什么东西是对象？什么东西不是对象？这是一个困扰哲学家数千年的问题。勒内·笛卡尔 (17世纪的哲学家) 观察到，人类是用面向对象的方式看待世界的 (例如与电梯的交互)。人类的大脑会从对象的角度认识世界 (例如鸟类、鱼类)，我们的思想和记忆也被组织成物体和它们之间的关系 (例如，鸟吃虫)。 对象像是一种模板亚里士多德大概是第一个深入研究 类型 (type) 的哲学家，它曾经提出过 鱼类 和 鸟类 这样的概念。所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。 这就好像我们拿着一个模具，我们可以使用该模具制作出各种各样东西，每个东西都有自己的 “个性”，但它们又都遵循一些相同的基本模式： 对象的特征我们可以把你的「银行账户」抽象成一个对象，但它不是由物质构成的。(虽然您和银行可以使用纸张和其他材料来记录您的账户，但您的账户独立于这些材料而存在。) 虽然它不是物质的，但你的账户是有 属性 的 (余额、利率、持有者等..)，你可以对它做一些事情 (存款、取款、查看余额等..,)，它自己也可以做一些事情 (交易收费、积累利息等…)。 这足够清楚吧。事实上，这些特征它们都有名字： 对象具有 标识 identity；(每个对象都是独立的个体) 对象具有 状态 state；(它具有各种可能会改变的属性) 对象具有 行为 behavior；(它可以做事情，也可以让别人对它做事情) 这就是对一个物体的一般描述。(上面的列表来自于 1994 年 Grady Booch/Addison-Wesley 出版的《面向对象分析与设计》一书。) 当你开始编写面向对象的软件时，你会发现这个列表将帮助你决定你的对象应该是什么样。 编程语言中的抽象过程所有编程语言都提供抽象机制。可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。 所谓的 “类型” 是指 “所抽象的是什么？”。 汇编语言是对底层机器语言的轻微抽象，接着出现的许多 “命令式” 语言 (如 FORTRAN、BASIC、C 等..) 都是对汇编语言的进一步抽象。 这些语言在汇编语言基础上有了很大幅度的改进，但是它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。 传统的结构化程序设计通过设计一系列的过程 (即算法) 来求解问题。一旦确定了这些过程，就要开始考虑存储数据的适当方式。 这就是 Pascal 语言的设计者 Niklaus Wirth 将其著作命名为《算法 + 数据结构 = 程序》(Algorithms + Data Structures = Programs, Prentice Hall, 1975) 的原因。 需要注意的是，在 Wirth 的这个书名中，算法是第一位的，数据结构是第二位的，这就明确的表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据的结构，以便于操作数据。 而 OOP 却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。(在 OOP 中，也有说法是：程序 = 对象 + 交互) 这使得程序员必须建立起在 机器模型 (位于 “解空间” 内，这是你对问题建模的地方，例如计算机) 和 实际需要解决问题的模型 (位于 “问题空间” 内，这是问题存在的地方，例如一项业务) 之间的 关联。 建立这种映射是费力的，而且这不属于编程语言固有的功能，这使得程序难以编写，并且维护代价高昂，同时也产生了作为副产物的整个 “编程方法” 行业。 面向对象思想的突破另一种对机器建模的方式就是针对待解问题建模。 早期的编程语言，例如 LISP 和 APL，都是选择一些特定的视角来 “解释世界” (分别敌营 “所有问题最终都是列表” 或者 “所有问题都是算法形式的”)。PROLOG 则将所有问题都转换成决策链。此外还产生了基于约束条件编程的语言和专门通过对图形符号操作来实现编程的语言 (后来被证明限制性过强)。 这些方式对于它们本身所要解决的 特定类型的问题 都是不错的解决方案，但是一旦 超出 其特定领域，它们就力不从心了。 面向对象的方式通过向程序员提供表示问题空间中的元素的工具而更近了一步。 这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。我们把问题空间中的一些基本元素进一步抽象成解空间中的 “对象”。这种思想的实质是：程序可以通过添加新类型的对象使其自身适用于某个特定的问题。 因此，当你在阅读描述解决方案的代码的同时，也是在阅读问题的表述。相比之前的语言，这是一种更灵活和更强力的语言抽象。所以，OOP 允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。 面向对象软件的最重要的突破之一就是允许我们按照 自然的面向对象的大脑思维方式相匹配的方式组织软件。我们希望使用具有属性并能够与其他对象进行交互的对象，而不是直接使用更改主存储器中的 bit 数据的机器指令。当然，在机器层面上什么也没有改变——bit 数据仍是由机器指令操作的，但至少我们不用再考虑机器指令了！ 对于一些规模较小的问题，将其分解为过程的开发方式比较理想。面向对象更加适合解决规模较大的问题。要想实现一个简单的 Web 浏览器可能需要大约 2000 个过程，这些过程可能需要对一组全局数据进行操作。 采用面向对象的设计风格，可能只需要大约 100 个类，每个类平均包含 20 个方法。这明显易于程序员掌握，也容易找到 BUG。(假设给定对象的数据出错了，在访问这个数据项的 20 个方法中查找错误要比在 2000 个过程中查找要容易多了) OOP 的起源正如我们上面描述的那样，面向对象的编程是当今不可回避的。让我们来看看它是如何变成现实的。 时间回到上世纪 60 年代，那个时候计算机图形还不存在。当时，美国计算机科学家 Ivan Edward Sutherland 实现了能够绘图的应用程序，名叫：SketchPad。 它是专门为设计人员开发的，它允许设计人员使用手写笔通过计算机绘制简单的几何形状，例如三角形、正方形、圆形等。该项目也是 计算机辅助设计 CAD 的起点。 这成为了面向对象编程的 奠基典范 之一。 因为在 Ivan 的程序设计中，使用了我们现在称为 “对象” 的表现形式来描述现实生活中的几何图形，这些图形对于设计人员来说是完全可以理解的！ 这其中没有无穷无尽的变量和函数，而是通过具体的几何图形 (对象形式) 来描述 (包括上下文数据，都存储在变量中) 和操作 (函数实现) 进行分组，并以一种关系进行管理这些特定的元素。 这些东西在现在都有确切的名称。(分别对应 “属性” 和 “方法”) OOP 的规范化Ivan 的项目和其他一些项目在 1967 年影响了 Simula 编程语言。该语言第一次直接将面向对象的思想引入到了 编程语言中 (重大更新之后被称为 Simula-67)。 1970 年代，Xerox (负责鼠标和图形界面的发明) 在个人电脑上工作。他们希望通过操纵 GUI 和鼠标来创建任何人都可以轻松使用的计算机。 为了表示屏幕上的所有元素并支持其显示和操作的逻辑，由艾伦·凯 (Alan Kay) 领导的团队创建了 SmallTalk 语言，该语言的灵感来自 Simula。根据许多资料显示，这标志着我们今天使用的面向对象编程概念的正式确立！ OOP 的普及化上述这些方法在 1981 年开始流行，并成为了伟大的面向对象语言的起点，例如： Objective-C 是 iOS 本机开发的原始语言。从那以后，Apple 对其进行了改进和增强，它仍然是 iOS 开发人员的常见选择。 C ++ 是 C 编程语言的面向对象版本。C 和 C++ 仍被广泛使用，尤其是在非常专业的行业中。 如我们所见，在编程方面取得了令人难以置信的进步，这是对以下问题的解决方案：简化软件开发！ 面向对象设计的特殊效率从何而来？ 部分影响来自于更清晰的表达复杂系统的方式； 也许最重要的原因 （也是从操作系统体系结构派生而来的） 是，当您给某人一个结构时，您很少希望他们拥有无限的特权。仅仅进行类型匹配甚至还不能满足需求。保护某些对象而不保护某些对象也不是非常合理有用。 正确执行封装不仅是对状态抽象的承诺，而且是消除编程中面向状态的隐喻的一种承诺。 Part 2. 类与对象概述 图片来源：https://javatutorial.net/java-oop 简单的说，类是对象的蓝图或模板，而对象是类的实例。 这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。 在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类 (型)*。当我们把一大堆拥有共同特征的对象的静态特征 *(属性) 和动态特征 (行为) 都抽取出来后，就可以定义出一个叫做 “类” 的东西。 定义类使用类几乎可以模拟任何东西。假设我们要编写一个表示小狗 Dog 的简单类 —— 它表示的不是特定的小狗，而是任何小狗。 对于大多数宠物狗，我们都知道些什么呢？—— 它们都有名字和年龄，还会叫、会吃东西。由于大多数的小狗都具备上述两项信息 (名字和年龄) 和两种行为 (叫和吃东西)，所以我们的 Dog 类将包含它们，这个类看上去会是这样： 代码实现起来大概会像这样： public class Dog { // 参数 private String name; private Integer age; // 构造器 public Dog(String name, Integer age) { this.name = name; this.age = age; } // 字段访问器 public String getName() { return name; } // 字段访问器 public Integer getAge() { return age; } // 方法 - 叫 void bark() { System.out.println(\"汪汪汪！\"); } // 方法 - 吃东西 void eat() { System.out.println(\"一只\" + age + \"岁大的名叫 \" + name + \" 的狗正在吃东西！\"); } } 剖析 Dog 类下面各个部分我们将对上面描述的 Dog 类进行剖析。首先从这个类的方法开始吧，上述源码我们看到，这个类包含一个构造器和四个方法： public Dog(String name, Integer age) public String getName() public Integer getAge() public void bark() public void eat() 这个类的所有方法都被标记为 public。关键字 public 意味着任何类的任何方法都可以调用这些方法 (共有四种访问级别，将在之后介绍到) 接下来，还需要注意 Dog 类实例中有 2 个实例字段用来存放将要操作的数据： private String name; private Integer age; 关键字 private 确保只有 Dog 类自身的方法能够访问到这些实例字段，而其他类的方法不能够读写这些字段。(这也是 Private 私有本身的含义) 注意：虽然可以用 public 标记实例字段，但这是一种很不好的做法。public 修饰数据字段后，程序中的任何方法都可以对其进行读取和修改，这就完全破坏了 封装。(这会使程序非常不可控) 强烈建议将实力字段标记为 private 最后，请注意，这两个实例字段本身也是对象：name 字段是 String 类型的对象，age 是 Integer 类型的对象。这种情况十分常见：类包含的实例字段通常属于某个类类型。 从构造器开始这个与类名相同且权限为 public 的方法 Dog() 我们把它称为 构造器，让我们来看看它： public Dog(String name, Integer age) { this.name = name; this.age = age; } 在构造 Dog 类对象的时候，构造器会运行，从而将实例字段初始化为所希望的初始状态。 例如，当时用下面这条代码创建 Dog 类时： new Dog(\"大黄\", 1) 将会把数据设置为： name = \"大黄\" age = 1 构造器与其他方法有一个重要的不同。构造器总是结合 new 关键字来调用。不能对一个已经存在的对象调用构造器来达到重新设置属性的目的。例如 (下方代码将产生编译错误)： dogInstance.Dog(\"小黄\", 2); // ERROR 有关构造器还有很多可以说的地方，现在只需要记住： 构造器与类同名； 每个类可以有一个以上的构造器； 构造器可以有 0 个、1 个或多个参数； 构造器没有返回值； 构造器总是伴随着 new 操作符一起调用。 封装的优点最后仔细看一下非常简单的 getName/getAge 方法。 public String getName() { return name; } public Integer getAge() { return age; } 这些都是典型的访问器方法。由于它们只返回实例字段值，因此又称为 字段访问器。 如果将 name、age 字段标记为 public，允许任意方法访问，而不是编写单独的访问其方法，难道不是更容易一些嘛？ 上面的例子似乎并不明显 (而且 name 还是一个只读字段)，所以为了说明这一点，我们来举一个更加有趣的例子。 假设我们有两个类，男人正在辛苦挣钱并时不时地查看余额，而此时来了一个小偷，专门偷男人的钱，逮着一个偷一个，而被偷了之后男人抓到了小偷，此时由于小偷的钱是私有的，男人抓着小偷咬牙切齿却没有丝毫办法可以把钱拿回来！ 封装不仅仅帮助我们提高安全性，更可以简化操作和提高 内聚性。 假设你写了一个很庞大的系统，一开始你的定义是这样的： public int age; 你的程序里大概有 100 条类似于这样的语句： instance.age = 10; 此时突然要求你把数据类型变一下或者对这个字段其他一些什么统一的处理，需要修改 100 处的你，是不是傻了？ 封装的另一个好处是模块化。这方便我们把散落在各处的代码收拢并做统一的处理。 设计模式器大原则之一的 迪米特法则 就是对于封装的具体要求，即 A 模块使用 B 模块的某个接口行为，对 B 模块中除此行为之外的其他信息知道得尽可能少。 比如：耳塞的插孔就是提供声音输出的行为接口，只需要关心这个插孔是否有相应的耳塞标记，是否是圆形，有没有声音即可，至于内部 CPU 如何运算音频信息，以及各个电容如何协同工作，根本不需要关注，这使得模块之间的协作只需忠于接口、忠于功能实现即可。 创建和使用类定义了 class 只是定义了对象模板，而要根据模板创建出真正的对象实例，必须使用 new 关键字，并调用对象的构造函数才行： Dog dog = new Dog(\"大黄\", 1); 上述代码创建了一个 Dog 类型的实例，并通过变量 dog 指向它。(下面我们将详细说明是怎么 “指向” 它的…) 第一个 Dog 表明了 dog 变量的类型，第二个 Dog 则是调用了 Dog 类的构造函数。在 Java 10 中，如果可以从变量的初始值推导出它们的类型，那么可以用 var 关键字来声明局部变量，而无须指定类型。例如： var dog = new Dog(\"大黄\", 1); 这一点很好，因为可以避免重复写类型名 Dog。但是参数和字段的类型还是必须显式地声明，该用法仅能用于方法中的局部变量。 要想使用类中公用方法，我们可以直接使用 . (英文句号) 来连接类中的方法并调用： dog.eat(); // 调用该实例的 eat() 方法 Java 使用引用来操纵对象每种编程语言都有自己的操纵内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示 (例如 C 和 C++ 里的指针) 来操纵对象？ 在 Java 中一切都被视为对象，这使得我们可以使用固定的语法。尽管这一切都看作对象，但操纵的标识符 (例如上面的 dog 变量) 实际上是 对象的一个 “引用” (reference)。 只要握住这个遥控器，就能保持与电视机的连接。当有人想改变频道或减小音量时，实际操纵的是遥控器 (引用)，再由控制器来调控电视机 (对象)。 如果想在房间里四处走走，同时仍能调控电视机，那么只需要携带遥控器就可以了，而不是背着电视机… 此外，即使没有电视机，遥控器也可以独立存在。 也就是说，你拥有一个引用，并不一定需要有一个对象与它关联。因此，如果你想操纵一个词或者一个句子，则可以创建一个 String 对象： String s; 但是这里创建的只是引用，并不是对象。如果此时向 s 发送一个消息，就会返回一个运行时错误。这是因为此时 s 实际上没有与任何事物相关联 (即没有电视机)。 因此，一种安全的做法是：创建一个引用的同时便进行初始化。 String s = \"abcd\"; 这里运用到了 Java 语言的一个特性：字符串可以直接使用带引号的文本进行初始化 (其他对象需要使用 new)。 null 引用上面我们已经了解到，一个对象变量包含一个对象的引用。当引用没有关联对象时，实际上指向了一个特殊的值 null，这表示它没有引用任何对象。(可以理解为 String s; 等同于 String s = null;) 听上去这是一种处理特殊情况的便捷机制，如未知的名字。但使用 null 值需要非常小心！如果对 null 值应用一个方法，那么就会产生一个 NullPointException 异常。 String s = null; System.out.println(s.length()); // NullPointException 这是一个很严重的错误！如果你的程序没有 “捕获” (理解为手动检测和处理) 异常，程序就会终止！正常情况下，程序并不会捕获这些异常，而是依赖于程序员从一开始就不要带来异常。(这显然很难..) 定义一个类时，最好清楚的知道哪些字段可能为 null。在我们的例子中 (Dog 类)，我们不希望 name 和 age 字段为 null。 对此我们有两种解决方法。 “宽容型” 方法 是把 null 参数转换为一个适当的非 null 值： if (n == null) { name = \"unknow\"; } else { name = n; } 在 Java 9 中，Objects 类 (JDK 自带的工具类) 对此提供了一个便利方法： name = Objects.requireNonNullElse(n, \"unknow\"); // 效果与上面代码等同 “严格型” 方法 则是干脆拒绝 null 参数： name = Objects.requireNonNull(n, \"The name cannot be null!\"); 如果把上述代码添加进 Dog 类的构造函数，并且有人用 null 名字构造了一个 Dog 类，就会产生一个 NullPointerException 异常。乍看上去，这种做法似乎不太好，但有以下几个好处： 异常报告会提供这个问题的描述；(也就是 The name cannot be null!) 异常报告会准确地支出问题所在的位置，否则异常可能在其他地方出现，而很难追踪到真正导致问题的这个构造器参数； Part 3. 面向对象的四大特性 图片来源：https://flashgene.com/archives/51547.html 面向对象有三大特性：封装、继承、多态。有的地方支持把 “抽象” 也归纳进来，合并称为面向对象的四大特性。我觉得也无可厚非。 (关于继承和多态会在后续章节里面详细说明, 这里只作简单描述用于简单理解..) 抽象抽象是面相对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装、继承、多态的基础，是软件大厦的基石。(上面有专门的一节描述，这里不再展开) 封装正如我们上面 男人与小偷 的例子，封装不仅能提高我们的安全性、帮助我们把实现细节隐藏起来，还是一种对象功能内聚的表现形式，这有助于让模块之间的耦合度变低，也更具有维护性。(封装的优点上方有介绍，这里也不再展开) 封装使面向对象的世界变得单纯，对象之间的关系变得简单，”自扫门前雪” 就行了。特别是当今智能化的时代，对封装的要求越来越高了，例如 小爱同学 好了，对外的唯一接口就是语音输入，隐藏了指令内部的细节实现和相关数据，这大大降低了使用成本，也有效地保护了内部数据安全。 继承继承允许创建 具有逻辑等级结构的类体系，形成一个继承树。就拿我们上面创建的 Dog 类来说明吧，不是只有狗拥有那些属性和方法，猫也有！(可能猫叫不能用 bark 表示，但本质都是叫) 自然界中，有许多动物 (动物是对这些生物的自然抽象) 都有这样的行为，那么好了，我们往上再抽象一个 Animal 对象： 只要继承自 Animal 类，那么就会拥有 Animal 这个父类所描述的属性和方法 (子类当然可以有自己的实现，这一点我们在后续章节中详细描述)。这让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用。 继承把枯燥的代码世界变得更有层次感，更具有扩展性，为多态打下了语法基础。 不过继承也有几个 缺点： 继承是一种 强耦合 的关系，父类如果做出一定改变，那么子类也必然会改变； 继承 破坏了封装，对于子类而言，它的实现对子类来说都是透明的； 多态多态是以上述的三个面向对象特征为基础，根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式。 太学术化了一点，举个例子可能明白点。比如，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作 (方法)，对于不同温度的水 (运行时不同的对象类型)，就会得到不同的结果，这就是多态。 自然界中最典型的例子就是碳家族。如果你告诉你的女朋友将在她的生日晚会上送她一块碳，女朋友当然不高兴了，可事实上却是 5 克拉的钻石。钻石就是碳元素在不断进化过程中的一种多态表现。 严格意义来说，多态并不是面向对象的一种特质，而是一种由继承行为衍生而来的进化能力而已。 (完) 要点回顾 类和对象 - 什么是类 / 什么是对象 / OOP 起源和发展 / 面向对象其他相关概念 定义类 - 基本结构 / 属性和方法 / 构造器 使用对象 - 创建对象 / 给对象发消息 面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态的简单介绍 基础练习 - 定义 Dog 类 / 定义时钟类 / 定义图形类 (下方) 练习练习 1：定义一个类描述数字时钟参考答案： public class Clock { private Integer hour; private Integer minute; private Integer second; public Clock(Integer hour, Integer minute, Integer second) { this.hour = hour; this.minute = minute; this.second = second; } /** * 时钟走字(走1s) */ public void run() { second += 1; if (second.equals(60)) { second = 0; minute += 1; if (minute.equals(60)) { minute = 0; hour += 1; if (hour.equals(24)) { hour = 0; } } } } /** * 显示当前时间 * @return */ public String showCurrentTime() { return String.format(\"当前时间是：%d时:%d分:%d秒\", hour, minute, second); } /** * 内部测试 * @throws InterruptedException - 使用 Thread.sleep() 需要手动检测该异常, 这里节约篇幅直接抛出 */ public static void main(String[] args) throws InterruptedException { Clock clock = new Clock(23, 59, 58); while (true) { clock.run(); System.out.println(clock.showCurrentTime()); // 让当前线程睡 1s Thread.sleep(1000); } } } 练习 2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法参考答案： public class Point { private Integer x; private Integer y; public Point() { this.x = 0; this.y = 0; } public Point(Integer x, Integer y) { this.x = x; this.y = y; } /** * 移动到指定位置 */ public void moveTo(Integer x, Integer y) { this.x = x; this.y = y; } /** * 移动指定的距离 */ public void moveBy(Integer dx, Integer dy) { this.x += dx; this.y += dy; } /** * 计算并返回与另一个点的距离 */ public Double distanceTo(Point other) { int dx = this.x - other.x; int dy = this.y - other.y; return Math.sqrt(dx ^ 2 + dy ^ 2); } /** * 当前的坐标信息 */ public String currentLocation() { return String.format(\"当前点横坐标：%d，纵坐标：%d\", x, y); } /** * 内部测试 */ public static void main(String[] args) { Point point1 = new Point(3, 5); Point point2 = new Point(); System.out.println(point1.currentLocation()); System.out.println(point2.currentLocation()); point2.moveTo(-1, 2); System.out.println(point2.currentLocation()); System.out.println(point1.distanceTo(point2)); } } 参考资料 《Java 核心技术 卷 I》 《Java 编程思想》 《码出高效 Java 开发手册》 Deepen your knowledge by learning Object Oriented Programming (OOP) with Swift - https://openclassrooms.com/en/courses/4542221-deepen-your-knowledge-by-learning-object-oriented-programming-oop-with-swift Think like a computer: the logic of programming - https://openclassrooms.com/en/courses/5261196-think-like-a-computer-the-logic-of-programming Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html#part02 Python 100 天从新手到大师 - https://github.com/jackfrued/Python-100-Days 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"【好文推荐】黑莓OS手册是如何详细阐述底层的进程和线程模型的？","slug":"【好文推荐】黑莓OS手册是如何详细阐述底层的进程和线程模型的？","date":"2020-07-31T09:12:00.000Z","updated":"2020-12-09T04:42:13.371Z","comments":true,"path":"2020/07/31/hao-wen-tui-jian-hei-mei-os-shou-ce-shi-ru-he-xiang-xi-chan-shu-di-ceng-de-jin-cheng-he-xian-cheng-mo-xing-de/","link":"","permalink":"http://www.wmyskxz.com/2020/07/31/hao-wen-tui-jian-hei-mei-os-shou-ce-shi-ru-he-xiang-xi-chan-shu-di-ceng-de-jin-cheng-he-xian-cheng-mo-xing-de/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 写在前面该文章的大部分内容都是翻译自是黑莓 10 实时操作系统 QNX Neutrino 的开发手册，该手册不仅详细地阐述了 BlackBerry 10 OS 的原理以及 OS 的体系结构，还描述了其 QNX Neutrino 微内核的详细信息 (包括进程线程、多和处理、网络架构、文件系统等…非常完整..)。 我阅读了其中「描述进程和线程」的精华部分，觉得写的非常不错，特意翻译 (主要靠有道和 Google 翻译) 跟大家分享一下 (部分内容有改动)。 手册中详细描述了许多关于 Linux 函数调用涉及底层方面的细节，在本文中我大都没有贴出来，感兴趣的朋友强烈建议去拜读一下原文！ 原文地址：https://developer.blackberry.com/native/documentation/dev/rtos/arch/about_system_architecture.html Part 1. 进程和线程基础在我们开始讨论线程、进程、时间片和所有其他的精彩的概念之前，让我们先来建立一个类比。 我要做的首先是 说明线程和进程是如何工作的。我能想到的最好的方法 (不涉及实时系统的设计) 是在某种情况下想象我们的线程和进程。 进程就像一栋房子 房子实际上是 具有某些属性的容器 (例如卧室数量、占地面积、区域划分等)。 如果您以这个角度来看，房子实际上并不会主动做任何事情————它是一个 被动的对象。这实际上就是进程干的事情了 (充当容器)。 线程就像是居住者 居住在房子里面的人是 活动的对象，他们可以使用各种房间，看电视、做饭、洗澡等等等… 单线程如果您独居过，那么您就会知道————您可以在家里的任何时间做您任何想做的事，因为家里面没有其他人，您只要遵从内心的规则就好。 多线程如果在您的房子中再另外添加一个人，情况将发生巨变。 假设您结婚了，那么现在您的家里住着您和您的配偶。因此您不能在 任何时间 都能够使用厕所，因为您需要首先确保您的配合不在其中！ 如果您有两个 负责任的成年人 居住在房屋中，那么通常您可以在 「安全性」 这一块儿稍微放松一些 (因为您知道另一个成年人会尊重您的空间，不会试图故意在厨房放火之类的..)。 但是，如果把几个 熊孩子 混在一起，事情就会变得更加有趣了… 说回进程和线程就像是房屋占用土地一样，进程也要占用内存。 也正如房屋拥有者可以随意进入他们想去的任何房间一样，进程中的线程也 都拥有 对该内存区域访问的权限。 如果某个线程被分配了某些东西 (例如哥哥进程出去买了游戏机🎮回家)，那么其他所有线程都可以立即访问它 (因为它存在于公共地址空间中————都在房子里)。 同样，如果给进程分配额外多的一块空间，则新的区域也能够用于所有线程。 这里的窍门在于识别内存是否应该对进程中的所有线程可用。 如果是，那么您将需要让所有线程同步它们对其的访问。 如果不是，那么我们将假定它只能用于某个特定的线程 (在这种情况下，因为只有特定线程能够访问它，我们可以在假设线程不会自己把自己玩儿坏的前提下，不需要同步操作)。 从日常的生活中我们知道，事情并不是那么简单。 现在我们已经了解了基本特征 (所有内容都是共享的)，下面我们来深入探究一下事情变得有趣的地方以及原因。 下图显示了我们表示线程和进程的方式。进程是一个圆圈，代表“容器”概念（地址空间），三个长方形是线程。在本文中，您将看到类似这样的图。 互斥在生活中，如果您想洗个澡，并且已经有人在洗手间了，您将不得不等待。线程又是如何处理的呢？ 这是通过一种叫做 互斥 (mutual exclusion) 的操作完成的。和你想的差不多——当涉及到 特定资源 时，许多线程是互斥的。 当你想要独占浴室洗澡时，你通常会走进浴室，从里面锁上门。任何想要上厕所的人都会被锁挡住。当你洗完之后，你会打开门，允许其他人进入。 这就是线程的作用。一个线程使用一个叫做 互斥锁 (mutex) 的对象 (互斥锁 MUTual EXclusion 的首字母缩写)。这个对象就像门上的锁 —— 一旦一个线程锁定了互斥锁，其他线程就不能获得该互斥锁，直到拥有它的线程释放它。就像门锁一样，等待获得互斥锁的线程将被阻挡。 互斥锁和门锁的另一个有趣的相似之处是，互斥锁实际上是一种 “建议” 锁 (“advisory” lock)。如果一个线程不遵守使用互斥锁的约定，那么保护就没有用了。在我们的房子比喻中，这就像有人不顾门和锁的惯例，从一堵墙闯进盥洗室。 优先级如果卫生间现在上锁了，有很多人在等着使用怎么办？显然，所有人都坐在外面，等着洗手间里的人出来。 真正的问题是：当门打开时会发生什么?谁下一个去? 你会想，让等待时间最长的人下一个走或许是 “公平的”。又或者，让年龄最大的人排在第二位也可能是 “公平的”。有很多方法可以确定什么是“公平”。 我们通过两个因素来解决这个问题：优先级 和 等待的时长。 假设两个人同时出现在锁着的浴室门口。其中一个有一个有急事 (例如：他们开会已经迟到了…)，而另一个没有。让那个有急事的人去做下一个，不是很有意义吗？ 当然！问题的关键是你如何决定谁更 “重要”。 这可以通过分配优先级来实现 (我们可以使用数字，例如 1 是最低的可用优先级，255 是这个版本的最高优先级)。房子中那些有急事的人将被给予更高的优先权，而那些没有急事的人将被给予较低的优先权。 线程也是一样。线程从父线程继承自己的调度算法，但是可以调用 Linux 系统函数 pthread_setschedparam() 来更改自己的调度策略和优先级 (如果它有权限这么做的话)。 如果有很多线程在等待，并且互斥锁被解锁，我们将把互斥锁给优先级最高的等待线程。但是，假设两个人有相同的优先级。现在该做什么呢？ 好吧，在这种情况下，让等待时间最长的人下一个去才是 “公平的”。这不仅是“公平的”，也是内核实际所做的。在有一堆线程等待的情况下，我们主要根据优先级，其次是等待的长度。 互斥锁当然不是我们将遇到的唯一 同步对象。让我们看看其他一些例子。 信号量让我们从浴室转到厨房，因为那里是一个社会认可的可以同时容纳一个人以上的地方。在厨房里，你可能不想让每个人都同时待在那里。事实上，你可能想要限制厨房里的人数 (厨师太多等等…)。 假设你不希望同时有 超过两个人 在里面，这可以使用互斥锁来实现吗？这对于我们的类比来说是一个非常有趣的问题。让我们稍微讨论一下。 计数为 1 的信号量在上面类比的卫生间的例子中，可以有两种情况，并且两种状态相互关联: 门没锁，房间里没人； 门锁了，房间里有人； 这里并没有其他可能的组合 —— 房间里没有人的时候门不能锁上 (我们怎么能打开它?)，房间里有人的时候门也不能打开 (他们怎么能保证自己的隐私呢?)。这是一个计数为 1 的信号量示例：房间中最多只能有一个人，或者有一个线程使用该信号量。 这里的关键是我们描述锁的方式。 在你典型的浴室锁里，你只能从里面上锁和解锁 (没有可以从外部访问的锁)。实际上，这意味着互斥锁的所有权是一个原子操作 —— 在你获得互斥锁的过程中，其他线程不可能获得它，结果就是一个线程进入 “厨房” 上锁，导致另一个线程将无法进入。在我们用房子来比喻的故事里，这一点就不那么明显了，因为人类比 1 和 0 聪明得多。 很显然，我们厨房需要的是一种不同类型的锁。 计数大于 1 的信号量假设我们在厨房安装了传统的基于钥匙的锁。这把锁的工作原理是，如果你有一把钥匙，你就可以开门进去。任何使用这把锁的人都同意，当他们进入内部时，他们将立即从内部锁门，这样，任何在外部的人都将始终需要一把钥匙。 好了，现在控制我们想要多少人在厨房就变成一件简单的事情了 —— 把两把钥匙挂在门外！厨房总是锁着。当有人想进厨房时，他们要看是否有钥匙挂在门外。如果是的话，他们就把它带在身边，打开厨房的门，走进去，用钥匙锁门。 因为进入厨房的人必须在他们进入厨房时带着钥匙，所以我们通过限制门外挂钩上可用的钥匙数量来直接控制允许进入厨房的人数。 对于线程，这是通过 信号量 来完成的。“普通” 信号量就像互斥锁一样工作 —— 你要么拥有互斥锁，在这种情况下你可以访问资源，要么不拥有，在这种情况下你不能访问资源。我们刚才在厨房中描述的信号量是一个计数信号量 —— 它跟踪计数 (根据线程可用的 “钥匙” 的数量)。 作为互斥锁的信号量我们刚才问了这样一个问题:“可以用互斥锁来实现吗?” 对于使用互斥锁实现计数，答案是否定的。反过来怎么样？我们可以使用信号量作为互斥锁吗？ 当然可以！事实上，在某些操作系统中，这正是它们所做的 —— 它们没有互斥锁，只有信号量！那么，为什么要为互斥锁费心呢？ 要回答这个问题，先看看你的洗手间。你房子的建造者是如何实现 “互斥锁” 的？我敢肯定你家的厕所外面并没有挂在墙上的钥匙！ 互斥锁是一种 “特殊用途” 的信号量。如果您希望在代码的特定部分中运行一个线程，那么互斥是目前为止最有效的实现。 (事实上文章的后续介绍了其他同步方案——称为 condvars、barrier 和 sleepons，这些就是 Java 中同步方案的操作系统层面的原型，感兴趣的可以自行去阅读一下.. 差别不大，只不过使用的是操作系统层面的描述…) 为了避免混淆，请认识到 互斥锁还有其他属性，比如 优先级继承，这是它与 信号量 的区别。 Part 2. 内核的作用房子的类比很好地解释了同步的概念，但是它在另一个主要领域是解释不通的。在我们家里，有许多 “线程” 是同时运行的。然而，在一个真实的实时系统中，通常只有一个 CPU，所以一次只能运行一个 “东西”。 单核 CPU让我们看看在现实情况中会发生什么，特别是在系统中 只有一个 CPU 的情况下。在这种情况下，由于只有一个 CPU，因此在 任何给定的时间点只能运行一个线程。内核决定 (使用一些规则，我们将很快看到) 到底该运行哪个线程。 多核CPU (SMP)如果您购买的系统具有多个相同的 CPU，它们都共享内存和设备，那么您将拥有一个 SMP box (SMP 代表对称的多处理器，“对称的” 部分表示系统中的所有 CPU 都是相同的)*。在这种情况下，可以并发 *(同时) 运行的线程数量受到 CPU 数量的限制。(实际上，单处理器机箱也是如此!) 由于每个处理器一次只能执行一个线程，因此如果有多个处理器，多个线程就可以同时执行。 现在让我们先忽略 CPU 的数量 —— 一个有用的抽象是把系统设计成多线程同时运行的样子，即使事实并非如此。(稍后，在 “使用 SMP 时要注意的事情” 一节中，我们将看到 SMP 的一些非直观影响…) 内核作为仲裁程序那么，在任何给定的时刻，谁来决定哪个线程将运行？这是内核的工作。 内核确定在特定时刻应该使用 CPU 的线程，并将上下文切换到该线程。让我们研究一下内核对 CPU 做了什么。 CPU 有许多寄存器 (确切的数目取决于处理器家族，例如，x86 对 MIPS，以及特定的家族成员，例如，80486 对 奔腾)。当线程运行时，信息存储在这些寄存器中 (例如，当前程序位置)。 当内核决定另一个线程应该运行时，它需要: 保存当前运行线程的寄存器和其他上下文信息； 将新线程的寄存器和上下文加载到 CPU 中； 但是内核如何决定应该运行另一个线程呢？ 它会查看某个特定线程此时是否能够使用该 CPU。例如，当我们谈到互斥锁时，我们引入了一种 阻塞状态 (当一个线程拥有互斥锁，另一个线程也想获得它时，就会发生这种情况;第二个线程将被阻塞)。 因此，从内核的角度来看，我们有一个线程可以消耗 CPU，而另一个线程由于被阻塞而不能等待互斥锁。在这种情况下，内核让可以运行的线程消耗 CPU，并将另一个线程放入一个内部列表 (以便内核可以跟踪它对互斥锁的请求)。 显然，这不是一个很有趣的情况。假设有许多线程可以使用该 CPU。还记得我们基于优先级和等待长度来委托对互斥的访问吗？内核使用类似的方案来确定下一个将运行哪个线程。有两个因素：优先级 和 调度算法，基于此顺序评估。 优先级考虑两个能够使用 CPU 的线程。如果这些线程具有不同的优先级，那么答案真的很简单 —— 内核将 CPU 分配给优先级最高的线程。正如我们在讨论获得互斥锁时提到的，优先级是从 1 (可用性最低的) 开始的。 注意，优先级为零是为空闲线程保留的 —— 您不能使用它。 (如果您想知道您的系统的最小值和最大值，可以使用 Linux 的系统函数 sched_get_priority_min() 和 sched_get_priority_max() —— 它们的原型被定义在 &lt;sched.h&gt; 中。我们假设 1 是最低可用性，255 是最高可用性。) 如果另一个具有更高优先级的线程突然能够使用 CPU，内核将立即上下文切换到更高优先级的线程。我们称之为 抢占 —— 高优先级线程抢占了低优先级线程。当高优先级线程完成时，内核上下文切换回之前运行的低优先级线程，我们称之为 恢复 —— 内核继续运行前一个线程。 现在，假设有两个线程能够使用 CPU，并且具有完全相同的优先级。 调度算法让我们假设其中一个线程当前正在使用该 CPU。在本例中，我们将研究内核用于决定何时进行上下文切换的规则。(当然，这整个讨论实际上只适用于具有相同优先级的线程) 内核有两种主要调度算法 (策略)*：轮询调度 *(或简称“RR”) 和 FIFO (先入先出)。 FIFO(First In First Out，先进先出)在 FIFO 调度算法中，允许线程一直使用 CPU (只要它想要使用)*。这意味着，如果该线程正在进行非常长的数学计算，并且没有其他具有更高优先级的线程准备好，那么该线程可能会永远运行下去。那么具有相同优先级的线程呢？它们也被锁在外面了。(显然，此时低优先级的线程也被锁定。)* 如果正在运行的线程放弃或自愿放弃 CPU，那么内核将查找 具有相同优先级、能够使用该 CPU 的其他线程。如果没有这样的线程，那么内核将寻找能够使用 CPU 的低优先级线程。 注意，术语 “自愿放弃CPU” 可能意味着两种情况。 如果线程进入睡眠状态，或者在信号量上阻塞，那么是的，一个低优先级的线程可以运行 (如上所述)。 但是还有一个 “特殊” 调用，sched_yield() (基于内核调用 SchedYield())，它仅将 CPU 让给另一个具有相同优先级的线程 —— 如果高优先级的线程已经准备好运行，那么低优先级的线程将永远不会有机会运行。如果一个线程确实调用了 sched_yield()，并且没有其他具有相同优先级的线程准备运行，那么原始线程将继续运行。实际上，sched_yield() 用于在 CPU 上对另一个具有相同优先级的线程进行访问。 在下面的图中，我们看到三个线程在两个不同的进程中运行: 如果我们假设线程“A”和“B”已经准备好了，线程“C”被阻塞了(可能在等待互斥)，线程“D”(没有显示)正在执行，那么内核维护的就绪队列的一部分看起来是这样的： 这显示了内核的 内部就绪队列，内核使用它来决定下一步调度谁。注意，线程“C”没有在就绪队列中，因为它被阻塞了；线程“D”也没有在就绪队列中，因为它正在运行。 轮循(Round Robin)RR 调度算法 与 FIFO 相同，只是如果有另一个具有相同优先级的线程，则该线程不会永远运行。它只对系统定义的时间片运行，您可以使用函数 sched_rr_get_interval() 来确定时间片的值。时间片通常为 4 毫秒，但实际上是 ticksize 的 4 倍，您可以查询或使用 ClockPeriod() 设置 ticksize。 实际发生的情况是，内核启动一个 RR 线程，并记录时间。如果 RR 线程运行了一段时间，分配给它的时间就会超时 (时间片已经过期)。内核查看是否有另一个具有相同优先级的线程已经准备好了。如果有，内核运行它。如果没有，那么内核将继续运行 RR 线程 (内核授予线程另一个时间片)。 让我们总结一下 调度规则 (对于单个CPU)，按重要性排序: 一次只能运行一个线程。 最高优先级的就绪线程将运行。 线程将一直运行，直到阻塞或退出。 RR 线程将运行它的时间片，然后内核将重新安排它 (如果需要)。 下面的流程图显示了内核做出的决策： 对于多 CPU 系统，规则是相同的，除了多个 CPU 可以并发地运行多个线程。线程运行的顺序 (在多个 CPU 上运行哪些线程) 的确定方法与在单个 CPU 上完全相同 —— 最高优先级的就绪线程将在一个 CPU 上运行。对于优先级较低或等待时间较长的线程，内核在安排它们以避免缓存使用效率低下方面具有一定的灵活性。 内核状态我们一直在松散地讨论 “运行”、“就绪” 和 “阻塞” —— 现在让我们更加深入地来讨论这些线程状态。 运行态（RUNNING）运行状态仅仅意味着线程正在积极地消耗 CPU。在一个 SMP 系统上，会有多个线程在运行;在单处理器系统中，只有一个线程在运行。 就绪态（READY）就绪状态意味着这个线程现在就可以运行 —— 但它不会立刻运行，因为另一个线程 (具有相同或更高优先级) 正在运行。如果两个线程能够使用 CPU，一个线程优先级为 10，一个线程优先级为 7，那么优先级为 10 的线程将正在运行，优先级为 7 的线程将准备就绪。 阻塞状态（BLOCKED）我们把阻塞状态称为什么？问题是，阻塞状态并不只有一个。在内核的作用下，实际上有超过 12 种阻塞状态。 为什么那么多？因为内核会跟踪线程被阻塞的原因。 我们已经看到了两种阻塞状态 —— 当一个线程被阻塞等待互斥锁时，这个线程处于互斥锁状态；当线程被阻塞等待信号量时，它处于 SEM 状态。这些状态只是表明线程阻塞在哪个队列 (和哪个资源) 上。 如果在一个互斥锁上阻塞了许多线程 (处于互斥锁阻塞状态)，内核不会注意到它们，直到拥有该互斥锁的线程释放它。此时，阻塞的一个线程已经准备就绪，内核将做出重新调度决策 (如果需要)。 为什么说 “如果需要” 呢？刚刚释放互斥锁的线程可能还有其他事情要做，并且比等待的线程有更高的优先级。在本例中，我们使用第二个规则，即 “最高优先级的就绪线程将运行”，这意味着调度顺序没有改变 —— 高优先级线程继续运行。 内核状态，完整的列表下面是内核阻塞状态的完整列表，并简要说明了每个状态。顺便说一下，这个列表可以在 \\&lt;sys/neutrino.h&gt; —— 你会注意到所有的状态都以 STATE_ 作为前缀 (例如，这个表中的 “READY” 在头文件中以 STATE_READY 的形式列出)： 状态标识 当前线程动作 CONDVAR 等待一个条件变量被通知。 DEAD 线程死亡。内核正在等待释放线程的资源。 INTR 等待中断。 JOIN 等待另一个线程的完成。 MUTEX 等待获取互斥锁。 NANOSLEEP 睡一段时间 (当前的线程将暂停执行,直到 rqtp 参数所指定的时间间隔)。 NET_REPLY 等待通过网络发送的回复。 NET_SEND 等待一个脉冲或消息通过网络传送。 READY 不在 CPU 上运行，但已准备运行 (一个或多个更高或同等优先级的线程正在运行)。 RECEIVE 等待客户端发送消息。 REPLY 等待服务器回复消息。 RUNNING 正在 CPU 上积极地运行。 SEM 等待获取信号量。 SEND 等待服务器接收消息。 SIGSUSPEND 等待信号。 SIGWAITINFO 等待信号。 STACK 等待分配更多堆栈。 STOPPED 暂停(SIGSTOP信号)。 WAITCTX 等待寄存器上下文 (通常是浮点) 可用 (仅在SMP系统上)。 WAITPAGE 等待进程管理者解决页面上的一个错误。 WAITTHREAD 等待创建线程。 需要记住的重要一点是，当一个线程被阻塞时，无论它处于何种状态，它都不会消耗CPU。相反，线程消耗 CPU 的唯一状态是运行状态。 Part 3. 线程和进程让我们从真实的实时系统的角度回到对线程和进程的讨论。 我们知道一个进程可以有一个或多个线程。(一个没有线程的进程将不能做任何事情 —— 也就是说，没有人在家执行任何有用的工作。) 一个系统可以有一个或多个进程。(同样的讨论也适用于 —— 一个没有任何进程的系统不会有任何作用。) 那么这些进程和线程是做什么的呢？最终，它们形成一个系统 —— 执行某个目标的线程和进程的集合。 在最高层次上，系统由许多进程组成。每个进程都负责提供某种性质的服务 —— 无论是文件系统、显示驱动程序、数据采集模块、控制模块，还是其他什么。 在每个进程中，可能有许多线程。线程的数量是不同的。一个只使用一个线程的进程可以完成与另一个使用五个线程的进程相同的功能。有些问题本身是多线程的，实际上解决起来相对简单，而其他进程本身是单线程的，很难实现多线程。 如何用线程进行设计的话题很容易就会被另一本书占用 —— 在这里我们只关注基础知识。 为什么需要多个进程？那么为什么不让一个进程拥有无数线程呢？虽然有些操作系统强迫你这样编码，但将事情分解成多个进程的好处有很多: 分离和模块化； 可维护性； 可靠性； 将问题 “分解” 成几个独立问题的能力是一个强大的概念。它也是系统的核心。一个系统由许多独立的模块组成，每个模块都有一定的职责。这些独立的模块是不同的进程。QSS 的人员使用这个技巧来开发独立的模块，而不需要模块相互依赖。模块之间唯一的 “依赖” 是通过少量定义良好的接口实现的。 由于缺乏相互依赖关系，这自然会增强可维护性。因为每个模块都有自己的特定定义，所以修复一个模块相当容易 —— 尤其是在它不绑定到任何其他模块的情况下。 然而，可靠性可能是最重要的一点。进程就像房子一样，有一些定义明确的 “边界”。住在房子里的人很清楚自己什么时候在房子里，什么时候不在房子里。一个线程有一个很好的想法 —— 如果它在进程中访问内存，它可以存活。如果它超出了进程地址空间的范围，它就会被杀死。这意味着运行在不同进程中的两个线程可以有效地相互隔离。 进程地址空间由系统的进程管理器模块维护和执行。当一个进程启动时，进程管理器会分配一些内存给它，并启动一个正在运行的线程。内存被标记为该进程所拥有。 这意味着如果进程中有多个线程，内核需要在它们之间进行上下文切换，这是一个非常高效的操作 —— 我们不需要改变地址空间，只需要改变哪个线程在运行。但是，如果我们必须切换到另一个进程中的另一个线程，那么进程管理器就会介入并导致地址空间的切换。不用担心，虽然在这个额外的步骤中会有一些额外的开销，但是在系统的作用下仍然是非常快的。 如何启动一个进程现在让我们将注意力稍微转向可用于处理线程和进程的函数调用 。任何线程都可以启动一个进程；唯一施加的限制是那些来自基本安全性的限制 (文件访问、特权限制等)。 想要启动一个进程大概有以下几种方法 (具体的细节我们在这里不介绍)： 命令行启动； 使用 system() 函数调用启动：这是最简单的，直接在命令行输入就可以。实际上，system() 启动了一个外壳程序来处理您要执行的命令； 使用 exec() 系列函数 和 spawn() 函数调用启动：当一个进程发出 exec() 函数，则该进程停止运行当前程序，并开始运行另一个程序；进程 ID 没有改变 ——— 进程变成了另一个程序；而调用 spwan() 函数则会创建另一个进程 (带有新的进程 ID)，该进程与函数的参数中指定的程序相对应。 使用 fork() 调用启动：完全复制当前进程，所有代码都是相同的，数据也与创建 (或父) 进程的数据相同。有意思的是，当您调用 fork() 时，您创建了另一个进程，该进程在相同的位置执行相同的代码，两个进程都将从 fork() 调用中作为父进程返回。(感兴趣的同学可以自行搜索一下…) 使用 vfork() 调用启动：与普通 fork() 函数相比，vfork() 函数的资源消耗要少得多，因为它共享父线程的地址空间。vfork() 函数创建一个子线程，然后挂起父线程，直到子线程调用 exec() 或退出。另外，vfork() 可以在物理内存模型系统上工作，而 fork() 不能 —— fork() 需要创建相同的地址空间，这在物理内存模型中是不可能的。 如何启动线程现在我们已经了解了如何启动另一个进程，让我们看看如何启动另一个线程。 任何线程都可以在同一进程中创建另一个线程。没有任何限制 （当然，内存空间不足除外！）。最常见的方法是通过 POSIX pthread_create() 调用： #include &lt;pthread.h> int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 参数细节和更多线程管理的内容这里就不讨论了.. 线程是个好主意有两类问题，线程的应用是一个好主意。 并行化操作，如计算许多数学问题 (图形、数字信号处理等…)； 共享数据执行几个独立的功能，如服务器同时服务多个客户； 第一类问题很容易理解，把同一个问题分成四份并让四个 CPU 同时计算，这当然感觉会快上不少。 第二类问题稍微麻烦一些，我们借助网络中一台「计算图形结果并发往远端的节点」用来演示，并进一步说明「为什么单核 CPU 系统使用多线程仍然是一个好主意」。 假设我们有一个程序，需要先计算图形的部分 (假设使用 “C” 表示)，然后需要传输到远端 (假设使用 “X” 表示)，并最终等待远端回应做下一步操作 (假设使用 “W” 表示)，以下就是该程序在单核 CPU 下的使用情况： 等一下！这浪费了我们许多宝贵的可用于计算的时间！因为等待远端回复的过程，CPU 做的仅仅是 “等待” 而已.. 如果我们使用多线程，应该可以更好地利用我们的 CPU，对吗？ 这样好得多，因为现在，即使第二个线程花了一些时间等待，我们也减少了计算所需的总时间。 我们可以来简单计算一下。假设我们计算的时间记为 T计算，发送和等待的时间分别记为：T发送 和 T等待。那么在第一种情况下，我们的总运行时间为： （T计算 + T发送 + T等待） x 任务数量 而使用两个线程： (T计算 + T发送) x 任务数量 + T等待 直接减少了： T等待 x (任务数量 - 1) 请注意，我们速度最终还是受到以下因素的决定： T计算 + T发送 x 任务数量 因为我们必须至少进行一次完整的计算，并且必须将数据传输到硬件之外 —— 尽管我们可以使用多线程覆盖计算周期，但只有一个硬件资源可以传输。 现在，我们创建一个四线程的版本，并且在 4 核的系统上运行它，那么我们最终将得到如下图示的结果： 请注意，四个 CPU 的每个利用率均未得到充分利用 (如图示 “利用率” 中的灰色矩形所示)。上图中有两个有趣的区域。当四个线程启动时，它们各自进行计算。不过，当线程在每次计算完成时，它们都在争夺传输硬件 (图中的 “X” 部分 —— 一次只能进行一次传输)。这算是在启动部分给了我们一个小异常。一旦线程经过此阶段，由于传输时间比计算周期的 1/4 小得多，因此它们自然会与传输硬件同步。首先，忽略小异常，该系统的特征在于以下公式： （T计算 + T发送 + T等待） x 任务数量 / CPU 数量 该公式指出，在四个 CPU 上使用四个线程将比我们刚开始使用的单线程模型快大约 4 倍。 通过结合从简单拥有多线程单处理器版本中学到的知识，我们理所当然地希望拥有更多的 CPU 运行更多的线程，以便多余的线程可以 “吸收” 发送确认等待 （和发送信息） 中的空闲的 CPU 时间。 但是你尝试像我这样画一下 8 核 8 线程的情况，你就会注意到一些神奇的事情：我们仍然会遭遇利用率不足的情况，并且会发现 CPU 处于 “停滞等待” 状态的可能同时会有很多个。 这给了我们一个很重要的教训 —— 我们不能简单的增加 CPU 以倍速我们的运算速度。 我们希望越来越快，但存在许多限制因素。在某些情况下，这些限制因素仅受多 CPU 主板的设计 —— 当许多 CPU 尝试访问相同的内存区域时，会发生多少内存和设备争用。 尽管多线程多核给我们带来了许多好处，但 “更加复杂的环境” 也让我们面临更多的困难和挑战。可以参考我们类比的例子，在生活中，你面临的情况如果仔细思考和罗列的话，那将会是多么复杂…. 这里也不展开讲了 总结相信看完的朋友都能够对进程和线程进一步加深印象.. 进程像房子，线程像住户，非常深入人心！ 原文章的后半程还详细地介绍了很多线程同步的更多内容，涉及 Linux 底层的函数调用，再后面一个章节还详细地介绍了进程间的通讯相关的内容，感兴趣的童鞋，请移步原文！ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术文章","slug":"想要跟你们分享/技术文章","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"翻译文","slug":"翻译文","permalink":"http://www.wmyskxz.com/tags/%E7%BF%BB%E8%AF%91%E6%96%87/"}],"author":"我没有三颗心脏"},{"title":"96年/离职8个月/拒绝华为offer/目前自由职业-记这大半年来的挣扎与迷茫","slug":"96年-离职8个月-拒绝华为offer-目前自由职业-记这大半年来的挣扎与迷茫","date":"2020-07-26T03:48:00.000Z","updated":"2020-12-09T04:47:10.290Z","comments":true,"path":"2020/07/26/96-nian-chi-zhi-8-ge-yue-ju-jue-hua-wei-offer-mu-qian-zi-you-zhi-ye-ji-zhe-da-ban-nian-lai-de-zheng-zha-yu-mi-mang/","link":"","permalink":"http://www.wmyskxz.com/2020/07/26/96-nian-chi-zhi-8-ge-yue-ju-jue-hua-wei-offer-mu-qian-zi-you-zhi-ye-ji-zhe-da-ban-nian-lai-de-zheng-zha-yu-mi-mang/","excerpt":"","text":"仅以此文，记录自己这大半年来的挣扎与迷茫。 2019 年 11 月在公司工作七个月之后，我被裁员了。 回忆自己这七个月的经历，不管是遇到的人和事，更多感到的是收获和感恩，于是我写下了：「应届毕业生工作7个月小结」，当做对于这七个月的小小总结。 本想好好休息几天，不料第二天还在睡梦中，就有 HR 和猎头找上门来了.. 既然来了，就好好准备复习面试吧.. 2019 年 12 月疯狂面试ing…然后 12 月开始了疯狂面试，包括华为 (口头 Offer)*、字节跳动 *(一面挂,面试官说很久没问过应届生了..) 等，一下子就面到了 12 月中旬了。 说实话，那段时间好怕面试官问：「你对 HashMap 了解多少？」 这种问题。 从「基础结构」到「1.7 到 1.8 版本变化」； 从「与其他 Map 结构对比和区别」到「HashMap 具体的 put/resize/hash 等的具体过程」； 从「为什么 String/Integer 适合做 HashMap 的 K」到「HashMap 为什么不直接使用 hashCode() 处理后的哈希值直接作为 table 下标」； 从「什么是哈希，什么是哈希冲突」到「HashMap 如何解决哈希冲突」； 再从 HashMap 延伸的其他 Java 常用集合…. 这些教科书式回答我都快说吐了.. 疯狂面试的生活，也从我拿到华为口头 Offer 开始逐渐告一段落.. 拒绝华为 Offer…虽然拿到了华为的口头 Offer (签约是第三方，享受华为待遇)，但我拒绝了… 并且把其他所有的 Offer 都拒绝了… 我大概是跟钱不太能过得去吧.. 彼时跟华为谈下来的条件，薪资直接翻了一倍，一个月能拿到的薪资甚至是部分同学朋友的三倍四倍还多… 去，那就是一份看上去十分体面、充实且奋斗的工作，但可想而知的是，属于自己的时间会直线缩水，甚至过上每天下班回家，时间就只够洗澡睡觉的生活… 我自觉有些工作狂的潜质，之前上班的时候，精力总是很旺盛，但一旦神经一松懈下来，就能够躺上一整天，而我甚至是懒觉都不睡的人… 我惧怕工作狂的状态让我没有时间思考或者审视自己，当我意识处于自动驾驶时，很多问题和琐碎就会逐渐地远离我，工作也似乎会变成一种逃避现实和填满时间的方式，我想起在这之后那些为了工作而工作的片段就感到难受。(特别是还会牺牲部分健康) 如果工作是为了未来幸福快乐的生活，那么是否可以忍受当下的不快乐和不幸福？ 所以让我感到奇怪的是：「我是否必须埋头工作并过着 “悲惨的生活”，以便让我的未来感觉到快乐和幸福？」 当然也真不是黑华为.. 那天华为面我的部门 Leader 跟我通电话的时候已经过晚上 10 点了，说道：「其实加班没有外面传那么厉害啦，你看我现在已经准备下班回家啦。」 看不清的答案…经历过的千篇一律的面试，那些反反复复的面试套路问题，让我也开始对「工作」开始重新审视起来：「无非是换个地方拧螺丝而已吗？」 又看向公司高层和那些技术大牛们，他们背上了房贷、车贷，家里老婆孩子等着照顾，一刻不敢停歇忙碌的身影，我问自己：「这就是我未来理想的生活吗？」 答案很明显。 我不想要 30% or 50% 的幸福，我对自己承诺的是 100% 的幸福 (尽管这一点都不现实，甚至有点魔幻主义)。 彼时这些自以为是、天真烂漫的想法，充斥着我的大脑。这些也让那个 22 岁的少年充满了迷茫。 就像是上图，前方的路于我而言，就像不停加速的滚轮一样，一旦踏上了，要么保持持续的热诚和兴奋，要么等待着滚轮将我重重地甩在墙壁上。而我有强烈的预感，我会是后者 (即使我对编程保有强烈的热情和兴趣)。 机会和计划…可是如果不工作，干什么呢？ 我想起好朋友很早之前就对我发出过的，成为「MC (我的世界) 开发者」的邀请 (彼时朋友早已是挂上网易官网三大明星开发团队的核心成员)。 详细咨询一番后，从他那里得知的关键信息是： 每天 3-5 个小时的自由工作时长 (总之就是很自由)； 还过得去的收入 (部分是来自于团队积攒的口碑)； 都说先求生存再求发展。这样的工作和机会不仅很好地解决了我的生活问题，而且本身还十分有趣，可以自己构思自己的产品并实现它 (写 Python 代码)，并通过它来赚取利润，挺有意思。 另外审视过去，发现自己很大部分幸福来自于 「分享」 这事儿。 很多现在看仍然觉得 牛逼 的文章，都是自己有大量空余时间认真思考问题时总结的，工作之后写的大部分文章 (19 年 4 月到 19 年 11 月的文章) 都显得差了那么点儿意思。唯一自己还满意的 一篇文章 也是熬了很多个大夜熬出来的… 而工作之后这样的机会和时间就变得相对少了起来… 这也是后来我创建 「MoreThanJava」 文集的原因，我希望我写的东西很多年之后回看时，仍保留着特殊的价值。 分享、写文是我喜欢的事 (事实上我很向往那种能把事情说清楚，思想表达明白的人)，并且跟 3y、Guide、敖丙 都交流了一下，似乎公众号的发展空间还是很大的。做自己喜欢的事，顺便还能赚钱，似乎还蛮酷的样子。 再者自己的兴趣还挺广泛的。吉他、钢琴、绘画、设计、UI 等多多少少都想学习学习。而这些无不需要花费大量的时间。 也想趁年轻多出去走走，反正有网就行，去丽江之类的地方住一段时间再回来也不是不可。 毅然而然的决定…这会是一个好的决定吗？ 我带着我的这些想法先是咨询了前辈领导，我们聊了很久，他帮助我理顺了这其中的得失并给了我一些很好的建议 (手动感谢)，我更加坚定了些。 我又告诉了我的好朋友们，他们也表示支持，值得尝试。 于是拒掉了所有的 offer，我也给好朋友打电话确定了加入工作室的事情，决心成为「MC 开发者」的一员开始自己的计划。 并假装许诺自己一年时间去尝试尝试。即使一年之后，我也才 23 岁，仍然有大把的机会可以选择。 2020 年 1 月再次婉拒华为…为了防止自己一个人自闭，我找到还在读研究生的同学一起合租。 我搬离了之前工作的地方，等一切准备好想好之后，我告诉了我妈，我妈一秒犹豫也没有：「我不同意！」 别人挤破头想进华为都进不去，为什么会拒绝这么好的工作？ 为什么在应该奋斗挣钱的年纪不选择努力工作选择出来单干？ 别说我妈了.. 估计这事儿华为之前跟我沟通的领导也没怎么想明白吧.. 于是我在 2020 年 1 月 6 号 的下午又接到了华为领导的电话： 我再次婉拒了… 做这样的决定，需要的不仅仅是勇气，还需要有特殊的傻楞劲儿。 当然还得有运气。这里想多说一些，抛开钱，有多少人能真的想明白「为什么工作」这件事情呢？真正借助平台做实事的毕竟是少数，那既然大部分人都是为了钱，途径就真的只剩下工作一条了吗？ 努力学习是为了找到一个好的单位好的工作，努力工作是为了挣更多的钱，这似乎成了唯一的选择 (至少是在我身处的环境中给我营造出来唯一的路..)，当所有的答案都指向同一个方向，那我就属实不敢苟同了 (至少不唯一)。 而且很奇怪的地方是，既然挣钱这么重要，为什么学校从来不教呢 (特别是九年义务教育)？学校反而教给你的是成为一个优秀员工的必备技能，从结果来看，这并不能让大部分的人挣到钱。 时常听到：「啊！不想上班呐！」，是因为做着不喜欢的事情。相反，如果把喜欢变成工作，那么情况将完全不同。 说着说着，就有愤青那么点儿味道了…收！ 总而言之，我实属很幸运的那一拨，幸运地能够喜欢计算机，幸运地有机会，幸运地能够自由地做这样的选择… 接了一个外包项目…由于搬到了学校附近，就时常在实验室晃悠… 由此也很巧地受到实验室学长的推荐，在学校老师手底下接了一个外包项目 (还是有不少钱的)… 后端、前端、UI、微信小程序全部都由我一个人把控 (就是我一个人写)，这感觉还是挺舒服的，于是开始了一边写项目一边学习 MC 的生活… 开始学做饭…时间多起来，也要学会照顾好自己，开始学一些简单的「一人食」： 2020 年 2 月2 月由于过年加上疫情的影响，效率拉到了最低… 几乎干不了什么事情… 毕竟大过年还有什么事情好忙呢？(反讽…) 于是快二月底就毅然离开了老家，回到了成都.. 回成都第二天.. 老家就给封路了.. 不让出了.. 2020 年 3 月学习 Redis 和 Python…一边继续进行着项目，一边抽出时间来钻研一下 Redis。 之前就是背了一些常见的面试题，也没有深入了解过，自己不趟一遍水，踩一遍坑始终觉得心里不踏实。 Redis(1)——5种基本数据结构 Redis(2)——跳跃表 Redis(3)——分布式锁深入探究 Reids(4)——神奇的HyperLoglog解决统计问题 Redis(5)——亿级数据过滤和布隆过滤器 Redis(6)——GeoHash查找附近的人 Redis(7)——持久化【一文了解】 Redis(8)——发布/订阅与Stream Redis(9)——史上最强【集群】入门实践教程 妈妈再也不担心我面试被Redis问得脸都绿了 另外由于 MC 是使用的 Python，也粗浅地自学了一把 Python： 懂一点Python系列——快速入门 参与网易 MC 季度 Mod 开发…第一次上手的项目就是网易第三季度准备推出的季度 Mod：「星际探险：迫降」(倍感荣幸… 多少有点儿出道即巅峰的意味在里面…) 这是当时在测试随机生成树算法的画面： 2020 年 4 月MoreThanJava 开篇…本着「分享」的初衷，就着最初的计划，「MoreThanJava」系列开工： 看着还挺像那么回事的。 四月新增文章： 「MoreThanJava」当大学选择了计算机之后应该知道的 「MoreThanJava」计算机发展史—从织布机到IBM 一切似乎都不那么如愿…我突然有些觉得，把生活比喻成一条河流的另外一层意思是：「就算你不动，生活也会推着你往前走」 假如生活不推你了，你还继续走吗？是往前吗？哪里又是前？ 一方面，我自觉有着明确的目标以及一定要留下那么一笔的信念。 另一方面，生活并不轻松，特别是本该发小项目挂商城赚钱的我，刚开始就接触到了这么大的一个季度 Mod，没有立马能拿到的额外收入还得帮着干不少活儿以及熟悉 MC 的开发 (不过好歹接了一个外包项目有收入)，还得独自面对生活中的琐碎。 再另一方面，一个人的时间确实能够获得难得的专注，不仅仅包括学习、工作，娱乐也是一样。特别是当生活不再推着你的时候。 一边过着颓废的生活，一边又在内心给自己喊话.. 这种纠结从上面节选的标题就能略微感受一二了.. 似乎一切都不如最初的那般如愿，计划也好，收入也好，甚至连生活都开始变得一团糟.. 缩水的钱包…最终迫使我改变的，还是那个最初我有些不对付的东西：钱。 我给自己搭建了一个还比较满意的工作环境，2 块 4k 屏幕，一张升降桌，一把电竞椅。但这些使我不得不计划着过日子，特别是当我额外买下一台华为笔记本之后 (MC 是微软的游戏.. Mac 运行不了.. 虚拟机也不行.. 蛋疼..)。 (ps：其中一块显示器在之后的搬家过程中还遭遇了不测…还不保修…) 我开始逼迫自己早上晨跑，晚上做运动..尽管没能坚持很久..(现在坚持去打打球) 我开始要求自己每天至少要看一个小时书，保持输入是一件特别重要的事情..尽管也断断续续的吧.. 最重要的是，强迫自己上纲上线，和团队成员出了自己第一款 Mod 组件.. 挂上了商城.. 尽管销量也不怎么好吧.. 但这一切对于我来说，都是一种积极的「开始」.. 尽管窘迫，但对自己的投资还是丝毫不吝啬的，比如： 2020 年 5 月重心的转移…生活的「窘迫」使我不得不转移更多的重心在 MC 组件的构思和开发上，整个 5 月，我没有发一篇原创文章 (此时我反而因为之前的 Redis 系列文章吧.. 接了一些广告发..).. 也由此，我得以构思了一个，和团队讨论之后预计会 卖爆 的组件，甚至我们一度还调研了找主播推广的价格 (悄悄说，一条视频五位数…)… 因为它不仅颠覆了 MC 的传统玩法，更有庞大有趣的世界观 (借鉴多个动漫来的) 和丰富多彩的新模型… 按照历史的数据和经验来看，这个组件大卖！(相当于制作了一款全新的游戏一样…) 于是我把所有的重心放在了组件的开发上，一边学习一边动手实践和改进着自己的想法.. 这让我兴奋不已，从早到晚.. 我感觉这酷极了.. 2020 年 6 月恢复输出…用了整个 5 月，组件终于准备上线了.. 同时上线的还有另外一个，花两个小时就写完的特别简单又好玩儿的玩儿法… 有了前一个月积攒的劲儿，写起文章来也顺畅了许多..(其实有些文章之前就查了很久的资料…) 五月输出： 「MoreThanJava」计算机系统概述 「MoreThanJava」一文了解二进制和CPU工作原理 「MoreThanJava」机器指令到汇编再到高级编程语言 「MoreThanJava」Java 发展史及起航新世界 现实打击…我们算好组件发布的时间，尽一切可能地增加模组的热度，但它没有按照预想的那般火热… 甚至可以说有些冷淡… 因为看最终的成交量和总金额来说，跟我两个小时就做完的没有什么特别本质的区别… 甚至专门仿照传统 RPG 游戏重新设计和实现的 UI，居然被人诟病成是 BUG..(因为有一点不符合原版游戏的操作习惯) 还因此给了许多低评分的差评… 这属实给我们来了一次打击… 特别是策划本人 (我)… 不过更多的是给我们上了一课。事实是：这是我们自己非常喜欢的组件，而不是广大玩家们喜欢的组件。(对于如何找准玩家口味这事儿，除了多试错，广撒网，我还真没什么好办法…) 另外从产品的角度反过头来审视： 本身全新的模式需要有学习成本； 又没有特别友好的提示系统 (「一个好的提示系统比十个新功能都有用」不知哪儿看的，但此刻映入脑海..)； 加上游戏的部分，大多都是靠几乎相同的方式硬肝 (类似于刷塔)； 等等等.. 以上种种的原因，就造成了这既不是那种让人愉悦到爆的产品，又根本不是那种能够帮助玩家抵御某种恐惧的产品，所以才会这般 “不痛不痒”。 “令人羡慕”的自由职业…从某种程度来说，我确实过上了 “令人羡慕” 的生活：不用朝九晚五的打卡签到，不用硬着头皮出去应酬，不用做违心的事只为了应付 KPI，也不用面对复杂的职场关系，一切都只有自己，想吃啥就可以吃，想去哪儿玩儿就可以去，做自己喜欢的事，对自己负责就够了。 不考虑钱的前提下，我假借着 “自由” 的名义，确实过得舒服极了… 身体方面除了久坐的屁股也是越发地健康… 但其实只有自己知道，这其中的难.. 一方面虽然我还算能够保持规律的作息和生活 (我特别需要维持这种状态以维持做事的能量…)，但能够打断你的事情比想象中要多得多，特别是当你 “自由” 之后。 毕竟又不工作，能有什么事呢？(反讽… 实际上需要做的事是越来越多的…) 另一方面来说，这种 “自由” 其实很自我，就当前来说，财务方面的「窘境」使我不得不这样：只能也只够对自己负责。 不免谈到钱这个话题时，心里默默算了一下如果去华为这几个月能够拿到的工资和自己这几个月的收入一对比 (差距接近六位数)*，心里还是会不免酸上一把。(实际情况如下图)* 所以实际上，网络上我是乐于分享的 热心博主，朋友前我是令人 “羡慕” 的 自由职业者 (目前仅实现了时间自由)，家人面前我则是 家里蹲的不上班的自闭网瘾少年。 2020 年 7 月保持输出…七月的前半程，还是输出了一些文章的… 在写 Day 4 面向对象的文章时，查了很多天资料总觉得差点意思.. 就有点卡住的意味了..(我时常用完成比完美重要来劝自己，但大部分时候还是劝不过.. 我只是希望力所能及的范围内能尽可能做得更好而已..) 七月新增文章： 「MoreThanJava」Day 1：环境搭建和程序基本结构元素 「MoreThanJava」Day 2：变量、数据类型和运算符 「MoreThanJava」Day 3：构建程序逻辑的方法 【知乎问题】如何让不懂编程的人感受到编程的魅力 网易 MC 创作大师赛…七月的后半程跟随团队参加了网易跟抖音联合举办的比赛，我是主编程。 之前的 “失败” 并没有打消我们的积极性，反而让我们迸发出了很多有意思的想法.. 随着许多组件的发布，收入方面也相比之前越来越好… 这几天编码的工作也差不多快进入尾声了.. 计划跟朋友们一起出去旅个游作为七月和上半年的终结~ 总结承诺给自己的时间已经过去大半，捧起自己给自己的答卷，勉强能算个及格分。事实上大部分时候自己甚至是怠惰的，但我愿意给这个及格分。 对于自己来说，上班对我来说是最容易的选择 (事实上这期间有很多机会我都拒绝了..)，我也并不觉得上班辛苦之类的，相反，现在需要直面自己内心各种各样复杂的声音，需要应付家人朋友的 “关心爱护” 反而让我有些疲惫。 当前的时光，一段时间的「窘境」是我给未来的自己下的赌注。 尽管有些艰难，但我是很愿意，也觉得很值得尝试的。 就像 @Lenciel 说的那样 (最近很喜欢逛他的博客..)： “究竟该怎么活，自己真正享受什么，喜欢什么，很多时候不是通过循规蹈矩的生活就能弄明白的，总得为什么东西拼过。” 后续的计划这里就不列了.. 最后以我微博的签名来作为结尾吧： 「想做一个自由且自律的人，靠势必实现的决心认真地活着！」 希望你我都能够奔赴在路上吧… 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"【知乎问题】如何让不懂编程的人感受到编程的魅力","slug":"【知乎问题】如何让不懂编程的人感受到编程的魅力","date":"2020-07-15T15:21:00.000Z","updated":"2020-12-09T04:45:46.016Z","comments":true,"path":"2020/07/15/zhi-hu-wen-ti-ru-he-rang-bu-dong-bian-cheng-de-ren-gan-shou-dao-bian-cheng-de-mei-li/","link":"","permalink":"http://www.wmyskxz.com/2020/07/15/zhi-hu-wen-ti-ru-he-rang-bu-dong-bian-cheng-de-ren-gan-shou-dao-bian-cheng-de-mei-li/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 知乎问题：如何让不懂编程的人感受到编程的魅力？ 链接：https://www.zhihu.com/question/406408447 Part 0. 前言问一个类似的问题：「如何让不懂篮球的人感受到篮球的乐趣？」 很明显，答案取决于人。 对于某些人来说，编码可能是乏味而艰巨的，但对于有些人则是非常有趣且有益的。 通常情况下，编写好代码之后，我们很难评判编码的过程是无聊还是有趣的。 但是我们可以通过更好地了解 「计算机编程是什么」，因此您可以自己来评判这是否让你感到乐趣。 就当代的发展水平来说，只要有电的东西就会涉及到编码； Part 1. 计算机发展简史 | 解决实际的问题 原文地址：「MoreThanJava」计算机发展史—从织布机到IBM 一切的开端 | 织布机衣食住行是人类的基本需求，世界各地都有纺织和织机的发明。 如何提升纺织的效率，成为一个很重要的课题。 与 「针织物」 不同，「机织物」 由两条或两组以上的相互垂直的两个系统纱线或丝线构成，纵向的纱线 叫 经纱，横向的纱线 叫 纬纱。 通过两条线不同规律的交错，就会形成不同的颜色和排列的变化，也就会带来不同的纹样。 图片引用自：https://www.sohu.com/a/301616592_99894978 最原始的织机是手动完成的。 后来人们发现，织物纹样的变化总是按照一定规律排列完成的，到了战国时期，就发明了 多综式提花织机，通过 综框 来完成这一项工作： [图片上传失败…(image-a35874-1594826100047)] 这或许就是最原始的 编码：通过把 提起规律相同的经纱 穿入 同一个综框的综丝 中，来达到当某一个综框提起时 (通过脚踏板完成)，表达某一个特定纹路的线被提起，也就完成了 特定纹路的编织，加快了工作效率。 织布机的更进一步 | 束综提花织机不过采用综框也有一个明显的限制，那就是 无法织出比较复杂的纹样，因为纹样复杂则代表着需要更多的经纬纱以及经纱提升的规律更复杂，意味着可能引入成百上千次纬纱才能完成一个循环。 如果仍然采用综框控制纱线提升，则可能需要成百上千个综框，这在机械上实现是非常困难的，因此便有了 束综提花织机。 束综提花织机没有综框，而是被 设计成两层，每一根经纱会穿入综丝中实现 单独的控制，上层 的人将需要提起的经纱提起，而 下层 的人则再经纱提起后通过梭子将纬纱送入织口，并用打纬装置将引入的纬纱打牢。 然而通常来说，这类织机上会有成千上万根纬纱，纹样复杂，于是聪明的老祖宗们发明了 花本： 简单来说，花本存储了纹样信息。 图中花本的竖线连接穿入了经纱的综丝，横线存储了每一次引入纬纱时提花信息，当竖线越过横线覆盖在横线前方时，表明对应的经纱要被提起。 这就有点儿 编码规则 的意思。 会说话的「机器」 | 雅卡尔织布机上面说到的束综提花织机虽然是一大进步，但可想而知的是，它仍然效率缓慢并且织布工人的劳动量非常大，也非常辛苦。 时间来到 18 世纪的欧洲。1725 年，布乔 开拓性的使用 打孔纸带 来控制经线的提起和放下，从而让织出花样成为一种半自动化的工作： 历史上第一次，机器能够读出存储介质中的内容，并且照其行事。 在布乔提出构想 65 后的 1790 年，约瑟夫·玛丽·雅卡尔 根据前人的成果设计了新式织机，最终于 1805 年完成了首台 自动提花织机： 雅卡尔将 穿孔纸带 改进为 穿孔卡片，根据纹样图案在卡片上打孔，通过孔的有无 带动一系列机械运动装置来 控制经纱的提升，一张卡片对应循环内一次引纬时经纱提升的信息，引纬完成后，可通过脚踏板控制卡孔卡片转动，下一张卡片翻转至工作位置以控制新一次引纬的提花： [图片上传失败…(image-547502-1594826100047)] 雅卡尔织机大幅度节省了时间和工作量 (全自动且效率是之前的二十五倍)，而且只需一位工人，很快就被广泛使用在工厂生产中，雅卡尔也荣获了拿破仑授予的荣誉勋章。 穿孔卡片控制织物纹样的设计成为了程序设计思想的萌芽，为信息技术的发展开展了一条新的道路。 程序设计思想开始萌芽 | 差分机 时间来到 19 世纪初，法国人 巴贝奇 (Chanles Badbbage) 在贾卡织机的启发下，设计并制造了 差分机。 故事背景18 世纪末，法国政府在开创米制之后，决定在数学中统一采用十进制，竟奇葩地想把原本 90 度的直角划分成 100 度、把原本 60 秒的 1 分钟划分成 100 秒，尽管从现在看来这样的想法绝逼是一种倒退，但他们在当时真就实施了。这一改制带来的不光是人们在使用时直观上的别扭，原本制作好的数学用表 （如三角函数表） 都需要全部重制。 法国政府将这项丧心病狂的工程交给了 数学家普罗尼 （Gaspard de Prony），普罗尼正头疼着要如何才能完成这项艰巨的任务，突然想起著名经济学家 *亚当·斯密** *（Adam Smith） 的那本《富国论》，他决定采用书中提出的 劳动分工 的做法，将制表的工作人员分成三组： 第一组 由五六名牛逼的数学家组成，他们负责制定运算中所需的公式； 第二组 由九到十个擅长数学的人组成，他们负责计算出一些关键数据，并把第一组制定好的公式进行简化； 第三组 由约一百名计算人员组成，他们利用第二组提供的关键数据和公式，做最简单的加减操作就能得出最终结果。 第三组的工作简单到什么程度，就是他们甚至都不知道自己正在算什么玩意儿，事实上他们的文化程度大部分都不高，里头好多都是理发师、失业人员什么的。可见即便文盲都能完成的计算，在那个时代还是得依靠人力去做。 而为了保证用表的正确性，普罗尼要求 每个数至少算两遍，并且 要在法国的不同地点用不同的方法计算。这项劳民伤财的工程整整进行了十年才完成，然而不幸的是，最终的表里仍然有错。说到这一点，可以说，那个时代基本没有一版数学用表是完全正确的，有些版本甚至错误百出，要知道数学用表出错有时后果会很严重，比如航海表一出错就可能直接导致船毁人亡。 巴贝奇 在了解到普罗尼的事迹后泪流满面，决心要做一套完全正确的数学用表，为达目的，他尝试了各种减少错误的手段，比如调整纸张和墨水的颜色以提高数字的识别度，直接拿现有的多个版本的表进行誊抄、比对、让不同人员反复校对，在 1827 年出版了一个版本，结果里头还是有错。只要是人为的就没有完美的，巴贝奇彻底跪了，他发誓要造一台机器，让机器去生产数学表。 这就是史上著名的 差分机 了。 伦敦科学博物馆·差分机设计图纸&amp;半成品： 第一台真正意义上的电脑 | 分析机尽管没能亲手实现差分机，但巴贝奇并不会气馁，或者说他本来就是根本停不下来的那种人。明知实现不了，巴贝奇仍在一刻不停地改进着自己的设计，直到有一天，他构思出了一种空前的机器——分析机，正式成为现代计算机史上的第一位伟大先驱。 (Father of computing) 1834 年，分析机概念诞生之际，巴贝奇自己都为之感到无比震惊。在此之前，任何一台计算机器都只能完成其被预定赋予的计算任务，要么是简单的加减乘除，要么像差分机那样只能做差分运算，它们都属于 calculator，而分析机才是真正的 computer，它不局限于特定功能，而竟然是可编程的，可以用来 计算任意函数——现代人无论如何也无法想象在一坨齿轮上写程序是怎样一种体验吧！ 巴贝奇设计的分析机主要包括三大部分： 用于存储数据的计数装置，巴贝奇称之为 “仓库”（store），相当于现在 CPU 中的存储器，这部分是从差分机上的计数装置改进而来的，我们很容易想象它的模样； 专门负责四则运算的装置，巴贝奇称之为 “工厂”（mill），相当于现在 CPU 中的运算器，这部分的结构相对复杂，巴贝奇针对乘除法还做了一些优化； 控制操作顺序、选择所需处理的数据和输出结果的装置，巴贝奇没有起名字，由于其呈桶状，我们可以叫它 “控制桶”，控制桶显然相当于现在 CPU 中的控制器。 以上三部分，加上巴贝奇并没有疏漏的输入输出设备，我们惊讶地发现，分析机的组成部分和现在冯·诺依曼架构所要求的五大部件一模一样！ 巴贝奇另一大了不起的创举就是将 穿孔卡片（punched card） 引入了计算机器领域，用于控制数据输入和计算，从那时起，到第一台电子计算机诞生为止，期间几乎所有的数字计算机都使用了穿孔卡片。 [图片上传失败…(image-14c434-1594826100047)] 整个分析机就是在类似这样的齿轮和拉杆作用下实现可编程运算的：先从数据卡片读入数据到存储器，再将存储器中的数据传输到运算器，运算器算完后又将数据传回存储器。 可惜的是，巴贝奇穷其一生也没能真正把分析机做出来，留给后世的又是一台模型机和两千多张图纸，以及这样一段遗言： 「如果一个人不因我一生的借鉴而却步，仍然一往直前制成一台本身具有全部数学分析能力的机器……那么我愿将我的声誉毫不吝啬地让给他，因为只有他能够完全理解我的种种努力以及这些努力所得成果的真正价值。」 伦敦科学博物馆·分析机设计图纸&amp;模型机： 穿孔时代的到来 | 制表机从 1790 年开始，美国每 10 进行一次人口普查。百年间，随着人口繁衍和移民的增多，从 1790 年的 400 万不到，到 1880 年的 5000 多万，人口总数呈爆炸式地增长。 不像现在这个的互联网时代，人一出生，各种信息就已经电子化、登记好了，甚至还能数据挖掘，你无法想象，在那个计算设备简陋得基本只能靠手摇进行四则运算的 19 世纪，千万级的人口统计就已经成了当时政府的 “不能承受之重”。 1880 年开始的第 10 次人口普查，历时 8 年才最终完成，也就是说，他们在休息两年之后就要开始第 11 次普查了，而这一次普查，需要的时间恐怕要超过 10 年，那第 12 次、13 次呢？本来就是 10 年一次的统计，如果每次耗时都在 10 年以上，这件事情就变得没有意义了。 这可愁煞了当时的人口调查办公室，他们决定面向全社会招标，寻求能减轻手工劳动、提高统计效率的发明。正所谓机会都是给有准备的人的，一位毕业于哥伦比亚大学的年轻人 赫尔曼·霍尔瑞斯 （Herman Hollerith） 带着他在 1884 年申请的专利从众多方案中脱颖而出。 制表机他发明的机器叫 制表机 （tabulator/tabulating machine），顾名思义，就是专门用来制作数据统计表的机器。制表机主要由示数装置、穿孔机、读卡装置和分类箱组成。 示数装置包含 4 行、10 列共 40 个示数表盘，每个盘面被均匀地分成 100 格，并装有两根指针，和钟表十分相像，“分针” 转一圈可计 100，“时针” 转一圈则计 10000。可见，整个示数装置可以表达很庞大的数据。 制表机的工作是围绕穿孔卡片展开的：操作员先使用穿孔机制作穿孔卡片，再使用读卡装置识别卡片上的信息，机器自动完成统计并在示数表盘上实时显示结果，最后，将卡片投入分类箱的某一格中，进行分类存放，以供下次统计使用。 穿孔卡片的应用此前的某一天，霍尔瑞斯正在火车站排队检票，目光不经意落到检票员手中咔咔直响的打孔机上。他发现，检票员会特意根据乘客的性别和年龄段，在车票的不同地方打孔。越来越多的人过检，他进一步确认了这个规律。一个灵感朝他袭来：如果有一张更大的卡，上面有更多的位置可以打孔，就可以用来表示更多的身份信息，包括国籍、人种、性别、生日等等。 这就是用在 1890 年人口普查中的穿孔卡片，一张卡片记录一个居民的信息。卡片设计长约 18.73cm，宽约 8.26cm，正好是当时一张美元纸币的尺寸，因为霍尔瑞斯直接用财政部装钱的盒子来装卡片。 卡片设有 300 多个孔位，与雅卡尔和巴贝奇的做法一样，靠每个孔位打孔与否来表示信息。尽管这种形式颇有几分二进制的意味，但当时的设计还远不够成熟，并没有用到二进制真正的价值。举个例子，我们现在一般用 1 位数据就可以表示性别，比如 1 表示男性，0 表示女性，而霍尔瑞斯在卡片上用了两个孔位，表示男性就其中一处打孔，表示女性就在另一处打孔。其实性别还凑合，表示日期时浪费得就多了，12 个月需要 12 个孔位，而常规的二进制编码只需要 4 位。当然，这样的局限也与制表机中简单的电路实现有关。 细心的读者可能发现卡片的右下角被切掉了，那不是残缺，而是为了避免放反而专门设计的，和现在的二维码只有 3 个角是一个道理。 这类实用的细节设计在穿孔机上表现得更为出色。下图为一位操作员正在使用穿孔机给卡片打孔的情景，她并不需要在卡片上吃力地搜寻孔位，而是直接对着孔距更大的操作面板打孔，一根杠杆将两者的孔位一一对应。操作面板还做成了弧形，颇有一分如今人体工程学键盘的风姿。 在制表机前，穿孔卡片（或纸带）多用于存储指令而不是数据。比较有代表性的，一是雅卡尔提花机，用穿孔卡片控制经线提沉；二是自动钢琴，用穿孔纸带控制琴键压放。美剧《西部世界》中，每次故事循环的开始，都会给一个自动钢琴的特写，弹奏起看似宁静安逸、实则诡异违和的背景乐。 是霍尔瑞斯将穿孔卡片作为 数据存储介质 开来，并开启了一个崭新的 数据处理纪元。后来人们也把这类卡片称为霍尔瑞斯卡片，穿孔卡片和穿孔纸带作为输入输出载体，统治了计算领域整整一个世纪。 单元记录时代在制表机的高效运转下，1890 年的人口普查只花了 6 年时间。1896 年，霍尔瑞斯成立制表机公司（The Tabulating Machine Company）并不断改进自己的产品，先后与英国、意大利、德国、俄罗斯、澳大利亚、加拿大、法国、挪威、美国波多黎各、古巴、菲律宾等多个国家和地区合作开展了人口普查。 到 1914 年，制表机公司每天生产的穿孔卡片多达 200 万张。不多久，一些竞争对手逐渐起家，历史迎来了繁荣的数据处理时代。它们的产品也不再局限于人口普查，逐渐扩展到会计、库存管理等一些同样需要跟大数据打交道的领域，这些机器作为制表机的后裔被统称为单元记录设备（unit record equipment）。 围绕穿孔卡片的制卡、读卡、数据处理和卡片分类是它们的标准功能，穿孔机、读卡器、分类器是它们的标准配置。这些部件的自动化程度越来越高，比如手动的读卡装置很快被自动读卡机所取代，读卡速度从每分钟 100 张逐步提高至每分钟 2000 张。随着识别精度的提高，卡片的孔距也越来越小，具有 80～90 列孔位的卡片成为主流，有些卡片的孔位甚至多达 130 列。 机器的功能也逐渐强大，不再只是简单地统计穿孔数目，减法、乘法等运算能力陆续登场。1928 年，哥伦比亚大学的科学家们甚至用单元记录设备计算月球的运行轨迹，他们在 50 万张卡片上打了 2000 万个孔，彰显着单元记录设备的无限潜力。 机器的电路实现越来越复杂，但同时也越来越通用。1890 年所用的那台制表机的 线路是固定的，遇到新的统计任务，改造起来十分麻烦。 1906 年，霍尔瑞斯便引入了接插线板（plugboard）——一块布满导电孔的板卡，可通过改变导线插脚在板上的位置改变线路逻辑。试想一下，接插线板的内部已经布好了具有各种功能的线路，但它们都处在断开状态，各自连接着接插线板上的某两个孔位，像一窝嗷嗷待哺的小鸟长大着嘴巴，外部的导线就像美味的虫子，当虫子的头尾分别与小鸟的上喙和下喙接触，线路就被导通，这只小鸟就开始工作了。如此，每次使用就可以激活不同的 “小鸟”，从而完成不同的任务。这已经是一种可编程性的体现。 1911 年，制表机公司与另外 3 家公司合并成立 CTR 公司 （Computing-Tabulating-Recording Company），制表机公司作为其子公司继续运营到 1933 年。 1924 年，CTR 更名为 国际商业机器公司（International Business Machines Corporation），就是现在大名鼎鼎的 IBM 公司。可见，在如今众多年轻的 IT 公司中，拥有百年历史的 IBM 是位当之无愧的前辈，它完整地参与和见证了整个现代计算机的发展史。IBM 保持了制表机公司在单元记录市场的龙头地位，到 1955 年，其每天生产的穿孔卡片多达 7250 万张。 1937 年开始，单元记录设备逐步电子化，与电子计算机的界线渐渐模糊，并最终为后者让路。随着 1976 年 IBM 一型最核心的单元记录产品的停产，短暂的单元记录时代也宣告谢幕，它仿佛是电子计算时代来临前的预演和铺垫，许多设计被沿用下来，比如穿孔卡片和接插线板。 有趣的是，即使电子计算机逐渐普及，许多机构由于用惯了单元记录设备，迟迟不愿更换，少数机构甚至一直用到了 21 世纪。 一句话总结编程能够帮助我们解决一些非常实际的问题，用一种非常酷的方式。 感兴趣也可以扩展阅读一下：改变世界的代码行 Part 2. 二进制和 CPU 原理 | 编码中蕴藏的智慧 原文地址：「MoreThanJava」一文了解二进制和CPU工作原理 原来，我们是这样计数的在讨论「二进制」和「CPU 如何工作」之前，我们先来讨论一下我们生活中最稀疏平常的 数字，我们与之频繁地打交道：一个约定的时间、一件商品的价格、一个人的身高….却很少有人细细想过，这些数字是如何表达出来的？为什么你理所当然地把 1024 理解为「一千零二十四」而不是别的含义？ 也许你从未想过，在这简单的记数中，沉淀着人类的大智慧。 一进制计数法早在数字的概念产生之前，人类就学会了使用树枝、石子、贝壳等自然界随处可见的小物件表示猎物的、果实的、部落人口的数量。比如在某个角落堆上一堆石子，每打到 1 只猎物，就扔 1 颗石子进去，每吃掉 2 只猎物，就从中取走 2 颗石子。他们并不在意石子的总数，只是时不时地瞅一眼，心底大致有数。 其实这是一种最朴素的记数方式，数学家称之为 一进制记数法（unary numeral system）。我们把它符号化一下，比如用斜杠 / 来表示： 1 就是 /； 2 就是 //； 4 就是 ////； 好像没毛病，我们平时掰手指用的就是这种记数法，但数字一大，场面就要失控了。 符值相加记数法为了解决记录大数的问题，于是我们得发明一些其他符号来表示更大的数值，比如用横杠 - 表示 10，用十字 + 表示 100。那么： 16 就是 -//////; 32 就是 ---//; 128 就是 +--////////; 漂亮….这种靠符号类型和符号数量表示数字的方法被称为 符值相加记数法（sign-value notation），古埃及和古罗马用的都是它，只不过符号各不相同。 古埃及的记数符号： 1 10 100 1000 10000 100000 1000000 1024 在古埃及就写作： 你会发现，符值相加记数法的一大优点是，符号的顺序可以任意打乱，数字含义不受影响。我国藏族曾用石子表示 1、木棍表示 10、果核表示 100、蚕豆表示 1000、瓦片表示 10000，那么，当你把 1 颗蚕豆、2 根木棍和 4 颗石子胡乱地攥在手里，别人依然知道它们是 1024。 古罗马的做法略有不同，他们对五进制情有独钟： 1 5 10 50 100 500 1000 I V X L C D M 这些符号沿用至今，想必大家（至少对前 3 个）都比较熟悉，许多钟表仍保留着使用罗马数字的习惯，1~12 分别表示为：I、II、III、IV、V、VI、VII、VIII、IX、X、XI、XII。你会发现，罗马记数法是符值相加记数法的变种，因为它不光「相加」，还「相减」。这种方式就不允许符号乱序了，IV 和 VI 表示的是不同的数字。 那罗马人何苦要使用这种更复杂的记数法呢？无非是为了读写方便。同样表示 9，IX 比 VIIII 更简洁。 其实有一种更好使的方法——用另外一些列符号来表示符号的数量。比如用 A 表示 1 个符号，用 B 表示 2 个符号，以此类推，用 I 表示 9 个符号。 如此，上文表示 256 的 ++-----////// 就可以写作 B+E-F/。你一定感觉莫名其妙，这种写法哪里方便了。其实中文的数字表示就是这种形式，只不过我们用得太习惯了，以至于没有发现。 在中文中，个、十、百 代替了 /、-、+，而 一、二、三 代替了 A、B、C。256 就写作 二百五十六个，个 比较累赘，我们通常把它省略了。 其实像日语、英语用的也同样是这种记数法，简洁、优雅。 美中不足的是，这种形式虽便于读写，却不便于计算。中国古人为算筹和算盘这类经典算具搭建起广阔的舞台，却没给笔算留出一席之地。想象一下，如果让你把这些汉字写在草稿纸上，列个竖式，你的内心一定非常别扭。 位值制记数法公元5世纪，印度数学家阿耶波多（Aryabhata 476–550）创立了现在广泛使用的 位值制记数法（positional notation/place-value notation），该记数法使用的主要符号，是同为印度人发明的阿拉伯数字：0、1、2、3、4、5、6、7、8、9。 与符值相加记数法类比，位值制中的 1、2、3 代替的是 A、B、C，那 /、-、+ 呢？是 靠阿拉伯数字的位置来表示的。众所周知，最右位相当于 /，次右位相当于 -。靠每个位置上的数值来表示数字，故名位值制。 严谨的数学家用一种多项式高度概括了位值制记数法的本质，在十进制中，这个多项式是这样的： 这是一个 n 位十进制数，ai 就是第 i 位上的数值。为便于直观理解，举个 1024 的例子吧： 由于我们熟悉了十进制，这样费心费力的展开可能会让你觉得好笑，但当我们把它推广到其他进制时，这个多项式的价值就体现了出来。n 位 b 进制数的位值制表示： 1024 用二进制怎么表示？ 因此，1024 的二进制写作 10000000000。 除了最普遍的十进制和计算机中的二进制，常见的还有七进制（如 1 周 7 天）、十二进制（如 1 年 12 个月）、十六进制（如古代 1 斤 16 两）、六十进制（如六十甲子）等等，只要有意义，任何进制都可以为你所用。 为什么使用二进制至此，你对「二进制」或许不再那么陌生，它仅仅是数制的一种而已。 可为什么一定是二进制呢？使用人类习惯的十进制不好吗？ 理由一：物理上易于实现计算机依靠电力工作，这也就意味着需要将数字信号映射到电信号，实现这种映射最简单的方法是： 0 - 没有电（0 V） 1 - 有点（5 V） 二进制在技术上最容易实现。这是因为具有两种 稳定状态 的物理器件很多，如门电路的导通与截止、电压的高与低等，而它们恰好可以对应表示 “1” 和 “0” 这两个数码。假如采用十进制，那么就要制造具有 10 种 稳定状态 的物理电路，而这是非常困难的。 理由二：机器可靠性高为什么使用更复杂的数字系统是一个问题？ 假设我们使用三元（3 位数字）数字系统涉及计算机，如果我们具有从 0 V 到 5 V 的电压，那么我们可以进行以下的映射： 0 - 0 V; 1 - 2.5 V; 2 - 5 V; 图片来源：https://pmihaylov.com/intro-binary-numbers/ 看起来合理吧？但是，想象一下，我以 2.5 V 的电压发送了一个数字。但是由于电路中的一些噪声，我在输出端得到 2.3 V 的电压，因此将其视为 0。结果是？ 有人给我发送了 1，但我将其视为 0。数据丢失可是一个非常严重的问题。 使用二进制则可靠得多，由于电压的高和低、电流的有和无等都是一种 质的变化，两种物理状态稳定、分明，因此，二进制码传输的抗干扰能力强，鉴别信息的可靠性高。 为什么计算机系统必须有时钟 图片来源：http://programmedlessons.org/Java9/chap02/ch02_11.html 建立数字系统的目的是 仅在某些时间点测试开/关（二进制）值，这使电线（或其他设备）有时间更换。这就是计算机系统有时钟的原因。 时钟会周期性地进行信号的测量，图中所示的 T1 和 T2 就是可以测量信号的时间点。 时钟利用所有这些时间点来保持同步。更快的时钟意味着每秒可以对电线进行更多次测试，并且整个系统运行得更快。2 GHz 处理器每秒检查二进制值 20 亿次。在这些时间之间，允许值改变并稳定下来。处理器芯片速度越快，每秒可以测试的次数就越多，每秒可以做出的决策就越多。 理由三：运算规则简单数学推导已经证明，对 N 进制数进行算术求和或求积运算，其运算规则各有 N(N+1)/2 种。如采用十进制，则 N=10，就有 55 种求和或求积的运算规则；而采用二进制，则 N=2，仅有 3 种求和或求积的运算规则，以上面提到的加法为例： 0+0=0，0+1=1 (1+0=1)，1+1=10 因而可以大大简化运算器等物理器件的设计。 理由四：逻辑判断方便采用二进制后，仅有的两个符号 “1” 和 “0” 正好可以与逻辑命题的两个值 “真” 和 “假” 相对应，能够方便地使用逻辑代数这一有力工具来分析和设计计算机的逻辑电路。 虽然在 1950 年代就造出了更加高效的三元计算机，但在效率和复杂度的取舍上，始终抵不过二进制。二进制仍然在当今世界中长期存在。 CPU 的实际工作方式简单演示上面我们了解到计算机以二进制的形式运行，它们只有两种状态：开（1）和关（0），为了执行二进制计算，我们需要采用一种特殊的电子元器件，称为 「晶体管」。暂时我们把它理解为一种开关吧，通电就打开，没电流通过就关闭。 利用「开关」搭建逻辑电路我们知道，给电灯通上电，它就会亮： 于是，结合上开关，我们就能搭建出最基础的 与门 和 或门。 与门 该电路的逻辑是：只有当 A 和 B 同时开启时，LED 灯才会亮，也就是认为输出 1，我们可以利用电信号来简单模拟一下： A B Y 0 0 0 1 0 0 0 1 0 1 1 1 或门 该电路的逻辑是：当 A 或者 B 开启时，LED 灯就会亮，也就是认为输出 1，我们可以利用电信号来简单模拟一下： A B Y 0 0 0 1 0 1 0 1 1 1 1 1 其他门类似地，我们可以借助更多的电子元器件来创造出基础的 7 种逻辑门电路： 图片来源：https://www.zhihu.com/question/348237008/answer/843382847 | @Zign 这里需要特别提一下 异或门，我们需要先知道有一种电子元器件可以利用电气特性对 输入取反，也就是说输入 1 则输出 0，输入 0 则输出 1，那么我们就可以 简单模拟 出异或门逻辑电路（实际会更复杂些，这里仅展示出异或的意思）： A&#39; 和 B&#39; 分别表示 A 和 B 开关的反值，从图中我们很容易知道只有当 A、B 只存在一个输入 1 时，整个电路才会输出 1。 利用逻辑门制作简单加法器演示OK，上面我们了解到我们能够利用 “开关” 来模拟逻辑的运算，我们接下来试着还原一个简单的加法运算器是如何实现的： 仅需两个门，就可以完成基本的二进制加法运算。上图是利用 logic.ly 创建的半加法器，A、B 相当于使我们计算的两个数，最后一块相当于是我们的数显芯片，它的功能是根据输入显示数字，从上到下的引脚（也就是图中输入的地方，通常我们这样称呼）分别对应了 20=1、21=2、22=4、23=8 的输入，没有任何输入时显示为 0，如果 引脚 1（对应 20=1）像上图一样有输入，则显示 0 + 1 = 1。 我们来理解一下上方的电路： 如果仅打开一个输入，但不同时打开两个输入，则此处的 XOR 门（异或门）将打开，此时对应输入 引脚 1，显示 数字 1（类似于 1 + 0 和 0 + 1)； 如果两个输入均打开，则 AND 门(与门)将打开，此时对应输入 引脚 2，显示 数字 2（类似于 1 + 1）； 如果没有输入，则 AND 门和 XOR 门都保持关闭，此时显示 数字 0（类似于 0 + 0）； 因此，如果两个都打开，则 XOR 保持关闭，并且 AND 门打开，得出正确的答案为 2： 但这只是最基础的半加法运算器，不是太有用，因为它只能解决最简单的数学问题之一。但如果我们把它们两个与另一个输入连接，就会得到一个完整的加法器： 仔细思考几遍，你就会得知这个三个输入的加法器已经可以计算 3 个二进制数字的加法运算了，我们如法炮制，可以通过连接更多的”进位”来使这个加法器能够运算更多的数，这当然也意味着这个计算链条更长。 大多数其他数学运算都可以加法完成。乘法只是重复加法，减法可以通过一些奇特的位反转来完成，而除法只是重复减法。并且，尽管所有现代计算机都具有基于硬件的解决方案以加快更复杂的操作，但从技术上讲，您可以使用完整的加法器来完成全部操作。 一句话总结编码伴随探索和学习新知的过程，如果愿意，我们能从中获取很多类似于解出一道数学题的乐趣。 Part 3. 机器指令到高级语言 | 站在先驱巨人的肩膀 原文地址：「MoreThanJava」机器指令到汇编再到高级编程语言 机器指令我们已经了解了 二进制和 CPU 的基本原理，知道了程序运行时，CPU 每秒数以亿次、十亿次、百亿次地震荡着时钟，同步执行着微小的 「电子操作」，例如：从内存读取一个字节的数据到 CPU 又或者判断字节中的某一位是 0 还是 1。 CPU 本身有一组 规定好的 可以执行的 「基本动作」（被称为 机器指令）： 读取指令；2. 执行指令；3. 写寄存器； 这几乎就是 CPU 工作的全部了。 这些动作虽然每次只能执行一次，但是每秒可以执行数十亿次，这个数量级的「小操作」累加成为一个大的「有用的操作」。 处理器所做的一切都是基于这些微小的操作！幸运的是，我们已经不再需要了解这些操作的详细信息就可以编写和使用各类程序。诸如 Java 这一类的 「高级语言」 的 目的 就是 将这些微小的电子操作组织成由人类可读的「程序语言」表示的大型有用单元。 尽管机器语言有一些反人类，但至少我们可以用它来来编写代码了，如： 00000001 00000010 00000001 00000100 00000100 00000000 似乎看着这一段儿代码有点迷糊，并且 可读性太差了。 如此你就会感知到 上个世纪 的程序员使用 打孔卡片： 使用 纸带： 甚至是 直接插拔线路 or 按下开关： 是一件多么硬核的事情… 汇编语言PU 的指令都是 二进制 的，这显然对于人类来说是 不可读 的。为了解决二进制指令的可读性问题，工程师将那些指令写成了 八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。 很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是 用标签 表示。 这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为 汇编语言。 汇编语言演示举个简单的例子，我们需要计算： (1 + 4) * 2 + 3 我们按照 「后缀表示法」 进行一下转换： 1，4，+，2，*，3，+ 我们平常使用的方法是 「中缀表示法」，也就是把计算符号放中间，例如 1 + 3，后缀则是把符号放最后，例如 1, 3, +。 这样做的好处是没有先乘除后加减的影响，也没有括号，直接运算就行了。（例如 1, 3, +，先把 1 和 3 保存起来碰到 + 知道是加法则直接相加） OK，我们从头开始使用汇编语言来编写一下程序，首先第一步：把 1 保存起来（放入寄存器）： MOV 1 之后是 4, +，那就直接加一下： ADD 4 然后是 2, *，那就直接乘一下（SHL 是向左移动一位的意思，二进制中左移一个单位就相当于乘以 2，例如 01 表示 1，而 10 则表示 2）： SHL 0 最后是 3, +，再加一下： ADD 3 完整程序如下： MOV 1 ADD 4 SHL 0 ADD 3 这似乎看起来比 00001111 这样的二进制要好上太多了！程序员们感动到落泪： 高级语言摆脱了 二进制，我们有了更可读的 汇编语言，但仍然十分繁琐和复杂，每一条汇编指令代表一个基本操作，例如：「从内存 x 位置获取一个数字并放入寄存器 A」、「将寄存器 A 中的数字添加到寄存器 B 的数字上」。这样的编程风格既费时又容易出错，并且一旦出错还很难发现。 例如，我们来看一看 「1969 年阿波罗 11号登月计划」 用来 防止登月舱计算机耗尽自身资源 的 BAILOUT 代码： POODOO INHINT CA Q TS ALMCADR TC BANKCALL CADR VAC5STOR # STORE ERASABLES FOR DEBUGGING PURPOSES. INDEX ALMCADR CAF 0 ABORT2 TC BORTENT OCT77770 OCT 77770 # DONT MOVE CA V37FLBIT # IS AVERAGE G ON MASK FLAGWRD7 CCS A TC WHIMPER -1 # YES. DONT DO POODOO. DO BAILOUT. TC DOWNFLAG ADRES STATEFLG TC DOWNFLAG ADRES REINTFLG TC DOWNFLAG ADRES NODOFLAG TC BANKCALL CADR MR.KLEAN TC WHIMPER 出处：改变世界的代码行 - https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX 似乎不太容易读的样子… 阿波罗登月计划的源代码在 Github 上已经公开，有兴趣的可以去下方链接膜拜一下（可以去感受一下当时程序员的工程能力）： https://github.com/chrislgarry/Apollo-11 另外附一下当时代码的设计负责人 Margaret Heafield Hamilton（女程序员）和完成的堆起来跟人一样高的代码量： 第一个高级语言：FORTRAN当 John Backus 在 1950 年以一名科学程序员的身份加入 IBM 时，已经可以使用诸如 ADD 之类的助记词代替数字代码来编写程序，也就是我们的汇编语言。这使编程变得容易一些，但是即使是一个简单的程序也需要数十次操作，并且仍然很难找到错误。 巴克斯认为，应该有可能创建一种编程语言，使一系列计算可以用类似于数学符号的形式来表达。然后，使用特定的翻译程序（以今天的术语来说是编译器）可以将其转换为计算机可以理解的数字代码。 Backus 在 1953 年向他的经理提出了这个想法。他得到了预算，并被鼓励雇用一个小团队来测试该想法的可行性。三年后，该团队发布了一本手册，其中描述了 IBM Mathematical Formula Translating System（简称 FORTRAN）。不久之后， IBM 向 IBM 704 的用户提供了第一个 FORTRAN 编译器。 Backus 和他的团队创造了世界上第一种高级编程语言。科学家和工程师将不再需要将其程序编写为数字代码或冗长的助记符。 FORTRAN 代码演示下面演示计算并输出 8 * 6 的代码实例： program VF0944 implicit none integer a, b, c a= 8 b= 6 c= a*b print *, 'Hello World, a, b, c= ', a, b, c end program VF0944 对比汇编代码，是不是看上去要清晰（人类可读）多了呢？ FORTRAN 的意义FORTRAN 的问世在计算机史上具有划时代的意义，它使计算机语言从原始的低级汇编语言走出来，进入了更高的境界，使得 计算机语言不再是计算机专家的专利，使广大的工程技术人员有了进行计算机编程的手段。 由此计算机更快地深入到了社会之中，它在工业部门中初露头角，更是在火箭、导弹、人造地球卫星的设计中大显身手，因此有人称 FORTRAN 语言使计算机的工业应用成了可能，是推动第二次世界大战以后西方工业经济复苏和进入第二次工业革命的无形力量，是 “看不见的蒸汽机”。 一句话总结计算机先驱们已经为我们架设好了计算机的世界，站在先驱巨人们的肩膀，我们如今很容易也可以看得更高和更远。 Part 4. 构建自己独有的程序(世界) 图片来源自：https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX 编码的乐趣有很多，把自己的想法动手实践就是其中一个。 例如网友玩儿游戏活动需要不停点鼠标，于是写了一个鼠标连点器： 例如给自己心爱的妹子写一个恋爱纪念网站： 例如给 FlappyBird 加一个强化学习算法让它自己学习如何飞行：(图示已经能自己飞 4527 步了) 例如网友自己写的文言文语言：(使用文言文写代码) // HelloWorld 程序演示 吾有一數。曰三。名之曰「甲」。 為是「甲」遍。 吾有一言。曰「「問天地好在。」」。書之。 云云。 运行输出： 問天地好在。 問天地好在。 問天地好在。 一句话总结我们可以动手通过编程把我们的很多想法付诸于实现 (前提是不断探索和学习)，并在迎接挑战和最终实现的过程中获得无限的乐趣。 小总结总体而言，IT 是令人兴奋的。 素有「软件吞噬世界」的说法，我们也正生活在计算机当道的世界。 并且编程并不是每个人都具备的技能，借助技术，一切皆有可能，并且现在互联网时代比以往都更有机会学习和创建「自己的世界」。 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 3：构建程序逻辑的方法","slug":"「MoreThanJava」Day-3：构建程序逻辑的方法","date":"2020-07-05T11:33:00.000Z","updated":"2020-12-09T04:39:20.826Z","comments":true,"path":"2020/07/05/morethanjava-day-3-gou-jian-cheng-xu-luo-ji-de-fang-fa/","link":"","permalink":"http://www.wmyskxz.com/2020/07/05/morethanjava-day-3-gou-jian-cheng-xu-luo-ji-de-fang-fa/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 分支结构 图片来源：http://www.jituwang.com/vector/201512/569157.html 迄今为止，我们写的 Java 代码都是一条一条语句顺序执行的，这种代码结构通常称之为 顺序结构。 然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是获得 1000 分，如果分数到达则进入下一关，如果未到达则 “Game Over”： 这里就产生了两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为 「分支结构」 或 「选择结构」。 「是否进入下一关」这样的决策似乎很小，但是在编程中，复杂的决策是由许多这种小的决策组成的。下面是实现是否进入下一关的程序演示： import java.util.Scanner; public class Tester { public static void main(String[] args) { Scanner scan = new Scanner(System.in); String answer; System.out.print(\"玩家是否达到 1000 分?(Y or N): \"); answer = scan.nextLine(); if (\"Y\".equals(answer)) { System.out.println(\"进入下一关\"); // true branch } else { System.out.println(\"Game Over\"); // false branch } } } 程序首先提醒用户用单一的字符 Y 或 N 来回答： System.out.print(\"玩家是否达到 1000 分?(Y or N): \"); 然后使用 Scanner 类来获取用户的输入： answer = scan.nextLine(); 然后使用 if 关键字来判断用户输入的字符是否等于 Y： if (\"Y\".equals(answer)) 如果相等则进入 true branch，否则进入 false branch。 缩进： 这里 if 下方的缩进是为了让用户更容易看到程序的逻辑，编译器将忽略掉这些缩进。 合理的缩进和程序布局很重要，没有适当的距离和缩进，看程序的逻辑有时会稍显困难。您也期望尽可能清晰地表明程序在做什么不是吗？ if 条件语句在 Java 中，要构造分支结构可以使用 if、else 关键字。 if 语句的基本语法是： if (条件) { // 条件满足时执行的语句 } 当条件满足时，则会执行 if 语句中的代码块儿，否则执行 if 语句块后面的代码。 例如： public class Tester { public static void main(String[] args) { int n = 70; if (n >= 60) { System.out.println(\"及格了\"); } System.out.println(\"END\"); } } 尽管当 if 语句块只有一行语句时，可以省略花括号 {}： if (n >= 60) System.out.println(\"及格了\"); 当这并不是一个好主意。 假设某个时候，突然想给 if 语句块增加一条语句时： public class Tester { public static void main(String[] args) { int n = 50; if (n >= 60) System.out.println(\"及格了\"); System.out.println(\"恭喜你\"); // 注意这条语句不是if语句块的一部分 System.out.println(\"END\"); } } 由于使用缩进格式，很容易把两行语句都看成 if 语句的执行块，但实际上只有第一行语句是 if 的执行块。 在使用 git 这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。(事实上，你使用 IDEA 的自动排版代码的功能会帮你自动还原成有花括号的写法，快捷键「ctrl + alt + l」) else 语句if 语句还可以编写一个 else { ... }，当条件判断为 false 时，将执行 else 的语句块： public class Tester { public static void main(String[] args) { int n = 70; if (n >= 60) { System.out.println(\"及格了\"); } else { System.out.println(\"挂科了\"); } System.out.println(\"END\"); } } 修改上面代码的 n 值，观察 if 条件为 true/ false 时，程序执行的语句块。 注意，else 不是必须的。 还可以用多个 if ... else if ... 串联。例如： public class Tester { public static void main(String[] args) { int n = 70; if (n >= 90) { System.out.println(\"优秀\"); } else if (n >= 60) { System.out.println(\"及格了\"); } else { System.out.println(\"挂科了\"); } System.out.println(\"END\"); } } 串联的效果其实相当于： if (n >= 90) { // n >= 90为true: System.out.println(\"优秀\"); } else { // n >= 90为false: if (n >= 60) { // n >= 60为true: System.out.println(\"及格了\"); } else { // n >= 60为false: System.out.println(\"挂科了\"); } } 注意顺序和临界条件在串联使用多个 if 时，要特别注意判断顺序。观察下面的代码： public class Tester { public static void main(String[] args) { int n = 100; if (n >= 60) { System.out.println(\"及格了\"); } else if (n >= 90) { System.out.println(\"优秀\"); } else { System.out.println(\"挂科了\"); } } } 执行发现，n = 100 时，满足条件 n &gt;= 90，但输出的不是 &quot;优秀&quot;，而是 &quot;及格了&quot;，原因是 if 语句从上到下执行时，先判断 n &gt;= 60 成功后，后续 else 不再执行，因此，if (n &gt;= 90) 没有机会执行了。 正确的方式是按照判断范围从大到小依次判断： // 从大到小依次判断： if (n >= 90) { // ... } else if (n >= 60) { // ... } else { // ... } 或者改写成从小到大依次判断： // 从小到大依次判断： if (n &lt; 60) { // ... } else if (n &lt; 90) { // ... } else { // ... } 使用 if 时，还要特别注意边界条件。例如： public class Tester { public static void main(String[] args) { int n = 90; if (n > 90) { System.out.println(\"优秀\"); } else if (n >= 60) { System.out.println(\"及格了\"); } else { System.out.println(\"挂科了\"); } } } 假设我们期望 90 分或更高为 “优秀”，上述代码输出的却是 “及格”，原因是 &gt; 和 &gt;= 效果是不同的。 Part 2. 循环结构 图片引用自：https://www.zlovezl.cn/articles/two-tips-on-loop-writing/ 顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次，就需要使用循环结构。 Java 中有三种主要的循环结构： while 循环； do...while 循环； for 循环 (在 Java 5 中还引入了一种主要用于数组的增强型 for 循环)； while 循环while 是最基本的循环，它的结构为： while ( 布尔表达式 ) { // 循环内容 } 只要布尔表达式为 true，循环就会一直执行下去。 实例public class Test { public static void main(String args[]) { int x = 10; while (x &lt; 20) { System.out.println(\"value of x : \" + x); x++; } } } 以上实例编译运行结果如下： value of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 do…while 循环对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 do { // 代码语句 } while (布尔表达式); 注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。 实例public class Test { public static void main(String args[]) { int x = 10; do { System.out.println(\"value of x : \" + x); x++; } while (x &lt; 20); } } 以上实例编译运行结果如下： value of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 for 循环虽然所有循环结构都可以用 while 或者 do...while 表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for 循环执行的次数是在执行前就确定的。语法格式如下： for(初始化; 布尔表达式; 更新) { // 代码语句 } 关于 for 循环有以下几点说明： 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。 执行一次循环后，更新循环控制变量。 再次检测布尔表达式。循环执行上面的过程。 实例public class Test { public static void main(String args[]) { for (int x = 10; x &lt; 20; x = x + 1) { System.out.println(\"value of x : \" + x); } } } 以上实例编译运行结果如下： value of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 您可以再 IDEA 中快速输入 fori 关键字来快速创建 for 循环的基本结构 控制循环break 关键字break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 实例public class Test { public static void main(String args[]) { int[] numbers = {10, 20, 30, 40, 50}; for (int x : numbers) { // x 等于 30 时跳出循环 if (x == 30) { break; } System.out.print(x); System.out.print(\"\\n\"); } } } 以上实例编译运行结果如下： 10 20 continue 关键字continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 实例public class Tester { public static void main(String args[]) { int[] numbers = {10, 20, 30, 40, 50}; for (int x : numbers) { if (x == 30) { continue; } System.out.print(x); System.out.print(\"\\n\"); } } } 以上实例编译运行结果如下： 10 20 40 50 Part 3. 构造程序逻辑 图片来源：http://www.mzh.ren/machine-learning-3.html 虽然迄今为止我们学习的内容只是 Java 的冰山一角，但是这些内容已经足够我们来构建程序中的逻辑。 对于编程语言的初学者来说，在学习了 Java 的核心语言元素 （变量、类型、运算符、表达式、分支结构、循环结构等） 之后，必须做的一件事情就是尝试用所学知识去解决现实中的问题，换句话说就是锻炼自己把用人类自然语言描述的算法 （解决问题的方法和步骤） 翻译成 Java 代码的能力，而这件事情必须通过大量的练习才能达成。 我们在这一 Part 为大家整理了一些经典的案例和习题，希望通过这些例子，一方面帮助大家巩固之前所学的 Java 知识，另一方面帮助大家了解如何建立程序中的逻辑以及如何运用一些简单的算法解决现实中的问题。 经典的例子题目一：寻找水仙花数 说明：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个 3 位数，该数字每个位上数字的立方之和正好等于它本身，例如：13 + 53+ 33=153。 public class Tester { public static void main(String[] args) { findAllDaffodilNumberAndPrint(); } /** * 查找所有的水仙花数并打印 */ public static void findAllDaffodilNumberAndPrint() { for (int num = 100; num &lt; 1000; num++) { int low = num % 10; int mid = num / 10 % 10; int high = num / 100; // Math.pow(x, 3) 相当于求 x 的 3 次方 if (num == Math.pow(low, 3) + Math.pow(mid, 3) + Math.pow(high, 3)) { System.out.println(num); } } } } 题目二：百钱百鸡问题 说明：百钱百鸡是我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡 5 元一只，母鸡 3 元一只，小鸡 1 元三只，用 100 块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？ public class Tester { public static void main(String[] args) { getResultAndPrint(); } /** * 获取百钱百鸡的结果并输出 */ public static void getResultAndPrint() { for (int cockNum = 0; cockNum &lt; 20; cockNum++) { for (int henNum = 0; henNum &lt; 33; henNum++) { int chickNum = 100 - cockNum - henNum; if (5 * cockNum + 3 * henNum + chickNum / 3 == 100) { System.out .println(\"公鸡：\" + cockNum + \"只, 母鸡：\" + henNum + \"只, 小鸡：\" + chickNum + \"只\"); } } } } } 上面使用的方法叫做 穷举法，也称为 暴力搜索法，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。 这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，而且问题的解如果存在，这种方法一定能够找到它。 要点回顾 分支结构 if 和 else 的使用和实例； 循环结构 while、do...while 和 for 循环的使用和实例； 控制循环的 break 和 continue 实例； 构建程序逻辑的练习； 练习练习 1：百分之成绩转换成等级制成绩 要求： 如果输入成绩在 90 分以上 (含 90 分) 输出 A； 80 ~ 90 分 (不含 90) 输出 B； 70 ~ 80 分 (不含 80) 输出 C； 60 ~ 70 分 (不含 70) 输出 D； 60 分以下输出 E； 参考答案： import java.util.Scanner; public class Tester { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int score = scan.nextInt(); if (score >= 90) { System.out.println(\"A\"); } else if (score >= 80) { System.out.println(\"B\"); } else if (score >= 70) { System.out.println(\"C\"); } else if (score >= 60) { System.out.println(\"D\"); } else { System.out.println(\"E\"); } } } 练习 2：输入三条边长，如果能构成三角形就计算周长和面积参考答案： import java.util.Scanner; public class Tester { public static void main(String[] args) { Scanner scan = new Scanner(System.in); double a = scan.nextDouble(); double b = scan.nextDouble(); double c = scan.nextDouble(); if (a + b > c &amp;&amp; a + c > b &amp;&amp; b + c > a) { double perimeter = a + b + c; System.out.println(\"三角形周长为：\" + perimeter); double p = (a + b + c) / 2; double area = Math.sqrt(p * (p - a) * (p - b) * (p - c)); System.out.println(\"三角形面积为：\" + area); } else { System.out.println(\"不能构成三角形！\"); } } } 练习 3：打印如下所示的三角形图案* ** *** **** ***** * ** *** **** ***** * *** ***** ******* ********* 参考答案： import java.util.Scanner; public class Tester { public static void main(String[] args) { System.out.println(\"请输入行数：\"); Scanner scanner = new Scanner(System.in); int row = scanner.nextInt(); for (int i = 0; i &lt; row; i++) { for (int j = row - i - 1; j &lt; row; j++) { System.out.print(\"*\"); } // 换行 System.out.println(); } for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; row; j++) { if (j &lt; row - i - 1) { System.out.print(\" \"); } else { System.out.print(\"*\"); } } // 换行 System.out.println(); } for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; row - i - 1; j++) { System.out.print(\" \"); } for (int j = 0; j &lt; 2 * i + 1; j++) { System.out.print(\"*\"); } // 换行 System.out.println(); } } } 自取资料优秀入门资料选取 Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html Java零基础入门教程包含面向对象 - https://study.163.com/course/courseMain.htm?courseId=1003108028 网易云课堂 - 顶尖中文大学计算机专业课程体系 - https://study.163.com/curricula/cs.htm TeachYourselfCS-CN (自学计算机科学) - https://github.com/keithnull/TeachYourselfCS-CN C语言中文网 Java 入门系列教程 - http://c.biancheng.net/java/10/ 廖雪峰 Java 教程 - https://www.liaoxuefeng.com/wiki/1252599548343744 注重动手能力的 Java 教程 - https://how2j.cn/ 推荐书籍Java 核心技术·卷 I(原书第 11 版) 推荐理由： 这本书在知识体系完整充实的同时，又比《Thinking in Java》暴风式的知识洗礼来得轻松，新人入门书籍强烈推荐！ 码出高效：Java开发手册 推荐理由： 阿里系出品。从最基础的计算机基础入手，到 Java 的方方面面，加上精美的配图和通俗易懂的解释，是非常适合新手阅读的一本儿关于 Java 的技术书籍。 参考资料 《Java 核心技术 卷I》(第11版) Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html#part02 菜鸟教程 - https://www.runoob.com/java/ C语言中文网 Java 入门系列教程 - http://c.biancheng.net/java/10/ Python 100 天从新手到大师 - https://github.com/jackfrued/Python-100-Days 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 2：变量、数据类型和运算符","slug":"「MoreThanJava」Day-2：变量、数据类型和运算符","date":"2020-07-04T13:48:00.000Z","updated":"2020-12-09T04:39:16.487Z","comments":true,"path":"2020/07/04/morethanjava-day-2-bian-liang-shu-ju-lei-xing-he-yun-suan-fu/","link":"","permalink":"http://www.wmyskxz.com/2020/07/04/morethanjava-day-2-bian-liang-shu-ju-lei-xing-he-yun-suan-fu/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 数据类型 假设您遇到了以下撕碎的纸片，您觉得会是什么意思？ 在不了解上下文的情况下，很难说出 MIX 的含义，它可能是罗马数字 1009，也可以是英语单词 mix 或者别的什么东西。 在不知道上下文的情况下，一串字母没有任何意义。 与一串字母一样，一串 01 的含义取决于如何使用。而决定这一串数据如何使用的方案被称为其 数据类型 (跟文件类型有些类似)。 8 种基本数据类型Java 是一种强类型语言。这意味着必须为每一条数据声明一种类型。在 Java 中共有 8 种基本类型 (primitive type)*，其中 4 种整型、2 种浮点类型、1 种字符类型、1 种表示真值的 boolean *(布尔) 类型。 整型整型被用来表示没有小数部分的数值，允许是负数。Java 提供了 4 种整型，具体内容如下： 类型 存储需求 取值范围 int 4 字节 -2147483648 ~ 2147483647 (刚超过 20 亿，这个数值也就是 232 对半分成正负值，32=4字节*每个字节8位) short 2 字节 -32768 ~ 32767 long 8 字节 -9223372036854775808 ~ 9223372036854775807 byte 1 字节 -128 ~ 127 在通常情况下，int 类型最常用。但如果想要表示整个地球的居住人口，那么就需要使用 long 类型了。byte 和 short 类型主要用于特定的应用场合，例如，底层的文件处理或者存储空间很宝贵时的大数组 (因为节约内存)。 浮点类型浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型，具体内容如下： 类型 存储需求 取值范围 float 4 字节 大约 ±3.40282347E + 38F (大约有效数为 6 ~ 7) double 8 字节 大约 ±1.7976931486231580E + 308 (大约有效数为 15 位) double 表示这种类型的数值精度是 float 类型的两倍 (也有人称 double 为双精度数值)。 浮点数精度问题问一个问题：0.1 + 0.2 = ？ 先别奇怪，在 IDEA 中尝试着输出一下这句话就知道了： System.out.println(0.1 + 0.2); // 输出：0.30000000000000004 0.1 + 0.2 为什么会等于 0.30000000000000004？而不是我们想象中的 0.3？ 这不是因为它们在计算时出现了错误，而是因为浮点数计算标准的要求。 首先我们要明确一点：编程中的浮点数并不能和数学中的小数看做同一个东西。 编程中的浮点数的精度往往都是有限的，单精度的浮点数使用 32 位表示，而双精度的浮点数使用 64 位表示； 数学中的小数系统可以通过引入无限序列….可以表示任意的实数； 请考虑使用 十进制 表示 1/3： 0.3333333333333333.... 如果想要完整地表达 1/3 的精度，那么小数点之后的 3 需要无限地写下去。如果需要让你在一张纸上表达清晰，显然由于纸张大小的限制你无法无限地写下去… 0.1 和 0.2 在 二进制 中同 1/3 在 十进制 中一样，不属于整数的范畴，所以只能用近似值来代替，由于精度的限制 0.1 和 0.2 使用单精度浮点数表示的实际值为：0.100000001490116119384765625 和 0.20000000298023223876953125，把它们相加起来得到的结果与我们在一开始看到的非常相似： 在交易系统或者科学计算的场景中，如果需要更高的精度小数，可以使用具有 28 个有效位数的 decimal 或者直接使用分数，不过这些表示方法的开销也随着有效位数的增加而提高，我们应该按照需要选择最合适的方法。 重新回到最开始的问题 — 0.1 和 0.2 相加不等于 0.3 的原因包括以下两个： 使用二进制表达十进制的小数时，某些数字无法被有限位的二进制小数表示； 单精度和双精度的浮点数只包括 7 位或者 15 位的有效小数位，存储需要无限位表示的小数时只能存储近似值； 在使用单精度和双精度浮点数时也应该牢记它们只有 7 位和 15 位的有效位数。 char 类型char 用来表示单个字符。在 Java 中 char 类型的数据使用 16 位来存储和表示，而许多编程语言则仅用 8 位。 char 类型的字面量值需要用 单引号 括起来。例如：&#39;A&#39; 是编码值为 65 的 字符常量，它与 &quot;A&quot; 不同，&quot;A&quot; 是仅包含字符 A 的 字符串 (String 类型)。 强烈建议：不要在程序中使用 char 类型，除非您确实需要处理 UTF-16 代码单元。 (更多相关资料放入了下面的自取资料，感兴趣可以去阅读一下更多 char 类型的东西，不感兴趣跳过即可…) boolean 类型boolean (布尔) 类型有两个值：false 和 true (注意这两个是布尔类型的字面常量也是保留字)，用来判断逻辑条件是否成立。 对象类型Java 中的所有数据都属于「基本数据类型」或「对象」中的一种。 虽然只有八种基本数据类型，但 Java 有许多满足您需求的相关类型的对象供您使用，例如，表示字符串的 String 类型。 我们会在之后的内容中更多地讨论对象 (因为 Java 是一种面向对象的编程语言)，现在，您需要了解以下信息： 基本数据类型使用少量的固定字节数 (下面会详细介绍)； 只有 8 种基本数据类型，您无法创建新的原始数据类型； 一个对象是一个较大的数据块，可能使用很多字节的内存； 对象类型的数据被称为 类； Java 中已经封装了足够多的类用来满足您各类的需求，您也可以发明新的类来满足程序的特定需求； Part 2. 变量 计算机内存中有数以十亿计的字节用于存储机器指令和数据。 程序运行时，某些内存用于存储机器指令，而另外一些则用于存储数据。后来，当另一个程序运行时，以前保存的机器指令中的某些字节现在可以用来保存数据，而之前保存的数据中的某些字节现在可以保存机器指令。 计算机先驱 约翰·冯·诺依曼 (John von Neumann) 的想法是：使用相同的存储器来存储指令和数据。 回想一下，数据类型是一种使用位模式来表示值的方案。 可以把 变量 视为一个由一个或多个字节组成的小盒子，该盒子可以使用特定的数据类型保存值。 要将值存储在内存中，以后再取回它，则程序必须为每个变量指定一个名称，如 className/ payAmount (变量名采用小驼峰命名法)。 变量随运行程序的需要而变化。当正在运行的程序不再需要变量时，该内存部分可用于其他目的。 声明变量在 Java 中，每个变量都必须有一个类型 (type)。在声明变量时，需要先指定变量的类型，然后是变量名： double salary; int vacationDays; long earthPopluation; boolean finished; 可以看到，每个变量都以分号 (;) 结束。由于声明是一条完整的 Java 语句，而所有的 Java 语句都以分号结束，所以这里的分号是必须的。 变量命名在 Java 中，变量命名需要遵循以下硬性规定和强烈建议遵守的非硬性规定： 硬性规则 变量名必须是一个以字母开头并由字母或数字构成的序列 (尽管 $ 是合法的，但不要在你自己的代码中使用这个字符，它只用在 Java 编译器或其他工具生成的名字中)； 每一个字符都有意义，且大小写敏感； 不要使用 Java 中的保留字； 《阿里巴巴 Java 开发手册》规则 【强制】 代码中的命名 (所有标识符) 均不能以下划线或美元符号开始，也不能以下划线或美元符号结束；(反例: $name) 【强制] 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式；(反例：DaZhePromotion - 打折) 【强制】 杜绝完全不规范的缩写，避免词不达意；(反例：condition 缩写成 condi) 【推荐】 为了达到代码自解释的目的，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意；(反例：int a; 的随意命名方式) 变量初始化声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。例如，Java 编译器认为下面的语句序列是错误的： int amount; System.out.println(amount); // ERROR -- variable not initialized 要相对一个已经声明过的变量进行赋值，就需要将变量名放在等号 (=) 左侧，再把一个适当取值放在等号的右侧： int amount; amount = 12; 也可以将变量的声明和初始化放在同一行中。例如： int amount = 12; 最后，在 Java 中可以将声明放在代码中的任何地方。 但让变量尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。 变量使用范例我们来使用变量完成两个数的加减乘除： int num1 = 2; int num2 = 3; System.out.println(num1 + num2); System.out.println(num1 - num2); System.out.println(num1 * num2); System.out.println(num1 / num2); Part 3. 运算符 计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java 也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组： 算术运算符; 关系运算符; 位运算符; 逻辑运算符; 赋值运算符; 其他运算符; 算术运算符算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。 表格中的实例假设整数变量 A 的值为 10，变量 B 的值为 20： 实例下面的简单示例程序演示了算术运算符。复制并粘贴下面的 Java 程序并保存为 Test.java 文件，然后编译并运行这个程序： public class Test { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(\"a + b = \" + (a + b)); System.out.println(\"a - b = \" + (a - b)); System.out.println(\"a * b = \" + (a * b)); System.out.println(\"b / a = \" + (b / a)); System.out.println(\"b % a = \" + (b % a)); System.out.println(\"c % a = \" + (c % a)); System.out.println(\"a++ = \" + (a++)); System.out.println(\"a-- = \" + (a--)); // 查看 d++ 与 ++d 的不同 System.out.println(\"d++ = \" + (d++)); System.out.println(\"++d = \" + (++d)); } } 运行结果： a + b = 30 a - b = -10 a * b = 200 b / a = 2 b % a = 0 c % a = 5 a++ = 10 a-- = 11 d++ = 25 ++d = 27 i++ 与 ++i 到底有什么不同？实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。 二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。 关系运算符下表为Java支持的关系运算符。 表格中的实例整数变量 A 的值为 10，变量 B 的值为 20： 实例下面的简单示例程序演示了关系运算符。复制并粘贴下面的 Java 程序并保存为 Test.java 文件，然后编译并运行这个程序： public class Test { public static void main(String[] args) { int a = 10; int b = 20; System.out.println(\"a == b = \" + (a == b)); System.out.println(\"a != b = \" + (a != b)); System.out.println(\"a > b = \" + (a > b)); System.out.println(\"a &lt; b = \" + (a &lt; b)); System.out.println(\"b >= a = \" + (b >= a)); System.out.println(\"b &lt;= a = \" + (b &lt;= a)); } } 运行结果： a == b = false a != b = true a > b = false a < b = true b >= a = true b > 2; /* 15 = 1111 */ System.out.println(\"a >> 2 = \" + c); c = a >>> 2; /* 15 = 0000 1111 */ System.out.println(\"a >>> 2 = \" + c); } } 运行结果： a & b = 12 a | b = 61 a ^ b = 49 ~a = -61 a < 2 = 240 a >> 2 = 15 a >>> 2 = 15>= 2; System.out.println(\"c >>= 2 = \" + c); c >>= 2; System.out.println(\"c >>= 2 = \" + c); c &amp;= a; System.out.println(\"c &amp;= a = \" + c); c ^= a; System.out.println(\"c ^= a = \" + c); c |= a; System.out.println(\"c |= a = \" + c); } } 运行结果： c = a + b = 30 c += a = 40 c -= a = 30 c *= a = 300 c /= a = 1 c %= a = 5 c = 2 = 5 c >>= 2 = 1 c &= a = 0 c ^= a = 10 c |= a = 10 其他运算符条件运算符 (?:)条件运算符也被称为三元运算符。该运算符有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 variable x = (expression) ? value if true : value if false 实例下面的简单示例程序演示了关系运算符。复制并粘贴下面的 Java 程序并保存为 Test.java 文件，然后编译并运行这个程序： public class Test { public static void main(String[] args) { int a, b; a = 10; // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30 b = (a == 1) ? 20 : 30; System.out.println(\"Value of b is : \" + b); // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30 b = (a == 10) ? 20 : 30; System.out.println(\"Value of b is : \" + b); } } 运行结果： Value of b is : 30 Value of b is : 20 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof 运算符使用格式如下： ( Object reference variable ) instanceof (class/interface type) 如果运算符左侧变量所指的对象，是操作符右侧类或接口 (class/interface) 的一个对象，那么结果为真。 下面是一个例子： String name = \"James\"; boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真 要点回顾 Java 是一种强类型语言，任何一种数据都属于 1 种基本类型或者对象类型 (类) 中的一种； 8 种基本数据类型； 为什么引入变量、如何定义使用变量以及变量名的命名规范； Java 中的运算符以及使用实例； 练习获取用户输入 Scannerjava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： Scanner scanner = new Scanner(System.in); 在下面的示例中，我们将使用该类的 nextLine() 方法，该方法用于读取字符串： import java.util.Scanner; // Import the Scanner class class MyClass { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Create a Scanner object System.out.println(\"Enter username\"); String userName = scanner.nextLine(); // Read user input System.out.println(\"Username is: \" + userName); // Output user input } } 输入类型在上面的示例中，我们使用了 nextLine() 用于读取字符串的方法。要阅读其他类型，请查看下表： 引用自：https://www.w3schools.com/java/java_user_input.asp 练习 1：输入圆的半径计算周长和面积参考答案： import java.util.Scanner; public class Tester { public static void main(String[] args) { System.out.println(\"请输入圆的半径：\"); Scanner scanner = new Scanner(System.in); int radius = scanner.nextInt(); // 计算周长和面积 double area = radius * radius * 3.14; double perimeter = 2 * 3.14 * radius; System.out.println(\"该圆的面积为：\" + area); System.out.println(\"该圆的周长为：\" + perimeter); } } 练习 2：输入年份判断是不是闰年提示： 闰年需要满足： 能被 4 整除，并且不能被 100 整除； 或者能被 400 整除； 参考答案： import java.util.Scanner; public class Tester { public static void main(String[] args) { System.out.println(\"请输入年份：\"); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt(); boolean leapYear; boolean divisbleBy4 = year % 4 == 0; boolean notDivisbleBy100 = year % 100 != 0; boolean divisibleBy400 = year % 400 == 0; leapYear = (divisbleBy4 &amp;&amp; notDivisbleBy100) || divisibleBy400; System.out.println(\"该年份是否是闰年：\" + leapYear); } } 自取资料扩展阅读推荐 Java 基本数据类型 | 菜鸟教程 - https://www.runoob.com/java/java-basic-datatypes.html 浮点类型精度深度讨论： 为什么 0.1 + 0.2 = 0.3？ - https://draveness.me/whys-the-design-decimal-and-rational/ 为什么 0.1 + 0.2 = 0.300000004？ - https://draveness.me/whys-the-design-floating-point-arithmetic/#fn:2 IEEE754标准: 浮点数在内存中的存储方式 - https://www.jianshu.com/p/8ee02e9bb57d 为什么Java中char类型不能完整表示一个字符？ - https://fookwood.com/java-string-charset-char 推荐书籍Java 核心技术·卷 I(原书第 11 版) 推荐理由： 这本书在知识体系完整充实的同时，又比《Thinking in Java》暴风式的知识洗礼来得轻松，新人入门书籍强烈推荐！ 码出高效：Java开发手册 推荐理由： 阿里系出品。从最基础的计算机基础入手，到 Java 的方方面面，加上精美的配图和通俗易懂的解释，是非常适合新手阅读的一本儿关于 Java 的技术书籍。 参考资料 Introduction to Computer Science using Java - http://programmedlessons.org/Java9/index.html#part02 Java 运算符 | 菜鸟教程 - https://www.runoob.com/java/java-operators.html 《Java 核心技术 卷I》(第11版) 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Day 1：环境搭建和程序基本结构元素","slug":"「MoreThanJava」Day-1：环境搭建和程序基本结构元素","date":"2020-07-03T09:41:00.000Z","updated":"2021-01-11T09:45:16.318Z","comments":true,"path":"2020/07/03/morethanjava-day-1-huan-jing-da-jian-he-cheng-xu-ji-ben-jie-gou-yuan-su/","link":"","permalink":"http://www.wmyskxz.com/2020/07/03/morethanjava-day-1-huan-jing-da-jian-he-cheng-xu-ji-ben-jie-gou-yuan-su/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 0. 搭建好开发环境 在一切开始之前，我们需要先搭建好我们的 开发环境 (从前文得知 Java 程序的运行需要 JVM，编写 Java 代码需要 IDE)*，或者在您完全准备好之前可以 *暂时使用 在线版本的 Java 环境来运行前面一些内容涉及的简单代码：https://c.runoob.com/compile/10 安装 JDK 并配置环境JVM、JRE 和 JDK 有什么关系？ JVM（Java Virtual Machine，Java 虚拟机）：是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言写作的软件程序。 JRE（Java Runtime Environment，Java 运行环境）：是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。 JDK（Java Development Kid，Java 开发开源工具包）：是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。 这三者的关系是一层层的嵌套关系：JDK &gt; JRE &gt; JVM JDK 包含了 Java 的编译器、调试器等一系列开发工具，所以作为开发人员我们需要安装 JDK，而某一些只需要运行编译好的 Java 程序的服务器则可以只安装 JRE 即可 （极少数情况，通常还是安装 JDK）。 下载安装 JDKJava 程序必须运行在 JVM 之上，所以我们第一件事情就是安装 JDK。我们选择最新的 JDK 14 进行安装： 选择合适自己电脑平台的 JDK 进行下载安装即可： 配置环境Windows平台Mac平台第一步 在 Windows 安装之后需要额外 配置环境变量，首先【右键我的电脑】 → 选择【属性(R)】 → 打开【高级系统设置】：图片引用自：https://www.jikeyuan.cn/index.php/a/174.html 第二步 在【高级】标签下选择【环境变量】，并对环境变量【path】进行编辑操作：图片引用自：https://www.jikeyuan.cn/index.php/a/174.html 第三步 新建环境变量，然后把刚才安装 jdk 的安装路径复制进去，路径截止到 bin 目录：图片引用自：https://www.jikeyuan.cn/index.php/a/174.html 第四步 快捷键【Win + R】输入【cmd】调出 dos 窗口，输入【java -version】进行验证：图片引用自：https://www.jikeyuan.cn/index.php/a/174.html 第一步 打开苹果 dos 窗口，先确认自己使用的 shell 是 zsh 还是 bash，在命令行中输入 echo $SHELL：如果输出 /bin/bash 则为 bash;如果输出结果为 /bin/zsh 则为 zsh。 第二步 根据上面不同的结果 修改 shell 配置文件，若为 bash，则打开 ~/.bash_profile，若为 zsh 则打开 ~/.zshrc，在响应的文件末尾添加以下内容，并保存：export JAVA_HOME=$(/usr/libexec/java_home) 第三步 在 ~/ 目录，命令行执行 source 命令：同样如果是 bash，则执行 source .bash_profile，而如果是 zsh，则执行 source .zshrc，让刚才的修改生效。 第四步 命令行执行 java -version 检查是否配置成功： Java 的不同版本随着 Java 的发展，SUN 公司给 Java 分出了三个不同版本： Java SE(Standard Edition)：标准版，包含标准的 JVM 和标准库； Java EE(Enterprise Edition)：企业版，在 SE 的基础上加了大量的 API 和库，以方便开发 Web 应用、数据库、消息服务等； Java ME(Micro Edition)：是针对嵌入式设备 “瘦身” 之后的 Java SE； 毫无疑问，Java SE 是 Java 平台的核心，而 Java EE 是进一步学习 Web 应用所必须的。 安装 IDEA 开发工具体验记事本编写运行 Java 程序Java 源代码本质上其实就是普通的文本文件，所以理论上来说任何可以编辑文本文件的编辑器都可以作为我们的 Java 代码编辑工具。比如：Windows 记事本、Mac OS X 下的文本编辑、Linux 下的 vi 等。 但是这些简单工具没有「语法的高亮提示」、「自动完成」等功能，这些功能的缺失会 大大降低代码的编写效率。 第一步：新建一个 HelloWorld.java 文件然后输入以下内容并保存： public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World\"); } } 注意： HelloWorld.java 文件名不允许出现空格，以及要保证和第一行 class 后跟着的字符串 HelloWorld 保持一致； 第二步：编译和运行将 Java 源程序编写并保存到文件之后，还需要进行编译才能运行。编译 Java 源程序使用的是 JDK 中的 javac 命令，例如编译上节的 HelloWorld.java，完整命令如下： javac HelloWorld.java 该命令会让 Java 编译器读取 JavaWorld.java 文件的源代码，并把它编译成符合 Java 虚拟机规范的字节码文件 (.class 文件)。 想要运行字节码文件也需要使用 JDK 中的 java 命令，例如运行上面生成的 .class 文件，完整命令如下： java HelloWorld 具体效果如下： 更加智能的 IDEA 尽管能够使用文本编辑器来编写我们的 Java 程序，但效率着实不敢恭维，所以我们一般使用更加先进的 集成开发工具 （俗称 IDE，Integrated Development Environment）。 不仅仅包含更加智能的代码编辑器、编译器、调试器，还有友好的用户界面以及各式各样帮助我们提升效率的插件。 对于效率这方面，下面我们就几个方面简单感受一下。 更友好的代码提示功能不仅仅是基础的关键字的提醒，IDEA 会基于当前的上下文 (也就是基于位于当前代码上下的代码进行分析)，更加智能的进行过滤和提醒： 强大的纠错能力我们总是会犯一些低级错误，比如一不留神打错一个字母，可能找了好久都找不到错误所在，IDEA 的纠错能力也许可以帮到你，看一个例子： 智能提示重构代码如果你写的代码过于复杂，或者有更好的方式来替代你写的代码，那么 IDEA 会给你一个提示，告诉你还可以有更好的方式。如下图： 一些酷炫的操作比如你看我从头写一个 HelloWorld 程序： 这应该比一个一个字符敲快多了吧…(小声bb：文章末尾有教程哦) And More…来一个总结： 验证环境是否安装成功打开【IDEA】新建一个空白的 Java 项目： 右键在【scr】目录新建一个空白的【HelloIDEA】的 Java Class 文件： 然后接下来像我这样操作，来编写一个【HelloIDEA】的 Java 程序： psvm：是 public static void main 的缩写； sout：是 System.out 的缩写； 您在 IDEA 中键入以上单词时会由 IDEA 提示智能快速地完成输入，以此来提升效率； 怕有些同学迷惑，点击左边的绿三角会弹出如下的信息，点击第一个选项就能够运行啦： Part 1. 标识符和保留字 图片来源：https://medium.com/@thiagonascimento/time-to-first-hello-world-11a4735602f2 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 我们来看看刚才我们写的 Hello World 程序。 第一行：public class HelloWorld { 关键字 public：称为 访问修饰符 (access modifier)，用来控制程序的其他部分对这一段代码的访问级别 (这里暂时理解为公用的，之后会更加详细地介绍)； 关键字 class：表明 Java 程序中的全部内容都包含在类中 (之后会花很多功夫来说明类，这里可以仅仅把类理解为程序逻辑的一个容器，程序逻辑定义了应用软件的行为)。 HelloWorld：关键字 class 后面紧跟的是类名，它除了必须跟文件名保持一致外，还应该遵循 Java 类名的命名规范 —— 类名以大写字母开头。如果名字由多个单词组成，每个单词的第一个字母需要大写。 例如：FirstSample 就遵循了 Java 类的命名规范的原则； 这样的 命名方式 被称为 驼峰命名法 (camel case)，首字母是大写的则称为 *大驼峰命名法，首字母小写的则称为 **小驼峰命名法 *(如：firstSample，后续文章会提到的变量就采用这种方式) 类名命名规范： Bad：hello、Good123、Note_Book、_World Good：Hello、Tester、NoteBook 标识符在编程中，某个东西的名称就被称为 标识符，例如上述的类名 HelloWorld。在 Java 中定义标识符存在以下几种规则： 只能由数字、字母、下划线(_)和美元符号($)组成； 第一个字符不能是数字； 标识符内不允许有空格； 不能使用 Java 保留字 (下方有列出 Java 中存在的保留字)； 标识符命名示范： Bad：Lady Luck (坏：标识符内不允许有空格)、x/y *(错误：标识符中不允许使用斜杠)、1stPrize (错误：以数字开头)、abc (坏：没有任何意义)、_name *(坏：不要以 _ 或 $ 开头) Good：userName、StudentManager、NoteBook 保留字保留字就是像 class 这样有特殊含义的标识符，您只能将保留字用于其设定的专属用途 (如 class 除了定义类，您将不能用作其他任何目的)。 在 Java 中存在以下的保留字：(无需记忆，它们中的大部分都或多或少地出现在之后您的编码中.. IDEA 也会有智能的提示) abstract class extends implements null strictfp true assert const false import package super try boolean continue final instanceof private switch void break default finally int protected synchronized volatile byte do float interface public this while case double for long return throw catch else goto native short throws char enum if new static transient Part 2. 程序的基本结构和方法简述 程序基本结构在类的第一个大括号和最后一个大括号之间描述了程序所做的一切： public class ClassName { } 首先，每个源代码文件必须有一个主类 (名字同文件名)，在之后的文章中我们会看到一个源代码文件可能会同时存在几个类的情况发生，暂时不考虑。 在上文程序的第三行：public static void main ( String[] args )，展示了程序在何处开始运行，Java 虚拟机总是从指定类的 main 方法的代码开始执行，因此为了代码能够执行，在类的原文件中必须包含一个 main 方法。 对这一行稍微做一下解释： public：访问修饰符，用来描述该方法的访问权限级别，这里为所有人都能访问； static：保留字，用来定义该方法是一个静态方法； void：用来描述该方法没有任何的返回值； main：方法名； (String[] args)：描述了该方法所接收的参数； 所以刚开始接触的程序结构大概看起来像是下面这样： public class ClassName { public static void main(String[] args) { ...... } } 由于 Java 是大小写敏感 的，所以 main 这个单词不允许任何的修改。(Java 语言规范中规定 main 方法必须声明为 public) 大括号的使用风格曾经引发过许多无意义的争论，以下两种风格，哪一种更好呢？： public class ClassName { } public class ClassName { } 没有答案，虽然对于 Java 编译器来说空白符会被省略，这两种并无差别，但作为开发者的我们，选择 Java 惯用的风格 (第一种) 就好了… println()考虑下面这一段代码，实际上就是上面的 HelloWorld 程序 main 方法中的语句： { System.out.println(\"Hello World！\"); } 一对大括号表示 方法体 的开始与结束，在这个方法中只包含一条语句。跟大多数程序设计语言一样，可以把 Java 中的语句看成是语言中的一个句子。 在 Java 中，每个句子必须用分号结束 (英文分号)。 特别需要说明，回车并不是语句的结束标志，因此，如果需要可以将一条语句写在多行上。 在这里，我们使用了 System.out 这个对象并调用了它的 println 方法 (点号 . 用于调用方法)。它的作用是在屏幕上输出指定的信息。例如，我们想要输出 我没有三颗心脏 则可以这样调用： System.out.println(\"我没有三颗心脏\"); Java 使用方法的通用语法是： object.method(parameters) 这一条语句的作用是在屏幕上输出 Hello World!，这一部分由字符组成的序列 (其中不应该包含引号) 被称为 字符串。它可以包含任何有效字符，包括空格和标点符号。 方法简述方法 是根据语句构建的。程序通常包含许多方法。 我们的示例程序仅包含一种方法 (main 方法)。当然我们还调用了系统帮我们写好的 System.out.println() 方法。 尝试定义自己的方法我们可以试着仿照 main 方法来写一个自己的方法，假设我们想要输出一段心理学三大巨头之一阿德勒的一段话： public static void printAdlerOneQuote() { System.out.println( \"太在意别人的视线和评价，才会不断寻求别人的认可。\" + \"对认可的追求，才扼杀了自由。\" + \"由于不想被任何人讨厌，才选择了不自由的生活方式。\" + \"换言之，自由就是不再寻求认可。\" ); } 有几点需要说明： 方法名采用小驼峰命名法，且尽量保证有意义的命名：如果这里把方法名修改成 abc 似乎就有点儿不知所云了； 一行代码量不要超过可视距离：如果全部冗余在一行，不仅看这一段代码会花额外的精力去翻看和理解，也会给其他阅读代码的人造成困扰； 建议：一个方法只做一件事情。您可以看到这个方法除了像方法名描述的那样打印一句阿德勒的名言之外，没有做其他任何的操作，这样做能大大增加代码的可阅读性； 在 main 方法中调用正常的方法调用需要像上面提到的那样：object.method(parameters)，但由于身处同一个类中，this.printAdlerOneQuote(); 就可以简写成：printAdlerOneQuote();。 完整的程序代码如下： public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World！\"); printAdlerOneQuote(); } public static void printAdlerOneQuote() { System.out.println( \"太在意别人的视线和评价，才会不断寻求别人的认可。\" + \"对认可的追求，才扼杀了自由。\" + \"由于不想被任何人讨厌，才选择了不自由的生活方式。\" + \"换言之，自由就是不再寻求认可。\" ); } } 练习：尝试输出自己喜欢的一段话在屏幕中参考答案：(上面的完整代码演示) Part 3. 语法错误和 Bug 图片来源：https://blog.csdn.net/csdnnews/article/details/86684475 简述语法错误在源文件中，字符串文字必须仅在一行上。以下内容不合法，将无法编译： System.out.println(\"Hello \" \"World！\"); 您编写的代码不符合 Java 的语法规定，就会发生 语法错误。 在 Java 编译器将源代码文件编译成 .class 文件之前，会默认帮你做许多工作，检查语法就是其中一项。 例如，我们在桌面上试着创建一个【HelloWorld.java】文件然后输入一段存在错误的代码 (您可以试着检查一下哪里出现了一处错误)： public Class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World\"); } } 然后再当前目录执行 javac HelloWorld.java 尝试编译这个存在错误的 Java 源文件： → javac HelloWorld.java HelloWorld.java:1: 错误: 需要class, interface或enum public Class HelloWorld { ^ HelloWorld.java:3: 错误: 需要class, interface或enum public static void main(String[] args) { ^ HelloWorld.java:6: 错误: 需要class, interface或enum } ^ 3 个错误 Java 编译器提示我们有三处错误，实际上我们也确实粗心地把 class 错误的写成了 Class。 编译器也未创建新的字节码文件 (.class)，因为在遇到错误时它将停止翻译。 Bug 简述仅仅因为程序通过编译并且成功运行并不意味着它是正确的。 例如，您的任务是创建一个在屏幕上输出 Hello Wrold!，但是您却错误地写成了 Hello Bug!，运行时没有按照预期执行，则就称该程序存在 Bug！ Bug 起源Bug 一词的原意是 “臭虫” 或 “虫子”。 第一个有记载的 Bug 是美国海军编程员、编译器的发明者格蕾斯·哈珀 （GraceHopper） 发现的。 1945 年 9 月 9 日，下午三点。哈珀中尉正领着她的小组构造一个称为“马克二型”的计算机。这还不是一个真正的电子计算机，它使用了大量的继电器，一种电子机械装置。第二次世界大战还没有结束。哈珀的小组日以继夜地工作。机房是一间第一次世界大战时建造的老建筑。那是一个炎热的夏天，房间没有空调，所有窗户都敞开散热。 突然，马克二型死机了。技术人员试了很多办法，最后定位到第 70 号继电器出错。哈珀观察这个出错的继电器，发现一只飞蛾躺在中间，已经被继电器打死。她小心地用摄子将蛾子夹出来，用透明胶布帖到「事件记录本」中，并注明「第一个发现虫子的实例」。 从此以后，人们将计算机错误称为 Bug，与之相对应，人们将发现 Bug 并加以纠正的过程叫做 “Debug”，意即「捉虫子」或「杀虫子」。 以上内容引用自：http://www.cxyym.com/2014/11/999/ Bug 是怎么产生的？来几个清奇的段子吧。 段子一：庞博脱口秀大会解释 Bug B 站自取：https://www.bilibili.com/video/BV1oJ411S7o4?from=search&amp;seid=7940414495637079568 段子二：测试工程师们来到一家酒吧 引用自知乎@第七地区的答案：https://www.zhihu.com/question/365343579/answer/967299388 段子三：领导让我修房子 引用自知乎@哒柏的答案：https://www.zhihu.com/question/365343579/answer/967299388 地球人和程序员眼中改 Bug 的不同修改程序中的 Bug，要经过三个步骤： 找到它； 想办法解决它； 确认它已经被解决 （并且没有引入其它问题）； 说起来比较简单，在地球人 （程序员等同于外星人） 看起来，过程是这样的： 但是，对于程序员来说，找一个 Bug 往往是这样的： 找到之后呢，解决这个 Bug 又是一个难题： 换个柱子什么的比较简单，还有更崩溃的！ 以上内容引用自：http://www.accessoft.com/blog/article-show.asp?userid=11&amp;Id=17629 Part 4. 注释 图片来源：http://www.cocoachina.com/articles/20146 注释 是写程序的人留下的阅读笔记。 通常注释以两个字符 // 开头。Java 编译器将忽略那些字符以及在该行之后的所有字符。例如： public class HelloWorld { // 程序入口 public static void main(String[] args) { // 输出 Hello World! System.out.println(\"Hello World!\"); } } 这一段代码跟我们最开始的 HelloWrold 程序完全相同。大多数的程序编辑器 (例如 IDEA) 都足够聪明，可以识别注释并将其显示为无关紧要的一些颜色： 与大多数程序设计语言一样，Java 中的注释也不会出现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。 三种注释的方式/** * 文档注释 * 可以注释多条内容 */ public static void main(String[] args) { // 这是单行注释 System.out.println(\"演示三种注释方式\"); /* 这是多行注释 */ } 单行注释：以 // 标识，只能注释一行内容； 多行注释：包含在 /* 和 */ 之间，能注释多行内容，为了提高可阅读性，一般首行和尾行不写注释信息； 文档注释：包含在 /** (两个 *) 和 */ 之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用 (这是 Java 的一种规范，之后会更多的见识到)； 几点建议 注释的目的是： 尽量帮助读者了解得和作者一样多。 —— 《编写可读代码的艺术》 以下节选自《阿里巴巴 Java 开发手册》对于注释的几点要求： 【强制】 类、雷属性、类方法的注释必须使用 Javadoc 规范，使用 /**内容*/ 格式，不得使用 // 方式 (上面的演示程序中就不符合规范，需要注意)； 【强制】 方法内部的单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部的多行注释，使用 /* */ 并注意与代码对齐； 【推荐】 与其用「半吊子」英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可； 【推荐】 在修改代码的同时，要对注释进行相应的修改； 【参考】 对于注释的要求： 能够准确反映设计思想和代码逻辑； 能够描述业务含义，使其他程序员能够迅速了解代码背后的信息。完全没有注释的大段代码对于阅读者如同天书；注释是给自己看的，应做到即使间隔很长时间，也能清晰理解当时的思路；注释也是给继任者看得，使其能够快速接替自己的工作； 【参考】 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释。因为代码的逻辑一旦修改，修改注释也是相当大的负担； 对于以上的一些建议，我相信在您之后的编程之路上会越发地体会深刻。 要点回顾 JVM、JRE、JDK 的说明和联系； Java 开发环境的搭建方法； 标识符和保留字的定义以及标识符的命名规范； 程序的基本结构和方法定义和调用的简单方法； 语法错误和 Bug (起源、怎么产生的)； 注释的定义、三种注释的方式、注释的规范； 练习练习 1：尝试输出自己喜欢的一段话在屏幕中参考答案：(上面有完整代码演示) 练习 2：尝试把上方输出的内容单独实现为自己的方法并在 main 方法中调用运行参考答案：(上面有完整代码演示) 练习 3：给自己的代码添加上注释并让朋友阅读询问是否清晰必要参考答案：(上面有完整代码演示) 自取资料相关扩展阅读资料 Java 教程 | 廖雪峰官方网站 - https://www.liaoxuefeng.com/wiki/1252599548343744 史上最简单的 Intellij IDEA 教程 - https://github.com/judasn/IntelliJ-IDEA-Tutorial 计算机发展史上十大著名软件缺陷 - https://zhuanlan.zhihu.com/p/31167236 推荐书籍Java 核心技术·卷 I(原书第 11 版) 推荐理由： 这本书在知识体系完整充实的同时，又比《Thinking in Java》暴风式的知识洗礼来得轻松，新人入门书籍强烈推荐！ 可读代码的艺术 推荐理由： 编写可阅读的代码是程序员从始至终需要提升的能力，这本书完整呈体系的结构，和朴实充实的实例，让读者通过阅读就能在实践中真实地运用起来，推荐！ 参考资料 《Thinking in Java》第四版 《Java 核心技术 卷 I》第11版 廖雪峰系列 Java 教程 - https://www.liaoxuefeng.com/wiki/1252599548343744 历史上的第一个计算机Bug - http://www.cxyym.com/2014/11/999/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」Java 发展史及起航新世界","slug":"「MoreThanJava」Java-发展史及起航新世界","date":"2020-06-09T03:18:00.000Z","updated":"2020-12-09T04:39:51.702Z","comments":true,"path":"2020/06/09/morethanjava-java-fa-zhan-shi-ji-qi-hang-xin-shi-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/06/09/morethanjava-java-fa-zhan-shi-ji-qi-hang-xin-shi-jie/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. Java 发展简史 图片来源：https://www.geeksforgeeks.org/the-complete-history-of-java-programming-language/ 起源：”Green” 项目20 世纪 90 年代，单片式计算机系统诞生，单片式计算机系统不仅廉价，而且功能强大，使用它可以大幅度提升消费性电子产品的智能化程度。 SUN 公司为了抢占市场先机，在 1991 年成立了一个由詹姆斯·高斯林（James Gosling）领导，名为 “Green” 项目小组，目的是开发一种 能够在各种消费性电子产品上运行的程序架构（主要是像 有线电视转换盒 这一类 处理能力和内存都很有限，并且 CPU 厂商又各不相同 的消费设备）。 由于这些消费设备的处理能力和内存都有限，所以语言必须 非常小且能够生成非常紧凑的代码。另外，由于不同厂商会选择不同的 CPU，因此很重要的一点是这种语言 不应该与任何特定的体系结构绑定。代码短小、紧凑且与平台无关，这些要求促使开发团队设计出一个 可移植的语言，可以为虚拟机生成中间代码。 不过，Sun 公司的人都有 UNIX 的应用背景。因此，所开发的语言以 C++ 为基础，而不是 Lisp/ Smalltalk 或 Pascal。不过，就像 Gosling 在专访中谈道：“毕竟，语言只是实现目标的工具，而不是目标本身。” Gosling 把这种语言称为 “Oak”（直译为橡树，大概是因为它非常喜欢自己办公室窗外的一颗橡树…）。后来 Sun 公司发现，Oak 是一种已有的计算机语言名字，于是 Gosling 和他的团队进行了一次头脑风暴，多次讨论后，从 Java/ DNA/ SILK/ RUBY 中决定使用 Java 来命名。事实证明这是一个很有灵感的选择。 埋没：没人为 “Green” 项目买单1992 年，Green 项目发布了它的第一个产品，称之为 「* 7」。这个产品可以提供非常智能的远程控制。遗憾的是，Sun 公司对生产这个产品并不感兴趣。Green 项目组的人员必须找出其他的方法来讲他们的技术推向市场。 然而，仍然没有任何一家标准消费品电子公司对此感兴趣。于是，Green 项目组投标了一个设计有线电视盒的项目，它能提供视频点播等新型有线服务，但他们没能拿到这个合同 （有趣的是，得到这个项目的公司的领导恰恰是开辟 Netscape 公司的 Jim Clark。Netscape 公司后来对 Java 的成功给予了很大的帮助。） Green 项目 （这时已经换了一个新名字 ———— “First Person 公司”） 在 1993 年一整年以及 1994 年上半年，一直在苦苦寻找买家购买他们的技术。然而，一个也没有找到 （Partick Naughton ———— 项目组的创始人之一，也是完成了大多数营销工作的人，声称为了销售这项技术，已累计飞行了 300,000 英里）。 1994 年 First Person 公司解散了。 转机：Internet 的壮大当这一切在 Sun 公司发生的时候，Internet 的万维网也在日渐发展壮大。万维网的关键是把超文本页面转换到屏幕上的浏览器。 1994 年大多数人都在使用 Mosaic，这是一个 1993 年出自伊利诺斯大学超级计算中心的非商业化的 Web 浏览器（ Mosaic 的一部分是由 Marc Andreessen 编写的。当时，他作为一名参加半工半读项目的本科生， 编写了这个软件，每小时的薪水只有 6.85 美元。他后来成了 Netscape 公司的创始人之一和技术总监， 可谓名利双收。) 在接受 SunWorld 采访的时候，Gosling 说在 1994 年中期，Java 语言的开发者意识到： “我们能够建立一个相当酷的浏览器。在客户机/ 服务器主流模型中，浏览器恰好需要我们已经完成的一些工作：体系结构中立、实时、可靠、安全 ———— 这些在工作站环境并不太重要，所以，我们决定开发浏览器” 实际的浏览器是由 Patrick Naughton 和 Jonathan Payne 开发的，并演变为 HotJava 浏览器。为了炫耀 Java 语言超强的能力，HotJava 浏览器采用 Java 编写。设计者让 HotJava 浏览器具有在网页中执行内嵌代码的能力。 这一 “技术证明” 在 1995 年 5 月 23 日的 SunWorld’95 上得到展示，同时引发了人们延续至今的对 Java 的狂热追逐。 至此，这一场持续长达 20 多年的「Java 热」开始了。 观察近 20 年的数据，Java 的排名从未跌出过前三，而且有将近一半的年份抢占了透明，不得不令人感叹：「流水的程序员，铁打的 Java 啊！」 Part 2. Java 与 Internet 图片来源：https://www.morethanshipping.com/internet-things-iot-will-help-logistics/ 如果 Java 仅仅只是众多的程序设计语言中的一种，你可能就会问：为什么它如此重要呢？为什么它促使计算机编程语言向前迈进了革命性的一步？ 如果从传统的程序设计的角度看，问题的答案似乎不太明显。尽管 Java 对于解决传统的单机程序设计问题非常有用，但同样重要的事，它解决了在万维网（WWW）上的程序设计问题。 Web 1.0 时代的程序设计问题在刚创造 Java 的年代（20 世纪 90 年代），整个互联网还处于 Web 1.0 的网络萌芽阶段。 在 之前的一篇文章 其实有对 Web 做了一些概念性的描述（概念、发展、体系结构）。 问题一：网页没有交互Web 1.0 的网站是静态的。最初的互联网只有一种很简单的 单向过程：你 对某一个服务器发起一个请求，然后它 返回 给你一个 文件，你的机器（俗称客户端）上的 浏览器软件 根据本地机器的格式来 解读并展示 这个文件的内容。这期间没有任何的交互发生，因为最初的浏览器只是一个 “展示器”，它甚至不能执行最简单的计算任务。（另一方面，它确是安全的，因为它在你的本地机器上不会执行任何程序，而这些程序可能包含 bug 和病毒） 用户 只能访问 这些站点而不会对它们做出任何贡献。这就像你捧起书架中的一本书一样，它是一种 「只读」 模式的存在，如果你想与创造这本书的出版社也好，作者也好建立链接，只能通过其他的一些方式。（当时的网站也是主要是向消费者展示产品，从感兴趣的消费者那里收钱） 很快人们就不满足于只是从服务器传递回页面，人们希望实现完整的客户/ 服务器能力，使得客户可以将信息反馈给服务器，来完成例如：在服务器上进行数据查找，并将用户提供的新信息加到服务器中，服务器管理人员接受到新信息之后就下发订单的操作。 问题二：响应缓慢早期的浏览器不仅没有交互，而且它还趋向于让服务器和 Internet 阻塞。因为在任何时候，只要 你需要完成 通过编程 才能实现的 任务，就必须将信息发挥到 服务器 去 处理。然而在互联网中，在任意时刻都有可能会有 成百上千 的客户向服务器发出请求，所以任何小的延迟都会产生重大的影响。 为了解决这个问题，人们采用了各种不同的方法。首先，图形标准得到了加强，这使得在浏览器中可以播放质量更好的动画和视频。剩下的问题通过引入 在客户端浏览器中运行程序 的能力就可以解决，这被称为 「客户端编程」。 问题三：客户端编程平台各异大多数运行 Web 浏览器的机器都是能够执行大型任务的强有力的引擎。在使用原始的静态 HTML 方式的情况下，它们通常只是闲在那里，等着服务器送来下一个页面。 客户端编程意味着 Web 浏览器能够用来执行任何它可以完成的工作，使得返回给用户的结果 更迅速 （不用全部的结果都等着服务器来运算），而且使得你的网站 更加具有交互性 （那些不需要使用服务器数据的操作可以完全在本地完成）。 但客户端编程的问题是：它与通常意义上的编程十分不同，参数几乎相同，而平台却不同。在 Web 浏览器中编程就像是使用一台功能受限的操作系统，而每一台功能还略微的有差别。最终，你不仅需要编写程序，还需要处理因为平台不同带来的兼容问题。 小结因为「没有交互」和「访问缓慢」的问题，所以引入「客户端编程」，因为引入客户端编程，遇到「各种各样不仅仅是平台差异带来的问题」。 Java 的解决方案插件和脚本语言 “差点意思”在当时，客户端编程所迈出的最重要的一步就是 插件（plug-in） 的开发。通过这种方式，用户可以下载一段代码，并将其插入到浏览器中适当的位置，以此来为浏览器添加新的功能。 图片来源：https://zhuanlan.zhihu.com/p/28889449 插件又引发了浏览器 脚本语言（scripting language） 的开发。通过使用某种脚本语言，你可以将客户端程序的源代码直接嵌入到 HTML 页面中，解释这种语言的插件在 HTML 页面被显示时自动激活。(脚本语言可以解决客户端编程中遇到的百分之八十的问题) 脚本语言先天就相当易于理解，因为它们只是作为 HTML 页面一部分的简单文本，当服务器收到要获取该页面的请求时，它们可以被快速加载。此方法的缺点是代码会直接暴露给任何浏览（或窃取）的人，但是，通常不会使用脚本语言去做相当复杂的事情，所以这个缺点不会太严重。 如果脚本语言可以解决客户端编程百分之八十的问题的话，那么剩下那百分之二十 （那才是真正难啃的骨头） 又该怎么办呢？ Java 带来了 Applet 图片来源：https://www.ibm.com/developerworks/cn/java/ Java 带着 Applet 及时出现。 1995 年， Java 之父 James Gosling 和 Sun 公司科学办公室主任 John Gage 一起前往蒙特利，去参加一个 TED 会议，两人要在那里展示一个划时代的技术， 号称向能把枯燥的静态网页变得栩栩如生，美轮美奂。 演示开始了，James Gosling 把鼠标指向了浏览器中的一个 3D 分子模型，来回地旋转它，台下的观众发出阵阵惊叹声，他们被镇住了，从没有人想到在浏览器中也能实现这么 “美轮美奂” 的效果 ! 图片来源：https://zhuanlan.51cto.com/art/201911/606791.htm Java 火了! 这个演示所使用的技术就是 Applet。 Applet 是只在 Web 浏览器中运行的小程序，它是作为网页的一部分而自动下载的 （就像是网站图片被自动下载一样）。当 Applet 被激活时，它变开始执行一个程序，这正是它优雅的地方：它提供了一种分发软件的方式，一旦用户需要客户端软件时，就自动从服务器把客户端软件分发给用户。 用户获取最新版本的客户端软件时不会产生错误，而且也不需要很麻烦的重新安装过程 （有点像现在的小程序）。Java 的这种设计方式，使得程序员只需要创建单一的程序，而只要一台计算机有浏览器，且浏览器具有内置的 Java 解释器 （大部分机器都有），那么这个程序就可以自动在这台计算客户端尽可能地多做事情。例如，不必跨网络地发送一张请求表单来检查自己是否填写了错误的日期或者其他参数，客户端计算机就可以快速地标出错误数据。 这不仅立即就获得了快速的响应能力，而且也降低了网络流量和服务器负载，从而不会使整个网络的速度慢下来。 Java 对服务端编程的加持当提出对服务器的请求之后，会发生什么呢？大部分时间，请求只是要求「给我发送一个文件」，之后浏览器会以某种适当的形式解释这个文件，例如将其作为 HTML 页面、图片、Java applet 或脚本程序等来解释。 更复杂的对服务器的请求通常涉及数据库，这可能会需要服务器端对请求到的数据进行一定的编排 （例如把数据嵌到一个表格之内） 来最终使其成为一个 HTML 文件发送给客户端 （当然，如果客户端具备更多的只能，你完全可以把原始数据发送给客户端让它自己进行编排工作..）。另一种常见的情形是：你注册账号或者提交订单，这对数据库数据造成了更改，而这些必须通过服务器端的某些代码进行处理，这就是所谓的 服务端编程。 Java 后来编写的被称为 Servlet 的程序 （及其衍生物 JSP），是许多开发网站的公司迁移到 Java 上的主要原因。尤其是因为凭借 Java 跨平台的特性 消除了处理具有不同能力的浏览器时所遇到的问题。 小结Java 凭借自身强大、安全、跨平台、国际化的特性，加上解决了当时客户端、服务端开发的诸多 “痛点”，成功搭上 Internet 这列 “国际快车”，一跃成为了时下 （20 实际 90 年代中） 最热门的语言之一，并持续火热至今 （这跟 Java 自身不断地成熟有脱不开的关系）。 现如今 Applet 和 Servlet 两个技术已经逐步淡出人们的视野，但在 Java 的历史上，是举足轻重的两个突破点。 Part 3. Hello Wrold！ 图片来源：https://medium.com/@thiagonascimento/time-to-first-hello-world-11a4735602f2 当我们集中注意力 学习一种新的编程语言 时，教程上的 第一个案例 就是如何 在计算机屏幕上显示短语 Hello，world！ 也许这条短语最知名的来源是贝尔实验室的备忘录《C 语言编程——一份教程》。这份材料编写于 1974 年。不过在编写于 1972 年的 B 语言教程中，我们同样看到了这条短语的身影。 Hello, World! 是一种伟大的教学方法。这是一项能够轻松完成的小任务，同时也代表着一种标准，体现出不同编程语言之间的重要差异。此外，这也是高级程序员在安装新环境测试一切是否正常的快速简便方法。（有时候，程序员们也会使用「hello world」运行时间来比较不同语言与环境的速度水平。） 也许更重要的是，Hello, world！ 具有一种温暖而柔和的力量，对编程新人有着一种莫名的亲和力。 「代码拥有无穷威力，而新的世界已经向你张开怀抱。」 ———— Chris Noessel，IBM 公司 AI 设计负责人 public class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 以上就是Java 语言版本 Hello World 程序。（现在看不懂也没关系，可以进 https://c.runoob.com/compile/10 这个网站在线运行测试一下看看效果…） 至此，欢迎你进入 Java 的世界。 参考资料 《Thinking in Java》 第四版； 《Java 核心技术 卷 I》 第 11 版； The complete History of Java Programming Language - https://www.geeksforgeeks.org/the-complete-history-of-java-programming-language/ Java 发展简史：初生遇低谷，崛起于互联网 - https://www.chainnews.com/articles/628715645859.htm 永别了，Java的“小苹果”! - https://zhuanlan.51cto.com/art/201911/606791.htm 改变世界的代码行 - https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX 往期精彩 「MoreThanJava」当大学选择了计算机之后应该知道的 「MoreThanJava」计算机发展史—从织布机到IBM 「MoreThanJava」计算机系统概述 「MoreThanJava」一文了解二进制和CPU工作原理 「MoreThanJava」机器指令到汇编再到高级编程语言 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」机器指令到汇编再到高级编程语言","slug":"「MoreThanJava」机器指令到汇编再到高级编程语言","date":"2020-06-04T02:44:00.000Z","updated":"2020-12-09T04:38:34.271Z","comments":true,"path":"2020/06/04/morethanjava-ji-qi-zhi-ling-dao-hui-bian-zai-dao-gao-ji-bian-cheng-yu-yan/","link":"","permalink":"http://www.wmyskxz.com/2020/06/04/morethanjava-ji-qi-zhi-ling-dao-hui-bian-zai-dao-gao-ji-bian-cheng-yu-yan/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 机器指令 上一次 我们已经了解了 二进制和 CPU 的基本原理，知道了程序运行时，CPU 每秒数以亿次、十亿次、百亿次地震荡着时钟，同步执行着微小的 「电子操作」，例如：从内存读取一个字节的数据到 CPU 又或者判断字节中的某一位是 0 还是 1。 CPU 本身有一组 规定好的 可以执行的 「基本动作」（被称为 机器指令）： 读取指令；2. 执行指令；3. 写寄存器； 这几乎就是 CPU 工作的全部了。 这些动作虽然每次只能执行一次，但是每秒可以执行数十亿次，这个数量级的「小操作」累加成为一个大的「有用的操作」。 处理器所做的一切都是基于这些微小的操作！幸运的是，我们已经不再需要了解这些操作的详细信息就可以编写和使用各类程序。诸如 Java 这一类的 「高级语言」 的 目的 就是 将这些微小的电子操作组织成由人类可读的「程序语言」表示的大型有用单元。 机器指令演示一条 机器指令 一般由内存中的几个字节组成，它们告诉 CPU 应该执行一个什么样的 「机器操作」（是取数据还是写寄存器等..）。处理器依次查看 CPU 中的机器指令，并执行每一条。内存中的一组机器指令被称为 「机器语言程序」，或称为 「可执行程序」。 下面我们来使用机器语言来演示一个控制灯泡亮度的机器语言程序。 先和硬件做好规定假设灯泡由内存中的某一个程序控制，该程序能够完全打开和关闭灯泡，可以使灯泡变亮或变暗，机器指令一个字节长度，并且与机器操作对应如下： 机器指令 机器操作 00000000 停止程序 00000001 完全打开灯泡 00000010 完全关闭灯泡 00000100 灯泡暗淡 10％ 00001000 将灯泡照亮 10％ 00010000 如果灯泡完全点亮，则跳过下一条说明 00100000 如果灯泡完全熄灭，请跳过下一条说明 01000000 转到程序的开始（地址 0） Demo 程序 &amp;&amp; 演示根据上方作出的规定，我们写下如下的程序：（为了方便理解，我把对应的机器操作也写在了后面，实际的程序只包含机器指令） 地址 机器指令 机器操作 0 00000001 完全打开灯泡 1 00000010 完全关闭灯泡 2 00000001 完全打开灯泡 3 00000100 灯泡暗淡10％ 4 00000100 灯泡暗淡10％ 5 00000000 停止程序 所以这样的一段程序执行效果就如下图： 您可以尝试自己利用 01000000（跳转到程序开始） 来改写程序来达到让「灯逐渐变亮又逐渐变暗」的目的。 小结上面演示的程序 核心思想 是： 机器语言程序是内存中一系列机器指令的集合； 机器指令由一个或多个字节组成（在此示例中，仅一个字节）； 处理器一次运行一条机器指令的程序； 所有的小机器操作加起来都是有用的； 在实际的 CPU 中，拥有更多的机器指令，而且更详细，并且不同的 CPU，指令集是不同的。典型的 CPU 拥有一千或更多的机器指令。 Part 2. 汇编语言 图片来源：http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html 机器语言太 “反人类”我们已经可以开始写一些程序使用了，但是使用 机器语言编写代码会十分辛苦，比如： 00000001 00000010 00000001 00000100 00000100 00000000 即使你刚看过你也会对这一段就在 上方的实例代码 没有什么感知，这是因为机器语言是设计给机器的，人类记忆和使用起来就会显得十分麻烦。 如此你就会感知到 上个世纪 的程序员使用 打孔卡片： 使用 纸带： 甚至是 直接插拔线路 or 按下开关： 是一件多么硬核的事情… 如果你对它们如何工作以及多么硬核感兴趣，可以参考一下下方的链接： 开发语言小传之一：最早的编程语言——机器语言 - https://blog.csdn.net/killer080414/article/details/42219091 50年前的登月程序和程序员有多硬核 - https://coolshell.cn/articles/19612.html、 再附带一个宝藏网站(哥伦比亚大学出版的计算机历史，非常详细)，有条件的同学 非常推荐 进去浏览一下： http://www.columbia.edu/cu/computinghistory/index.html 汇编语言诞生CPU 的指令都是 二进制 的，这显然对于人类来说是 不可读 的。为了解决二进制指令的可读性问题，工程师将那些指令写成了 八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。 很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是 用标签 表示。 这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为 汇编语言。 图片来源：http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html 理解汇编语言每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。 寄存器要学习汇编语言，首先必须了解两个知识点：寄存器 和 内存模型。 先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。 但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。 寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。 寄存器的种类早期的 x86 CPU 只有 8 个寄存器，而且每个都有不同的用途。现在的寄存器已经有 100 多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。 EAX EBX ECX EDX EDI ESI EBP ESP 上面这 8 个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。 我们常常看到 32 位 CPU、64 位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是 4 个字节。 内存模型：Heap（堆）寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。 程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从 0x1000 到 0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。 程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用 malloc 命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到 10 个字节内存，那么从起始地址 0x1000 开始给他分配，一直分配到地址 0x100A，如果再要求得到 22 个字节，那么就分配到 0x1020。 这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。 内存模型：Stack（栈）除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于 函数运行 而 临时占用 的内存区域。 例如我们在执行一个叫 main 的函数时，会为它在内存里面创建一个 帧，用来保存所有 main 中使用的内部变量。main 函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。 如果在 main 函数 内部调用了其他函数，例如 add_a_and_b 函数，那么执行到这一行的时候，系统也会为 add_a_and_b 新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main 和 add_a_and_b。一般来说，调用栈有多少层，就有多少帧。 等到 add_a_and_b 运行结束，它的帧就会被回收，系统会回到函数 main 刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的 层层调用，并且 每一层都能使用自己的本地变量。 我们可以把栈理解为一个下方密封，而上方打开的「桶」。 生成的新帧放入我们称之为 「入栈」，而释放帧我们称之为 「出栈」。栈的特点 就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做 “后进先出” 的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个栈就都释放了。 汇编语言演示举个简单的例子，我们需要计算： (1 + 4) * 2 + 3 我们按照 「后缀表示法」 进行一下转换： 1，4，+，2，*，3，+ 我们平常使用的方法是 「中缀表示法」，也就是把计算符号放中间，例如 1 + 3，后缀则是把符号放最后，例如 1, 3, +。 这样做的好处是没有先乘除后加减的影响，也没有括号，直接运算就行了。（例如 1, 3, +，先把 1 和 3 保存起来碰到 + 知道是加法则直接相加） OK，我们从头开始使用汇编语言来编写一下程序，首先第一步：把 1 保存起来（放入寄存器）： MOV 1 之后是 4, +，那就直接加一下： ADD 4 然后是 2, *，那就直接乘一下（SHL 是向左移动一位的意思，二进制中左移一个单位就相当于乘以 2，例如 01 表示 1，而 10 则表示 2）： SHL 0 最后是 3, +，再加一下： ADD 3 完整程序如下： MOV 1 ADD 4 SHL 0 ADD 3 这似乎看起来比 00001111 这样的二进制要好上太多了！程序员们感动到落泪： Part 3. 高级编程语言 摆脱了 二进制，我们有了更可读的 汇编语言，但仍然十分繁琐和复杂，每一条汇编指令代表一个基本操作，例如：「从内存 x 位置获取一个数字并放入寄存器 A」、「将寄存器 A 中的数字添加到寄存器 B 的数字上」。这样的编程风格既费时又容易出错，并且一旦出错还很难发现。 例如，我们来看一看 「1969 年阿波罗 11号登月计划」 用来 防止登月舱计算机耗尽自身资源 的 BAILOUT 代码： POODOO INHINT CA Q TS ALMCADR TC BANKCALL CADR VAC5STOR # STORE ERASABLES FOR DEBUGGING PURPOSES. INDEX ALMCADR CAF 0 ABORT2 TC BORTENT OCT77770 OCT 77770 # DONT MOVE CA V37FLBIT # IS AVERAGE G ON MASK FLAGWRD7 CCS A TC WHIMPER -1 # YES. DONT DO POODOO. DO BAILOUT. TC DOWNFLAG ADRES STATEFLG TC DOWNFLAG ADRES REINTFLG TC DOWNFLAG ADRES NODOFLAG TC BANKCALL CADR MR.KLEAN TC WHIMPER 出处：改变世界的代码行 - https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX 似乎不太容易读的样子… 阿波罗登月计划的源代码在 Github 上已经公开，有兴趣的可以去下方链接膜拜一下（可以去感受一下当时程序员的工程能力）： https://github.com/chrislgarry/Apollo-11 另外附一下当时代码的设计负责人 Margaret Heafield Hamilton（女程序员）和完成的堆起来跟人一样高的代码量： 第一个高级语言：FORTRAN当 John Backus 在 1950 年以一名科学程序员的身份加入 IBM 时，已经可以使用诸如 ADD 之类的助记词代替数字代码来编写程序，也就是我们的汇编语言。这使编程变得容易一些，但是即使是一个简单的程序也需要数十次操作，并且仍然很难找到错误。 巴克斯认为，应该有可能创建一种编程语言，使一系列计算可以用类似于数学符号的形式来表达。然后，使用特定的翻译程序（以今天的术语来说是编译器）可以将其转换为计算机可以理解的数字代码。 Backus 在 1953 年向他的经理提出了这个想法。他得到了预算，并被鼓励雇用一个小团队来测试该想法的可行性。三年后，该团队发布了一本手册，其中描述了 IBM Mathematical Formula Translating System（简称 FORTRAN）。不久之后， IBM 向 IBM 704 的用户提供了第一个 FORTRAN 编译器。 Backus 和他的团队创造了世界上第一种高级编程语言。科学家和工程师将不再需要将其程序编写为数字代码或冗长的助记符。 FORTRAN 代码演示下面演示计算并输出 8 * 6 的代码实例： program VF0944 implicit none integer a, b, c a= 8 b= 6 c= a*b print *, 'Hello World, a, b, c= ', a, b, c end program VF0944 对比汇编代码，是不是看上去要清晰（人类可读）多了呢？ FORTRAN 的意义FORTRAN 的问世在计算机史上具有划时代的意义，它使计算机语言从原始的低级汇编语言走出来，进入了更高的境界，使得 计算机语言不再是计算机专家的专利，使广大的工程技术人员有了进行计算机编程的手段。 由此计算机更快地深入到了社会之中，它在工业部门中初露头角，更是在火箭、导弹、人造地球卫星的设计中大显身手，因此有人称 FORTRAN 语言使计算机的工业应用成了可能，是推动第二次世界大战以后西方工业经济复苏和进入第二次工业革命的无形力量，是 “看不见的蒸汽机”。 FORTRAN 后时代FORTRAN 高级程序设计语言的出现孕育了计算机软件业，继其之后，计算机高级程序语言的开发进入到了一个蓬勃发展的时代。 1959Grace Hopper 发明了第一个面向企业业务的编程语言，又称 “面向商业的通用语言”，也常常简称 COBOL。 1964美国达特茅斯学院约翰·凯梅尼和托马斯·卡茨认为，像 FORTRAN 那样的语言太过专业，编程非常困难。于是他们简化了 FORTRAN，并设计出了更适合初学者的 BASIC 语言。 1970尼古拉斯·沃斯非常痴迷于编程语言，他率先提出了结构化程序设计思想并发明了 Pascal 语言。 此外他还提出了 Wirth 定律，意为 “软件变慢的速度比硬件变快的速度更快”，这让摩尔定律变得充满讽刺。之后的 Electron.js 也确实证明了这一点。 1972丹尼斯·里奇在贝尔实验室工作期间发明了 C 语言，开启了现代程序语言的革命。之后，他又添加了段错误和其他一些帮助开发人员的实用功能，大大提升了编程效率。 除了 C 语言之外， 他和贝尔实验室的同事还创造了伟大的 Unix 操作系统。 1980Alan Kay 发明了面向对象的编程语言 Smalltalk，在 Smalltalk 中，一切皆对象。 1987拉里·沃尔发明了 Perl 语言。 1983Jean Ichbiah 发现 Ada Lovelace 的程序从未运行成功过，因此决定用她的名字创建一种语言，于是 Ada 语言诞生了。 1986Brac Box 和 Tol Move 通过融合 C 语言和 Smalltalk 的特征，发明了 Objective-C。但由于其语法晦涩，不太容易理解。 1983Bjarne Stroustrup 在 C 语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言并将其命名为 C++。 C++ 大大提升了应用程序的编程效率。 1991Guido van Rossum 讨厌带有大括号的编程语言，于是他参考 Monty Python 和 Flying Circus 语法，并发明了 Python。 1993Roberto Ierusalimschy 和其朋友创造了一门巴西本地的脚本语言。在本地化过程中，由于一个小的错误使得索引从1开始，而不是0。这门语言就是 Lua。 1994Rasmus Lerdorf 为他个人主页的 CGI 脚本制作了一个模板引擎，用来统计他自己网站的访问量。 这个文件被上传到网上之后用它的人越来越多。后来又用 C 语言重新编写，还添加了数据库访问功能。这门语言就是 PHP。 1995松本行弘发明了 Ruby 语言。 1995Brendan Eich 利用周末时间设计了一种语言，用于为世界各地的网页浏览器提供支持，并最终推出了 Skynet。他最初去了 Netscape，并将这门语言命名为 LiveScript，后来在代码审查期间 Java 逐渐开始风靡，因此他们决定将其改名为 JavaScript。 后来 Java 使其陷入了商标麻烦，于是 JavaScript 被更名为 ECMAScript。但是人们还是习惯称之为 JavaScript。 1996James Gosling 发明了 Java，这是 第一个真正意义上面向对象得编程语言，其中设计模式在实用主义中占统治地位。 More… 对于这一段计算机历史感兴趣的同学可以拜读一下「IT 通史 12.2 节 - 高级计算机程序设计语言」的内容，在线预览链接如下： https://books.google.com.hk/books?id=ZrAol3RzcNkC&amp;printsec=frontcover&amp;hl=zh-CN#v=onepage&amp;q&amp;f=false 高级语言分类CPU 终究只认识二进制指令，在我们发明高级语言之后，仍然无可避免的需要进行 「翻译」 工作。按照翻译方式的不同，我们又把高级语言分为了 「编译型」 和 「解释型」。 编译型 编译型专业解释为： 使用 专门的编译器，针对 特定的平台，将高级语言源代码 一次性 的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式，并且只需要编译一次，以后再也不用编译。其实可以简单理解成谷歌/ 百度翻译，我们把要翻译的文字全部放进去，一次翻译，下次使用直接使用上一次翻译好的结果。 优点（较解释型）：执行效率高(有解释器省去很多翻译的过程) 缺点（较解释型）：开发效率低(写完所有的代码才能检查 bug，得多恐怖呀？？？) 解释型 解释型专业解释为： 使用 专门的解释器 对源程序逐行解释成 特定平台 的机器码并 立即执行，它不需要事先编译，直接将代码解释称机器码直接运行，也就是说只要某一平台提供了相应的解释器即可运行代码。其实可以理解成同声传译，我们需要翻译的时候，找一个翻译员，对方说一句翻译员翻译一句，下次翻译还是需要一个翻译员一句一句的翻译。 缺点（较编译型）：执行效率低(写一次翻译一次) 优点（较编译型）：开发效率高(写一行翻译一行，错了马上就知道，妈妈再也不用担心我找不到 bug 了) 半解释半编译的 Java不同厂商、不同时间开发的 CPU 的指令集是不一样的，这就是上方为什么提到要使用 专门的解释器，要用于 特定的平台 的原因。 所以 Java 为了实现 「一次编译，到处运行」 的目的，采用了一种特别的方案：先 编译 为 与任何具体及其环境及操作系统环境无关的中间代码（也就是 .class 字节码文件），然后交由各个平台特定的 Java 解释器（也就是 JVM）来负责 解释 运行。 编程人员和计算机都无法直接读懂字节码文件，它必须由专用的 Java 解释器来解释执行，因此 Java 是一种在 编译基础上进行解释运行 的语言。（Java 程序运行流程如下） Java 解释器 负责将字节码文件翻译成具体硬件环境和操作系统平台下的机器代码，以便执行。因此 Java 程序不能直接运行在现有的操作系统平台上，它必须运行在被称为 Java 虚拟机的软件平台之上。 Java 虚拟机（JVM） 是运行 Java 程序的软件环境（我们后面会详细说到，这是学习 Java 绕不过的题），Java 解释器是 Java 虚拟机的一部分。在运行 Java 程序时，首先会启动 JVM，然后由它来负责解释执行 Java 的字节码程序，并且 Java 字节码程序只能运行于 JVM 之上。这样利用 JVM 就可以把 Java 字节码程序和具体的硬件平台以及操作系统环境分隔开来，只要在不同的计算机上安装了针对特定平台的 JVM，Java 程序就可以运行，而不用考虑当前具体的硬件平台及操作系统环境，也不用考虑字节码文件是在何种平台上生成的。 JVM 把这种不同软、硬件平台的具体差别隐藏起来，从而 实现了真正的二进制代码级的跨平台移植。JVM 是 Java 平台架构的基础，Java 的跨平台特性正是通过在 JVM 中运行 Java 程序实现的。Java 的这种运行机制可以通过下图来说明： Java 语言这种「一次编写，到处运行」的方式，有效地解决了目前大多数高级程序设计语言需要针对不同系统来编译产生不同机器代码的问题，即硬件环境和操作平台的异构问题，大大降低了程序开发、维护和管理的开销。 提示： Java 程序通过 JVM 可以实现跨平台特性，但 JVM 是不跨平台的。也就是说，不同操作系统之上的 JVM 是不同的，Windows 平台之上的 JVM 不能用在 Linux 平台，反之亦然。 参考资料 Introduction to Computer Science using Java | CHAPTER 4 - http://programmedlessons.org/Java9/chap04/ch04_01.html 汇编语言入门教程 - http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html CPU 是怎么认识代码的？ | 知乎@Zign - https://www.zhihu.com/question/348237008/answer/843382847 改变世界的代码行 - https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX The History of FORTRAN - https://www.obliquity.com/computer/fortran/history.html 《IT 通史》 | @李彦 A Brief Totally Accurate History Of Programming Languages - https://medium.com/commitlog/a-brief-totally-accurate-history-of-programming-languages-cd93ec806124 编程语言分类 - https://www.cnblogs.com/nickchen121/p/10722720.html 往期精彩 「MoreThanJava」当大学选择了计算机之后应该知道的 「MoreThanJava」计算机发展史—从织布机到IBM 「MoreThanJava」计算机系统概述 「MoreThanJava」一文了解二进制和CPU工作原理 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编码之前需要知道的事","slug":"基础知识/编码之前需要知道的事","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」一文了解二进制和CPU工作原理","slug":"「MoreThanJava」一文了解二进制和CPU工作原理","date":"2020-06-02T00:10:00.000Z","updated":"2020-12-09T04:38:55.890Z","comments":true,"path":"2020/06/02/morethanjava-yi-wen-liao-jie-er-jin-zhi-he-cpu-gong-zuo-yuan-li/","link":"","permalink":"http://www.wmyskxz.com/2020/06/02/morethanjava-yi-wen-liao-jie-er-jin-zhi-he-cpu-gong-zuo-yuan-li/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ Part 1. 原来，我们是这样记数的 本节内容节选自下方 参考资料 1 在讨论「二进制」和「CPU 如何工作」之前，我们先来讨论一下我们生活中最稀疏平常的 数字，我们与之频繁地打交道：一个约定的时间、一件商品的价格、一个人的身高….却很少有人细细想过，这些数字是如何表达出来的？为什么你理所当然地把 1024 理解为「一千零二十四」而不是别的含义？ 也许你从未想过，在这简单的记数中，沉淀着人类的大智慧。 一进制计数法 图片来源：https://www.goethe.de/ins/cn/cn/kul/mag/20629923.html 早在数字的概念产生之前，人类就学会了使用树枝、石子、贝壳等自然界随处可见的小物件表示猎物的、果实的、部落人口的数量。比如在某个角落堆上一堆石子，每打到 1 只猎物，就扔 1 颗石子进去，每吃掉 2 只猎物，就从中取走 2 颗石子。他们并不在意石子的总数，只是时不时地瞅一眼，心底大致有数。 其实这是一种最朴素的记数方式，数学家称之为 一进制记数法（unary numeral system）。我们把它符号化一下，比如用斜杠 / 来表示： 1 就是 /； 2 就是 //； 4 就是 ////； 好像没毛病，我们平时掰手指用的就是这种记数法，但数字一大，场面就要失控了。 符值相加记数法为了解决记录大数的问题，于是我们得发明一些其他符号来表示更大的数值，比如用横杠 - 表示 10，用十字 + 表示 100。那么： 16 就是 -//////; 32 就是 ---//; 128 就是 +--////////; 漂亮….这种靠符号类型和符号数量表示数字的方法被称为 符值相加记数法（sign-value notation），古埃及和古罗马用的都是它，只不过符号各不相同。 古埃及的记数符号： 1 10 100 1000 10000 100000 1000000 1024 在古埃及就写作： 你会发现，符值相加记数法的一大优点是，符号的顺序可以任意打乱，数字含义不受影响。我国藏族曾用石子表示 1、木棍表示 10、果核表示 100、蚕豆表示 1000、瓦片表示 10000，那么，当你把 1 颗蚕豆、2 根木棍和 4 颗石子胡乱地攥在手里，别人依然知道它们是 1024。 古罗马的做法略有不同，他们对五进制情有独钟： 1 5 10 50 100 500 1000 I V X L C D M 这些符号沿用至今，想必大家（至少对前 3 个）都比较熟悉，许多钟表仍保留着使用罗马数字的习惯，1~12 分别表示为：I、II、III、IV、V、VI、VII、VIII、IX、X、XI、XII。你会发现，罗马记数法是符值相加记数法的变种，因为它不光「相加」，还「相减」。这种方式就不允许符号乱序了，IV 和 VI 表示的是不同的数字。 那罗马人何苦要使用这种更复杂的记数法呢？无非是为了读写方便。同样表示 9，IX 比 VIIII 更简洁。 其实有一种更好使的方法——用另外一些列符号来表示符号的数量。比如用 A 表示 1 个符号，用 B 表示 2 个符号，以此类推，用 I 表示 9 个符号。 如此，上文表示 256 的 ++-----////// 就可以写作 B+E-F/。你一定感觉莫名其妙，这种写法哪里方便了。其实中文的数字表示就是这种形式，只不过我们用得太习惯了，以至于没有发现。 在中文中，个、十、百 代替了 /、-、+，而 一、二、三 代替了 A、B、C。256 就写作 二百五十六个，个 比较累赘，我们通常把它省略了。 其实像日语、英语用的也同样是这种记数法，简洁、优雅。 美中不足的是，这种形式虽便于读写，却不便于计算。中国古人为算筹和算盘这类经典算具搭建起广阔的舞台，却没给笔算留出一席之地。想象一下，如果让你把这些汉字写在草稿纸上，列个竖式，你的内心一定非常别扭。 位值制记数法公元5世纪，印度数学家阿耶波多（Aryabhata 476–550）创立了现在广泛使用的 位值制记数法（positional notation/place-value notation），该记数法使用的主要符号，是同为印度人发明的阿拉伯数字：0、1、2、3、4、5、6、7、8、9。 与符值相加记数法类比，位值制中的 1、2、3 代替的是 A、B、C，那 /、-、+ 呢？是 靠阿拉伯数字的位置来表示的。众所周知，最右位相当于 /，次右位相当于 -。靠每个位置上的数值来表示数字，故名位值制。 严谨的数学家用一种多项式高度概括了位值制记数法的本质，在十进制中，这个多项式是这样的： 这是一个 n 位十进制数，ai 就是第 i 位上的数值。为便于直观理解，举个 1024 的例子吧： 由于我们熟悉了十进制，这样费心费力的展开可能会让你觉得好笑，但当我们把它推广到其他进制时，这个多项式的价值就体现了出来。n 位 b 进制数的位值制表示： 1024 用二进制怎么表示？ 因此，1024 的二进制写作 10000000000。 除了最普遍的十进制和计算机中的二进制，常见的还有七进制（如 1 周 7 天）、十二进制（如 1 年 12 个月）、十六进制（如古代 1 斤 16 两）、六十进制（如六十甲子）等等，只要有意义，任何进制都可以为你所用。 非标准位值制在上述的多项式中，如果 ai 或 b 的取值奇葩一点，就形成了 非标准位值制（non-standard positional numeral systems），这类记数法往往应用于专业领域，很难在日常生活中见到。比如标准位值制中的三进制 ai 的取值为 0、1、2，但在一种名为平衡三进制（balanced ternary）的非标准位值制中，ai 取 -1、0、1，苏联曾使用这种进制研发电子计算机。 Part 2. 二进制简介 图片来源：https://zhuanlan.zhihu.com/p/26743163 至此，你对「二进制」应该会感觉亲切了些，它只是一种数制而已，本质上与我们熟悉的十进制没有很大的差别，我们这一 Part 来稍微理解一下二进制。（至于电脑为什么使用二进制我们在下一 Part 中介绍） 二进制的基本运算十进制中的那些基本运算原则，二进制中同样适用，只不过需要稍加变幻而已，下面我们分别就加、减、乘、除四则运算来介绍。 二级制加法根据「逢二进一」规则，二进制数加法的法则为： 0＋0＝0 0＋1＝1＋0＝1 1＋1＝0 （进位为1） 1＋1＋1＝1 （进位为1） 例如：1101 和 1011 相加过程如下： 二进制数的减法根据「借一有二」的规则，二进制数减法的法则为： 0－0＝0 1－1＝0 1－0＝1 0－1＝1 （借位为1） 例如：1101 减去 1011 的过程如下： 二进制的乘法二进制数乘法过程可仿照十进制数乘法进行。但由于二进制数只有 0 或 1 两种可能的乘数位，导致二进制乘法更为简单。二进制数乘法的法则为： 0×0＝0 0×1＝1×0＝0 1×1＝1 例如：1001 和 1010 相乘的过程如下： 二进制的除法二进制数除法与十进制数除法很类似。 例如：100110 ÷ 110 的过程如下： 二进制为什么能表示所有的数据因为编码规定。 之前我们有说到，所有保存的程序和数据在计算机中都被描述为 文件，也就是说我们能够知道当前的数据集合被期望的用途是什么，也就能够找到对应的 处理器 来正确处理当前的数据。 例如保存文字拿文字举例，为了让一串 0、1 能够代表特定的文字，人们规定使用一个字节中的七位来表达特定的文字， 这就是大名鼎鼎 ASCII (American Standard Code for Information Interchange) 码，ASCll 码能够表达 27=128 种字符(编码从 0~127)，对于 26 个英文字母和一些常用的可打印字符，这完全足够了： 可是，世界文化是多元的，面对类似汉字这样的象形文字，ASCll码表用起来自然是捉襟见肘。 穷则思变，一个字节不行，那就两个字节，这就是大名鼎鼎的 Unicode 码，不难看出，Unicode 码有 216=65536 种表示方式，这样就足以表达一些常用的字符了，值得一提的是，Unicode 码算是在 ASCll 码上的一种扩充,其第 0~127 个编码字符与 ASCll 码表一模一样。 再比如图片这里涉及一点点物理知识，话说很久以前，牛顿通过三棱镜把白色的光分解成七种不同颜色的光，后来又通过各种实验发现红、绿、蓝三种颜色的光是无法被分解的，因此我们就称为红蓝绿为光的三原色。 至此人类已经知道了：可以通过组合不同比例的红、绿、蓝三种颜色来获得各种各样的颜色，那么我们就可以在计算机上模拟了。现在的计算机，一般使用 32 位来表示颜色，32 位平分给四个分量，也就是每个分量 8 位。 为啥是四个颜色分量? 因为颜色模型中有一个 alpha 值，用来表示透明度，这一点我们先不考虑。总之三种颜色，每个使用 8 位来表示的话，我们就能够表示 256 * 256 * 256 = 16777216 种颜色了，已经足够基础的使用了。 先来看一张图片： 这张图像的尺寸是 600px * 664px（px 是一种图片单位，中文名称为像素，你可以暂时理解为一个点）。我们把它放大一下，如下图所示： 看见了吗？实际上，大部分图像（你拍摄的照片、你扫描的图片、你使用 iPad 画的图片等等…）都是位图文件，位图就是由像素点构成的，它就像是一个网格一样，每个格子里面填一个颜色。（除了位图外，还有一种图是矢量图，它描述的是形状而非网格） OK，我想你已经能理解图像是由像素点组成的了（事实上我们的显示器也是），我们只需要在编码中附带上一些额外的信息，例如图像有多大的尺寸、时间、作者、颜色深度、是否支持透明度之类的就能够对图像进行正确表示了。（视频可以简单理解成一张张连续不断的图片） 要让显示器正确显示图片或者视频，只需要让显示器上每个像素显示特定的颜色就好了。 图片来源：https://www.bbc.co.uk/bitesize/topics/zf2f9j6/articles/z2tgr82 Part 3. 为什么是二进制？ 图片来源：https://zhuanlan.zhihu.com/p/33439000 可为什么一定是二进制呢？使用人类习惯的十进制不好吗？ 理由一：物理上易于实现计算机依靠电力工作，这也就意味着需要将数字信号映射到电信号，实现这种映射最简单的方法是： 0 - 没有电（0 V） 1 - 有点（5 V） 二进制在技术上最容易实现。这是因为具有两种 稳定状态 的物理器件很多，如门电路的导通与截止、电压的高与低等，而它们恰好可以对应表示 “1” 和 “0” 这两个数码。假如采用十进制，那么就要制造具有 10 种 稳定状态 的物理电路，而这是非常困难的。 理由二：机器可靠性高为什么使用更复杂的数字系统是一个问题？ 假设我们使用三元（3 位数字）数字系统涉及计算机，如果我们具有从 0 V 到 5 V 的电压，那么我们可以进行以下的映射： 0 - 0 V; 1 - 2.5 V; 2 - 5 V; 图片来源：https://pmihaylov.com/intro-binary-numbers/ 看起来合理吧？但是，想象一下，我以 2.5 V 的电压发送了一个数字。但是由于电路中的一些噪声，我在输出端得到 2.3 V 的电压，因此将其视为 0。结果是？ 有人给我发送了 1，但我将其视为 0。数据丢失可是一个非常严重的问题。 使用二进制则可靠得多，由于电压的高和低、电流的有和无等都是一种 质的变化，两种物理状态稳定、分明，因此，二进制码传输的抗干扰能力强，鉴别信息的可靠性高。 为什么计算机系统必须有时钟 图片来源：http://programmedlessons.org/Java9/chap02/ch02_11.html 建立数字系统的目的是 仅在某些时间点测试开/关（二进制）值，这使电线（或其他设备）有时间更换。这就是计算机系统有时钟的原因。 时钟会周期性地进行信号的测量，图中所示的 T1 和 T2 就是可以测量信号的时间点。 时钟利用所有这些时间点来保持同步。更快的时钟意味着每秒可以对电线进行更多次测试，并且整个系统运行得更快。2 GHz 处理器每秒检查二进制值 20 亿次。在这些时间之间，允许值改变并稳定下来。处理器芯片速度越快，每秒可以测试的次数就越多，每秒可以做出的决策就越多。 理由三：运算规则简单数学推导已经证明，对 N 进制数进行算术求和或求积运算，其运算规则各有 N(N+1)/2 种。如采用十进制，则 N=10，就有 55 种求和或求积的运算规则；而采用二进制，则 N=2，仅有 3 种求和或求积的运算规则，以上面提到的加法为例： 0+0=0，0+1=1 (1+0=1)，1+1=10 因而可以大大简化运算器等物理器件的设计。 理由四：逻辑判断方便采用二进制后，仅有的两个符号 “1” 和 “0” 正好可以与逻辑命题的两个值 “真” 和 “假” 相对应，能够方便地使用逻辑代数这一有力工具来分析和设计计算机的逻辑电路。 虽然在 1950 年代就造出了更加高效的三元计算机，但在效率和复杂度的取舍上，始终抵不过二进制。二进制仍然在当今世界中长期存在。 Part 4. CPU 的实际工作方式上面我们了解到计算机以二进制的形式运行，它们只有两种状态：开（1）和关（0），为了执行二进制计算，我们需要采用一种特殊的电子元器件，称为 「晶体管」。暂时我们把它理解为一种开关吧，通电就打开，没电流通过就关闭。 利用”开关”搭建逻辑电路我们知道，给电灯通上电，它就会亮： 于是，结合上开关，我们就能搭建出最基础的 与门 和 或门。 与门 该电路的逻辑是：只有当 A 和 B 同时开启时，LED 灯才会亮，也就是认为输出 1，我们可以利用电信号来简单模拟一下： A B Y 0 0 0 1 0 0 0 1 0 1 1 1 或门 该电路的逻辑是：当 A 或者 B 开启时，LED 灯就会亮，也就是认为输出 1，我们可以利用电信号来简单模拟一下： A B Y 0 0 0 1 0 1 0 1 1 1 1 1 其他门类似地，我们可以借助更多的电子元器件来创造出基础的 7 种逻辑门电路： 图片来源：https://www.zhihu.com/question/348237008/answer/843382847 | @Zign 这里需要特别提一下 异或门，我们需要先知道有一种电子元器件可以利用电气特性对 输入取反，也就是说输入 1 则输出 0，输入 0 则输出 1，那么我们就可以 简单模拟 出异或门逻辑电路（实际会更复杂些，这里仅展示出异或的意思）： A&#39; 和 B&#39; 分别表示 A 和 B 开关的反值，从图中我们很容易知道只有当 A、B 只存在一个输入 1 时，整个电路才会输出 1。 利用逻辑门简单计算加法OK，上面我们了解到我们能够利用 “开关” 来模拟逻辑的运算，我们接下来试着还原一个简单的加法运算器是如何实现的： 仅需两个门，就可以完成基本的二进制加法运算。上图是利用 logic.ly 创建的半加法器，A、B 相当于使我们计算的两个数，最后一块相当于是我们的数显芯片，它的功能是根据输入显示数字，从上到下的引脚（也就是图中输入的地方，通常我们这样称呼）分别对应了 20=1、21=2、22=4、23=8 的输入，没有任何输入时显示为 0，如果 引脚 1（对应 20=1）像上图一样有输入，则显示 0 + 1 = 1。 我们来理解一下上方的电路： 如果仅打开一个输入，但不同时打开两个输入，则此处的 XOR 门（异或门）将打开，此时对应输入 引脚 1，显示 数字 1（类似于 1 + 0 和 0 + 1)； 如果两个输入均打开，则 AND 门(与门)将打开，此时对应输入 引脚 2，显示 数字 2（类似于 1 + 1）； 如果没有输入，则 AND 门和 XOR 门都保持关闭，此时显示 数字 0（类似于 0 + 0）； 因此，如果两个都打开，则 XOR 保持关闭，并且 AND 门打开，得出正确的答案为 2： 但这只是最基础的半加法运算器，不是太有用，因为它只能解决最简单的数学问题之一。但如果我们把它们两个与另一个输入连接，就会得到一个完整的加法器： 仔细思考几遍，你就会得知这个三个输入的加法器已经可以计算 3 个二进制数字的加法运算了，我们如法炮制，可以通过连接更多的”进位”来使这个加法器能够运算更多的数，这当然也意味着这个计算链条更长。 大多数其他数学运算都可以加法完成。乘法只是重复加法，减法可以通过一些奇特的位反转来完成，而除法只是重复减法。并且，尽管所有现代计算机都具有基于硬件的解决方案以加快更复杂的操作，但从技术上讲，您可以使用完整的加法器来完成全部操作。 总线和内存现在，我们的计算机只不过是一个计算器，它记不住任何内容也对输出没有任何操作，上述电路只是接了一个显示单元而已。 上面展示的是一个存储单元。它使用了大量的 NAND 门，并且在实际生产中，根据存储技术的不同，它们可能会大不相同，但其功能是相同的。 您给它一些输入，并打开“写”位（Write 输入 1），它将把输入存储在单元内。这不仅是一个存储单元，因为我们还需要一种从中读取信息的方法。这是通过一个使能器完成的，该使能器是「存储器」中每个位的“与”门的集合，所有位都与另一个输入（即“读取”位）绑定在一起。写入和读取位通常也称为“设置”(set)和“启用”(enable)。 上面整个存储单元都包裹在所谓的寄存器中。这些寄存器连接到 总线，总线是围绕整个系统运行的一束电线，并连接到每个组件。即使现代计算机也具有总线，尽管它们可能具有多个总线以提高多任务处理性能。 每个寄存器仍有一个读写位，但是在这种设置下，输入和输出是一样的。这实际上很好。例如：如果要将 R1 的内容复制到 R2，则应打开 R1 的读取位，这会将 R1 的内容压入总线。当读取位打开时，您将打开 R2 的写入位，这会将总线内容复制到 R2 中。 寄存器也用于制作 RAM。RAM 通常布置在网格中，并且导线有两个方向： 解码器采用二进制输入并打开相应的编号线。例如，11 在二进制数中是 3，即最高的 2 位数字，因此解码器将打开最高的线路。每个路口都有一个寄存器。所有这些都连接到中央总线以及中央写入和读取输入。只有跨寄存器的两条导线也都打开时，读和写输入才会打开，从而有效地允许您选择要从中进行读写的寄存器。同样，现代 RAM 要复杂得多，但是此设置仍然有效。 时钟，步进器和解码器寄存器无处不在，是在 CPU 中移动数据并将信息存储在 CPU 中的基本工具。那么，是什么告诉他们移动数据的呢？ 时钟是 CPU 核心中的第一个组件，它将按设置的时间间隔（以赫兹或每秒周期为单位）关闭和打开。这就是您看到的最直观的 CPU 速度指标。 时钟具有三种不同的状态：基本时钟，使能时钟和设置时钟。基本时钟将打开半个周期，另一半关闭。使能时钟用于打开寄存器，并且需要更长的时间才能确保数据被使能。设置时钟必须始终与使能时钟同时打开，否则可能会写入错误的数据。 时钟连接到步进器，步进器将从 1 到最大步数进行计数，并在完成后将自身重置为 1。时钟还连接到 CPU 可以写入的每个寄存器的 AND 门： 这些 “与” 门还连接到另一个组件的输出，即指令解码器。指令解码器接受 SET R2 TO R1 之类的指令，并将其解码为 CPU 可以理解的内容。它有自己的内部寄存器，称为“指令寄存器”，该寄存器存储了当前操作。它的精确程度取决于您正在运行的系统，但是一旦解码，它将打开正确的设置并启用正确寄存器的位，这些寄存器将根据时钟触发。 程序指令存储在 RAM（或现代系统中的 L1 高速缓存，更靠近 CPU）中。由于程序数据与其他所有变量一样都存储在寄存器中，因此可以随时对其进行操作以在程序中跳转。这就是程序通过循环和 if 语句获取结构的方式。跳转指令将指令解码器正在读取的存储器中的当前位置设置到其他位置。 一切如何配合 现在，我们对 CPU 工作原理的有了一些基本的了解。主总线跨越整个系统，并连接到所有寄存器。完整的加法器以及其他一系列运算都打包在算术逻辑单元或 ALU 中。该 ALU 将与总线建立连接，并且还将具有自己的寄存器来存储正在操作的第二个数字。 为了执行计算，将程序数据从系统 RAM 加载到控制部分。控制部分从 RAM 中读取两个数字，将第一个数字加载到 ALU 的指令寄存器中，然后将第二个数字加载到总线上。同时，它向 ALU 发送指令代码，告知其操作方法。然后，ALU 执行所有计算，并将结果存储在另一个寄存器中，CPU 可以从该寄存器中读取该值，然后继续该过程。 参考资料 原来，我们是这样记数的 - https://www.jianshu.com/p/58844323e4fb 二进制数的运算方法 - https://www.jianshu.com/p/560aba49c9a4 文字,图片,视频,音频的二进制表示 - https://blog.csdn.net/c46550/article/details/91040925 知乎 - 计算机只认识0和1但是怎么表示图像和影视等等众多应用的？ | @kross - https://www.zhihu.com/question/36269548 Introduction to binary numbers - https://pmihaylov.com/intro-binary-numbers/ What is Binary, and Why Do Computers Use It? - https://www.howtogeek.com/367621/what-is-binary-and-why-do-computers-use-it/ CPU 是怎样认识代码的？ | 知乎 - https://www.zhihu.com/question/348237008/answer/843382847 | @Zign HTG Explains: How Does a CPU Actually Work? - https://www.howtogeek.com/367931/htg-explains-how-does-a-cpu-actually-work/ 往期推荐 「MoreThanJava」当大学选择了计算机之后应该知道的 「MoreThanJava」计算机发展史—从织布机到IBM 「MoreThanJava」计算机系统概述 妈妈再也不担心我面试被Redis问得脸都绿了 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编码之前需要知道的事","slug":"基础知识/编码之前需要知道的事","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」计算机系统概述","slug":"「MoreThanJava」计算机系统概述","date":"2020-05-31T23:10:00.000Z","updated":"2020-12-09T04:38:48.786Z","comments":true,"path":"2020/06/01/morethanjava-ji-suan-ji-xi-tong-gai-shu/","link":"","permalink":"http://www.wmyskxz.com/2020/06/01/morethanjava-ji-suan-ji-xi-tong-gai-shu/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 计算机是由 硬件 和 软件 组件组成的复杂系统。希望通过本篇文章能够扩展和加深您对「计算机系统」的了解和认识。 Part 1. 硬件和软件想一想《复仇者联盟》系列电影？ 图片来源：https://new.qq.com/cmsn/20181208/20181208006498.html 当你开始想《复仇者联盟》时，通常你都不会考虑任何关于 “物理” 方面的东西，例如影片是存储在哪一种物理媒介(例如 DVD、电影胶卷)上，或者是播放影片所需的物理设备（例如 DVD 机、电影放映机）。因为一张 DVD 是有实体的物理设备，而电影本身确是一种没有实体的数据信息。 硬件 这个词通常就用于称呼那些有实体的「物理设备」，如电视机、DVD 播放器和电脑等。 软件 则是指与 硬件 一起使用的「数据信息」，如电影、音乐、小说、网页、计算机程序等。 「数据信息」是非常有趣的东西，你此刻正在查看的网页、浏览的视频，它们的实际数据可能存储在中国乃至世界的任何一个角落。在数据从源头的物理设备复制到你的物理设备之前，可能已经辗转复制了成几百次，最终到达浏览器并交由系统渲染，在屏幕上还原出这些数据。 硬件组成 图片来源：https://zhuanlan.zhihu.com/p/33574137 计算机系统的主要 硬件组成 是： CPU（处理器）； 主要存储器（内存）； 辅助存储器（硬盘）； 输入设备（如键盘、鼠标）； 输出设备（如显示器）； 对于典型的台式计算机来说，CPU、主存、辅存、电源加上其他支持的硬件设备（如光驱，也就是放光盘的设备）通常都是放在金属外壳中，上述的这些组件也都是连接到俗称「主板」的计算机电路板上，而各种输入输出设备则通过暴露在金属外壳背面的连接器连接。 当然排除部分比较硬核的「搞机玩家」，如「鞋盒低成本版」： 再比如「终极水冷」： 主板主板是用来连接其他硬件的「桥梁」。 如果把电脑比作是航空母舰，那么主板就是航母主体，其他控制中心、动能装置、武器设备等都必须安装在这个航母上才能协同使用，缺一不可。 图片及引用：https://www.zhihu.com/question/59272639（作者知乎：@黎小白） 我们来看一个典型的主板组成，这里只介绍一些重要常用的组件。（完整的可以参看上方图片下面的链接） 图中 1 -&gt; CPU 插槽 CPU 插槽（英语：CPU socket）是计算机里主板上固定住 CPU 并导通电气讯号的一种插槽。不同 CPU 系列使用不同插槽。 图中 4 -&gt; 内存插槽内存插槽是指主板上用来插内存条的插槽。 DDR4 内存条（第四代内存条）拥有与 DDR3、DDR2 或 DDR 内存条相同的外观，但是 DDR4 内存条插槽的缺口与 DDR3、DDR2 或 DDR 内存插槽不同，以防止插入错误的内存条。 PS：这里只展示了 ASUS X99-DELUXE 的内存安装方式，不同主板的内存安装方式可能不同，具体请按照主板说明书进行，否则系统将可能无法启动。 图中 5 -&gt; PCI 扩展插槽凡是显卡、网卡、声卡和 SCSI 卡等符合 PCI 接口规格的设备，都可以使用这些 PCI 扩展插槽。 图中 9&amp;10 -&gt; 主板电源插槽这些电源插槽用来连接一个 ATX +12V 电源。24-pin 插槽用于主板供电，8-pin 插槽用于 CPU 供电。 电源所提供的连接插头已经过特别设计，只能以一个特定方向插入主板上的电源插槽。找到正确的插入方向后，仅需稳稳地将之套进插槽中即可。 图中 11 -&gt; 后侧面板连接端口 图中 12 -&gt; USB 连接插槽这个插槽用来连接 USB 模块，可在前面板或后侧连接端口扩展 USB 模块。 USB 连接插槽分为 USB 2.0 和 USB 3.0。 注意： 请勿将 1394 排线连接到 USB 2.0 插槽上，同理，也不要将 USB 2.0 排线接到 1394 插槽上，这么做可能会导致主板的损毁。 图中 14 -&gt; SATA 设备连接插槽这些插槽可支持使用 Serial ATA（SATA）排线来连接 SATA 硬盘和光驱。 PS：上面是一些常见的主要组成，其结构会因不同主板而又略微的不同，例如有些主板没有显示器接口（独立显卡）。 CPU（中央处理器）CPU 常常被比喻为计算机系统的 “大脑”，这非常符合。 处理器 执行计算机系统的 所有基本计算。其他组件则是通过执行诸如 「存储数据」 或 「将数据移入和移出处理器」 之类的工作来促进计算。但是处理器是发生基本动作的地方。 处理器非常努力，但同时它也不那么”聪明”，它唯一要做的就是执行老板（正在运行的程序）的命令（指令），它从来不问那些命令到底是做什么，只负责执行。这也就是为什么程序和 CPU 之间存在一个称为「操作系统」的中间人的原因。 （Ps: 关于 CPU 其他知识我们会在之后来详细说。） Hz 代表什么？通常我们讨论 CPU 时，都会说这个 CPU 的是多少多少赫兹的，它其实 代表的就是 CPU 执行指令的速度（≈运行速度）。 每个 CPU 都有一个非常简单但非常重要的组件，它被称为 时钟。其唯一的目的就是 按一致的方式 来 打开 和 关闭 电信号，就像是您的心脏每秒跳动一次一样，时钟也会周期性地产生高电压信号和低电压信号。 1 Hz 表示每秒 1 个周期，也就是每秒产生一个高压信号一个低压信号，3 Ghz 也就是表示每秒 3 千万个周期。因此，如果一条指令需要 5 个时钟周期才能完成，则 CPU 的时钟越快，该指令将被执行得越快。（但现在 CPU 的快慢并不能简单考虑 Hz 大小，还得附加考虑”多核”和每个周期内能够完成的工作量的因素） CPU 可以有多快？ 普通台式计算机可以在不到百万分之一秒的时间内执行一条指令，即使是真空中传播的光，在这段时间内也只能走 10 厘米左右，而超级计算机（在所有计算机中速度最快）可以在不到十亿分之一秒的时间内执行一条指令！ CPU 的基本要素 图片来源：https://www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/ 寄存器： 寄存器是一个很小的地方，用于保存处理器的数据。寄存器用于存储信息，例如指令，存储地址和任何类型的数据，例如位序列或任何字符等。处理器的寄存器应足够大以存储所有给定的信息。64 位处理器应至少具有 64 位寄存器和 32 位处理器的 2 位寄存器。寄存器是所有存储设备中最快的。 L1和L2高速缓存存储器： 高速缓存存储器是一种类型的存储器，位于处理器的芯片中，或者可以通过总线单独连接。高速缓冲存储器的用途是存储程序指令，这些指令被软件一次又一次地用于操作。当 CPU 处理数据时，首先将数据查找到高速缓存中。如果找到了数据，则它将相应地使用该数据；如果未找到，则处理器开始在较大的内存中查找，这实际上是耗时的。高速缓存的成本很高，但速度确实很快。 CPU 如何执行程序指令 | 简单原理典型的 CPU 可以简单看成由 「控制单元」 和 「逻辑单元」 组成。 在执行一条指令之前，必须将程序指令和数据从输入设备或辅助存储设备放入内存中，一旦必要的数据和指令存储在内存中，中央处理单元就会对 每个指令 执行以下四个步骤： 「控制单元」从「存储器」中获取指令； 「控制单元」对指令进行解码（确定含义），并指示将必要的数据从存储器移至「逻辑单元」； 「逻辑单元」执行算术或逻辑指令； 「逻辑单元」将该运算的结果存储在存储器或寄存器中； 控制单元最终指示存储器将结果释放到输出设备或辅助存储设备。这一套步骤下来就被称为 「机器周期」。单个机器周期指令可以由大量子指令组成，每个子指令必须至少占用一个时钟周期（上面提到的一个上下脉冲时间）。 每种类型的中央处理单元都 只能理解一组特定的指令，称为 「指令集」。正如人们可以理解许多不同的语言一样，每种不同类型的CPU都有其可以理解的指令集。 将指令和数据存储在内存中是一回事，而控制单元能够找到它们又是另一回事。它是如何做到的？ 每个指令和每个数据在「存储器」中的位置都有一个地址标识。也就是说，每个位置都有一个地址号码，就像公寓前面的邮箱一样。并且，与邮箱一样，位置的地址号保持不变，但是位置的内容（指令和数据）可能会更改。 但是，与邮箱不同，内存位置只能容纳固定数量的数据；地址只能容纳固定数量的字节-在现代计算机中通常为两个字节。 32 位 和 64 位？您可能已经听说过 N 位处理器的概念。最常见的是 32 位和 64 位处理器。这些位确定传入和传出处理器的 数据量大小。具体会有以下几点不同： 一、处理数据的能力不同 32 位和 64 位表示 CPU 一次能处理的最大位数，理论上来说，64 位系统处理的数据效率比 32 位更高，相当于单车道和双车道开车似得，双车道单位时间可以有更多的车辆通行。但需要内存跟上，而且程序本身也是 64 位编译才能发挥 64 位系统的优势。 二、支持的内存不同（寻址能力不同） 简单来说，32 位系统的最多能在是 232=4294967296=4 (GB) 左右的内存里面找程序所需要的数据，而 64 位系统这就最大支持 128 GB 内存； 三、软件兼容性不同 32 位系统无法运行 64 位软件，64 位系统可以安装多数 32 位软件，以前因为大部分软件都是基于 32 位架构环境下开发，所以 64 位系统的兼容性不如 32 位。但现在 64 位兼容性也很强了，基本都是可以兼容各类软件了，而且 64 位的病毒都少了很多。 特别是大量消耗内存的软件，如 PS，64 位和 32 位软件在 64 位系统里区别很大，64 位真的快许多。 存储器内存和硬盘的差别内存 中通常放置的是您 短期存储 的数据，而 硬盘 中存放的则是 长期存储 的数据。 想象一下您正在办公，并且您拥有一个 办公桌 和一个 文件柜，那么此时办公桌的区域则代表了内存，文件柜则代表了硬盘。 刚开始工作不久，你就把需要使用的物品放置在了您的办公桌上，以便于使用，但由于桌子大小的限制，不能在桌上存放太多的东西。必须保留但不一定很快就可以访问的项目存储在文件柜中。根据文件柜的大小的不同，可以存储许多东西。 内存和硬盘之间的重要区别是前者在计算机关闭时会清除。另一方面，无论关闭计算机多少次，硬盘都将保持不变（除非物理破坏）。因此，类似于办公桌和文件柜，您离开办公室时在办公桌上留下的所有文件都会被丢弃。文件柜中的所有内容都将保留。 数据如何表示？在主存储器和辅助存储器中，信息都以 位(bit) 模式存储。这是一个单一的开/关值，仅开/关这两种值是可能的。（也就是俗称的「二进制」） 有很多方法可以实现这一点，下面我们来列举一些： 机械上电器的开关（如电灯开关）； 电线上的高低电压； 单个晶体管； 磁盘表面的一小部分； 磁带表面的一小部分； 卡上打了一个洞；（如上一篇文章提到的制表机） More.. 在主存储器和辅助存储器中，位的实现方式不同，但是从逻辑上讲，两种类型的存储器都存储表示为位模式的信息。 字节 | 存储单位一位能表示的信息太少了，以至于通常计算机内存被分成八位一组，每个八位组称为一个 字节。 一个字节大约足以容纳一个字符。 当某些数据需要八个以上的位时，将使用几个字节。通常，四个字节用于表示整数。 通常，我们需要用成千上百，甚至上亿，几十亿的字节来表示某一些数据，这样大数量的字节数我们又规定了一些单位，如下表所示：（仅列出常用单位） 名称 字节数 2 的幂 字节 1 20 千字节(kilobyte，俗称 1 Kb) 1024 210 兆字节(megabyte，俗称 1 Mb) 1,048,576 220 十亿字节(gigabyte，俗称 1 Gb) 1,073,741,824 230 万亿字节(terabyte，俗称 1 Tb) 1,099,511,627,776 240 硬盘计算机系统的硬盘将字节记录在磁性表面上，就像录音带的表面一样。 数据的记录（写入）和读取使用类似于磁带的读写头完成。 图片来源：http://programmedlessons.org/Java9/chap03/ch03_11.html 上图显示了一个可移动臂末端的一个磁盘和一个读/写头。手臂沿着磁盘的半径移动。由于磁盘正在旋转，它将在磁盘上的圆形轨道中记录数据。稍后，要读取数据，必须将其移至正确的位置，然后必须等待直到旋转磁盘将数据放置到位。与录音带一样，无需更改即可读取数据。记录新数据时，它将替换以前在该位置记录的任何数据。与音频磁带不同，读/写磁头实际上并不接触磁盘，而是略高于磁盘。（由于磁盘在计算机启动时一直在旋转，因此如果读写头接触到磁盘，磁盘很快就会磨损。） 通常，称为计算机系统硬盘的组件包含许多单独的磁盘和上述的读/写磁头。磁盘的两面都涂有磁性材料（因此，每个磁盘都有两个读/写磁头），并且所有磁盘都连接到一个主轴上。所有磁盘和磁头均密封在无尘的金属容器中。由于硬盘的操作涉及机械运动（比电子过程要慢得多），因此读写数据要比使用主存储器慢得多。 文件（File）硬盘（和其他辅助存储设备）用于长期存储大信息块，例如程序和数据集。通常，硬盘内存被组织成 文件，一个文件是已经被赋予了名称，并存储在辅助存储器的 信息集合。该信息可以是程序，也可以是数据。 文件中的信息表示方式与任何数字信息相同——它由位组成，通常分为八位字节。文件通常很大；它们的大小以千字节(Kb)或兆字节(Mb)为单位。 文件和操作系统主存储之外的大多数数据集合都组织成文件。跟踪所有这些信息是操作系统的工作之一。如果计算机是网络的一部分，那么跟踪所有计算机上的所有文件是一项艰巨的工作，并且涉及网络上的所有操作系统。 应用程序（包括您可能编写的程序）不会直接读取，写入，创建或删除文件。 由于操作系统必须跟踪所有内容，因此所有其他程序都要求操作系统执行文件操作任务。例如，假设某个程序刚刚计算出一组数字，则需要保存它们。以下可能发生的操作方式： 👨‍💻‍程序： 要求操作系统创建一个名称为RESULTS.DAT的文件 💻操作系统： 获取请求；查找磁盘的未使用部分并创建一个空文件。程序完成时会被告知。 👨‍💻‍程序： 要求操作系统将数字保存在文件中。 💻操作系统： 从程序的主内存中获取数字，并将其写入文件。程序完成时会被告知。 👨‍💻‍程序： 继续进行任何操作。 文件类型就硬盘而言，所有文件都是相同的。在电子级别，包含程序的文件和包含数据的文件之间没有区别。所有文件都被命名为字节集合。当然，这些文件的用途不同。操作系统可以获取程序文件，将其复制到主内存中，然后开始运行。操作系统也可以获取数据文件，并在需要时将其信息提供给正在运行的程序。 然而，我们通常会看到文件名的最后一部分（扩展名）通常会显示该文件的 预期用途。例如，mydata.txt 的扩展名 .txt 意味着该文件应被用作文本（即字符）的集合，program.exe 扩展名 .exe 就标识着该文件是一个 “可执行文件”，也就是一个程序，在 Windows 中可以直接运行。 当文件以非预期用途使用时会发生什么？例如，如果您尝试在 “.EXE” 文件上使用文字处理器，该怎么办？ 这当然会出现问题。因为 .exe 文件中包含的信息使用的是文字处理器无法理解的位模式表示。 就像遇到某人说您不懂的语言一样。他们发出的声音与您相同（大部分情况下），但是它们发出的声音（单词和句子）的模式不同。 软件 图片来源：https://www.aqniu.com/learn/48019.html 计算机软件由 程序 和 数据 组成的。 程序 包含用于处理器（CPU）的指令。数据 可以是程序需要的任何信息：字符数据，数字数据，图像数据，音频数据和无数其他类型。但是，程序和数据之间的区别并不像您想象的那么清晰。 记住这个重要的基本思想： 程序和数据都以相同的方式被保存在计算机存储器中。也就是说在存储器中（主存储器和辅助存储器），程序和数据并无任何区别。 举个例子：这就像你写或者画东西在纸上一样，对于纸来说，并无什么特别的区分。 可以使用相同的电子的存储方式来保存数据和程序对于计算机科学来说是一个重要的概念，这意味着计算机系统提供可以根据需求来将内存用于程序或数据。 程序类型有两类程序：应用程序、系统程序。 应用程序 是人们用来完成工作的程序。系统程序 用来使硬件和软件平稳运行。 重要的系统程序是操作系统。当计算机运行时，操作系统始终存在。它协调计算机系统其他硬件和软件组件的操作。操作系统负责启动应用程序，运行它们并管理它们所需的资源。当应用程序正在运行时，操作系统将为其管理硬件的详细信息。例如，当您在键盘上键入字符时，操作系统将确定它们打算用于哪个应用程序，并完成将其放置在那里的工作。 一些 「嵌入式系统」 不使用操作系统，而是直接在处理器上运行其程序。例如：交通灯、微波炉、洗衣机等等。 用于台式计算机的现代操作系统几乎都带有用户界面，该界面使用户能够通过使用窗口，按钮，菜单，图标，鼠标和键盘轻松地与应用程序（以及与操作系统本身）进行交互。例如：Unix，Linux，Android，Mac OS 和 Windows。 操作系统操作系统是一个复杂的程序，可以使计算机系统的硬件和软件组件保持协调和运行。就像一家小商店的所有者一样，他通过拜访客户，接受送货，在架子上储货，进行簿记等来保持一切井井有条。店主必须及时处理出现的任务。没有店主，商店就无法运转。 大多数计算机系统都可以运行多种操作系统中的任何一种。例如，大多数基于奔腾的计算机都可以运行 Linux 或 Windows 操作系统。尽管某些计算机有多个操作系统，但通常在一个计算机系统上仅安装一个操作系统。无论如何，一次只能控制一个操作系统。计算机用户可以在计算机打开时进行选择，并且操作系统将一直处于控制状态，直到计算机关闭为止。 首次启动计算机时，硬件会自动加载操作系统并开始运行。此过程称为 启动。之所以说这是个奇怪的术语，是因为操作系统本身参与了其自身的运行，这一过程就像某人 “自己拉自己一把” 一样。操作系统运行后，将用于启动应用程序。 一个应用程序启动时的场景 用户要求运行应用程序。 通过单击图标，选择菜单或通过其他方式可以完成此操作。 操作系统确定应用程序的名称。 操作系统在存储应用程序及其存储数据的硬盘上找到文件。 操作系统发现主内存的未使用部分足以容纳应用程序。 操作系统在主内存的该部分中复制应用程序及其数据。 硬盘上的软件未更改；主内存保存磁盘上的内容的副本。 操作系统为应用程序申请资源。 最后，操作系统启动应用程序运行。 总结： 在应用程序运行时，操作系统在后台管理资源，为应用程序进行输入和输出，并使其他所有程序保持运行。 Part 2. 网络（Network） 图片来源：https://www.aqniu.com/learn/27008.html 一个计算机网络由连接的两台或更多台计算机组成，以便它们可以交换数据和程序。当计算机是网络的成员时，它运行的程序和使用的数据可以位于网络上其他计算机的硬盘上。 在商业和工业环境中，大多数计算机都在网络上。在联网计算机上运行的操作系统必须管理其分享的网络资源（以及管理其所有其他职责）。操作系统能够找到存储在其他网络计算机上的程序和数据，并将它们复制到其自己的主内存中。 网络中的每台计算机都有一个网络接口卡。这是一种通过电缆发送和接收数据的输入/输出设备。网络上计算机的网络接口卡通过电缆连接在一起。 局域网局域网（LAN）是局限于相对较小区域的网络。它通常局限于地理区域，例如写作实验室，学校或建筑物。 每台计算机都有一个其他计算机用来访问它的网络地址。通常，计算机共享一台打印机。局域网中也可能有一台功能特别强大的计算机，称为「服务器」，其硬盘上装有其他计算机可能需要的应用程序和数据。 广域网广域网（WAN）连接较大地理区域的网络，例如四川到北京或世界各地。专用的越洋电缆或卫星上行链路可用于连接这种类型的全球网络。 广域网使用各种特殊的硬件来管理数据流。当两台计算机共享数据时，这些硬件使两台计算机直接连接在一起。实际上，两台计算机之间可能有数十个网络设备。但对于用户而言，使用 WAN 和 LAN 并无差别。 所有这些设备都 使用相同的方法来处理数据。没有通用的数据处理方法，大型网络将变得毫无希望。关于如何通过网络表示和传输数据的协议称为 「协议」。通常，大型网络使用称为 TCP / IP 的协议（用于传输控制协议/ Internet协议）。 互联网（Internet）互联网包含所有连接在一起的计算机的一个庞大的全球网络。在这个庞大的网络上，每台计算机 必须具有 唯一的网络地址（称为 IP 地址），就像世界上的每部电话都具有唯一的电话号码（包括国家/地区代码和区号）一样。 例如这是一个典型的 IP 地址：149.152.21.203，IP 地址实际上是 32 位二进制数。联网设备使用这些地址在网络上路由信息。上面的示例显示了使用十进制数字写入这些位的标准方法（每 8 位转换成十进制并使用 . 隔开）。 但是，即使以十进制形式书写，该地址也无法被人类识别。万维网的功能之一是它允许人类使用 计算机名称而不是数字。例如：这是一个典型的计算机名称：wmyskxz.com。这就要容易记住的多，在 Web 浏览器中使用它时，它将自动转换为计算机 IP 地址的 32 个二进制数字。 全球资讯网（World Wide Web）还记得我们上面提到的 重要思想 吗：程序和数据都以 相同的方式 保存在计算机内存中。计算机存储器（主存储器和辅助存储器）在存储程序和数据时没有区别。 通信设备也不区分程序和数据。就其而言，它就是所有信息，并且所有信息都以相同的方式传输。互联网就像是全球包裹递送服务。它关心的是将包裹从一个地址移到另一个地址，而不用担心包裹中的内容。 互联网提供硬件基础，而信息传输协议服务于万维网。 与任何数据一样，用于 Web 的数据也通过 Internet 传输。使 Web 数据与众不同的原因在于，它是针对 Web 浏览器（例如您可能正在使用的浏览器）而设计的。浏览器是一种程序，可以读取网页并以一种格式正确的方式显示它们。 网页是一组数据，其中包含有关如何在监视器上显示信息的信息。使用称为 超文本标记语言（HTML） 的语言来提供此信息 。如果要查看描述此页面的 HTML，您可以直接右击正在浏览的网页然后会看到「显示源代码」的选项。 参考资料 Introduction to Computer Systems - http://programmedlessons.org/Java9/chap01/ch01_01.html How does the processor work - https://pmihaylov.com/how-does-the-processor-work/ How Computers Work: The CPU and Memory - https://homepage.cs.uri.edu/faculty/wolfe/book/Readings/Reading04.htm What Is CPU (Central Processing Unit) And How It’s Work? - https://www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/ Computer Memory - http://programmedlessons.org/Java9/chap03/ch03_01.html 计算机原理-CPU到底有多快？内存：是我的250倍 - https://blog.csdn.net/pyf09/article/details/95256493 电脑系统32位和64位的区别 - https://www.jianshu.com/p/d0e95bed5b60 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编码之前需要知道的事","slug":"基础知识/编码之前需要知道的事","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」计算机发展史—从织布机到IBM","slug":"「MoreThanJava」计算机发展史—从织布机到IBM","date":"2020-04-07T01:05:00.000Z","updated":"2020-12-09T04:38:42.355Z","comments":true,"path":"2020/04/07/morethanjava-ji-suan-ji-fa-zhan-shi-cong-zhi-bu-ji-dao-ibm/","link":"","permalink":"http://www.wmyskxz.com/2020/04/07/morethanjava-ji-suan-ji-fa-zhan-shi-cong-zhi-bu-ji-dao-ibm/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 一、织布机 | 一切的开端如今代表智能现代的计算机与老式织布机的血缘关系超乎你的想象。无论是摆在写字台上的 台式机、塞在口袋里的 掌上电脑、挂在腰上的 移动电话、乃至你家中的很多 家用电器，其实都是 1804 年诞生的 一台织布机的后代——雅卡尔传空纸带提花机。 图片源自：http://blog.sciencenet.cn/blog-528739-903746.html 织物与织布机常见的织物常见的织物有 「机织物」 和 「针织物」 两种。 我们平时最为熟悉的 「针织物」 借助的工具是 “针”，利用织针按照一定方向弯曲成线圈形态，然后再将线圈相互串套而形成的织物，可以横向或者纵向地进行，横向编织称为纬编织物，而纵向编织称为经编织物。 而 「机织物」 由两条或两组以上的相互垂直的两个系统纱线或者丝线，在 织机 上按照一定规律相互交织而形成的织物叫机织物，纵向的纱线 叫 经纱，横向的纱线 叫 纬纱，基本组织有平纹、斜纹和缎纹。 织机是如何工作和迭代的 在织机上，经纱在经轴上逐根排列，根据织物纹样的要求，部分经纱被抬起，另一部分经纱则保持不动 形成织口，纬纱从织口中引入，经纱抬起的规律不同以及纱线颜色的排列变化，就会给织物带来不同的纹样： 可是，经纱有那么多，是如何挑选出引入没根纬纱时要提起哪些经纱的呢？ 最原始的织机是手动完成的： 图片引用自：https://www.sohu.com/a/301616592_99894978 而到了战国时期的 多综式提花织机，则发明了 综框 来完成这项工作，棕框的上下梁间有垂直排列的综丝，经纱穿入综丝中，织物纹样的变化有一个规律，也就意味着经纱是随着纬纱的引入被 有规律的循环提起，将 提起规律相同的经纱 穿入 同一个综框的综丝 中，当综框被提升时，穿入的所有经纱都会被同时提起，每一个综框都有一个脚踏板，踩下脚踏板则可通过机械装置控制其抬升： 不过采用综框也有一个明显的限制，那就是 无法织出比较复杂的纹样，因为纹样复杂则代表着需要更多的经纬纱以及经纱提升的规律更复杂，意味着可能引入成百上千次纬纱才能完成一个循环。 如果仍然采用综框控制纱线提升，则可能需要成百上千个综框，这在机械上实现是非常困难的，因此便有了 束综提花织机。 束综提花织机没有综框，而是被 设计成两层，每一根经纱会穿入综丝中实现 单独的控制，上层 的人将需要提起的经纱提起，而 下层 的人则再经纱提起后通过梭子将纬纱送入织口，并用打纬装置将引入的纬纱打牢。 然而通常来说，这类织机上会有成千上万根纬纱，纹样复杂，于是聪明的老祖宗们发明了 花本： 简单来说，花本存储了纹样信息。图中花本的竖线连接穿入了经纱的综丝，横线存储了每一次引入纬纱时提花信息，当竖线越过横线覆盖在横线前方时，表明对应的经纱要被提起。 如果还是没有理解到这个过程的话，这里有一个比较硬核的视频，教你如何手工来制作一个简易织布机：戳这里 “识字”的机器 | 雅卡尔织机的诞生上面说到的束综提花织机虽然是一大进步，但可想而知的是，它仍然效率缓慢并且织布工人的劳动量非常大，也非常辛苦。虽然聪明的祖先们进行了很多机械化的尝试，但仍然没有取得跨越式的发展。 时间来到 18 世纪的欧洲。欧洲游历和学徒的传统，造就了许多城市独特的支柱产业，例如威尼斯的玻璃业和法国里昂的 丝织业。1725 年，里昂的织匠 布乔 (B.Bouchon) 做出了开拓性的发明：他用 打孔纸带 控制经线的提起和放下，从而让织出花样成为了一种半自动的工作。 做为一个乐器工人的儿子，布乔把家学和自己的工作结合得很好。然而，柔软的打孔纸带不能织出太宽的织物，这是它的致命伤之一；而纸带依然需要有人照看，每穿过一次纬线，纸带就需要向下移动一格。布乔提花机的最大贡献，在于实现了花纹的二进制存储——以机器能够识别的方式。历史上第一次，机器能够读出存储介质中的内容，并且照其行事。 在布乔提出构想 65 后的 1790 年，约瑟夫·玛丽·雅卡尔 根据前人的成果设计了新式织机，不过正在此时，轰轰烈烈的法国大革命爆发了，雅卡尔也停下了手中的工作，投入到了家乡里昂的里昂保卫战中，这一拖就拖到了 1805 年，雅卡尔终于组装完成了首台 自动提花织机： 雅卡尔将 穿孔纸带 改进为 穿孔卡片，根据纹样图案在卡片上打孔，通过孔的有无 带动一系列机械运动装置来 控制经纱的提升，一张卡片对应循环内一次引纬时经纱提升的信息，引纬完成后，可通过脚踏板控制卡孔卡片转动，下一张卡片翻转至工作位置以控制新一次引纬的提花： 雅卡尔织机大幅度节省了时间和工作量 (全自动且效率是之前的二十五倍)，而且只需一位工人，很快就被广泛使用在工厂生产中，雅卡尔也荣获了拿破仑授予的荣誉勋章。然而，迎接这位发明家的，却是失业的纺织工人迎面扔来的石头。最终导致雅卡尔客死异乡。 雅卡尔 = 贾卡。笔者在写文的时候，发现不同的资料文献中对于该织机作者的翻译会有偏差，有的叫 雅卡尔织机，有的叫 贾卡织机，但都是同一个人啦.. 二、差分机 | 程序设计思想开始萌芽穿孔卡片控制织物纹样的设计成为了程序设计思想的萌芽，为信息技术的发展开展了一条新的道路。 时间来到 19 世纪初，法国人 巴贝奇 (Chanles Badbbage) 在贾卡织机的启发下，设计并制造了 差分机。 故事背景 以下内容大部分摘录自下方引用资料：现代计算机真正的鼻祖——超越时代的伟大思想 18 世纪末，法国政府在开创米制之后，决定在数学中统一采用十进制，竟奇葩地想把原本 90 度的直角划分成 100 度、把原本 60 秒的 1 分钟划分成 100 秒，尽管从现在看来这样的想法绝逼是一种倒退，但他们在当时真就实施了。这一改制带来的不光是人们在使用时直观上的别扭，原本制作好的数学用表 （如三角函数表） 都需要全部重制。 法国政府将这项丧心病狂的工程交给了 数学家普罗尼 （Gaspard de Prony），普罗尼正头疼着要如何才能完成这项艰巨的任务，突然想起著名经济学家 *亚当·斯密** *（Adam Smith） 的那本《富国论》，他决定采用书中提出的 劳动分工 的做法，将制表的工作人员分成三组： 第一组 由五六名牛逼的数学家组成，他们负责制定运算中所需的公式； 第二组 由九到十个擅长数学的人组成，他们负责计算出一些关键数据，并把第一组制定好的公式进行简化； 第三组 由约一百名计算人员组成，他们利用第二组提供的关键数据和公式，做最简单的加减操作就能得出最终结果。 第三组的工作简单到什么程度，就是他们甚至都不知道自己正在算什么玩意儿，事实上他们的文化程度大部分都不高，里头好多都是理发师、失业人员什么的。可见即便文盲都能完成的计算，在那个时代还是得依靠人力去做。 而为了保证用表的正确性，普罗尼要求 每个数至少算两遍，并且 要在法国的不同地点用不同的方法计算。这项劳民伤财的工程整整进行了十年才完成，然而不幸的是，最终的表里仍然有错。说到这一点，可以说，那个时代基本没有一版数学用表是完全正确的，有些版本甚至错误百出，要知道数学用表出错有时后果会很严重，比如航海表一出错就可能直接导致船毁人亡。 巴贝奇 在了解到普罗尼的事迹后泪流满面，决心要做一套完全正确的数学用表，为达目的，他尝试了各种减少错误的手段，比如调整纸张和墨水的颜色以提高数字的识别度，直接拿现有的多个版本的表进行誊抄、比对、让不同人员反复校对，在 1827 年出版了一个版本，结果里头还是有错。只要是人为的就没有完美的，巴贝奇彻底跪了，他发誓要造一台机器，让机器去生产数学表。 这就是史上著名的 差分机 了。 重要的差分思想其实早在巴贝奇出生前，有个叫 米勒 （Johann Helfrich von Müller） 的德国工程师就提出了差分机的思想，但仅仅是提了一下，并没有进行具体设计和制造，他最终还是把研制差分机的历史重任让给了巴贝奇。 之所以叫差分机这个名字，是因为它计算所使用的是帕斯卡在 1654 年提出的差分思想：n 次多项式的 n 次数值差分为同一常数。举个简单例子好了，对于函数 F(x) = 12x + 12，x 取自然数： 对于一次多项式，每个相邻的 x 所对应的 F(x) 之差都是一个常数，这个常数很明显就是 x 的系数。那么二次多项式呢？对于函数 F(x) = 15x2 + 12x + 12，x 取自然数： 对于二次多项式，每个相邻的 x 所对应的一次差分之差仍然都是一个常数，我们可以导出这一常数的通用公式： 在上述例子中，a = 15，故二次差分常数 2a 即为 30。 差分规律是一项伟大的发现，有了差分，在计算多项式时就可以 用加法替代乘法，我们只需要算出几个初始值，后面对于任意 x 所对应的 F(x) 均可以通过加法得出： 学过高数的朋友应该知道，一个函数在满足一定条件的情况下可以用多项式逼近 （幂级数展开），于是常用的三角函数、对数函数都可以通过多项式来计算的，而机械时期的计算设备最擅长的就是做加法，有了差分思想，巴贝奇看到差分机的前途一片光明。 完成一半的差分机（Difference Engine）从 1812 年到 1822 年，巴贝奇克服重重困难完成了一台可以计算六位数二次多项式的模型机，他给皇家学会的主席写信，希望政府可以出资，赞助他建造真正可用的大型差分机。政府也觉得这事儿很有意义，尤其对海军很有价值，于是在 1823 年拨款 1500 英镑，巴贝奇如鱼得水，号称只要两三年时间就能完工。 谁知实行起来要比想象中困难得多，那个时代的机械制造水平实在落后，差分机是十分精密的仪器，巴贝奇跑遍了欧洲都没找到多少能用的零件，于是在制造差分机之前，他还要先想着怎么制造各类零件。 在英国当时一个牛逼的机械师 克莱门特 （Joseph Clement） 的帮助下，他们真的在提高机械制造方面下足了功夫，不但做出了差分机能用的零件，还培养出大批优秀的技师。本来这两人强强联合势必能把差分机做好，但是巴贝奇是个精益求精的人，经常改动设计方案，导致工程时常要返工，工作量大大增加，外加亲人的相继去世，后来又和克莱门特闹掰，到了 1833 年，十年都过去了，巴贝奇只做出了机器的一小部分，却已经花费了 3 万英镑 （远超最初预算）。政府对巴贝奇大失所望，终于在 1842 年正式宣布不再出资，到头来巴贝奇给后世留下的就只有一个半成品，以及在 1839 年修订好的一大堆设计图纸，现存于伦敦科学博物馆。 值得一提的是，巴贝奇做不出差分机实在不是客观原因所致，与他同时代的瑞典人 乔治·舒茨 （Per Georg Scheutz） 就根据他的设计在 1843 年做出了切实能用的差分机，巴贝奇倒是提供了不少指导和帮助，也算是了却了自己一桩心愿吧。 150 年后，为了纪念巴贝奇 200 年诞辰，从 1989 到 1991 年人们根据巴贝奇的设计图纸建造了第一台真正的巴贝奇差分机，机器完美运行，工程师们惊奇地发现，巴贝奇的图纸里只有极少的错误，而且这些错误八成是当时为防止图纸被盗用而刻意为之的。这台差分机被保护在伦敦科学博物馆的玻璃柜里，后来又造了一台，放在美国硅谷的计算机历史博物馆，每天由导游给参观者讲解和演示，人们得以近距离膜拜。 差分机的工作原理简析在巴贝奇 1839 年的设计中，差分机可以支持七次多项式的计算。由于每次参与计算的都是函数值和 1~7 次差分值的最新值，于是仅需响应的 8 个计数器。巴贝奇设计的计算器由 31 个计数轮垂直叠加而成，即支持 31 位十进制数： 加上传动装置和进位装置，就成了这样一幅丧心病狂的样子： 巴贝奇使用梯形的传动轮实现两个计数轮之间的相加，由于有梯形齿，传动轮可以同时带动两个计数轮，也可以只带动一个。于是在进行两数相加时，传动轮先顺时针旋转，将右侧计数轮上的数字加到左侧轮上，而后上升一段距离，逆时针旋转相同度数，将右侧计数轮的示数还原到原来的位置。 仔细观察可以发现，这两个轮子上的数字排列顺序是相反的。在两轮相加的过程中，左侧轮作为累加轮朝数值增大的方向旋转，而右侧轮作为加数轮则朝数值减少方向旋转。在巴贝奇改进的并行差分算法中，两个步骤交替进行，同一个计数轮需要交替充当累加轮和加数轮的角色，于是当机器运行起来，这些齿轮需要正反方向交替旋转。 差分机的进位机构比较复杂，简单地说，每个计数轮都有一个针对高位的 “进位提示器”，当计数轮从 9 转到 0，其对应的 “进位提示器” 就被拨到 “需要进位” 的状态，每次计算，计数轮都要转动两次，第一次是每位数相加，第二次是按照“进位提示器”进行进位。我们直观地感受一下连续进位是什么样子： 最后我们来欣赏一下差分机整个运行起来的样子： 还有另外一个适用乐高还原的硬核版本： 如果对这一部分感兴趣的童鞋请进一步阅读原版文章：现代计算机真正的鼻祖——超越时代的伟大思想 三、分析机 | 第一台真正意义上的 Computer尽管没能亲手实现差分机，但巴贝奇并不会气馁，或者说他本来就是根本停不下来的那种人。明知实现不了，巴贝奇仍在一刻不停地改进着自己的设计，直到有一天，他构思出了一种空前的机器——分析机，正式成为现代计算机史上的第一位伟大先驱。 (Father of computing) 1834 年，分析机概念诞生之际，巴贝奇自己都为之感到无比震惊。在此之前，任何一台计算机器都只能完成其被预定赋予的计算任务，要么是简单的加减乘除，要么像差分机那样只能做差分运算，它们都属于 calculator，而分析机才是真正的 computer，它不局限于特定功能，而竟然是可编程的，可以用来 计算任意函数——现代人无论如何也无法想象在一坨齿轮上写程序是怎样一种体验吧！ 巴贝奇设计的分析机主要包括三大部分： 用于存储数据的计数装置，巴贝奇称之为 “仓库”（store），相当于现在 CPU 中的存储器，这部分是从差分机上的计数装置改进而来的，我们很容易想象它的模样； 专门负责四则运算的装置，巴贝奇称之为 “工厂”（mill），相当于现在 CPU 中的运算器，这部分的结构相对复杂，巴贝奇针对乘除法还做了一些优化； 控制操作顺序、选择所需处理的数据和输出结果的装置，巴贝奇没有起名字，由于其呈桶状，我们可以叫它 “控制桶”，控制桶显然相当于现在 CPU 中的控制器。 以上三部分，加上巴贝奇并没有疏漏的输入输出设备，我们惊讶地发现，分析机的组成部分和现在冯·诺依曼架构所要求的五大部件一模一样！ 巴贝奇另一大了不起的创举就是将 穿孔卡片（punched card） 引入了计算机器领域，用于控制数据输入和计算，从那时起，到第一台电子计算机诞生为止，期间几乎所有的数字计算机都使用了穿孔卡片。 巴贝奇在一次巴黎展览会上看到了贾卡的提花机，对其印象十分深刻，由于一直在研究计算机器，自然想到可以把穿孔卡片也应用到分析机上。于是分析机中的输入数据、存储地址、运算类型都使用穿孔卡片来表示。在机器运行时，卡片上有孔和无孔的地方会导致对应的金属杆执行不同操作，可编程性由此体现。下图可以直观地展现这一原理： 整个分析机就是在类似这样的齿轮和拉杆作用下实现可编程运算的：先从数据卡片读入数据到存储器，再将存储器中的数据传输到运算器，运算器算完后又将数据传回存储器。 可惜的是，巴贝奇穷其一生也没能真正把分析机做出来，留给后世的又是一台模型机和两千多张图纸，以及这样一段遗言： 如果一个人不因我一生的借鉴而却步，仍然一往直前制成一台本身具有全部数学分析能力的机器……那么我愿将我的声誉毫不吝啬地让给他，因为只有他能够完全理解我的种种努力以及这些努力所得成果的真正价值。 可以说，巴贝奇一生的奋斗都是孤独的，在那个年代，人们看不到分析机的巨大价值和意义，有了先前差分机的失败，政府也不再愿理会分析机的想法。巴贝奇的思想超前了整整一个世纪，但庆幸的是在有生之年，依然有着三位难能可贵的支持者： 首先是他的儿子 亨利·巴贝奇 （Henry Prevost Babbage），直到巴贝奇过世后，亨利也继续着分析机的建造工作，但终究也力不从心未能完成； 而后是后来成为了意大利总理的数学家 闵那布利 （Luigi Federico Menabrea），他在巴贝奇 1840 年演讲时详细记录下了分析机的思想； 最后就是著名诗人拜伦的女儿，史上大名鼎鼎的 女程序员艾达 （Ada Lovelace），她将闵那布利记录分析机的文章翻译成英文，巴贝奇建议她在翻译时增添一些自己的理解，结果艾达注解的长度是原文的两倍，其中针对计算伯努利数的算法被视为史上第一个计算机程序，这篇名为《关于巴贝奇先生发明的分析机简讯》的译文被视为程序设计方面的第一篇著作，而 艾达本人则成了世界上第一位程序员。 艾达几乎是那个时候唯一一个真正理解分析机的人，她不仅编写了许多可以在分析机上运行的程序，甚至还看到了巴贝奇自己都没有看到的事情——她说：分析机不光能用来计算，它应该还能用来表示其他东西，比如音乐。这是多么远大的目光啊！后来美国国防部将一种编程语言命名为 Ada，就是为了纪念这位与巴贝奇同样具有超前思想的伟大女性。 四、制表机 | 穿孔时代的到来从 1790 年开始，美国每 10 进行一次人口普查。百年间，随着人口繁衍和移民的增多，从 1790 年的 400 万不到，到 1880 年的 5000 多万，人口总数呈爆炸式地增长。 不像现在这个的互联网时代，人一出生，各种信息就已经电子化、登记好了，甚至还能数据挖掘，你无法想象，在那个计算设备简陋得基本只能靠手摇进行四则运算的 19 世纪，千万级的人口统计就已经成了当时政府的 “不能承受之重”。1880 年开始的第 10 次人口普查，历时 8 年才最终完成，也就是说，他们在休息两年之后就要开始第 11 次普查了，而这一次普查，需要的时间恐怕要超过 10 年，那第 12 次、13 次呢？本来就是 10 年一次的统计，如果每次耗时都在 10 年以上，这件事情就变得没有意义了。 这可愁煞了当时的人口调查办公室，他们决定面向全社会招标，寻求能减轻手工劳动、提高统计效率的发明。正所谓机会都是给有准备的人的，一位毕业于哥伦比亚大学的年轻人 赫尔曼·霍尔瑞斯 （Herman Hollerith） 带着他在 1884 年申请的专利从众多方案中脱颖而出。 制表机他发明的机器叫 制表机 （tabulator/tabulating machine），顾名思义，就是专门用来制作数据统计表的机器。制表机主要由示数装置、穿孔机、读卡装置和分类箱组成。 示数装置包含 4 行、10 列共 40 个示数表盘，每个盘面被均匀地分成 100 格，并装有两根指针，和钟表十分相像，“分针” 转一圈可计 100，“时针” 转一圈则计 10000。可见，整个示数装置可以表达很庞大的数据。 制表机的工作是围绕穿孔卡片展开的：操作员先使用穿孔机制作穿孔卡片，再使用读卡装置识别卡片上的信息，机器自动完成统计并在示数表盘上实时显示结果，最后，将卡片投入分类箱的某一格中，进行分类存放，以供下次统计使用。 穿孔卡片的应用此前的某一天，霍尔瑞斯正在火车站排队检票，目光不经意落到检票员手中咔咔直响的打孔机上。他发现，检票员会特意根据乘客的性别和年龄段，在车票的不同地方打孔。越来越多的人过检，他进一步确认了这个规律。一个灵感朝他袭来：如果有一张更大的卡，上面有更多的位置可以打孔，就可以用来表示更多的身份信息，包括国籍、人种、性别、生日等等。 这就是用在 1890 年人口普查中的穿孔卡片，一张卡片记录一个居民的信息。卡片设计长约 18.73cm，宽约 8.26cm，正好是当时一张美元纸币的尺寸，因为霍尔瑞斯直接用财政部装钱的盒子来装卡片。 卡片设有 300 多个孔位，与雅卡尔和巴贝奇的做法一样，靠每个孔位打孔与否来表示信息。尽管这种形式颇有几分二进制的意味，但当时的设计还远不够成熟，并没有用到二进制真正的价值。举个例子，我们现在一般用 1 位数据就可以表示性别，比如 1 表示男性，0 表示女性，而霍尔瑞斯在卡片上用了两个孔位，表示男性就其中一处打孔，表示女性就在另一处打孔。其实性别还凑合，表示日期时浪费得就多了，12 个月需要 12 个孔位，而常规的二进制编码只需要 4 位。当然，这样的局限也与制表机中简单的电路实现有关。 细心的读者可能发现卡片的右下角被切掉了，那不是残缺，而是为了避免放反而专门设计的，和现在的二维码只有 3 个角是一个道理。 这类实用的细节设计在穿孔机上表现得更为出色。下图为一位操作员正在使用穿孔机给卡片打孔的情景，她并不需要在卡片上吃力地搜寻孔位，而是直接对着孔距更大的操作面板打孔，一根杠杆将两者的孔位一一对应。操作面板还做成了弧形，颇有一分如今人体工程学键盘的风姿。 在制表机前，穿孔卡片（或纸带）多用于存储指令而不是数据。比较有代表性的，一是雅卡尔提花机，用穿孔卡片控制经线提沉；二是自动钢琴，用穿孔纸带控制琴键压放。美剧《西部世界》中，每次故事循环的开始，都会给一个自动钢琴的特写，弹奏起看似宁静安逸、实则诡异违和的背景乐。 是霍尔瑞斯将穿孔卡片作为 数据存储介质 开来，并开启了一个崭新的 数据处理纪元。后来人们也把这类卡片称为霍尔瑞斯卡片，穿孔卡片和穿孔纸带作为输入输出载体，统治了计算领域整整一个世纪。 统计原理打好了孔，下一步就是将卡片上的信息统计起来。读卡装置的组成如下图所示，其外形和使用方式有点类似现在的重型订书机，将卡片置于压板和底座之间，按压手柄，就完成了对这张卡片的信息读取。 原理上，通过电路通断识别卡上信息。底座中内嵌着诸多管状容器，位置与卡片孔位一一对应，容器里盛有水银，水银与导线相连。底座上方的压板中嵌着诸多金属针，同样与孔位一一对应，针的上部抵着弹簧，可以伸缩，压板的上下面由导电材料制成。这样，当把卡片放在底座上，按下压板时，卡片有孔的地方，针可以通过，与水银接触，电路接通，没孔的地方，针就被挡住。 这一基本原理与雅卡尔提花机类似，不难理解。重头戏是，如何将电路通断对应到所需要的统计信息呢？霍尔瑞斯在专利中给出了一个简单的例子，如下图所示。这是涉及性别、国籍和人种 3 项信息的统计电路图，虚线为控制电路，实线为工作电路。 图顶有7根金属针，从左至右标的分别是：G（类似于总开关）、Female（女）、Male（男）、Foreign（外国籍）、Native（本国籍）、Colored（有色人种）、White（白种人）。 工作电路中分散着标识为 m1~m10 的电磁继电器。 图底从右至左为标识为 M1~M6 的 6 组电磁铁，所对应的统计信息为（为贴合穿孔的形象，我特意选择使用圆圈进行标记）： 以 M1 为例，如果表示 Native、White 和 Male 的针同时与水银接触，接通的控制电路： 这一示例首先展示了针 G 的作用，它把控着所有控制电路的通断，目的有二： 在卡片上留出一个专供 G 通过的孔，以防止卡片没有放正（照样可以有部分针穿过错误的孔）而统计到错误的信息。 令 G 比其他针短，或者 G 下的水银比其他容器里少，从而确保其他针都已经接触到水银之后，G 才最终将整个电路接通。众所周知，电路通断的瞬间容易产生火花，这样的设计可以将此类元器件的损耗集中在 G 身上，便于后期维护。 不得不感慨，这些发明家做设计真的特别实用、细致。 控制电路的接通引起图中标有橘黄色箭头的 3 个电磁继电器 m1 、 m3 和 m5 闭合，进而接通 M1 所在的工作电路： 最终，通电的 M1 将产生磁场，牵引相关杠杆，拨动齿轮完成计数，最终体现到示数表盘上指针的旋转。虽然霍尔瑞斯的专利中没有给出这一计数装置的具体结构，可以想象，从 17 世纪开始，机械计算器中的齿轮传动技术已经发展到足够成熟的水平，霍尔瑞斯无需重新设计，完全可以使用现成的装置，正如他在专利中所说的“any suitable mechanical counter”（任何合适的机械计数器都可以）。 电磁铁不单控制着计数装置，还控制着分类箱盖子的开合。将分类箱上的电磁铁接入工作电路，每次完成计数的同时，对应格子的盖子会在电磁铁的作用下自动打开，熟练的操作员甚至不用转头去看，就可以顺手将卡片投到正确的格子里，由此完成卡片的快速分类。 每天工作的最后一步，就是将示数表盘上的结果誊抄下来，置零，第二天继续。 单元记录时代在制表机的高效运转下，1890 年的人口普查只花了 6 年时间。1896 年，霍尔瑞斯成立制表机公司（The Tabulating Machine Company）并不断改进自己的产品，先后与英国、意大利、德国、俄罗斯、澳大利亚、加拿大、法国、挪威、美国波多黎各、古巴、菲律宾等多个国家和地区合作开展了人口普查。 到 1914 年，制表机公司每天生产的穿孔卡片多达 200 万张。不多久，一些竞争对手逐渐起家，历史迎来了繁荣的数据处理时代。它们的产品也不再局限于人口普查，逐渐扩展到会计、库存管理等一些同样需要跟大数据打交道的领域，这些机器作为制表机的后裔被统称为单元记录设备（unit record equipment）。 围绕穿孔卡片的制卡、读卡、数据处理和卡片分类是它们的标准功能，穿孔机、读卡器、分类器是它们的标准配置。这些部件的自动化程度越来越高，比如手动的读卡装置很快被自动读卡机所取代，读卡速度从每分钟 100 张逐步提高至每分钟 2000 张。随着识别精度的提高，卡片的孔距也越来越小，具有 80～90 列孔位的卡片成为主流，有些卡片的孔位甚至多达 130 列。 机器的功能也逐渐强大，不再只是简单地统计穿孔数目，减法、乘法等运算能力陆续登场。1928 年，哥伦比亚大学的科学家们甚至用单元记录设备计算月球的运行轨迹，他们在 50 万张卡片上打了 2000 万个孔，彰显着单元记录设备的无限潜力。 机器的电路实现越来越复杂，但同时也越来越通用。1890 年所用的那台制表机的 线路是固定的，遇到新的统计任务，改造起来十分麻烦。 1906 年，霍尔瑞斯便引入了接插线板（plugboard）——一块布满导电孔的板卡，可通过改变导线插脚在板上的位置改变线路逻辑。试想一下，接插线板的内部已经布好了具有各种功能的线路，但它们都处在断开状态，各自连接着接插线板上的某两个孔位，像一窝嗷嗷待哺的小鸟长大着嘴巴，外部的导线就像美味的虫子，当虫子的头尾分别与小鸟的上喙和下喙接触，线路就被导通，这只小鸟就开始工作了。如此，每次使用就可以激活不同的 “小鸟”，从而完成不同的任务。这已经是一种可编程性的体现。 1911 年，制表机公司与另外 3 家公司合并成立 CTR 公司 （Computing-Tabulating-Recording Company），制表机公司作为其子公司继续运营到 1933 年。 1924 年，CTR 更名为 国际商业机器公司（International Business Machines Corporation），就是现在大名鼎鼎的 IBM 公司。可见，在如今众多年轻的 IT 公司中，拥有百年历史的 IBM 是位当之无愧的前辈，它完整地参与和见证了整个现代计算机的发展史。IBM 保持了制表机公司在单元记录市场的龙头地位，到 1955 年，其每天生产的穿孔卡片多达 7250 万张。 1937 年开始，单元记录设备逐步电子化，与电子计算机的界线渐渐模糊，并最终为后者让路。随着 1976 年 IBM 一型最核心的单元记录产品的停产，短暂的单元记录时代也宣告谢幕，它仿佛是电子计算时代来临前的预演和铺垫，许多设计被沿用下来，比如穿孔卡片和接插线板。 有趣的是，即使电子计算机逐渐普及，许多机构由于用惯了单元记录设备，迟迟不愿更换，少数机构甚至一直用到了 21 世纪。 在翻阅资料的时候发现了一个特别有趣的谈计算机发展是的简书专栏，感兴趣的童鞋可以进一步去阅读：传送门 参考资料 机织布、针织布和无纺布的概念介绍 从织布机到计算机 记忆传承，信息永生（四） 织布机与计算机 计算机发展的引路者——贾卡织机的前世今生 布爾與電腦——《科學月刊》 Who is the father of the computer? 现代计算机真正的鼻祖——超越时代的伟大思想 制表机：穿孔时代的到来 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编码之前需要知道的事","slug":"基础知识/编码之前需要知道的事","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"「MoreThanJava」当大学选择了计算机之后应该知道的","slug":"「MoreThanJava」当大学选择了计算机之后应该知道的","date":"2020-04-02T09:37:00.000Z","updated":"2021-01-11T09:52:39.345Z","comments":true,"path":"2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/","link":"","permalink":"http://www.wmyskxz.com/2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/","excerpt":"","text":"「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然 不论新老朋友 我相信您都可以 从中获益。如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 一、计算机 = 互联网 = 高薪 = 996？你真的了解计算机专业吗？不论你是自己选择的计算机专业还是家人帮你报的名，首先恭喜你！因为计算机是少数的几个 「不用拼爹」，完完全全可以凭借自己的努力就能够获得回报的专业，而且从近 20 年来看，回报还相当不错！ 那 计算机专业 是做什么的呢？ 图片引用自：https://mp.weixin.qq.com/s/1sb8YqFZm4yRZBzA_Zbn3g 简单来说，计算机专业是以 计算机等技术 为主要研究工具，以扩展人类的信息功能 为主要目标的一门学科。 计算机是个大门类翻开本科专业目录，会发现计算机是个大类，包括计算机科学与技术、软件工程、网络工程、信息安全、物联网工程等等等好多专业。其中，最核心、最基础的专业就是 计算机科学与技术 (Computer Science and Technology - CS) 了，这也是各院校计算机系招生的主要专业。 百度百科给出的计算机专业概念的论述是：计算机专业是指计算机硬件与软件相结合、面向系统、更偏向应用的宽口径专业。 总之计算机是个很大的门类，不光编写应用软件的 软件工程师： 还有制作硬件的 硬件工程师，例如我们日常使用大到手机，小刀计算器，一切物理设备的底层逻辑都是由它们负责编写的： 还有 网络工程师，但也有黑帽子、白帽子、运维等等很多的分别：(这图感觉明显比较黑和帅呢..) and more… 另外想说一点是，随着技术的进步和世界的复杂程度的加深，社会分工越来越细之后，大学专业也随之变得越来越细化，这些都不要紧，无论在哪一个方向 深耕 都能带来不菲的收获。(即行行出状元) 计算机专业都学哪些课程了解一门专业最快的方式就是了解它的课程。我们来看一下 网易云课堂顶尖中文大学计算机专业课程体系 给出的标准的 CS 体系的课程表：(链接可戳，下图课程全部免费) 可以看到计算机专业的课程大致分为基础课程和专业课程两类： 主要基础课程：高等数学、大学英语、线性代数、大学物理、概率论、离散数学等； 主要专业课程：数据结构、C 语言程序设计、数据库原理、操作系统、计算机网络、算法分析与设计、编译原理、软件工程等； “计算机热” 还能持续多久？计算机有多热门呢？看一下现在 漫天飞 的程序员培训广告就知道了，在前几年，这些地方还被英语培训占据着。(关于计算机培训逐步替代英语培训这事儿，有兴趣了解更多可以 戳这里) 于是总有人担心，报选计算机的 人太多，竞争太激烈了，或者是传言说计算机行业已经 快饱和了、互联网泡沫正在酝酿 等，但实际情况是怎么样的呢？ 我们先来看一段采访： 全球最大豪华车制造商戴姆勒奔驰（Daimler Benz） 的总经理在最近的一次采访中表示： 我们的竞争对手哪里是其他汽车公司，我们的竞争对手已经变成了特斯拉，谷歌，苹果，亚马逊等科技公司……科技公司的发展让我们不安，我们面临着巨大的转变。 不难发现，全社会正在 信息化中加速前进，计算机和互联网已经 渗透到生活的方方面面，促使许多传统行业发生变革： 招聘：LinkedIn 的出现，正在蚕食美国4000亿美元的利润丰厚的招聘行业。 零售：Amazon 的出现，让美国零售业人人自危，尤其是知名百货 Macy’s，因业绩不振已经连续关店及裁员。 交通：Uber 一辆“出租车”都没有，却是全球最大的打车公司，改变交通行业的游戏规则。 住宿：Airbnb 从不盖楼造宾馆，但是把目前世界最大的连锁酒店集团 Marriott 逼的不得不重新进行战略布局。 医疗：人工智能医疗机器人、智能诊断、可穿戴医疗设备…新的技术给医疗行业多个领域带来发展机会。 金融：金融领域也因为互联网和数据的发展，发生着剧变……一夜之间铺遍所有商家的 “扫码支付” 就是最好的例子。 就连 国防领域，也越来越以软件为基础，对科技人才的需求日趋迫切： 软件驱动的无人机发动空袭，不再让人类飞行员面临风险； 情报机构利用软件进行大规模数据挖掘，以发现和追踪潜在的恐怖主义活动； 从某种程度上来说，计算机行业不但不会饱和，并在大口 “侵食” 其它行业！几乎所有的公司和领域，都需要计算机相关的人才！ 有人说，未来世界将只剩下三种职业： 娱乐人士； Pizza 快递员； 程序员； 不过，基于现在的发展来看，娱乐可以被 VR／AR 渗透，Pizza 快递会由送餐机器人完成，而世界最终需要的，就是程序员。 对程序员的认识高薪是真的，996 也是真的工作 996，生病 ICU（重症监护病房）。 图片引用自：https://36kr.com/p/5191849 诚然，程序员的薪资水平普遍都要率高于其他一些传统行业： 图片引用自：设计资源网 但高薪的同时，也意味着高投入。 中国的信息技术产业，特别是过去十多年崛起的一些大型互联网公司，他们的重点主要还是在对技术应用的开发上。过去十多年来，中国互联网产业的发展所提供的机会，使得业界认识到：投入到应用中的收益，显然比基础研究的收益更大。 随着这些基础的开源技术开发工具的进步，中国的程序员的入行门槛也越来越低，这和市场对程序员的需求数量越来越多这一趋势又是匹配的。随着资本参与互联网的大战，“快” 成为互联网行业的共识。其实由于开源生态的存在，技术开发如今本身已经快得不能再快了，但市场竞争是残酷的，没有最快只有更快。 这就产生了一个矛盾：产业迅速膨胀，从业人员的水分也越来越高，但市场对公司的效率要求也越来越高。在这种态势下，技术应用方面的研发，很容易落入劳动密集型的实质当中。 难怪如今程序员往往自嘲为 “码农”，意思是 “写代码的农民工”。程序员褪去了 “智力劳动者” 的光环，似乎成为了和车间工人没太大区别的工种：无论是从工作的复杂程度来看，还是工作时长对工作的产出来看，都越来越接近了。 当然，把程序员和传统的产业工人做类比其实并不完全正确，这主要是因为：脑力劳动，或者说智力和知识，在信息技术开发的工作中起的作用太大了。 程序员的「行业偏见」在极光大数据的 2018 年中国程序员研究报告里，对于 「外行对你的职业最大的误解是什么」 的这个问题，有 46.1% 的程序员选择了 “很会修电脑”，42.7% 的人选择了 “可以轻易开发出任何软件”。 图片引用自：https://www.pingwest.com/a/160607 每个行业都存在各自的行业偏见，例如遇到健身教练就想让人帮你 3 天瘦 10 斤，还得不打针、不吃药、不节食、不运动。这些偏见都无可厚非，重要的是你怎么看待这事儿，是选择被贴标签就靠近标签，还是选择做自己。 什么样的人适合学习计算机？4 点吧：兴趣、逻辑、就业、静下来学习。 兴趣计算机行业的 知识迭代 相比其他行业来说速度要 快 上不少，加之市场对程序员的 要求 也越来越 高，这就要求了程序员需要更多的时间来学习。而说到底，计算机是一个偏实践性的理论知识学科，你不仅需要 花费大量的时间学习 枯燥的基础的理论知识，还需要再画 大量时间去动手实践 最终将这些知识 融会贯通 起来，这个过程可能略显枯燥和冗长，而 兴趣会帮助你跨过不少的无趣。 在 《黑客与漫画》 一书中有这样一段描述： 在达·芬奇的年代，绘画并不是一件很酷的事情，达·芬奇用自己的工作推动绘画成为一种伟大的表达方式。同样，编程到底能够有多酷，取决于我们能够用这种新媒介做出怎样的工作。 「兴趣是最好的老师」 这句话再怎么吹也不为过，你对一件事情的兴趣和热爱，在很大程度上决定了你做一件事情所取得的成绩。 看到有网友调侃：”给我妈买的智能洗衣机教了 n 遍都不会用，后来给她买了台麻将机，不仅会用还会修呢。” 还看到有网友吐槽说：「也可以先结婚后恋爱的..」，这… 你们自己品吧… 逻辑现代的计算机还没有足够的「聪明」，当你实现一些东西和想法的时候，需要考虑 「足够多」 的细节，这就涉及到 「逻辑思考，讲求因果」 的能力了。 这事儿我在 「知乎讨论 - 编程到底难在哪里？」 看到了许多有趣生动的例子，这里我们截取一个关于 「树上有十只鸟，开枪打死一只，还剩几只?」 问题的讨论来论述：(例子略长.. 不感兴趣的读者可以跳过..) 某日，老师在课堂上想考考学生们的智商，就问一个男孩: “树上有十只鸟，开枪打死一只，还剩几只?” 🙋‍♂️:“是无声手枪，还是其他没有声音的枪么?” “不是.” 🙋‍♂️：“枪声有多大?” “80~100 分贝.” 🙋‍♂️：“那就是说会震的耳朵疼?” “是.” 🙋‍♂️：“在这个城市里打鸟犯不犯法?” “不犯.” 🙋‍♂️：“您确定那只鸟真的被打死啦?” “确定.” (老师已经不耐烦了)，”拜托，你告诉我还剩几只就行了,OK?” 🙋‍♂️：“OK.鸟里有没有聋子?” “没有.” 🙋‍♂️：“有没有鸟智力有问题，呆傻到听到枪响不知道飞的?” “没有，智商都在 200 以上!” 🙋‍♂️：“有没有关在笼子里的?” “没有.” 🙋‍♂️：“边上还有没有其他的树，树上还有没有其他鸟?” “没有.” 🙋‍♂️：“方圆十里呢?” “就这么一棵树!” 🙋‍♂️：“有没有残疾或饿的飞不动的鸟?” “没有，都身体倍棒.” 🙋‍♂️：“算不算怀孕肚子里的小鸟?” “都是公的.” 🙋‍♂️：“都不可能怀孕?” “………，决不可能.” 🙋‍♂️：“打鸟的人眼里有没有花?保证是十只?” “没有花，就十只.” 老师脑门上的汗已经流下来了， 🙋‍♂️：“有没有傻的不怕死的?” “都怕死.” 🙋‍♂️：“有没有因为情侣被打中，自己留下来的?” “笨蛋，之前不是说都是公的嘛!” 🙋‍♂️：“同性恋可不可以啊？” “………….，性取向都很正常!” 🙋‍♂️：“会不会一枪打死两只?” “不会.” 🙋‍♂️：“一枪打死三只呢?” “不会.” 🙋‍♂️：“四只呢?” “更不会!” 🙋‍♂️：“五只呢?” “绝对不会!!!” 🙋‍♂️：“那六只总有可能吧?” “除非你他妈的是猪生的才有可能!一枪只能打死一只!” 🙋‍♂️：“…好吧，那么所有的鸟都可以自由活动么?” “完全可以.” 🙋‍♂️：“它们受到惊吓起飞时会不会惊慌失措而互相撞上?” “不会，每只鸟都装有卫星导航系统，而且可以自动飞行.” 🙋‍♂️：“恩，如果您的回答没有骗人，” 学生满怀信心的回答，“打死的鸟要是挂在树上没掉下来，那么就剩一只，如果掉下来，就一只不剩.” 老师推推眼镜，强忍着要昏倒的感觉，颤抖地说道：“你可以去当程序员了……” 静下来学习《黑客与漫画》 一书中有描述说： 程序员因为常常埋头于编程，而没有更多的时间精力去与学习如何与别人相处。这常常导致他们看起来有点“呆”——就像书呆子经常只和书打交道一样，程序员大部分时间只对着计算机屏幕。 这也从侧面反映出了编程这件事的特点。我们需要 「静下来沉淀学习」 的能力，如果你渴望几个月速成，或者不想学习新技术，指望二十来岁拿一个学位证，可以吃到退休，那么你就不太适合计算机行业。 二、对「大学」了解多一些为什么你可以不读大学？可不要被这个标题吓到，读书，念大学仍然是当今社会下的主流选择，这里只是借 阮一峰 大大的文章来提供一种 全新的视角，我相信读者会跟我一样，看完会带来一定思考的。 以下内容均引用自：为什么你可以不读大学 | 阮一峰 什么知识才是有用的知识？在 农业社会，上一代人的知识可以一成不变地用在下一代。而在信息社会，前几年的知识，再过几年就不能用了。 举例来说，眼下就业前景最好的行业，我觉得有两个：区块链和 VR。它们在五年前都是不存在的，那时就业最好的是苹果 iOS 系统的应用开发，可是再往前推五年，它也是不存在的。伴随着它们的是，很多旧工作岗位的消失，比如塞班、黑莓、Windows Phone 的开发。 这种情况下，大学应该教什么，我们根本不知道。学生毕业后的行业，现在根本还没有出现。因此，大学只能重点教 基础类课程，而且各个方向都必须教到，因为不知道学生将来会用到哪个方向的东西。这样就会耗费大量的时间，学习专业的各种基础知识，其中许多对人生来说是没用的。学生常常感叹：「考试一结束，有些课程这辈子再没有用到的机会了」。 更糟糕的是，学生的培养计划，都是一些二三十年前毕业、然后一直待在大学里、与社会生产实践脱节的人制定的。他们的知识和思维早已过时了。这样的人指定你应该学习的知识，很可能在你学的时候就已经过时了。 大学的四年时间退一步说，就算你在大学里能学到了真正的知识，那也不应该在那里待四年。如果只学最需要学习的东西，一年就够了。 四年时间足以让一个人在任何领域成为资深业者，甚至专家。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。 18 岁是人生最有热情和精力投入一项事业的时候，但是，大学将你一连四年关在教室和图书馆里，把考试和绩点伪装成你奋斗的目标，人为将你与真实世界隔离，引导你去关注那些对未来人生毫不重要的事情。经过这样四年的歧途，等你真正走上社会、要跟全世界竞争的时候，你的竞争力不是变强了，而是变弱了。换句话说，四年制大学很可能是削弱你，而不是让你变得更强。 2014 年诺贝尔物理学奖得主中村修二，就曾经写过一篇长文，名字就叫 《东亚教育浪费了太多的生命》。 我们时代的很多成功者—-乔布斯、比尔盖茨、扎克伯格等等—-都是退学生，这绝不是偶然的。不是他们在大学待不下去，而是他们发现，没必要在那个地方待四年。如果他们咬着牙忍受下去，熬到拿到文凭的那一天，苹果公司和微软公司可能都不会有了。 不是说知识无用注意，我不是说知识无用，而是说知识（尤其是非学术的知识）不一定要通过大学获得，通过互联网一样可以接受高等教育，而且更高效和便宜。 技术已经成为人类社会发展的主导性力量，学习和教育变得比以往更重要、更关键。但是很不幸，我们的学习和教育制度已经完全过时，传授的知识有用的少，没用的多；传授方法仍然依靠灌输和记忆，而不是启发和理解，极其低效，浪费学生的时间，打击学习热情，磨灭对知识的兴趣；对年轻人的成长，正面影响少，负面影响大，而且看不到改变的希望。 图片引用自：https://zhuanlan.zhihu.com/p/54933216 以前，人生的选择很少，你不得不去读大学，因为没有其他地方可以接受高等教育。社会还把很多机会与文凭挂钩，先有文凭，然后才能有就业、职称、住房等等。 但是，时代已经变了，文凭正变得越来越不重要。那些与文凭挂钩的东西，正在一项项脱钩。 互联网将教育的自主权，交到了每个人自己手里。上什么课程、什么时间上，都完全由你决定。你可以一边工作，一边利用夜晚和周末，学习网络课程。这样的话，不仅早早就会有收入，而且只学那些对自己最有用、最感兴趣的内容，学习的效率很高。如果发现对学术有兴趣，将来再回大学，攻读更高的学位，也是完全可以的。 大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程”画地为牢“限制住。你要主动去接触和学习，那些自己感兴趣的东西。引用一个网友的话，“你要做的就是自主、跨界、终身学习“。 中国大学的教育理念在吴军老师 《大学之路》 中介绍了大学的基本教育理念有两种： 纽曼的教育理念：倡导通才教育，本科阶段讲求知识面的广阔，要求更多的课外活动，而不要求专业的深度，专业的深造放到大四或者研究生阶段。具体像是哈佛大学，耶鲁大学，本科生在入学时有足够多的课程可以选择，但不需要确定专业，本科学习的后期才要求确定专业，保证本科生能够在尝试中找到自己心仪的专业，以确定未来自己的发展方向。 德国洪堡教育体制：强调专才教育，要求学生入学时就选定发展方向，讲求专业的深度。中国目前的高等教育模式就来自洪堡教育体制。 在纽曼的教育理念之下，学生一毕业并不能马上达到专业工作的要求，但事业和未来发展会有后劲。洪堡教育体制则更适合需要迅速发展生产的时代，比如工业革命后需要大量科学家的美国。洪堡教育体制下毕业的学生能够迅速为国家所用，实现自身脱贫，有助于社会的迅速工业化。 纽曼的教育理念和洪堡教育体制很难简单地说谁更好一点，而是要看 社会发展所处的阶段。 改革开放初期需要尽快发展经济，类似于工业革命背景之下的美国，显然洪堡教育体制下的大学教育见效更快。社会发展趋于稳定之后，纽曼的教育理念能够帮助学生找到发展的后劲。这也是为什么现在高考开始出现 “3 + 3”、某些地方大学计划可以自选专业课的原因。 虽然专才教育能够培养出很好的执行层面的人(无论是科学家、工程师，还是律师和医生)，但是却很难培养出拥有广阔事业的领袖以及实业家。当一个国家已经处于稳步发现阶段，当一个学生来自中上产之家，正朝着精英目标努力，这个时候，倘若缺少博雅的素质教育，路就跟难走得远。今天，中国的高中生一进高中就开始专攻那些高考必考的课程，而一进入大学，他们就被限制在不允许修改的专业中，这不仅失去了得到通才教育的机会，甚至被剥夺了培养自己学习兴趣的可能，我自己在读高中时受到了很多的通才教育，以至于到今天我所具备的人文和社会科学方面的素养，足以让我成为一个受人尊敬的人。可以说，没有好的通才教育，一个人的事业发展就不会有后劲。——吴军《大学之路》 三、我该如何学习？先做好终身学习的心里准备美国有一个谚语 「手里拿着锤子，看什么都是钉子」。指的是人们被自己的所拥有的知识能力所局限，导致自己做什么事情都想用手头已有的锤子来解决问题。 图片引用自：https://m.zcool.com.cn/work/ZNDA2NDkwNzY=.html 要克服这种铁锤人综合症的方法就是：在精通某一领域的同时接受各个领域的知识，并且将他们用来解决现实世界中的问题。 如此，再遇见钉子我们就有了一个工具箱。既有锤子，也有螺丝刀，还有钳子… 但是，要在短短的四年时间里做到这一点是有一定困难的： 首先，学校要有能力开出足够可供学生选择的课程。这一点，即使是如上交这样 (有大量政府投入的) 的学校都很难做到。每年到了选课的季节，都是对学校教务系统服务器的一次大考。学生们需要像抢春运火车票一样来抢仅有的上百门选修课。 其次，即使强行开出这些课程，但是课程的质量往往无法得到保障。在我的学校，许多选修课完全算不上吸引人，也很少教课教的好的老师 (我大学有一门课，老师上课不讲课就放视频，学生安静地待到下课就可以走了…)，于是这些选修课成了同学赶作业，玩手机的时间。 唯一的解决办法就是延长教育时间。 在美国许多名校，例如哈弗，普林斯顿采用本科给学生以通识教育，学生可以自由选课 (哈弗为了 6000 名本科开出了 2000 多门课)。之后再通过 1-2 年的研究生教育让学生实现专业教育。这个与中国研究生的轻教育重科研有所不同。 但是对于我们普通人来说，我们很难有机会进入这些顶级大学，接触到这样的资源，那我们应该怎么办呢？ 这个就要抛出所秉持的观念：坚持终身教育。这里引用吴军在《大学之路》里面的一段话： 可能许多人认识不到教育是一辈子的事情，我们不必担心输在起跑线上，因为世界上大部分人跑到一半就不会再跑了，这就给了长跑者机会 并且，一个善于学习的人，随着年龄的增长，他会找到自己的兴趣点，如果他还能够学习，就有了目的性和针对性。 在大学里我们需要养成一种自学的习惯。不仅仅是自学学校所定制的专业课，并且要有能根据自己的兴趣，要解决的问题而高效自学的能力。 并且养成习惯： 遇见问题 -&gt; 分析问题 -&gt; 搜集相关资料 -&gt; 学习相关资料 -&gt; 解决问题。 通过这样的方式，我们才能够跳出环境给我们带来的局限性，拥有更丰富的的人生。 方向不对，努力白费有一个清晰的目标很重要就说说我的两个同学吧。 同学 A | 大佬程序员： 一个是在大一刚进来，正当同学们还处于刚进入大学的那种朦朦胧胧、放放松松时，就已经决定好了要走技术这条路线的 同学 A。 在大一刚开学时就开始早早准备自学 C/ C++，等到我们开始上学校为我们开设的课程时，他已经利用一个暑假的时间，自己基于 Unix 改写自己的 操作系统。在我们上机的课堂上还听他吐槽自己实现的垃圾桶删不了文件，有 BUG。 后来等到我们开始学习计算机网络时，他又自己仿写了一个类 Nginx 服务器。 再等我们大四准备实习时，他俨然已经成为了 Offer 收割机，想去哪儿就去哪儿 (尽管我们学校仅仅是一个二本院校)。当时看着他简历上的两个项目：自己实现的操作系统和服务器，心里就是一句：「卧槽！牛逼！」。 同学 B | 大佬销售员： 大一就开始卖我们电脑.. 后来大二开学开始代理学校的电信、移动等移动业务，再后来还开展了驾校的业务，大四的时候吧，我们都还在找实习呢，他已经在学校周边开办起了自己的公司..成为了自己的 CEO.. 为之努力，并且永远不要怕晚后来想起这两位同学，常常会以 “他们目标好清晰” 这样的句式来 掩盖他们为之付出的努力，方向固然重要，但为之努力也同样。如果不是 同学 A 牺牲其他同学玩耍的时间自学学习编程，他不会成为后来人人眼红的 Offer 收割机，如果不是 同学 B 勤勤恳恳不怕辛苦经营、探索各种业务，那也不会后来早早成为自己的 CEO。 为之努力，并且永远不要觉得晚。说来惭愧，我的大学几乎可以说是从大三开始的，当我突然开始意识到我即将进入社会却身无长物时，我突然觉得需要一些些的改变和努力。于是我当天就开始制定计划，从那天到学期结束还有 七个星期零 2 天，于是有了下面这个计划： 从最基础的 Servlet/ JSP 到 SpringBoot 一整个基础的学习过来，也到了暑假，发现自己还是有差距所以毅然决定留校学习，于是有了 暑期计划： 这一段时间，给自己的简历上增加项目、学习巩固基础的数据结构、算法知识，然后 参加秋招 (当时的面经)，意识到自己的差距，并且想明白了自己想要继续学习更多的知识之后，决定 考研： 两个月的拼搏，虽然最终以 4 分的差距未能如愿择校，但后来春招也算是如愿进入了自己比较心仪的公司。 这一切的 “逆袭” 对于我来说，也不过仅仅一年的时间。 我把这些经历也记录在了这里 - 2018 年终总结 锻炼独立思考、自主研究解决问题的能力在前一段时间里，我接触到一个词：「二手人生」。它概括的是这样一种处境：「你发现你在生活里遇到的所有问题，在搜索引擎里都能找到答案」。 比如说，怎么搭配衣服才低调优雅，去哪吃饭便宜又美味，买哪款耳机更划算，工作还是考研，要不要入手比特币，都有人替你解答了。你还发现有一批人用照片、视频、段子、广告为你提供了一个精心加工过的世界，这个世界常常比你自个儿的世界要美丽有趣深刻好笑有品位得多。如果把当代生活比作一场开卷考，比起你自己慢慢找答案，达人们已经为你提供了一套高分答案放到你面前让你参考。 渐渐地你养成了一种 学生式习惯，当生活给你发了一份新卷子，你的第一反应就是先翻到网上，去看参考答案。 事实证明，后来我们接触的大部分事情 (无论生活还是学习上)，都不太容易有一个标准答案，当问题来临时，如何独立思考、自主研究解决问题，是非常重要的能力。 自我写博客以来，常常收到读者们发来的问题，有一些是他们真实地遇到了不可解决的问题寻求我的帮助，有一些问题则显得我很意外，就像下面这样：(网站链接 戳这里) 为什么会这样呢？我想大概就是学生时代遗留下来的习惯吧，习惯了更轻松一些的向别人寻求帮助或者是翻找参考答案，很少自己主动地去思考并得出问题的答案。 这里给出一个问问题的标准模板： 学会编程而不是学会 Java其实技术是相通的。编程的落脚点还是应该放在 解决问题 上，而不是使用某种工具上。更重要的是我们通过学习某一种编程语言，来帮助我们养成 计算机的思维方式，这也要求了我们在掌握一种技术时，不仅要 知其然，还要知其所以然。 例如在「码农翻身」的一篇文章「学会编程， 而不是学会Java」 里就提到了一个问题，模仿 Java 的 ArrayList 实现一个自己的 SimpleList 类：(现在看不懂也没关系) public class SimpleList&lt;T> { private Object[] elementData; private int size = 0; public int size() { return -1; } public SimpleList() { } public boolean isEmpty() { return false; } public boolean add(T e) { return false; } public boolean remove(Object o) { return false; } public T get(int index) { return null; } } 这个题目不要求实现复杂的算法， 也不需要进行面向对象的设计，也不需要考虑多线程下的线程安全， 况且已经给了提示：「用一个Object数组来实现」。如果说有一点语法层面的难度， 那就是使用了一点泛型。 这个 SimpleList 要求的就是能对一个数组进行操作，核心就两点： 能往数组添加数据， 记录size ，如果数组空间不够了， 需要增大空间 能删除数组指定位置的数据，并且把之后的数据往前挪动。 难吗？这其实是编程序的基本素养，编程的本质，和用什么语言实现没有关系。 写更多更多的代码技术没有捷径技术不要想着有捷径可寻，十年入行是有道理的。 现在随便走进一家书店，都会在技术类的书架上看到一堆的类似于《24小时学会Java》、《21天C++从入门到精通》这样的的书 (上面的漫画就很好地调侃了)，然而这一类「标题党」书籍，都是让你「走马观花」地瞧上一瞧，也没有时间让你写几个真正有意义的程序，这样的 「一知半解」 是一件极其危险的事情。 踏踏实实铺平基础知识，才是正道。 做 ABC 的程序员而不是 ABR ABC: Always Be Coding… ABR: Always Be Reading… 看时会，做时废？人们口中常说的 「经验」，其实是指从自己 「一手实践」 中得到的 「一手经验」，而不是指那些从文章从别人口中获取到的「二手经验」。所以要保持 「保持始终编程」，你编写的代码越多，那么你的水平就会提升得越多。 去 造重复的轮子、与其他程序员交流、动手实践自己的想法。最佳实践就是集中训练，并且不断地探索新领域并挑战自己。 自学自学是程序员必须掌握的一项技能，上面已经说到了大学的课程设计不是以 培养程序员 为目的的，而是以 教授最基础的知识技能，所以自学很重要。 一些高质量的自学资料和平台 部分摘录自：Github 近90k点赞的计算机专业课程,在家也能上名校! | JavaGuide computer-science star :56.1k Github 地址：https://github.com/ossu/computer-science#intro-cs 介绍：通往计算机科学免费自学教育之路！计算机专业课程 TeachYourselfCS-CN (自学计算机科学) star :0.8k Github 地址：https://github.com/keithnull/TeachYourselfCS-CN 介绍：TeachYourselfCS 的中文翻译。内容超级棒！如果你是一个自学成才的工程师，或者从编程培训班毕业，那么你很有必要学习计算机科学。幸运的是，不必为此花上数年光阴和不菲费用去攻读一个学位：仅仅依靠自己，你就可以获得世界一流水平的教育。在这份指引中会为你解答：你应当学习 哪些科目，为什么？对于这些科目，最好的书籍或者视频课程是什么？ REKCARC-TSC-UHT(清华大学计算机系课程攻略) star :12.2k Github 地址：https://github.com/PKUanonym/REKCARC-TSC-UHT 介绍：清华大学计算机系课程攻略。受 浙江大学相关项目 启发，创立了本项目。 网易云课堂 - 顶尖中文大学计算机专业课程体系 地址：https://study.163.com/curricula/cs.htm 介绍：汇集全国多家知名大学里广受学生好评的计算机老师，每一门课程都由他们亲自制作，权威、专业！人人都可以在这里体验到时下最流行的 MOOC，系统地掌握计算机专业知识。 and more… 类似的资料有很多，重点还是要自己能够静得下心来学习，如果纠结「看书还是看视频」，我的建议是 「都看！」。 不要在寝室学习宿舍里面吃的喝的玩的，要啥啥都有，而且环境复杂.. 很难不被各种奇怪的东西影响.. 所以要学习就不要呆在宿舍。 对自己有更高的标准，才会有更多选择 这里直接引用《精进》 的段落。 决策心理学认为，人在面临选择时，通常会采用 “满意原则”，而不是 “最优原则”。所谓 “满意原则”，就是人会从自己最熟悉的待选项开始逐一考察，如果发现了一个能满足内心标准的选项，觉得它是 OK 的，就会采纳它，不会继续寻找其他选项了。 拿怎样度过大学生涯来举例子。很多大一新生来到大学后，以为你刚刚从原本严苛的高中生活中解放出来，所以一时间不知道怎么适应大学生活，整天耽于玩乐，荒废了学业。本来他们完全可以选择认真地对待学习，可是他们却选择了相反的大学之路，其中一个最重要的原因就是没有在心中设立一个比较高的标准。 特别是那些考入二三流大学的学生，在这方面的问题可能更加严重，因为高考本身带来的挫败感、二三流高校学生的身份设定及环境暗示、不称职的老师引发的失望以及同学间放任自流气氛的带动作用，都容易让他们在一个低标准下自觉“满意”地度过每一天。 一个成熟的人，他的标准来自他的内心，而大多数人，却受环境所左右。一个年轻人，进入一所不那么优秀的高校，对自己的标准会不由自主地降低以适应这个环境，减少自身与环境的冲突，而这种做法对他们的人生也许是致命的。一个二三流大学的学生，能够勇敢地以 “985” 高校学生中的中档乃至高档水准来要求自己才是更恰当的做法，他也一定会从中受益。 如果心中有了更高的标准，他甚至可以选择 “炒掉” 自己的学校、专业，打破旧环境的束缚，寻找更高层次的新环境，比如选择做这些事： 选择网络上高水平的在线课程，不选择本校水平稀烂的课程； 选择国内或国外优秀的教材，不选择国内某些拼凑而成的注水教材； 选择与最优秀的同学或学长交流，不选择与班级里成天玩乐的同学为伍； 选择参加具有挑战性的各类竞赛，不选择只满足于完成基本的课程作业； …… 首先意识到你是有更多选择的，意识到现在环境给你的选项远远不是你可以获得的全部，然后你便可以让更高的标准推动着你，去发现更多的选项，最后做出对自己来说更好的选择。 这个方法，不论是对于什么身份、什么年龄、什么处境的人应该都是适用的。 参考资料 千万别学计算机 | 码农翻身 计算机行业还能火多久？ 996.ICU 背后：程序员在互联网公司的真实生态 | InfoQ 编程到底难在哪？ | 知乎 这篇写给想选计算机专业的学弟学妹们 | Crossin的编程教室 为什么你可以不读大学 | 阮一峰 从《大学之路》思考我的大学教育为什么失败？ 纽曼+鸿堡 | 真正的大学生活 学会编程，而不是学会Java 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编码之前需要知道的事","slug":"基础知识/编码之前需要知道的事","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"}],"tags":[{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"}],"author":"我没有三颗心脏"},{"title":"懂一点前端—Vue快速入门","slug":"懂一点前端—Vue快速入门","date":"2020-03-30T06:38:00.000Z","updated":"2020-12-09T04:51:45.505Z","comments":true,"path":"2020/03/30/dong-yi-dian-qian-duan-vue-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2020/03/30/dong-yi-dian-qian-duan-vue-kuai-su-ru-men/","excerpt":"","text":"01. 什么是 Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，是当下很火的一个 JavaScript MVVM 库，是以 数据驱动和组件化 的思想构建的。 MVVM 模式简述下图不仅概括了 MVVM 模式 （Model-View-ViewModel），还描述了在 Vue.js 中 ViewModel 是如何和 View 以及 Model 进行交互的。 ViewModel 是 Vue.js 的核心，它是一个 Vue 实例。Vue 实例是作用于某一个 HTML 元素上的，这个元素可以是 HTML 的 body 元素，也可以是指定了 id 的某个元素。 当创建了 ViewModel 后，双向绑定是如何达成的呢？ 首先，我们将上图中的 DOM Listeners 和 Data Bindings 看作两个工具，它们是实现双向绑定的关键。 从 View 侧看，ViewModel 中的 DOM Listeners 工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据； 从 Model 侧看，当我们更新 Model 中的数据时，Data Bindings 工具会帮我们更新页面中的 DOM 元素。 库和框架的区别 在这里我们需要稍微注意一下前端 库(Library) 和 框架(Framework) 的区别，它们的本质都是某人编写的，用于解决常见问题的 可复用代码 的集合。 比如，你有一个处理字符串的程序，你为了保持代码的 DRY (Don’t Repeat Yourself)，你编写了如下可复用的功能代码： function getWords(str) { const words = str.split(' '); return words; } function createSentence(words) { const sentence = words.join(' '); return sentence; } 恭喜你，你创建了一个 JavaScript 库！ 如果我们用 「构建房子」 来类比 「构建应用」 的话，那么 使用库 就像是 去宜家购物 一样，我已经有了一个家，现在我需要挑选自己喜欢的一些家具，以达到我自己满意的状态，这一切 都在我的控制范围之内；而 使用框架 就会像是已经有了一个 清装房，在已经规划好的蓝图和选择之中，我们的一些想法会显得十分地有限。 Vue.js 本身只是一个 JavaScript 库，包括 React 也一样，只不过平时我们所说的 Vue 框架，是指包含 Router/ Vuex 等一系列组件之后融合的 一整套解决方案。 更加详细的解释如下： 「库」 是一个封装好的特定的集合，提供给开发者使用，而且是特定于某一方面的集合（方法和函数），库没有控制权，控制权完全在于使用者本身； 「框架」 顾名思义是一套架构，会基于自身的特点向用户提供一套比较完整的解决方案，如果使用者选定了一套框架，那么就需要根据框架本身做出一定的适应。 02. 为什么使用 Vue？ 说实话，我个人非常喜欢 Vue。在我大学刚尝试学习 HTML + CSS + JavaScript 和 Bootstrap 融合之后，我就接触了 Vue，它对我来说这样的「前端小白」来说，几乎没有什么开发的门槛，很平滑地就得以过渡到 Vue 的使用中去。 典型的 .vue 文件可以简单成如下的样子：(vue-tutorial/typical-case.html) // JavaScript 代码 /* css 代码 */ 另外我也非常喜欢尤大大本人，大家可以去看一看 Honeypot 记录的关于 Vue 的 纪录片 (趁着写文的间隙我又看了一遍)，当然如果英文有些吃力也可以围观一下在 B 站上的 带中文字幕的版本。 Vue 从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。———— 尤雨溪 理由一：易上手、学习曲线平滑就像上面的典型 .vue 文件的展示一样，在 Vue 中，一切都很自然，例如我们使用 Vue 来构建我们的 Hello World 程序：(vue-tutorial/hello-vue.html) &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Hello Vue!&lt;/title> &lt;/head> &lt;body> &lt;div id=\"app\"> {{ message }} &lt;/div> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\">&lt;/script> &lt;script> // 创建一个 Vue 实例或者说是 VieModel 实例 var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }) &lt;/script> &lt;/body> &lt;/html> 可以看到几乎没有多余的部分，只是在创建 Vue 实例时，把 id 为 app 的对象 (此处为一个 div) 绑定到了 Vue 实例中而已。 理由二：文档友好由于 Vue 是国人编写的，所以在官网中有完整的中文文档可供开发者参考，并且借由尤大大出色的文笔，非常地清晰易懂，相信看过的朋友会和我有一样的感受： 官方文档的地址可戳 这里 理由三：MVVM 天然的双向绑定Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 JavaScript 库，这就让我们能够专注于 View 层的开发，这种轻量级的框架让前端开发更加高效、便捷。 例如，我们使用 v-model 来简单改造一下我们的 hello-vue.html 文件让它编程一个简单的双向绑定示例：(vue-tutorial/v-model-demo.html) &lt;div id=\"app\"> &lt;p>{{ message }}&lt;/p> &lt;input type=\"text\" v-model=\"message\" /> &lt;/div> 将 message 绑定到文本框，当更改文本框的值的时候， &lt;p&gt;&lt;/p&gt; 中的内容也会被更新： 反过来如果我们更改 message 的值的话，文本框的值也会被更新，我们可以在控制台中尝试一下： 千万不要把框架能力看得比你解决问题的能力还重要这里是借鉴了 知乎中的一个讨论，不论是使用 React 还是 Vue，我们最终还是要以 解决实际的问题 为出发点。引用一下尤大大在 知乎-Vue 和 React 的优点分别是什么？ 上的回答部分截取： 说了这么多，无非是希望大家能停下来想想所谓的 ”A 技术比 B 技术牛逼“ 背后到底是在争些什么，我们使用这些技术的初衷又是什么。很多时候你说这方面，他说那方面，鸡同鸭讲，即使说到一起去，也往往缺乏对等的信息量或者基础共识，只是各自表达主观看法，最后变成两个阵营各自抱团取暖… 说到底，就算你证明了 A 比 B 牛逼，也不意味着你或者你的项目就牛逼了… 比起争这个，不如多想想怎么让自己变得更牛逼吧。—————— 尤雨溪 03. Vue 常用指令 上面我们已经实际体验了一个 Vue 的指令 v-model 了，在 Vue 中，指令都带有 v- 前缀，以表示它们是 Vue 提供的特殊的 attribute，它们会在渲染 DOM 时进行特殊的响应式行为。 Vue 内置了一些常用的指令，接下来我们将依次来介绍： v-if 和 v-else 条件渲染指令； v-show 条件展示指令； v-for 列表渲染指令 v-bind 条件绑定指令； v-on 事件处理指令； 大部分照搬的官方教程，写得非常具有参考性，感兴趣的朋友可以直接略过下面部分去参考 官方文档。 v-if 和 v-else 条件渲染指令v-if 指令v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。例如：(vue-tutorial/v-if-demo) &lt;p v-if=\"seen\">现在你看到我了！&lt;/p> var app = new Vue({ el: '#app', data: { seen: true } }) 页面会正确的显示「现在你看到我了！」这几个字。 v-else 指令你也可以使用 v-else 来添加一个 “else 块” 来表达条件不满足时应该渲染的模块： &lt;p v-if=\"seen\">现在你看到我了！&lt;/p> &lt;p v-else>Oh no!&lt;/p> var app = new Vue({ el: '#app', data: { seen: false } }) 此时条件 seen 不满足，页面就会显示「Oh no!」的字样。 v-else-if 指令这是 2.1.0 版本新增的指令，充当 v-if 的 “else-if 块”，可以用来连续判断条件： &lt;div v-if=\"type === 'A'\"> A &lt;/div> &lt;div v-else-if=\"type === 'B'\"> B &lt;/div> &lt;div v-else-if=\"type === 'C'\"> C &lt;/div> &lt;div v-else> Not A/B/C &lt;/div> 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 v-show 条件展示指令另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： &lt;h1 v-show=\"ok\">Hello!&lt;/h1> 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display (条件不满足则把元素 display 属性设置为 none)，而 v-if 则在条件不满足时直接不渲染出对象。 v-if 与 v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是 惰性 的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-for 列表渲染指令我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。 &lt;ul id=\"example-1\"> &lt;li v-for=\"item in items\"> {{ item.message }} &lt;/li> &lt;/ul> var example1 = new Vue({ el: '#example-1', data: { items: [ { message: 'Foo' }, { message: 'Bar' } ] } }) 结果： Foo Bar 注意：永远不要把 v-if 和 v-for 同时用在同一个元素上。 因为当 Vue 处理指令时，v-for 比 v-if 拥有更高的优先级，所以会导致错误，详细的技术细节可以 戳这里 v-bind 条件绑定指令我们可以传给 v-bind:class 一个对象，以动态地切换 class：(也可以用缩写 : 来替代 v-bind 指令) &lt;div v-bind:class=\"{ active: isActive }\">&lt;/div> 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。当有如下模板： &lt;div class=\"static\" v-bind:class=\"{ active: isActive, 'text-danger': hasError }\" >&lt;/div> 和如下 data： data: { isActive: true, hasError: false } 结果渲染为： &lt;div class=\"static active\">&lt;/div> 当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果 hasError 的值为 true，class 列表将变为 &quot;static active text-danger&quot;。 v-on 事件处理指令可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。(也可以用缩写 @ 来替代 v-on 指令) 示例： &lt;div id=\"example-1\"> &lt;button v-on:click=\"counter += 1\">Add 1&lt;/button> &lt;p>The button above has been clicked {{ counter }} times.&lt;/p> &lt;/div> var example1 = new Vue({ el: '#example-1', data: { counter: 0 } }) 结果： v-on 的事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive &lt;!-- 阻止单击事件继续传播 --> &lt;a v-on:click.stop=\"doThis\">&lt;/a> &lt;!-- 提交事件不再重载页面 --> &lt;form v-on:submit.prevent=\"onSubmit\">&lt;/form> &lt;!-- 修饰符可以串联 --> &lt;a v-on:click.stop.prevent=\"doThat\">&lt;/a> &lt;!-- 只有修饰符 --> &lt;form v-on:submit.prevent>&lt;/form> &lt;!-- 添加事件监听器时使用事件捕获模式 --> &lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --> &lt;div v-on:click.capture=\"doThis\">...&lt;/div> &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --> &lt;!-- 即事件不是从内部元素触发的 --> &lt;div v-on:click.self=\"doThat\">...&lt;/div> 另外事件处理还可以支持 按键码 (某一个键按下)、系统修饰符 (键盘鼠标按下)，可以参看 官方教程 04. Todo-List 示例 上面我们了解了一些基本的指令了，接下来我们实际动动手，来搭建一个简单的 TodoList demo 小程序。 第一步：明确需求TodoList 想必大家都很熟悉，使用来记录我们接下来要做的一些事情的程序，最基本的功能有增加和删除： 很简单，可以看出我们只需要一个输入框 (用来记录将要保存的数据)，一个按钮 *(用来添加数据)，和一个集合 *(用来保存数据) 就差不多可以了，上手！ 第二步：创建好需要的 data先来创建好我们需要的数据 data： data: { todos: [{ id: nextTodoId++, text: '写代码' }, { id: nextTodoId++, text: '还是写代码' } ], newTodoText: \"\" } 这里多定义了 id 属性是为了方便我们的删除操作。 第三步：创建好对应的 HTML没有任何布局，就直接定义好我们所需要的组件就好了： &lt;input type=\"text\" v-model=\"newTodoText\" /> &lt;button @click=\"addItem\">添加&lt;/button> &lt;ul> &lt;li v-for=\"item in todos\"> &lt;span>{{ item.text }}&lt;/span> &lt;span>&lt;button @click=\"removeItem(item.id)\">del&lt;/button>&lt;/span> &lt;/li> &lt;/ul> 没有任何的特别，只是里面包含了两个我们 未定义 的方法：addItem 和 removeItem 而已。 第三步：定义并实现方法Vue 中的方法需要定义在 Vue 实例的 methods 关键字下面： methods: { addItem(key) { this.todos.push({ id: nextTodoId, text: this.newTodoText }) this.newTodoText = \"\" }, removeItem(id) { this.todos = this.todos.filter(todo => { return todo.id !== id }) } } 这里数组的更新需要用到 push，另外删除时我们使用了一个 lambda 表达式来完成，删除时传入了一个要删除元素的 id，然后从数组中挑选出所有 不等于 这个 id 的元素重新赋值给原数组，这样就相当于是删除了元素了。 本文涉及的所有代码都上传到了【More Than Java】项目中。(地址下方) 更好的参考上面的代码仅仅是简单实现，更好的参考可以查看 Vue 官方实现的一个更加具有参考性的例子：https://codesandbox.io/s/o29j95wx9 参考资料 Vue【官方文档】 - https://cn.vuejs.org/v2/guide/ 【译】框架与库的差异 - https://juejin.im/post/5c5fe3e751882561dd7b4e9b Vue.js——60分钟快速入门 - https://www.cnblogs.com/keepfool/p/5619070.html 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"妈妈再也不担心我面试被Redis问得脸都绿了","slug":"妈妈再也不担心我面试被Redis问得脸都绿了","date":"2020-03-25T06:38:00.000Z","updated":"2020-12-09T04:55:10.390Z","comments":true,"path":"2020/03/25/ma-ma-zai-ye-bu-dan-xin-wo-mian-shi-bei-redis-wen-de-lian-du-lu-liao/","link":"","permalink":"http://www.wmyskxz.com/2020/03/25/ma-ma-zai-ye-bu-dan-xin-wo-mian-shi-bei-redis-wen-de-lian-du-lu-liao/","excerpt":"","text":"长文前排提醒，收藏向前排提醒，素质三连 (转发 + 在看 + 留言) 前排提醒！ 前言 Redis 作为一个开源的，高级的键值存储和一个适用的解决方案，已经越来越在构建 「高性能」、「可扩展」 的 Web 应用上发挥着举足轻重的作用。 当今互联网技术架构中 Redis 已然成为了应用得最广泛的中间件之一，它也是中高级后端工程 技术面试 中面试官最喜欢问的工程技能之一，不仅仅要求着我们对 基本的使用 进行掌握，更要深层次地理解 Redis 内部实现 的细节原理。 熟练掌握 Redis，甚至可以毫不夸张地说已经半只脚踏入心仪的公司了。下面我们一起来盘点回顾一下 Redis 的面试经典问题，就不要再被面试官问得 脸都绿了 呀！ Ps： 我把 重要的知识点 都做成了 图片，希望各位 “用餐愉快”。(不错记得付餐费.. 点个赞留个言..) 一、基础篇 什么是 Redis ？先解释 Redis 基本概念Redis (Remote Dictionary Server) 是一个使用 C 语言 编写的，开源的 (BSD许可) 高性能 非关系型 (NoSQL) 的 键值对数据库。 简单提一下 Redis 数据结构Redis 可以存储 键 和 不同类型数据结构值 之间的映射关系。键的类型只能是字符串，而值除了支持最 基础的五种数据类型 外，还支持一些 高级数据类型： 一定要说出一些高级数据结构 (当然你自己也要了解.. 下面会说到的别担心)，这样面试官的眼睛才会亮。 Redis 小总结与传统数据库不同的是 Redis 的数据是 存在内存 中的，所以 读写速度 非常 快，因此 Redis 被广泛应用于 缓存 方向，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做 分布式锁。 除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 Redis 优缺点优点 读写性能优异， Redis能读的速度是 110000 次/s，写的速度是 81000 次/s。 支持数据持久化，支持 AOF 和 RDB 两种持久化方式。 支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 缺点 数据库 容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 系统的可用性。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 为什么要用缓存？为什么使用 Redis？提一下现在 Web 应用的现状在日常的 Web 应用对数据库的访问中，读操作的次数远超写操作，比例大概在 1:9 到 3:7，所以需要读的可能性是比写的可能大得多的。当我们使用 SQL 语句去数据库进行读写操作时，数据库就会 去磁盘把对应的数据索引取回来，这是一个相对较慢的过程。 使用 Redis or 使用缓存带来的优势如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样 速度 明显就会快上不少 (高性能)，并且会 极大减小数据库的压力 (特别是在高并发情况下)。 记得是 两个角度 啊.. 高性能 和 高并发.. 也要提一下使用缓存的考虑但是使用内存进行数据存储开销也是比较大的，限于成本 的原因，一般我们只是使用 Redis 存储一些 常用和主要的数据，比如用户登录的信息等。 一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑： 业务数据常用吗？命中率如何？ 如果命中率很低，就没有必要写入缓存； 该业务数据是读操作多，还是写操作多？ 如果写操作多，频繁需要写入数据库，也没有必要使用缓存； 业务数据大小如何？ 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要； 在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！ 使用缓存会出现什么问题？一般来说有如下几个问题，回答思路遵照 是什么 → 为什么 → 怎么解决： 缓存雪崩问题； 缓存穿透问题； 缓存和数据库双写一致性问题； 缓存雪崩问题 另外对于 “Redis 挂掉了，请求全部走数据库” 这样的情况，我们还可以有如下的思路： 事发前：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。 事发中：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的) 事发后：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。 缓存穿透问题 缓存与数据库双写一致问题 双写一致性上图还是稍微粗糙了些，你还需要知道两种方案 (先操作数据库和先操作缓存) 分别都有什么优势和对应的问题，这里不作赘述，可以参考一下下方的文章，写得非常详细。 面试前必须要知道的Redis面试题 | Java3y - https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A Redis 为什么早期版本选择单线程？官方解释因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是 机器内存的大小 或者 网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。 简单总结一下 使用单线程模型能带来更好的 可维护性，方便开发和调试； 使用单线程模型也能 并发 的处理客户端的请求；(I/O 多路复用机制) Redis 服务中运行的绝大多数操作的 性能瓶颈都不是 CPU； 强烈推荐 各位亲看一下这篇文章： 为什么 Redis 选择单线程模型 · Why’s THE Design? - https://draveness.me/whys-the-design-redis-single-thread Redis 为什么这么快？简单总结： 纯内存操作：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快) 单线程，无锁竞争：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能； 多路 I/O 复用模型，非阻塞 I/O：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）； 高效的数据结构，加上底层做了大量优化：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等.. 二、数据结构篇 简述一下 Redis 常用数据结构及实现？首先在 Redis 内部会使用一个 RedisObject 对象来表示所有的 key 和 value： 其次 Redis 为了 平衡空间和时间效率，针对 value 的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系：(好像乱糟糟的，但至少能看清楚..) Redis 的 SDS 和 C 中字符串相比有什么优势？先简单总结一下C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 \\0，这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。 再来说 C 语言字符串的问题这样简单的数据结构可能会造成以下一些问题： 获取字符串长度为 O(N) 级别的操作 → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组； 不能很好的杜绝 缓冲区溢出/内存泄漏 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题； C 字符串 只能保存文本数据 → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 &#39;\\0&#39; 可能会被判定为提前结束的字符串而识别不了； Redis 如何解决的 | SDS 的优势 如果去看 Redis 的源码 sds.h/sdshdr 文件，你会看到 SDS 完整的实现细节，这里简单来说一下 Redis 如何解决的： 多增加 len 表示当前字符串的长度：这样就可以直接获取长度了，复杂度 O(1)； 自动扩展空间：当 SDS 需要对字符串进行修改时，首先借助于 len 和 alloc 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况； 有效降低内存分配次数：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 空间预分配 和 惰性空间释放 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS； 二进制安全：C 语言字符串只能保存 ascii 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制； 字典是如何实现的？Rehash 了解吗？先总体聊一下 Redis 中的字典字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 hash 结构的数据会用到字典外，整个 Redis 数据库的所有 key 和 value 也组成了一个 全局字典，还有带过期时间的 key 也是一个字典。(存储在 RedisDb 数据结构中) 说明字典内部结构和 rehashRedis 中的字典相当于 Java 中的 HashMap，内部实现也差不多类似，都是通过 “数组 + 链表” 的 链地址法 来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。 字典结构内部包含 两个 hashtable，通常情况下只有一个 hashtable 有值，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 渐进式搬迁 (rehash)，这时候两个 hashtable 分别存储旧的和新的 hashtable，待搬迁结束后，旧的将被删除，新的 hashtable 取而代之。 扩缩容的条件正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。 当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。 跳跃表是如何实现的？原理？ 这是 Redis 中比较重要的一个数据结构，建议阅读 之前写过的文章，里面详细介绍了原理和一些细节： Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ HyperLogLog 有了解吗？ 建议阅读 之前的系列文章： Redis(4)——神奇的HyperLoglog解决统计问题 - https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/ 布隆过滤器有了解吗？ 建议阅读 之前的系列文章： Redis(5)——亿级数据过滤和布隆过滤器 - https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/ GeoHash 了解吗？ 建议阅读 之前的系列文章： Redis(6)——GeoHash查找附近的人 - https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/ 压缩列表了解吗？这是 Redis 为了节约内存 而使用的一种数据结构，zset 和 hash 容器对象会在元素个数较少的时候，采用压缩列表（ziplist）进行存储。压缩列表是 一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。 因为之前自己也没有学习过，所以找了一篇比较好比较容易理解的文章： 图解Redis之数据结构篇——压缩列表 - https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg 这一篇稍微底层稍微硬核一点：http://www.web-lovers.com/redis-source-ziplist.html 快速列表 quicklist 了解吗？Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，prev 和 next 指针就要占去 16 个字节（64 位操作系统占用 8 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。 后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。 同上..建议阅读一下以下的文章： Redis列表list 底层原理 - https://zhuanlan.zhihu.com/p/102422311 Stream 结构有了解吗？Redis Stream 从概念上来说，就像是一个 仅追加内容 的 消息链表，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：消费者组(Consumer Group) (思路一致，实现不同)： 上图就展示了一个典型的 Stream 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。我们对图中的一些概念做一下解释： Consumer Group：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 XREAD 命令进行 独立消费，也可以多个消费者同时加入一个消费者组进行 组内消费。同一个消费者组内的消费者共享所有的 Stream 信息，同一条消息只会有一个消费者消费到，这样就可以应用在分布式的应用场景中来保证消息的唯一性。 last_delivered_id：用来表示消费者组消费在 Stream 上 消费位置 的游标信息。每个消费者组都有一个 Stream 内 唯一的名称，消费者组不会自动创建，需要使用 XGROUP CREATE 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 last_delivered_id 这个变量。 pending_ids：每个消费者内部都有的一个状态变量，用来表示 已经 被客户端 获取，但是 还没有 ack 的消息。记录的目的是为了 保证客户端至少消费了消息一次，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 PEL (Pending Entries List)。 Stream 消息太多怎么办？很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。xdel 指令又不会删除消息，它只是给消息做了个标志位。 Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 xadd 的指令提供一个定长长度 maxlen，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单： > XADD mystream MAXLEN 2 * value 1 1526654998691-0 > XADD mystream MAXLEN 2 * value 2 1526654999635-0 > XADD mystream MAXLEN 2 * value 3 1526655000369-0 > XLEN mystream (integer) 2 > XRANGE mystream - + 1) 1) 1526654999635-0 2) 1) \"value\" 2) \"2\" 2) 1) 1526655000369-0 2) 1) \"value\" 2) \"3\" 如果使用 MAXLEN 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息) 另外使用 MAXLEN 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 ~ 的特殊命令： XADD mystream MAXLEN ~ 1000 * ... entry fields here ... 它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 1000 条数据，可能是 1010 也可能是 1030。 PEL 是如何避免消息丢失的？在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 xreadgroup 的起始消息 ID 不能为参数 &gt; ，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自 last_delivered_id 之后的新消息。 和 Kafka 对比起来呢？Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 不能长时间存储大量数据。不过如果您想以 最小延迟 实时处理消息的话，您可以考虑 Redis，但是如果 消息很大并且应该重用数据 的话，则应该首先考虑使用 Kafka。 另外从某些角度来说，Redis Stream 也更适用于小型、廉价的应用程序，因为 Kafka 相对来说更难配置一些。 推荐阅读 之前的系列文章，里面 也对 Pub/ Sub 做了详细的描述： Redis(8)——发布/订阅与Stream - https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/ 三、持久化篇 什么是持久化？先简单谈一谈是什么Redis 的数据 全部存储 在 内存 中，如果 突然宕机，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 持久化机制，它会将内存中的数据库状态 保存到磁盘 中。 解释一下持久化发生了什么我们来稍微考虑一下 Redis 作为一个 “内存数据库” 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情： 详细版 的文字描述大概就是下面这样： 客户端向数据库 发送写命令 (数据在客户端的内存中) 数据库 接收 到客户端的 写请求 (数据在服务器的内存中) 数据库 调用系统 API 将数据写入磁盘 (数据在内核缓冲区中) 操作系统将 写缓冲区 传输到 磁盘控控制器 (数据在磁盘缓存中) 操作系统的磁盘控制器将数据 写入实际的物理媒介 中 (数据在磁盘中) 分析如何保证持久化安全如果我们故障仅仅涉及到 软件层面 (该进程被管理员终止或程序崩溃) 并且没有接触到内核，那么在 上述步骤 3 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。 如果我们考虑 停电/ 火灾 等 更具灾难性 的事情，那么只有在完成了第 5 步之后，才是安全的。 所以我们可以总结得出数据安全最重要的阶段是：步骤三、四、五，即： 数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？ 内核多久从缓冲区取数据刷新到磁盘控制器？ 磁盘控制器多久把数据写入物理媒介一次？ 注意： 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 尽可能地保证 数据的安全，这对于所有数据库来说都是一样的。 我们从 第三步 开始。Linux 系统提供了清晰、易用的用于操作文件的 POSIX file API，20 多年过去，仍然还有很多人对于这一套 API 的设计津津乐道，我想其中一个原因就是因为你光从 API 的命名就能够很清晰地知道这一套 API 的用途： int open(const char *path, int oflag, .../*,mode_t mode */); int close (int filedes);int remove( const char *fname ); ssize_t write(int fildes, const void *buf, size_t nbyte); ssize_t read(int fildes, void *buf, size_t nbyte); 参考自：API 设计最佳实践的思考 - https://www.cnblogs.com/yuanjiangw/p/10846560.html 所以，我们有很好的可用的 API 来完成 第三步，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。 然后我们来说说 第四步。我们知道，除了早期对电脑特别了解那帮人 (操作系统就这帮人搞的)，实际的物理硬件都不是我们能够 直接操作 的，都是通过 操作系统调用 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 上述第四步 提到的 写缓冲区，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 30 秒 后实际提交写入。 但是很明显，30 秒 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 PROSIX API 提供了另一个解决方案：fsync，该命令会 强制 内核将 缓冲区 写入 磁盘，但这是一个非常消耗性能的操作，每次调用都会 阻塞等待 直到设备报告 IO 完成，所以一般在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 fsync 操作。 到目前为止，我们了解到了如何控制 第三步 和 第四步，但是对于 第五步，我们 完全无法控制。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。 普通人简单说一下第一条就过了，如果你详细地对后面两方面 侃侃而谈，那面试官就会对你另眼相看了。 Redis 中的两种持久化方式？方式一：快照 Redis 快照 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 100 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 .rdb 文件生成。 方式二：AOF 快照不是很持久。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 kill -9 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。 AOF(Append Only File - 仅追加文件) 它的工作方式非常简单：每次执行 修改内存 中数据集的写操作时，都会 记录 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 所有的修改性指令序列，那么就可以通过对一个空的 Redis 实例 顺序执行所有的指令，也就是 「重放」，来恢复 Redis 当前实例的内存数据结构的状态。 Redis 4.0 的混合持久化 重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 自持久化开始到持久化结束 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小： 于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。 关于两种持久化方式的更多细节 (原理) 可以参考： Redis(7)——持久化【一文了解】 - https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/ RDB 和 AOF 各自有什么优缺点？RDB | 优点 只有一个文件 dump.rdb，方便持久化。 容灾性好，一个文件可以保存到安全的磁盘。 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能 相对于数据集大时，比 AOF 的 启动效率 更高。 RDB | 缺点 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候； AOF | 优点 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。 AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall） AOF | 缺点 AOF 文件比 RDB 文件大，且 恢复速度慢。 数据集大 的时候，比 rdb 启动效率低。 两种方式如何选择？ 一般来说， 如果想达到足以媲美 PostgreSQL 的 数据安全性，你应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。 如果你非常关心你的数据， 但仍然 可以承受数分钟以内的数据丢失，那么你可以 只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。 Redis 的数据恢复Redis 的数据恢复有着如下的优先级： 如果只配置 AOF ，重启时加载 AOF 文件恢复数据； 如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据； 如果只配置 RDB，启动将加载 dump 文件恢复数据。 拷贝 AOF 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程：Redis 虚拟一个客户端，读取 AOF 文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在 loadAppendOnlyFile() 中实现。 拷贝 RDB 文件到 Redis 的数据目录，启动 redis-server 即可，因为 RDB 文件和重启前保存的是真实数据而不是命令状态和参数。 四、集群篇 主从同步了解吗？ 主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 主节点(master)，后者称为 从节点(slave)。且数据的复制是 单向 的，只能由主节点到从节点。Redis 主从复制支持 主从同步 和 从从同步 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。 主从复制主要的作用 数据冗余： 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是一种服务的冗余)。 负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。 高可用基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的 基础，因此说主从复制是 Redis 高可用的基础。 实现原理 为了节省篇幅，我把主要的步骤都 浓缩 在了上图中，其实也可以 简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段。 更多细节 推荐阅读 之前的系列文章，不仅有原理讲解，还有实战环节： Redis(9)——史上最强【集群】入门实践教程 - https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/ 哨兵模式了解吗？ 上图 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点： 哨兵节点： 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据； 数据节点： 主节点和从节点都是数据节点； 在复制的基础上，哨兵实现了 自动化的故障恢复 功能，下方是官方对于哨兵功能的描述： 监控（Monitoring）： 哨兵会不断地检查主节点和从节点是否运作正常。 自动故障转移（Automatic failover）： 当 主节点 不能正常工作时，哨兵会开始 自动故障转移操作，它会将失效主节点的其中一个 从节点升级为新的主节点，并让其他从节点改为复制新的主节点。 配置提供者（Configuration provider）： 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。 通知（Notification）： 哨兵可以将故障转移的结果发送给客户端。 其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。 新的主服务器是怎样被挑选出来的？故障转移操作的第一步 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 slaveof no one 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？ 简单来说 Sentinel 使用以下规则来选择新的主服务器： 在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 淘汰。 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 淘汰。 在 经历了以上两轮淘汰之后 剩下来的从服务器中， 我们选出 复制偏移量（replication offset）最大 的那个 从服务器 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 带有最小运行 ID 的那个从服务器成为新的主服务器。 更多细节 推荐阅读 之前的系列文章，不仅有原理讲解，还有实战环节： Redis(9)——史上最强【集群】入门实践教程 - https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/ Redis 集群使用过吗？原理？ 上图 展示了 Redis Cluster 典型的架构图，集群中的每一个 Redis 节点都 互相两两相连，客户端任意 直连 到集群中的 任意一台，就可以对其他 Redis 节点进行 读写 的操作。 基本原理 Redis 集群中内置了 16384 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 集群的配置信息，当客户端具体对某一个 key 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量 大致均等 的将哈希槽映射到不同的节点。 再结合集群的配置信息就能够知道这个 key 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 MOVED 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据： GET x -MOVED 3999 127.0.0.1:6381 MOVED 指令第一个参数 3999 是 key 对应的槽位编号，后面是目标节点地址，MOVED 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 MOVED 指令后，就立即纠正本地的 槽位映射表，那么下一次再访问 key 时就能够到正确的地方去获取了。 集群的主要作用 数据分区： 数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面 每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，bgsave 和 bgrewriteaof 的 fork 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出…… 高可用： 集群支持主从复制和主节点的 自动故障转移 （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。 集群中数据如何分区？Redis 采用方案三。 方案一：哈希值 % 节点数哈希取余分区思路非常简单：计算 key 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。 不过该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要 重新计算映射关系，引发大规模数据迁移。 方案二：一致性哈希分区一致性哈希算法将 整个哈希值空间 组织成一个虚拟的圆环，范围是 *[0 - 232 - 1]*，对于每一个数据，根据 key 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器： 与哈希取余分区相比，一致性哈希分区将 增减节点的影响限制在相邻节点。以上图为例，如果在 node1 和 node2 之间增加 node5，则只有 node2 中的一部分数据会迁移到 node5；如果去掉 node2，则原 node2 中的数据只会迁移到 node4 中，只有 node4 会受影响。 一致性哈希分区的主要问题在于，当 节点数量较少 时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉 node2，node4 中的数据由总数据的 1/4 左右变为 1/2 左右，与其他节点相比负载过高。 方案三：带有虚拟节点的一致性哈希分区该方案在 一致性哈希分区的基础上，引入了 虚拟节点 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 槽（slot）。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。 在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽 解耦 了 数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 4 个实际节点，假设为其分配 16 个槽(0-15)； 槽 0-3 位于 node1；4-7 位于 node2；以此类推…. 如果此时删除 node2，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 node1，槽 6 分配给 node3，槽 7 分配给 node4；可以看出删除 node2 后，数据在其他节点的分布仍然较为均衡。 节点之间的通信机制了解吗？集群的建立离不开节点之间的通信，例如我们在 快速体验 中刚启动六个集群节点之后通过 redis-cli 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 CLUSTER MEET &lt;ip&gt; &lt;port&gt; 命令发送 MEET 消息完成的，下面我们展开详细说说。 两个端口在 哨兵系统 中，节点分为 数据节点 和 哨兵节点：前者存储数据，后者实现额外的控制功能。在 集群 中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个 TCP 端口： 普通端口： 即我们在前面指定的端口 (7000等)。普通端口主要用于为客户端提供服务 （与单机节点类似）；但在节点间数据迁移时也会使用。 集群端口： 端口号是普通端口 + 10000 （10000是固定值，无法改变），如 7000 节点的集群端口为 17000。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。 Gossip 协议节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。 广播是指向集群内所有节点发送消息。优点 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。 Gossip 协议的特点是：在节点数量有限的网络中，每个节点都 “随机” 的与部分节点通信 （并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *优点** 有负载 *(比广播) 低、去中心化、容错性高 (因为通信有冗余) 等；缺点 主要是集群的收敛速度慢。 消息类型集群中的节点采用 固定频率（每秒10次） 的 定时任务 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。 节点间发送的消息主要分为 5 种：meet 消息、ping 消息、pong 消息、fail 消息、publish 消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的： MEET 消息： 在节点握手阶段，当节点收到客户端的 CLUSTER MEET 命令时，会向新加入的节点发送 MEET 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 PONG 消息。 PING 消息： 集群里每个节点每秒钟会选择部分节点发送 PING 消息，接收者收到消息后会回复一个 PONG 消息。PING 消息的内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。PING 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 PONG 消息时间大于 cluster_node_timeout / 2 的所有节点，防止这些节点长时间未更新。 PONG消息： PONG 消息封装了自身状态数据。可以分为两种：第一种 是在接到 MEET/PING 消息后回复的 PONG 消息；第二种 是指节点向集群广播 PONG 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 PONG 消息。 FAIL 消息： 当一个主节点判断另一个主节点进入 FAIL 状态时，会向集群广播这一 FAIL 消息；接收节点会将这一 FAIL 消息保存起来，便于后续的判断。 PUBLISH 消息： 节点收到 PUBLISH 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 PUBLISH 命令。 集群数据如何存储的有了解吗？节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布…… 节点为了存储集群状态而提供的数据结构中，最关键的是 clusterNode 和 clusterState 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。 clusterNode 结构clusterNode 结构保存了 一个节点的当前状态，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 clusterNode 结构记录自己的状态，并为集群内所有其他节点都创建一个 clusterNode 结构来记录节点状态。 下面列举了 clusterNode 的部分字段，并说明了字段的含义和作用： typedef struct clusterNode { //节点创建时间 mstime_t ctime; //节点id char name[REDIS_CLUSTER_NAMELEN]; //节点的ip和端口号 char ip[REDIS_IP_STR_LEN]; int port; //节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等 int flags; //配置纪元：故障转移时起作用，类似于哨兵的配置纪元 uint64_t configEpoch; //槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中 unsigned char slots[16384/8]; //节点中槽的数量 int numslots; ………… } clusterNode; 除了上述字段，clusterNode 还包含节点连接、主从复制、故障发现和转移需要的信息等。 clusterState 结构clusterState 结构保存了在当前节点视角下，集群所处的状态。主要字段包括： typedef struct clusterState { //自身节点 clusterNode *myself; //配置纪元 uint64_t currentEpoch; //集群状态：在线还是下线 int state; //集群中至少包含一个槽的节点数量 int size; //哈希表，节点名称->clusterNode节点指针 dict *nodes; //槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL clusterNode *slots[16384]; ………… } clusterState; 除此之外，clusterState 还包括故障转移、槽迁移等需要的信息。 五、其他问题Redis 如何实现分布式锁？ 推荐阅读 之前的系列文章：Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ Redis 过期键的删除策略？简单描述先抛开 Redis 想一下几种可能的删除策略： 定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。 惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。 定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。 在上述的三种策略中定时删除和定期删除属于不同时间粒度的 主动删除，惰性删除属于 被动删除。 三种策略都有各自的优缺点 定时删除对内存使用率有优势，但是对 CPU 不友好； 惰性删除对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费； 定期删除是定时删除和惰性删除的折中。 Redis 中的实现Reids 采用的是 惰性删除和定时删除 的结合，一般来说可以借助最小堆来实现定时器，不过 Redis 的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，这样如果在此基础上实现定时删除，就意味着 O(N) 遍历获取最近需要删除的数据。 Redis 的淘汰策略有哪些？Redis 有六种淘汰策略 策略 描述 volatile-lru 从已设置过期时间的 KV 集中优先对最近最少使用(less recently used)的数据淘汰 volitile-ttl 从已设置过期时间的 KV 集中优先对剩余时间短(time to live)的数据淘汰 volitile-random 从已设置过期时间的 KV 集中随机选择数据淘汰 allkeys-lru 从所有 KV 集中优先对最近最少使用(less recently used)的数据淘汰 allKeys-random 从所有 KV 集中随机选择数据淘汰 noeviction 不淘汰策略，若超过最大内存，返回错误信息 4.0 版本后增加以下两种 volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰 allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key Redis常见性能问题和解决方案？ Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。 如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。 为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。 尽量避免在压力较大的主库上增加从库。 Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。 为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？使用 keys 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。 More..参考资料 3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了 - https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w 大厂面试！我和面试官之间关于Redis的一场对弈！ - https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g Redis面试题（2020最新版） - https://blog.csdn.net/ThinkWon/article/details/103522351 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"懂一点Python系列——快速入门","slug":"懂一点Python系列——快速入门","date":"2020-03-23T06:36:00.000Z","updated":"2020-12-09T05:14:11.168Z","comments":true,"path":"2020/03/23/dong-yi-dian-python-xi-lie-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2020/03/23/dong-yi-dian-python-xi-lie-kuai-su-ru-men/","excerpt":"","text":"本文面相有 一定编程基础 的朋友学习，所以略过了 环境安装、IDE 搭建 等一系列简单繁琐的事情。 一、Python 简介Python 英文原意为 “蟒蛇”，直到 1989 年荷兰人 Guido van Rossum （简称 Guido）发明了一种 面向对象 的 解释型 编程语言，并将其命名为 Python，才赋予了它表示一门编程语言的含义。 说到 Python 的诞生，极具戏剧色彩，据 Guido 的自述记载，Python 语言是他在圣诞节期间为了打发时间开发出来的，之所以会选择 Python 作为该编程语言的名字，是因为他是一个叫 Monty Python 戏剧团体的忠实粉丝。 解释型 vs 编译型作为电子元器件的 计算机，实际上 只能 识别某些 特定的二进制指令 (特殊的 01 组合)，但由于 人类阅读 这些 指令 非常难以阅读，加上使用这些指令编写程序的 耗时 太过于 冗长，所以，人们在此基础上再次制定了一套规范，采用特定的 人类可阅读 的代码编写，待到要执行时再 翻译 回特定二进制指令，这样就帮助了人们更加轻松地理解和阅读程序逻辑了。 这也就是所谓现在的 “高级编程语言” 了。 上述 翻译 这个过程 (其实相当复杂，涉及语法分析、语义分析、性能优化等等..) 其实也是由一个特定程序来执行的，那 什么时候将源代码翻译成二进制指令呢？，不同的编程语言有不同的规定： 编译型语言：必须 提前 将所有源代码 一次性 转换成二进制指令，生成一个可执行文件 (例如 Windows 下的 .exe) 比如：C 语言、C++、Golang、汇编等。使用的转换工具我们称为 编译器。 解释型语言：允许程序 一边执行一边转换，并且不会生成可执行程序，比如 Python、JavaScript、PHP 等。使用的转换工具我们称为 解释器。 Java 和 C# 是一种比较奇葩的存在，它们是 半编译半解释型 的语言，源码需要先转换成一种中间文件 (字节码文件)，然后再把中间文件拿到 虚拟机 中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率。 上图 就展示了两种不同类型语言的执行流程的不同，两种方式对比起来总结如下： 编译型语言一般不能跨平台：对于不同的 CPU 来说，它们的指令集是有差异的，这就导致了 可执行文件 (翻译后的指令) 不能跨平台，另外不同的系统之间的命令也会存在差异，例如 Linux 中睡眠是 sleep() 参数是毫秒，而 Windows 中是 Sleep() (首字母大写) 参数是秒，这就导致了 源代码也不能跨平台； 解释型语言可跨平台：这一切都归功于 解释器，它本身就是一个可执行文件，官方只要针对不同的平台开发不同的解释器，那么解释器就能够根据相同的语法解析出同样功能的指令； 编译型一般比解释型效率高：由于解释型是采取一边执行一边翻译的做法，所以会慢上一些，再加上我们强大的 编译器 会帮我们做许多代码优化的工作。 关于 PythonPython 属于典型的解释型语言，所以运行 Python 程序需要解释器的支持，只要你在不同的平台安装了不同的解释器，你的代码就可以随时运行，不用担心任何兼容性问题，真正的 “一次编写，到处运行”。 Python 几乎支持所有常见的平台，比如 Linux、Windows、Mac OS、Android、FreeBSD、Solaris、PocketPC 等，你所写的 Python 代码无需修改就能在这些平台上正确运行。也就是说，Python 的 可移植性 是很强的。 面向对象 vs 面向过程面向对象 和 面向过程 是我们使用计算机编程解决问题的两种不同方式的方案。 面向过程 可以说是一种 基于事件 or 过程 来描述的编码方式，譬如「把大象放进冰箱」就可以描述成那经典的三个步骤，「把牛放进冰箱」又是另一个相似的经典三步，只是这样单独的事件 or 过程多了之后，随着项目复杂度的增加，项目会变得非常难以维护。 软件危机最典型的例子莫过于 IBM 的 System/360 的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领 2000 多个程序员夜以继日的工作，共计花费了 5000 人一年的工作量，写出将近 100 万行的源码，总共投入 5 亿美元，是美国的 “曼哈顿” 原子弹计划投入的 1/4。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了史上最畅销的软件工程书籍。 引用自：http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110880 尽管 结构化的程序设计 (将一个大问题逐步划分成一个一个的小问题) 能够帮助我们解决一部分问题，但 面向过程 仍然有一些不符合人类惯有的思考方式，譬如说：我今天想去存钱，我不会说「请拿走我的银行卡和钱，然后在我卡上充值上相应的数目，最后把银行卡还给我谢谢」，而我只会说「存钱，谢谢」，因为人大部分时间都是基于 对象 (或者可以说角色) 来思考的。 对于 面向过程 最好的总结可能是：「程序 = 算法 + 数据结构」，而对于 面向对象 来说则可以更改为：「程序 = 对象 + 交互」。 Why Python？ 上面的 漫画 很好地说明了 Python 快速构建工具的能力，这也是 Why Python 的一大理由。下面根据惯例列举一些让我们足以选择 Python 的原因。 初学者友善 | 容易明白且功能强大Python 的设计足够简单和易于使用，这样使得初学者能够从中不断得获取到乐趣以继续 Python 之旅。 另外作为一种非常高级的语言，Python 读起来像英语，这减轻了编码初学者的许多语法学习压力。Python 为您处理了很多复杂性，因此它非常适合初学者，因为它使初学者可以专注于学习编程概念，而不必担心过多的细节。 Python 还一度被爆纳入高考，收编到小学课本。 非常灵活作为一种 动态类型 的语言，Python 确实非常灵活。这意味着没有关于如何构建特征的硬性规则，并且使用不同的方法来解决问题将具有更大的灵活性 （尽管 Python 哲学鼓励使用明显的方法来解决问题）。此外，Python 也更宽容错误，因此您仍然可以编译并运行程序，直到遇到问题为止。 越来越火爆Python 在诞生之初，因为其功能不好，运转功率低，不支持多核，根本没有并发性可言，在计算功能不那么好的年代，一直没有火爆起来，甚至很多人根本不知道有这门语言。 随着时代的发展，物理硬件功能不断提高，而软件的复杂性也不断增大，开发效率越来越被企业重视。因此就有了不一样的声音，在软件开发的初始阶段，性能并没有开发效率重要，没必然为了节省不到 1ms 的时间却让开发量增加好几倍，这样划不过来。也就是开发效率比机器效率更为重要，那么 Python 就逐渐得到越来越多开发者的亲睐了。 在 12-14 年，云计算升温，大量创业公司和互联网巨头挤进云计算领域，而最著名的云核算开源渠道 OpenStack 就是基于 Python 开发的。 随后几年的备受关注的人工智能，机器学习首选开发语言也是 Python。 至此，Python 已经成为互联网开发的焦点。在 「Top 10 的编程语言走势图」 可以看到，Python 已经跃居第三位，而且在 2017 年还成为了最受欢迎的语言。 工作机会 | 薪资待遇高 来自 gooroo.io 的薪资信息： 在天使榜上，Python 是需求第二高的技能，也是提供最高平均薪水的技能。 随着大数据的兴起，Python 开发人员需要作为数据科学家，尤其是因为 Python 可以轻松集成到 Web 应用程序中以执行需要机器学习的任务。 快速体验 | No Hello World !Hello World 似乎是学习编程绕不过去的东西，但使用 Python，我们来换点儿别的，Emmm.. 比如，一个 查询天气 的小程序 (效果如下图)： 源码 &amp; 解释http://wthrcdn.etouch.cn/weather_mini?city=xxx 这个网址可以返回任意城市昨日以及 5 天内的天气预报，包括气温、指数、空气质量、风力等，你可以用浏览器试着访问一下，你会得到一个 weather_mini 的文件，里面就包含了我们想要的一些数据。 不过这里由于我们发起了网络请求用到了第三方库 requests，所以在运行之前还需要使用 pip install requests 命令把该库下载到 Python 的安装目录下。 # -*- coding: utf-8 -*- import requests while True: city = input('请输入城市,回车退出:\\n') if not city: break req = requests.get('http://wthrcdn.etouch.cn/weather_mini?city=%s' % city) print(req.text) 运行你的代码你可以在 当前文件夹 下执行命令： python hello_python.py，或是使用 python &lt;源文件路径&gt; 运行也行，例如，如果我是 Windows 用户并且将上述源文件保存在了 D 盘下面，那就可以执行 python D:\\hello_python.py，然后你就可以看到上面的效果了。当然如果使用 IDE 将更加方便。 Python vs Java引入一张比较著名的图吧，可以很明显地感受到 Python 在写法上要简洁一些吧： 二、Python 基本语法简介Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。Python 最具特色的就是用 缩进 来写模块。 2.0 注释# 第一个注释 # 第二个注释 ''' 第三注释 第四注释 ''' \"\"\" 第五注释 第六注释 \"\"\" print(\"Hello, Python!\") 2.1 数据类型Python 中的变量赋值不需要类型声明。Python 有五个标准的数据类型： Numbers（数字）：Python3 中有四种数字类型 (没有 Python2 中的 Long)，分别是 int 长整型、bool 布尔、float 浮点数、complex 复数 (1 + 2j)； String（字符串）：Python 中字符串不能改变，并且没有单独的字符类型，一个字符就是长度为 1 的字符串； Tuple（元组）：类似于 List，但不能二次赋值，相当于只读列表。eg：(&#39;test1&#39;, &#39;test2&#39;) List（列表）：类似 Java 中的 Array 类型。eg:[1, 2, ,3] Dictionary（字典）：类似于 Java 的 Map 类型。eg:{a: 1, b: 2} set 集合也属于数据结构，它是一个 无序 且 不重复 的元素序列。可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 str = 'Hello World!' print str[2:5] # 输出字符串中第三个至第五个之间的字符串 list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] print list[1:3] # 输出第二个至第三个元素 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 ) print tuple[1:3] # 输出第二个至第三个的元素 tinydict = {'name': 'john','code':6734, 'dept': 'sales'} print tinydict['name'] # 输出键为 2 的值 2.2 条件语句# 当判断条件为 1 个值时 flag = False name = 'luren' if name == 'python': # 判断变量否为'python' flag = True # 条件成立时设置标志为真 print 'welcome boss' # 并输出欢迎信息 else: print name # 条件不成立时输出变量名称 # 当判断条件为多个值时 num = 5 if num == 3: # 判断num的值 print 'boss' elif num == 2: print 'user' else: print 'roadman' # 条件均不成立时输出 2.3 循环while 循环在 Python 中没有 do..while 的循环 count = 0 while count &lt; 5: print (count, \" 小于 5\") count = count + 1 else: print (count, \" 大于或等于 5\") for..in 循环for..in 适用于 list/ dict/ set 数据类型，如果需要遍历数字序列，我们也可以借助 range(min, max, step) 函数来生成数列。 sites = [\"Baidu\", \"Google\",\"Runoob\",\"Taobao\"] for site in sites: if site == \"Runoob\": print(\"菜鸟教程!\") break print(\"循环数据 \" + site) else: print(\"没有循环数据!\") print(\"完成循环!\") # 输出 0/ 3/ 6/ 9 for i in range(0, 10, 3) : print(i) # 替换成 range(5) 则输出 0/ 1/ 2/ 3/ 4 # 替换成 range(5,9) 则输出 5/ 6/ 7/ 8 2.4 函数函数基本定义和使用# 计算面积函数 def area(width, height): return width * height def print_welcome(name): print(\"Welcome\", name) print_welcome(\"Runoob\") w = 4 h = 5 print(\"width =\", w, \" height =\", h, \" area =\", area(w, h)) 参数传递在 Python 中，类型属于对象，变量是没有类型的，例如 name = &quot;wmyskxz&quot;，则 &quot;wmyskxz&quot; 是 String 类型，而变量 name 仅仅是一个对象的引用。 Python 中一切都是对象，严格意义我们 不能说值传递还是引用传递，我们应该说传 不可变对象 (string、tuples、number 不可变) 和 传可变对象 (list、dict 可变)。 ############################################ # 传递不可变对象 def ChangeInt(a): a = 10 b = 2 ChangeInt(b) print b # 结果是 2 ############################################ # 传递可变对象 def changeme( mylist ): \"修改传入的列表\" mylist.append([1,2,3,4]) print (\"函数内取值: \", mylist) # [10, 20, 30, [1, 2, 3, 4]] return # 调用changeme函数 mylist = [10,20,30] changeme( mylist ) print (\"函数外取值: \", mylist) # [10, 20, 30, [1, 2, 3, 4]] # 函数内外值一致，因为都同属于同一个引用 2.5 class 类基本定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) # 实例化类 p = people('wmyskxz', 24, 120) p.speak() # wmyskxz 说: 我 10 岁。 继承 &amp; 多继承 &amp; 方法重写# 单继承 class DerivedClassName(BaseClassName1): &lt;statement-1> . &lt;statement-N> # 多继承 class DerivedClassName(Base1, Base2, Base3): &lt;statement-1> . . . &lt;statement-N> # 方法重写演示 class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 # 先输出 \"调用子类方法\" 再输出 \"调用父类方法\" 2.6 module 模块一个 .py 文件就是一个模块，想要使用其他 .py 文件中的方法就需要引入进来。 import [module] # 导入整个random模块，可以是内置/当前路径 import random # 使用 `random` 模块下的 `randint` 方法 print(random.randint(0, 5)) from [module] import [name1, name2, ...] # 从 `random` 模块里导入其中一个方法 `randint` from random import randint # 不一样的是，使用 `randint` 的就不需要先写 `random` 了 print(randint(0, 5)) import [module] as [new_name] # 但这个名字可能跟其他地方有冲突，因此改名成 `rd` import random as rd # 使用 `rd` 这个名称取代原本的 `random` print(rd.randint(0, 5)) from [module] import * 不推荐，容易造成名称冲突，降低可读性和可维护性。 # Import 所有 `random` module 底下的东西 from random import * # 使用 `randint` 的时候也不需要先写 `random` print(randint(0, 5)) module 搜索路径当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 如果都找不到，Python 会察看默认路径。UNIX 下，默认路径一般为 /usr/local/lib/python/。 2.7 package 包把两个 module 放在一个新的目录 sample_package，再新增 _init__.py (可以是空，但不能没有)，宣称自己是一个 package : sample_package |-- __init__.py |-- 1.py |-- 2.py# package_runoob 同级目录下创建 test.py 来调用 package_runoob 包 # 导入包 from package_runoob.runoob1 import runoob1 from package_runoob.runoob2 import runoob2 runoob1() runoob2() 单个py文件就是一个 module，而当多个 .py 文件 + __init__.py 文件时，就等于 package。 三、基本代码规范代码规范 再怎么强调也不为过： 图片来源：https://codingpy.com/article/programmers-daily-what-idiot-wrote-this-crappy-code/ 3.1 命名规范模块 模块尽量使用 小写命名，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况) # 正确的模块名 import decoder import html_parser # 不推荐的模块名 import Decoder 类名 类名使用 驼峰 (CamelCase)命名风格，首字母大写，私有类可用一个下划线开头 class Farm(): pass class AnimalFarm(Farm): pass class _PrivateFarm(Farm): pass 函数 函数名 一律小写，如有多个单词，用下划线隔开 def run(): pass def run_with_env(): pass 私有函数在函数前加一个下划线 _ class Person(): def _private_func(): pass 变量名 变量名尽量 小写, 如有多个单词，用下划线隔开 if __name__ == '__main__': count = 0 school_name = '' 常量使用以下划线分隔的 大写 命名 MAX_CLIENT = 100 MAX_CONNECTION = 1000 CONNECTION_TIMEOUT = 600 3.2 基本编码规范缩进 统一使用 4 个空格进行缩进 行宽每行代码尽量不超过 80 个字符(在特殊情况下可以略微超过 80 ，但最长不得超过 120) 理由： 这在查看 side-by-side 的 diff 时很有帮助 方便在控制台下查看代码 太长可能是设计有缺陷 引号简单说，自然语言使用双引号，机器标示使用单引号，因此 代码里 多数应该使用 单引号 自然语言 使用双引号 &quot;...&quot;，例如错误信息；很多情况还是 unicode，使用u”你好世界” 机器标识 使用单引号 ‘...&#39;，例如 dict 里的 key 正则表达式 使用原生的双引号 r&quot;...&quot; 文档字符串 (docstring) 使用三个双引号 &quot;&quot;&quot;......&quot;&quot;&quot; import 语句 import 语句应该分行书写 # 正确的写法 import os import sys # 不推荐的写法 import sys,os # 正确的写法 from subprocess import Popen, PIPE import 语句应该使用 absolute import # 正确的写法 from foo.bar import Bar # 不推荐的写法 from ..bar import Bar import 语句应该放在文件头部，置于模块说明及 DocString 之后，于全局变量之前； import 语句应该按照顺序排列，每组之间用一个空行分隔 import os import sys import msgpack import zmq import foo 导入其他模块的类定义时，可以使用相对导入 from myclass import MyClass 如果发生命名冲突，则可使用命名空间 import bar import foo.bar bar.Bar() foo.bar.Bar() DocStringDocString 的规范中最其本的两点： 所有的公共模块、函数、类、方法，都应该写 DocString 。私有方法不一定需要，但应该在 def 后提供一个块注释来说明。 DocString 的结束”””应该独占一行，除非此 DocString 只有一行。 \"\"\"Return a foobar Optional plotz says to frobnicate the bizbaz first. \"\"\" \"\"\"Oneline docstring\"\"\" 3.3 注释规范建议 在代码的 关键部分(或比较复杂的地方), 能写注释的要尽量写注释 比较重要的注释段, 使用多个等号隔开, 可以更加醒目, 突出 重要性 app = create_app(name, options) # ===================================== # 请勿在此处添加 get post等app路由行为 !!! # ===================================== if __name__ == '__main__': app.run() 文档注释（DocString） 文档注释以 “”” 开头和结尾, 首行不换行, 如有多行, 末行必需换行, 以下是Google的docstring风格示例 # -*- coding: utf-8 -*- \"\"\"Example docstrings. This module demonstrates documentation as specified by the `Google Python Style Guide`_. Docstrings may extend over multiple lines. Sections are created with a section header and a colon followed by a block of indented text. Example: Examples can be given using either the ``Example`` or ``Examples`` sections. Sections support any reStructuredText formatting, including literal blocks:: $ python example_google.py Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts. \"\"\" 不要在文档注释复制函数定义原型, 而是具体描述其具体内容, 解释具体参数和返回值等 # 不推荐的写法(不要写函数原型等废话) def function(a, b): \"\"\"function(a, b) -> list\"\"\" ... ... # 正确的写法 def function(a, b): \"\"\"计算并返回a到b范围内数据的平均值\"\"\" ... ... 对函数参数、返回值等的说明采用 numpy 标准, 如下所示 def func(arg1, arg2): \"\"\"在这里写函数的一句话总结(如: 计算平均值). 这里是具体描述. 参数 ---------- arg1 : int arg1的具体描述 arg2 : int arg2的具体描述 返回值 ------- int 返回值的具体描述 参看 -------- otherfunc : 其它关联函数等... 示例 -------- 示例使用doctest格式, 在`>>>`后的代码可以被文档测试工具作为测试用例自动运行 >>> a=[1,2,3] >>> print [x + 3 for x in a] [4, 5, 6] \"\"\" 更多细致详细的规范可以参考： Google 开源项目指南 - https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/ 官方 PEP 8 代码规范 - https://www.python.org/dev/peps/pep-0008/ 推荐阅读 Redis(9)——史上最强【集群】入门实践教程 - https://juejin.im/post/5e7429a16fb9a07ccc460fe7 React入门学习 - https://juejin.im/post/5da5e9e8e51d4525292d2ed7 参考资料 WhyStudyPython.md | TwoWater - https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python0/WhyStudyPython.md C 语言中文网 | Python 系列教程 - http://c.biancheng.net/python/ Crossin的编程教室 - https://python666.cn/ 计算机和编程语言的发展历史 - https://blog.csdn.net/abc6368765/article/details/83990756 面向对象葵花宝典 - http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110879 RUNOOB | Python3 系列教程 - ttps://www.runoob.com/python3 Python 基础语法 | springleo’sblog - https://lq782655835.github.io/blogs/tools/python-grammar.html#_1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python","slug":"后端/Python","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Python/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Redis(9)——史上最强【集群】入门实践教程","slug":"Redis-9-——史上最强【集群】入门实践教程","date":"2020-03-17T09:40:00.000Z","updated":"2020-12-09T05:10:04.253Z","comments":true,"path":"2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/","link":"","permalink":"http://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/","excerpt":"","text":"一、Redis 集群概述Redis 主从复制到 目前 为止，我们所学习的 Redis 都是 单机版 的，这也就意味着一旦我们所依赖的 Redis 服务宕机了，我们的主流程也会受到一定的影响，这当然是我们不能够接受的。 所以一开始我们的想法是：搞一台备用机。这样我们就可以在一台服务器出现问题的时候切换动态地到另一台去： 幸运的是，两个节点数据的同步我们可以使用 Redis 的 主从同步 功能帮助到我们，这样一来，有个备份，心里就踏实多了。 Redis 哨兵后来因为某种神秘力量，Redis 老会在莫名其妙的时间点出问题 (比如半夜 2 点)，我总不能 24 小时时刻守在电脑旁边切换节点吧，于是另一个想法又开始了：给所有的节点找一个 “管家”，自动帮我监听照顾节点的状态并切换： 这大概就是 Redis 哨兵 (Sentinel) 的简单理解啦。什么？管家宕机了怎么办？相较于有大量请求的 Redis 服务来说，管家宕机的概率就要小得多啦.. 如果真的宕机了，我们也可以直接切换成当前可用的节点保证可用.. Redis 集群化好了，通过上面的一些解决方案我们对 Redis 的 稳定性 稍微有了一些底气了，但单台节点的计算能力始终有限，所谓人多力量大，如果我们把 多个节点组合 成 一个可用的工作节点，那就大大增加了 Redis 的 高可用、可扩展、分布式、容错 等特性： 二、主从复制 主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 主节点(master)，后者称为 从节点(slave)。且数据的复制是 单向 的，只能由主节点到从节点。Redis 主从复制支持 主从同步 和 从从同步 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。 主从复制主要的作用 数据冗余： 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是一种服务的冗余)。 负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。 高可用基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的 基础，因此说主从复制是 Redis 高可用的基础。 快速体验在 Redis 中，用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制另一个服务器，以下三种方式是 完全等效 的： 配置文件：在从服务器的配置文件中加入：slaveof &lt;masterip&gt; &lt;masterport&gt; 启动命令：redis-server 启动命令后加入 --slaveof &lt;masterip&gt; &lt;masterport&gt; 客户端命令：Redis 服务器启动后，直接通过客户端执行命令：slaveof &lt;masterip&gt; &lt;masterport&gt;，让该 Redis 实例成为从节点。 需要注意的是：主从复制的开启，完全是在从节点发起的，不需要我们在主节点做任何事情。 第一步：本地启动两个节点在正确安装好 Redis 之后，我们可以使用 redis-server --port &lt;port&gt; 的方式指定创建两个不同端口的 Redis 实例，例如，下方我分别创建了一个 6379 和 6380 的两个 Redis 实例： # 创建一个端口为 6379 的 Redis 实例 redis-server --port 6379 # 创建一个端口为 6380 的 Redis 实例 redis-server --port 6380 此时两个 Redis 节点启动后，都默认为 主节点。 第二步：建立复制我们在 6380 端口的节点中执行 slaveof 命令，使之变为从节点： # 在 6380 端口的 Redis 实例中使用控制台 redis-cli -p 6380 # 成为本地 6379 端口实例的从节点 127.0.0.1:6380> SLAVEOF 127.0.0.1ø 6379 OK 第三步：观察效果下面我们来验证一下，主节点的数据是否会复制到从节点之中： 先在 从节点 中查询一个 不存在 的 key：```bash 127.0.0.1:6380&gt; GET mykey(nil) - 再在 **主节点** 中添加这个 key： ```bash 127.0.0.1:6379&gt; SET mykey myvalue OK 此时再从 从节点 中查询，会发现已经从 主节点 同步到 从节点：```bash 127.0.0.1:6380&gt; GET mykey“myvalue” #### 第四步：断开复制 通过 `slaveof &lt;masterip&gt; &lt;masterport&gt;` 命令建立主从复制关系以后，可以通过 `slaveof no one` 断开。需要注意的是，从节点断开复制后，**不会删除已有的数据**，只是不再接受主节点新的数据变化。 从节点执行 `slaveof no one` 之后，从节点和主节点分别打印日志如下：、 ```bash # 从节点打印日志 61496:M 17 Mar 2020 08:10:22.749 # Connection with master lost. 61496:M 17 Mar 2020 08:10:22.749 * Caching the disconnected master state. 61496:M 17 Mar 2020 08:10:22.749 * Discarding previously cached master state. 61496:M 17 Mar 2020 08:10:22.749 * MASTER MODE enabled (user request from &#39;id=4 addr=127.0.0.1:55096 fd=8 name= age=1664 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof&#39;) # 主节点打印日志 61467:M 17 Mar 2020 08:10:22.749 # Connection with replica 127.0.0.1:6380 lost.实现原理简析 为了节省篇幅，我把主要的步骤都 浓缩 在了上图中，其实也可以 简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段。下面我们来进行一些必要的说明。 身份验证 | 主从复制安全问题在上面的 快速体验 过程中，你会发现 slaveof 这个命令居然不需要验证？这意味着只要知道了 ip 和端口就可以随意拷贝服务器上的数据了？ 那当然不能够了，我们可以通过在 主节点 配置 requirepass 来设置密码，这样就必须在 从节点 中对应配置好 masterauth 参数 (与主节点 requirepass 保持一致) 才能够进行正常复制了。 SYNC 命令是一个非常耗费资源的操作每次执行 SYNC 命令，主从服务器需要执行如下动作： 主服务器 需要执行 BGSAVE 命令来生成 RDB 文件，这个生成操作会 消耗 主服务器大量的 CPU、内存和磁盘 I/O 的资源； 主服务器 需要将自己生成的 RDB 文件 发送给从服务器，这个发送操作会 消耗 主服务器 大量的网络资源 (带宽和流量)，并对主服务器响应命令请求的时间产生影响； 接收到 RDB 文件的 从服务器 需要载入主服务器发来的 RBD 文件，并且在载入期间，从服务器 会因为阻塞而没办法处理命令请求； 特别是当出现 断线重复制 的情况是时，为了让从服务器补足断线时确实的那一小部分数据，却要执行一次如此耗资源的 SYNC 命令，显然是不合理的。 PSYNC 命令的引入所以在 Redis 2.8 中引入了 PSYNC 命令来代替 SYNC，它具有两种模式： 全量复制： 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作； 部分复制： 用于网络中断等情况后的复制，只将 中断期间主节点执行的写命令 发送给从节点，与全量复制相比更加高效。需要注意 的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制； 部分复制的原理主要是靠主从节点分别维护一个 复制偏移量，有了这个偏移量之后断线重连之后一比较，之后就可以仅仅把从服务器断线之后确实的这部分数据给补回来了。 更多的详细内容可以参考下方 参考资料 3 三、Redis Sentinel 哨兵 上图 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点： 哨兵节点： 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据； 数据节点： 主节点和从节点都是数据节点； 在复制的基础上，哨兵实现了 自动化的故障恢复 功能，下方是官方对于哨兵功能的描述： 监控（Monitoring）： 哨兵会不断地检查主节点和从节点是否运作正常。 自动故障转移（Automatic failover）： 当 主节点 不能正常工作时，哨兵会开始 自动故障转移操作，它会将失效主节点的其中一个 从节点升级为新的主节点，并让其他从节点改为复制新的主节点。 配置提供者（Configuration provider）： 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。 通知（Notification）： 哨兵可以将故障转移的结果发送给客户端。 其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。 快速体验第一步：创建主从节点配置文件并启动正确安装好 Redis 之后，我们去到 Redis 的安装目录 (mac 默认在 /usr/local/)*，找到 redis.conf 文件复制三份分别命名为 redis-master.conf/redis-slave1.conf/redis-slave2.conf，分别作为 1 个主节点和 2 个从节点的配置文件 *(下图演示了我本机的 redis.conf 文件的位置) 打开可以看到这个 .conf 后缀的文件里面有很多说明的内容，全部删除然后分别改成下面的样子： #redis-master.conf port 6379 daemonize yes logfile \"6379.log\" dbfilename \"dump-6379.rdb\" #redis-slave1.conf port 6380 daemonize yes logfile \"6380.log\" dbfilename \"dump-6380.rdb\" slaveof 127.0.0.1 6379 #redis-slave2.conf port 6381 daemonize yes logfile \"6381.log\" dbfilename \"dump-6381.rdb\" slaveof 127.0.0.1 6379 然后我们可以执行 redis-server &lt;config file path&gt; 来根据配置文件启动不同的 Redis 实例，依次启动主从节点： redis-server /usr/local/redis-5.0.3/redis-master.conf redis-server /usr/local/redis-5.0.3/redis-slave1.conf redis-server /usr/local/redis-5.0.3/redis-slave2.conf 节点启动后，我们执行 redis-cli 默认连接到我们端口为 6379 的主节点执行 info Replication 检查一下主从状态是否正常：(可以看到下方正确地显示了两个从节点) 第二步：创建哨兵节点配置文件并启动按照上面同样的方法，我们给哨兵节点也创建三个配置文件。(哨兵节点本质上是特殊的 Redis 节点，所以配置几乎没什么差别，只是在端口上做区分就好) # redis-sentinel-1.conf port 26379 daemonize yes logfile \"26379.log\" sentinel monitor mymaster 127.0.0.1 6379 2 # redis-sentinel-2.conf port 26380 daemonize yes logfile \"26380.log\" sentinel monitor mymaster 127.0.0.1 6379 2 # redis-sentinel-3.conf port 26381 daemonize yes logfile \"26381.log\" sentinel monitor mymaster 127.0.0.1 6379 2 其中，sentinel monitor mymaster 127.0.0.1 6379 2 配置的含义是：该哨兵节点监控 127.0.0.1:6379 这个主节点，该主节点的名称是 mymaster，最后的 2 的含义与主节点的故障判定有关：至少需要 2 个哨兵节点同意，才能判定主节点故障并进行故障转移。 执行下方命令将哨兵节点启动起来： redis-server /usr/local/redis-5.0.3/redis-sentinel-1.conf --sentinel redis-server /usr/local/redis-5.0.3/redis-sentinel-2.conf --sentinel redis-server /usr/local/redis-5.0.3/redis-sentinel-3.conf --sentinel 使用 redis-cil 工具连接哨兵节点，并执行 info Sentinel 命令来查看是否已经在监视主节点了： # 连接端口为 26379 的 Redis 节点 ➜ ~ redis-cli -p 26379 127.0.0.1:26379> info Sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3 此时你打开刚才写好的哨兵配置文件，你还会发现出现了一些变化： 第三步：演示故障转移首先，我们使用 kill -9 命令来杀掉主节点，同时 在哨兵节点中执行 info Sentinel 命令来观察故障节点的过程： ➜ ~ ps aux | grep 6379 longtao 74529 0.3 0.0 4346936 2132 ?? Ss 10:30上午 0:03.09 redis-server *:26379 [sentinel] longtao 73541 0.2 0.0 4348072 2292 ?? Ss 10:18上午 0:04.79 redis-server *:6379 longtao 75521 0.0 0.0 4286728 728 s008 S+ 10:39上午 0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn 6379 longtao 74836 0.0 0.0 4289844 944 s006 S+ 10:32上午 0:00.01 redis-cli -p 26379 ➜ ~ kill -9 73541 如果 刚杀掉瞬间 在哨兵节点中执行 info 命令来查看，会发现主节点还没有切换过来，因为哨兵发现主节点故障并转移需要一段时间： # 第一时间查看哨兵节点发现并未转移，还在 6379 端口 127.0.0.1:26379> info Sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3 一段时间之后你再执行 info 命令，查看，你就会发现主节点已经切换成了 6381 端口的从节点： # 过一段时间之后在执行，发现已经切换了 6381 端口 127.0.0.1:26379> info Sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=mymaster,status=ok,address=127.0.0.1:6381,slaves=2,sentinels=3 但同时还可以发现，哨兵节点认为新的主节点仍然有两个从节点 (上方 slaves=2)，这是因为哨兵在将 6381 切换成主节点的同时，将 6379 节点置为其从节点。虽然 6379 从节点已经挂掉，但是由于 哨兵并不会对从节点进行客观下线，因此认为该从节点一直存在。当 6379 节点重新启动后，会自动变成 6381 节点的从节点。 另外，在故障转移的阶段，哨兵和主从节点的配置文件都会被改写： 对于主从节点： 主要是 slaveof 配置的变化，新的主节点没有了 slaveof 配置，其从节点则 slaveof 新的主节点。 对于哨兵节点： 除了主从节点信息的变化，纪元(epoch) (记录当前集群状态的参数) 也会变化，纪元相关的参数都 +1 了。 客户端访问哨兵系统代码演示上面我们在 快速体验 中主要感受到了服务端自己对于当前主从节点的自动化治理，下面我们以 Java 代码为例，来演示一下客户端如何访问我们的哨兵系统： public static void testSentinel() throws Exception { String masterName = \"mymaster\"; Set&lt;String> sentinels = new HashSet&lt;>(); sentinels.add(\"127.0.0.1:26379\"); sentinels.add(\"127.0.0.1:26380\"); sentinels.add(\"127.0.0.1:26381\"); // 初始化过程做了很多工作 JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels); Jedis jedis = pool.getResource(); jedis.set(\"key1\", \"value1\"); pool.close(); } 客户端原理Jedis 客户端对哨兵提供了很好的支持。如上述代码所示，我们只需要向 Jedis 提供哨兵节点集合和 masterName ，构造 JedisSentinelPool 对象，然后便可以像使用普通 Redis 连接池一样来使用了：通过 pool.getResource() 获取连接，执行具体的命令。 在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点；代码中对故障转移没有任何体现，就可以在哨兵完成故障转移后自动的切换主节点。之所以可以做到这一点，是因为在 JedisSentinelPool 的构造器中，进行了相关的工作；主要包括以下两点： 遍历哨兵节点，获取主节点信息： 遍历哨兵节点，通过其中一个哨兵节点 + masterName 获得主节点的信息；该功能是通过调用哨兵节点的 sentinel get-master-addr-by-name 命令实现； 增加对哨兵的监听： 这样当发生故障转移时，客户端便可以收到哨兵的通知，从而完成主节点的切换。具体做法是：利用 Redis 提供的 发布订阅 功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的 + switch-master 频道，当收到消息时，重新初始化连接池。 新的主服务器是怎样被挑选出来的？故障转移操作的第一步 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 slaveof no one 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？ 简单来说 Sentinel 使用以下规则来选择新的主服务器： 在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 淘汰。 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 淘汰。 在 经历了以上两轮淘汰之后 剩下来的从服务器中， 我们选出 复制偏移量（replication offset）最大 的那个 从服务器 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 带有最小运行 ID 的那个从服务器成为新的主服务器。 四、Redis 集群 上图 展示了 Redis Cluster 典型的架构图，集群中的每一个 Redis 节点都 互相两两相连，客户端任意 直连 到集群中的 任意一台，就可以对其他 Redis 节点进行 读写 的操作。 基本原理 Redis 集群中内置了 16384 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 集群的配置信息，当客户端具体对某一个 key 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量 大致均等 的将哈希槽映射到不同的节点。 再结合集群的配置信息就能够知道这个 key 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 MOVED 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据： GET x -MOVED 3999 127.0.0.1:6381 MOVED 指令第一个参数 3999 是 key 对应的槽位编号，后面是目标节点地址，MOVED 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 MOVED 指令后，就立即纠正本地的 槽位映射表，那么下一次再访问 key 时就能够到正确的地方去获取了。 集群的主要作用 数据分区： 数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面 每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，bgsave 和 bgrewriteaof 的 fork 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出…… 高可用： 集群支持主从复制和主节点的 自动故障转移 （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。 快速体验第一步：创建集群节点配置文件首先我们找一个地方创建一个名为 redis-cluster 的目录： mkdir -p ~/Desktop/redis-cluster 然后按照上面的方法，创建六个配置文件，分别命名为：redis_7000.conf/redis_7001.conf…..redis_7005.conf，然后根据不同的端口号修改对应的端口值就好了： # 后台执行 daemonize yes # 端口号 port 7000 # 为每一个集群节点指定一个 pid_file pidfile ~/Desktop/redis-cluster/redis_7000.pid # 启动集群模式 cluster-enabled yes # 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通 cluster-config-file nodes-7000.conf # 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败 cluster-node-timeout 5000 # 最后将 appendonly 改成 yes(AOF 持久化) appendonly yes 记得把对应上述配置文件中根端口对应的配置都修改掉 (port/ pidfile/ cluster-config-file)。 第二步：分别启动 6 个 Redis 实例redis-server ~/Desktop/redis-cluster/redis_7000.conf redis-server ~/Desktop/redis-cluster/redis_7001.conf redis-server ~/Desktop/redis-cluster/redis_7002.conf redis-server ~/Desktop/redis-cluster/redis_7003.conf redis-server ~/Desktop/redis-cluster/redis_7004.conf redis-server ~/Desktop/redis-cluster/redis_7005.conf 然后执行 ps -ef | grep redis 查看是否启动成功： 可以看到 6 个 Redis 节点都以集群的方式成功启动了，但是现在每个节点还处于独立的状态，也就是说它们每一个都各自成了一个集群，还没有互相联系起来，我们需要手动地把他们之间建立起联系。 第三步：建立集群执行下列命令： redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 这里稍微解释一下这个 --replicas 1 的意思是：我们希望为集群中的每个主节点创建一个从节点。 观察控制台输出： 看到 [OK] 的信息之后，就表示集群已经搭建成功了，可以看到，这里我们正确地创建了三主三从的集群。 第四步：验证集群我们先使用 redic-cli 任意连接一个节点： redis-cli -c -h 127.0.0.1 -p 7000 127.0.0.1:7000> -c表示集群模式；-h 指定 ip 地址；-p 指定端口。 然后随便 set 一些值观察控制台输入： 127.0.0.1:7000> SET name wmyskxz -> Redirected to slot [5798] located at 127.0.0.1:7001 OK 127.0.0.1:7001> 可以看到这里 Redis 自动帮我们进行了 Redirected 操作跳转到了 7001 这个实例上。 我们再使用 cluster info (查看集群信息) 和 cluster nodes (查看节点列表) 来分别看看：(任意节点输入均可) 127.0.0.1:7001> CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:2 cluster_stats_messages_ping_sent:1365 cluster_stats_messages_pong_sent:1358 cluster_stats_messages_meet_sent:4 cluster_stats_messages_sent:2727 cluster_stats_messages_ping_received:1357 cluster_stats_messages_pong_received:1369 cluster_stats_messages_meet_received:1 cluster_stats_messages_received:2727 127.0.0.1:7001> CLUSTER NODES 56a04742f36c6e84968cae871cd438935081e86f 127.0.0.1:7003@17003 slave 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 0 1584428884000 4 connected 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 127.0.0.1:7000@17000 master - 0 1584428884000 1 connected 0-5460 e2539c4398b8258d3f9ffa714bd778da107cb2cd 127.0.0.1:7005@17005 slave a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 0 1584428885222 6 connected d31cd1f423ab1e1849cac01ae927e4b6950f55d9 127.0.0.1:7004@17004 slave 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 0 1584428884209 5 connected 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 127.0.0.1:7001@17001 myself,master - 0 1584428882000 2 connected 5461-10922 a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 127.0.0.1:7002@17002 master - 0 1584428884000 3 connected 10923-16383 127.0.0.1:7001> 数据分区方案简析方案一：哈希值 % 节点数哈希取余分区思路非常简单：计算 key 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。 不过该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要 重新计算映射关系，引发大规模数据迁移。 方案二：一致性哈希分区一致性哈希算法将 整个哈希值空间 组织成一个虚拟的圆环，范围是 *[0 - 232 - 1]*，对于每一个数据，根据 key 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器： 与哈希取余分区相比，一致性哈希分区将 增减节点的影响限制在相邻节点。以上图为例，如果在 node1 和 node2 之间增加 node5，则只有 node2 中的一部分数据会迁移到 node5；如果去掉 node2，则原 node2 中的数据只会迁移到 node4 中，只有 node4 会受影响。 一致性哈希分区的主要问题在于，当 节点数量较少 时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉 node2，node4 中的数据由总数据的 1/4 左右变为 1/2 左右，与其他节点相比负载过高。 方案三：带有虚拟节点的一致性哈希分区该方案在 一致性哈希分区的基础上，引入了 虚拟节点 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 槽（slot）。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。 在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽 解耦 了 数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 4 个实际节点，假设为其分配 16 个槽(0-15)； 槽 0-3 位于 node1；4-7 位于 node2；以此类推…. 如果此时删除 node2，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 node1，槽 6 分配给 node3，槽 7 分配给 node4；可以看出删除 node2 后，数据在其他节点的分布仍然较为均衡。 节点通信机制简析集群的建立离不开节点之间的通信，例如我们上访在 快速体验 中刚启动六个集群节点之后通过 redis-cli 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 CLUSTER MEET &lt;ip&gt; &lt;port&gt; 命令发送 MEET 消息完成的，下面我们展开详细说说。 两个端口在 哨兵系统 中，节点分为 数据节点 和 哨兵节点：前者存储数据，后者实现额外的控制功能。在 集群 中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个 TCP 端口： 普通端口： 即我们在前面指定的端口 (7000等)。普通端口主要用于为客户端提供服务 （与单机节点类似）；但在节点间数据迁移时也会使用。 集群端口： 端口号是普通端口 + 10000 （10000是固定值，无法改变），如 7000 节点的集群端口为 17000。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。 Gossip 协议节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。 广播是指向集群内所有节点发送消息。优点 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。 Gossip 协议的特点是：在节点数量有限的网络中，每个节点都 “随机” 的与部分节点通信 （并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *优点** 有负载 *(比广播) 低、去中心化、容错性高 (因为通信有冗余) 等；缺点 主要是集群的收敛速度慢。 消息类型集群中的节点采用 固定频率（每秒10次） 的 定时任务 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。 节点间发送的消息主要分为 5 种：meet 消息、ping 消息、pong 消息、fail 消息、publish 消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的： MEET 消息： 在节点握手阶段，当节点收到客户端的 CLUSTER MEET 命令时，会向新加入的节点发送 MEET 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 PONG 消息。 PING 消息： 集群里每个节点每秒钟会选择部分节点发送 PING 消息，接收者收到消息后会回复一个 PONG 消息。PING 消息的内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。PING 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 PONG 消息时间大于 cluster_node_timeout / 2 的所有节点，防止这些节点长时间未更新。 PONG消息： PONG 消息封装了自身状态数据。可以分为两种：第一种 是在接到 MEET/PING 消息后回复的 PONG 消息；第二种 是指节点向集群广播 PONG 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 PONG 消息。 FAIL 消息： 当一个主节点判断另一个主节点进入 FAIL 状态时，会向集群广播这一 FAIL 消息；接收节点会将这一 FAIL 消息保存起来，便于后续的判断。 PUBLISH 消息： 节点收到 PUBLISH 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 PUBLISH 命令。 数据结构简析节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布…… 节点为了存储集群状态而提供的数据结构中，最关键的是 clusterNode 和 clusterState 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。 clusterNode 结构clusterNode 结构保存了 一个节点的当前状态，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 clusterNode 结构记录自己的状态，并为集群内所有其他节点都创建一个 clusterNode 结构来记录节点状态。 下面列举了 clusterNode 的部分字段，并说明了字段的含义和作用： typedef struct clusterNode { //节点创建时间 mstime_t ctime; //节点id char name[REDIS_CLUSTER_NAMELEN]; //节点的ip和端口号 char ip[REDIS_IP_STR_LEN]; int port; //节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等 int flags; //配置纪元：故障转移时起作用，类似于哨兵的配置纪元 uint64_t configEpoch; //槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中 unsigned char slots[16384/8]; //节点中槽的数量 int numslots; ………… } clusterNode; 除了上述字段，clusterNode 还包含节点连接、主从复制、故障发现和转移需要的信息等。 clusterState 结构clusterState 结构保存了在当前节点视角下，集群所处的状态。主要字段包括： typedef struct clusterState { //自身节点 clusterNode *myself; //配置纪元 uint64_t currentEpoch; //集群状态：在线还是下线 int state; //集群中至少包含一个槽的节点数量 int size; //哈希表，节点名称->clusterNode节点指针 dict *nodes; //槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL clusterNode *slots[16384]; ………… } clusterState; 除此之外，clusterState 还包括故障转移、槽迁移等需要的信息。 更多关于集群内容请自行阅读《Redis 设计与实现》，其中有更多细节方面的介绍 - http://redisbook.com/ 相关阅读 Redis(1)——5种基本数据结构 - https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/ Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ Reids(4)——神奇的HyperLoglog解决统计问题 - https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/ Redis(5)——亿级数据过滤和布隆过滤器 - https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/ Redis(6)——GeoHash查找附近的人https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/ Redis(7)——持久化【一文了解】 - https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/ Redis(8)——发布/订阅与Stream - https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/ 参考资料 《Redis 设计与实现》 | 黄健宏 著 - http://redisbook.com/ 《Redis 深度历险》 | 钱文品 著 - https://book.douban.com/subject/30386804/ 深入学习Redis（3）：主从复制 - https://www.cnblogs.com/kismetv/p/9236731.html Redis 主从复制 原理与用法 - https://blog.csdn.net/Stubborn_Cow/article/details/50442950 深入学习Redis（4）：哨兵 - https://www.cnblogs.com/kismetv/p/9609938.html Redis 5 之后版本的高可用集群搭建 - https://www.jianshu.com/p/8045b92fafb2 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(8)——发布/订阅与Stream","slug":"Redis-8-——发布-订阅与Stream","date":"2020-03-15T10:07:00.000Z","updated":"2020-12-09T05:10:00.876Z","comments":true,"path":"2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/","link":"","permalink":"http://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/","excerpt":"","text":"一、Redis 中的发布/订阅功能发布/ 订阅系统 是 Web 系统中比较常用的一个功能。简单点说就是 发布者发布消息，订阅者接受消息，这有点类似于我们的报纸/ 杂志社之类的： (借用前边的一张图) 图片引用自：「消息队列」看过来! - https://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/ 从我们 前面(下方相关阅读) 学习的知识来看，我们虽然可以使用一个 list 列表结构结合 lpush 和 rpop 来实现消息队列的功能，但是似乎很难实现实现 消息多播 的功能： 为了支持消息多播，Redis 不能再依赖于那 5 种基础的数据结构了，它单独使用了一个模块来支持消息多播，这个模块就是 PubSub，也就是 PublisherSubscriber (发布者/ 订阅者模式)。 PubSub 简介我们从 上面的图 中可以看到，基于 list 结构的消息队列，是一种 Publisher 与 Consumer 点对点的强关联关系，Redis 为了消除这样的强关联，引入了另一种概念：频道 (channel)： 当 Publisher 往 channel 中发布消息时，关注了指定 channel 的 Consumer 就能够同时受到消息。但这里的 问题 是，消费者订阅一个频道是必须 明确指定频道名称 的，这意味着，如果我们想要 订阅多个 频道，那么就必须 显式地关注多个 名称。 为了简化订阅的繁琐操作，Redis 提供了 模式订阅 的功能 Pattern Subscribe，这样就可以 一次性关注多个频道 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息： 例如上图中，所有 位于图片下方的 Consumer 都能够受到消息。 Publisher 往 wmyskxz.chat 这个 channel 中发送了一条消息，不仅仅关注了这个频道的 Consumer 1 和 Consumer 2 能够受到消息，图片中的两个 channel 都和模式 wmyskxz.* 匹配，所以 Redis 此时会同样发送消息给订阅了 wmyskxz.* 这个模式的 Consumer 3 和关注了在这个模式下的另一个频道 wmyskxz.log 下的 Consumer 4 和 Consumer 5。 另一方面，如果接收消息的频道是 wmyskxz.chat，那么 Consumer 3 也会受到消息。 快速体验在 Redis 中，PubSub 模块的使用非常简单，常用的命令也就下面这么几条： # 订阅频道： SUBSCRIBE channel [channel ....] # 订阅给定的一个或多个频道的信息 PSUBSCRIBE pattern [pattern ....] # 订阅一个或多个符合给定模式的频道 # 发布频道： PUBLISH channel message # 将消息发送到指定的频道 # 退订频道： UNSUBSCRIBE [channel [channel ....]] # 退订指定的频道 PUNSUBSCRIBE [pattern [pattern ....]] #退订所有给定模式的频道 我们可以在本地快速地来体验一下 PubSub： 具体步骤如下： 开启本地 Redis 服务，新建两个控制台窗口； 在其中一个窗口输入 SUBSCRIBE wmyskxz.chat 关注 wmyskxz.chat 频道，让这个窗口成为 消费者。 在另一个窗口输入 PUBLISH wmyskxz.chat &#39;message&#39; 往这个频道发送消息，这个时候就会看到 另一个窗口实时地出现 了发送的测试消息。 实现原理可以看到，我们通过很简单的两条命令，几乎就可以简单使用这样的一个 发布/ 订阅系统 了，但是具体是怎么样实现的呢？ 每个 Redis 服务器进程维持着一个标识服务器状态 的 redis.h/redisServer 结构，其中就 保存着有订阅的频道 以及 订阅模式 的信息： struct redisServer { // ... dict *pubsub_channels; // 订阅频道 list *pubsub_patterns; // 订阅模式 // ... }; 订阅频道原理当客户端订阅某一个频道之后，Redis 就会往 pubsub_channels 这个字典中新添加一条数据，实际上这个 dict 字典维护的是一张链表，比如，下图展示的 pubsub_channels 示例中，client 1、client 2 就订阅了 channel 1，而其他频道也分别被其他客户端订阅： SUBSCRIBE 命令SUBSCRIBE 命令的行为可以用下列的伪代码表示： def SUBSCRIBE(client, channels): # 遍历所有输入频道 for channel in channels: # 将客户端添加到链表的末尾 redisServer.pubsub_channels[channel].append(client) 通过 pubsub_channels 字典，程序只要检查某个频道是否为字典的键，就可以知道该频道是否正在被客户端订阅；只要取出某个键的值，就可以得到所有订阅该频道的客户端的信息。 PUBLISH 命令了解 SUBSCRIBE，那么 PUBLISH 命令的实现也变得十分简单了，只需要通过上述字典定位到具体的客户端，再把消息发送给它们就好了：(伪代码实现如下) def PUBLISH(channel, message): # 遍历所有订阅频道 channel 的客户端 for client in server.pubsub_channels[channel]: # 将信息发送给它们 send_message(client, message) UNSUBSCRIBE 命令使用 UNSUBSCRIBE 命令可以退订指定的频道，这个命令执行的是订阅的反操作：它从 pubsub_channels 字典的给定频道（键）中，删除关于当前客户端的信息，这样被退订频道的信息就不会再发送给这个客户端。 订阅模式原理 正如我们上面说到了，当发送一条消息到 wmyskxz.chat 这个频道时，Redis 不仅仅会发送到当前的频道，还会发送到匹配于当前模式的所有频道，实际上，pubsub_patterns 背后还维护了一个 redis.h/pubsubPattern 结构： typedef struct pubsubPattern { redisClient *client; // 订阅模式的客户端 robj *pattern; // 订阅的模式 } pubsubPattern; 每当调用 PSUBSCRIBE 命令订阅一个模式时，程序就创建一个包含客户端信息和被订阅模式的 pubsubPattern 结构，并将该结构添加到 redisServer.pubsub_patterns 链表中。 我们来看一个 pusub_patterns 链表的示例： 这个时候客户端 client 3 执行 PSUBSCRIBE wmyskxz.java.*，那么 pubsub_patterns 链表就会被更新成这样： 通过遍历整个 pubsub_patterns 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。 PUBLISH 命令上面给出的伪代码并没有 完整描述 PUBLISH 命令的行为，因为 PUBLISH 除了将 message 发送到 所有订阅 channel 的客户端 之外，它还会将 channel 和 pubsub_patterns 中的 模式 进行对比，如果 channel 和某个模式匹配的话，那么也将 message 发送到 订阅那个模式的客户端。 完整描述 PUBLISH 功能的伪代码定于如下： def PUBLISH(channel, message): # 遍历所有订阅频道 channel 的客户端 for client in server.pubsub_channels[channel]: # 将信息发送给它们 send_message(client, message) # 取出所有模式，以及订阅模式的客户端 for pattern, client in server.pubsub_patterns: # 如果 channel 和模式匹配 if match(channel, pattern): # 那么也将信息发给订阅这个模式的客户端 send_message(client, message) PUNSUBSCRIBE 命令使用 PUNSUBSCRIBE 命令可以退订指定的模式，这个命令执行的是订阅模式的反操作：序会删除 redisServer.pubsub_patterns 链表中，所有和被退订模式相关联的 pubsubPattern 结构，这样客户端就不会再收到和模式相匹配的频道发来的信息。 PubSub 的缺点尽管 Redis 实现了 PubSub 模式来达到了 多播消息队列 的目的，但在实际的消息队列的领域，几乎 找不到特别合适的场景，因为它的缺点十分明显： 没有 Ack 机制，也不保证数据的连续： PubSub 的生产者传递过来一个消息，Redis 会直接找到相应的消费者传递过去。如果没有一个消费者，那么消息会被直接丢弃。如果开始有三个消费者，其中一个突然挂掉了，过了一会儿等它再重连时，那么重连期间的消息对于这个消费者来说就彻底丢失了。 不持久化消息： 如果 Redis 停机重启，PubSub 的消息是不会持久化的，毕竟 Redis 宕机就相当于一个消费者都没有，所有的消息都会被直接丢弃。 基于上述缺点，Redis 的作者甚至单独开启了一个 Disque 的项目来专门用来做多播消息队列，不过该项目目前好像都没有成熟。不过后来在 2018 年 6 月，Redis 5.0 新增了 Stream 数据结构，这个功能给 Redis 带来了 持久化消息队列，从此 PubSub 作为消息队列的功能可以说是就消失了.. 二、更为强大的 Stream | 持久化的发布/订阅系统Redis Stream 从概念上来说，就像是一个 仅追加内容 的 消息链表，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：消费者组(Consumer Group) (思路一致，实现不同)： 上图就展示了一个典型的 Stream 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。我们对图中的一些概念做一下解释： Consumer Group：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 XREAD 命令进行 独立消费，也可以多个消费者同时加入一个消费者组进行 组内消费。同一个消费者组内的消费者共享所有的 Stream 信息，同一条消息只会有一个消费者消费到，这样就可以应用在分布式的应用场景中来保证消息的唯一性。 last_delivered_id：用来表示消费者组消费在 Stream 上 消费位置 的游标信息。每个消费者组都有一个 Stream 内 唯一的名称，消费者组不会自动创建，需要使用 XGROUP CREATE 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 last_delivered_id 这个变量。 pending_ids：每个消费者内部都有的一个状态变量，用来表示 已经 被客户端 获取，但是 还没有 ack 的消息。记录的目的是为了 保证客户端至少消费了消息一次，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 PEL (Pending Entries List)。 消息 ID 和消息内容消息 ID消息 ID 如果是由 XADD 命令返回自动创建的话，那么它的格式会像这样：timestampInMillis-sequence (毫秒时间戳-序列号)，例如 1527846880585-5，它表示当前的消息是在毫秒时间戳 1527846880585 时产生的，并且是该毫秒内产生的第 5 条消息。 这些 ID 的格式看起来有一些奇怪，为什么要使用时间来当做 ID 的一部分呢？ 一方面，我们要 满足 ID 自增 的属性，另一方面，也是为了 支持范围查找 的功能。由于 ID 和生成消息的时间有关，这样就使得在根据时间范围内查找时基本上是没有额外损耗的。 当然消息 ID 也可以由客户端自定义，但是形式必须是 “整数-整数”，而且后面加入的消息的 ID 必须要大于前面的消息 ID。 消息内容消息内容就是普通的键值对，形如 hash 结构的键值对。 增删改查示例增删改查命令很简单，详情如下： xadd：追加消息 xdel：删除消息，这里的删除仅仅是设置了标志位，不影响消息总长度 xrange：获取消息列表，会自动过滤已经删除的消息 xlen：消息长度 del：删除Stream 使用示例： # *号表示服务器自动生成ID，后面顺序跟着一堆key/value 127.0.0.1:6379> xadd codehole * name laoqian age 30 # 名字叫laoqian，年龄30岁 1527849609889-0 # 生成的消息ID 127.0.0.1:6379> xadd codehole * name xiaoyu age 29 1527849629172-0 127.0.0.1:6379> xadd codehole * name xiaoqian age 1 1527849637634-0 127.0.0.1:6379> xlen codehole (integer) 3 127.0.0.1:6379> xrange codehole - + # -表示最小值, +表示最大值 1) 1) 1527849609889-0 2) 1) \"name\" 2) \"laoqian\" 3) \"age\" 4) \"30\" 2) 1) 1527849629172-0 2) 1) \"name\" 2) \"xiaoyu\" 3) \"age\" 4) \"29\" 3) 1) 1527849637634-0 2) 1) \"name\" 2) \"xiaoqian\" 3) \"age\" 4) \"1\" 127.0.0.1:6379> xrange codehole 1527849629172-0 + # 指定最小消息ID的列表 1) 1) 1527849629172-0 2) 1) \"name\" 2) \"xiaoyu\" 3) \"age\" 4) \"29\" 2) 1) 1527849637634-0 2) 1) \"name\" 2) \"xiaoqian\" 3) \"age\" 4) \"1\" 127.0.0.1:6379> xrange codehole - 1527849629172-0 # 指定最大消息ID的列表 1) 1) 1527849609889-0 2) 1) \"name\" 2) \"laoqian\" 3) \"age\" 4) \"30\" 2) 1) 1527849629172-0 2) 1) \"name\" 2) \"xiaoyu\" 3) \"age\" 4) \"29\" 127.0.0.1:6379> xdel codehole 1527849609889-0 (integer) 1 127.0.0.1:6379> xlen codehole # 长度不受影响 (integer) 3 127.0.0.1:6379> xrange codehole - + # 被删除的消息没了 1) 1) 1527849629172-0 2) 1) \"name\" 2) \"xiaoyu\" 3) \"age\" 4) \"29\" 2) 1) 1527849637634-0 2) 1) \"name\" 2) \"xiaoqian\" 3) \"age\" 4) \"1\" 127.0.0.1:6379> del codehole # 删除整个Stream (integer) 1 独立消费示例我们可以在不定义消费组的情况下进行 Stream 消息的 独立消费，当 Stream 没有新消息时，甚至可以阻塞等待。Redis 设计了一个单独的消费指令 xread，可以将 Stream 当成普通的消息队列(list)来使用。使用 xread 时，我们可以完全忽略 消费组(Consumer Group) 的存在，就好比 Stream 就是一个普通的列表(list)： # 从Stream头部读取两条消息 127.0.0.1:6379> xread count 2 streams codehole 0-0 1) 1) \"codehole\" 2) 1) 1) 1527851486781-0 2) 1) \"name\" 2) \"laoqian\" 3) \"age\" 4) \"30\" 2) 1) 1527851493405-0 2) 1) \"name\" 2) \"yurui\" 3) \"age\" 4) \"29\" # 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息 127.0.0.1:6379> xread count 1 streams codehole $ (nil) # 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来 127.0.0.1:6379> xread block 0 count 1 streams codehole $ # 我们从新打开一个窗口，在这个窗口往Stream里塞消息 127.0.0.1:6379> xadd codehole * name youming age 60 1527852774092-0 # 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容 # 而且还显示了一个等待时间，这里我们等待了93s 127.0.0.1:6379> xread block 0 count 1 streams codehole $ 1) 1) \"codehole\" 2) 1) 1) 1527852774092-0 2) 1) \"name\" 2) \"youming\" 3) \"age\" 4) \"60\" (93.11s) 客户端如果想要使用 xread 进行 顺序消费，一定要 记住当前消费 到哪里了，也就是返回的消息 ID。下次继续调用 xread 时，将上次返回的最后一个消息 ID 作为参数传递进去，就可以继续消费后续的消息。 block 0 表示永远阻塞，直到消息到来，block 1000 表示阻塞 1s，如果 1s 内没有任何消息到来，就返回 nil： 127.0.0.1:6379> xread block 1000 count 1 streams codehole $ (nil) (1.07s) 创建消费者示例Stream 通过 xgroup create 指令创建消费组(Consumer Group)，需要传递起始消息 ID 参数用来初始化 last_delivered_id 变量： 127.0.0.1:6379> xgroup create codehole cg1 0-0 # 表示从头开始消费 OK # $表示从尾部开始消费，只接受新消息，当前Stream消息会全部忽略 127.0.0.1:6379> xgroup create codehole cg2 $ OK 127.0.0.1:6379> xinfo codehole # 获取Stream信息 1) length 2) (integer) 3 # 共3个消息 3) radix-tree-keys 4) (integer) 1 5) radix-tree-nodes 6) (integer) 2 7) groups 8) (integer) 2 # 两个消费组 9) first-entry # 第一个消息 10) 1) 1527851486781-0 2) 1) \"name\" 2) \"laoqian\" 3) \"age\" 4) \"30\" 11) last-entry # 最后一个消息 12) 1) 1527851498956-0 2) 1) \"name\" 2) \"xiaoqian\" 3) \"age\" 4) \"1\" 127.0.0.1:6379> xinfo groups codehole # 获取Stream的消费组信息 1) 1) name 2) \"cg1\" 3) consumers 4) (integer) 0 # 该消费组还没有消费者 5) pending 6) (integer) 0 # 该消费组没有正在处理的消息 2) 1) name 2) \"cg2\" 3) consumers # 该消费组还没有消费者 4) (integer) 0 5) pending 6) (integer) 0 # 该消费组没有正在处理的消息 组内消费示例Stream 提供了 xreadgroup 指令可以进行消费组的组内消费，需要提供 消费组名称、消费者名称和起始消息 ID。它同 xread 一样，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 PEL (正在处理的消息) 结构里，客户端处理完毕后使用 xack 指令 通知服务器，本条消息已经处理完毕，该消息 ID 就会从 PEL 中移除，下面是示例： # >号表示从当前消费组的last_delivered_id后面开始读 # 每当消费者读取一条消息，last_delivered_id变量就会前进 127.0.0.1:6379> xreadgroup GROUP cg1 c1 count 1 streams codehole > 1) 1) \"codehole\" 2) 1) 1) 1527851486781-0 2) 1) \"name\" 2) \"laoqian\" 3) \"age\" 4) \"30\" 127.0.0.1:6379> xreadgroup GROUP cg1 c1 count 1 streams codehole > 1) 1) \"codehole\" 2) 1) 1) 1527851493405-0 2) 1) \"name\" 2) \"yurui\" 3) \"age\" 4) \"29\" 127.0.0.1:6379> xreadgroup GROUP cg1 c1 count 2 streams codehole > 1) 1) \"codehole\" 2) 1) 1) 1527851498956-0 2) 1) \"name\" 2) \"xiaoqian\" 3) \"age\" 4) \"1\" 2) 1) 1527852774092-0 2) 1) \"name\" 2) \"youming\" 3) \"age\" 4) \"60\" # 再继续读取，就没有新消息了 127.0.0.1:6379> xreadgroup GROUP cg1 c1 count 1 streams codehole > (nil) # 那就阻塞等待吧 127.0.0.1:6379> xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole > # 开启另一个窗口，往里塞消息 127.0.0.1:6379> xadd codehole * name lanying age 61 1527854062442-0 # 回到前一个窗口，发现阻塞解除，收到新消息了 127.0.0.1:6379> xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole > 1) 1) \"codehole\" 2) 1) 1) 1527854062442-0 2) 1) \"name\" 2) \"lanying\" 3) \"age\" 4) \"61\" (36.54s) 127.0.0.1:6379> xinfo groups codehole # 观察消费组信息 1) 1) name 2) \"cg1\" 3) consumers 4) (integer) 1 # 一个消费者 5) pending 6) (integer) 5 # 共5条正在处理的信息还有没有ack 2) 1) name 2) \"cg2\" 3) consumers 4) (integer) 0 # 消费组cg2没有任何变化，因为前面我们一直在操纵cg1 5) pending 6) (integer) 0 # 如果同一个消费组有多个消费者，我们可以通过xinfo consumers指令观察每个消费者的状态 127.0.0.1:6379> xinfo consumers codehole cg1 # 目前还有1个消费者 1) 1) name 2) \"c1\" 3) pending 4) (integer) 5 # 共5条待处理消息 5) idle 6) (integer) 418715 # 空闲了多长时间ms没有读取消息了 # 接下来我们ack一条消息 127.0.0.1:6379> xack codehole cg1 1527851486781-0 (integer) 1 127.0.0.1:6379> xinfo consumers codehole cg1 1) 1) name 2) \"c1\" 3) pending 4) (integer) 4 # 变成了5条 5) idle 6) (integer) 668504 # 下面ack所有消息 127.0.0.1:6379> xack codehole cg1 1527851493405-0 1527851498956-0 1527852774092-0 1527854062442-0 (integer) 4 127.0.0.1:6379> xinfo consumers codehole cg1 1) 1) name 2) \"c1\" 3) pending 4) (integer) 0 # pel空了 5) idle 6) (integer) 745505 QA 1：Stream 消息太多怎么办？ | Stream 的上限很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。xdel 指令又不会删除消息，它只是给消息做了个标志位。 Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 xadd 的指令提供一个定长长度 maxlen，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单： > XADD mystream MAXLEN 2 * value 1 1526654998691-0 > XADD mystream MAXLEN 2 * value 2 1526654999635-0 > XADD mystream MAXLEN 2 * value 3 1526655000369-0 > XLEN mystream (integer) 2 > XRANGE mystream - + 1) 1) 1526654999635-0 2) 1) \"value\" 2) \"2\" 2) 1) 1526655000369-0 2) 1) \"value\" 2) \"3\" 如果使用 MAXLEN 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息) 另外使用 MAXLEN 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 ~ 的特殊命令： XADD mystream MAXLEN ~ 1000 * ... entry fields here ... 它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 1000 条数据，可能是 1010 也可能是 1030。 QA 2：PEL 是如何避免消息丢失的？在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 xreadgroup 的起始消息 ID 不能为参数 &gt; ，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自 last_delivered_id 之后的新消息。 Redis Stream Vs KafkaRedis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 不能长时间存储大量数据。不过如果您想以 最小延迟 实时处理消息的话，您可以考虑 Redis，但是如果 消息很大并且应该重用数据 的话，则应该首先考虑使用 Kafka。 另外从某些角度来说，Redis Stream 也更适用于小型、廉价的应用程序，因为 Kafka 相对来说更难配置一些。 相关阅读 Redis(1)——5种基本数据结构 - https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/ Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ Reids(4)——神奇的HyperLoglog解决统计问题 - https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/ Redis(5)——亿级数据过滤和布隆过滤器 - https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/ Redis(6)——GeoHash查找附近的人https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/ Redis(7)——持久化【一文了解】 - https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/ 参考资料 订阅与发布——Redis 设计与实现 - https://redisbook.readthedocs.io/en/latest/feature/pubsub.html 《Redis 深度历险》 - 钱文品/ 著 - https://book.douban.com/subject/30386804/ Introduction to Redis Streams【官方文档】 - https://redis.io/topics/streams-intro Kafka vs. Redis: Log Aggregation Capabilities and Performance - https://logz.io/blog/kafka-vs-redis/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(7)——持久化【一文了解】","slug":"Redis-7-——持久化【一文了解】","date":"2020-03-13T10:58:00.000Z","updated":"2020-12-09T05:09:57.562Z","comments":true,"path":"2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/","link":"","permalink":"http://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/","excerpt":"","text":"一、持久化简介Redis 的数据 全部存储 在 内存 中，如果 突然宕机，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 持久化机制，它会将内存中的数据库状态 保存到磁盘 中。 持久化发生了什么 | 从内存到磁盘我们来稍微考虑一下 Redis 作为一个 “内存数据库” 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情： 详细版 的文字描述大概就是下面这样： 客户端向数据库 发送写命令 (数据在客户端的内存中) 数据库 接收 到客户端的 写请求 (数据在服务器的内存中) 数据库 调用系统 API 将数据写入磁盘 (数据在内核缓冲区中) 操作系统将 写缓冲区 传输到 磁盘控控制器 (数据在磁盘缓存中) 操作系统的磁盘控制器将数据 写入实际的物理媒介 中 (数据在磁盘中) 注意: 上面的过程其实是 极度精简 的，在实际的操作系统中，缓存 和 缓冲区 会比这 多得多… 如何尽可能保证持久化的安全如果我们故障仅仅涉及到 软件层面 (该进程被管理员终止或程序崩溃) 并且没有接触到内核，那么在 上述步骤 3 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。 如果我们考虑 停电/ 火灾 等 更具灾难性 的事情，那么只有在完成了第 5 步之后，才是安全的。 所以我们可以总结得出数据安全最重要的阶段是：步骤三、四、五，即： 数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？ 内核多久从缓冲区取数据刷新到磁盘控制器？ 磁盘控制器多久把数据写入物理媒介一次？ 注意： 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 尽可能地保证 数据的安全，这对于所有数据库来说都是一样的。 我们从 第三步 开始。Linux 系统提供了清晰、易用的用于操作文件的 POSIX file API，20 多年过去，仍然还有很多人对于这一套 API 的设计津津乐道，我想其中一个原因就是因为你光从 API 的命名就能够很清晰地知道这一套 API 的用途： int open(const char *path, int oflag, .../*,mode_t mode */); int close (int filedes);int remove( const char *fname ); ssize_t write(int fildes, const void *buf, size_t nbyte); ssize_t read(int fildes, void *buf, size_t nbyte); 参考自：API 设计最佳实践的思考 - https://www.cnblogs.com/yuanjiangw/p/10846560.html 所以，我们有很好的可用的 API 来完成 第三步，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。 然后我们来说说 第四步。我们知道，除了早期对电脑特别了解那帮人 (操作系统就这帮人搞的)，实际的物理硬件都不是我们能够 直接操作 的，都是通过 操作系统调用 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 上述第四步 提到的 写缓冲区，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 30 秒 后实际提交写入。 但是很明显，30 秒 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 PROSIX API 提供了另一个解决方案：fsync，该命令会 强制 内核将 缓冲区 写入 磁盘，但这是一个非常消耗性能的操作，每次调用都会 阻塞等待 直到设备报告 IO 完成，所以一般在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 fsync 操作。 到目前为止，我们了解到了如何控制 第三步 和 第四步，但是对于 第五步，我们 完全无法控制。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。 二、Redis 中的两种持久化方式方式一：快照 Redis 快照 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 100 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 .rdb 文件生成。 但我们知道，Redis 是一个 单线程 的程序，这意味着，我们不仅仅要响应用户的请求，还需要进行内存快照。而后者要求 Redis 必须进行 IO 操作，这会严重拖累服务器的性能。 还有一个重要的问题是，我们在 持久化的同时，内存数据结构 还可能在 变化，比如一个大型的 hash 字典正在持久化，结果一个请求过来把它删除了，可是这才刚持久化结束，咋办？ 使用系统多进程 COW(Copy On Write) 机制 | fork 函数操作系统多进程 COW(Copy On Write) 机制 拯救了我们。Redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，简单理解也就是基于当前进程 复制 了一个进程，主进程和子进程会共享内存里面的代码块和数据段： 这里多说一点，为什么 fork 成功调用后会有两个返回值呢？ 因为子进程在复制时复制了父进程的堆栈段，所以两个进程都停留在了 fork 函数中 (都在同一个地方往下继续”同时”执行)，等待返回，所以 *一次在父进程中返回子进程的 pid，另一次在子进程中返回零，系统资源不够时返回负数**。 *(伪代码如下) pid = os.fork() if pid > 0: handle_client_request() # 父进程继续处理客户端请求 if pid == 0: handle_snapshot_write() # 子进程处理快照写磁盘 if pid &lt; 0: # fork error 所以 快照持久化 可以完全交给 子进程 来处理，父进程 则继续 处理客户端请求。子进程 做数据持久化，它 不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是 父进程 不一样，它必须持续服务客户端请求，然后对 内存数据结构进行不间断的修改。 这个时候就会使用操作系统的 COW 机制来进行 数据段页面 的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后 对这个复制的页面进行修改。这时 子进程 相应的页面是 没有变化的，还是进程产生时那一瞬间的数据。 子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 Redis 的持久化 叫「快照」的原因。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。 方式二：AOF 快照不是很持久。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 kill -9 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。 AOF(Append Only File - 仅追加文件) 它的工作方式非常简单：每次执行 修改内存 中数据集的写操作时，都会 记录 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 所有的修改性指令序列，那么就可以通过对一个空的 Redis 实例 顺序执行所有的指令，也就是 「重放」，来恢复 Redis 当前实例的内存数据结构的状态。 为了展示 AOF 在实际中的工作方式，我们来做一个简单的实验： ./redis-server --appendonly yes # 设置一个新实例为 AOF 模式 然后我们执行一些写操作： redis 127.0.0.1:6379> set key1 Hello OK redis 127.0.0.1:6379> append key1 \" World!\" (integer) 12 redis 127.0.0.1:6379> del key1 (integer) 1 redis 127.0.0.1:6379> del non_existing_key (integer) 0 前三个操作实际上修改了数据集，第四个操作没有修改，因为没有指定名称的键。这是 AOF 日志保存的文本： $ cat appendonly.aof *2 $6 SELECT $1 0 *3 $3 set $4 key1 $5 Hello *3 $6 append $4 key1 $7 World! *2 $3 del $4 key1 如您所见，最后的那一条 DEL 指令不见了，因为它没有对数据集进行任何修改。 就是这么简单。当 Redis 收到客户端修改指令后，会先进行参数校验、逻辑处理，如果没问题，就 立即 将该指令文本 存储 到 AOF 日志中，也就是说，先执行指令再将日志存盘。这一点不同于 MySQL、LevelDB、HBase 等存储引擎，如果我们先存储日志再做逻辑处理，这样就可以保证即使宕机了，我们仍然可以通过之前保存的日志恢复到之前的数据状态，但是 Redis 为什么没有这么做呢？ Emmm… 没找到特别满意的答案，引用一条来自知乎上的回答吧： @缘于专注 - 我甚至觉得没有什么特别的原因。仅仅是因为，由于AOF文件会比较大，为了避免写入无效指令（错误指令），必须先做指令检查？如何检查，只能先执行了。因为语法级别检查并不能保证指令的有效性，比如删除一个不存在的key。而MySQL这种是因为它本身就维护了所有的表的信息，所以可以语法检查后过滤掉大部分无效指令直接记录日志，然后再执行。 更多讨论参见：为什么Redis先执行指令，再记录AOF日志，而不是像其它存储引擎一样反过来呢？ - https://www.zhihu.com/question/342427472 AOF 重写 Redis 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个 AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 AOF 日志 “瘦身”。 Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行瘦身。其 原理 就是 开辟一个子进程 对内存进行 遍历 转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件 中。序列化完毕后再将操作期间发生的 增量 AOF 日志 追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。 fsync AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘的。 就像我们 上方第四步 描述的那样，我们需要借助 glibc 提供的 fsync(int fd) 函数来讲指定的文件内容 强制从内核缓存刷到磁盘。但 “强制开车” 仍然是一个很消耗资源的一个过程，需要 “节制”！通常来说，生产环境的服务器，Redis 每隔 1s 左右执行一次 fsync 操作就可以了。 Redis 同样也提供了另外两种策略，一个是 永不 fsync，来让操作系统来决定合适同步磁盘，很不安全，另一个是 来一个指令就 fsync 一次，非常慢。但是在生产环境基本不会使用，了解一下即可。 Redis 4.0 混合持久化 重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 自持久化开始到持久化结束 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小： 于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。 相关阅读 Redis(1)——5种基本数据结构 - https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/ Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ Reids(4)——神奇的HyperLoglog解决统计问题 - https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/ Redis(5)——亿级数据过滤和布隆过滤器 - https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/ Redis(6)——GeoHash查找附近的人https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/ 扩展阅读 Redis 数据备份与恢复 | 菜鸟教程 - https://www.runoob.com/redis/redis-backup.html Java Fork/Join 框架 - https://www.cnblogs.com/cjsblog/p/9078341.html 参考资料 Redis persistence demystified | antirez weblog (作者博客) - http://oldblog.antirez.com/post/redis-persistence-demystified.html 操作系统 — fork()函数的使用与底层原理 - https://blog.csdn.net/Dawn_sf/article/details/78709839 磁盘和内存读写简单原理 - https://blog.csdn.net/zhanghongzheng3213/article/details/54141202 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(6)——GeoHash查找附近的人","slug":"Redis-6-——GeoHash查找附近的人","date":"2020-03-12T00:12:00.000Z","updated":"2020-12-09T05:09:54.034Z","comments":true,"path":"2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/","link":"","permalink":"http://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/","excerpt":"","text":"像微信 “附近的人”，美团 “附近的餐厅”，支付宝共享单车 “附近的车” 是怎么设计实现的呢？ 一、使用数据库实现查找附近的人我们都知道，地球上的任何一个位置都可以使用二维的 经纬度 来表示，经度范围 [-180, 180]，纬度范围 *[-90, 90]，纬度正负以赤道为界，北正南负，经度正负以本初子午线 *(英国格林尼治天文台) 为界，东正西负。比如说，北京人民英雄纪念碑的经纬度坐标就是 (39.904610, 116.397724)，都是正数，因为中国位于东北半球。 所以，当我们使用数据库存储了所有人的 经纬度 信息之后，我们就可以基于当前的坐标节点，来划分出一个矩形的范围，来得知附近的人，如下图： 所以，我们很容易写出下列的伪 SQL 语句： SELECT id FROM positions WHERE x0 - r &lt; x &lt; x0 + r AND y0 - r &lt; y &lt; y0 + r 如果我们还想进一步地知道与每个坐标元素的距离并排序的话，就需要一定的计算。 当两个坐标元素的距离不是很远的时候，我们就可以简单利用 勾股定理 就能够得出他们之间的 距离。不过需要注意的是，地球不是一个标准的球体，经纬度的密度 是 不一样 的，所以我们使用勾股定理计算平方之后再求和时，需要按照一定的系数 加权 再进行求和。当然，如果不准求精确的话，加权也不必了。 参考下方 参考资料 2 我们能够差不多能写出如下优化之后的 SQL 语句来：(仅供参考) SELECT * FROM users_location WHERE latitude > '.$lat.' - 1 AND latitude &lt; '.$lat.' + 1 AND longitude > '.$lon.' - 1 AND longitude &lt; '.$lon.' + 1 ORDER BY ACOS( SIN( ( '.$lat.' * 3.1415 ) / 180 ) * SIN( ( latitude * 3.1415 ) / 180 ) + COS( ( '.$lat.' * 3.1415 ) / 180 ) * COS( ( latitude * 3.1415 ) / 180 ) * COS( ( '.$lon.' * 3.1415 ) / 180 - ( longitude * 3.1415 ) / 180 ) ) * 6380 ASC LIMIT 10 '; 为了满足高性能的矩形区域算法，数据表也需要把经纬度坐标加上 双向复合索引 (x, y)，这样可以满足最大优化查询性能。 二、GeoHash 算法简述这是业界比较通用的，用于 地理位置距离排序 的一个算法，Redis 也采用了这样的算法。GeoHash 算法将 二维的经纬度 数据映射到 一维 的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。当我们想要计算 「附近的人时」，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行了。 它的核心思想就是把整个地球看成是一个 二维的平面，然后把这个平面不断地等分成一个一个小的方格，每一个 坐标元素都位于其中的 唯一一个方格 中，等分之后的 方格越小，那么坐标也就 越精确，类似下图： 经过划分的地球，我们需要对其进行编码： 经过这样顺序的编码之后，如果你仔细观察一会儿，你就会发现一些规律： 横着的所有编码中，第 2 位和第 4 位都是一样的，例如第一排第一个 0101 和第二个 0111，他们的第 2 位和第 4 位都是 1； 竖着的所有编码中，第 1 位和第 3 位是递增的，例如第一排第一个 0101，如果单独把第 1 位和第 3 位拎出来的话，那就是 00，同理看第一排第二个 0111，同样的方法第 1 位和第 3 位拎出来是 01，刚好是 00 递增一个； 通过这样的规律我们就把每一个小方块儿进行了一定顺序的编码，这样做的 好处 是显而易见的：每一个元素坐标既能够被 唯一标识 在这张被编码的地图上，也不至于 暴露特别的具体的位置，因为区域是共享的，我可以告诉你我就在公园附近，但是在具体的哪个地方你就无从得知了。 总之，我们通过上面的思想，能够把任意坐标变成一串二进制的编码了，类似于 11010010110001000100 这样 (注意经度和维度是交替出现的哦..)，通过这个整数我们就可以还原出元素的坐标，整数越长，还原出来的坐标值的损失程序就越小。对于 “附近的人” 这个功能来说，损失的一点经度可以忽略不计。 最后就是一个 Base32 (09, az, 去掉 a/i/l/o 四个字母) 的编码操作，让它变成一个字符串，例如上面那一串儿就变成了 wx4g0ec1。 在 Redis 中，经纬度使用 52 位的整数进行编码，放进了 zset 里面，zset 的 value 是元素的 key，score 是 GeoHash 的 52 位整数值。zset 的 score 虽然是浮点数，但是对于 52 位的整数值来说，它可以无损存储。 三、在 Redis 中使用 Geo 下方内容引自 参考资料 1 - 《Redis 深度历险》 在使用 Redis 进行 Geo 查询 时，我们要时刻想到它的内部结构实际上只是一个 zset(skiplist)。通过 zset 的 score 排序就可以得到坐标附近的其他元素 (实际情况要复杂一些，不过这样理解足够了)，通过将 score 还原成坐标值就可以得到元素的原始坐标了。 Redis 提供的 Geo 指令只有 6 个，很容易就可以掌握。 增加geoadd 指令携带集合名称以及多个经纬度名称三元组，注意这里可以加入多个三元组。 127.0.0.1:6379> geoadd company 116.48105 39.996794 juejin (integer) 1 127.0.0.1:6379> geoadd company 116.514203 39.905409 ireader (integer) 1 127.0.0.1:6379> geoadd company 116.489033 40.007669 meituan (integer) 1 127.0.0.1:6379> geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi (integer) 2 不过很奇怪.. Redis 没有直接提供 Geo 的删除指令，但是我们可以通过 zset 相关的指令来操作 Geo 数据，所以元素删除可以使用 zrem 指令即可。 距离geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。 127.0.0.1:6379> geodist company juejin ireader km \"10.5501\" 127.0.0.1:6379> geodist company juejin meituan km \"1.3878\" 127.0.0.1:6379> geodist company juejin jd km \"24.2739\" 127.0.0.1:6379> geodist company juejin xiaomi km \"12.9606\" 127.0.0.1:6379> geodist company juejin juejin km \"0.0000\" 我们可以看到掘金离美团最近，因为它们都在望京。距离单位可以是 m、km、ml、ft，分别代表米、千米、英里和尺。 获取元素位置geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。 127.0.0.1:6379> geopos company juejin 1) 1) \"116.48104995489120483\" 2) \"39.99679348858259686\" 127.0.0.1:6379> geopos company ireader 1) 1) \"116.5142020583152771\" 2) \"39.90540918662494363\" 127.0.0.1:6379> geopos company juejin ireader 1) 1) \"116.48104995489120483\" 2) \"39.99679348858259686\" 2) 1) \"116.5142020583152771\" 2) \"39.90540918662494363\" 我们观察到获取的经纬度坐标和 geoadd 进去的坐标有轻微的误差，原因是 Geohash 对二维坐标进行的一维映射是有损的，通过映射再还原回来的值会出现较小的差别。对于 「附近的人」 这种功能来说，这点误差根本不是事。 获取元素的 hash 值geohash 可以获取元素的经纬度编码字符串，上面已经提到，它是 base32 编码。 你可以使用这个编码值去 http://geohash.org/${hash} 中进行直接定位，它是 Geohash 的标准编码值。 127.0.0.1:6379> geohash company ireader 1) \"wx4g52e1ce0\" 127.0.0.1:6379> geohash company juejin 1) \"wx4gd94yjn0\" 让我们打开地址 http://geohash.org/wx4g52e1ce0，观察地图指向的位置是否正确： 很好，就是这个位置，非常准确。 附近的公司georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素，它的参数非常复杂。 # 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身 127.0.0.1:6379> georadiusbymember company ireader 20 km count 3 asc 1) \"ireader\" 2) \"juejin\" 3) \"meituan\" # 范围 20 公里以内最多 3 个元素按距离倒排 127.0.0.1:6379> georadiusbymember company ireader 20 km count 3 desc 1) \"jd\" 2) \"meituan\" 3) \"juejin\" # 三个可选参数 withcoord withdist withhash 用来携带附加参数 # withdist 很有用，它可以用来显示距离 127.0.0.1:6379> georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc 1) 1) \"ireader\" 2) \"0.0000\" 3) (integer) 4069886008361398 4) 1) \"116.5142020583152771\" 2) \"39.90540918662494363\" 2) 1) \"juejin\" 2) \"10.5501\" 3) (integer) 4069887154388167 4) 1) \"116.48104995489120483\" 2) \"39.99679348858259686\" 3) 1) \"meituan\" 2) \"11.5748\" 3) (integer) 4069887179083478 4) 1) \"116.48903220891952515\" 2) \"40.00766997707732031\" 除了 georadiusbymember 指令根据元素查询附近的元素，Redis 还提供了根据坐标值来查询附近的元素，这个指令更加有用，它可以根据用户的定位来计算「附近的车」，「附近的餐馆」等。它的参数和 georadiusbymember 基本一致，除了将目标元素改成经纬度坐标值： 127.0.0.1:6379> georadius company 116.514202 39.905409 20 km withdist count 3 asc 1) 1) \"ireader\" 2) \"0.0000\" 2) 1) \"juejin\" 2) \"10.5501\" 3) 1) \"meituan\" 2) \"11.5748\" 注意事项在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条，如果使用 Redis 的 Geo 数据结构，它们将 全部放在一个 zset 集合中。在 Redis 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响，在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。 所以，这里建议 Geo 的数据使用 单独的 Redis 实例部署，不使用集群环境。 如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。这样就可以显著降低单个 zset 集合的大小。 相关阅读 Redis(1)——5种基本数据结构 - https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/ Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ Reids(4)——神奇的HyperLoglog解决统计问题 - https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/ Redis(5)——亿级数据过滤和布隆过滤器 - https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/ 参考资料 《Redis 深度历险》 - 钱文品/ 著 - https://book.douban.com/subject/30386804/ mysql经纬度查询并且计算2KM范围内附近用户的sql查询性能优化实例教程 - https://www.cnblogs.com/mgbert/p/4146538.html Geohash算法原理及实现 - https://www.jianshu.com/p/2fd0cf12e5ba GeoHash算法学习讲解、解析及原理分析 - https://zhuanlan.zhihu.com/p/35940647 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(5)——亿级数据过滤和布隆过滤器","slug":"Redis-5-——亿级数据过滤和布隆过滤器","date":"2020-03-11T11:02:00.000Z","updated":"2020-12-09T05:09:49.863Z","comments":true,"path":"2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/","link":"","permalink":"http://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/","excerpt":"","text":"一、布隆过滤器简介上一次 我们学会了使用 HyperLogLog 来对大数据进行一个估算，它非常有价值，可以解决很多精确度不高的统计需求。但是如果我们想知道某一个值是不是已经在 HyperLogLog 结构里面了，它就无能为力了，它只提供了 pfadd 和 pfcount 方法，没有提供类似于 contains 的这种方法。 就举一个场景吧，比如你 刷抖音： 你有 刷到过重复的推荐内容 吗？这么多的推荐内容要推荐给这么多的用户，它是怎么保证每个用户在看推荐内容时，保证不会出现之前已经看过的推荐视频呢？也就是说，抖音是如何实现 推送去重 的呢？ 你会想到服务器 记录 了用户看过的 所有历史记录，当推荐系统推荐短视频时会从每个用户的历史记录里进行 筛选，过滤掉那些已经存在的记录。问题是当 用户量很大，每个用户看过的短视频又很多的情况下，这种方式，推荐系统的去重工作 在性能上跟的上么？ 实际上，如果历史记录存储在关系数据库里，去重就需要频繁地对数据库进行 exists 查询，当系统并发量很高时，数据库是很难抗住压力的。 你可能又想到了 缓存，但是这么多用户这么多的历史记录，如果全部缓存起来，那得需要 浪费多大的空间 啊.. (可能老板看一眼账单，看一眼你..) 并且这个存储空间会随着时间呈线性增长，就算你用缓存撑得住一个月，但是又能继续撑多久呢？不缓存性能又跟不上，咋办呢？ 如上图所示，布隆过滤器(Bloom Filter) 就是这样一种专门用来解决去重问题的高级数据结构。但是跟 HyperLogLog 一样，它也一样有那么一点点不精确，也存在一定的误判概率，但它能在解决去重的同时，在 空间上能节省 90% 以上，也是非常值得的。 布隆过滤器是什么布隆过滤器（Bloom Filter） 是 1970 年由布隆提出的。它 实际上 是一个很长的二进制向量和一系列随机映射函数 (下面详细说)，实际上你也可以把它 简单理解 为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。 当布隆过滤器说某个值存在时，这个值 可能不存在；当它说不存在时，那么 一定不存在。打个比方，当它说不认识你时，那就是真的不认识，但是当它说认识你的时候，可能是因为你长得像它认识的另外一个朋友 (脸长得有些相似)，所以误判认识你。 布隆过滤器的使用场景基于上述的功能，我们大致可以把布隆过滤器用于以下的场景之中： 大数据判断是否存在：这就可以实现出上述的去重功能，如果你的服务器内存足够大的话，那么使用 HashMap 可能是一个不错的解决方案，理论上时间复杂度可以达到 O(1 的级别，但是当数据量起来之后，还是只能考虑布隆过滤器。 解决缓存穿透：我们经常会把一些热点数据放在 Redis 中当作缓存，例如产品详情。 通常一个请求过来之后我们会先查询缓存，而不用直接读取数据库，这是提升性能最简单也是最普遍的做法，但是 如果一直请求一个不存在的缓存，那么此时一定不存在缓存，那就会有 大量请求直接打到数据库 上，造成 缓存穿透，布隆过滤器也可以用来解决此类问题。 爬虫/ 邮箱等系统的过滤：平时不知道你有没有注意到有一些正常的邮件也会被放进垃圾邮件目录中，这就是使用布隆过滤器 误判 导致的。 二、布隆过滤器原理解析布隆过滤器 本质上 是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0，所以我们先来创建一个稍微长一些的位向量用作展示： 当我们向布隆过滤器中添加数据时，会使用 多个 hash 函数对 key 进行运算，算得一个证书索引值，然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作，例如，我们添加一个 wmyskxz： 向布隆过滤器查查询 key 是否存在时，跟 add 操作一样，会把这个 key 通过相同的多个 hash 函数进行运算，查看 对应的位置 是否 都 为 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果这几个位置都是 1，并不能说明这个 key 一定存在，只能说极有可能存在，因为这些位置的 1 可能是因为其他的 key 存在导致的。 就比如我们在 add 了一定的数据之后，查询一个 不存在 的 key： 很明显，1/3/5 这几个位置的 1 是因为上面第一次添加的 wmyskxz 而导致的，所以这里就存在 误判。幸运的是，布隆过滤器有一个可以预判误判率的公式，比较复杂，感兴趣的朋友可以自行去阅读，比较烧脑.. 只需要记住以下几点就好了： 使用时 不要让实际元素数量远大于初始化数量； 当实际元素数量超过初始化数量时，应该对布隆过滤器进行 重建，重新分配一个 size 更大的过滤器，再将所有的历史元素批量 add 进行； 三、布隆过滤器的使用Redis 官方 提供的布隆过滤器到了 Redis 4.0 提供了插件功能之后才正式登场。布隆过滤器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。下面我们来体验一下 Redis 4.0 的布隆过滤器，为了省去繁琐安装过程，我们直接用Docker 吧。 > docker pull redislabs/rebloom # 拉取镜像 > docker run -p6379:6379 redislabs/rebloom # 运行容器 > redis-cli # 连接容器中的 redis 服务 如果上面三条指令执行没有问题，下面就可以体验布隆过滤器了。 当然，如果你不想使用 Docker，也可以在检查本机 Redis 版本合格之后自行安装插件，可以参考这里: https://blog.csdn.net/u013030276/article/details/88350641 布隆过滤器的基本用法布隆过滤器有两个基本指令，bf.add 添加元素，bf.exists 查询元素是否存在，它的用法和 set 集合的 sadd 和 sismember 差不多。注意 bf.add 只能一次添加一个元素，如果想要一次添加多个，就需要用到 bf.madd 指令。同样如果需要一次查询多个元素是否存在，就需要用到 bf.mexists 指令。 127.0.0.1:6379> bf.add codehole user1 (integer) 1 127.0.0.1:6379> bf.add codehole user2 (integer) 1 127.0.0.1:6379> bf.add codehole user3 (integer) 1 127.0.0.1:6379> bf.exists codehole user1 (integer) 1 127.0.0.1:6379> bf.exists codehole user2 (integer) 1 127.0.0.1:6379> bf.exists codehole user3 (integer) 1 127.0.0.1:6379> bf.exists codehole user4 (integer) 0 127.0.0.1:6379> bf.madd codehole user4 user5 user6 1) (integer) 1 2) (integer) 1 3) (integer) 1 127.0.0.1:6379> bf.mexists codehole user4 user5 user6 user7 1) (integer) 1 2) (integer) 1 3) (integer) 1 4) (integer) 0 上面使用的布隆过过滤器只是默认参数的布隆过滤器，它在我们第一次 add 的时候自动创建。Redis 也提供了可以自定义参数的布隆过滤器，只需要在 add 之前使用 bf.reserve 指令显式创建就好了。如果对应的 key 已经存在，bf.reserve 会报错。 bf.reserve 有三个参数，分别是 key、error_rate (错误率) 和 initial_size： error_rate 越低，需要的空间越大，对于不需要过于精确的场合，设置稍大一些也没有关系，比如上面说的推送系统，只会让一小部分的内容被过滤掉，整体的观看体验还是不会受到很大影响的； initial_size 表示预计放入的元素数量，当实际数量超过这个值时，误判率就会提升，所以需要提前设置一个较大的数值避免超出导致误判率升高； 如果不适用 bf.reserve，默认的 error_rate 是 0.01，默认的 initial_size 是 100。 四、布隆过滤器代码实现自己简单模拟实现根据上面的基础理论，我们很容易就可以自己实现一个用于 简单模拟 的布隆过滤器数据结构： public static class BloomFilter { private byte[] data; public BloomFilter(int initSize) { this.data = new byte[initSize * 2]; // 默认创建大小 * 2 的空间 } public void add(int key) { int location1 = Math.abs(hash1(key) % data.length); int location2 = Math.abs(hash2(key) % data.length); int location3 = Math.abs(hash3(key) % data.length); data[location1] = data[location2] = data[location3] = 1; } public boolean contains(int key) { int location1 = Math.abs(hash1(key) % data.length); int location2 = Math.abs(hash2(key) % data.length); int location3 = Math.abs(hash3(key) % data.length); return data[location1] * data[location2] * data[location3] == 1; } private int hash1(Integer key) { return key.hashCode(); } private int hash2(Integer key) { int hashCode = key.hashCode(); return hashCode ^ (hashCode >>> 3); } private int hash3(Integer key) { int hashCode = key.hashCode(); return hashCode ^ (hashCode >>> 16); } } 这里很简单，内部仅维护了一个 byte 类型的 data 数组，实际上 byte 仍然占有一个字节之多，可以优化成 bit 来代替，这里也仅仅是用于方便模拟。另外我也创建了三个不同的 hash 函数，其实也就是借鉴 HashMap 哈希抖动的办法，分别使用自身的 hash 和右移不同位数相异或的结果。并且提供了基础的 add 和 contains 方法。 下面我们来简单测试一下这个布隆过滤器的效果如何： public static void main(String[] args) { Random random = new Random(); // 假设我们的数据有 1 百万 int size = 1_000_000; // 用一个数据结构保存一下所有实际存在的值 LinkedList&lt;Integer> existentNumbers = new LinkedList&lt;>(); BloomFilter bloomFilter = new BloomFilter(size); for (int i = 0; i &lt; size; i++) { int randomKey = random.nextInt(); existentNumbers.add(randomKey); bloomFilter.add(randomKey); } // 验证已存在的数是否都存在 AtomicInteger count = new AtomicInteger(); AtomicInteger finalCount = count; existentNumbers.forEach(number -> { if (bloomFilter.contains(number)) { finalCount.incrementAndGet(); } }); System.out.printf(\"实际的数据量： %d, 判断存在的数据量: %d \\n\", size, count.get()); // 验证10个不存在的数 count = new AtomicInteger(); while (count.get() &lt; 10) { int key = random.nextInt(); if (existentNumbers.contains(key)) { continue; } else { // 这里一定是不存在的数 System.out.println(bloomFilter.contains(key)); count.incrementAndGet(); } } } 输出如下： 实际的数据量： 1000000, 判断存在的数据量: 1000000 false true false true true true false false true false 这就是前面说到的，当布隆过滤器说某个值 存在时，这个值 可能不存在，当它说某个值 不存在时，那就 肯定不存在，并且还有一定的误判率… 手动实现参考当然上面的版本特别 low，不过主体思想是不差的，这里也给出一个好一些的版本用作自己实现测试的参考： import java.util.BitSet; public class MyBloomFilter { /** * 位数组的大小 */ private static final int DEFAULT_SIZE = 2 &lt;&lt; 24; /** * 通过这个数组可以创建 6 个不同的哈希函数 */ private static final int[] SEEDS = new int[]{3, 13, 46, 71, 91, 134}; /** * 位数组。数组中的元素只能是 0 或者 1 */ private BitSet bits = new BitSet(DEFAULT_SIZE); /** * 存放包含 hash 函数的类的数组 */ private SimpleHash[] func = new SimpleHash[SEEDS.length]; /** * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样 */ public MyBloomFilter() { // 初始化多个不同的 Hash 函数 for (int i = 0; i &lt; SEEDS.length; i++) { func[i] = new SimpleHash(DEFAULT_SIZE, SEEDS[i]); } } /** * 添加元素到位数组 */ public void add(Object value) { for (SimpleHash f : func) { bits.set(f.hash(value), true); } } /** * 判断指定元素是否存在于位数组 */ public boolean contains(Object value) { boolean ret = true; for (SimpleHash f : func) { ret = ret &amp;&amp; bits.get(f.hash(value)); } return ret; } /** * 静态内部类。用于 hash 操作！ */ public static class SimpleHash { private int cap; private int seed; public SimpleHash(int cap, int seed) { this.cap = cap; this.seed = seed; } /** * 计算 hash 值 */ public int hash(Object value) { int h; return (value == null) ? 0 : Math.abs(seed * (cap - 1) &amp; ((h = value.hashCode()) ^ (h >>> 16))); } } } 使用 Google 开源的 Guava 中自带的布隆过滤器自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。 首先我们需要在项目中引入 Guava 的依赖： &lt;dependency> &lt;groupId>com.google.guava&lt;/groupId> &lt;artifactId>guava&lt;/artifactId> &lt;version>28.0-jre&lt;/version> &lt;/dependency> 实际使用如下： 我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01） // 创建布隆过滤器对象 BloomFilter&lt;Integer> filter = BloomFilter.create( Funnels.integerFunnel(), 1500, 0.01); // 判断指定元素是否存在 System.out.println(filter.mightContain(1)); System.out.println(filter.mightContain(2)); // 将元素添加进布隆过滤器 filter.put(1); filter.put(2); System.out.println(filter.mightContain(1)); System.out.println(filter.mightContain(2)); 在我们的示例中，当 mightContain() 方法返回 true 时，我们可以 99％ 确定该元素在过滤器中，当过滤器返回 false 时，我们可以 100％ 确定该元素不存在于过滤器中。 Guava 提供的布隆过滤器的实现还是很不错的 （想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用 （另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。 相关阅读 Redis(1)——5种基本数据结构 - https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/ Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ Reids(4)——神奇的HyperLoglog解决统计问题 - https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/\\ 参考资料 《Redis 深度历险》 - 钱文品/ 著 - https://book.douban.com/subject/30386804/ 5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - https://juejin.im/post/5de1e37c5188256e8e43adfc 【原创】不了解布隆过滤器？一文给你整的明明白白！ - https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"\"长辈牌\"电子产品:有一种评论朋友圈叫给你打电话","slug":"\"长辈牌\"电子产品:有一种评论朋友圈叫给你打电话","date":"2020-03-10T06:16:00.000Z","updated":"2020-12-09T04:51:06.023Z","comments":true,"path":"2020/03/10/chang-bei-pai-dian-zi-chan-pin-you-yi-chong-ping-lun-peng-you-quan-jiao-gei-ni-da-dian-hua/","link":"","permalink":"http://www.wmyskxz.com/2020/03/10/chang-bei-pai-dian-zi-chan-pin-you-yi-chong-ping-lun-peng-you-quan-jiao-gei-ni-da-dian-hua/","excerpt":"","text":"一、长辈们使用电子产品的姿势集合先问你一个问题：「怎么下载搜狗输入法？」 (非广告) 摁？看到这篇文章的你可能都有点懵，不就下载安装就完了吗？但是，真的就只是这样吗？ 前一段时间，当家里的长辈问到我这个问题，我一时间也不知道怎么回答.. 一阵沟通无果后，尝试远程解决了.. 我才发现了与长辈们的 「数字鸿沟」： 下载？在哪里下载？我下的文件去哪儿了？ 百度？什么是百度？在哪里能点开百度？ 安装？怎么安装？安好了怎么用？ 起初我也不是那么在意的，只是后来又跟长辈远程了一次，又发现了长辈使用的 WINDOWS 电脑简直乱成一团.. 桌面上铺满的文件和文件夹/ 磁盘中下拉 5s 也拉不完的文件列表/ 右下角不停地弹窗广告/ 开机默认启动的 100 个软件，别误会，我举这些例子，并不是想说明长辈们不会使用电脑。毕竟，任何一个产品都不能保证它们被正确的使用，例如： 电钻吃玉米： （据说是世界上最快的吃玉米的方法😇） 这里只是想讨论一下关于长辈们与”电子产品”的那些事。 姿势一：杂乱的桌面 + 繁杂的应用不知道你有没有看过长辈的电子产品，不论是个人电脑，还是手机，桌面上永远都长这样： 图片来源：https://www.jianshu.com/p/cbb626dd344e 我曾经问过我妈为什么你手机桌面这么多 APP，她的回答也很粗暴：「懒得删 or 忘了删」。 姿势二：纷杂的信息就拿 微信 来说吧，我感觉我妈至少加了 50 个群.. 全部都没有屏蔽，也没有什么置顶，微信消息总是 99+，每次跟我妈发消息都不会有很多的期待，她能看到我的消息并回复我，那我知道，她一定是玩了好一段时间手机，刷了好一会儿微信了，所以每次找我妈基本上都 打电话… 姿势三：同类软件扎堆什么？！这么多大厂都出了电池管理的软件？选一个？怎么可能.. 我都要： 二、为什么教长辈使用电子产品这么难？不知道你有没有这样的类似经历： 去阿姨家做客，让你帮忙删除一下相机的相片，你一下子找到了类似 “垃圾桶” 的按钮，点击确认成功删除了，阿姨跟一大家人夸耀说：「现在的小孩这种东西不用教就懂，我们就不行了」 给老妈说了在 XX 市场可以下载应用，于是教她下载了某某应用.. 过了几天.. 「我想要下载 XX 听歌在哪里下载啊？」*，又过了几天.. *「我想要下载 XX 电子书怎么办？」 「为什么我手机现在没声音了？」… ….. 如果你有教过长辈使用电子产品，那么你一定会有些许 共鸣，网友们也不仅感慨：「为什么教老人用电子产品这么难？」，甚至还有网友提出了 教长辈使用电子产品（手机、电脑等）的过程，如何保持不急不躁的良好心态？ 这样的问题，啧啧啧… 认知不同我妈每次放假就会对我有很多期待，其中一项就是：「儿子！你帮我清理一下手机内存！」，我有时候会感觉到奇怪，现在各种各样的清理软件有许多，包括手机电脑都会自带有清理软件，甚至 APP 自己都能支持清理自己的缓存…点一下为啥这么难呢？ 道格拉斯·亚当斯 (英国作家) 说过：任何在你出生时已经有的技术都稀松平常，不过是世界自然秩序的一部分；任何在你 15-35 岁之间发明的技术都是新颖刺激的革命性产物，你很可能会拿它当职业;任何在你 35 岁以后发明的技术都是违反自然秩序的玩意儿… 大多数长辈成长的环境里面，能够接触到的电器顶多也就是常规三件套：电视、冰箱、洗衣机。这三个电器早起的使用难度是在是太低了，无非就是几个按钮操作，有点毛病几乎都能靠踢或拍打解决: 我望着长辈手机边角上的坑坑洼洼，不禁陷入了沉默… 老年不友好的设计 | 缺失的互联网学习成长过程电子产品尤其是互联网产品的迭代其实是一直以照顾最主流人群为目标来做的，也就是说 面向最有消费能力、最能接受 电子产品的群体。 拿 「智能手机」 举例，大家总觉得 “年轻人” 天然就是智能手机的用户。其实并不是，所有现如今的主流用户，都是培养成长起来的。 看早期的 iOS 的画风，为什么要做成拟物化的？ 因为早期所有人在智能手机产品面前，都是一视同仁的 “小白”，老年人也好年轻人也好，大家都不太理解手机上的图形示意是什么，代表着什么操作，交互要怎么理解。 拟物能够较好地体现层次感，让用户知道，现实生活里长什么样，在手机里就长什么样。 比如上图中的计算器，左边是旧版本 (iOS 6) 的，更加写实。等这些年轻人用户都被教育透了之后， iOS 就变成了更加简洁的风格。 学习操作的问题解决了之后，就可以去掉可能干扰使用的各种复杂阴影，让视觉重点更加集中。 但是，老年人大都没有参与到这个学习过程中。 等到老年人使用上智能产品之后，他们已经直接到了最新的 交互系统 里了，学习成本自然就不是一回事了。 (据朋友说最惨的案例是教长辈们左滑右滑..) 这里不得不 实名制吐槽 一下现在类似于 电信的那种互联网电视 了，自从升级互联网电视之后，之前打开电视电源就能播放的电视，现在隐藏下去了好几层，需要在界面上点点点才能正确进入到播放的界面，这无疑对于老年人来说，造成了使用和学习上的成本。 缺少社交环境知乎 @YorN 在 为什么教老人用电子产品这么难？ 这个问题中举了这样的一个例子： 有一个长辈，我们教他 用微信 的时候告诉他，别人发了朋友圈，你 可以在底下评论。然后，他就真的开始 “评论” 别人的朋友圈，评语都是 “风趣幽默”、“优美动人”、“温馨和睦”、“风景如画” 等等。 虽然年轻人已经习惯了互联网上所说的评论、回复、留言都是差不多的意思。但是在上一辈眼里，“评论” 这个词还保留着它本来的意义，所以他就会针对别人发的内容进行 “严肃” 地评论。 但是没过多久，也没有经过任何人 “指正”，这位长辈的评论就自动趋于正常了。因为他 身边越来越多的同龄人 也开始用朋友圈，当他看到别人的评论都是 日常闲聊，就知道了评论朋友圈不用真的写 “评语” 了。 还有一个段子呢，长辈们还有另一种评论朋友圈的姿势：直接给你打电话。 自我放弃的心态 | 不愿意改变以及依赖心理人都是社会塑造的动物，30 岁 之前整个人的人格基本已经塑造完了，对整个世界的理解和价值观，平时的喜好和习惯，都 基本定型了。 长辈们靠着几十年来的一步步积淀的经验，或平顺或坎坷地已经过去大半辈子了，他们会觉得自己 不会使用电子产品是非常正常的，理所应当的。抱着 “年纪大了”、“落伍了” 之类的思想，以及 不会可以靠别人，特别是家里人，自己只要学会使用微信以及拍照就行了。这关乎心态，而无关乎年龄。 还有一个有意思的 段子： 一位父亲已达到 85 岁高龄，他的儿子 45 岁，当时，父亲和儿子在家里坐着，忽然，窗户边飞来一只乌鸦，并且一直在那里叫唤。 这时，父亲问儿子：孩子，这是什么？” 儿子：“是乌鸦。” 过了一会儿，父亲又问：“这是什么？”，儿子很奇怪地答道：“是乌鸦。” 又过了几分钟，父亲又问，这是什么？ 这次，儿子的声音大了起来，这是乌鸦，乌鸦，父亲。 又过了几分钟，父亲又第四次问道：“这是什么？” 儿子终于忍不住内心的怒火，说道：“你怎么了，问这么多遍，我已经告诉你这是乌鸦，这很难理解吗？” 这时，父亲走进卧室，从里面拿出一些像是被撕过的日记簿来，把它递给儿子，并说道：“你念念。” 儿子开始念了：“今天儿子刚好满 3 岁，他会笑，能跑来跑去的，公园里有只乌鸦在叫唤，他问我：父亲，那是什么？我就告诉他说，那是一只乌鸦。他又再次问相同的问题，一直问了 23 遍，我回答了他 23 遍…… 父亲：你看，我只问了四遍，你怎么就不耐烦了呢？ 儿子：爸，我问第四遍的时候，你把我狠狠打了一顿。我一共问了 23 遍，你打了我 20 次。 儿子：我现在可以打你了吗，父亲？ 啪，父亲一巴掌打过来：还学会顶嘴了！ 反向思考：长辈们真的需要电子产品吗？我的爷爷奶奶还生活在农村，一家一院一亩田地一圈鸡鸭，他们的生活就可以完全没有互联网 (事实上，家里网都没有..)，在他们的理解里，生活就是可以没有电子产品的，何必去学习接受新的东西呢？ 并且他们所积攒的价值观、喜好和习惯，造成了 对于电子产品天然的排斥，这种排斥不是因为老年人头脑不灵光或者手脚不灵活了，纯粹是心里觉得 “没意思” 罢了。 要真觉得有意思，没有什么东西是学不会的： 或许他们硬着头皮请教你的每一个问题，逼自己接触的每一个电子产品，背后都藏着一句：「我想你」 吧。 三、我们能够做的那些事现在科技发展得太快，已经有点逼迫老年人不得不跟上的意味了。教会长辈使用电子产品这份重任，很明显已经落在了我们的头上，为了避免 “两败俱伤” 的局面发生，下面简单盘点一下我们能够力所能及去做的一些事情吧，也欢迎留言讨论！ 保持足够的耐心大部分网友在教长辈使用电子产品的时候的经过：耐心、细心、忍住不耐烦、忍住怒火、崩溃。 在看完了上面 第二部分 的情况下，我们一起来 品一品 多才多艺的网友们 “足够的耐心”： 合理使用工具 “人类为什么伟大？因为会使用工具啊！“ —— 佚名 就拿 教长辈们使用微信 这事儿来说吧，有的人为了教会父母用微信，硬是把自己逼成了抽象画大师，类似这样： 但其实微信官方就有 「微信使用小助手」 这样的官方使用教程，并且不仅有视频，还有 分步骤 讲解的图文，通俗易懂，一学就会： 简直不能更棒了： ps: 友情提醒，记得加进长辈们的常用小程序里面哦。 购买适合长辈的电子产品例如小米旗下的 21ke 手机，价格便宜 138，功能完备，性价比高： 再比如小米家的另一款产品： 另外还有一些 “适老化” 的智能家电也是非常值得考虑的。 做好远程准备难免会有需要你远程操作的情况出现，所以提前在长辈们的电脑中下载好支撑我们远程操作的软件，就显得非常必要了，这里比较推荐 Team Viewer 这个软件，不仅全平台支持，而且还支持 远程手机操纵电脑 哦！ 教长辈发红包，也要教如何选择公众号 “今天是马化腾生日，转发，之后自动充值100qb（或者自动升级2个太阳），我已经得到了，你快转发吧。” 不知道大家对于上面这一段话熟不熟悉，对于刚接触互联网不久的长辈，分辨能力明显是不足的，并且互联网整个就是一个信息的洪流，给他们 推荐关注一些靠谱的公众号，或者类似 可信可靠的信息来源渠道，就显得尤为重要了。 另外，微信官方的小程序中也有 「微信辟谣助手」 这样的实用小程序哦，给长辈们关注起来吧： 常回家看看说到底，对新技术，我们不能简单一句 “为什么长辈不接受” 就结束，里面牵涉到多方的共同努力，但 归根到底 还是要理解长辈们的需求是什么，才能更好地让新技术为他们服务。 常回家看看吧。 最后也要防止长辈们在互联网中遨游得太远如题： 参考资料 为什么教老人用电子产品这么难？ - 知乎 | @刘飞 | @shairley skirt | @槿年 - https://www.zhihu.com/question/27996612 教父母用微信有多难？有什么便捷的方法？ - 知乎 | @腾讯(Kerr) - https://www.zhihu.com/question/58622256 你教过长辈使用过电子产品吗？看了满满都是感动 - https://baijiahao.baidu.com/s?id=1641376481781947136&amp;wfr=spider&amp;for=pc 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Reids(4)——神奇的HyperLoglog解决统计问题","slug":"Reids-4-——神奇的HyperLoglog解决统计问题","date":"2020-03-02T08:46:00.000Z","updated":"2020-12-09T05:10:24.841Z","comments":true,"path":"2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/","link":"","permalink":"http://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/","excerpt":"","text":"一、HyperLogLog 简介HyperLogLog 是最早由 Flajolet 及其同事在 2007 年提出的一种 估算基数的近似最优算法。但跟原版论文不同的是，好像很多书包括 Redis 作者都把它称为一种 新的数据结构(new datastruct) (算法实现确实需要一种特定的数据结构来实现)。 关于基数统计基数统计(Cardinality Counting) 通常是用来统计一个集合中不重复的元素个数。 思考这样的一个场景： 如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站上每个网页的 UV(独立访客，每个用户每天只记录一次)，然后让你来开发这个统计模块，你会如何实现？ 如果统计 PV(浏览量，用户没点一次记录一次)，那非常好办，给每个页面配置一个独立的 Redis 计数器就可以了，把这个计数器的 key 后缀加上当天的日期。这样每来一个请求，就执行 INCRBY 指令一次，最终就可以统计出所有的 PV 数据了。 但是 UV 不同，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求了每一个网页请求都需要带上用户的 ID，无论是登录用户还是未登录的用户，都需要一个唯一 ID 来标识。 你也许马上就想到了一个 简单的解决方案：那就是 为每一个页面设置一个独立的 set 集合 来存储所有当天访问过此页面的用户 ID。但这样的 问题 就是： 存储空间巨大： 如果网站访问量一大，你需要用来存储的 set 集合就会非常大，如果页面再一多.. 为了一个去重功能耗费的资源就可以直接让你 老板打死你； 统计复杂： 这么多 set 集合如果要聚合统计一下，又是一个复杂的事情； 基数统计的常用方法对于上述这样需要 基数统计 的事情，通常来说有两种比 set 集合更好的解决方案： 第一种：B 树B 树最大的优势就是插入和查找效率很高，如果用 B 树存储要统计的数据，可以快速判断新来的数据是否存在，并快速将元素插入 B 树。要计算基础值，只需要计算 B 树的节点个数就行了。 不过将 B 树结构维护到内存中，能够解决统计和计算的问题，但是 并没有节省内存。 第二种：bitmapbitmap 可以理解为通过一个 bit 数组来存储特定数据的一种数据结构，每一个 bit 位都能独立包含信息，bit 是数据的最小存储单位，因此能大量节省空间，也可以将整个 bit 数据一次性 load 到内存计算。如果定义一个很大的 bit 数组，基础统计中 每一个元素对应到 bit 数组中的一位，例如： bitmap 还有一个明显的优势是 可以轻松合并多个统计结果，只需要对多个结果求异或就可以了，也可以大大减少存储内存。可以简单做一个计算，如果要统计 1 亿 个数据的基数值，大约需要的内存：100_000_000/ 8/ 1024/ 1024 ≈ 12 M，如果用 32 bit 的 int 代表 每一个 统计的数据，大约需要内存：32 * 100_000_000/ 8/ 1024/ 1024 ≈ 381 M 可以看到 bitmap 对于内存的节省显而易见，但仍然不够。统计一个对象的基数值就需要 12 M，如果统计 1 万个对象，就需要接近 120 G，对于大数据的场景仍然不适用。 概率算法实际上目前还没有发现更好的在 大数据场景 中 准确计算 基数的高效算法，因此在不追求绝对精确的情况下，使用概率算法算是一个不错的解决方案。 概率算法 不直接存储 数据集合本身，通过一定的 概率统计方法预估基数值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括: Linear Counting(LC)：早期的基数估计算法，LC 在空间复杂度方面并不算优秀，实际上 LC 的空间复杂度与上文中简单 bitmap 方法是一样的（但是有个常数项级别的降低），都是 O(Nmax) LogLog Counting(LLC)：LogLog Counting 相比于 LC 更加节省内存，空间复杂度只有 O(log2(log2(Nmax))) HyperLogLog Counting(HLL)：HyperLogLog Counting 是基于 LLC 的优化和改进，在同样空间复杂度情况下，能够比 LLC 的基数估计误差更小 其中，HyperLogLog 的表现是惊人的，上面我们简单计算过用 bitmap 存储 1 个亿 统计数据大概需要 12 M 内存，而在 HyperLoglog 中，只需要不到 1 K 内存就能够做到！在 Redis 中实现的 HyperLoglog 也只需要 12 K 内存，在 标准误差 0.81% 的前提下，能够统计 264 个数据！ 这是怎么做到的？！ 下面赶紧来了解一下！ 二、HyperLogLog 原理我们来思考一个抛硬币的游戏：你连续掷 n 次硬币，然后说出其中连续掷为正面的最大次数，我来猜你一共抛了多少次。 这很容易理解吧，例如：你说你这一次 最多连续出现了 2 次 正面，那么我就可以知道你这一次投掷的次数并不多，所以 我可能会猜是 5 或者是其他小一些的数字，但如果你说你这一次 最多连续出现了 20 次 正面，虽然我觉得不可能，但我仍然知道你花了特别多的时间，所以 我说 GUN…。 这期间我可能会要求你重复实验，然后我得到了更多的数据之后就会估计得更准。我们来把刚才的游戏换一种说法： 这张图的意思是，我们给定一系列的随机整数，记录下低位连续零位的最大长度 K，即为图中的 maxbit，通过这个 K 值我们就可以估算出随机数的数量 N。 代码实验我们可以简单编写代码做一个实验，来探究一下 K 和 N 之间的关系： public class PfTest { static class BitKeeper { private int maxbit; public void random() { long value = ThreadLocalRandom.current().nextLong(2L &lt;&lt; 32); int bit = lowZeros(value); if (bit > this.maxbit) { this.maxbit = bit; } } private int lowZeros(long value) { int i = 0; for (; i &lt; 32; i++) { if (value >> i &lt;&lt; i != value) { break; } } return i - 1; } } static class Experiment { private int n; private BitKeeper keeper; public Experiment(int n) { this.n = n; this.keeper = new BitKeeper(); } public void work() { for (int i = 0; i &lt; n; i++) { this.keeper.random(); } } public void debug() { System.out .printf(\"%d %.2f %d\\n\", this.n, Math.log(this.n) / Math.log(2), this.keeper.maxbit); } } public static void main(String[] args) { for (int i = 1000; i &lt; 100000; i += 100) { Experiment exp = new Experiment(i); exp.work(); exp.debug(); } } } 跟上图中的过程是一致的，话说为啥叫 PfTest 呢，包括 Redis 中的命令也一样带有一个 PF 前缀，还记得嘛，因为 HyperLogLog 的提出者上文提到过的，叫 Philippe Flajolet。 截取部分输出查看： //n n/log2 maxbit 34000 15.05 13 35000 15.10 13 36000 15.14 16 37000 15.18 17 38000 15.21 14 39000 15.25 16 40000 15.29 14 41000 15.32 16 42000 15.36 18 会发现 K 和 N 的对数之间存在显著的线性相关性：N 约等于 2k 更近一步：分桶平均如果 N 介于 2k 和 2k+1 之间，用这种方式估计的值都等于 2k，这明显是不合理的，所以我们可以使用多个 BitKeeper 进行加权估计，就可以得到一个比较准确的值了： public class PfTest { static class BitKeeper { // 无变化, 代码省略 } static class Experiment { private int n; private int k; private BitKeeper[] keepers; public Experiment(int n) { this(n, 1024); } public Experiment(int n, int k) { this.n = n; this.k = k; this.keepers = new BitKeeper[k]; for (int i = 0; i &lt; k; i++) { this.keepers[i] = new BitKeeper(); } } public void work() { for (int i = 0; i &lt; this.n; i++) { long m = ThreadLocalRandom.current().nextLong(1L &lt;&lt; 32); BitKeeper keeper = keepers[(int) (((m &amp; 0xfff0000) >> 16) % keepers.length)]; keeper.random(); } } public double estimate() { double sumbitsInverse = 0.0; for (BitKeeper keeper : keepers) { sumbitsInverse += 1.0 / (float) keeper.maxbit; } double avgBits = (float) keepers.length / sumbitsInverse; return Math.pow(2, avgBits) * this.k; } } public static void main(String[] args) { for (int i = 100000; i &lt; 1000000; i += 100000) { Experiment exp = new Experiment(i); exp.work(); double est = exp.estimate(); System.out.printf(\"%d %.2f %.2f\\n\", i, est, Math.abs(est - i) / i); } } } 这个过程有点 类似于选秀节目里面的打分，一堆专业评委打分，但是有一些评委因为自己特别喜欢所以给高了，一些评委又打低了，所以一般都要 屏蔽最高分和最低分，然后 再计算平均值，这样的出来的分数就差不多是公平公正的了。 上述代码就有 1024 个 “评委”，并且在计算平均值的时候，采用了 调和平均数，也就是倒数的平均值，它能有效地平滑离群值的影响： avg = (3 + 4 + 5 + 104) / 4 = 29 avg = 4 / (1/3 + 1/4 + 1/5 + 1/104) = 5.044 观察脚本的输出，误差率百分比控制在个位数： 100000 94274.94 0.06 200000 194092.62 0.03 300000 277329.92 0.08 400000 373281.66 0.07 500000 501551.60 0.00 600000 596078.40 0.01 700000 687265.72 0.02 800000 828778.96 0.04 900000 944683.53 0.05 真实的 HyperLogLog 要比上面的示例代码更加复杂一些，也更加精确一些。上面这个算法在随机次数很少的情况下会出现除零错误，因为 maxbit = 0 是不可以求倒数的。 真实的 HyperLogLog有一个神奇的网站，可以动态地让你观察到 HyperLogLog 的算法到底是怎么执行的：http://content.research.neustar.biz/blog/hll.html 其中的一些概念这里稍微解释一下，您就可以自行去点击 step 来观察了： m 表示分桶个数： 从图中可以看到，这里分成了 64 个桶； 蓝色的 bit 表示在桶中的位置： 例如图中的 101110 实则表示二进制的 46，所以该元素被统计在中间大表格 Register Values 中标红的第 46 个桶之中； 绿色的 bit 表示第一个 1 出现的位置： 从图中可以看到标绿的 bit 中，从右往左数，第一位就是 1，所以在 Register Values 第 46 个桶中写入 1； 红色 bit 表示绿色 bit 的值的累加： 下一个出现在第 46 个桶的元素值会被累加； 为什么要统计 Hash 值中第一个 1 出现的位置？因为第一个 1 出现的位置可以同我们抛硬币的游戏中第一次抛到正面的抛掷次数对应起来，根据上面掷硬币实验的结论，记录每个数据的第一个出现的位置 K，就可以通过其中最大值 Kmax 来推导出数据集合中的基数：N = 2Kmax PF 的内存占用为什么是 12 KB？我们上面的算法中使用了 1024 个桶，网站演示也只有 64 个桶，不过在 Redis 的 HyperLogLog 实现中，用的是 16384 个桶，即：214，也就是说，就像上面网站中间那个 Register Values 大表格有 16384 格。 而Redis 最大能够统计的数据量是 264，即每个桶的 maxbit 需要 6 个 bit 来存储，最大可以表示 maxbit = 63，于是总共占用内存就是：(214) x 6 / 8 (每个桶 6 bit，而这么多桶本身要占用 16384 bit，再除以 8 转换成 KB),算出来的结果就是 12 KB。 三、Redis 中的 HyperLogLog 实现从上面我们算是对 HyperLogLog 的算法和思想有了一定的了解，并且知道了一个 HyperLogLog 实际占用的空间大约是 12 KB，但 Redis 对于内存的优化非常变态，当 计数比较小 的时候，大多数桶的计数值都是 零，这个时候 Redis 就会适当节约空间，转换成另外一种 稀疏存储方式，与之相对的，正常的存储模式叫做 密集存储，这种方式会恒定地占用 12 KB。 密集型存储结构密集型的存储结构非常简单，就是 16384 个 6 bit 连续串成 的字符串位图： 我们都知道，一个字节是由 8 个 bit 组成的，这样 6 bit 排列的结构就会导致，有一些桶会 跨越字节边界，我们需要 对这一个或者两个字节进行适当的移位拼接 才可以得到具体的计数值。 假设桶的编号为 index，这个 6 bity 计数值的起始字节偏移用 offset_bytes 表示，它在这个字节的其实比特位置偏移用 offset_bits 表示，于是我们有： offset_bytes = (index * 6) / 8 offset_bits = (index * 6) % 8 前者是商，后者是余数。比如 bucket 2 的字节偏移是 1，也就是第 2 个字节。它的位偏移是 4，也就是第 2 个字节的第 5 个位开始是 bucket 2 的计数值。需要注意的是 字节位序是左边低位右边高位，而通常我们使用的字节都是左边高位右边低位。 这里就涉及到两种情况，如果 offset_bits 小于等于 2，说明这 6 bit 在一个字节的内部，可以直接使用下面的表达式得到计数值 val： val = buffer[offset_bytes] >> offset_bits # 向右移位 如果 offset_bits 大于 2，那么就会涉及到 跨越字节边界，我们需要拼接两个字节的位片段： # 低位值 low_val = buffer[offset_bytes] >> offset_bits # 低位个数 low_bits = 8 - offset_bits # 拼接，保留低6位 val = (high_val &lt;&lt; low_bits | low_val) &amp; 0b111111 不过下面 Redis 的源码要晦涩一点，看形式它似乎只考虑了跨越字节边界的情况。这是因为如果 6 bit 在单个字节内，上面代码中的 high_val 的值是零，所以这一份代码可以同时照顾单字节和双字节： // 获取指定桶的计数值 #define HLL_DENSE_GET_REGISTER(target,p,regnum) do { \\ uint8_t *_p = (uint8_t*) p; \\ unsigned long _byte = regnum*HLL_BITS/8; \\ unsigned long _fb = regnum*HLL_BITS&amp;7; \\ # %8 = &amp;7 unsigned long _fb8 = 8 - _fb; \\ unsigned long b0 = _p[_byte]; \\ unsigned long b1 = _p[_byte+1]; \\ target = ((b0 >> _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \\ } while(0) // 设置指定桶的计数值 #define HLL_DENSE_SET_REGISTER(p,regnum,val) do { \\ uint8_t *_p = (uint8_t*) p; \\ unsigned long _byte = regnum*HLL_BITS/8; \\ unsigned long _fb = regnum*HLL_BITS&amp;7; \\ unsigned long _fb8 = 8 - _fb; \\ unsigned long _v = val; \\ _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \\ _p[_byte] |= _v &lt;&lt; _fb; \\ _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX >> _fb8); \\ _p[_byte+1] |= _v >> _fb8; \\ } while(0) 稀疏存储结构稀疏存储适用于很多计数值都是零的情况。下图表示了一般稀疏存储计数值的状态： 当 多个连续桶的计数值都是零 时，Redis 提供了几种不同的表达形式： 00xxxxxx：前缀两个零表示接下来的 6bit 整数值加 1 就是零值计数器的数量，注意这里要加 1 是因为数量如果为零是没有意义的。比如 00010101 表示连续 22 个零值计数器。 01xxxxxx yyyyyyyy：6bit 最多只能表示连续 64 个零值计数器，这样扩展出的 14bit 可以表示最多连续 16384 个零值计数器。这意味着 HyperLogLog 数据结构中 16384 个桶的初始状态，所有的计数器都是零值，可以直接使用 2 个字节来表示。 1vvvvvxx：中间 5bit 表示计数值，尾部 2bit 表示连续几个桶。它的意思是连续 (xx +1) 个计数值都是 (vvvvv + 1)。比如 10101011 表示连续 4 个计数值都是 11。 注意 上面第三种方式 的计数值最大只能表示到 32，而 HyperLogLog 的密集存储单个计数值用 6bit 表示，最大可以表示到 63。当稀疏存储的某个计数值需要调整到大于 32 时，Redis 就会立即转换 HyperLogLog 的存储结构，将稀疏存储转换成密集存储。 对象头HyperLogLog 除了需要存储 16384 个桶的计数值之外，它还有一些附加的字段需要存储，比如总计数缓存、存储类型。所以它使用了一个额外的对象头来表示： struct hllhdr { char magic[4]; /* 魔术字符串\"HYLL\" */ uint8_t encoding; /* 存储类型 HLL_DENSE or HLL_SPARSE. */ uint8_t notused[3]; /* 保留三个字节未来可能会使用 */ uint8_t card[8]; /* 总计数缓存 */ uint8_t registers[]; /* 所有桶的计数器 */ }; 所以 HyperLogLog 整体的内部结构就是 HLL 对象头 加上 16384 个桶的计数值位图。它在 Redis 的内部结构表现就是一个字符串位图。你可以把 HyperLogLog 对象当成普通的字符串来进行处理： > PFADD codehole python java golang (integer) 1 > GET codehole \"HYLL\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80C\\x03\\x84MK\\x80P\\xb8\\x80^\\xf3\" 但是 不可以 使用 HyperLogLog 指令来 操纵普通的字符串，因为它需要检查对象头魔术字符串是否是 “HYLL”。 四、HyperLogLog 的使用HyperLogLog 提供了两个指令 PFADD 和 PFCOUNT，字面意思就是一个是增加，另一个是获取计数。PFADD 和 set 集合的 SADD 的用法是一样的，来一个用户 ID，就将用户 ID 塞进去就是，PFCOUNT 和 SCARD 的用法是一致的，直接获取计数值： > PFADD codehole user1 (interger) 1 > PFCOUNT codehole (integer) 1 > PFADD codehole user2 (integer) 1 > PFCOUNT codehole (integer) 2 > PFADD codehole user3 (integer) 1 > PFCOUNT codehole (integer) 3 > PFADD codehole user4 user 5 (integer) 1 > PFCOUNT codehole (integer) 5 我们可以用 Java 编写一个脚本来试试 HyperLogLog 的准确性到底有多少： public class JedisTest { public static void main(String[] args) { for (int i = 0; i &lt; 100000; i++) { jedis.pfadd(\"codehole\", \"user\" + i); } long total = jedis.pfcount(\"codehole\"); System.out.printf(\"%d %d\\n\", 100000, total); jedis.close(); } } 结果输出如下： 100000 99723 发现 10 万条数据只差了 277，按照百分比误差率是 0.277%，对于巨量的 UV 需求来说，这个误差率真的不算高。 当然，除了上面的 PFADD 和 PFCOUNT 之外，还提供了第三个 PFMEGER 指令，用于将多个计数值累加在一起形成一个新的 pf 值： > PFADD nosql \"Redis\" \"MongoDB\" \"Memcached\" (integer) 1 > PFADD RDBMS \"MySQL\" \"MSSQL\" \"PostgreSQL\" (integer) 1 > PFMERGE databases nosql RDBMS OK > PFCOUNT databases (integer) 6 相关阅读 Redis(1)——5种基本数据结构 - https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/ Redis(2)——跳跃表 - https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/ Redis(3)——分布式锁深入探究 - https://www.wmyskxz.com/2020/03/01/redis-3/ 扩展阅读 【算法原文】HyperLogLog: the analysis of a near-optimalcardinality estimation algorithm - http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf 参考资料 【Redis 作者博客】Redis new data structure: the HyperLogLog - http://antirez.com/news/75 神奇的HyperLogLog算法 - http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html 深度探索 Redis HyperLogLog 内部数据结构 - https://zhuanlan.zhihu.com/p/43426875 《Redis 深度历险》 - 钱文品/ 著 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(3)——分布式锁深入探究","slug":"Redis-3","date":"2020-03-01T06:07:00.000Z","updated":"2020-12-09T05:09:40.867Z","comments":true,"path":"2020/03/01/redis-3/","link":"","permalink":"http://www.wmyskxz.com/2020/03/01/redis-3/","excerpt":"","text":"一、分布式锁简介锁 是一种用来解决多个执行线程 访问共享资源 错误或数据不一致问题的工具。 如果 把一台服务器比作一个房子，那么 线程就好比里面的住户，当他们想要共同访问一个共享资源，例如厕所的时候，如果厕所门上没有锁…更甚者厕所没装门…这是会出原则性的问题的.. 装上了锁，大家用起来就安心多了，本质也就是 同一时间只允许一个住户使用。 而随着互联网世界的发展，单体应用已经越来越无法满足复杂互联网的高并发需求，转而慢慢朝着分布式方向发展，慢慢进化成了 更大一些的住户。所以同样，我们需要引入分布式锁来解决分布式应用之间访问共享资源的并发问题。 为何需要分布式锁一般情况下，我们使用分布式锁主要有两个场景： 避免不同节点重复相同的工作：比如用户执行了某个操作有可能不同节点会发送多封邮件； 避免破坏数据的正确性：如果两个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现； Java 中实现的常见方式上面我们用简单的比喻说明了锁的本质：同一时间只允许一个用户操作。所以理论上，能够满足这个需求的工具我们都能够使用 (就是其他应用能帮我们加锁的)： 基于 MySQL 中的锁：MySQL 本身有自带的悲观锁 for update 关键字，也可以自己实现悲观/乐观锁来达到目的； 基于 Zookeeper 有序节点：Zookeeper 允许临时创建有序的子节点，这样客户端获取节点列表时，就能够当前子节点列表中的序号判断是否能够获得锁； 基于 Redis 的单线程：由于 Redis 是单线程，所以命令会以串行的方式执行，并且本身提供了像 SETNX(set if not exists) 这样的指令，本身具有互斥性； 每个方案都有各自的优缺点，例如 MySQL 虽然直观理解容易，但是实现起来却需要额外考虑 锁超时、加事务 等，并且性能局限于数据库，诸如此类我们在此不作讨论，重点关注 Redis。 Redis 分布式锁的问题1）锁超时假设现在我们有两台平行的服务 A B，其中 A 服务在 获取锁之后 由于未知神秘力量突然 挂了，那么 B 服务就永远无法获取到锁了： 所以我们需要额外设置一个超时时间，来保证服务的可用性。 但是另一个问题随即而来：如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，也会出现问题。因为这时候第一个线程持有锁过期了，而临界区的逻辑还没有执行完，与此同时第二个线程就提前拥有了这把锁，导致临界区的代码不能得到严格的串行执行。 为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了问题，造成的数据小错乱可能就需要人工的干预。 有一个稍微安全一点的方案是 将锁的 value 值设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 确保当前线程占有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自动释放的。 但是匹配 value 和删除 key 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 保证多个指令的原子性执行。 延伸的讨论：GC 可能引发的安全问题Martin Kleppmann 曾与 Redis 之父 Antirez 就 Redis 实现分布式锁的安全性问题进行过深入的讨论，其中有一个问题就涉及到 GC。 熟悉 Java 的同学肯定对 GC 不陌生，在 GC 的时候会发生 STW(Stop-The-World)，这本身是为了保障垃圾回收器的正常执行，但可能会引发如下的问题： 服务 A 获取了锁并设置了超时时间，但是服务 A 出现了 STW 且时间较长，导致了分布式锁进行了超时释放，在这个期间服务 B 获取到了锁，待服务 A STW 结束之后又恢复了锁，这就导致了 服务 A 和服务 B 同时获取到了锁，这个时候分布式锁就不安全了。 不仅仅局限于 Redis，Zookeeper 和 MySQL 有同样的问题。 想吃更多瓜的童鞋，可以访问下列网站看看 Redis 之父 Antirez 怎么说：http://antirez.com/news/101 2）单点/多点问题如果 Redis 采用单机部署模式，那就意味着当 Redis 故障了，就会导致整个服务不可用。 而如果采用主从模式部署，我们想象一个这样的场景：服务 A 申请到一把锁之后，如果作为主机的 Redis 宕机了，那么 服务 B 在申请锁的时候就会从从机那里获取到这把锁，为了解决这个问题，Redis 作者提出了一种 RedLock 红锁 的算法 (Redission 同 Jedis)： // 三个 Redis 集群 RLock lock1 = redissionInstance1.getLock(\"lock1\"); RLock lock2 = redissionInstance2.getLock(\"lock2\"); RLock lock3 = redissionInstance3.getLock(\"lock3\"); RedissionRedLock lock = new RedissionLock(lock1, lock2, lock2); lock.lock(); // do something.... lock.unlock(); 二、Redis 分布式锁的实现分布式锁类似于 “占坑”，而 SETNX(SET if Not eXists) 指令就是这样的一个操作，只允许被一个客户端占有，我们来看看 源码(t_string.c/setGenericCommand) 吧： // SET/ SETEX/ SETTEX/ SETNX 最底层实现 void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) { long long milliseconds = 0; /* initialized to avoid any harmness warning */ // 如果定义了 key 的过期时间则保存到上面定义的变量中 // 如果过期时间设置错误则返回错误信息 if (expire) { if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK) return; if (milliseconds &lt;= 0) { addReplyErrorFormat(c,\"invalid expire time in %s\",c->cmd->name); return; } if (unit == UNIT_SECONDS) milliseconds *= 1000; } // lookupKeyWrite 函数是为执行写操作而取出 key 的值对象 // 这里的判断条件是： // 1.如果设置了 NX(不存在)，并且在数据库中找到了 key 值 // 2.或者设置了 XX(存在)，并且在数据库中没有找到该 key // => 那么回复 abort_reply 给客户端 if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c->db,key) != NULL) || (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c->db,key) == NULL)) { addReply(c, abort_reply ? abort_reply : shared.null[c->resp]); return; } // 在当前的数据库中设置键为 key 值为 value 的数据 genericSetKey(c->db,key,val,flags &amp; OBJ_SET_KEEPTTL); // 服务器每修改一个 key 后都会修改 dirty 值 server.dirty++; if (expire) setExpire(c,c->db,key,mstime()+milliseconds); notifyKeyspaceEvent(NOTIFY_STRING,\"set\",key,c->db->id); if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC, \"expire\",key,c->db->id); addReply(c, ok_reply ? ok_reply : shared.ok); } 就像上面介绍的那样，其实在之前版本的 Redis 中，由于 SETNX 和 EXPIRE 并不是 原子指令，所以在一起执行会出现问题。 也许你会想到使用 Redis 事务来解决，但在这里不行，因为 EXPIRE 命令依赖于 SETNX 的执行结果，而事务中没有 if-else 的分支逻辑，如果 SETNX 没有抢到锁，EXPIRE 就不应该执行。 为了解决这个疑难问题，Redis 开源社区涌现了许多分布式锁的 library，为了治理这个乱象，后来在 Redis 2.8 的版本中，加入了 SET 指令的扩展参数，使得 SETNX 可以和 EXPIRE 指令一起执行了： > SET lock:test true ex 5 nx OK ... do something critical ... > del lock:test 你只需要符合 SET key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL] 这样的格式就好了，你也在下方右拐参照官方的文档： 官方文档：https://redis.io/commands/set 另外，官方文档也在 SETNX 文档中提到了这样一种思路：把 SETNX 对应 key 的 value 设置为 &lt;current Unix time + lock timeout + 1&gt;，这样在其他客户端访问时就能够自己判断是否能够获取下一个 value 为上述格式的锁了。 代码实现下面用 Jedis 来模拟实现以下，关键代码如下： private static final String LOCK_SUCCESS = \"OK\"; private static final Long RELEASE_SUCCESS = 1L; private static final String SET_IF_NOT_EXIST = \"NX\"; private static final String SET_WITH_EXPIRE_TIME = \"PX\"; @Override public String acquire() { try { // 获取锁的超时时间，超过这个时间则放弃获取锁 long end = System.currentTimeMillis() + acquireTimeout; // 随机生成一个 value String requireToken = UUID.randomUUID().toString(); while (System.currentTimeMillis() &lt; end) { String result = jedis .set(lockKey, requireToken, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) { return requireToken; } try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } catch (Exception e) { log.error(\"acquire lock due to error\", e); } return null; } @Override public boolean release(String identify) { if (identify == null) { return false; } String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; Object result = new Object(); try { result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(identify)); if (RELEASE_SUCCESS.equals(result)) { log.info(\"release lock success, requestToken:{}\", identify); return true; } } catch (Exception e) { log.error(\"release lock due to error\", e); } finally { if (jedis != null) { jedis.close(); } } log.info(\"release lock failed, requestToken:{}, result:{}\", identify, result); return false; } 引用自下方 参考资料 3，其中还有 RedLock 的实现和测试，有兴趣的童鞋可以戳一下 推荐阅读 【官方文档】Distributed locks with Redis - https://redis.io/topics/distlock Redis【入门】就这一篇! - https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/ Redission - Redis Java Client 源码 - https://github.com/redisson/redisson 手写一个 Jedis 以及 JedisPool - https://juejin.im/post/5e5101c46fb9a07cab3a953a 参考资料 再有人问你分布式锁，这篇文章扔给他 - https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-0 【官方文档】Distributed locks with Redis - https://redis.io/topics/distlock 【分布式缓存系列】Redis实现分布式锁的正确姿势 - https://www.cnblogs.com/zhili/p/redisdistributelock.html Redis源码剖析和注释（九）— 字符串命令的实现(t_string) - https://blog.csdn.net/men_wen/article/details/70325566 《Redis 深度历险》 - 钱文品/ 著 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(2)——跳跃表","slug":"Redis-2-——跳跃表","date":"2020-02-29T07:25:00.000Z","updated":"2020-12-09T05:09:37.703Z","comments":true,"path":"2020/02/29/redis-2-tiao-yue-biao/","link":"","permalink":"http://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/","excerpt":"","text":"一、跳跃表简介跳跃表（skiplist）是一种随机化的数据结构，由 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出，是一种可以于平衡树媲美的层次化链表结构——查找、删除、添加等操作都可以在对数期望时间下完成，以下是一个典型的跳跃表例子： 我们在上一篇中提到了 Redis 的五种基本结构中，有一个叫做 有序列表 zset 的数据结构，它类似于 Java 中的 SortedSet 和 HashMap 的结合体，一方面它是一个 set 保证了内部 value 的唯一性，另一方面又可以给每个 value 赋予一个排序的权重值 score，来达到 排序 的目的。 它的内部实现就依赖了一种叫做 「跳跃列表」 的数据结构。 为什么使用跳跃表首先，因为 zset 要支持随机的插入和删除，所以它 不宜使用数组来实现，关于排序问题，我们也很容易就想到 红黑树/ 平衡树 这样的树形结构，为什么 Redis 不使用这样一些结构呢？ 性能考虑： 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 _(下面详细说)_； 实现考虑： 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观； 基于以上的一些考虑，Redis 基于 William Pugh 的论文做出一些改进后采用了 跳跃表 这样的结构。 本质是解决查找问题我们先来看一个普通的链表结构： 我们需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，通常我们会使用 二分查找法，但二分查找是有序数组的，链表没办法进行位置定位，我们除了遍历整个找到第一个比给定数据大的节点为止 （时间复杂度 O(n)) 似乎没有更好的办法。 但假如我们每相邻两个节点之间就增加一个指针，让指针指向下一个节点，如下图： 这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半 _（图中的为 3，11）_。 现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，比如，我们想要查找 7，查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的： 这是一个略微极端的例子，但我们仍然可以看到，通过新增加的指针查找，我们不再需要与链表上的每一个节点逐一进行比较，这样改进之后需要比较的节点数大概只有原来的一半。 利用同样的方式，我们可以在新产生的链表上，继续为每两个相邻的节点增加一个指针，从而产生第三层链表： 在这个新的三层链表结构中，我们试着 查找 13，那么沿着最上层链表首先比较的是 11，发现 11 比 13 小，于是我们就知道只需要到 11 后面继续查找，从而一下子跳过了 11 前面的所有节点。 可以想象，当链表足够长，这样的多层链表结构可以帮助我们跳过很多下层节点，从而加快查找的效率。 更进一步的跳跃表跳跃表 skiplist 就是受到这种多层链表结构的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 _O(logn)_。 但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的 2:1 的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点 （也包括新插入的节点） 重新进行调整，这会让时间复杂度重新蜕化成 _O(n)_。删除数据也有同样的问题。 skiplist 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是 为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个 skiplist 的过程： 从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整，这就降低了插入操作的复杂度。 现在我们假设从我们刚才创建的这个结构中查找 23 这个不存在的数，那么查找路径会如下图： 二、跳跃表的实现Redis 中的跳跃表由 server.h/zskiplistNode 和 server.h/zskiplist 两个结构定义，前者为跳跃表节点，后者则保存了跳跃节点的相关信息，同之前的 集合 list 结构类似，其实只有 zskiplistNode 就可以实现了，但是引入后者是为了更加方便的操作： /* ZSETs use a specialized version of Skiplists */ typedef struct zskiplistNode { // value sds ele; // 分值 double score; // 后退指针 struct zskiplistNode *backward; // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned long span; } level[]; } zskiplistNode; typedef struct zskiplist { // 跳跃表头指针 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level; } zskiplist; 正如文章开头画出来的那张标准的跳跃表那样。 随机层数对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数，源码在 t_zset.c/zslRandomLevel(void) 中被定义： int zslRandomLevel(void) { int level = 1; while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF)) level += 1; return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; } 直观上期望的目标是 50% 的概率被分配到 Level 1，25% 的概率被分配到 Level 2，12.5% 的概率被分配到 Level 3，以此类推…有 2-63 的概率被分配到最顶层，因为这里每一层的晋升率都是 50%。 Redis 跳跃表默认允许最大的层数是 32，被源码中 ZSKIPLIST_MAXLEVEL 定义，当 Level[0] 有 264 个元素时，才能达到 32 层，所以定义 32 完全够用了。 创建跳跃表这个过程比较简单，在源码中的 t_zset.c/zslCreate 中被定义： zskiplist *zslCreate(void) { int j; zskiplist *zsl; // 申请内存空间 zsl = zmalloc(sizeof(*zsl)); // 初始化层数为 1 zsl->level = 1; // 初始化长度为 0 zsl->length = 0; // 创建一个层数为 32，分数为 0，没有 value 值的跳跃表头节点 zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); // 跳跃表头节点初始化 for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) { // 将跳跃表头节点的所有前进指针 forward 设置为 NULL zsl->header->level[j].forward = NULL; // 将跳跃表头节点的所有跨度 span 设置为 0 zsl->header->level[j].span = 0; } // 跳跃表头节点的后退指针 backward 置为 NULL zsl->header->backward = NULL; // 表头指向跳跃表尾节点的指针置为 NULL zsl->tail = NULL; return zsl; } 即执行完之后创建了如下结构的初始化跳跃表： 插入节点实现这几乎是最重要的一段代码了，但总体思路也比较清晰简单，如果理解了上面所说的跳跃表的原理，那么很容易理清楚插入节点时发生的几个动作 （几乎跟链表类似）： 找到当前我需要插入的位置 （其中包括相同 score 时的处理）； 创建新节点，调整前后的指针指向，完成插入； 为了方便阅读，我把源码 t_zset.c/zslInsert 定义的插入函数拆成了几个部分 第一部分：声明需要存储的变量// 存储搜索路径 zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; // 存储经过的节点跨度 unsigned int rank[ZSKIPLIST_MAXLEVEL]; int i, level; 第二部分：搜索当前节点插入位置serverAssert(!isnan(score)); x = zsl->header; // 逐步降级寻找目标节点，得到 \"搜索路径\" for (i = zsl->level-1; i >= 0; i--) { /* store rank that is crossed to reach the insert position */ rank[i] = i == (zsl->level-1) ? 0 : rank[i+1]; // 如果 score 相等，还需要比较 value 值 while (x->level[i].forward &amp;&amp; (x->level[i].forward->score &lt; score || (x->level[i].forward->score == score &amp;&amp; sdscmp(x->level[i].forward->ele,ele) &lt; 0))) { rank[i] += x->level[i].span; x = x->level[i].forward; } // 记录 \"搜索路径\" update[i] = x; } 讨论： 有一种极端的情况，就是跳跃表中的所有 score 值都是一样，zset 的查找性能会不会退化为 O(n) 呢？ 从上面的源码中我们可以发现 zset 的排序元素不只是看 score 值，也会比较 value 值 （字符串比较） 第三部分：生成插入节点/* we assume the element is not already inside, since we allow duplicated * scores, reinserting the same element should never happen since the * caller of zslInsert() should test in the hash table if the element is * already inside or not. */ level = zslRandomLevel(); // 如果随机生成的 level 超过了当前最大 level 需要更新跳跃表的信息 if (level > zsl->level) { for (i = zsl->level; i &lt; level; i++) { rank[i] = 0; update[i] = zsl->header; update[i]->level[i].span = zsl->length; } zsl->level = level; } // 创建新节点 x = zslCreateNode(level,score,ele); 第四部分：重排前向指针for (i = 0; i &lt; level; i++) { x->level[i].forward = update[i]->level[i].forward; update[i]->level[i].forward = x; /* update span covered by update[i] as x is inserted here */ x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]); update[i]->level[i].span = (rank[0] - rank[i]) + 1; } /* increment span for untouched levels */ for (i = level; i &lt; zsl->level; i++) { update[i]->level[i].span++; } 第五部分：重排后向指针并返回x->backward = (update[0] == zsl->header) ? NULL : update[0]; if (x->level[0].forward) x->level[0].forward->backward = x; else zsl->tail = x; zsl->length++; return x; 节点删除实现删除过程由源码中的 t_zset.c/zslDeleteNode 定义，和插入过程类似，都需要先把这个 “搜索路径” 找出来，然后对于每个层的相关节点重排一下前向后向指针，同时还要注意更新一下最高层数 maxLevel，直接放源码 (如果理解了插入这里还是很容易理解的)： /* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */ void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) { int i; for (i = 0; i &lt; zsl->level; i++) { if (update[i]->level[i].forward == x) { update[i]->level[i].span += x->level[i].span - 1; update[i]->level[i].forward = x->level[i].forward; } else { update[i]->level[i].span -= 1; } } if (x->level[0].forward) { x->level[0].forward->backward = x->backward; } else { zsl->tail = x->backward; } while(zsl->level > 1 &amp;&amp; zsl->header->level[zsl->level-1].forward == NULL) zsl->level--; zsl->length--; } /* Delete an element with matching score/element from the skiplist. * The function returns 1 if the node was found and deleted, otherwise * 0 is returned. * * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise * it is not freed (but just unlinked) and *node is set to the node pointer, * so that it is possible for the caller to reuse the node (including the * referenced SDS string at node->ele). */ int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) { zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; int i; x = zsl->header; for (i = zsl->level-1; i >= 0; i--) { while (x->level[i].forward &amp;&amp; (x->level[i].forward->score &lt; score || (x->level[i].forward->score == score &amp;&amp; sdscmp(x->level[i].forward->ele,ele) &lt; 0))) { x = x->level[i].forward; } update[i] = x; } /* We may have multiple elements with the same score, what we need * is to find the element with both the right score and object. */ x = x->level[0].forward; if (x &amp;&amp; score == x->score &amp;&amp; sdscmp(x->ele,ele) == 0) { zslDeleteNode(zsl, x, update); if (!node) zslFreeNode(x); else *node = x; return 1; } return 0; /* not found */ } 节点更新实现当我们调用 ZADD 方法时，如果对应的 value 不存在，那就是插入过程，如果这个 value 已经存在，只是调整一下 score 的值，那就需要走一个更新流程。 假设这个新的 score 值并不会带来排序上的变化，那么就不需要调整位置，直接修改元素的 score 值就可以了，但是如果排序位置改变了，那就需要调整位置，该如何调整呢？ 从源码 t_zset.c/zsetAdd 函数 1350 行左右可以看到，Redis 采用了一个非常简单的策略： /* Remove and re-insert when score changed. */ if (score != curscore) { zobj->ptr = zzlDelete(zobj->ptr,eptr); zobj->ptr = zzlInsert(zobj->ptr,ele,score); *flags |= ZADD_UPDATED; } 把这个元素删除再插入这个，需要经过两次路径搜索，从这一点上来看，Redis 的 ZADD 代码似乎还有进一步优化的空间。 元素排名的实现跳跃表本身是有序的，Redis 在 skiplist 的 forward 指针上进行了优化，给每一个 forward 指针都增加了 span 属性，用来 表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点。在上面的源码中我们也可以看到 Redis 在插入、删除操作时都会小心翼翼地更新 span 值的大小。 所以，沿着 “搜索路径”，把所有经过节点的跨度 span 值进行累加就可以算出当前元素的最终 rank 值了： /* Find the rank for an element by both score and key. * Returns 0 when the element cannot be found, rank otherwise. * Note that the rank is 1-based due to the span of zsl->header to the * first element. */ unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) { zskiplistNode *x; unsigned long rank = 0; int i; x = zsl->header; for (i = zsl->level-1; i >= 0; i--) { while (x->level[i].forward &amp;&amp; (x->level[i].forward->score &lt; score || (x->level[i].forward->score == score &amp;&amp; sdscmp(x->level[i].forward->ele,ele) &lt;= 0))) { // span 累加 rank += x->level[i].span; x = x->level[i].forward; } /* x might be equal to zsl->header, so test if obj is non-NULL */ if (x->ele &amp;&amp; sdscmp(x->ele,ele) == 0) { return rank; } } return 0; } 扩展阅读 跳跃表 Skip List 的原理和实现（Java） - https://blog.csdn.net/DERRANTCM/article/details/79063312 【算法导论33】跳跃表（Skip list）原理与java实现 - https://blog.csdn.net/brillianteagle/article/details/52206261 参考资料 《Redis 设计与实现》 - http://redisbook.com/ 【官方文档】Redis 数据类型介绍 - http://www.redis.cn/topics/data-types-intro.html 《Redis 深度历险》 - https://book.douban.com/subject/30386804/ Redis 源码 - https://github.com/antirez/redis Redis 快速入门 - 易百教程 - https://www.yiibai.com/redis/redis_quick_guide.html Redis【入门】就这一篇! - https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/ Redis为什么用跳表而不用平衡树？ - https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261425&amp;idx=1&amp;sn=d840079ea35875a8c8e02d9b3e44cf95&amp;scene=21#wechat_redirect 为啥 redis 使用跳表(skiplist)而不是使用 red-black？ - 知乎@于康 - https://www.zhihu.com/question/20202931 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，个人独立域名博客：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"Redis(1)——5种基本数据结构","slug":"Redis-1-——5种基本数据结构","date":"2020-02-28T13:57:00.000Z","updated":"2021-01-05T07:07:29.415Z","comments":true,"path":"2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/","link":"","permalink":"http://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/","excerpt":"","text":"一、Redis 简介 “Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.” —— Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 (摘自官网) Redis 是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的 Web 应用程序。Redis 也被作者戏称为 数据结构服务器 ，这意味着使用者可以通过一些命令，基于带有 TCP 套接字的简单 服务器-客户端 协议来访问一组 可变数据结构 。(在 Redis 中都采用键值对的方式，只不过对应的数据结构不一样罢了) Redis 的优点以下是 Redis 的一些优点： 异常快 - Redis 非常快，每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。 支持丰富的数据类型 - Redis 支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得 Redis 很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。 操作具有原子性 - 所有 Redis 操作都是原子操作，这确保如果两个客户端并发访问，Redis 服务器能接收更新的值。 多实用工具 - Redis 是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis 本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。 Redis 的安装这一步比较简单，你可以在网上搜到许多满意的教程，这里就不再赘述。 给一个菜鸟教程的安装教程用作参考：https://www.runoob.com/redis/redis-install.html 测试本地 Redis 性能当你安装完成之后，你可以先执行 redis-server 让 Redis 启动起来，然后运行命令 redis-benchmark -n 100000 -q 来检测本地同时执行 10 万个请求时的性能： 当然不同电脑之间由于各方面的原因会存在性能差距，这个测试您可以权当是一种 「乐趣」 就好。 二、Redis 五种基本数据结构Redis 有 5 种基础数据结构，它们分别是：string(字符串)、list(列表)、hash(字典)、set(集合) 和 zset(有序集合)。这 5 种是 Redis 相关知识中最基础、最重要的部分，下面我们结合源码以及一些实践来给大家分别讲解一下。 1）字符串 stringRedis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组，从源码的 sds.h/sdshdr 文件 中可以看到 Redis 底层对于字符串的定义 SDS，即 Simple Dynamic String 结构： /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 你会发现同样一组结构 Redis 使用泛型定义了好多次，为什么不直接使用 int 类型呢？ 因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。 SDS 与 C 字符串的区别为什么不考虑直接使用 C 语言的字符串呢？因为 C 语言这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。我们知道，C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 &#39;\\0&#39;。(下图就展示了 C 语言中值为 “Redis” 的一个字符数组) 这样简单的数据结构可能会造成以下一些问题： 获取字符串长度为 O(N) 级别的操作 → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组； 不能很好的杜绝 缓冲区溢出/内存泄漏 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题； C 字符串 只能保存文本数据 → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 &#39;\\0&#39; 可能会被判定为提前结束的字符串而识别不了； 我们以追加字符串的操作举例，Redis 源码如下： /* Append the specified binary-safe string pointed by 't' of 'len' bytes to the * end of the specified sds string 's'. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { // 获取原字符串的长度 size_t curlen = sdslen(s); // 按需调整空间，如果容量不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中 s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; // 内存不足 memcpy(s+curlen, t, len); // 追加目标字符串到字节数组中 sdssetlen(s, curlen+len); // 设置追加后的长度 s[curlen+len] = '\\0'; // 让字符串以 \\0 结尾，便于调试打印 return s; } 注：Redis 规定了字符串的长度不得超过 512 MB。 对字符串的基本操作安装好 Redis，我们可以使用 redis-cli 来对 Redis 进行命令行的操作，当然 Redis 官方也提供了在线的调试器，你也可以在里面敲入命令进行操作：http://try.redis.io/#run 设置和获取键值对> SET key value OK > GET key \"value\" 正如你看到的，我们通常使用 SET 和 GET 来设置和获取字符串值。 值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 .jpeg 图片，只需要注意不要超过 512 MB 的最大限度就好了。 当 key 存在时，SET 命令会覆盖掉你上一次设置的值： > SET key newValue OK > GET key \"newValue\" 另外你还可以使用 EXISTS 和 DEL 关键字来查询是否存在和删除键值对： > EXISTS key (integer) 1 > DEL key (integer) 1 > GET key (nil) 批量设置键值对> SET key1 value1 OK > SET key2 value2 OK > MGET key1 key2 key3 # 返回一个列表 1) \"value1\" 2) \"value2\" 3) (nil) > MSET key1 value1 key2 value2 > MGET key1 key2 1) \"value1\" 2) \"value2\" 过期和 SET 命令扩展可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。(过期可以是任意数据结构) > SET key value1 > GET key \"value1\" > EXPIRE name 5 # 5s 后过期 ... # 等待 5s > GET key (nil) 等价于 SET + EXPIRE 的 SETEX 命令： > SETEX key value1 ... # 等待 5s 后获取 > GET key (nil) > SETEX key value1 # 如果 key 不存在则 SET 成功 (integer) 1 > SETEX key value1 # 如果 key 存在则 SET 失败 (integer) 0 > GET key \"value\" # 没有改变 计数如果 value 是一个整数，还可以对它使用 INCR 命令进行 原子性 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况： > SET counter 100 > INCR count (interger) 101 > INCRBY counter 50 (integer) 151 返回原值的 GETSET 命令对字符串，还有一个 GETSET 比较让人觉得有意思，它的功能跟它名字一样：为 key 设置一个值并返回原值： > SET key value > GETSET key value1 \"value\" 这可以对于某一些需要隔一段时间就统计的 key 很方便的设置和查看，例如：系统每当由用户进入的时候你就是用 INCR 命令操作一个 key，当需要统计时候你就把这个 key 使用 GETSET 命令重新赋值为 0，这样就达到了统计的目的。 2）列表 listRedis 的列表相当于 Java 语言中的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。 我们可以从源码的 adlist.h/listNode 来看到对其的定义： /* Node, List, and Iterator are the only data structures used currently. */ typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; typedef struct listIter { listNode *next; int direction; } listIter; typedef struct list { listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len; } list; 可以看到，多个 listNode 可以通过 prev 和 next 指针组成双向链表： 虽然仅仅使用多个 listNode 结构就可以组成链表，但是使用 adlist.h/list 结构来持有链表的话，操作起来会更加方便： 链表的基本操作 LPUSH 和 RPUSH 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素； LRANGE 命令可以从 list 中取出一定范围的元素； LINDEX 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 get(int index) 操作； 示范： > rpush mylist A (integer) 1 > rpush mylist B (integer) 2 > lpush mylist first (integer) 3 > lrange mylist 0 -1 # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有 1) \"first\" 2) \"A\" 3) \"B\" list 实现队列队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序： > RPUSH books python java golang (integer) 3 > LPOP books \"python\" > LPOP books \"java\" > LPOP books \"golang\" > LPOP books (nil) list 实现栈栈是先进后出的数据结构，跟队列正好相反： > RPUSH books python java golang > RPOP books \"golang\" > RPOP books \"java\" > RPOP books \"python\" > RPOP books (nil) 3）字典 hashRedis 中的字典相当于 Java 中的 HashMap，内部实现也差不多类似，都是通过 “数组 + 链表” 的链地址法来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。源码定义如 dict.h/dictht 定义： typedef struct dictht { // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值，总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used; } dictht; typedef struct dict { dictType *type; void *privdata; // 内部有两个 dictht 结构 dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */ } dict; table 属性是一个数组，数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针，而每个 dictEntry 结构保存着一个键值对： typedef struct dictEntry { // 键 void *key; // 值 union { void *val; uint64_t u64; int64_t s64; double d; } v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry; 可以从上面的源码中看到，实际上字典结构的内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 渐进式搬迁 (下面说原因)。 渐进式 rehash大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 小步搬迁： 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。 扩缩容的条件正常情况下，当 hash 表中 元素的个数等于第一维数组的长度时，就会开始扩容，扩容的新数组是 原数组大小的 2 倍。不过如果 Redis 正在做 bgsave(持久化命令)，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，达到了第一维数组长度的 5 倍了，这个时候就会 强制扩容。 当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 元素个数低于数组长度的 10%，缩容不会考虑 Redis 是否在做 bgsave。 字典的基本操作hash 也有缺点，hash 结构的存储消耗要高于单个字符串，所以到底该使用 hash 还是字符串，需要根据实际情况再三权衡： > HSET books java \"think in java\" # 命令行的字符串如果包含空格则需要使用引号包裹 (integer) 1 > HSET books python \"python cookbook\" (integer) 1 > HGETALL books # key 和 value 间隔出现 1) \"java\" 2) \"think in java\" 3) \"python\" 4) \"python cookbook\" > HGET books java \"think in java\" > HSET books java \"head first java\" (integer) 0 # 因为是更新操作，所以返回 0 > HMSET books java \"effetive java\" python \"learning python\" # 批量操作 OK 4）集合 setRedis 的集合相当于 Java 语言中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。 集合 set 的基本使用由于该结构比较简单，我们直接来看看是如何使用的： > SADD books java (integer) 1 > SADD books java # 重复 (integer) 0 > SADD books python golang (integer) 2 > SMEMBERS books # 注意顺序，set 是无序的 1) \"java\" 2) \"python\" 3) \"golang\" > SISMEMBER books java # 查询某个 value 是否存在，相当于 contains (integer) 1 > SCARD books # 获取长度 (integer) 3 > SPOP books # 弹出一个 \"java\" 5）有序列表 zset这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。 它的内部实现用的是一种叫做 「跳跃表」 的数据结构，由于比较复杂，所以在这里简单提一下原理就好了： 想象你是一家创业公司的老板，刚开始只有几个人，大家都平起平坐。后来随着公司的发展，人数越来越多，团队沟通成本逐渐增加，渐渐地引入了组长制，对团队进行划分，于是有一些人又是员工又有组长的身份。 再后来，公司规模进一步扩大，公司需要再进入一个层级：部门。于是每个部门又会从组长中推举一位选出部长。 跳跃表就类似于这样的机制，最下面一层所有的元素都会串起来，都是员工，然后每隔几个元素就会挑选出一个代表，再把这几个代表使用另外一级指针串起来。然后再在这些代表里面挑出二级代表，再串起来。最终形成了一个金字塔的结构。 想一下你目前所在的地理位置：亚洲 &gt; 中国 &gt; 某省 &gt; 某市 &gt; ….，就是这样一个结构！ 有序列表 zset 基础操作> ZADD books 9.0 \"think in java\" > ZADD books 8.9 \"java concurrency\" > ZADD books 8.6 \"java cookbook\" > ZRANGE books 0 -1 # 按 score 排序列出，参数区间为排名范围 1) \"java cookbook\" 2) \"java concurrency\" 3) \"think in java\" > ZREVRANGE books 0 -1 # 按 score 逆序列出，参数区间为排名范围 1) \"think in java\" 2) \"java concurrency\" 3) \"java cookbook\" > ZCARD books # 相当于 count() (integer) 3 > ZSCORE books \"java concurrency\" # 获取指定 value 的 score \"8.9000000000000004\" # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题 > ZRANK books \"java concurrency\" # 排名 (integer) 1 > ZRANGEBYSCORE books 0 8.91 # 根据分值区间遍历 zset 1) \"java cookbook\" 2) \"java concurrency\" > ZRANGEBYSCORE books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。 1) \"java cookbook\" 2) \"8.5999999999999996\" 3) \"java concurrency\" 4) \"8.9000000000000004\" > ZREM books \"java concurrency\" # 删除 value (integer) 1 > ZRANGE books 0 -1 1) \"java cookbook\" 2) \"think in java\" 扩展/相关阅读 阿里云 Redis 开发规范 - https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px 为什么要防止 bigkey？ - https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;mid=2247483677&amp;idx=1&amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;scene=21#wechat_redirect Redis【入门】就这一篇！ - https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/ 参考资料 《Redis 设计与实现》 - http://redisbook.com/ 【官方文档】Redis 数据类型介绍 - http://www.redis.cn/topics/data-types-intro.html 《Redis 深度历险》 - https://book.douban.com/subject/30386804/ 阿里云 Redis 开发规范 - https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px Redis 快速入门 - 易百教程 - https://www.yiibai.com/redis/redis_quick_guide.html Redis【入门】就这一篇! - https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/ 本文已收录至我的 Github 程序员成长系列 【More Than Java】，学习，不止 Code，欢迎 star：https://github.com/wmyskxz/MoreThanJava 个人公众号 ：wmyskxz，坚持原创输出，下方扫码关注，2020，与您共同成长！ 非常感谢各位人才能 看到这里，如果觉得本篇文章写得不错，觉得 「我没有三颗心脏」有点东西 的话，求点赞，求关注，求分享，求留言！ 创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"【人类观察所】\"当代人\"正经历的生活","slug":"【人类观察所】\"当代人\"正经历的生活","date":"2020-02-22T04:49:00.000Z","updated":"2020-12-09T04:50:43.730Z","comments":true,"path":"2020/02/22/ren-lei-guan-cha-suo-dang-dai-ren-zheng-jing-li-de-sheng-huo/","link":"","permalink":"http://www.wmyskxz.com/2020/02/22/ren-lei-guan-cha-suo-dang-dai-ren-zheng-jing-li-de-sheng-huo/","excerpt":"","text":"一、”即时满足”的互联网 “轻微烦躁，偶尔自燃，当代生活多数时刻的心情基调。” 如果你出生于上个世纪，应该能明白木心的《从前慢》里的 「从前的日色变得慢，车、马、邮件都慢」 这种情怀是从何而来，但如果你是一位出生在互联网时代的 「网络原住民」，对这首诗里形容的生活，你很可能已经彻底失去了感受它的机会。 买东西有快递，吃饭叫外卖，上网靠智能手机，工作用电脑，一切都随时供应、立等可取。只要是技术能解决的问题，没有什么需要你等太久。 一个在最近几年相当常见的讨论是，互联网时代的人们是不是变得越来越没耐心了。不管是 「IWWIWWIWI（I want what I want when I want it）」，或是 「注意力不足症（Attention Deficit Disorder）」，以及 「Culture of Impatience（不耐烦文化）」，都是对这种趋势下人类心态变化的担忧。 这种担忧确实不无道理：手机读文章「太长不看（TLDR，too long, didn’t read）」，所以有了标题党；流媒体时代听众听歌切歌都很方便，导致流行歌曲的长度也跟着缩短；根据哥伦比亚大学 2009 年的研究，网站速度快 1 毫秒，每年带来的收益可以超过一亿美元。 假如说互联网真有什么永远不变的趋势的话，“快，而且越来越快”大概是最明显的答案。 「即时满足」 和 「延迟满足」 这对概念最早来自学术界，现在则往往被拿来探讨人和互联网的关系。按照深谙心理学的产品设计者们的观点，人类天性就是热爱即时满足、讨厌等待的，只是囿于时间空间所以被迫克制而已。从这个角度说，我们并不是「变得」没耐心了，而是本来就没啥耐心，被高速互联网改变了心理期待之后，逮着了机会把「没耐心」发挥到方方面面而已：有了「用秒计算」的预期之后，再回头看「以天为单位」当然不能忍。长久以来人类习惯了「春种是为了秋收」的延迟满足，现在互联网终于又让我们重返采集时代原始的快乐：「点一下手机屏幕就获得一次响应（Click-treat）」的微小满足感，跟「摘到一个果子就吃一个」也没啥区别。善于取悦用户的商家，就是这么一点点惯坏我们的。 但是注意了，我们提到这些，并不等于在说「当代社会越来越浮躁」。「浮躁」这个指控毕竟有点大，超过了我们本次讨论的范围。我们也不支持把「即时满足」和「延迟满足」对立起来，将前者单纯地理解成目光短浅或耽于享乐。我们只能谨慎地将现状陈述为「生活容错率在变低」：人们对众多环节的心理耗时都在缩短，任何与想象不符的细节，都有可能会引发不耐烦。 所以，在使用互联网的时候，当代人的耐心一般能坚持多久呢？ 10 个跟耐心有关的数字30 秒： 在调研公司 Onepoll 的一项关于网购体验的调查中，有一半的受访者表示，只要付款流程持续超过半分钟，他们就可能会失去耐心。1/4 的人会中止在重新输入地址这个环节，1/3 的人则会在重输信用卡信息的时候放弃购买。 15 秒：根据网站设计公司 Go-gulf，在互联网上，55% 的页面得到的关注时间都不超过 15 秒。人们在浏览网页时的平均注意力时长，从 2000 年的 12 秒降低到了今年的 8 秒。 20%：同样来自 Go-gulf，当人们浏览网页的时候，平均只会看其中大约 20% 的内容，一篇文章只有 10-20% 的人会滑到最后读完。 2 秒：2012 年，一项来自马萨诸塞大学阿默斯特分校的研究发现，在线视频缓冲时间只要超过 2 秒，人们就会开始不耐烦。网速快的用户愿意等待的加载时间，比网速慢的用户还要更短一些。 6 秒：YouTube 在移动客户端上的贴片广告时长。YouTube 从去年开始力推 6 秒广告产品，用来取代原来的 30 秒时长的贴片广告。 3.5 分钟：Billboard 的统计显示，单曲榜中歌曲的时长中位数在 2000 年是 4 分 6 秒，2010 年是 3 分 40 多秒，今年进一步下降到了 3 分 31 秒，18 年间缩短了 35 秒。 5 秒：Spotify 在 2014 年的一项报告显示，21% 的歌曲在播放 5 秒后就会被切歌。在我所发起的开放式调查“你有哪些听歌习惯”中，排名第一位的表态也是“一边用随机播放或猜你喜欢，一边不断点击跳过”。 10 秒：为了抓住听众的注意，歌曲的前奏也在变短。2017 年，音乐心理学期刊 Musicae Scientiae 上的一篇研究分析了 303 首热门单曲后得出结论，1980 年代歌曲的前奏普遍超过 20 秒，现在只有 10 秒不到。 1 个单词：调研公司 priceonomics 前年观察了 Billboard Hot 100 榜单的历年数据，发现歌名长度只有一个单词的歌曲出现在榜单中的概率是 60 年代的 2.5 倍，与此同时，歌曲名字的平均字数相比 60 年代也有了大幅下降。 几个小时：来自 Yougov 今年的调查。对于“如果不算上工作中必须打开手机的情况，你可以多久不看手机”这个问题，31% 的人选的是“几个小时”，这个答案的比例最高。17% 的人说“可以度过一整天”，只有 13% 的人赞同“没手机也可以过上好几天”。 看上去，现如今我们的等待门槛确实变高了一些，每一个珍贵的停留时间，几乎都可以用秒来计算。 3 个即时满足时代出现的新问题当然了，「即时满足」的生活方式不仅永远改变了我们的平均耐心水平，还带来了几个跟它有关的新问题： 1. 知识越来越易得，“即时学习”对我们来说是好事吗？ 搜索引擎、电子书、知识付费、公众号、问答 app、“一分钟学会xxx”式教程，每个都在致力于让缺乏耐心的人们“更便利、更即时地获得知识”。但是，就像那句“买书不如借书”的调侃一样，知识唾手可得，你真的会因此更热爱知识，还是会觉得它们就像自热食品一样快捷迅速却不得真味？又或者，你确实通过它们获得了大量二手知识，但你又如何保证，你对它们的习惯性信任不会让自己形成「没有答案可抄就不会写作业」的习惯性无助呢？ 2. “即时响应”的社交媒体，能让谈对象这事儿变得容易些吗？ 我们通过社交网络表达的内容和形式越来越复杂（聊天/屏蔽/拉黑/隐身……），越来越习惯隔着屏幕交流，再加上各式各样的娱乐占据了本就我们不多的注意力，在这种情况下，需要培养的、「非即时」的亲密关系还算人生必须品吗？如果有一天 AI 成为了人类的「即时伴侣」，我们还需要耗费耐心去跟人谈对象吗？ 3. 工作越来越「即时化」，我们会不会彻底「社畜化」？ 如果说过去你还可以借下班和休假为由逃避工作的话，现在大概是彻底不可能了，即时通讯让你走到哪里都可以开会、谈公事、回邮件，除非断网断电，否则你的工作跟生活基本上就是无界的。自由职业、在家办公、远程办公、弹性工作……上班可以采取任何形式、被搬到任何地方。当代人的休息时间本就所剩无几，讲究效率、「即时反馈」的工作方式会不会让我们进一步变成工作的奴隶呢？ 总的来说，在越来越快的当代生活，等待确实是正在一点点地、有意无意地让步于速度。但我们并不能因此指责彼此的没耐心，毕竟为即时满足而愉悦的是我们，为它所苦的也是我们。 基于此，你能稍稍提醒自己的就是，没耐心无可厚非，但也得用对了地方，一边说「我一秒都等不了」，一边用拖延症浪费光阴的自相矛盾少一点，你在这个并不友好的世界能获得的耐心和时间，或许就可以多一些。 二、不经意过上的”二手人生” “当你发现，你生活里的所有问题，在网上都能找到答案，这也就意味着，你的整个生活，别人已经过过了。” 二手人生是这样一种处境：你发现你在生活里遇到的所有问题，在搜索引擎里都能找到答案。 比如说，怎么搭配衣服才低调优雅，去哪吃饭便宜又美味，买哪款耳机更划算，工作还是考研，要不要入手比特币，都有人替你解答了。你还发现有一批人用照片、视频、段子、广告为你提供了一个精心加工过的世界，这个世界常常比你自个儿的世界要美丽有趣深刻好笑有品位得多。如果把当代生活比作一场开卷考，比起你自己慢慢找答案，达人们已经为你提供了一套高分答案放到你面前让你参考。 注意，你很有可能连这些高分答案也看不上，但那多半建立在你已经对生活的这些乱七八糟的细节有所思虑的基础上，只不过你还没得出属于自己的明确结论。更有可能的是，你觉得思虑本身就乱七八糟的，所以毫无警惕地接受了高分答案。 或者不是高分答案也没关系。反正「关于这件事他们都是这样说的」。 让我们假设一种听起来有点悲伤的状况：你买的东西是点评分数最高的、看的书是大 V 的推荐、拍照用的是 Instagram 博主的 pose、旅游去的是「不能错过的 20 个打卡圣地」、情人节买的礼物是知乎搜出的「最适合送男朋友的礼物」，你的观点是从别人「如何看待某件事」来看待某件事，你的体验是按照别人「告诉你是一种怎样的体验」去体验的。你养成了一个学生式习惯，当生活给你发了一份新卷子，你的第一反应就是先翻到网上，去看参考答案。 悲伤吗？有一种新的悲伤是你不觉得以上这些有什么可悲伤的。 我们大多数人对「地球是圆的」深信不疑，因为课本这么写，权威专家给的证据这么说，因为我们对课本和权威专家，有经过理性思考后的习惯性信任。后来这种信任用在了市场上的品牌商家，他们提供标准化服务，准确得就像宇宙定理一样不被怀疑，你随手打开任意一罐自动售货机买的可口可乐，都能毫无戒心地灌进肚子，既不会担心有毒也不会惊讶于它有冲鼻的气泡。现在这种信任习惯被延伸到各种测评排行榜、豆瓣评分、淘宝买家秀、Instagram 博主、知乎大 V，他们告诉你世界是什么样的，经历生活是一种怎样的体验，怎么经历生活才是最明智的，他们为你拼凑出了一个经过筛选的人生样本，照着做就行。 法国学者居依·德波在《景观社会》一书里，把景观描述成「通过影像主导的新型社会关系」，在景观社会里，商品的关系取代人的关系。人们因为对景观的迷入而丧失自己对真正生活的渴望和要求。德波认为观众自己没有思考，屈从于看到的景观，当他预期得越多他生活得就越少；他对影像认同得越多，他对自己的生存和欲望就理解得越少。个人的姿势不再是他自己的，而是展示这些姿势给他看的另外一个人的。 提请各位注意，此处罗列这些，并不意味着本文对生活持有一种不可知论的态度（人人说话都是为了自己的利益，根本没人说的是真的），也绝不意味着我们提倡摒弃一切经验，盲目无畏开创自我（比如「豆瓣什么的评分我根本不信，别人说烂片我就要去看一看是不是有人故意抹黑」）。我们只是对生活为何千篇一律提出一种微弱的警告——你在过自己的日子，还在过别人希望你过的日子（同时还花着你的钱）？ 二手个性 | 个体天生的差别是怎么丧失了的 所谓的「个性」，原本是一个荒唐的字眼，每个人对于他人而言，本来就是截然不同的个体，差别是天然存在的。但人们又十分迫切地需要个性。对差异化的个性越推崇，就越说明了我们同质化的严重。 法国学者让·鲍德里亚在《消费社会》里认为，人们追求「个性」，其实只是消极接受一种符号，让自己进入或脱离某个集团。「物品」不再具有本来的意义，而只是一种可供消费的社会符号。 消费社会的如今，人们早已经习惯出让部分自我给物品，让物品替你完成部分人生。 你穿日系优衣库还是韩系东大门，你戴着小米手环还是 Apple Watch，你的书架上是郭敬明还是爱丽丝门罗，都在替你说明你是什么样的人。你的个性是可以被你拥有的标准化物品定义的，仅仅是「衣柜里全是优衣库」、「书架上摆着郭敬明全集」可能就会让你位列某种「鄙视链」下游。也就意味着，在这个评价体系里，你和所有「衣柜里全是优衣库」、「书架上摆着郭敬明全集」的人有相同的个性。 你的独特性，因为买的东西而消失了。 奇怪的是，我们不屑于与他人为伍，却又害怕与众不同。 随处可见的鄙视链向我们表明了一个事实：人们对个性并没有那么宽容。如今所谓的个性，都源自小众，因为小众就意味着「跟大多数人不一样」，但小众本身就必须在「小众内部」足够大众，一个人是不能称为小众的。也就是说，「个性」必须至少满足小众的期待。当保持身材成为品质生活的普遍标准时，不健身就是生活未达标，构成了人们深层的负罪感，在健身成为政治正确的情形下，你是没有不健身个性的。 此外，消费社会讲究 Customer first，于是有了「个性化定制」，常常以「猜你喜欢」的变体出现。但本质上也是在把你分门别类，加强你原本就和数据库里其他相似样本的偏好。 也就是说，你的「独特」正在变得跟另外和你相似的「独特」越来越像。 二手感情 | 人们对经验的渴望胜过了对真理的追问 信息时代的潮流，是所有需要自己亲身体验和摸索的事，都先去查查攻略和经验，爱情也不例外，怎么约会怎么恋爱怎么维持怎么复合什么时候分手，别人都写着呢。 齐格蒙·鲍曼在《工作、消费、新穷人》中认为，对市场的依赖，破坏了人们社交能力的培养，恋爱关系变得短暂易变，人们只能求助于市场的货物、服务和专家的意见。情侣们迫切地希望通过礼物、情侣套餐和恋爱课来解决亲密关系中出现的问题，本质上是为了降低婚恋中出现的种种不确定性，最好有一套标准化的公式来指导，实际操作时套用就行了。于是心理学上的各种效应就在恋爱秘籍中格外受欢迎。这也是为什么 ayawawa 的「理论」看起来荒谬无比，却仍有大量市场。 人们找对象，不可避免地会用一些指标来描述对方，和以往不同的是，人们更少地用「勇敢、善良、正直」这类品格词汇，因为不容易量化，市场导向下「才华、美丽、职业、年薪」，这类资源和（能转化为资源的）能力词汇更常称为择偶标准。为了要找一个爱自己的人，得拼命提升自己的被爱的资本：男人要有更多的财富，女人要有更苗条的身材。爱情由一张清单组成，一式七项，一项项打钩评分，最后找一个综测分数高的，大家组成一个 team，来完成婚姻这个大项目。 此外，并不只是你照本宣科地参与爱情，你的恋爱对象也在这套系统里，你们按照该有的剧本，约会、吃饭、看电影，第一次吃什么，第二次去哪儿，对对方的恋爱技巧莞尔一笑。 二手态度 | 他们给了几个阵营，你只要站队就行 在互联网社会里，你常常绞尽脑汁想出的一个道理一个创意，网上一查，别人早就发现了。术业有专攻，与其自己去思考，上网看看领域里专家的观点显然要来得更有性价比。 一有事件发生，你习惯性地第一时间到知乎上看大 V 们是如何评价的，一篇文章没看完就拉到底部看看网友的留言是怎么评论的。与其自己思考，转发大 V 替你发表态度，要来得轻松许多。当这种依赖成为惯性，就容易把观点当做理所当然的事实。态度常常以这样的形式出现：他们给了几个阵营，你只要站队就行了。 二手体验 | “毕竟，人类的本质是复读机” 二手人生和好奇心的区别在于：好奇心是想要知道更多的东西，二手人生则是完全服从于这些东西。 当你去看别人「去冰岛旅行是一种怎样的体验」、「交一个日本女朋友是一种怎样的体验」、「到A餐厅就餐是一种怎样的体验」时，你可以出于想知道别人的生活是什么样的，但如果你恰好要去冰岛旅行、交了一个日本女朋友，或是要去 A 餐厅吃饭当你看过他人的经历时，你会下意识地按照他的体验来执行。当他说 A 餐厅的屋檐花纹好看，你进餐厅时就会去注意屋檐上的花纹，不伦你是否觉得好看，你都在按照他的体验来体验。 而当你发现，他们描绘的那种体验，要比你独自去摸索要来得更精彩时，你会很容易按照他们给的角度去冰岛，去和日本女朋友相处。在相处的过程中，可能连情话，也是从抖音上复制下来的网络流行语。 毕竟，「人类的本质就是复读机。」 三、互联网友谊 “互联网友谊并不完全是线下友谊的 online 版本，而是发展出了一套独立的体系。” 自打手机变成生活必需品之后，任何形式的关系，基本上都可以在一定程度上依托网络而存在。从未谋面的陌生人，可能前一天还跟你在某个种草帖里以兄弟/姐妹相称；楼下小卖部的老板，也许是你金钱来往最多的支付宝好友；十年没联系的老同学，说不定与你同在一个微信群里默默潜水。在鸡犬相闻的互联网时代，「找到并了解一个人」变得前所未有地容易。从这个角度说，有了网络之后，人与人之间的距离，是变得更「近」了一点的。 社会学家说，友谊的发生有三个要素：距离上的接近、非计划性的重复接触，以及可以放下防备的交流机会。线下友谊因为「人情」的成分更高，所以往往生发于某种固有关系（比如同学和同事）；但互联网友谊不再完全遵从这条定律，物理上的距离基本上已经不成问题，「表态」反而成了交友成功的唯一前提。在线下，你可以依赖外界环境帮你找朋友，但在手机里，不发 Emoji 和 哈哈哈 就表达不出你的友好：因为没有了实体，所以必须有相应的言语/行为来代替，也就是所谓的 「You are what you say」。 网络承载了每个人的好恶、倾向、意见，排列取舍一下就是可以出厂运行的虚拟人格。「你们有 n 个爱好相同」、「你们在 xx 个问题上观点一致」、「你们同时拉黑了某某某」，确实都很能给人「我俩气味相投」的感觉。但是，表态从线下转移到线上，必然带着一定程度的损耗和失真。毕竟自拍可以修图，朋友圈可以屏蔽，动态可以分组展示，只要经营得当，每个人都可以大隐隐于市，在不同的地方让不同的人知道不同的事情。 在此基础上，新的友谊形式对当代人提出了不少新考验：互联网上有态可表的事情太多，多到「前一刻让你发现一个人的闪光点骤生好感，下一刻就让你看到 ta 的另一番言论而瞬间幻灭」。倘若对方几乎所有的表态都符合你的心意，唯独在某一件事上击穿了你的底线，这友谊还要不要继续下去？又或者，再功利一点，如果没有线下的交集作为依托，仅有线上交情的友谊，会不会因为「反正也没付出太多成本」，所以放弃起来也更加得心应手？ 这个现状可以用一个最近的流行词「蹦迪型社交」来概括，它的大意是社交聚落就像迪厅，而我们的目的就是「赶场子」，虽然看上去热闹非凡，但绝大部分人的关系只会停留在低成本的「日抛」阶段。The Conversation 在之前的一篇文章里同样表达了类似的观点：旧的社交礼仪比较单线程，就像一对一、面对面的交流，对方问你什么，你就得当场做出回答，一言不发/拂袖而去的成本很高；然而无需见面的即时通讯彻底改变了这些所谓的「契约」，你可以同时跟许多人互动，也可以随手取关/拉黑/卸载，无视和悬置成为常态，几乎没有什么明显的后果需要你承担。 如果把友谊同样理解成某种亲密关系的话，你可能会发现，其实它也面临着不少相似的困境：旧的「社交礼仪」正在瓦解，但新的社交规则却没有成型（「规则」只是一种方便的说法，实际上它们到底能不能被称为规则都值得商榷）。一辈子待一个工作单位、认识同一拨街坊邻居的「强关系」早已不再是刚需，「轻量级关系」才是主流。网线背后人人平等，别人无法阻止你在微信装死不回，就像你也没有办法命令（除下属之外的）另一个人在 30 秒之内必须回复你一样。 所以，互联网让人际关系变得「塑料」了吗？好像……也有那么一点儿。但友情本来就是自我的投射和巩固，如果不是网络让我们一瞥这拥有无限种可能的美丽新世界，我们连借助这轻松愉快、允许试错的「迪厅式社交」放飞自我的机会都没有。毕竟网络情谊再怎么淡如水，总归还是比递烟拼酒的传统美德要更适配当代人一点的。 四、当代生活定律 “关于当代生活真相的观察，都在这些定律和理论里面了。” 袜子量子力学： 家里的袜子总是以量子状态存在，即它们可能随时出现在屋里任何位置。并且会发生量子纠缠，即不论距离多远，一只袜子破了/丢了另外一只也跟着失效了。打破这一规律的诀窍在于，买很多只一样的袜子。 网购能量守恒定律： 指，以在网上甄别真假的时间精力来弥补网购可以足不出户省下的时间精力。虽说电商无疑让消费更快速更便捷，但因为不能实现“所见即所得”，因此足不出户省下的时间和精力，都被真假难辨的卖家秀和复杂的折扣数学题给抵消了。 刷新相对论 ： 你在网站/app上点击“刷新”的频率越高，新内容出现的频率就越低。 反向巴纳姆效应： 互联网上一种“此地无银三百两”型言论，当评论“我不是杠、没有黑的意思”时，多半就是在抬杠；“纯路人、不吹不黑”的后面评论的八成是站队言论；“我这是为你好”，其实是自己说出来爽了就好了。 社交媒体熵增定律： 任何一个社交平台都会随着时间推移而变得越发混乱无序，“一个网站出名之后越来越水”是必然且不可逆的。 侯世达定律： 一件事所花费的时间永远比你预期的要长，即使你已经考虑了侯世达定律。原本是指做复杂任务需要花费的时间总是很难预计的，而现在，这一定律反而体现在一些日常小事上，当你睡前躺在床上拿着手机告诉自己只刷10min就睡的时候，跟朋友约饭对方迟到说“马上，还有两三站”的时候，以及当你把减肥目标从“这一个月减 20 斤”放宽到“这一年减 20 斤”的时候。 薛定谔的聊天： 当代版薛定谔的量子困惑实验，即当一个人问出“在吗”的时候，手机里面的另一个人处于在与不在的叠加状态，跟盒子里的猫是死是活一样，很难说。 职场费斯汀格法则： 上班就是用 10% 的时间发生点啥，再用 90% 的时间来对发生的那些事做出反应，又称职场九一法则。 当代生活马斯洛金字塔需求： 金字塔的底层需求正在被现代生活无限挖深，比起吃饭睡眠，当代人似乎更需要 Wi-Fi 和 battery 来维持心理状态的稳定。而以往很容易获取的例如“真正放空自己、享受什么也不做的无聊”反而变得难以实现，现在光荣地挪到了金字塔的顶层。 健身锚定效应： 无糖零度可乐和膳食纤维雪碧是当代减脂人士的心理建设之锚，只要牢牢把住这个底线，心态就不会崩。比方说，不管一餐饭里有多少超标的芝士培根甜点烧烤，只要可乐喝的是无糖的，就总能说服自己这顿还是“减脂餐”，我们称这种现象为“健身锚定效应”。 时间相对论： 时间对人来说是一种主观感知，比如说在不同的情况下，明明是相同的一段时间单位，却可能有不同的感受：刚过 18 岁感觉自己的独立人生刚开始，然而过了 20 岁开始感觉自己快奔三了；充实的一年下来并不会觉得时间溜走了，碌碌无为反而会觉得一年没干什么好快就过去；但放到短期来看，手头越忙的时候觉得时间过得越快，闲的时候觉得时间特别的慢。 再来一单定律： 点外卖基本都是逛了一圈最终还是在历史订单里选吃过的再点一次。 进度条定律： 指，角色死不死不取决于剧情，而取决于进度条当时走到了哪里。 顶格夸奖定律： 一个褒义词里的极限成分越大，它的词义通胀速度就越快。比如在表现女性美丽的夸张程度上，“仙女”&gt;“女神”&gt;“美女”，那这三个词的词义贬值速度就是“美女”&lt;“女神”&lt;“仙女”。 食物地心引力： 食物对你的作用力=mg，m 为你的质量，g 为你想戒断它的指数常量。换言之，在不加控制的情况下，越吃越贪吃是大概率事件。 心情木桶效应： 一天的心情好坏不取决于当天最开心的事，而是取决于当天最不爽的事。 杠精阴影守恒： 在互联网上遇到杠精，被杠之后的心理阴影不会消失，只会以“留在网上去杠下一个人”或者“下线之后在生活中找人吵架”的形式转移。这就是你发现网上的吵架总是越来越频繁越来越激烈的原因之一。 游戏存档点定律： 游戏里出现存档意味着必有一场恶战，所以，当遇到一个新的存档点的时候，你十有八九之后还会再次见到它。 “社交网络真实自我”定律： 它有三个子定律，一是社交账号发的东西负能量往往比正能量走心；三更半夜比白天走心；二是如果同时使用多个平台，那么真实自我程度是“豆瓣&gt;微博&gt;朋友圈”；三是 po 出的合照上出现的人越多，配的文字越虚伪。 粉色定律： 小的时候对粉色不敏感觉得幼稚土气，上了年纪反而开始对各种粉色物件青睐有加，多应验于女生，也不排除一些男性对小时候“男孩子不能穿粉色”刻板印象发起抗议，不失为一种成长叛逆的方式。 评价钓鱼法则： 类似于 Cunningham’s Law 的反向提问思路，为了得到关于 xxx 的靠谱评价，你可以在社交网络上发一个关于 ta 的差评等人来反驳；为了向你的朋友成功安利，与其夸作品好不如说“天哪你可千万别入坑”管用。 猫化定律： 指家里养了猫之后，原本自己用的每一样物品会不知不觉逐渐被猫占据的一种现象。猫入侵你的生活后，你手机里的自拍会逐渐被猫片取代，256G 压根就不够使；猫总爱用你的水杯喝水，所以杯子就成了猫的水碗；猫对家里瑜伽垫的使用频率远高于你，导致它最终跟沙发一样沦落为大型猫抓板。 初老定律： 除了渐渐开始脱发、熬不了夜这些切肤之痛，你可能更容易忽略的“初老症状”可能体现在，把朋友备注改成真名；热搜里流量明星名字都听过很熟，但就是跟脸对不上号；大脑中的歌单停止更新，排行榜上的新歌们一首都没听过。 买买买摩尔定律： 出于“买一双鞋就要配全套衣服”“买一个耳机就要搭全套电子设备”的心情，你购物的件数如果不加控制，每 18 个月就会翻上一番。 杂物循环法则： 家里的杂物（比如衣服）会在桌、椅、床、沙发之间循环流动的规律，比如当你白天需要用桌子时，杂物会出现在你的床/沙发上，当你需要睡觉时杂物会回到桌子/椅子上，如此循环往复。 短视频猫狗定律： 凡是关于猫的视频，内容十有八九是“我家猫成精了”，以狗为主角的视频，十有八九是不遗余力地展现“我家狗太傻了”“我的狗子又被我骗了”，可以用来间接判定不同物种的普遍智商。 Stigler 定律： 一个法则（或者一个定理）不是由其发现者命名的。也就是说，你发现的定律在之前早就已经有人发现过了，只不过没人总结和命名罢了。当然了，上面的那些以及这条本身也符合这一定律。 参考资料 “即时满足”的互联网时代，当代人的耐心引爆点好像越来越多了 | 100 个生活大问题 - https://www.qdaily.com/articles/59065.html 不经意间，你可能正过着一种二手人生 | 100个生活大问题 - http://www.qdaily.com/articles/58601.html 互联网让交朋友变难了吗？未必，但当代友谊变得更像试错游戏了 | 100个生活大问题 - https://www.qdaily.com/articles/61848.html 给你一份当代生活定律，它们都是现代人再造的经典 | 100个生活大问题 - https://www.qdaily.com/articles/64108.html – 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"高并发编程学习(2)——线程通信详解","slug":"高并发编程学习-2-——线程通信详解","date":"2019-11-27T08:51:00.000Z","updated":"2020-12-09T04:54:15.088Z","comments":true,"path":"2019/11/27/gao-bing-fa-bian-cheng-xue-xi-2-xian-cheng-tong-xin-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2019/11/27/gao-bing-fa-bian-cheng-xue-xi-2-xian-cheng-tong-xin-xiang-jie/","excerpt":"","text":"前序文章 高并发编程学习(1)——并发基础 - https://www.wmyskxz.com/2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/ 一、经典的生产者消费者案例 上一篇文章我们提到一个应用可以创建多个线程去执行不同的任务，如果这些任务之间有着某种关系，那么线程之间必须能够通信来协调完成工作。 生产者消费者问题（英语：Producer-consumer problem）就是典型的多线程同步案例，它也被称为有限缓冲问题（英语：Bounded-buffer problem）。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。(摘自维基百科：生产者消费者问题) 注意： 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差； 准备基础代码：无通信的生产者消费者我们来自己编写一个例子：一个生产者，一个消费者，并且让他们让他们使用同一个共享资源，并且我们期望的是生产者生产一条放到共享资源中，消费者就会对应地消费一条。 我们先来模拟一个简单的共享资源对象： public class ShareResource { private String name; private String gender; /** * 模拟生产者向共享资源对象中存储数据 * * @param name * @param gender */ public void push(String name, String gender) { this.name = name; this.gender = gender; } /** * 模拟消费者从共享资源中取出数据 */ public void popup() { System.out.println(this.name + \"-\" + this.gender); } } 然后来编写我们的生产者，使用循环来交替地向共享资源中添加不同的数据： public class Producer implements Runnable { private ShareResource shareResource; public Producer(ShareResource shareResource) { this.shareResource = shareResource; } @Override public void run() { for (int i = 0; i &lt; 50; i++) { if (i % 2 == 0) { shareResource.push(\"凤姐\", \"女\"); } else { shareResource.push(\"张三\", \"男\"); } } } } 接着让我们的消费者不停地消费生产者产生的数据： public class Consumer implements Runnable { private ShareResource shareResource; public Consumer(ShareResource shareResource) { this.shareResource = shareResource; } @Override public void run() { for (int i = 0; i &lt; 50; i++) { shareResource.popup(); } } } 然后我们写一段测试代码，来看看效果： public static void main(String[] args) { // 创建生产者和消费者的共享资源对象 ShareResource shareResource = new ShareResource(); // 启动生产者线程 new Thread(new Producer(shareResource)).start(); // 启动消费者线程 new Thread(new Consumer(shareResource)).start(); } 我们运行发现出现了诡异的现象，所有的生产者都似乎消费到了同一条数据： 张三-男 张三-男 ....以下全是张三-男....为什么会出现这样的情况呢？照理说，我的生产者在交替地向共享资源中生产数据，消费者也应该交替消费才对呀..我们大胆猜测一下，会不会是因为消费者是直接循环了 30 次打印共享资源中的数据，而此时生产者还没有来得及更新共享资源中的数据，消费者就已经连续打印了 30 次了，所以我们让消费者消费的时候以及生产者生产的时候都小睡个 10 ms 来缓解消费太快 or 生产太快带来的影响，也让现象更明显一些： /** * 模拟生产者向共享资源对象中存储数据 * * @param name * @param gender */ public void push(String name, String gender) { try { Thread.sleep(10); } catch (InterruptedException ignored) { } this.name = name; this.gender = gender; } /** * 模拟消费者从共享资源中取出数据 */ public void popup() { try { Thread.sleep(10); } catch (InterruptedException ignored) { } System.out.println(this.name + \"-\" + this.gender); } 再次运行代码，发现了出现了以下的几种情况： 重复消费：消费者连续地出现两次相同的消费情况（张三-男/ 张三-男）； 性别紊乱：消费者消费到了脏数据（张三-女/ 凤姐-男）； 分析出现问题的原因 重复消费：我们先来看看重复消费的问题，当生产者生产出一条数据的时候，消费者正确地消费了一条，但是当消费者再来共享资源中消费的时候，生产者还没有准备好新的一条数据，所以消费者就又消费到老数据了，这其中的根本原因是生产者和消费者的速率不一致。 性别紊乱：再来分析第二种情况。不同于上面的情况，消费者在消费第二条数据时，生产者也正在生产新的数据，但是尴尬的是，生产者只生产了一半儿（也就是该执行完 this.name = name），也就是还没有来得及给 gender 赋值就被消费者给取走消费了.. 造成这样情况的根本原因是没有保证生产者生产数据的原子性。 解决出现的问题加锁解决性别紊乱我们先来解决性别紊乱，也就是原子性的问题吧，上一篇文章里我们也提到了，对于这样的原子性操作，解决方法也很简单：加锁。稍微改造一下就好了： /** * 模拟生产者向共享资源对象中存储数据 * * @param name * @param gender */ synchronized public void push(String name, String gender) { this.name = name; try { Thread.sleep(10); } catch (InterruptedException ignored) { } this.gender = gender; } /** * 模拟消费者从共享资源中取出数据 */ synchronized public void popup() { try { Thread.sleep(10); } catch (InterruptedException ignored) { } System.out.println(this.name + \"-\" + this.gender); } 我们在方法前面都加上了 synchronized 关键字，来保证每一次读取和修改都只能是一个线程，这是因为当 synchronized 修饰在普通同步方法上时，它会自动锁住当前实例对象，也就是说这样改造之后读/ 写操作同时只能进行其一； 我把 push 方法小睡的代码改在了赋值 name 和 gender 的中间，以强化验证原子性操作是否成功，因为如果不是原子性的话，就很可能出现赋值 name 还没赋值给 gender 就被取走的情况，小睡一会儿是为了加强这种情况的出现概率（可以试着把 synchronized 去掉看看效果）； 运行代码后发现，并没有出现性别紊乱的现象了，但是重复消费仍然存在。 等待唤醒机制解决重复消费我们期望的是 张三-男 和 凤姐-女 交替出现，而不是有重复消费的情况，所以我们的生产者和消费者之间需要一点沟通，最容易想到的解决方法是，我们新增加一个标志位，然后在消费者中使用 while 循环判断，不满足条件则不消费，条件满足则退出 while 循环，从而完成消费者的工作。 while (value != desire) { Thread.sleep(10); } doSomething(); 这样做的目的就是为了防止「过快的无效尝试」，这种方法看似能够实现所需的功能，但是却存在如下的问题： 1）难以确保及时性。在睡眠时，基本不消耗处理器的资源，但是如果睡得过久，就不能及时发现条件已经变化，也就是及时性难以保证； 2）难以降低开销。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能够更加迅速地发现条件变化，但是却可能消耗更多的处理资源，造成了无端的浪费。 以上两个问题吗，看似矛盾难以调和，但是 Java 通过内置的等待/ 通知机制能够很好地解决这个矛盾并实现所需的功能。 等待/ 通知机制，是指一个线程 A 调用了对象 O 的 wait() 方法进入等待状态，而另一个线程 B 调用了对象 O 的 notifyAll() 方法，线程 A 收到通知后从对象 O 的 wait() 方法返回，进而执行后续操作。上述两个线程都是通过对象 O 来完成交互的，而对象上的 wait 和 notify/ notifyAll 的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。 这里有一个比较奇怪的点是，为什么看起来像是线程之间操作的 wait 和 notify/ notifyAll 方法会是 Object 类中的方法，而不是 Thread 类中的方法呢？ 简单来说：因为 synchronized 中的这把锁可以是任意对象，因为要满足任意对象都能够调用，所以属于 Object 类； 专业点说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的 notify 唤醒，不可以对不同锁中的线程进行唤醒。也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在 Object 类中。 好，简单介绍完等待/ 通知机制，我们开始改造吧： public class ShareResource { private String name; private String gender; // 新增加一个标志位，表示共享资源是否为空，默认为 true private boolean isEmpty = true; /** * 模拟生产者向共享资源对象中存储数据 * * @param name * @param gender */ synchronized public void push(String name, String gender) { try { while (!isEmpty) { // 当前共享资源不为空的时，则等待消费者来消费 // 使用同步锁对象来调用，表示当前线程释放同步锁，进入等待池，只能被其他线程所唤醒 this.wait(); } // 开始生产 this.name = name; Thread.sleep(10); this.gender = gender; // 生产结束 isEmpty = false; // 生产结束唤醒一个消费者来消费 this.notify(); } catch (Exception ignored) { } } /** * 模拟消费者从共享资源中取出数据 */ synchronized public void popup() { try { while (isEmpty) { // 为空则等着生产者进行生产 // 使用同步锁对象来调用，表示当前线程释放同步锁，进入等待池，只能被其他线程所唤醒 this.wait(); } // 消费开始 Thread.sleep(10); System.out.println(this.name + \"-\" + this.gender); // 消费结束 isEmpty = true; // 消费结束唤醒一个生产者去生产 this.notify(); } catch (InterruptedException ignored) { } } } 我们期望生产者生产一条，然后就去通知消费者消费一条，那么在生产和消费之前，都需要考虑当前是否需要生产 or 消费，所以我们新增了一个标志位来判断，如果不满足则等待； 被通知后仍然要检查条件，条件满足，则执行我们相应的生产 or 消费的逻辑，然后改变条件（这里是 isEmpty），并且通知所有等待在对象上的线程； 注意：上面的代码中通知使用的 notify() 方法，这是因为例子中写死了只有一个消费者和生产者，在实际情况中建议还是使用 notifyAll() 方法，这样多个消费和生产者逻辑也能够保证（可以自己试一下）； 小结通过初始版本一步步地分析问题和解决问题，我们就差不多写出了我们经典生产者消费者的经典代码，但通常消费和生产的逻辑是写在各自的消费者和生产者代码里的，这里我为了方便阅读，把他们都抽离到了共享资源上，我们可以简单地再来回顾一下这个消费生产和等待通知的整个过程： 以上就是关于生产者生产一条数据，消费者消费一次的过程了，涉及的一些具体细节我们下面来说。 二、线程间的通信方式 等待唤醒机制的替代：Lock 和 Condition我们从上面的中看到了 wait() 和 notify() 方法，只能被同步监听锁对象来调用，否则就会报出 IllegalMonitorZStateException 的异常，那么现在问题来了，我们在上一篇提到的 Lock 机制根本就没有同步锁了，也就是没有自动获取锁和自动释放锁的概念，因为没有同步锁，也就意味着 Lock 机制不能调用 wait 和 notify 方法，我们怎么办呢？ 好在 Java 5 中提供了 Lock 机制的同时也提供了用于 Lock 机制控制通信的 Condition 接口，如果大家理解了上面说到的 Object.wait() 和 Object.notify() 方法的话，那么就能很容易地理解 Condition 对象了。 它和 wait() 和 notify() 方法的作用是大致相同的，只不过后者是配合 synchronized 关键字使用的，而 Condition 是与重入锁相关联的。通过 Lock 接口（重入锁就实现了这一接口）的 newCondition() 方法可以生成一个与当前重入锁绑定的 Condition 实例。利用 Condition 对象，我们就可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。 我们拿上面的生产者消费者来举例，修改成 Lock 和 Condition 代码如下： public class ShareResource { private String name; private String gender; // 新增加一个标志位，表示共享资源是否为空，默认为 true private boolean isEmpty = true; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); /** * 模拟生产者向共享资源对象中存储数据 * * @param name * @param gender */ public void push(String name, String gender) { lock.lock(); try { while (!isEmpty) { // 当前共享资源不为空的时，则等待消费者来消费 condition.await(); } // 开始生产 this.name = name; Thread.sleep(10); this.gender = gender; // 生产结束 isEmpty = false; // 生产结束唤醒消费者来消费 condition.signalAll(); } catch (Exception ignored) { } finally { lock.unlock(); } } /** * 模拟消费者从共享资源中取出数据 */ public void popup() { lock.lock(); try { while (isEmpty) { // 为空则等着生产者进行生产 condition.await(); } // 消费开始 Thread.sleep(10); System.out.println(this.name + \"-\" + this.gender); // 消费结束 isEmpty = true; // 消费结束唤醒生产者去生产 condition.signalAll(); } catch (InterruptedException ignored) { } finally { lock.unlock(); } } } 在 JDK 内部，重入锁和 Condition 对象被广泛地使用，以 ArrayBlockingQueue 为例，它的 put() 方法实现如下： /** Main lock guarding all access */ final ReentrantLock lock; /** Condition for waiting takes */ private final Condition notEmpty; /** Condition for waiting puts */ private final Condition notFull; // 构造函数，初始化锁以及对应的 Condition 对象 public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition(); } public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) // 等待队列有足够的空间 notFull.await(); enqueue(e); } finally { lock.unlock(); } } private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; // 通知需要 take() 的线程，队列已有数据 notEmpty.signal(); } 同理，对应的 take() 方法实现如下： public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) // 如果队列为空，则消费者队列要等待一个非空的信号 notEmpty.await(); return dequeue(); } finally { lock.unlock(); } } 允许多个线程同时访问：信号量(Semaphore) 以下内容摘录 or 改编自 《实战 Java 高并发程序设计》 3.1.3 节的内容 信号量为多线程协作提供了更为强大的控制方法。广义上说，信号量是对锁的扩展，无论是内部锁 synchronized 还是重入锁 ReentrantLock，一次都只允许一个线程访问一个资源，而信号量却可以指定多个线程，同时访问某一个资源。信号量主要提供了以下构造函数： public Semaphore(int permits) public Semaphore(int permits, boolean fair) // 第二个参数可以指定是否公平 在构造信号量对象时，必须要指定信号量的准入数，即同时能申请多少个许可。当每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。信号量的主要逻辑如下： public void acquire() public void acquireUninterruptibly() public boolean tryAcquire() public boolean tryAcquire(long timeout, TimeUnit unit) public void release() acquire() 方法尝试获得一个准入的许可。若无法获得，则线程会等待，直到有线程释放一个许可或者当前线程被中断。 acquireUninterruptibly() 方法和 acquire() 方法类似，但是不响应中断。 tryAcquire() 尝试获得一个许可，如果成功则返回 true，失败则返回 false，它不会进行等待，立即返回。 release() 用于在线程访问资源结束后，释放一个许可，以使其他等待许可的线程可以进行资源访问。 在 JDK 的官方 Javadoc 中，就有一个有关信号量使用的简单实例，有兴趣的读者可以自行去翻阅一下，这里给出一个更傻瓜化的例子： public class SemapDemo implements Runnable { final Semaphore semaphore = new Semaphore(5); @Override public void run() { try { semaphore.acquire(); // 模拟耗时操作 Thread.sleep(2000); System.out.println(Thread.currentThread().getId() + \":done!\"); semaphore.release(); } catch (InterruptedException ignore) { } } public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(20); final SemapDemo demo = new SemapDemo(); for (int i = 0; i &lt; 20; i++) { executorService.submit(demo); } } } 执行程序，就会发现系统以 5 个线程为单位，依次输出带有线程 ID 的提示文本。 在实现上，Semaphore 借助了线程同步框架 AQS（AbstractQueuedSynchornizer），同样借助了 AQS 来实现的是 Java 中可重入锁的实现。AQS 的强大之处在于，你仅仅需要继承它，然后使用它提供的 api 就可以实现任意复杂的线程同步方案，AQS 为我们做了大部分的同步工作，所以这里不细说，之后再来详细探究一下… 我等着你：Thread.join()如果一个线程 A 执行了 thread.join() 方法，其含义是：当前线程 A 等待 thread 线程终止之后才从 thread.join() 返回。线程 Thread 除了提供 join() 方法之外，还提供了 join(long millis) 和 join(long millis, int nanos) 两个具备超时特性的方法。这两个超时方法表示，如果线程 Thread 在给定的超时时间里没有终止，那么将会从该超时方法中返回。 在下面的代码中，我们创建了 10 个线程，编号 0 ~ 9，每个线程调用前一个线程的 join() 方法，也就是线程 0 结束了，线程 1 才能从 join() 方法中返回，而线程 0 需要等待 main 线程结束。 public class Join { public static void main(String[] args) throws InterruptedException { Thread previous = Thread.currentThread(); for (int i = 0; i &lt; 10; i++) { // 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回 Thread thread = new Thread(new Domino(previous), String.valueOf(i)); thread.start(); previous = thread; } TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + \" terminate. \"); } static class Domino implements Runnable { private Thread thread; public Domino(Thread thread) { this.thread = thread; } @Override public void run() { try { thread.join(); } catch (InterruptedException ignore) { } System.out.println(Thread.currentThread().getName() + \" terminate. \"); } } } 运行程序，可以看到下列输出： main terminate. 0 terminate. 1 terminate. 2 terminate. 3 terminate. 4 terminate. 5 terminate. 6 terminate. 7 terminate. 8 terminate. 9 terminate. 说明每个线程终止的前提都是前驱线程的终止，每个线程等待前驱线程结束后，才从 join() 方法中返回，这里涉及了等待/ 通知机制，在 JDK 的源码中，我们可以看到 join() 的方法如下： public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } if (millis == 0) { // 条件不满足则继续等待 while (isAlive()) { wait(0); } // 条件符合则返回 } else { while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } 当线程终止时，会调用线程自身的 notifyAll() 方法，会通知所有等待在该线程对象上的线程。可以看到 join() 方法的逻辑结构跟我们上面写的生产者消费者类似，即加锁、循环和处理逻辑三个步骤。 三、线程之间的数据交互 保证可见性：volatile 关键字我们先从一个有趣的例子入手： private static boolean isOver = false; public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -> { while (!isOver) { } System.out.println(\"线程已感知到 isOver 置为 true，线程正常返回!\"); }); thread.start(); Thread.sleep(500); isOver = true; System.out.println(\"isOver 已置为 true\"); } 我们开启了一个主线程和一个子线程，我们期望子线程能够感知到 isOver 变量的变化以结束掉死循环正常返回，但是运行程序却发现并不是像我们期望的那样发生，子线程一直处在了死循环的状态！ 为什么会这样呢？ Java 内存模型关于这一点，我们有几点需要说明，首先需要搞懂 Java 的内存模型： Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。 那么不同的线程之间是如何通信的呢？ 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。 例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤： 首先，线程 A 把本地内存 A 更新过的共享变量刷新到主内存中去 然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。 说回刚才出现的问题，就很容易理解了：每个线程都有独占的内存区域，如操作栈、本地变量表等。线程本地保存了引用变量在堆内存中的副本，线程对变量的所有操作都在本地内存区域中进行，执行结束后再同步到堆内存中去。也就是说，我们在主线程中修改的 isOver 的值并没有被子线程读取到（没有被刷入主内存），也就造成了子线程对于 isOver 变量不可见。 解决方法也很简单，只需要在 isOver 变量前加入 volatile 关键字就可以了，这是因为加入了 volatile 修饰的变量允许直接与主内存交互，进行读写操作，保证可见性。 指令重排/ happen-before 原则再从另一个有趣的例子中入手，这是在高并发场景下会存在的问题： class LazyInitDemo { private static TransationService service = null; public static TransationService getTransationService(){ if (service == null) { synchronized (this) { if (service == null) { service = new TransationService(); } } } } } 这是一个典型的双重检查锁定思想，这段代码也是一个典型的双重检查锁定（Double-checked Locking）问题。在高并发的情况下，该对象引用在没有同步的情况下进行读写操作，导致用户可能会获取未构造完成的对象。 这是因为指令优化的结果。计算机不会根据代码顺序按部就班地执行相关指令，我们来举一个借书的例子：假如你要去还书并且想要借一个《高并发编程学习》系列丛书，而你的室友恰好也要还书，并且还想让你帮忙借一本《Java 从入门到放弃》。 这件事乍一看有两件事：你的事和你室友的事。先办完你的事，再开始处理你室友的事情是属于单线程的死板行为，此时你会潜意识地进行「优化」，例如你可以把你要还的书和你室友需要还的书一起还了，再一起把想要借的书借出来，这其实就相当于合并数据进行存取的操作过程了。 我们知道一条指令的执行是可以分成很多步骤的，简单地说，可以分为： 取值 IF 译码和去寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问 MEM 写回 WB 由于每一个步骤可能使用不同的硬件完成，因此，聪明的工程师就发明了流水线技术来执行指令，如下图所示： 可以看到，当第 2 条指令执行时，第 1 条执行其实并没有执行完，确切地说第一条指令还没有开始执行，只是刚刚完成了取值操作而已。这样的好处非常明显，假如这里每一个步骤都需要花费 1 毫秒，那么指令 2 等待指令 1 完全执行后再执行，则需要等待 5 毫秒，而使用流水线指令，指令 2 只需要等待 1 毫秒就可以执行了。如此大的性能提升，当然让人眼红。 回到最初的问题，我们分析一下：对于 Java 编译器来说，初始化 TransactionService 实例和将对象地址写到 service 字段并非原子操作，且这两个阶段的执行顺序是未定义的。加入某个线程执行 new TransactionService() 时，构造方法还未被调用，编译器仅仅为该对象分配了内存空间并设为默认值，此时若另一个线程调用 getTransactionService() 方法，由于 service != null，但是此时 service 对象还没有被赋予真正的有效值，从而无法取到正确的 service 单例对象。 对于此问题，一种较为简单的解决方案就是用 volatile 关键字修饰目标属性（适用于 JDK5 及以上版本），这样 service 就限制了编译器对它的相关读写操作，对它的读写操作进行指令重排，确定对象实例化之后才返回引用。 另外指令重排也有自己的规则，并非所有的指令都可以随意改变执行位置，下面列举一下基本的原则： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作； volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C； 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作； 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始； volatile 不保证原子性volatile 解决的是多线程共享变量的可见性问题，类似于 synchronized，但不具备 synchronized 的互斥性。所以对 volatile 变量的操作并非都具有原子性，例如我们用下面的例子来说明： public class VolatileNotAtomic { private static volatile long count = 0L; private static final int NUMBER = 10000; public static void main(String[] args) { Thread subtractThread = new SubstractThread(); subtractThread.start(); for (int i = 0; i &lt; NUMBER; i++) { count++; } // 等待减法线程结束 while (subtractThread.isAlive()) { } System.out.println(\"count 最后的值为: \" + count); } private static class SubstractThread extends Thread { @Override public void run() { for (int i = 0; i &lt; NUMBER; i++) { count--; } } } } 多次执行后，发现结果基本都不为 0。只有在 count++ 和 count-- 两处都进行加锁时，才能正确的返回 0，了解 Java 的童鞋都应该知道这 count++ 和 count-- 都不是一个原子操作，这里就不作说明了。 volatile 的使用优化在了解一点吧，注明的并发编程大师 Doug lea 在 JDK 7 的并发包里新增一个队列集合类 LinkedTransferQueue，它在使用 volatile 变量时，用一种追加字节的方式来优化对列出队和入队的性能，具体的可以看一下下列的链接，这里就不具体说明了。 追加字节方式来优化队列性能？ - https://my.oschina.net/u/3694754/blog/2990652 保证原子性：synchronizedJava 中任何一个对象都有一个唯一与之关联的锁，这样的锁作为该对象的一系列标志位存储在对象信息的头部。Java 对象头里的 Mark Word 里默认的存放的对象的 Hashcode/ 分代年龄和锁标记位。32 为JVM Mark Word 默认存储结构如下： Java SE 1.6中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 偏向锁HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 偏向锁的获取：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。 下图线程 1 展示了偏向锁获取的过程，线程 2 展示了偏向锁撤销的过程。 轻量级锁和自旋锁如果偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。 线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋（自己执行几个空循环再进行尝试）来获取锁。 轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。 几种锁的比较下图就简单概括了一下几种锁的比较： 每人一支笔：ThreadLocal除了控制资源的访问外，我们还可以通过增加资源来保证所有对象的线程安全。比如，让 100 个人填写个人信息表，如果只有一支笔，那么大家就得挨个写，对于管理人员来说，必须保证大家不会去哄抢这仅存的一支笔，否则，谁也填不完。从另外一个角度出发，我们可以干脆就准备 100 支笔，那么所有人都可以各自为营，很快就能完成表格的填写工作。 如果说锁是使用第一种思路，那么 ThreadLocal 就是使用第二种思路了。 当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。 ThreadLocal 内部实现机制： 每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程； Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系； Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。 ThreadLodal 的副作用为了让线程安全地共享某个变量，JDK 开出了 ThreadLocal 这副药方，但「是药三分毒」，ThreadLocal 也有一定的副作用。主要问题是「产生脏数据」和「内存泄漏」。这两个问题通常是在线程池中使用 ThreadLocal 引发的，因为线程池有 「线程复用」 和 「内存常驻」 两个特点。 脏数据线程复用会产生脏数据。由于线程池会重用 Thread 对象，那么与 Thread 绑定的类的静态属性 ThreadLocal 变量也会被重用。如果在实现的线程 run() 方法中不显式地 remove() 清理与线程相关的 ThreadLocal 信息，那么倘若下一个线程不调用 set() 设置初始值，就可能 get() 到重用的线程信息，包括 ThreadLocal 所关联的线程对象的 value 值。 为了方便理解，用一段简要代码来模拟，如下所示： public class DirtyDataInThreadLocal { public static ThreadLocal&lt;String> threadLocal = new ThreadLocal&lt;>(); public static void main(String[] args) { // 使用固定大小为 1 的线程池，说明上一个的线程属性会被下一个线程属性复用 ExecutorService pool = Executors.newFixedThreadPool(1); for (int i = 0; i &lt; 2; i++) { Mythread mythread = new Mythread(); pool.execute(mythread); } } private static class Mythread extends Thread { private static boolean flag = true; @Override public void run() { if (flag) { // 第 1 个线程 set 后，并没有进行 remove // 而第二个线程由于某种原因没有进行 set 操作 threadLocal.set(this.getName() + \", session info.\"); flag = false; } System.out.println(this.getName() + \" 线程是 \" + threadLocal.get()); } } } 执行结果： Thread-0 线程是 Thread-0, session info. Thread-1 线程是 Thread-0, session info.内存泄漏在源码注释中提示使用 static 关键字来修饰 ThreadLocal。在此场景下，寄希望于 ThreadLocal 对象失去引用后，触发弱引用机制来回收 Entry 的 Value 就变得不现实了。在上面的例子中，如果不进行 remove() 操作，那么这个线程执行完成后，通过 ThreadLocal 对象持有的 String 对象是不会被释放的。 以上两个问题的解决办法很简单，就是在每次使用完 ThreadLocal 时，必须要及时调用 remove() 方法清理。 参考资料 《Java 零基础入门教程》 - http://study.163.com/course/courseMain.htm?courseId=1003108028 《Java 并发编程的艺术》 《码出高效 Java 开发手册》 - 杨冠宝（孤尽） 高海慧（鸣莎）著 Java面试知识点解析(二)——高并发编程篇 - https://www.wmyskxz.com/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/ 让你彻底理解Synchronized - https://www.jianshu.com/p/d53bf830fa09 《Offer来了 - Java面试核心知识点精讲》 - 王磊 编著 《实战Java高并发程序设计》 - 葛一鸣 郭超 编著","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"高并发编程学习(1)——并发基础","slug":"高并发编程学习-1-——并发基础","date":"2019-11-26T04:20:00.000Z","updated":"2020-12-09T04:54:12.676Z","comments":true,"path":"2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/","link":"","permalink":"http://www.wmyskxz.com/2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/","excerpt":"","text":"为更良好的阅读体验，请访问原文：传送门 一、前言 当我们使用计算机时，可以同时做许多事情，例如一边打游戏一边听音乐。这是因为操作系统支持并发任务，从而使得这些工作得以同时进行。 那么提出一个问题：如果我们要实现一个程序能一边听音乐一边玩游戏怎么实现呢？ public class Tester { public static void main(String[] args) { System.out.println(\"开始....\"); playGame(); playMusic(); System.out.println(\"结束....\"); } private static void playGame() { for (int i = 0; i &lt; 50; i++) { System.out.println(\"玩游戏\" + i); } } private static void playMusic() { for (int i = 0; i &lt; 50; i++) { System.out.println(\"播放音乐\" + i); } } } 我们使用了循环来模拟过程，因为播放音乐和打游戏都是连续的，但是结果却不尽人意，因为函数体总是要执行完之后才能返回。那么到底怎么解决这个问题？ 并行与并发 并行性和并发性是既相似又有区别的两个概念。 并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。 在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机环境下（一个处理器），每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。例如，在 1 秒钟时间内，0 - 15 ms 程序 A 运行；15 - 30 ms 程序 B 运行；30 - 45 ms 程序 C 运行；45 - 60 ms 程序 D 运行，因此可以说，在 1 秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序 A、B、C、D 是分时地交替执行的。 如果在计算机系统中有多个处理机，这些可以并发执行的程序就可以被分配到多个处理机上，实现并发执行，即利用每个处理机爱处理一个可并发执行的程序。这样，多个程序便可以同时执行。以此就能提高系统中的资源利用率，增加系统的吞吐量。 进程和线程进程是指一个内存中运行的应用程序。一个应用程序可以同时启动多个进程，那么上面的问题就有了解决的思路：我们启动两个进程，一个用来打游戏，一个用来播放音乐。这当然是一种解决方案，但是想象一下，如果一个应用程序需要执行的任务非常多，例如 LOL 游戏吧，光是需要播放的音乐就有非常多，人物本身的语音，技能的音效，游戏的背景音乐，塔攻击的声音等等等，还不用说游戏本身，就光播放音乐就需要创建许多许多的进程，而进程本身是一种非常消耗资源的东西，这样的设计显然是不合理的。更何况大多数的操作系统都不需要一个进程访问其他进程的内存空间，也就是说，进程之间的通信很不方便，此时我们就得引入“线程”这门技术，来解决这个问题。 线程是指进程中的一个执行任务（控制单元），一个进程可以同时并发运行多个线程。我们可以打开任务管理器，观察到几乎所有的进程都拥有着许多的「线程」(在 WINDOWS 中线程是默认隐藏的，需要在「查看」里面点击「选择列」，有一个线程数的勾选项，找到并勾选就可以了)。 进程和线程的区别进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的，又称为轻型进程或进程元。 因为一个进程中的多个线程是并发运行的，那么从微观角度上考虑也是有先后顺序的，那么哪个线程执行完全取决于 CPU 调度器(JVM 来调度)，程序员是控制不了的。我们可以把多线程并发性看作是多个线程在瞬间抢 CPU 资源，谁抢到资源谁就运行，这也造就了多线程的随机性。下面我们将看到更生动的例子。 Java 程序的进程(Java 的一个程序运行在系统中)里至少包含主线程和垃圾回收线程(后台线程)，你可以简单的这样认为，但实际上有四个线程（了解就好）： [1] main——main 线程，用户程序入口 [2] Reference Handler——清除 Reference 的线程 [3] Finalizer——调用对象 finalize 方法的线程 [4] Signal Dispatcher——分发处理发送给 JVM 信号的线程 多线程和单线程的区别和联系？ 单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。 结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。 多线程的优势尽管面临很多挑战，多线程有一些优点仍然使得它一直被使用，而这些优点我们应该了解。 优势一：资源利用率更好想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。处理两个文件则需要： 1| 5秒读取文件A 2| 2秒处理文件A 3| 5秒读取文件B 4| 2秒处理文件B 5| --------------------- 6| 总共需要14秒从磁盘中读取文件的时候，大部分的 CPU 时间用于等待磁盘去读取数据。在这段时间里，CPU 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 CPU 资源。看下面的顺序： 1| 5秒读取文件A 2| 5秒读取文件B + 2秒处理文件A 3| 2秒处理文件B 4| --------------------- 5| 总共需要12秒CPU 等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU 会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU 大部分时间是空闲的。 总的说来，CPU 能够在等待 IO 的时候做一些其他的事情。这个不一定就是磁盘 IO。它也可以是网络的 IO，或者用户输入。通常情况下，网络和磁盘的 IO 比 CPU 和内存的 IO 慢的多。 优势二：程序设计在某些情况下更简单在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用 CPU 去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和 CPU 利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 优势三：程序响应更快有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单赶快找、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？ 在上面的场景中，可以使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。 其他优势多线程还有一些优势也显而易见： 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高. Java 语言本身内置多线程功能的支持,而不是单纯地作为底层系统的调度方式,从而简化了多线程编程. 上下文切换即使是单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。时间片是 CPU 分配给各个线程的时间，因为时间片非常短，所以 CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。 CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务的时候，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是打开中英文字典，但是在放下英文技术书之前，大脑必须先记住这本书独到了多少页的多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。 二、创建线程的两种方式 继承 Thread 类public class Tester { // 播放音乐的线程类 static class PlayMusicThread extends Thread { // 播放时间，用循环来模拟播放的过程 private int playTime = 50; public void run() { for (int i = 0; i &lt; playTime; i++) { System.out.println(\"播放音乐\" + i); } } } // 方式1：继承 Thread 类 public static void main(String[] args) { // 主线程：运行游戏 for (int i = 0; i &lt; 50; i++) { System.out.println(\"打游戏\" + i); if (i == 10) { // 创建播放音乐线程 PlayMusicThread musicThread = new PlayMusicThread(); musicThread.start(); } } } } 运行结果发现打游戏和播放音乐交替出现，说明已经成功了。 实现 Runnable 接口public class Tester { // 播放音乐的线程类 static class PlayMusicThread implements Runnable { // 播放时间，用循环来模拟播放的过程 private int playTime = 50; public void run() { for (int i = 0; i &lt; playTime; i++) { System.out.println(\"播放音乐\" + i); } } } // 方式2：实现 Runnable 方法 public static void main(String[] args) { // 主线程：运行游戏 for (int i = 0; i &lt; 50; i++) { System.out.println(\"打游戏\" + i); if (i == 10) { // 创建播放音乐线程 Thread musicThread = new Thread(new PlayMusicThread()); musicThread.start(); } } } } 也能完成效果。 以上就是传统的两种创建线程的方式，事实上还有第三种，我们后边再讲。 多线程一定快吗？先来一段代码，通过并行和串行来分别执行累加操作，分析：下面的代码并发执行一定比串行执行快吗？ import org.springframework.util.StopWatch; // 比较并行和串行执行累加操作的速度 public class Tester { // 执行次数 private static final long COUNT = 100000000; private static final StopWatch TIMER = new StopWatch(); public static void main(String[] args) throws InterruptedException { concurrency(); serial(); // 打印比较测试结果 System.out.println(TIMER.prettyPrint()); } private static void serial() { TIMER.start(\"串行执行\" + COUNT + \"条数据\"); int a = 0; for (long i = 0; i &lt; COUNT; i++) { a += 5; } // 串行执行 int b = 0; for (long i = 0; i &lt; COUNT; i++) { b--; } TIMER.stop(); } private static void concurrency() throws InterruptedException { TIMER.start(\"并行执行\" + COUNT + \"条数据\"); // 通过匿名内部类来创建线程 Thread thread = new Thread(() -> { int a = 0; for (long i = 0; i &lt; COUNT; i++) { a += 5; } }); thread.start(); // 并行执行 int b = 0; for (long i = 0; i &lt; COUNT; i++) { b--; } // 等待线程结束 thread.join(); TIMER.stop(); } } 大家可以自己测试一下，每一台机器 CPU 不同测试结果可能也会不同，之前在 WINDOWS 本儿上测试的时候，多线程的优势从 1 千万数据的时候才开始体现出来，但是现在换了 MAC，1 亿条数据时间也差不多，到 10 亿的时候明显串行就比并行快了… 总之，为什么并发执行的速度会比串行慢呢？就是因为线程有创建和上下文切换的开销。 继承 Thread 类还是实现 Runnable 接口？想象一个这样的例子：给出一共 50 个苹果，让三个同学一起来吃，并且给苹果编上号码，让他们吃的时候顺便要说出苹果的编号： 运行结果可以看到，使用继承方式实现，每一个线程都吃了 50 个苹果。这样的结果显而易见：是因为显式地创建了三个不同的 Person 对象，而每个对象在堆空间中有独立的区域来保存定义好的 50 个苹果。 而使用实现方式则满足要求，这是因为三个线程共享了同一个 Apple 对象，而对象中的 num 数量是一定的。 所以可以简单总结出继承方式和实现方式的区别： 继承方式： Java 中类是单继承的，如果继承了 Thread 了，该类就不能再有其他的直接父类了； 从操作上分析，继承方式更简单，获取线程名字也简单..(操作上，更简单) 从多线程共享同一个资源上分析，继承方式不能做到… 实现方式： Java 中类可以实现多个接口，此时该类还可以继承其他类，并且还可以实现其他接口(设计上，更优雅).. 从操作上分析，实现方式稍微复杂点，获取线程名字也比较复杂，需要使用 Thread.currentThread() 来获取当前线程的引用.. 从多线程共享同一个资源上分析，实现方式可以做到.. 在这里，三个同学完成抢苹果的例子，使用实现方式才是更合理的方式。 对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。就我个人意见，我更倾向于实现 Runnable 接口这种方法。因为线程池可以有效的管理实现了 Runnable 接口的线程，如果线程池满了，新的线程就会排队等候执行，直到线程池空闲出来为止。而如果线程是通过实现 Thread 子类实现的，这将会复杂一些。 有时我们要同时融合实现 Runnable 接口和 Thread 子类两种方式。例如，实现了 Thread 子类的实例可以执行多个实现了 Runnable 接口的线程。一个典型的应用就是线程池。 常见错误：调用 run() 方法而非 start() 方法创建并运行一个线程所犯的常见错误是调用线程的 run() 方法而非 start() 方法，如下所示： 1| Thread newThread = new Thread(MyRunnable()); 2| newThread.run(); //should be start(); 起初你并不会感觉到有什么不妥，因为 run() 方法的确如你所愿的被调用了。但是，事实上，run() 方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行 run() 方法，必须调用新线程的 start() 方法。 三、线程的安全问题 吃苹果游戏的不安全问题我们来考虑一下上面吃苹果的例子，会有什么问题？ 尽管，Java 并不保证线程的顺序执行，具有随机性，但吃苹果比赛的案例运行多次也并没有发现什么太大的问题。这并不是因为程序没有问题，而只是问题出现的不够明显，为了让问题更加明显，我们使用 Thread.sleep() 方法（经常用来模拟网络延迟）来让线程休息 10 ms，让其他线程去抢资源。（注意：在程序中并不是使用 Thread.sleep(10)之后,程序才出现问题,而是使用之后,问题更明显.） 为什么会出现这样的错误呢？ 先来分析第一种错误：为什么会吃重复的苹果呢？就拿 B 和 C 都吃了编号为 47 的苹果为例吧： A 线程拿到了编号为 48 的苹果，打印输出然后让 num 减 1，睡眠 10 ms，此时 num 为 47。 这时 B 和 C 同时都拿到了编号为 47 的苹果，打印输出，在其中一个线程作出了减一操作的时候，A 线程从睡眠中醒过来，拿到了编号为 46 的苹果，然后输出。在这期间并没有任何操作不允许 B 和 C 线程不能拿到同一个编号的苹果，之前没有明显的错误仅仅可能只是因为运行速度太快了。 再来分析第二种错误：照理来说只应该存在 1-50 编号的苹果，可是 0 和-1 是怎么出现的呢？ 当 num = 1 的时候，A，B，C 三个线程同时进入了 try 语句进行睡眠。 C 线程先醒过来，输出了编号为 1 的苹果，然后让 num 减一，当 C 线程醒过来的时候发现 num 为 0 了。 A 线程醒过来一看，0 都没有了，只有 -1 了。 归根结底是因为没有任何操作来限制线程来获取相同的资源并对他们进行操作，这就造成了线程安全性问题。 如果我们把打印和减一的操作分成两个步骤，会更加明显：ABC 三个线程同时打印了 50 的苹果，然后同时做出减一操作。 像这样的原子操作，是不允许分步骤进行的，必须保证同步进行，不然可能会引发不可设想的后果。 要解决上述多线程并发访问一个资源的安全性问题，就需要引入线程同步的概念。 线程同步多个执行线程共享一个资源的情景，是最常见的并发编程情景之一。为了解决访问共享资源错误或数据不一致的问题，人们引入了临界区的概念：用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。 为了帮助编程人员实现这个临界区，Java（以及大多数编程语言）提供了同步机制，当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已经有其他线程进入临界区。如果没有其他线程进入临界区，他就可以进入临界区。如果已经有线程进入了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入临界区的线程不止一个，JVM 会选择其中的一个，其余的将继续等待。 synchronized 关键字如果一个对象已用 synchronized 关键字声明，那么只有一个执行线程被允许访问它。使用 synchronized 的好处显而易见：保证了多线程并发访问时的同步操作，避免线程的安全性问题。但是坏处是：使用 synchronized 的方法/代码块的性能比不用要低一些。所以好的做法是：尽量减小 synchronized 的作用域。 我们还是先来解决吃苹果的问题，考虑一下 synchronized 关键字应该加在哪里呢？ 发现如果还再把 synchronized 关键字加在 if 里面的话，0 和 -1 又会出来了。这其实是因为当 ABC 同是进入到 if 语句中，等待临界区释放的时，拿到 1 编号的线程已经又把 num 减一操作了，而此时最后一个等待临界区的进程拿到的就会是 -1 了。 同步锁 LockLock 机制提供了比 synchronized 代码块和 synchronized 方法更广泛的锁定操作，同步代码块/ 同步方法具有的功能 Lock 都有，除此之外更强大，更体现面向对象。在并发包的类族中，Lock 是 JUC 包的顶层接口，它的实现逻辑并未用到 synchronized，而是利用了 volatile 的可见性。 使用 Lock 最典型的代码如下： class X { private final ReentrantLock lock = new ReentrantLock(); public void m() { lock.lock(); try { // ..... method body } finally { lock.unlock(); } } } 线程安全问题线程安全问题只在多线程环境下才会出现，单线程串行执行不存在此类问题。保证高并发场景下的线程安全，可以从以下四个维度考量： 维度一：数据单线程可见单线程总是安全的。通过限制数据仅在单线程内可见，可以避免数据被其他线程篡改。最典型的就是线程局部变量，它存储在独立虚拟机栈帧的局部变量表中，与其他线程毫无瓜葛。TreadLocal 就是采用这种方式来实现线程安全的。 维度二：只读对象只读对象总是安全的。它的特性是允许复制、拒绝写入。最典型的只读对象有 String、Integer 等。一个对象想要拒绝任何写入，必须要满足以下条件： 使用 final 关键字修饰类，避免被继承； 使用 private final 关键字避免属性被中途修改； 没有任何更新方法； 返回值不能为可变对象。 维度三：线程安全类某些线程安全类的内部有非常明确的线程安全机制。比如 StringBuffer 就是一个线程安全类，它采用 synchronized 关键字来修饰相关方法。 维度四：同步与锁机制如果想要对某个对象进行并发更新操作，但又不属于上述三类，需要开发工程师在代码中实现安全的同步机制。虽然这个机制支持的并发场景很有价值，但非常复杂且容易出现问题。 处理线程安全的核心理念要么只读，要么加锁。 合理利用好 JDK 提供的并发包，往往能化腐朽为神奇。Java 并发包（java.util.concurrent，JUC）中大多数类注释都写有：@author Doug Lea。如果说 Java 是一本史书，那么 Doug Lea 绝对是开疆拓土的伟大人物。Doug Lea 在当大学老师时，专攻并发编程和并发数据结构设计，主导设计了 JUC 并发包，提高了 Java 并发编程的易用性，大大推进了 Java 的商用进程。 参考资料 《Java 零基础入门教程》 - http://study.163.com/course/courseMain.htm?courseId=1003108028 《Java 并发编程的艺术》 《Java 7 并发编程实战手册》 《码出高效 Java 开发手册》 - 杨冠宝（孤尽） 高海慧（鸣莎）著 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书 ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加 qq 群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"当代的几点变化","slug":"当代的几点变化","date":"2019-11-25T14:14:00.000Z","updated":"2020-12-09T04:49:42.088Z","comments":true,"path":"2019/11/25/dang-dai-de-ji-dian-bian-hua/","link":"","permalink":"http://www.wmyskxz.com/2019/11/25/dang-dai-de-ji-dian-bian-hua/","excerpt":"","text":"前言：以下所有观点均摘录 or 改编自参考资料，纯属观点分享…为获得良好的阅读体验，请访问原文地址：传送门 一、当我们说「当代」时，我们在说什么 引用自：「当代」越来越让人看不懂，我们帮你找到了观察它的 15 个新角度 | 100个生活大问题 - https://www.qdaily.com/articles/62748.html 当代的意思似乎就是「目前所处的时代」，看上去是一个「早就存在于生活之中，无需费心理解」的词语，但如果稍稍在记忆里检索一下，你可能就会发现，在很长一段时间里，它其实是以「当代艺术」、「当代作家」这些相当严肃的面貌出现的，直到最近几年才开始进入我们的日常词库，而且内涵也变得有点不易形容：现在的「当代」，与其说是对一段时间的概括，不如说更接近于「真是一个纷繁复杂、一句两句解释不明白、说时迟那时快的时代」，换言之，「当代」其实也跟「硬核」「流量」一样成了一种景观，一个带点调侃和解构意味的 meme，它真正想说的其实是「喏，看这个世界，就是这样」。 好奇心研究所在 2018 年末的时候，曾经问过大家，「今年有哪些小事让你有一个时代开始/结束的感觉？」，得到最多赞同的回答包括「发现当红明星的年纪比自己还小」「再也不用带现金出门」「金庸先生去世」「开始习惯了视频会员付费制度」，它们刚好完整概括了人们对「当代」这个概念的几种典型印象： 以全球化、碎片化、城市化等关键词为代表的生活方式（一个典型的例子就是咖啡厅、机场这种走遍全世界都长得差不多的「云空间」）； 热爱科技、拥抱互联网却又震慑于科技的阴暗面、被手机和社交媒体所困的普通人； 以生动诠释各种小而又小的第一世界问题为特色的时髦情绪（比如社恐、FOMO、坏消息疲劳）； 以及，被名人、网红、商品、大公司所象征的「xx 时代」（共享时代、偶像时代、即时通讯时代，等等）。 这几个维度叠加在一起，共同组成了你眼前的美丽新世界，以及一种看不见摸不着、但总会令人若有所思的「时代感」。 但是话说回来，这个被冠以买买买、杠精遍地、网红经济、信息焦虑……之名的当代，究竟特别在何处？存身其中的我们，顶着千禧一代、Z 世代、数字游牧民族、飘一代的荣誉称号，真的已经气质迥异到值得被划分得这么细致吗？ 不，我们提出这个问题，并不是想否定「当代」的特殊性。从嬉皮士到 rapper、从电视到手机、从报纸到 Instagram，一代有一代的流行、象征、号召力，变化当然也是实实在在产生了的。我们只是提醒你，每一代人掌握话语权的时候，都会习惯性关注并强调自己的特立独行，习惯性认为「最好的时代已经过去了」「那帮年轻人怎么这样」，以及「我们这代人过得太不容易了」。 从这个角度来讲，所谓的「新时代」其实也有点像一台复读机，它跟上个时代的差距，可能没有我们想得那么大：当你看到那些表象（对传统怀有叛逆、总是在追忆过去、对司空见惯的事物感到疲劳）时，如果考虑藏在背后的人类理智和情感，就知道在多数情况下，它们并没有多么时髦新奇，有时甚至是反复出现、普遍存在的永恒体验。 英国科幻作家道格拉斯·亚当斯曾经提出过一个「科技三定律」，「任何在我出生时已经有的科技，都是稀松平常的，是世界自然秩序的一部分；任何在我 15-35 岁之间诞生的科技，都将会是改变世界的革命性产物；任何在我 35 岁以后诞生的科技，都是违反自然秩序的异端」。这段话可以在一定程度上解释「xx 时代」的说法为什么越来越密集而且越来越不值钱：在少数情况下，时间碰巧可以被一些叫做「里程碑/导火索/纪念日」的东西明确隔断，但更多时候，「时代」不过是一种「我想找到一个词来概括自己目力所及的一切」的快捷方式，是信息给我们制造的一张网，让我们每每生出「身处其中与有荣焉」的感觉。 二、「当代」的几点变化 所面对任务复杂度的改变过去的社会，每个人面对的是一个任务系统。题目已经出好了，每个人各凭本事去答题，靠分数。在学校，你得做老师出的题，在单位，你得干领导布置的活儿。那每个人的刹车就是各种各样的条条框框，原则规矩。 但是现在不一样了，现在一个学生毕业面对的，往往不是一个确定的任务，而是一个目标，一个“事”，具体怎么达到这个目标，做成这个“事”，每个人有自己的定义。甚至这件事，在每一个地方都不一样。看起来好像更自由，但其实对人的约束力更大。为啥？因为完成一个别人定义的任务，还有讨价还价的可能，还有优良中差的等级，一道题答对一半还能给分。但是如果做一个事，达到一个目标，差一点都不行。这是一个更好的人格塑造系统和刹车系统。 现在，人一到社会上，不管是做一个销售、还是搞一项科研、还是主办一个活动、还是搞一个产品、或者干脆去创业，你发现没有？没有任何一件事是完全一样的，达成目标，都需要根据一时一地的条件，做各种各样的创新。 举个例子，您一路学霸，大学中文系高材生毕业。但是又能怎样呢？一旦到工作单位，你会发现，并没有抽象的中文写作能力这个事，世界上没有那么多作文大赛。你遇到的，都是类似于给某某产品写个文案，给某某公众号写个文章，给领导的某次演讲做个ppt，这样的事。在所有这些“事”面前，你需要的远远不止写作能力，你需要调动各个方面的潜能，学习全新的东西，才能把事做成。而且还有一点，在做事这个环境里，没有谁有确定的优势。领导和老板，写公司的公众号文章，还真不见得就比刚毕业的大学生强。 学习方式的改变在过去的手抄时代，我们记忆力越好越牛；印刷时代，知道得越多越牛；但到了现在的信息时代，学得越快越牛。 过去你要说自己有知识焦虑，社会已经给你准备了成熟的解决方案，说白了就是读书看报加上学。只要你勤于用功，肯于花钱，你的焦虑是能解决的。但是今天，这些解决方案本身就在出问题，为啥？因为社会的底层因素正在发生重大变动。 比如说，第一，人的时间在碎片化。现在我们不管在干什么，动不动就要去摸下手机，刷下微信什么的。当然，这赖不着人家微信，这是我们的社会协作关系极度复杂化的结果，我们有太多的事情要同步运行、分头照料，所以我们拿不出整块时间了。读书上学这种事可是要花整块时间的。一本书20万字，你怎么也得读个三四天吧？上个学几年，最短的短训班也得好几天吧？你越来越花不起这个时间。 第二，学习越来越是一个终身化的事情。过去有一个词叫“学业有成”。大学毕业基本上算学业有成吧，你要是留学回来我们叫“学成归国”。但是今天有学成这件事情吗？永远也成不了，新的知识像海浪一般涌来，你一辈子都要奋力前行，永远成不了。但是 20 多岁你就大学毕业了，整个社会没有为终身学习提供解决方案和服务，怎么办呢？ 还有第三点，现在的学习越来越是跨界化的。这件事情要是几百年前，一点儿都不新鲜，那个时候的学者觉得自己上通天文，下晓地理，因为那个时候的知识总量少。可是，工业革命之后，人类的知识大爆炸，知识的负担太沉重。怎么办呢？两百年来我们找到了方法，叫分科治学。我们从中学的时候就文理分科，你学物理，他学化学，而且越分越细，分担人类的知识总量。每一个人都有一个知识的金字塔，你去往上爬吧，这辈子你爬一个塔就行了。但是今天，所有善于学习的人都明白一个道理，真正的创新的空间，恰恰在原来那些金字塔的中间地带。 对于退休认知的改变这是正在发生的事情： 有一本书，叫《百岁人生》。这书就是提醒大家一件事，随着医疗技术的进步，我们这代人有很大概率能活到100多岁。您先别高兴，活得长虽然是好事，但是代价是什么呢？ 最简单的一点，就是过去的三段式人生规划，没有用了。 所谓“三段式人生”，大概就是30岁之前，学习成家立业；30岁之后在社会和家庭中顶大梁；60岁之后退休回家，安度晚年等死。可是如果能活100岁，这个安排就出问题了。《百岁人生》里做了很多推导，比如人的伦理观会变化，过去相对不变的人是受尊重的，而未来敢于抛弃存量的人才是有道德的。再比如，人的婚姻选择会更加慎重，因为选一个人，要跟他在一起的时间实在太长了。还有，人的资产也会从金钱变成了信用和人脉，等等。 过去，人受教育，掌握一门知识或者手艺，然后应用到退休问题不大。所以才有人提倡要干一行爱一行，进一个单位要忠诚于一个单位。 可是你想过没有，现在产业迭代速度这么快，有的新兴行业从兴起到衰落，也许只有十几年的时间，你就是想为这个单位、这个行业奉献终生也做不到啊。我们如果能活100岁，一生要跨过的行业就可能有好几个。 所以我们必须有一种能力，就是不断扔掉存量，从零开始，创造一个新的生活阶段。60岁再去上个大学，65岁甚至70岁再去干一件全新的事，甚至创个业，未来这样的人会越来越常见。 对于感官的改变 以下摘录自《今日简史》P82 人类有身体。在 20 世纪，科技让我们与身体的距离越来越远，逐渐失去了好好感受味觉和嗅觉的能力，一头扎进智能手机和计算机，对网络上发生的事比对大街上发生的事更感兴趣。今天，我要和在法国的姐姐说话比以前任何时候都容易，但要在早餐的时候和我的爱人说话却比较难，因为她总是不看着我，而是盯着智能手机。 在远古时代，人类绝不可能如此的漫不经心。当时的采集者必须永远保持警觉、专心一意。走在森林里寻找蘑菇的时候，要注意地面是否有小小的凸起，还要注意草丛中是否发出了细微的声音，以免有蛇躲在那里。等到发现可食用的蘑菇，还要极其小心地试尝一下，以免吃到有毒的菌类。 但到了现代的富裕社会，人类不再需要如此敏锐的感官意识。我们可以边走在超市的走道里，一边发短信，一边在成百上千种食物中随意挑选。但不管我们挑了什么食物，最后都是坐在某个屏幕前一边狼吞虎咽，一边收着电子邮件或看着电视，全然不会注意食物究竟味道如何。 扎克伯格说，脸谱网致力于“持续改进我们的工具，让人们能够分享自己的体验。”但我们真正需要的，可能是好好感受一下自己的体验。以”分享体验“为名，现代人对自己的理解常常从别人的观点出发，一发生什么有趣的事，脸谱网用户就会下意识地拿出智能手机，拍照、发帖、等着有人点赞。在这个过程中，他们几乎不会注意自己到底有何感受。事实上，他们的感受越来越来自网络上的响应。 人类一旦与身体、感官和真实环境越来越疏离，很可能就会感受孤单、迷失方向。很多权威评论人士把这种疏离感归咎于宗教和国家的凝聚力式微，但或许和你的身体失去联系才是最重要的原因。曾有几百年的时间，人类没有宗教，也没有国家，但还是过得开开心心，所以在 21 世纪应该也不成问题。然而一旦与身体失去联系，日子就肯定无法过得开心。只要你在自己的身体里感觉不自在，在这个世界上就不可能自在。 就算到了今天，尽管我们可以在脸谱网上炫耀有许多好友，但是大多数人真正了解的人并不会超过 150 个。如果没有这些小团体的支持，人就会觉得寂寞，甚至被孤立。 于是，虽然整个地球连接得更加紧密，但每个人的生活却比过去更加孤独。 参考资料 「当代」越来越让人看不懂，我们帮你找到了观察它的 15 个新角度 | 100个生活大问题 - https://www.qdaily.com/articles/62748.html 《终身学习》 - 罗振宇 逻辑思维系列课程摘选 《洋葱阅读法》 「Three Big Things: The Most Important Forces Shapiøng the World」 - https://www.collaborativefund.com/blog/three-big-things-the-most-important-forces-shaping-the-world/ 《今日简史》 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"应届毕业生工作7个月小结","slug":"应届毕业生工作7个月小结","date":"2019-11-22T08:15:00.000Z","updated":"2020-12-09T05:01:45.967Z","comments":true,"path":"2019/11/22/ying-jie-bi-ye-sheng-gong-zuo-7-ge-yue-xiao-jie/","link":"","permalink":"http://www.wmyskxz.com/2019/11/22/ying-jie-bi-ye-sheng-gong-zuo-7-ge-yue-xiao-jie/","excerpt":"","text":"前言： 不知不觉已经工作了快 7 个月了，去年这个时候还跻身在考研的大军中，不禁有些感慨… 结合这 7 个月发生的一些事情，简单做一下总结吧… 为获得更好的阅读体验，请访问原文地址：传送门 一、那时候刚入职 不同于其他同学忙于毕设的 4 月，提早安排趁寒假已经完成毕设的我，已经开始扑在了「找工作」这件事上，有了去年「秋招」打下的基础，复习起来快了很多，没过多久就开始投简历面试了，面试也总体比较顺利，刚面没几家就迅速和一家自己看好的初创公司签下了。 公司使用的技术栈区别于自己熟悉的 Java/ MySQL 这一套，而是主要使用的 Rails/ MongoDB，所以刚入职的一段时间，基本上都是在自己熟悉技术栈，也趁着闲暇的时间，把自己入门时候的一些学习心得写成了文章发表： MongoDB【快速入门】：http://www.wmyskxz.com/2019/04/25/mongodb-kuai-su-ru-men/ Java转Ruby【快速入门】：http://www.wmyskxz.com/2019/04/26/java-zhuan-ruby-kuai-su-ru-men/ 对于职场小白来说，所谓「职场」还是显得有些陌生，刚来的时候，虽然跟周围的同事都稀松平常地打了一圈儿招呼，坐下之后，随着他们又埋头噼里啪啦敲打键盘工作的深入，又顿觉周围一片陌生，还挺奇妙的，在第一周完的周报里面我写道： 刚来公司有些迷茫，只是看着CheckList对照着熟悉一些技术，也不了解自己应该要熟悉到哪种程度，就希望自己能再主动些，不管是技术问题还是其他问题多请教，然后尽快跟其他成员熟悉起来。 刚开始上手的时候也有好多问题不懂，我都习惯性的选择自己研究一阵儿，因为自己有写博客的一些经历，被问过好多一搜索 or 自己一尝试就能解决的问题，所以比较克制，但是后来「入职 1v1」沟通的时候被说到有问题别自己死磕，半个小时没解决尽量就找一下旁边的同事。摁？我一下子就把我的「主动性」发挥了出来。 不过好记性也不如烂笔头，找了一些工具记录把这些「问题的答案」都记录了下来，方便之后再查找，当时对于 Git 都不是很熟悉，也记录了很多常用的命令在里面，还有一些问题的反馈，甚至知道了月会要自我介绍，也打了一遍草稿记录在了这里：（那段时间真的问了好多问题，周报里也手动感谢了坐我旁边的两位大佬..） 入职两周的时候，虽然已经开始上手做一些简单的埋点工作，但自己对于 Ruby 还是不是特别了解和熟悉，趁着某一个双休，抓着一本《Effetive-Ruby》啃了两天，也把自己的学习输出了一下： 《Effective-Ruby》读书笔记：http://www.wmyskxz.com/2019/05/12/effective-ruby-du-shu-bi-ji/ 二、逐渐能够上手 就这样一边熟悉，一边开始接一些小需求，我记得我写下的第一个 BUG，就报出了 6K 条记录.. 慌慌张张在修复之后我不禁感叹：「不要太相信用户的任何数据」。（包括 equal 反写也是之后在错误之中学习到的..） 刚上手没有一段时间，就接到了一个新项目的需求，跟着一位大佬开发一个新功能，大佬负责搭建基础代码和设计，我负责完成其余的功能代码，没敢一丝懈怠，下班回家之后也对照着别人写的代码敲敲敲，时间和完成度上倒是没有一丝耽搁，只是现在回过头一想，当时没有什么单元测试的概念和意识，就自己在本地 Post-Man 测试完就完，所幸比较简单 + 自己测试得比较仔细，到现在也没有出现过什么问题。 工作对我这样的小白另一个好处就是：「见识和增加技术的广度」。公司所使用技术栈不论是广度还是深度，都是自己在大学本科的学习中不可企及的程度，Jekins？Docker？K8S？跳板机？一下子冒出来好多新鲜陌生的名词，怀着好奇心也尝试了解了一些： 了解【Docker】从这里开始：http://www.wmyskxz.com/2019/05/29/liao-jie-docker-cong-zhe-li-kai-shi/ 「消息队列」看过来！：http://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/ Kafka【入门】就这一篇！：http://www.wmyskxz.com/2019/07/17/kafka-ru-men-jiu-zhe-yi-pian/ 也随着公司的逐渐壮大，各模块的耦合也越发严重，各条业务线之间的协作沟通成本越来越大，逐渐开始提出「微服务」这样的概念，具体怎么样理解就不作讨论了，总之就是期望通过梳理/ 重构/ 拆服务的方式来解决「协作」问题，所以期间也开始了解学习一些这方面的东西： 什么是微服务？：http://www.wmyskxz.com/2019/06/07/shi-me-shi-wei-fu-wu/ 《重构：改善既有代码的设计》读书笔记：http://www.wmyskxz.com/2019/06/08/chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-du-shu-bi-ji/ 甚至期间还做了一些「微服务」的调研，我们选用什么样的姿势和技术栈更加合适，所以也输出了一些关于「Spring Cloud」的东西，但是最终驳回的原因是待我们整个容器化之后 k8s 平台自带了这么一套东西，业务同学只需要关心业务代码就行了，也就没有继续深入了： 你想了解的「Spring Cloud」都在这里：http://www.wmyskxz.com/2019/06/09/ni-xiang-liao-jie-de-springcloud-du-zai-zhe-li/ 然后我们在拆解的过程中，也借鉴到一些「DDD」的思想，也尝试进行了一波学习： 【吐血推荐】领域驱动设计学习输出：http://www.wmyskxz.com/2019/06/13/tu-xie-tui-jian-ling-yu-qu-dong-she-ji-xue-xi-shu-chu/ 总之，这一段时间我一边通过各种小需求，接触和了解了公司的系统的大半，一边学习和了解着各种不同的技术，增加了技术上的广度。 三、开始负责一些项目 为了加速服务化的推进工作和验证「DDD」的一些东西，部门老大把一个边界足够清晰，也足够小的一个模块单独交给我，期望我快速上线，不过最终交付已经逾期快大半个月了.. 虽然从最终的结果来看，顺利交付完成了拆解任务并从 MongoDB 数据库转变成了 MySQL.. 但期间也踩过好些坑，当然也学习到一些东西.. 例如我真实地意识到「完美」这个词的理想化。就拿设计 API 来说吧.. 自己就基于 RESTful 风格设计了好几版.. 左想右想都觉得差一些，有一些接口觉得怎么设计都不优雅.. 后来纠结一阵子也就放弃了.. 再例如写代码这件事情吧，好的代码整洁的代码是一次一次迭代和重构中出来的，如果一开始就想着写出「完美」的代码，那么最终的结果可能就是写不出来代码。 另外一个小插曲是，在做数据迁移的时候，我差点把线上服务器搞挂了.. 我在测试环境验证了一把之后，就直接在线上进行操作了，因为当时对于数据库的操作管控还没有那么严格，加上自己对于线上环境的复杂程度认识不足，我就起了 50 个线程，去分批量地读取 MongoDB 的数据迁移到 MySQL，造成了线上库的性能报警，就赶紧停了.. 紧接着就被一群大佬抓进了一个会议室做事件的复盘.. 说实话，我紧张坏了，第一次经历这样的算是「事故」的情况吧，差一点线上就被我搞挂啦，一时间不知所措… 让人感到温暖的是部门老大随即丢来的消息： 那天还有一些相关的同事都陪我写复盘邮件到了晚上 10：30，现在想来都十分感谢他们。后来回到家我还打电话给我妈，我说我在工作中犯错了，我做了xxxx这些动作，你觉得我做的怎么样呢，老妈的回复也让人安心，只是现在想来，一些后续的动作可以做得更好的… 因为「埋点」这件事涉及到系统的方方面面，我也借此了解了很多不同的模块，也是拜这一点所赐吧，后来我被派到各种各样的支援任务中，同样也因为对不同模块都还不算陌生，都还算完成得不错吧… 时间一晃，在公司就四个月过去了，也在这个过程中从各个大佬那儿都学到了一些东西，在 8 月底发的周报里面我写下了以下的总结： 之后也跟着大佬碰了一些公司的核心模块，期间也没有停止在工作中不断地做学习输出： Git 原理入门解析：http://www.wmyskxz.com/2019/08/16/git-yuan-li-ru-men-jian-xi/ Java计时新姿势√：http://www.wmyskxz.com/2019/07/30/java-ji-shi-xin-zi-shi/ Java8流操作-基本使用&amp;性能测试：http://www.wmyskxz.com/2019/08/03/java8-liu-cao-zuo-ji-ben-shi-yong-xing-neng-ce-shi/ 《代码整洁之道》读书笔记：http://www.wmyskxz.com/2019/09/14/dai-ma-zheng-ji-zhi-dao-du-shu-bi-ji/ React 入门学习：http://www.wmyskxz.com/2019/10/15/react-ru-men-xue-xi/ 谈一谈依赖倒置原则：http://www.wmyskxz.com/2019/11/18/tan-yi-tan-yi-lai-dao-zhi-yuan-ze/ 四、回顾做的不好的部分 对代码还没有保持足够的敬畏之心。 特别是一开始上手的时候，有时候甚至是在线上环境搞测试，后来越来越注重 codereview 和单元测试好了很多。 沟通还不够深入/ 到位 有一次是临时接到一个需求，因为「通用语言」没有达成一致，导致最终交付的结果不符合产品的期望，最终我们所有相关人员在一起开了一个会，统一了「通用语言」，造成了额外的工作和负担，拿到需求就应该确认好相关事宜的，越底层越细节越好，这方面的能力我仍然欠缺，但我已经持续在注意当中。 另一次也是因为这一点，我需要帮助 A 系统拥有某一项功能，之前 A 系统已经介入了 B 系统完成了部分功能，我因为没有进一步地确认 B 系统的现状，就去接入了有完整功能的 C 系统，但其实 B 系统已经在上一周和开发 C 系统和 A 系统的同学对接好了，并完成了相关功能的接入，少了这一部分的沟通，就造成了不少额外的工作量.. 所以「沟通」还是非常重要的，也只能说持续进步吧… 缺少一些主动性 当我头上挂着一些事情的时候，还是能够保持着效率的，只是当我做完了，就时常缺乏一些主动地思考了，通常都是被动地去询问同小组的同事有什么事情是需要帮忙的.. 虽然也积极地参与到自己感兴趣的那些技术评审之类的事情之中，但似乎效果都不佳.. 也没有什么实际好的输出.. 接了一些私活儿黑活儿（没有充分考虑团队之间的配合） 因为「埋点」会接触各个平台的童鞋，并且时常变化和有一些新的需求，有时候直接绕过了一些环节，直接找上我了，我心想直接自己弄弄改改就可以了，也就没多想… 但是现在想来，这样跨团队的事情，不能越过「顶头上司」私自进行，一方面经常我的 BOSS 不知道我接了活儿，另一方面这样的私自对接就会造成一些信息的流失，对于团队之内还是团队之间都会造成影响… 五、回顾做得好的部分 养成了阅读的习惯 公司买书是免费的，也有自己的图书馆，同事也不乏喜欢阅读学习的，所以跟着跟着就养成了阅读的习惯，期间也学习到了一些方法论的东西，贴一下入职以来读过的那些书吧：（技术类的就没有囊括了） 其实每天阅读的时间也不长，想我大学总共捧起的那么些课外书，不禁有些唏嘘… 早睡早起 + 晨间日记 早睡早起，从步入职场以来，就发现这样的习惯会带来一些额外的价值，例如一些阅读我会放在早上，后来还加入了「晨间日记」，用来「回顾前一天的事情」和提前部署「今天的任务」，这不禁让我多了一份清醒，也让现在不怎么锻炼的我每一天精力更加好一些：（目前正在从印象笔记往 Notion 逐步迁移的过程中） 学习撰写 Commit Message &amp;&amp; 遵守一些 Git 规范 起初使用 Git 十分不规范，后来向大佬那儿学习到了如何标准地提交 Commit，包括 Commit Message 应该怎么写，我觉得这是一个很好的习惯，每一个 Commit 都有上下文，并且还带上了 JIRA 号，任务也很好跟踪，虽然公司并没有大范围地盛行起来，但我觉得这样好习惯应该坚持下来： 任务进度及时反馈给相关人员 自己比较注意这一点，因为不这样做会让别人感受不怎么好.. 光是自己心里清楚是不行的.. 要保持信息的通畅才行，及时反馈是很重要的一步.. 自己先 review 一遍代码 犯过一些白痴错误之后，就有些担心，逐步养成了自己先 review 一遍代码的习惯.. 六、小结 &amp;&amp; 展望 总的来说，看着自己这样一步一步成长过来，没有很懈怠，自己就算比较满意了，在工作中学习了很多东西，不管是技术上的硬技能，还是沟通中的软技能，也认识到了很多厉害的大佬和有趣的小伙伴们.. 感恩在路上相遇，有幸共同行走过一段已然算是幸运，突然翻看起自己的朋友圈有一句话说得好：「成长从来都不是告别过去，成长是更加坚定的看向未来！」 期待一路同行的大家，都能够 Be Better！ 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"谈一谈依赖倒置原则","slug":"谈一谈依赖倒置原则","date":"2019-11-18T14:17:00.000Z","updated":"2020-12-09T05:00:34.983Z","comments":true,"path":"2019/11/18/tan-yi-tan-yi-lai-dao-zhi-yuan-ze/","link":"","permalink":"http://www.wmyskxz.com/2019/11/18/tan-yi-tan-yi-lai-dao-zhi-yuan-ze/","excerpt":"为获得良好的阅读体验，请访问原文：传送门","text":"为获得良好的阅读体验，请访问原文：传送门 一、概念 依赖倒置原则（Dependence Inversion Principle，DIP）是指设计代码结构时，高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并且能够降低修改程序所造成的风险。 二、为什么 先来看一个例子可是依赖倒置原则是怎么做到的呢？我们先来看一个例子：一个爱学习的「我没有三颗心脏」同学现在正在学习「设计模式」和「Java」的课程，伪代码如下： public class Wmyskxz { public void studyJavaCourse() { System.out.println(\"「我没有三颗心脏」同学正在学习「Java」课程\"); } public void studyDesignPatternCourse() { System.out.println(\"「我没有三颗心脏」同学正在学习「设计模式」课程\"); } } 我们来模拟上层调用一下： public static void main(String[] args) { Wmyskxz wmyskxz = new Wmyskxz(); wmyskxz.studyJavaCourse(); wmyskxz.studyDesignPatternCourse(); } 原因一：有效控制影响范围由于「我没有三颗心脏」同学热爱学习，随着学习兴趣的 “暴增”，可能会继续学习 AI（人工智能）的课程。这个时候，因为「业务的扩展」，要从底层实现到高层调用依次地修改代码。 我们需要在 Wmyskxz 类中新增 studyAICourse() 方法，也需要在高层调用中增加调用，这样一来，系统发布后，其实是非常不稳定的。显然在这个简单的例子中，我们还可以自信地认为，我们能 Hold 住这一次的修改带来的影响，因为都是新增的代码，我们回归的时候也可以很好地 cover 住，但实际的情况和实际的软件环境要复杂得多。 最理想的情况就是，我们已经编写好的代码可以 “万年不变”，这就意味着已经覆盖的单元测试可以不用修改，已经存在的行为可以保证保持不变，这就意味着「稳定」。任何代码上的修改带来的影响都是有未知风险的，不论看上去多么简单。 原因二：增强代码可读性和可维护性另外一点，你有没有发现其实加上新增的 AI 课程的学习，他们三节课本质上行为都是一样的，如果我们任由这样行为近乎一样的代码在我们的类里面肆意扩展的话，很快我们的类就会变得臃肿不堪，等到我们意识到不得不重构这个类以缓解这样的情况的时候，或许成本已经变得高得可怕了。 原因三：降低耦合《资本论》中有这样一段描述： 在商品经济的萌芽时期，出现了物物交换。假设你要买一个 iPhone，卖 iPhone 的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的 APP 来换他一头猪，他说换猪可以，但是得用一条金项链来换… 所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象——也就是货币——来进行交换，这样一来耦合度就大为降低了。 三、怎么做 我们现在的代码是上层直接依赖低层实现，现在我们需要定义一个抽象的 ICourse 接口，来对这种强依赖进行解耦（就像上面《资本论》中的例子那样）： 接下来我们可以参考一下伪代码，先定一个课程的抽象 ICourse 接口： public interface ICourse { void study(); } 然后编写分别为 JavaCourse 和 DesignPatternCourse 编写一个类： public class JavaCourse implements ICourse { @Override public void study() { System.out.println(\"「我没有三颗心脏」同学正在学习「Java」课程\"); } } public class DesignPatternCourse implements ICourse { @Override public void study() { System.out.println(\"「我没有三颗心脏」同学正在学习「设计模式」课程\"); } } 然后把 Wmyskxz 类改造成如下的样子： public class Wmyskxz { public void study(ICourse course) { course.study(); } } 再来是我们的调用： public static void main(String[] args) { Wmyskxz wmyskxz = new Wmyskxz(); wmyskxz.study(new JavaCourse()); wmyskxz.study(new DesignPatternCourse()); } 这时候我们再来看代码，无论「我没有三颗心脏」的兴趣怎么暴涨，对于新的课程，都只需要新建一个类，通过参数传递的方式告诉它，而不需要修改底层的代码。实际上这有点像大家熟悉的依赖注入的方式了。 总之，切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此在拿到需求后，要面相接口编程，先顶层设计再细节地设计代码结构。 参考资料 https://www.cnblogs.com/aoyeyuyan/p/5495219.html - 那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程 《Spring 5 核心原理 与 30 个类手写实战》 - 谭勇德 著 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693钱","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"基础知识/设计模式","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"React入门学习","slug":"React入门学习","date":"2019-10-15T15:23:00.000Z","updated":"2020-12-09T05:08:59.263Z","comments":true,"path":"2019/10/15/react-ru-men-xue-xi/","link":"","permalink":"http://www.wmyskxz.com/2019/10/15/react-ru-men-xue-xi/","excerpt":"为了获得更好的阅读体验，请访问原地址：传送门","text":"为了获得更好的阅读体验，请访问原地址：传送门 一、React 简介 React 是什么React 是一个起源于 Facebook 的内部项目，因为当时 Facebook 对于市场上所有的 JavaScript MVC 框架都不太满意，所以索性就自己写了一套，用来架设 Instagram。做出来之后，发现这套东西还蛮好用的，于是就在 2013 年 5 月开源了。 在这里我们需要稍微注意一下 库(Library) 和 框架(Framework) 的区别，React 本身是一个用于构建用户界面的 JavaScript 库，而我们平时所说的 React 框架其实是指的是 React/ React-router 和 React-redux 的结合体，库和框架的本质区别体现在于控制权： 「库」是一个封装好的特定的集合，提供给开发者使用，而且是特定于某一方面的集合（方法和函数），库没有控制权，控制权完全在于使用者本身； 「框架」顾名思义是一套架构，会基于自身的特点向用户提供一套比较完整的解决方案，如果使用者选定了一套框架，那么就需要根据框架本身做出一定的适应。 为什么使用 React？这是一个非常有趣的问题，也让我困惑和苦恼。在笔者还在学校的时候尝试用 Vue 搭建了一套简单的博客系统，学习曲线平滑，让只会一些基础 HTML/ CSS 代码的我通过一段时间学习就能够上手了，但是学习 React 以来，进展变得相对缓慢.. 一部分原因是因为 React 创新性的开发模式以及让我感到无所适从的 JSX 语法（菜才是原罪）。 Vue 作者尤雨溪在知乎上回答「Vue 和 React 的优点分别是什么？」这个问题的时候提到 ： 这里我可以大方地承认，如果多年以后要论历史地位，React 肯定是高于 Vue 的。事实上，我作为一个开发者，也是由衷地佩服 Jordan Walke, Sebastian Markbage 这样的，能从开发模式层面上提出突破性的新方向的人。 React 从一开始的定位就是提出 UI 开发的新思路。当年 Pete Hunt 最开始推广 React 的时候的一句口号就叫 “Rethinking Best Practices”，这样的定位使得 React 打开了一些全新的思路，吸引了一群喜欢折腾的早期核心用户，并在这个基础上通过社区迭代孵化出了许多今天被 React 开发者当作常识的 pattern。这是 React 伟大的地方，Vue 里面也有很多地方是直接受到了 React 的启发。React 敢做这样的尝试，是因为它是 Facebook。这样的体量的公司，在 infrastructure 层面获得质的提升，收益是巨大的，而且 Facebook 的工程师们足够聪明又要靠工资吃饭，改变他/她们的习惯并不是什么问题。而对外推广，则是一种大公司才有的 “改变业界” 的底气。 相比「为什么使用 React？」的理由，称赞 React 的倒是明显更多一些（React 确实是突破性的开发模式）。 是因为 React 组件化的思想吗？不是。我觉得这跟多少跟微服务化之类的概念有点儿类似，这是属于一个时代对于计算机工程的思想进步，是对于团队协作提出的新一种成熟的解决方案，也是必然的一种趋势。当前流行的不管是 Angular/ Vue 还是 React，都天然的支持着组件化的概念。 那是因为 React 性能出众吗？我想也不是。或许 React 刚出世时因为其独特高效的虚拟 DOM 设计，能够在前端江湖中平步青云，但是现在前端技术都主键地趋于成熟（我也不懂，我乱说的..），从很多地方的对比数据中，都能够看得到其实 React 与其他框架的性能差异并不是特别大。并且体现在平时的开发中，这样对比不明显的速度差异，根本没有多大的用处。 还看到一种观点，说 React 适用于构建大型的项目。从我并不多的了解中，我知道 React 体系中天然有着许多的约束，以及一些不成文的约定，这就好像是 SpringBoot 中默认提供给使用者的一些姿势，天然就有很强的工程性，加上一些约定俗成的代码风格 or 归约，这就使得 Java 很适合一些大型的团队项目。但能不能开发大型的项目从来都是取决于人，而不是采用了哪种框架。 所以比较令我信服的理由是（我乱猜的）：像 Java 一样，React 体系足够成熟，社区也非常活跃，你遇到的问题很容易在网络上找到答案，并且也有一些成熟的实践 or 轮子用以解决各种各样的问题。而且 React 还有一个比较特别的特性是：你能够比较无痛地使用 React Native 开发原生移动应用。 二、React 核心概念 虚拟 DOM（Vitural Document Object Model）要理解这个「虚拟 DOM」的概念，首先我们就需要知道什么是「DOM」。我们先暂时忘掉什么网页之类的，我们想象现在我们需要编写程序来对下列的 Markdown 文档进行改变应该怎么做： # Title ## subtitle - 1 content - 1 ## subtitle - 2 content - 2 比如我现在就想要 content - 2 的内容进行改变，那么我就需要一行一行的不断遍历直到最后遍历到它才能进行操作，对内容改变的操作都差不多，所以如果我想对这个查找的操作进行优化，最简单的想法就是把它树化以减少高度，增加效率。 DOM 的概念DOM 是英文 Document Object Model 的缩写，即文档对象模型。它是一种跨平台的、独立于编程语言的 API，它把 HTML、XHTML 或 XML 文档都当做一个树结构，而每个节点视为一个对象，这些对象可以被编程语言操作，进而改变文档的结构，映射到文档的显示。DOM 最开始的时候是和 JavaScript 交织在一起的，只是后来它们最终演变成了两个独立的实体。DOM 被设计成与特定编程语言相独立，尽管绝大部分时候我们都是使用 JavaScript 来操作，但其实其他的语言一样可以（如 Python）。 假如有这么一段 HTML 代码： &lt;html> &lt;head> &lt;title>文档标题&lt;/title> &lt;/head> &lt;body> &lt;a href=\"\">链接&lt;/a> &lt;h1>标题&lt;/h1> &lt;/body> &lt;/html> 那么它最终就应该会是下面这棵树一样的结构： 这里不对 DOM 节点的类型啊方法之类的进行讨论，我们只需要对 DOM 有一个大致的概念就好了。 浏览器渲染 DOM 的流程我们可以简单了解一下浏览器渲染 DOM 的流程： 解析 HTML 建立 DOM 树； 解析 CSS，并结合 DOM 树形成 Reander 树； 布局 Render 树（Layout/ reflow），确定各节点的尺寸、位置等信息； 绘制 Render 树（Paint），绘制页面像素信息； 浏览器将各层信息发给 GPU，GPU 会将各层合成（Composite），显示在屏幕上； 操作 DOM 为什么慢其实严格来说，单纯的操作 DOM 并不慢，说它慢是带有一定条件的。 想象在一次事件循环中多次操作 DOM 时，有时希望 JS 代码中能立刻获取最新的 DOM 节点信息，这时浏览器不得不挂起 JS 引擎，转而调用 DOM 引擎，计算渲染出最新的 DOM，以此来获取最新的 DOM 节点信息，接着再重新激活 JS 引擎 继续后续的操作。 可以预见，上述操作不仅需要多次进行引擎的切换，还需要多次计算布局，重新绘制 DOM。事实上paint是一个耗时的过程，然而layout是一个更耗时的过程，我们无法确定layout一定是自上而下或是自下而上进行的，甚至一次layout会牵涉到整个文档布局的重新计算。 但是layout是肯定无法避免的，所以我们主要是要最小化layout的次数。 所以，降低引擎切换频率、减小 DOM 变更规模才是 DOM 性能优化方案的关键！ Virtual DOM 算法步骤虚拟 DOM 正是解决了上述问题，它的本质就是用 JS 对象来模拟出我们真实的 DOM 树，它的算法大致如下： 用 JavaScript 对象映射形成 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中； 当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较（Diff 算法），记录两棵树差异； 把第二步中所记录的差异应用到步骤一所构建的真正的 DOM 树上，视图就更新。 虚拟 DOM 和真实 DOM 的区别我们由此可以对比出两者的不同： 改变多个状态，影响多个节点布局时，只是频繁的修改了内存中的 JS 对象，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗； 真实 DOM 频繁排版与重绘的效率是相当低的； 虚拟 DOM 有效降低大面积（真实 DOM 节点）的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部（同2）； 使用虚拟DOM的损耗计算： 总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘 直接使用真实DOM的损耗计算： 总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘 Diff 算法虚拟 DOM 的核心在于 Diff，它自动帮你计算那些应该调整的，然后只修改应该被调整的区域，省下的不是运行速度这种 “小速度”，而是开发速度/ 维护速度/ 逻辑简练程度等 “总体速度”。 但虚拟 DOM 快也是在相对条件下的，这里引用 @尤雨溪大大在知乎问题《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》上回答的一句话吧： 不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。 Diff 大致可以分为三种类型： Tree Diff： 新旧两棵 DOM 树，逐层对比的过程，就是 Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够找到； Component Diff： 在进行 Tree Diff 的时候，每一层中，组件级别的对比，叫做 Component Diff： 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新； 如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上； Element Diff： 在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫做 Element Diff； 三、Hello World 引用自：http://www.ruanyifeng.com/blog/2015/03/react.html - 阮一峰 - React 入门实例教程 使用 React 的网页源码，结构大致如下（可以直接运行）： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"/> &lt;title>Hello React!&lt;/title> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;/head> &lt;body> &lt;div id=\"example\">&lt;/div> &lt;script type=\"text/babel\"> ReactDOM.render( &lt;h1>Hello, world!&lt;/h1>, document.getElementById('example') ); &lt;/script> &lt;/body> &lt;/html> 上面代码有两个地方需要注意。首先，最后一个 &lt;script&gt; 标签的 type 属性为 text/babel 。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=&quot;text/babel&quot; 。 其次，上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。 $ babel src --out-dir build 上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录。 ReactDOM.render()ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 ReactDOM.render( &lt;h1>Hello, world!&lt;/h1>, document.getElementById('example') ); 上面代码将一个 h1 标题，插入 example 节点，运行结果如下： JSX 语法 引用自：https://www.runoob.com/react/react-jsx.html - RUNOOB.COM - React JSX 上一节的代码， HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。我们先来看以下一段代码： const element = &lt;h1>Hello, world!&lt;/h1>; 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。要将 React 元素渲染到根 DOM 节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上： var myDivElement = &lt;div className=\"foo\" />; ReactDOM.render(myDivElement, document.getElementById('example')); JSX 看起来类似 HTML ，你也可以在上面代码中嵌套多个 HTML 标签，但是需要使用一个 div 元素包裹它。 JavaScript 表达式我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下： ReactDOM.render( &lt;div> &lt;h1>{1+1}&lt;/h1> &lt;/div> , document.getElementById('example') ); 在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false. ReactDOM.render( &lt;div> &lt;h1>{i == 1 ? 'True!' : 'False'}&lt;/h1> &lt;/div> , document.getElementById('example') ); 样式React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。以下实例演示了为 h1 元素添加 myStyle 内联样式： var myStyle = { fontSize: 100, color: '#FF0000' }; ReactDOM.render( &lt;h1 style = {myStyle}>菜鸟教程&lt;/h1>, document.getElementById('example') ); 注释注释需要写在花括号中，实例如下： ReactDOM.render( &lt;div> &lt;h1>菜鸟教程&lt;/h1> {/*注释...*/} &lt;/div>, document.getElementById('example') ); 数组JSX 允许在模板中插入数组，数组会自动展开所有成员： var arr = [ &lt;h1>菜鸟教程&lt;/h1>, &lt;h2>学的不仅是技术，更是梦想！&lt;/h2>, ]; ReactDOM.render( &lt;div>{arr}&lt;/div>, document.getElementById('example') ); 参考资料 http://www.ruanyifeng.com/blog/2015/03/react.html - React 入门实例教程 - 阮一峰 https://www.jianshu.com/p/60100985dd7f - 前端框架与库的区别 https://www.zhihu.com/question/301860721/answer/545031906 - Vue 和 React 的优点分别是什么？ https://zhuanlan.zhihu.com/p/22184194 - 你真的理解 DOM 了吗？ https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction - DOM 概述 https://blog.huteming.site/posts/e0c41c5f/ - 为什么说虚拟DOM更快 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693钱","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"分布式任务调度平台XXL-JOB","slug":"分布式任务调度平台XXL-JOB","date":"2019-10-02T07:47:00.000Z","updated":"2020-12-09T04:53:03.632Z","comments":true,"path":"2019/10/02/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/","link":"","permalink":"http://www.wmyskxz.com/2019/10/02/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/","excerpt":"","text":"为获得更好的阅读体验，请访问原文：传送门 一、分布式任务调度概述 什么是任务调度平台任务调度是指基于给定的时间点，给定的时间间隔又或者给定执行次数自动的执行任务。我们可以思考一下在以下场景中，我们应该怎么实现： 支付系统每天凌晨 1 点，进行一天清算，每月 1 号进行上个月清算； 电商整点抢购，商品价格8点整开始优惠 12306 购票系统，超过 30 分钟没有成功支付订单的，进行回收处理 为什么需要任务调度平台定时任务是程序员不可避免的话题，很多业务场景需要我们某一特定的时刻去做某件任务。一般来说，系统可以使用消息传递代替部分定时任务（比如商品成功发货后，需要向客户发送短信提醒），两者有很多相似之处，一些场景下也可以相互替换，但是有一些不能： 时间驱动/ 事件驱动： 内部系统一般可以通过事件来驱动，但如果涉及到外部系统，则只能使用时间驱动。如爬取外部网站价格，每小时爬一次。 批量处理/ 逐条处理： 批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理，如移动每个月结算我们的花费。 实时性/ 非实时性： 消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip 升级。 系统内部/ 系统解耦： 定时任务调度一般是在系统内部，而消息中间件可用于两个系统间 并且对于分布式系统来说，如果处理不当，会存在同一系统不同节点之间定时任务相互影响的问题，再考虑上监控、日志、信息面板，加上不同系统之间管理维护的问题，自己实现一套的成本又上来了..所以我们可以考虑一些比较成熟的任务调度平台来使用。 任务调度框架选型Java 领域主要分布式调度系统如下： xxl-job：是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展 。 Elastic-Job： 当当开源的分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成；Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务；Elastic-Job-Cloud采用自研Mesos Framework的解决方案，额外提供资源治理、应用分发以及进程隔离等功能； Saturn：是唯品会开源的一个分布式任务调度平台，在当当开源的Elastic Job基础上，取代传统的Linux Cron/Spring Batch Job的方式，做到全域统一配置，统一监控，任务高可用以及分片并发处理； light-task-scheduler：阿里员工开源的个人项目,主要用于解决分布式任务调度问题，支持实时任务，定时任务和Cron任务。有较好的伸缩性，扩展性，健壮稳定性 Quartz: Java定时任务的标配。利用数据库的锁机制实现集群调度，业务代码需要考虑调度的逻辑，对业务代码有入侵。 在这之前，我是一个都不知道的..有很多文章对他们进行对比，我们就参考其中一篇（下 2），选择热门且成熟的 XXL-JOB 来上手研究一下。 二、XXL-JOB 概述 官方中文文档：http://www.xuxueli.com/xxl-job/ XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 快速入门 - 本地运行先定个小目标，先把它在本地跑起来先。 第一步：下载代码到本地找一个合适的目录，然后执行下列语句把代码下载到本地： $ git clone https://github.com/xuxueli/xxl-job.git 第二步：执行初始化 SQL，再用 IDEA 打开找到 /xxl-job/doc/db/table_xxl_job.sql 初始化 SQL 脚本，并在本地执行。 然后按照 Maven 格式将源码导入 IDEA，源码结构如下： xxl-job-admin：调度中心 xxl-job-core：公共依赖 xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器） ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式； ：xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用； ：xxl-job-executor-sample-frameless：无框架版本； ：xxl-job-executor-sample-jfinal：JFinal版本，通过JFinal管理执行器； ：xxl-job-executor-sample-nutz：Nutz版本，通过Nutz管理执行器；第三步：配置并启动 “调度中心”调度中心配置文件地址： /xxl-job/xxl-job-admin/src/main/resources/xxl-job-admin.properties调度中心配置内容说明： ### 调度中心JDBC链接：链接地址请保持和初始化时创建的数据库保持一致 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 spring.datasource.username=root spring.datasource.password=root_pwd spring.datasource.driver-class-name=com.mysql.jdbc.Driver ### 报警邮箱 spring.mail.host=smtp.qq.com spring.mail.port=25 spring.mail.username=xxx@qq.com spring.mail.password=xxx spring.mail.properties.mail.smtp.auth=true spring.mail.properties.mail.smtp.starttls.enable=true spring.mail.properties.mail.smtp.starttls.required=true spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory ### xxl-job, access token xxl.job.accessToken= ### xxl-job, i18n (default empty as chinese, \"en\" as english) xxl.job.i18n= 在第一次启动的项目的时候可能会遇到找不到 log 文件的错误（Failed to create），我们只需要自己手动创建一下就好了，具体可以参照这篇文章：https://blog.csdn.net/leeue/article/details/100779424，记得之后再手动把当前目录权限置为可写状态哦：`sudo chmod 777 xxl-job` 当一切配置好了之后，我们就可以启动项目了，调度中心访问地址：http://localhost:8080/xxl-job-admin（该地址执行期将会使用到，作为回调地址），默认登录账号 “admin/123456”，登录后运行界面如下图所示： 至此，「调度中心」项目已经部署成功了，调度中心集群（可选）配置可参考官方文档。 第四步：配置启动”执行器”执行器配置，配置文件地址： /xxl-job/xxl-job-executor-samples/xxl-job-executor-sample-springboot/src/main/resources/application.properties执行器配置，配置内容说明： ### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行\"执行器心跳注册\"和\"任务结果回调\"；为空则关闭自动注册； xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin ### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册 xxl.job.executor.appname=xxl-job-executor-sample ### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 \"执行器注册\" 和 \"调度中心请求并触发任务\"； xxl.job.executor.ip= ### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口； xxl.job.executor.port=9999 ### 执行器通讯TOKEN [选填]：非空时启用；(注意与调度中心保持一致) xxl.job.accessToken= ### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径； xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler ### 执行器日志保存天数 [选填] ：值大于3时生效，启用执行器Log文件定期清理功能，否则不生效； xxl.job.executor.logretentiondays=-1 同样，也要注意一下日志文件的创建和权限问题，解决方法同上。 当配置完成之后运行起来，我们就可以在刚才的任务调度中心的主页，在右上角的「执行器的数量」上 + 1 了。 第五步：开发第一个任务当「调度中心」和「执行器」都启动之后，我们可以直接在「调度中心」的任务管理界面新增一条配置如下图所示（参考）的任务： 我们点击「操作」按钮下的「GLUE IDE」可以手动编写我们要执行的脚本，我们可以把我们的任务代码改写成如下的样子： package com.xxl.job.service.handler; import com.xxl.job.core.log.XxlJobLogger; import com.xxl.job.core.biz.model.ReturnT; import com.xxl.job.core.handler.IJobHandler; import java.util.concurrent.TimeUnit; public class DemoGlueJobHandler extends IJobHandler { @Override public ReturnT&lt;String> execute(String param) throws Exception { XxlJobLogger.log(\"XXL-JOB, Hello World.\"); for (int i = 0; i &lt; 5; i++) { XxlJobLogger.log(\"beat at:\" + i); TimeUnit.SECONDS.sleep(2); } return SUCCESS; } } 点击「保存」，然后继续在「操作」按钮下点击「执行一次」的操作，就可以在「调度日志」中看到我们的任务执行情况啦： 可以看到默认执行器中的日志输出了： 回头理解一下过程到目前为止，我们整个搭建运行的过程都比较顺滑，没有出现什么阻碍，现在我们稍微来理解一下这个过程。 首先我们在本地初始化了框架提供的 SQL 语句，里面定义的结构足够我们不管是单机还是分布式的任务管理需求。然后我们简单配置了一下连接的数据库、报警邮件、token 等信息成功启动了「调度中心」项目。这个时候项目中默认注册一个名字为 xxl-job-exectutor-sample 的执行器（名字同默认执行器的 AppName），并且采用的是自动注册的方式。 等我们把执行器配置项里的 xxl,job.admin.addresses 填写上「调度中心」实际的地址，然后 token 保持与「调度中心」一致，启动执行器时，执行器就会把自身的一些基础信息发送给「调度中心」，这时候「调度中心」会把接收到的注册信息与自身注册列表里的 AppName 进行对比（AppName 是每一个执行器的唯一标示），有匹配时就会把 ip 自动填写上（多个节点就写多个地址），并在 xxl_job_registry 表上更新信息。执行器可以简单理解为项目内嵌了端口为 9999（默认端口）的一个 Server。（架构图如下） 任务 “运行模式”在刚才的「快速入门」中，我们新建了一个「GLUE模式(Java)」模式的任务，我们在新建任务时可以直接在「调度中心」上编辑代码，然后让我们的 ”执行器“ 执行，这样的一种模式是把代码直接放在「调度中心」的做法，它的原理是：每个 “GLUE模式(Java)” 任务的代码，实际上是“一个继承自 “IJobHandler” 的实现类的类代码”，“执行器”接收到“调度中心”的调度请求时，会通过 Groovy 类加载器加载此代码，实例化成 Java 对象，同时注入此代码中声明的 Spring 服务（请确保 Glue 代码中的服务和类引用在“执行器”项目中存在），然后调用该对象的 execute 方法，执行任务逻辑。 另外一种方式是你提前把代码写进「执行器」程序中，这样的模式在 XXL-JOB 中叫做「Bean模式」：每个 Bean 模式任务都是一个 Spring 的 Bean 类实例，它被维护在“执行器”项目的 Spring 容器中。任务类需要加 “@JobHandler(value=”名称”)” 注解，因为“执行器”会根据该注解识别 Spring 容器中的任务。任务类需要继承统一接口 “IJobHandler”，任务逻辑在 execute 方法中开发，因为“执行器”在接收到调度中心的调度请求时，将会调用 “IJobHandler” 的 execute 方法，执行任务逻辑。 例如在 XXL-JOB 提供的实例代码中就有下面这么一段儿： package com.xxl.job.executor.service.jobhandler; import com.xxl.job.core.biz.model.ReturnT; import com.xxl.job.core.handler.IJobHandler; import com.xxl.job.core.handler.annotation.JobHandler; import com.xxl.job.core.log.XxlJobLogger; import org.springframework.stereotype.Component; import java.util.concurrent.TimeUnit; /** * 任务Handler示例（Bean模式） * * 开发步骤： * 1、继承\"IJobHandler\"：“com.xxl.job.core.handler.IJobHandler”； * 2、注册到Spring容器：添加“@Component”注解，被Spring容器扫描为Bean实例； * 3、注册到执行器工厂：添加“@JobHandler(value=\"自定义jobhandler名称\")”注解，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 4、执行日志：需要通过 \"XxlJobLogger.log\" 打印执行日志； * * @author xuxueli 2015-12-19 19:43:36 */ @JobHandler(value=\"demoJobHandler\") @Component public class DemoJobHandler extends IJobHandler { @Override public ReturnT&lt;String> execute(String param) throws Exception { XxlJobLogger.log(\"XXL-JOB, Hello World.\"); for (int i = 0; i &lt; 5; i++) { XxlJobLogger.log(\"beat at:\" + i); TimeUnit.SECONDS.sleep(2); } return SUCCESS; } } 我们就能在创建任务时直接按照下图这样创建，那么在调用任务时，”执行器” 就能够如愿的执行上面的逻辑： 当然 XXL-JOB 还能支持一些脚本语言类型的模式： - shell脚本：任务运行模式选择为 &quot;GLUE模式(Shell)&quot;时支持 &quot;shell&quot; 脚本任务； - python脚本：任务运行模式选择为 &quot;GLUE模式(Python)&quot;时支持 &quot;python&quot; 脚本任务； - nodejs脚本：务运行模式选择为 &quot;GLUE模式(NodeJS)&quot;时支持 &quot;nodejs&quot; 脚本任务；三、接入指南 前提：已经搭建并成功运行了「调度中心」服务。 快速接入第一步，我们需要在 pom 文件中引入 xxl-job-core 的 Maven 依赖，不过比较奇怪的是，明明 Github 上最新版本是 2.1.1，Maven 仓库上却没有最新的包，所以只能用 2.1.0 的： &lt;dependency> &lt;groupId>com.xuxueli&lt;/groupId> &lt;artifactId>xxl-job-core&lt;/artifactId> &lt;version>2.1.0&lt;/version> &lt;/dependency> 第二步，在配置文件中加入 xxl 相关的配置文件信息，不管 yml 格式还是 properties 都行，上面提供了 properties 的版本，这了就提供一个 yml 格式的作参考吧： xxl: job: accessToken: xxxx admin: addresses: http://127.0.0.1:8080/xxl-job-admin executor: appname: test logpath: /data/applogs/xxl-job/jobhandler logretentiondays: -1 ip: port: 9999 第三步，在合适的包目录下新建 XxlJobConfig 配置类： @Configuration public class XxlJobConfig { private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(\"${xxl.job.admin.addresses}\") private String adminAddresses; @Value(\"${xxl.job.executor.appname}\") private String appName; @Value(\"${xxl.job.executor.ip}\") private String ip; @Value(\"${xxl.job.executor.port}\") private int port; @Value(\"${xxl.job.accessToken}\") private String accessToken; @Value(\"${xxl.job.executor.logpath}\") private String logPath; @Value(\"${xxl.job.executor.logretentiondays}\") private int logRetentionDays; @Bean(initMethod = \"start\", destroyMethod = \"destroy\") public XxlJobSpringExecutor xxlJobExecutor() { logger.info(\">>>>>>>>>>> xxl-job config init.\"); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppName(appName); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; } /** * 针对多网卡、容器内部署等情况，可借助 \"spring-cloud-commons\" 提供的 \"InetUtils\" 组件灵活定制注册IP； * * 1、引入依赖： * &lt;dependency> * &lt;groupId>org.springframework.cloud&lt;/groupId> * &lt;artifactId>spring-cloud-commons&lt;/artifactId> * &lt;version>${version}&lt;/version> * &lt;/dependency> * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: 'xxx.xxx.xxx.' * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */ } 至此，我们的项目就差不多完成了我们的接入工作了，就只剩下开发 Handler 的工作量了。 第四步，建一个示例 DemoJobHandler 在平台上自测一下： @JobHandler(value=\"demoJobHandler\") @Component public class DemoJobHandler extends IJobHandler { @Override public ReturnT&lt;String> execute(String param) throws Exception { XxlJobLogger.log(\"XXL-JOB, Hello World.\"); for (int i = 0; i &lt; 5; i++) { XxlJobLogger.log(\"beat at:\" + i); TimeUnit.SECONDS.sleep(2); } return SUCCESS; } } 然后我们可以启动项目，看看「调度中心」是否已经成功注册当前项目的「执行器」，再使用上面介绍的「新建任务」的方法，来测试一下是否正常接入。 小结总体来说 XXL-JOB 非常的容易上手，并且官方提供了很友好的实例代码，包括一些高级特性「分片」、「远程调用」等多种任务都能够很好的通过示例代码理解和使用，这里就不再详细赘述了..官方文档已经很完善了，感兴趣的小伙伴可以去阅读以下。 参考资料 https://www.expectfly.com/2017/08/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/ - 分布式定时任务调度系统选型 https://www.yzhu.name/2019/03/30/Schedule-Job/ - 分布式调度系统选型 https://blog.csdn.net/qq924862077/article/details/82708610 - XXL-JOB原理–执行器注册（二） 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"其他","slug":"后端/中间件/其他","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%85%B6%E4%BB%96/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"《代码整洁之道》读书笔记","slug":"《代码整洁之道》读书笔记","date":"2019-09-14T09:35:00.000Z","updated":"2020-12-09T03:20:53.941Z","comments":true,"path":"2019/09/14/dai-ma-zheng-ji-zhi-dao-du-shu-bi-ji/","link":"","permalink":"http://www.wmyskxz.com/2019/09/14/dai-ma-zheng-ji-zhi-dao-du-shu-bi-ji/","excerpt":"为了获得更好的阅读体验，请访问原文：传送门","text":"为了获得更好的阅读体验，请访问原文：传送门 一、前言 代码是什么呢？或者说作为程序员的我们，对于写代码这件事又是抱着怎样的一种态度呢？我时常都在想，如今我如愿成为了一名程序员（虽然还很菜），写代码这件事成了我的工作，我期望从工作中获得些什么？而工作又能给予我什么呢？ 我在短暂的工作经历中（4 个月），犯下过不少错，少部分是因为经验，但大部分的情况下都是因为对代码没有足够的敬畏之心导致的，并且在工作中也遇到过一些很有意思的代码，所以今天就着这本《代码整洁之道》，来谈一谈对于代码的感受和一些想法。（Ps：想吐槽一下这本书挺魔怔的..） 二、什么是整洁的代码 我搜索「代码」这两个关键字，给出的官方解释都特别有意思，摘一下百度百科的好了： 代码就是程序员用开发工具所支持的语言写出来的源文件，是一组由字符、符号或信号码元以离散形式表示信息的明确的规则体系。代码设计的原则包括唯一确定性、标准化和通用性、可扩充性与稳定性、便于识别与记忆、力求短小与格式统一以及容易修改等。 源代码是代码的分支，某种意义上来说，源代码相当于代码。现代程序语言中，源代码可以书籍或磁带形式出现，但最为常用格式是文本文件，这种典型格式的目的是为了编译出计算机程序。计算机源代码最终目的是将人类可读文本翻译成为计算机可执行的二进制指令，这种过程叫编译，它由通过编译器完成。 好了，学术介绍一大堆，重点还是在最后一句：计算机源代码最终目的是将人类可读文本翻译成为计算机可执行的二进制指令。 再精简一下：「人类可读」、「计算机可执行」。 说到底，代码最终还是写给人看的，所以「可读性」就显得尤为重要，但总归我们是要先有「代码」，再有「可读的代码」，经过不断重构or重写，最终形成我们「简洁的代码」。 说几点感受比较大的吧。 方法尽量短 &amp;&amp; 职责单一有谁能告诉我下面这个方法究竟是在做什么吗？ /** * @author Administrator * */ public class GeneratePrimes { /** * @param maxValue is the generation limit. * */ public static int[] generatePrimes(int maxValue) { if (maxValue >= 2){ //the only valid case //ddeclarations int s = maxValue +1 ;// size of array boolean[] f = new boolean[s]; int i; //initialize array to true. for ( i = 0;i &lt; s;i++) { f[i] = true; } f[0] = f[1] = false; // sieve int j; for (i = 2;i &lt; Math.sqrt(s) + 1; i++) { if (f[i]) { // if i is uncrossed , cross its multiples. for (j = 2 * i; j &lt; s ;j += i) { f[j] = false; //multiple is not prime } } } // how many primes are there? int count = 0; for (i = 0;i &lt; s; i++) { if (f[i]) { count ++; //bump count. } } int[] primes = new int[count]; //move the primes into the result for (i = 0,j = 0;i &lt; s;i++) { if (f[i]) { primes[j++] = i; } } return primes; } else { //maxValue &lt; 2 return new int[0]; // return null array if bad input. } } } 如果你非常有耐心地看完了，你可能大概或许会了解到，这是一个返回 maxValue 范围以内的质数的方法，但是我们经过简单的重构之后，会变得更加容易理解： public class PrimeGenerator { private static boolean[] crossedOut; private static int[] result; public static int[] generatePrimes(int maxValue) { if (maxValue &lt; 2) { return new int[0]; } else { uncrossIntegersUpTo(maxValue); crossOutMultiples(); putUncrossedIntegersIntoResult(); return result; } } private static void putUncrossedIntegersIntoResult() { result = new int[numberOfUncrossedIntegers()]; for (int j = 0, i = 2; i &lt; crossedOut.length; i++) { if (notCrossed(i)) { result[j++] = i; } } } private static int numberOfUncrossedIntegers() { int count = 0; for (int i = 2; i &lt; crossedOut.length; i++) { if (notCrossed(i)) { count++; } } return count; } private static void crossOutMultiples() { int limit = determinuIterationLimit(); for (int i = 2;i &lt;= limit; i++) { if (notCrossed(i)) { crossOutMultiplesOf(i); } } } private static void crossOutMultiplesOf(int i) { for (int multiple = 2 * i; multiple &lt; crossedOut.length; multiple +=i) { crossedOut[multiple] = true; } } private static boolean notCrossed(int i) { return crossedOut[i] == false; } private static int determinuIterationLimit() { double iterationLimit = Math.sqrt(crossedOut.length); return (int)iterationLimit; } private static void uncrossIntegersUpTo(int maxValue) { crossedOut = new boolean[maxValue+1]; for (int i = 2; i &lt; crossedOut.length ; i++) { crossedOut[i] = false; } } } 首先我们通过私有方法隐藏掉了实现的具体细节，并且使用有意义的命名，使得我们主函数 generatePrimes 更加便于理解。 函数的第一规则就是要短小，第二条规则就是要更短小。每个函数保持职责单一，并且有意识的维持在一定行数内（JVM 就强制要求每个函数要小于 8000 行…也听过每个函数尽量维持在 15 行 or 30 行 之内这样的说法..可能有点魔怔，但要点就是函数要尽量短小），这当然是最理想的情况，而现实的情况往往要糟糕一些。 在工作中，我就遇到过一些长得可怕的方法，他们或许本来保持着单纯，职责单一，但是经过业务不断的改造，需求不断的叠加，甚至是一些临时逻辑的加入，这个方法就变得越来越臃肿不堪…并且因为业务的不断发展，越来越少的人会 care 到它，以至于改造成本越来越大，甚至被遗忘在角落.. 这其实是再正常不过的事情，但在多人协作的项目中，有一点需要自己来维持清醒，那就是：「一个方法就可以返回的为什么要写两个？」，关于这一点，保持自己的思考就好了.. 注释要体现代码之外的东西有一句听起来好厉害的话叫做：「代码即注释」，不知道大家是怎么看待这样一句话的，或者说是怎么看待注释的。其实反过来想，如果你的代码需要大量的注释来解释其中的逻辑，会不会是代码本身就存在一定问题？或者换个角度思考，注释是用来解释代码逻辑的吗？ 可怕的废话我们来看下面这一段代码的注释： /** The name. */ private String name; /** The version. */ private String version; /** The licenceName. */ private String licenceName; /** The version. */ private String info; 上面这些 Javadoc 的目的是什么？答案是：无。并且仔细阅读，你甚至会发现一处剪切-粘贴导致的错误，如果作者在写（或粘贴）注释时都没有花心思，怎么能指望读者从中收益呢？ 能用函数或变量时就别用注释看看以下代码概要： // does the module from the globale list &lt;mod> depend on the // subsystem we are part of? if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()) 可以修改成以下没有注释的版本： ArrayList moduleDependes = smodule.getDependSubsystems(); String ourSubSystem = subSysMod.getSubSystem(); if (moduleDependes.contains(ourSubSystem)) 用代码来阐述有时，代码本身不足以解释其行为。但不幸的是，许多程序员以此为由，觉得大部分时候代码都不足以解释工作。这种观点纯属错误，比如你愿意看到下面这个： // Check to see if the employee is eligible for full benefits if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age > 65)) 还是这个： if (employee.isEligibleForFullBenefits()) 只需要多思考那么几秒钟，就能用代码解释你的大部分意图。其实很多时候，简单到只需要创建一个描述与注释所言同一事物的函数即可。 小结注释终归是要用来体现代码之外的东西.. 名副其实的名字取名字这件事，真的是程序员的一门艺术。脑海里面能浮现出同事们用翻译软件取名的画面吗？ 一个好的名字再怎么夸赞都不为过，但是这个最基础的前提就是，它首先得是一个「正确的名字」。我就遇到过一次，函数名字叫做类似于 listAll 这样的东西，戳进去看实际上还基于业务规则做了过滤..（这样的牛肉不对马嘴的情况又让我联想到了注释这样的东西，可能实际的代码已经作了更改，但是注释还是是维持原样没有变化..） 并且还有一个特别有意思的点，就是关于名字的「长度」。有时候可能为了想要描述清楚一个变量 or 一个类的具体作用，我会给它起一个看起来特别长的名字..关于这个，这里有一些小经验可以分享一下： 去掉 Info 和 Data 这样的后缀：这些就像是英语中的 a/ an/ the 一样，是意义含糊的废话，废话都是冗余的.. 不要给变量加前缀来标识：变量不需要一个 m_ or 其他什么的前缀来标识这是一个变量.. 思考是否有必要标识出变量的类型：我们标注出变量的类型的目的是什么？对于弱类型的语言，可能有时候还是必要的，因为我们有时候并不能从 students 这个变量中判明我应该怎样对这个变量进行操作，但是对于 Java 这样的强类型的语言，我们就需要根据实际的场景思考是否真有那么必要了。 无副作用函数承诺只做一件事，但还是会做其他被隐藏起来的事。 public class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName); if (user != User.NULL) { String codedPhrase = user.getPhraseEncodedByPassrod(); String phrase = cryptographer.decrypt(codedPhrase, password); if (\"Vliad Passwordw\".equals(phrase)) { Session.initialize(); return true; } } return false; } } 上面的函数副作用就在于对 Session.initialize() 的调用。checkPassword 函数，顾名思义就是用来检查密码的，该名称并未暗示它会初始化该次会话。所以，当某个误信了函数名的调用者想要检查用户有效性时，就得冒着抹除现有会话数据的风险。 所以这里可以重命名函数为 checkPasswordAndInitializeSession，虽然这还是违背了 “只做一件事” 的规则。 函数参数尽可能少一个函数最理想的参数数量是 0，其次是 1，再次是 2.. 要避免使用三个以上参数的情况，因为参数带有太多的概念性，参数过多就会带来更多的复杂性.. 我就见过一个查询接口，为了满足不同的复杂查询场景，参数大概可能有接近 10 个.. 就算不为接手的编码人员考虑，测试人员也会头疼的.. 想想看，要覆盖如此兼容如此多场景如此复杂的一个查询接口，测试用例究竟应该怎么写呢？ More..这本书说实话看下来挺魔怔的.. 里面有许多简洁实用的观点可以让我们受益，我仅仅挑了一些最近比较感同身受的几点，来进行了说明。 代码仓库就像是一本《哈姆雷特》一样，每个人都有自己不同的见解，这无可厚非，我觉得重要的就是要保持对代码的敬畏之心，保持自身的思考，才能让我们不断向前（说话都变魔怔了..） 三、代码之外 每个人都能写出好的代码这就是一个非常有意思的话题了，我们可以分成几个角度来思考： 好的代码是写出来的吗？（这可能有点类似于好的文章是写出来的吗？） 为什么我们写不出好的代码？ 我记得之前在看《重构:改善既有代码的设计》这本老经典的书的时候，就提到一种观点说：「重构不是一个一蹴而就的事，需要长期的实践和经验才能够完成得很好。重构强调的是 Be Better，那在此之前我们首先需要先动起手来搭建我们的系统，而不要一味地“完美主义”。」 好的代码也是这样，需要一个循序渐进的过程，虽然大部分时候，经验可以让我们少走许多弯路，但这些都是一个过程。 当然上面所说的全部，都是理想中的状况，而现实中的情况往往不允许我们这样做。什么之前炒起来的 996，什么 ICU，都无情的揭示着大部分程序员的现状：忙。忙于各种已经堆成山的需求 &amp;&amp; 修复各种 BUG 中。 我学到一个很正经的概念，叫做「管窥」，附带的一种概念叫做「稀缺」。（看完下面这个故事应该很容易理解，故这里不作解释..） 我记得之前看过一篇报道，说是香港某富豪在节目中要体验几天环卫工人，参加节目前，他曾说过：“我的人生其实没有很多时间坐下来，想想现在的生活不错，享受一下。我有时间就会计划下一步！” 可几天下来，让他最纠结的竟然是吃饭问题，他对着镜头说：“很奇怪，我这两天只是考虑吃东西，完全没什么盼望，什么都不想。我努力工作，就是希望吃一顿好的。” 程序员是一种很容易陷入，对于时间「稀缺」状态的物种。稀缺会俘获我们的注意力，并带来一点点好处：我们能够在应对迫切需求时，做得更好。但从长远的角度来看，我们的损失更大：我们会忽视其他需要关注的事项，在生活的其他方面变得不那么有成效。（摘自《稀缺》P17） 这听上去就像是在找借口一样，但其实有点差别。我发觉每个人其实都能够写出好的代码，只是取决于你有没有这样的意识，有没有坚持自己的思考，更重要的是，有没有「跳出需求」，甚至是「跳出工作」之外来思考，就像是要跳出「我们明明知道了很多道理，却依然过不好这一生」的怪圈一样。 结尾 这一段时间都不怎么更新了，不是我变懒了.. 前段时间就陷入了不加班就完成不了工作的状态，一方面是因为事情比较杂.. 另外一方面就是自己效率还不够高.. （悄悄说：虽然很忙，但是总是能抽得出时间玩儿手机 hhhh…）值得反思吧.. 最近也开始有一些觉得越来越难下笔了.. 想写的东西很多，但总怕写不好.. 另外，程序员真的是很有意思的职位了，并且也觉得程序员都多少带着点儿自己的骄傲来得，因为每天都在自己的世界玩儿拼图，自己就是世界的造物主，久了，难免有些受影响..（主要体现在沟通上..） 摁.. 总之这是一本很好的书，建议感兴趣的童鞋可以溜一遍。 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693钱","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java8流操作-基本使用&性能测试","slug":"Java8流操作-基本使用-性能测试","date":"2019-08-03T11:50:00.000Z","updated":"2020-12-09T05:04:49.202Z","comments":true,"path":"2019/08/03/java8-liu-cao-zuo-ji-ben-shi-yong-xing-neng-ce-shi/","link":"","permalink":"http://www.wmyskxz.com/2019/08/03/java8-liu-cao-zuo-ji-ben-shi-yong-xing-neng-ce-shi/","excerpt":"","text":"为获得更好的阅读体验，请访问原文：传送门 一、流(Stream)简介 流是 Java8 中 API 的新成员，它允许你以声明式的方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。这有点儿像是我们操作数据库一样，例如我想要查询出热量较低的菜品名字我就可以像下面这样： SELECT name FROM dishes WHERE calorie &lt; 400; 您看，我们并没有对菜品的什么属性进行筛选（比如像之前使用迭代器一样每个做判断），我们只是表达了我们想要什么。那么为什么到了 Java 的集合中，这样做就不行了呢？ 另外一点，如果我们想要处理大量的数据又该怎么办？是否是考虑使用多线程进行并发处理呢？如果是，那么可能编写的关于并发的代码比使用迭代器本身更加的复杂，而且调试起来也会变得麻烦。 基于以上的几点考虑，Java 设计者在 Java 8 版本中，引入了流的概念，来帮助您节约时间！并且有了 lambda 的参与，流操作的使用将更加顺畅！ 特点一：内部迭代就现在来说，您可以把它简单的当成一种高级的迭代器（Iterator），或者是高级的 for 循环，区别在于，前面两者都是属于外部迭代，而流采用内部迭代。 上图简要说明了内部迭代与外部迭代的差异，我们再举一个生活中实际的例子（引自《Java 8 实战》），比如您想让您两岁的孩子索菲亚把她的玩具都收到盒子里面去，你们之间可能会产生如下的对话： 你：“索菲亚，我们把玩具收起来吧，地上还有玩具吗？” 索菲亚：“有，球。” 你：“好，把球放进盒子里面吧，还有吗？” 索菲亚：“有，那是我的娃娃。” 你：“好，把娃娃也放进去吧，还有吗？” 索菲亚：“有，有我的书。” 你：“好，把书也放进去，还有吗？” 索菲亚：“没有了。” 你：“好，我们收好啦。” 这正是你每天都要对 Java 集合做的事情。你外部迭代了一个集合，显式地取出每个项目再加以处理，但是如果你只是跟索菲亚说：“把地上所有玩具都放进盒子里”，那么索菲亚就可以选择一手拿娃娃一手拿球，或是选择先拿离盒子最近的那个东西，再拿其他的东西。 采用内部迭代，项目可以透明地并行处理，或者用优化的顺序进行处理，要是使用 Java 过去的外部迭代方法，这些优化都是很困难的。 这或许有点鸡蛋里挑骨头，但这差不多就是 Java 8 引入流的原因了——Streams 库的内部迭代可以自动选择一种是和你硬件的数据表示和并行实现。 特点二：只能遍历一次请注意，和迭代器一样，流只能遍历一次。当流遍历完之后，我们就说这个流已经被消费掉了，你可以从原始数据那里重新获得一条新的流，但是却不允许消费已消费掉的流。例如下面代码就会抛出一个异常，说流已被消费掉了： List&lt;String> title = Arrays.asList(\"Wmyskxz\", \"Is\", \"Learning\", \"Java8\", \"In\", \"Action\"); Stream&lt;String> s = title.stream(); s.forEach(System.out::println); s.forEach(System.out::println); // 运行上面程序会报以下错误 /* Exception in thread \"main\" java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279) at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) at Test1.main(Tester.java:17) */ 特点三：方便的并行处理Java 8 中不仅提供了方便的一些流操作（比如过滤、排序之类的），更重要的是对于并行处理有很好的支持，只需要加上 .parallel() 就行了！例如我们使用下面程序来说明一下多线程流操作的方便和快捷，并且与单线程做了一下对比： public class StreamParallelDemo { /** 总数 */ private static int total = 100_000_000; public static void main(String[] args) { System.out.println(String.format(\"本计算机的核数：%d\", Runtime.getRuntime().availableProcessors())); // 产生1000w个随机数(1 ~ 100)，组成列表 Random random = new Random(); List&lt;Integer> list = new ArrayList&lt;>(total); for (int i = 0; i &lt; total; i++) { list.add(random.nextInt(100)); } long prevTime = getCurrentTime(); list.stream().reduce((a, b) -> a + b).ifPresent(System.out::println); System.out.println(String.format(\"单线程计算耗时：%d\", getCurrentTime() - prevTime)); prevTime = getCurrentTime(); // 只需要加上 .parallel() 就行了 list.stream().parallel().reduce((a, b) -> a + b).ifPresent(System.out::println); System.out.println(String.format(\"多线程计算耗时：%d\", getCurrentTime() - prevTime)); } private static long getCurrentTime() { return System.currentTimeMillis(); } } 以上程序分别使用了单线程流和多线程流计算了一千万个随机数的和，输出如下： 本计算机的核数：8655028378单线程计算耗时：4159655028378多线程计算耗时：540 并行流的内部使用了默认的 ForkJoinPool 分支/合并框架，它的默认线程数量就是你的处理器数量，这个值是由 Runtime.getRuntime().availableProcessors() 得到的（当然我们也可以全局设置这个值）。我们也不再去过度的操心加锁线程安全等一系列问题。 二、流基本操作 至少我们从上面了解到了，流操作似乎是一种很强大的工具，能够帮助我们节约我们时间的同时让我们程序可读性更高，下面我们就具体的来了解一下 Java 8 带来的新 API Stream，能给我们带来哪些操作。 1、筛选和切片filterStream 接口支持 filter 方法，该操作会接受一个返回 boolean 的函数作为参数，并返回一个包含所有符合该条件的流。例如，你可以这样选出所有以字母 w 开头的单词并打印： List&lt;String> words = Arrays.asList(\"wmyskxz\", \"say\", \"wow\", \"to\", \"everybody\"); words.stream() .filter(word -> word.startsWith(\"w\")) .forEach(System.out::println); // ==============输出：=============== // wmyskxz // wow 这个过程类似下图： 当然如果您不是想要输出而是想要返回一个集合，那么可以使用 .collect(toList())，就像下面这样： List&lt;String> words = Arrays.asList(\"wmyskxz\", \"say\", \"wow\", \"to\", \"everybody\"); List&lt;String> filteredWords = words.stream() .filter(word -> word.startsWith(\"w\")) .collect(Collectors.toList()); distinct流还支持一个叫做 distinct 的方法，它会返回一个元素各异（根据流所生成的元素的 hashCode 和 equals 方法实现）的流。例如，以下代码会筛选出列表中所有的偶数，并确保没有重复： List&lt;Integer> numbers = Arrays.asList(1, 2, 1, 3, 2, 1, 3, 4); numbers.stream() .filter(integer -> integer % 2 == 0) .distinct() .forEach(System.out::println); // ==============输出：=============== // 2 // 4 limit流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流，所需长度需要作为参数传递给 limit。如果流是有序的，则最多会返回前 n 个元素。比如，你可以建立一个 List，选出前 3 个元素： List&lt;Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); numbers.stream() .filter(integer -> integer % 2 == 0) .limit(3) .forEach(System.out::println); // ==============输出：=============== // 2 // 4 // 6 请注意虽然上述的集合是有序的，但 limit 本身并不会做任何排序的操作。 skip流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。如果流中元素不足 n 个，则返回一个空流。请注意 litmit 和 skip 是互补的！例如，下面这段程序，选出了所有的偶数并跳过了前两个输出： List&lt;Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); numbers.stream() .filter(integer -> integer % 2 == 0) .skip(2) .forEach(System.out::println); // ==============输出：=============== // 6 // 8 2、映射一个非常常见的数据处理套路就是从某些对象中选择信息。比如在 SQL 里，你可以从表中选择一列，Stream API 也通过 map 和 flatMap 方法提供了类似的工具。 map流支持 map 方法，他会接受一个函数作为参数。这个函数会被应用到每个元素身上吗，并将其映射成一个新的函数。例如，下面的代码把方法引用 Words::getContent 传给了 map 方法，来提取流中 Words 的具体内容： public static void main(String[] args) { List&lt;Words> numbers = Arrays.asList(new Words(\"我没有三颗心脏\"), new Words(\"公众号\"), new Words(\"wmyskxz\")); numbers.stream() .map(Words::getContent) .forEach(System.out::println); } @Data @AllArgsConstructor private static class Words { private String content; } // ==============输出：=============== // 我没有三颗心脏 // 公众号 // wmyskxz 但是如果你现在只想要找出每个 Words 具体内容的长度又该怎么办呢？我们可以再进行一次映射： public static void main(String[] args) { List&lt;Words> numbers = Arrays.asList(new Words(\"我没有三颗心脏\"), new Words(\"公众号\"), new Words(\"wmyskxz\")); numbers.stream() .map(Words::getWords) .map(String::length) .forEach(System.out::println); } @Data @AllArgsConstructor private static class Words { private String words; } // ==============输出：=============== // 7 // 3 // 7 flatMap：流的扁平化你已经看到我们是如何使用 map 方法来返回每个 Words 的具体长度了，现在让我们来扩展一下：对于一个 Words 集合，我需要知道这个集合里一共有多少个不相同的字符呢？例如，给定单词列表为：[“Hello”, “World”]，则需要返回的列表是：[“H”, “e”, “l”, “o”, “W”, “r”, “d”]。 您可能会觉得简单，而后写下下列错误的第一版本： List&lt;String> words = Arrays.asList(\"Hello\", \"World\"); words.stream() .map(s -> s.split(\"\")) .distinct() .collect(Collectors.toList()) .forEach(System.out::println); // ==============输出：=============== // [Ljava.lang.String;@238e0d81 // [Ljava.lang.String;@31221be2 为什么会这样呢？这个方法的问题自傲与，传递给 map 方法的 lambda 表达式为每个单词返回了一个 String[]，所以经过 map 方法之后返回的流就不是我们预想的 Stream&lt;String&gt;，而是 Stream&lt;String[]&gt;，下图就说明了这个问题： 幸好我们可以使用 flatMap 来解决这个问题： List&lt;String> words = Arrays.asList(\"Hello\", \"World\"); words.stream() .map(s -> s.split(\"\")) .flatMap(Arrays::stream) .distinct() .collect(Collectors.toList()) .forEach(System.out::println); // ==============输出：=============== // H // e // l // o // W // r // d 使用 flatMap 方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。一言蔽之就是 flatMap 让你一个流中的每个值都转换成另一个六，然后把所有的流连接起来成为一个流，具体过程如下图： 3、查找和匹配另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性，Stream API 通过 allMatch、anyMatch、noneMatch、findFirst 和 findAny 方法提供了这样的工具(其实到这里看名字就会大概能够知道怎么使用了)。 我们简单的举两个例子就好。 比如，你可以用它来看看集合里面是否有偶数： List&lt;Integer> numbers = Arrays.asList(1, 2, 3); if (numbers.stream().anyMatch(i -> i % 2 == 0)) { System.out.println(\"集合里有偶数!\"); } 再比如，你可以用来它来检验是否集合里都为偶数： List&lt;Integer> numbers = Arrays.asList(2, 2, 4); if (numbers.stream().allMatch(i -> i % 2 == 0)) { System.out.println(\"集合里全是偶数!\"); } 再或者，给定一个数字列表，找出第一个平方能被 3 整除的数： List&lt;Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7); Optional&lt;Integer> firstSquareDivisibledByThree = numbers.stream() .map(x -> x * x) .filter(x -> x % 3 == 0) .findFirst(); System.out.println(firstSquareDivisibledByThree.get()); // ==============输出：=============== // 9 Optional 简介：Optional&lt;T&gt; 类是 java.util.Optional 包里的一个容器类，代表一个值存在或者不存在。在上面的代码中，findFirst() 可能什么元素都找不到，Java 8 的设计人员引入了 Optional&lt;T&gt;，这样就不用返回众所周知容易出问题的 null 了。我们在这里不对 Optional 做细致的讨论。 4、归约：reduce到目前为止，你见到过的终端操作(下面我们会说到这些操作其实分为中间操作和终端操作)都是返回一个 boolean（allMatch 之类的）、void（forEach）或 Optional 对象（findFirst 等）。你也见到过了使用 collect 来将流中的所有元素合并成一个 List。 接下来我们来接触更加复杂的一些操作，比如 “挑出单词中长度最长的的单词” 或是 “计算所有单词的总长度”。此类查询需要将流中的元素反复结合起来，得到一个值。这样的查询可以被归类为归约操作（将流归约成一个值）。 数组求和在研究 reduce 之前，我们先来回顾一下我们在之前是如何对一个数字数组进行求和的： List&lt;Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = 0; for (int x : numbers) { sum += x; } System.out.println(sum); // ==============输出：=============== // 15 numbers 中的每个元素都用加法运算符反复迭代来得到结果。通过反复使用加法，我们最终把一个数字列表归约成了一个数字。在这段代码中，我们一共使用了两个参数： sum：总和变量的初始值，在这里是 0； x：用于接受 numbers 中的每一个元素，并与 sum 做加法操作不断迭代； 要是还能把所有的数字相乘，而不用复制粘贴这段代码，岂不是很好？这正是 reduce 操作的用武之地，它对这种重复应用的模式做了抽象。你可以像下面这样对流中所有的元素求和： List&lt;Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream().reduce(0, (a, b) -> a + b); System.out.println(sum); // ==============输出：=============== // 15 其中 reduce 接受了两个参数： 一个初始值，这里是 0； 一个是 BinaryOperator&lt;T&gt; 来将两个元素结合起来产生一个新值，这里我们用的是 lambda (a, b) -&gt; a + b； 你也可以很容易改造成所有元素相乘的形式，只需要将另一个 Lambda：(a, b) -&gt; a * b 传递给 reduce 就可以了： int product = numbers.stream().reduce(0, (a, b) -> a * b); 我们先来深入研究一下 reduce 是如何对一个数字流进行求和的： 如上图所示一样的，reduce 每一次都把结果返回并与下一次的元素进行操作，比如第一次当遍历到元素 1 时，此时返回初始值 0 + 1 = 1，然后再用此时的返回值 1 与第二个元素进行叠加操作，如此往复，便完成了对数字列表的求和运算。 当然你也可以使用方法引用让这段代码更加简洁： int sum = numbers.stream().reduce(0, Integer::sum); 无初始值 reduce 还有一个重载的变体，它不接受初始值，但是会返回一个 Optional 对象(考虑到流中没有任何元素的情况)： Optional&lt;Integer> sum = numbers.stream().reduce(Integer::sum); 最大值和最小值有点类似于上面的操作，我们可以使用下面这样的 reduce 来计算流中的最大值or最小值： // 最大值 Optional&lt;Integer> max = numbers.stream().reduce(Integer::max); // 最小值 Optional&lt;Integer> max = numbers.stream().reduce(Integer::min); 5、中间操作和结束操作（终端操作）Stream API 上的所有操作分为两类：中间操作和结束操作。中间操作只是一种标记，只有结束操作才会触发实际计算。 中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果； 结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。 为了更好的理解流的中间操作和终端操作，可以通过下面的两段代码来看他们的执行过程： IntStream.range(1, 10) .peek(x -> System.out.print(\"\\nA\" + x)) .limit(3) .peek(x -> System.out.print(\"B\" + x)) .forEach(x -> System.out.print(\"C\" + x)); // ==============输出：=============== // A1B1C1 // A2B2C2 // A3B3C3 中间操作是懒惰的，也就是不会对数据做任何操作，直到遇到了结束操作。而结束操作都是比较热情的，他们会回溯之前所有的中间操作。 拿上面的例子来说，当执行到 forEach() 的时候，它会回溯到上一步中间操作，再到上一步中间操作，再上一步..直到第一步，也就是这里的 .peek(x -&gt; System.out.println(&quot;\\nA&quot; + x)，然后开始自上而下的依次执行，输出第一行的 A1B1C1，然而第二次执行 forEach() 操作的时候等同，以此类推.. 我们再来看第二段代码： IntStream.range(1, 10) .peek(x -> System.out.print(\"\\nA\" + x)) .skip(6) .peek(x -> System.out.print(\"B\" + x)) .forEach(x -> System.out.print(\"C\" + x)); // ==============输出：=============== // A1 // A2 // A3 // A4 // A5 // A6 // A7B7C7 // A8B8C8 // A9B9C9 根据上面介绍的规则，同样的当第一次执行 .forEach() 的时候，会回溯到第一个 peek 操作，打印出 A1，然后执行 skip，这个操作的意思就是跳过，也就是相当于 for 循环里面的 continue，所以前六次的 forEach() 操作都只会打印 A。 而第七次开始，skip 失效之后，就会开始分别执行 .peek() 和 forEach() 里面的打印语句了，就会看到输出的是：A7B7C7。 OK，到这里也算是对 Stream API 有了一定的认识，下面我们对中间操作和结束操作做一个总结： 图片截自：https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md 三、Stream 性能测试 引用自：下方参考文档第 4 条。 已经对 Stream API 的用法鼓吹够多了，用起简洁直观，但性能到底怎么样呢？会不会有很高的性能损失？本节我们对 Stream API 的性能一探究竟。 为保证测试结果真实可信，我们将 JVM 运行在 -server 模式下，测试数据在 GB 量级，测试机器采用常见的商用服务器，配置如下： 指标 数值 OS CentOS 6.7 x86_64 CPU Intel Xeon X5675, 12M Cache 3.06 GHz, 6 Cores 12 Threads 内存 96GB JDK java version 1.8.0_91, Java HotSpot(TM) 64-Bit Server VM 测试所用代码在这里，测试结果汇总. 测试方法和测试数据性能测试并不是容易的事，Java性能测试更费劲，因为虚拟机对性能的影响很大，JVM对性能的影响有两方面： GC的影响。GC的行为是Java中很不好控制的一块，为增加确定性，我们手动指定使用CMS收集器，并使用10GB固定大小的堆内存。具体到JVM参数就是-XX:+UseConcMarkSweepGC -Xms10G -Xmx10G JIT(Just-In-Time)即时编译技术。即时编译技术会将热点代码在JVM运行的过程中编译成本地代码，测试时我们会先对程序预热，触发对测试函数的即时编译。相关的JVM参数是-XX:CompileThreshold=10000。 Stream并行执行时用到ForkJoinPool.commonPool()得到的线程池，为控制并行度我们使用Linux的taskset命令指定JVM可用的核数。 测试数据由程序随机生成。为防止一次测试带来的抖动，测试4次求出平均时间作为运行时间。 实验一 基本类型迭代测试内容：找出整型数组中的最小值。对比for循环外部迭代和Stream API内部迭代性能。 测试程序IntTest，测试结果如下图： 图中展示的是for循环外部迭代耗时为基准的时间比值。分析如下： 对于基本类型Stream串行迭代的性能开销明显高于外部迭代开销（两倍）；Stream并行迭代的性能比串行迭代和外部迭代都好。 并行迭代性能跟可利用的核数有关，上图中的并行迭代使用了全部 12 个核，为考察使用核数对性能的影响，我们专门测试了不同核数下的Stream并行迭代效果： 分析，对于基本类型： 使用Stream并行API在单核情况下性能很差，比Stream串行API的性能还差； 随着使用核数的增加，Stream并行效果逐渐变好，比使用for循环外部迭代的性能还好。 以上两个测试说明，对于基本类型的简单迭代，Stream串行迭代性能更差，但多核情况下Stream迭代时性能较好。 实验二 对象迭代再来看对象的迭代效果。 测试内容：找出字符串列表中最小的元素（自然顺序），对比for循环外部迭代和Stream API内部迭代性能。 测试程序StringTest，测试结果如下图： 结果分析如下： 对于对象类型Stream串行迭代的性能开销仍然高于外部迭代开销（1.5倍），但差距没有基本类型那么大。 Stream并行迭代的性能比串行迭代和外部迭代都好。 再来单独考察Stream并行迭代效果： 分析，对于对象类型： 使用Stream并行API在单核情况下性能比for循环外部迭代差； 随着使用核数的增加，Stream并行效果逐渐变好，多核带来的效果明显。 以上两个测试说明，对于对象类型的简单迭代，Stream串行迭代性能更差，但多核情况下Stream迭代时性能较好。 实验三 复杂对象归约从实验一、二的结果来看，Stream串行执行的效果都比外部迭代差（很多），是不是说明Stream真的不行了？先别下结论，我们再来考察一下更复杂的操作。 测试内容：给定订单列表，统计每个用户的总交易额。对比使用外部迭代手动实现和Stream API之间的性能。 我们将订单简化为&lt;userName, price, timeStamp&gt;构成的元组，并用Order对象来表示。测试程序ReductionTest，测试结果如下图： 分析，对于复杂的归约操作： Stream API的性能普遍好于外部手动迭代，并行Stream效果更佳； 再来考察并行度对并行效果的影响，测试结果如下： 分析，对于复杂的归约操作： 使用Stream并行归约在单核情况下性能比串行归约以及手动归约都要差，简单说就是最差的； 随着使用核数的增加，Stream并行效果逐渐变好，多核带来的效果明显。 以上两个实验说明，对于复杂的归约操作，Stream串行归约效果好于手动归约，在多核情况下，并行归约效果更佳。我们有理由相信，对于其他复杂的操作，Stream API也能表现出相似的性能表现。 结论上述三个实验的结果可以总结如下： 对于简单操作，比如最简单的遍历，Stream串行API性能明显差于显示迭代，但并行的Stream API能够发挥多核特性。 对于复杂操作，Stream串行API性能可以和手动实现的效果匹敌，在并行执行时Stream API效果远超手动实现。 所以，如果出于性能考虑，1. 对于简单操作推荐使用外部迭代手动实现，2. 对于复杂操作，推荐使用Stream API， 3. 在多核情况下，推荐使用并行Stream API来发挥多核优势，4.单核情况下不建议使用并行Stream API。 如果出于代码简洁性考虑，使用Stream API能够写出更短的代码。即使是从性能方面说，尽可能的使用Stream API也另外一个优势，那就是只要Java Stream类库做了升级优化，代码不用做任何修改就能享受到升级带来的好处。 参考文档 https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/19 - Java 8 Stream并行计算原理 http://hack.xingren.com/index.php/2018/10/17/java-stream/ - 原来你是这样的 Stream —— 浅析 Java Stream 实现原理 https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md - Stream Pipelines https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/8-Stream%20Performance.md - Stream Performance 《Java 8 实战》 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java计时新姿势√","slug":"Java计时新姿势√","date":"2019-07-30T15:20:00.000Z","updated":"2020-12-09T05:05:33.307Z","comments":true,"path":"2019/07/30/java-ji-shi-xin-zi-shi/","link":"","permalink":"http://www.wmyskxz.com/2019/07/30/java-ji-shi-xin-zi-shi/","excerpt":"为获得更好的阅读体验，请访问原文：传送门前言： 最近公司来了个大佬，从他那里学到不少东西，其中一个就是计时的新姿势「StopWatch」，赶紧来一起了解了解吧!","text":"为获得更好的阅读体验，请访问原文：传送门前言： 最近公司来了个大佬，从他那里学到不少东西，其中一个就是计时的新姿势「StopWatch」，赶紧来一起了解了解吧! 一、最简单的计时 在我们的程序中不免需要对某一个运算或者方法进行计时，以便我们来观察该运算或方法是否符合我们的预期，所以在我们刚开始接触 Java 的时候都能写出类似下面这样的代码来计时： public static void main(String[] args) { Long startTime = System.currentTimeMillis(); doSomeThing(); Long endTime = System.currentTimeMillis(); Long elapsedTime = (endTime - startTime) / 1000; System.out.println(\"总共耗时：\" + elapsedTime + \"s\"); } // 用于模拟一些操作 private static void doSomeThing() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } 事实上这样也并没有什么问题，并且也能够运行的很好，但是有一点不太好的就是，自己关注了太多输出的信息，下面我们来认识一种更优雅的一种计时方式； 二、StopWatch 类 想要使用它，首先你需要在你的 Maven 中引入 Spring 核心包，当然 Spring MVC 和 Spring Boot 都已经自动引入了该包： &lt;!-- spring核心包 --> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-core&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> 现在我们计时的姿势或许就会变成以下这样： public static void main(String[] args) { StopWatch clock = new StopWatch(); clock.start(\"开始任务一\"); doSomeThing(); clock.stop(); clock.start(\"开始任务二\"); doSomeThing(); clock.stop(); System.out.println(clock.prettyPrint()); } // 用于模拟一些操作 private static void doSomeThing() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } 在最后我们使用 StopWatch 类自带的 prettyPrint() 方法类格式化我们的输出，运行程序你会发现你的程序输出了这样的东西： StopWatch '': running time (millis) = 2009 ----------------------------------------- ms % Task name ----------------------------------------- 01005 050% 开始任务一 01004 050% 开始任务二 不仅有总用时，还有每个任务分别的占用时间和占用时间的百分比，这或许就会比我们自己输出要优雅那么一些； StopWatch 类是怎么实现的呢？ 当你戳开 StopWatch 的源码，你会在总共不到 200 行的代码里看到熟悉的东西： public void start(String taskName) throws IllegalStateException { if (this.currentTaskName != null) { throw new IllegalStateException(\"Can't start StopWatch: it's already running\"); } else { this.currentTaskName = taskName; this.startTimeMillis = System.currentTimeMillis(); } } public void stop() throws IllegalStateException { if (this.currentTaskName == null) { throw new IllegalStateException(\"Can't stop StopWatch: it's not running\"); } else { long lastTime = System.currentTimeMillis() - this.startTimeMillis; this.totalTimeMillis += lastTime; this.lastTaskInfo = new StopWatch.TaskInfo(this.currentTaskName, lastTime); if (this.keepTaskList) { this.taskList.add(this.lastTaskInfo); } ++this.taskCount; this.currentTaskName = null; } } 你会发现该类使用 LinkedList 实现了一个叫做 taskList 的队列，然后每一次开始同样也是使用 System.currentTimeMillis() 方法来获取时间，每次除了计算耗时也会构建一个描述当前任务的 TaskInfo 对象，并把它放入 taskList 队列中。 当执行 prettyPrint() 方法的时候，就从 taskList 队列中依次取出任务，然后做些格式化的操作： public String shortSummary() { return \"StopWatch '\" + this.getId() + \"': running time (millis) = \" + this.getTotalTimeMillis(); } public String prettyPrint() { StringBuilder sb = new StringBuilder(this.shortSummary()); sb.append('\\n'); if (!this.keepTaskList) { sb.append(\"No task info kept\"); } else { sb.append(\"-----------------------------------------\\n\"); sb.append(\"ms % Task name\\n\"); sb.append(\"-----------------------------------------\\n\"); NumberFormat nf = NumberFormat.getNumberInstance(); nf.setMinimumIntegerDigits(5); nf.setGroupingUsed(false); NumberFormat pf = NumberFormat.getPercentInstance(); pf.setMinimumIntegerDigits(3); pf.setGroupingUsed(false); StopWatch.TaskInfo[] var4 = this.getTaskInfo(); int var5 = var4.length; for(int var6 = 0; var6 &lt; var5; ++var6) { StopWatch.TaskInfo task = var4[var6]; sb.append(nf.format(task.getTimeMillis())).append(\" \"); sb.append(pf.format(task.getTimeSeconds() / this.getTotalTimeSeconds())).append(\" \"); sb.append(task.getTaskName()).append(\"\\n\"); } } return sb.toString(); } 摁，新姿势 get √。 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"善良比聪明重要","slug":"善良比聪明重要","date":"2019-07-22T14:17:00.000Z","updated":"2020-12-09T04:57:32.154Z","comments":true,"path":"2019/07/22/shan-liang-bi-cong-ming-chong-yao/","link":"","permalink":"http://www.wmyskxz.com/2019/07/22/shan-liang-bi-cong-ming-chong-yao/","excerpt":"转载自：https://github.com/lifesinger/blog/issues/227","text":"转载自：https://github.com/lifesinger/blog/issues/227 2010 年，亚马逊 CEO 杰夫·贝佐斯（Jeff Bezos）在母校普林斯顿大学的毕业典礼上，勉励年轻人，善用自己的天赋，做出对的选择。因为，「人生到头来，我们的选择，决定了我们是什么样的人。」 以下是 Bezos 演讲内容： As a kid, I spent my summers with my grandparents on their ranch in Texas. I helped fix windmills, vaccinate cattle, and do other chores. We also watched soap operas every afternoon, especially “Days of our Lives.” My grandparents belonged to a Caravan Club, a group of Airstream trailer owners who travel together around the U.S. and Canada. And every few summers, we’d join the caravan. We’d hitch up the Airstream trailer to my grandfather’s car, and off we’d go, in a line with 300 other Airstream adventurers. I loved and worshipped my grandparents and I really looked forward to these trips. On one particular trip, I was about 10 years old. I was rolling around in the big bench seat in the back of the car. My grandfather was driving. And my grandmother had the passenger seat. She smoked throughout these trips, and I hated the smell. 孩提时代，我总是在德州祖父母的农场中度过夏天。我帮忙修理风车，为牛接种疫苗，也做其他杂活。每天下午，我们也看肥皂剧，特别是《光辉岁月》。祖父母参加了一个房车俱乐部，一群人驾驶 Airstream 房车，结伴游历美国和加拿大。每隔几个夏天，我们会加入一次旅程。把房车挂在祖父的小汽车后面，融入 300 余名 Airstream 探险者的浩荡队伍中，就这样出发。我爱祖父母，心怀敬仰，很期盼这些旅程。在我大约 10 岁时，有一次很特殊的旅程。那次我胡乱坐在后座上，祖父开着车，祖母坐在他旁边。整个旅程祖母都吸着烟，我讨厌烟味。 At that age, I’d take any excuse to make estimates and do minor arithmetic. I’d calculate our gas mileage – figure out useless statistics on things like grocery spending. I’d been hearing an ad campaign about smoking. I can’t remember the details, but basically the ad said, every puff of a cigarette takes some number of minutes off of your life: I think it might have been two minutes per puff. At any rate, I decided to do the math for my grandmother. I estimated the number of cigarettes per days, estimated the number of puffs per cigarette and so on. When I was satisfied that I’d come up with a reasonable number, I poked my head into the front of the car, tapped my grandmother on the shoulder, and proudly proclaimed, “At two minutes per puff, you’ve taken nine years off your life!” I have a vivid memory of what happened, and it was not what I expected. I expected to be applauded for my cleverness and arithmetic skills. “Jeff, you’re so smart. You had to have made some tricky estimates, figure out the number of minutes in a year and do some division.” That’s not what happened. Instead, my grandmother burst into tears. I sat in the backseat and did not know what to do. While my grandmother sat crying, my grandfather, who had been driving in silence, pulled over onto the shoulder of the highway. He got out of the car and came around and opened my door and waited for me to follow. Was I in trouble? My grandfather was a highly intelligent, quiet man. He had never said a harsh word to me, and maybe this was to be the first time? Or maybe he would ask that I get back in the car and apologize to my grandmother. I had no experience in this realm with my grandparents and no way to gauge what the consequences might be. We stopped beside the trailer. My grandfather looked at me, and after a bit of silence, he gently and calmly said, “Jeff, one day you’ll understand that it’s harder to be kind than clever.” 当年，我总是想尽办法去做估测或小算术。我会计算油耗还有杂货花销等鸡毛蒜皮的小事。我听过一个与吸烟相关的广告，但记不清细节了。广告大意是，每吸一口香烟会减少几分钟寿命，好像是两分钟。管它几分钟呢，我决定为祖母做个算术。我估测了祖母每天吸几支香烟，每支香烟吸几口等等，然后心满意足地得出了一个合理的数字。接着，我把头探入汽车前排，拍了拍祖母的肩膀，骄傲地宣称：「如果每吸一口烟少活两分钟的话，你的寿命已经少了九年！」我清晰地记得接下来发生的事，是我意料之外的。凭借聪明的大脑和算术技巧，我期待赢来夸赞：「杰夫，你真聪明。你应该做一些更需要技巧的算术，比如一年有多少分钟，以及做些除法。」我的期待并没有发生。相反，祖母突然哭泣起来，我坐在后座茫然无措。祖父一直在默默开车，听到祖母的哭声，把车停在高速路边。祖父走下车来，打开车门，等我跟他下车。我惹麻烦了吗？祖父是一个智慧而安静的人。他从来没有对我说过严厉的话，难道这会是第一次？还是他会让我回到车上给祖母道歉？我以前从未遇到过这种状况，无从知晓会有什么后果发生。我们在房车旁停下来，祖父注视着我，沉默片刻，然后轻轻地、平静地说： 「杰夫，有一天你会明白，善良比聪明更难。」 What I want to talk to you about today is the difference between gifts and choices. Cleverness is a gift, kindness is a choice. Gifts are easy – they’re given after all. Choices can be hard. You can seduce yourself with your gifts if you’re not careful, and if you do, it’ll probably be to the detriment of your choices. This is a group with many gifts. I’m sure one of your gifts is the gift of a smart and capable brain. I’m confident that’s the case because admission is competitive and if there weren’t some signs that you’re clever, the dean of admission wouldn’t have let you in. 今天我想对你们说的是，天赋和选择的不同。 聪明是一种天赋，而善良是一种选择。 天赋得来容易 —— 毕竟与生俱来。而选择颇为不易。一不小心，你可能会被天赋所诱惑，而这可能会损害到你的选择。 在座各位都拥有众多天赋。我确信你们的天赋之一就是拥有精明能干的头脑。之所以如此确信，是因为入学竞争如此激烈，如果你们不聪明，便不会有资格进入这所学校。 Your smarts will come in handy because you will travel in a land of marvels. We humans — plodding as we are – will astonish ourselves. We’ll invent ways to generate clean energy and a lot of it. Atom by atom, we’ll assemble tiny machines that will enter cell walls and make repairs. This month comes the extraordinary but also inevitable news that we’ve synthesized life. In the coming years, we’ll not only synthesize it, but we’ll engineer it to specifications. I believe you’ll even see us understand the human brain. Jules Verne, Mark Twain, Galileo, Newton – all the curious from the ages would have wanted to be alive most of all right now. As a civilization, we will have so many gifts, just as you as individuals have so many individual gifts as you sit before me. How will you use these gifts? And will you take pride in your gifts or pride in your choices? 你们将在一片充满奇迹的世界上前行，聪明才智必能派上用场。我们人类，尽管跬步前行，却终将令自己大吃一惊。我们能够想方设法制造清洁能源等等，也能够一个原子一个原子地组装微型机械，使之穿过细胞壁，去修复细胞。这个月，有一个非常激动人心却又不足为奇的消息 —— 人类终于合成了生命。在未来几年，我们不仅会合成生命，还能将之工程规范化。我相信你们甚至会看到人类大脑被彻底理解。儒勒·凡尔纳、马克·吐温、伽利略、牛顿 —— 所有那些充满好奇之心的人都希望能够活在现在。作为文明人，我们拥有如此多的天赋，就像是坐在我面前的你们，每一个生命个体都拥有众多独特的天赋。如何运用这些天赋？为自己的天赋感到骄傲，还是会为自己的选择感到骄傲？ I got the idea to start Amazon 16 years ago. I came across the fact that Web usage was growing at 2,300 percent per year. I’d never seen or heard of anything that grew that fast, and the idea of building an online bookstore with millions of titles – something that simply couldn’t exist in the physical world – was very exciting to me. I had just turned 30 years old, and I’d been married for a year. I told my wife MacKenzie that I wanted to quit my job and go do this crazy thing that probably wouldn’t work since most startups don’t, and I wasn’t sure what would happen after that. MacKenzie (also a Princeton grad and sitting here in the second row) told me I should go for it. As a young boy, I’d been a garage inventor. I’d invented an automatic gate closer out of cement-filled tires, a solar cooker that didn’t work very well out of an umbrella and tinfoil, baking-pan alarms to entrap my siblings. I’d always wanted to be an inventor, and she wanted me to follow my passion. 16 年前，我萌生了创办亚马逊的想法。当年，互联网使用量以每年 2300% 的速度增长，我从未看到或听说过任何东西增长如此快速。有个想法令我异常兴奋 —— 创建涵盖几百万种书籍的网上书店，这东西在物理世界根本无法存在。那时我刚满 30 岁，结婚才一年。我告诉妻子 MacKenzie 想辞去工作，然后去做这件疯狂的事，很可能会失败，因为大部分创业公司都如此，而且我不确定之后会发生什么。MacKenzie （也是普林斯顿毕业生，就坐在下面第二排）告诉我，我应该放手一搏。少年时期，我是一名车库发明家。我曾用水泥填充的轮胎制作自动关门器，用雨伞和锡箔制作太阳能炒锅（虽然不太好用），我还用煎锅做了一个警报器来吓唬邻居。我一直想做一个发明家，MacKenzie 支持我追随内心的热情。 I was working at a financial firm in New York City with a bunch of very smart people, and I had a brilliant boss that I much admired. I went to my boss and told him I wanted to start a company selling books on the Internet. He took me on a long walk in Central Park, listened carefully to me, and finally said, “That sounds like a really good idea, but it would be an even better idea for someone who didn’t already have a good job.” That logic made some sense to me, and he convinced me to think about it for 48 hours before making a final decision. Seen in that light, it really was a difficult choice, but ultimately, I decided I had to give it a shot. I didn’t think I’d regret trying and failing. And I suspected I would always be haunted by a decision to not try at all. After much consideration, I took the less safe path to follow my passion, and I’m proud of that choice. 我当时在纽约一家金融公司工作，同事是一群非常聪明的人，老板也很有智慧，我很敬佩他。我告诉老板我想开办一家公司，在网上卖书。老板带我在中央公园漫步良久，认真听我讲完，最后说：「听起来真是一个很好的主意。然而，对那些目前没有谋到一份好工作的人来说，这个主意会更好。」这一逻辑对我而言颇有道理，老板说服我做出最终决定之前再考虑 48 小时。那样想来，这个决定确实很艰难，但是最终，我决定拼一次。 我认为自己不会为尝试过后的失败而遗憾，倒是有所决定但完全不付诸行动会一直煎熬着我。 深思熟虑后，我选择了那条不安全的道路，去追随内心的热情。我为自己的决定感到骄傲。 Tomorrow, in a very real sense, your life – the life you author from scratch on your own – begins.How will you use your gifts? What choices will you make?Will inertia be your guide, or will you follow your passions?Will you follow dogma, or will you be original?Will you choose a life of ease, or a life of service and adventure?Will you wilt under criticism, or will you follow your convictions?Will you bluff it out when you’re wrong, or will you apologize?Will you guard your heart against rejection, or will you act when you fall in love?Will you play it safe, or will you be a little bit swashbuckling? When it’s tough, will you give up, or will you be relentless?Will you be a cynic, or will you be a builder?Will you be clever at the expense of others, or will you be kind? 明天，非常现实地说，从零塑造自己人生的时代，即将开启。你会如何运用自己的天赋？又会做出怎样的抉择？你会随波逐流，还是追随内心的热情？你会顺从于教条，还是保持初心？你会选择安逸的生活，还是奉献与冒险的人生？你会屈于批评，还是会坚守信念？你会掩饰错误，还是会坦诚道歉？你会因害怕拒绝而掩饰真心，还是会在深爱中勇往直前？你想要波澜不惊，还是想搏击风浪？你会在严峻的现实之下选择放弃，还是会义无反顾前行？你要做愤世嫉俗者，还是踏实建设者？你要不计一切地展示聪明，还是选择善良？ I will hazard a prediction. When you are 80 years old, and in a quiet moment of reflection narrating for only yourself the most personal version of your life story, the telling that will be most compact and meaningful will be the series of choices you have made. In the end, we are our choices. Build yourself a great story. Thank you and good luck! 我要做一个预测：在大家 80 岁追忆往昔的时刻，一个人静静对内心诉说人生故事时，其中最为充实、最有意义的那段故事，会是大家做出的一系列选择。最后， 是选择塑造了我们，为自己塑造一个伟大的故事吧。 谢谢，祝福好运！ （完） 说明：初始译文来自网络，未找到原作者。细节有瑕疵，还有小部分漏译，我做了大量修正。 Bezos 演讲视频：点此播放","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"喜欢的三观","slug":"想要跟你们分享/喜欢的三观","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Kafka【入门】就这一篇！","slug":"Kafka【入门】就这一篇！","date":"2019-07-17T13:05:00.000Z","updated":"2020-12-09T05:14:59.163Z","comments":true,"path":"2019/07/17/kafka-ru-men-jiu-zhe-yi-pian/","link":"","permalink":"http://www.wmyskxz.com/2019/07/17/kafka-ru-men-jiu-zhe-yi-pian/","excerpt":"前言：在之前的文章里面已经了解到了「消息队列」是怎么样的一种存在（传送门），Kafka 作为当下流行的一种中间件，我们现在开始学习它！","text":"前言：在之前的文章里面已经了解到了「消息队列」是怎么样的一种存在（传送门），Kafka 作为当下流行的一种中间件，我们现在开始学习它！ 一、Kafka 简介 Kafka 创建背景Kafka 是一个消息系统，原本开发自 LinkedIn，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。现在它已被多家不同类型的公司 作为多种类型的数据管道和消息系统使用。 活动流数据是几乎所有站点在对其网站使用情况做报表时都要用到的数据中最常规的部分。活动数据包括页面访问量（Page View）、被查看内容方面的信息以及搜索情况等内容。这种数据通常的处理方式是先把各种活动以日志的形式写入某种文件，然后周期性地对这些文件进行统计分析。运营数据指的是服务器的性能数据（CPU、IO 使用率、请求时间、服务日志等等数据)。运营数据的统计方法种类繁多。 近年来，活动和运营数据处理已经成为了网站软件产品特性中一个至关重要的组成部分，这就需要一套稍微更加复杂的基础设施对其提供支持。 Kafka 简介Kafka 是一种分布式的，基于发布 / 订阅的消息系统。主要设计目标如下： 以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。 支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out：支持在线水平扩展。 Kafka 基础概念概念一：生产者与消费者 对于 Kafka 来说客户端有两种基本类型：生产者（Producer）和消费者（Consumer）。除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。 这很容易理解，生产者（也称为发布者）创建消息，而消费者（也称为订阅者）负责消费or读取消息。 概念二：主题（Topic）与分区（Partition） 在 Kafka 中，消息以主题（Topic）来分类，每一个主题都对应一个「消息队列」，这有点儿类似于数据库中的表。但是如果我们把所有同类的消息都塞入到一个“中心”队列中，势必缺少可伸缩性，无论是生产者/消费者数目的增加，还是消息数量的增加，都可能耗尽系统的性能或存储。 我们使用一个生活中的例子来说明：现在 A 城市生产的某商品需要运输到 B 城市，走的是公路，那么单通道的高速公路不论是在「A 城市商品增多」还是「现在 C 城市也要往 B 城市运输东西」这样的情况下都会出现「吞吐量不足」的问题。所以我们现在引入分区（Partition）的概念，类似“允许多修几条道”的方式对我们的主题完成了水平扩展。 概念三：Broker 和集群（Cluster）一个 Kafka 服务器也称为 Broker，它接受生产者发送的消息并存入磁盘；Broker 同时服务消费者拉取分区消息的请求，返回目前已经提交的消息。使用特定的机器硬件，一个 Broker 每秒可以处理成千上万的分区和百万量级的消息。（现在动不动就百万量级..我特地去查了一把，好像确实集群的情况下吞吐量挺高的..摁..） 若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。下图是一个样例： Kafka 的一个关键性质是日志保留（retention），我们可以配置主题的消息保留策略，譬如只保留一段时间的日志或者只保留特定大小的日志。当超过这些限制时，老的消息会被删除。我们也可以针对某个主题单独设置消息过期策略，这样对于不同应用可以实现个性化。 概念四：多集群随着业务发展，我们往往需要多集群，通常处于下面几个原因： 基于数据的隔离； 基于安全的隔离； 多数据中心（容灾） 当构建多个数据中心时，往往需要实现消息互通。举个例子，假如用户修改了个人资料，那么后续的请求无论被哪个数据中心处理，这个更新需要反映出来。又或者，多个数据中心的数据需要汇总到一个总控中心来做数据分析。 上面说的分区复制冗余机制只适用于同一个 Kafka 集群内部，对于多个 Kafka 集群消息同步可以使用 Kafka 提供的 MirrorMaker 工具。本质上来说，MirrorMaker 只是一个 Kafka 消费者和生产者，并使用一个队列连接起来而已。它从一个集群中消费消息，然后往另一个集群生产消息。 二、Kafka 的设计与实现 上面我们知道了 Kafka 中的一些基本概念，但作为一个成熟的「消息队列」中间件，其中有许多有意思的设计值得我们思考，下面我们简单列举一些。 讨论一：Kafka 存储在文件系统上是的，您首先应该知道 Kafka 的消息是存在于文件系统之上的。Kafka 高度依赖文件系统来存储和缓存消息，一般的人认为 “磁盘是缓慢的”，所以对这样的设计持有怀疑态度。实际上，磁盘比人们预想的快很多也慢很多，这取决于它们如何被使用；一个好的磁盘结构设计可以使之跟网络速度一样快。 现代的操作系统针对磁盘的读写已经做了一些优化方案来加快磁盘的访问速度。比如，预读会提前将一个比较大的磁盘快读入内存。后写会将很多小的逻辑写操作合并起来组合成一个大的物理写操作。并且，操作系统还会将主内存剩余的所有空闲内存空间都用作磁盘缓存，所有的磁盘读写操作都会经过统一的磁盘缓存（除了直接 I/O 会绕过磁盘缓存）。综合这几点优化特点，如果是针对磁盘的顺序访问，某些情况下它可能比随机的内存访问都要快，甚至可以和网络的速度相差无几。 上述的 Topic 其实是逻辑上的概念，面相消费者和生产者，物理上存储的其实是 Partition，每一个 Partition 最终对应一个目录，里面存储所有的消息和索引文件。默认情况下，每一个 Topic 在创建时如果不指定 Partition 数量时只会创建 1 个 Partition。比如，我创建了一个 Topic 名字为 test ，没有指定 Partition 的数量，那么会默认创建一个 test-0 的文件夹，这里的命名规则是：&lt;topic_name&gt;-&lt;partition_id&gt;。 任何发布到 Partition 的消息都会被追加到 Partition 数据文件的尾部，这样的顺序写磁盘操作让 Kafka 的效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是 Kafka 高吞吐率的一个很重要的保证）。 每一条消息被发送到 Broker 中，会根据 Partition 规则选择被存储到哪一个 Partition。如果 Partition 规则设置的合理，所有消息可以均匀分布到不同的 Partition中。 讨论二：Kafka 中的底层存储设计假设我们现在 Kafka 集群只有一个 Broker，我们创建 2 个 Topic 名称分别为：「topic1」和「topic2」，Partition 数量分别为 1、2，那么我们的根目录下就会创建如下三个文件夹： | --topic1-0 | --topic2-0 | --topic2-1 在 Kafka 的文件存储中，同一个 Topic 下有多个不同的 Partition，每个 Partition 都为一个目录，而每一个目录又被平均分配成多个大小相等的 Segment File 中，Segment File 又由 index file 和 data file 组成，他们总是成对出现，后缀 “.index” 和 “.log” 分表表示 Segment 索引文件和数据文件。 现在假设我们设置每个 Segment 大小为 500 MB，并启动生产者向 topic1 中写入大量数据，topic1-0 文件夹中就会产生类似如下的一些文件： | --topic1-0 | --00000000000000000000.index | --00000000000000000000.log | --00000000000000368769.index | --00000000000000368769.log | --00000000000000737337.index | --00000000000000737337.log | --00000000000001105814.index | --00000000000001105814.log | --topic2-0 | --topic2-1 Segment 是 Kafka 文件存储的最小单位。Segment 文件命名规则：Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用0填充。如 00000000000000368769.index 和 00000000000000368769.log。 以上面的一对 Segment File 为例，说明一下索引文件和数据文件对应关系： 其中以索引文件中元数据 &lt;3, 497&gt; 为例，依次在数据文件中表示第 3 个 message（在全局 Partition 表示第 368769 + 3 = 368772 个 message）以及该消息的物理偏移地址为 497。 注意该 index 文件并不是从0开始，也不是每次递增1的，这是因为 Kafka 采取稀疏索引存储的方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，使得能够把 index 映射到内存，降低了查询时的磁盘 IO 开销，同时也并没有给查询带来太多的时间消耗。 因为其文件名为上一个 Segment 最后一条消息的 offset ，所以当需要查找一个指定 offset 的 message 时，通过在所有 segment 的文件名中进行二分查找就能找到它归属的 segment ，再在其 index 文件中找到其对应到文件上的物理位置，就能拿出该 message 。 由于消息在 Partition 的 Segment 数据文件中是顺序读写的，且消息消费后不会删除（删除策略是针对过期的 Segment 文件），这种顺序磁盘 IO 存储设计师 Kafka 高性能很重要的原因。 Kafka 是如何准确的知道 message 的偏移的呢？这是因为在 Kafka 定义了标准的数据存储结构，在 Partition 中的每一条 message 都包含了以下三个属性： offset：表示 message 在当前 Partition 中的偏移量，是一个逻辑上的值，唯一确定了 Partition 中的一条 message，可以简单的认为是一个 id； MessageSize：表示 message 内容 data 的大小； data：message 的具体内容 讨论三：生产者设计概要当我们发送消息之前，先问几个问题：每条消息都是很关键且不能容忍丢失么？偶尔重复消息可以么？我们关注的是消息延迟还是写入消息的吞吐量？ 举个例子，有一个信用卡交易处理系统，当交易发生时会发送一条消息到 Kafka，另一个服务来读取消息并根据规则引擎来检查交易是否通过，将结果通过 Kafka 返回。对于这样的业务，消息既不能丢失也不能重复，由于交易量大因此吞吐量需要尽可能大，延迟可以稍微高一点。 再举个例子，假如我们需要收集用户在网页上的点击数据，对于这样的场景，少量消息丢失或者重复是可以容忍的，延迟多大都不重要只要不影响用户体验，吞吐则根据实时用户数来决定。 不同的业务需要使用不同的写入方式和配置。具体的方式我们在这里不做讨论，现在先看下生产者写消息的基本流程： 图片来源：http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/12/kafka-producer.html 流程如下： 首先，我们需要创建一个ProducerRecord，这个对象需要包含消息的主题（topic）和值（value），可以选择性指定一个键值（key）或者分区（partition）。 发送消息时，生产者会对键值和值序列化成字节数组，然后发送到分配器（partitioner）。 如果我们指定了分区，那么分配器返回该分区即可；否则，分配器将会基于键值来选择一个分区并返回。 选择完分区后，生产者知道了消息所属的主题和分区，它将这条记录添加到相同主题和分区的批量消息中，另一个线程负责发送这些批量消息到对应的Kafka broker。 当broker接收到消息后，如果成功写入则返回一个包含消息的主题、分区及位移的RecordMetadata对象，否则返回异常。 生产者接收到结果后，对于异常可能会进行重试。 讨论四：消费者设计概要消费者与消费组假设这么个场景：我们从Kafka中读取消息，并且进行检查，最后产生结果数据。我们可以创建一个消费者实例去做这件事情，但如果生产者写入消息的速度比消费者读取的速度快怎么办呢？这样随着时间增长，消息堆积越来越严重。对于这种场景，我们需要增加多个消费者来进行水平扩展。 Kafka消费者是消费组的一部分，当多个消费者形成一个消费组来消费主题时，每个消费者会收到不同分区的消息。假设有一个T1主题，该主题有4个分区；同时我们有一个消费组G1，这个消费组只有一个消费者C1。那么消费者C1将会收到这4个分区的消息，如下所示： 如果我们增加新的消费者C2到消费组G1，那么每个消费者将会分别收到两个分区的消息，如下所示： 如果增加到4个消费者，那么每个消费者将会分别收到一个分区的消息，如下所示： 但如果我们继续增加消费者到这个消费组，剩余的消费者将会空闲，不会收到任何消息： 总而言之，我们可以通过增加消费组的消费者来进行水平扩展提升消费能力。这也是为什么建议创建主题时使用比较多的分区数，这样可以在消费负载高的情况下增加消费者来提升性能。另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助。 Kafka一个很重要的特性就是，只需写入一次消息，可以支持任意多的应用读取这个消息。换句话说，每个应用都可以读到全量的消息。为了使得每个应用都能读到全量消息，应用需要有不同的消费组。对于上面的例子，假如我们新增了一个新的消费组G2，而这个消费组有两个消费者，那么会是这样的： 在这个场景中，消费组G1和消费组G2都能收到T1主题的全量消息，在逻辑意义上来说它们属于不同的应用。 最后，总结起来就是：如果应用需要读取全量消息，那么请为该应用设置一个消费组；如果该应用消费能力不足，那么可以考虑在这个消费组里增加消费者。 消费组与分区重平衡可以看到，当新的消费者加入消费组，它会消费一个或多个分区，而这些分区之前是由其他消费者负责的；另外，当消费者离开消费组（比如重启、宕机等）时，它所消费的分区会分配给其他分区。这种现象称为重平衡（rebalance）。重平衡是 Kafka 一个很重要的性质，这个性质保证了高可用和水平扩展。不过也需要注意到，在重平衡期间，所有消费者都不能消费消息，因此会造成整个消费组短暂的不可用。而且，将分区进行重平衡也会导致原来的消费者状态过期，从而导致消费者需要重新更新状态，这段期间也会降低消费性能。后面我们会讨论如何安全的进行重平衡以及如何尽可能避免。 消费者通过定期发送心跳（hearbeat）到一个作为组协调者（group coordinator）的 broker 来保持在消费组内存活。这个 broker 不是固定的，每个消费组都可能不同。当消费者拉取消息或者提交时，便会发送心跳。 如果消费者超过一定时间没有发送心跳，那么它的会话（session）就会过期，组协调者会认为该消费者已经宕机，然后触发重平衡。可以看到，从消费者宕机到会话过期是有一定时间的，这段时间内该消费者的分区都不能进行消息消费；通常情况下，我们可以进行优雅关闭，这样消费者会发送离开的消息到组协调者，这样组协调者可以立即进行重平衡而不需要等待会话过期。 在 0.10.1 版本，Kafka 对心跳机制进行了修改，将发送心跳与拉取消息进行分离，这样使得发送心跳的频率不受拉取的频率影响。另外更高版本的 Kafka 支持配置一个消费者多长时间不拉取消息但仍然保持存活，这个配置可以避免活锁（livelock）。活锁，是指应用没有故障但是由于某些原因不能进一步消费。 Partition 与消费模型上面提到，Kafka 中一个 topic 中的消息是被打散分配在多个 Partition(分区) 中存储的， Consumer Group 在消费时需要从不同的 Partition 获取消息，那最终如何重建出 Topic 中消息的顺序呢？ 答案是：没有办法。Kafka 只会保证在 Partition 内消息是有序的，而不管全局的情况。 下一个问题是：Partition 中的消息可以被（不同的 Consumer Group）多次消费，那 Partition中被消费的消息是何时删除的？ Partition 又是如何知道一个 Consumer Group 当前消费的位置呢？ 无论消息是否被消费，除非消息到期 Partition 从不删除消息。例如设置保留时间为 2 天，则消息发布 2 天内任何 Group 都可以消费，2 天后，消息自动被删除。Partition 会为每个 Consumer Group 保存一个偏移量，记录 Group 消费到的位置。 如下图： 为什么 Kafka 是 pull 模型消费者应该向 Broker 要数据（pull）还是 Broker 向消费者推送数据（push）？作为一个消息系统，Kafka 遵循了传统的方式，选择由 Producer 向 broker push 消息并由 Consumer 从 broker pull 消息。一些 logging-centric system，比如 Facebook 的Scribe和 Cloudera 的Flume，采用 push 模式。事实上，push 模式和 pull 模式各有优劣。 push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。push 模式的目标是尽可能以最快速度传递消息，但是这样很容易造成 Consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。 对于 Kafka 而言，pull 模式更合适。pull 模式可简化 broker 的设计，Consumer 可自主控制消费消息的速率，同时 Consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。 讨论五：Kafka 如何保证可靠性当我们讨论可靠性的时候，我们总会提到保证*这个词语。可靠性保证是基础，我们基于这些基础之上构建我们的应用。比如关系型数据库的可靠性保证是ACID，也就是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。 Kafka 中的可靠性保证有如下四点： 对于一个分区来说，它的消息是有序的。如果一个生产者向一个分区先写入消息A，然后写入消息B，那么消费者会先读取消息A再读取消息B。 当消息写入所有in-sync状态的副本后，消息才会认为已提交（committed）。这里的写入有可能只是写入到文件系统的缓存，不一定刷新到磁盘。生产者可以等待不同时机的确认，比如等待分区主副本写入即返回，后者等待所有in-sync状态副本写入才返回。 一旦消息已提交，那么只要有一个副本存活，数据不会丢失。 消费者只能读取到已提交的消息。 使用这些基础保证，我们构建一个可靠的系统，这时候需要考虑一个问题：究竟我们的应用需要多大程度的可靠性？可靠性不是无偿的，它与系统可用性、吞吐量、延迟和硬件价格息息相关，得此失彼。因此，我们往往需要做权衡，一味的追求可靠性并不实际。 想了解更多戳这里：http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/21/kafka-data-delivery.html 三、动手搭一个 Kafka 通过上面的描述，我们已经大致了解到了「Kafka」是何方神圣了，现在我们开始尝试自己动手本地搭一个来实际体验一把。 第一步：下载 Kafka这里以 Mac OS 为例，在安装了 Homebrew 的情况下执行下列代码： brew install kafka 由于 Kafka 依赖了 Zookeeper，所以在下载的时候会自动下载。 第二步：启动服务我们在启动之前首先需要修改 Kafka 的监听地址和端口为 localhost:9092： vi /usr/local/etc/kafka/server.properties 然后修改成下图的样子： 依次启动 Zookeeper 和 Kafka： brew services start zookeeper brew services start kafka 然后执行下列语句来创建一个名字为 “test” 的 Topic： kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 我们可以通过下列的命令查看我们的 Topic 列表： kafka-topics --list --zookeeper localhost:2181 第三步：发送消息然后我们新建一个控制台，运行下列命令创建一个消费者关注刚才创建的 Topic： kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning 用控制台往刚才创建的 Topic 中添加消息，并观察刚才创建的消费者窗口： kafka-console-producer --broker-list localhost:9092 --topic test 能通过消费者窗口观察到正确的消息： 参考资料 https://www.infoq.cn/article/kafka-analysis-part-1 - Kafka 设计解析（一）：Kafka 背景及架构介绍 http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/06/kafka-Meet-Kafka.html - Kafka系列（一）初识Kafka https://lotabout.me/2018/kafka-introduction/ - Kafka 入门介绍 https://www.zhihu.com/question/28925721 - Kafka 中的 Topic 为什么要进行分区? - 知乎 https://blog.joway.io/posts/kafka-design-practice/ - Kafka 的设计与实践思考 http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/21/kafka-data-delivery.html - Kafka系列（六）可靠的数据传输 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Kafka","slug":"后端/中间件/Kafka","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"「消息队列」看过来！","slug":"「消息队列」看过来！","date":"2019-07-16T01:55:00.000Z","updated":"2020-12-09T04:53:23.499Z","comments":true,"path":"2019/07/16/xiao-xi-dui-lie-kan-guo-lai/","link":"","permalink":"http://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/","excerpt":"为了获得更良好的阅读体验，建议您前往个人独立域名博客观看：传送门)","text":"为了获得更良好的阅读体验，建议您前往个人独立域名博客观看：传送门) 一、什么是消息队列？ 当我试图用一则通俗的比喻来说明这个概念的时候，我想到一个有意思的比喻：如果把队列抽象成一个集合体，那么消息队列也就是一堆消息的集合。按照这个思路我想到了「杂志」。这不就是一堆消息的集合吗，关心这些消息的人都能通过「购买」来获得这些消息，而我可以通过不同种类的「杂志」或许到不同的消息。并且如果我作为出版方，我可以提供所有出版过的「杂志」，也可以选择让读者只能购买近期的。 二、为什么需要消息队列？ 好处一：解耦假设我们做了一个会议室预定系统，我们的一个设备坏了。我们需要通知预定这个会议室的所有人，于是我们需要发邮件，伪代码如下： @Service public class EquipmentServiceImpl implements EquipmentService { @Autowired private EmailService emailService; @Autowired private EquipmentRepository equipmentRepository; public void setEquipmentBroken(Long id) { Equipment equipment = equipmentRepository.findById(id); equipment.setStatus(Equipment.StatusEnum.BROKEN); emailService.sendEmail(); } } 问题来了，如果我们后来发现设备坏了并且需要更改可用库存的数量，这时候我们是不是要在这里加入 InventoryService 库存服务的代码呢？后来如果经理说设备坏了应该通知他才对啊，所以我们要不要加入 emailService.sendEmailTo(Manager) 这样的代码呢？ 随着我们业务模块接入越来越多，我们的代码与其他模块越来越耦合，修改代码的难度也指数级的增加，所以我们引入「消息队列」，把「设备坏了」这样的消息发送到队列中，其他关心这条消息的业务就会得到这样的「通知」，然后就会去做对应的事，这样各个模块之间就解耦了。伪代码看上去如下： public void setEquipmentBroken(Long id) { Equipment equipment = equipmentRepository.findById(id); equipment.broken(); eventBus.publish(new EquipmentBrokenEvent(equipment.id)); } 好处二：异步处理接着上面的例子，假设我们已经把「发送邮件」、「修改库存」以及「通知经理」的代码都写入了我们的 Service 代码中，它们分别耗时：30ms、50ms、80ms，并且我们得知，原本最主要的功能其实是「发送邮件」，但我们完成主要的功能之后却等待了更多的额外时间，这显示是不合理的。 所以我们为了提高用户体验&amp;提高吞吐量，我们其实可以引入「消息队列」来进行异步的操作。 好处三：削峰/限流 假设我们的服务器最多能支持每秒 1000 个请求，而我们公司在节日要搞促销，为了避免服务器挂掉我们额外申请了两台服务器做了负载均衡，于是我们现在的机器最理想的情况能够支持每秒 3000 个请求，但奈何活动太火爆了，每秒来的请求有大概 4000 个，这些多出来的请求就可能导致服务器给直接挂掉了。 所以我们就引入了一个「消息队列」，让消息不直接到达服务器，而是先让「消息队列」保存这些数据，然后让下面的服务器每一次都取各自能处理的请求数再去处理，这样当请求数超过服务器最大负载时，就不至于把服务器搞挂了。 三、消息队列适用的场景 基于上面的描述，我们大概能想到「消息队列」的局限性，例如当「生产者」需要「从消费者获得反馈」时，就会出现一定的问题。例如我之前尝试着使用「事件驱动」的方式编码时，我想要把 Service 的一些主逻辑给转移到关注该事件的监听器上时，发现有点问题，我原本的意图是想让一部分代码解耦，但作为主逻辑的一部分我需要保证它们准确的执行，当我使用「消息」的方式传递出去时，我无法得到消费者的反馈，所以最终我还是把主逻辑给迁回来了，算是一次失败的尝试吧。 场景一：异步处理通过上述的问题你也看到了，「消息队列」适用于异步处理，并且是那些不期望从消费者得到反馈的处理。就好像一开始说到的设备坏了的问题，我只需要通知设备坏了，至于之后需要做什么事，关心的人自然会去做相应的处理。 场景二：日志收集上面提到的异步处理，跟日志系统似乎搭配起来也很好。特别是当你需要把日志发往单独的数据平台的时候，「消息队列」尤为有用，我们不再需要在业务代码里面侵入我们的各种打点or日志，只需要简单的发布一条消息，再去关注做处理就好了。 场景四：应用解耦基于上面的例子你应该也能感受一二了。 场景三：流量削峰这也是「消息队列」常见的场景，通过引入「消息队列」，我们一来可以控制请求的人数，二来也可以缓解短时间内高流量的压力。 场景四：消息通讯消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 四、常见消息队列中间件 如果自己设计一个？我们在讨论市面上常见的「消息队列」中间件之前，我们先来考虑自己造一个怎么样？如果是你自己来设计，你会怎么做？乍一想，似乎每个语言都会有自己实现的「队列」，往队列里塞数据，再从队列里面挨个取就行了？ 但是一细想好像事情并不简单。作为一个「消息队列」，你首先要保证数据不能给人家弄丢了吧？存内存？万一断电了怎么办？写磁盘？消息量超过系统写磁盘速率上限了怎么办？备份又该怎么做呢？ 好，假设我一整捣鼓，保证了我的数据不会丢失了，下一个问题，生产者怎么往「消息队列」里面塞数据？我的意思是，生产者可能不止一个，把全量的消息放在一个队列似乎不太合适，我需要给这些消息分个类吧？新来了一个分类的消息我怎么动态的扩容呢？消费者又如何消费这些数据呢？多个消费者之间又如何进行协调呢？ 好吧..总之问题挺多的..并不像表面那么简单。 RabbitMQ RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负 载均衡或者数据持久化都有很好的支持。 RedisRedis 也能用来做「消息队列」。Redis 是一个基于 Key-Value 对的 NoSQL 数据库，开发维护很活跃。虽然它是一个 Key-Value 数据库存储系统，但它本身支持 MQ 功能， 所以完全可以当做一个轻量级的队列服务来使用。对于 RabbitMQ 和 Redis 的入队和出队操作，各执行 100 万次，每 10 万次记录一次执行时间。测试 数据分为 128 Bytes、512 Bytes、1 K和 10 K四个不同大小的数据。实验表明：入队时，当数据比较小时 Redis 的性能要高于 RabbitMQ，而如果数据大小超过了 10 K，Redis 则慢的无法忍受；出队时，无论数据大小，Redis 都表现出非常好的性能，而 RabbitMQ 的出队性能则远低于Redis。 Kafka/JafkaKafka 是 Apache 下的一个子项目，是一个高性能跨语言分布式 Publish/Subscribe 消息队列系统，而 Jafka 是在 Kafka 之上孵化而来的，即 Kafka 的一个升级版。 具有以下特性： 快速持久化，可以在O(1)的系统开销下进行消息持久化； 高吞吐，在一台普通的服务器上既可以达到 10 W/s的吞吐速率； 完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡； 支持 Hadoop 数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。 Kafka 通过 Hadoop 的并行加载机制来统一了在线和离线的消息处理。Apache Kafka 相对于 ActiveMQ 是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。 ZeroMQZeroMQ 号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ 能够实现 RabbitMQ 不擅长的高级 / 复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这 MQ 能够应用成功的挑战。ZeroMQ 具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用 ZeroMQ 程序库，可以使用 NuGet 安装，然后你就可以愉快的在应用程序之间发送消息了。但是 ZeroMQ 仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter 的 Storm 0.9.0 以前的版本中默认使用 ZeroMQ 作为数据流的传输（Storm 从 0.9 版本开始同时支持 ZeroMQ 和 Netty 作为传输模块）。 ActiveMQActiveMQ 是 Apache 下的一个子项目。 类似于 ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于 RabbitMQ，它少量代码就可以高效地实现高级应用场景。 参考资料 Kafka 设计解析（一）：Kafka 背景及架构介绍 浅谈消息队列及常见的消息中间件 消息队列介绍及常用MQ对比 什么是消息队列？ 消息队列的使用场景是怎样的？ - 知乎 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！独立域名博客：wmyskxz.com简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"基础知识","slug":"后端/中间件/基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"如何超越大多数人","slug":"如何超越大多数人","date":"2019-06-30T23:32:00.000Z","updated":"2020-12-09T04:57:06.179Z","comments":true,"path":"2019/07/01/ru-he-chao-yue-da-duo-shu-ren/","link":"","permalink":"http://www.wmyskxz.com/2019/07/01/ru-he-chao-yue-da-duo-shu-ren/","excerpt":"","text":"本文转载自酷壳-COOLSHELL：https://coolshell.cn/articles/19464.html作者：左耳听风 当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！ P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格……嘿嘿 相关技巧和最佳实践要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。 在信息获取上，你要不断地向大众鼓吹下面的这些事： 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。 把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场…… 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。 然后，在知识学习和技能训练上，让他们不得要领并产生幻觉 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉…… 培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”…… 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃…… 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业…… 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考…… 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型…… 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉…… 让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了…… 最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好…… 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云…… 告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等…… 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功…… 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋…… 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质…… 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉…… 告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春…… 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值） 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃…… 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟…… 最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。 相关原理和思维模型对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。 一般来说，超过别人一般来说就是两个维度： 在认知、知识和技能上。这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21天教你学会C++》） 在领导力上。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》） 首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。 认知要在认知上超过别人，就要在下面几个方面上做足功夫： 1）信息渠道。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？） 2）信息质量。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。 3）信息密度。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像Netflix的官方blog和AWS CTO的blog等等地方也会经常有一些这样的文章。 知识要在知识上超过别人，你就需要在下面几个方面上做足功夫： 1）知识树（图）。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！ 2）知识缘由。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。I 3）方法套路。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。 技能要在技能上超过别人，你就需要在下面几个方面做足功夫： 1）精益求精。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。 2）让自己犯错。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！ 3）找高手切磋。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！ 领导力最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。 1）识别自己的特长和天赋。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而你毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。 2）识别自己的兴趣和事业。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。 3）建立高级的习惯和方法。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。 4）勤奋努力执着坚持。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《21天教你学会C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。 好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。 （全文完）","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"喜欢的三观","slug":"想要跟你们分享/喜欢的三观","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"【吐血推荐】领域驱动设计学习输出","slug":"【吐血推荐】领域驱动设计学习输出","date":"2019-06-12T23:38:00.000Z","updated":"2020-12-09T04:43:21.405Z","comments":true,"path":"2019/06/13/tu-xie-tui-jian-ling-yu-qu-dong-she-ji-xue-xi-shu-chu/","link":"","permalink":"http://www.wmyskxz.com/2019/06/13/tu-xie-tui-jian-ling-yu-qu-dong-she-ji-xue-xi-shu-chu/","excerpt":"","text":"一、Hello DDD 刚开始接触学习「DDD - 领域驱动」的时候，我被各种新颖的概念所吸引：「领域」、「领域驱动」、「子域」、「聚合」、「聚合根」、「值对象」、「通用语言」…..总之一大堆有关的、无关的概念从我的脑海经过，其中不乏让我陷入思考的地方，我原以为我会很开心地 “享用” 这些新知识带给我的营养（参照下图） 可事实上，我为学习「DDD - 领域驱动」付出了很多的精力，我尝试用「DDD CRUD」、「DDD vs CRUD」、「Domain-Driven Design」、「DDD CQRS」、「领域驱动设计」等等一系列的关键字搜集我想要的资料（翻遍了 Google 前排的所有文章&amp;手动感谢谷歌让我能获得一些精彩的文章），可似乎都不太近人意，一方面这个「新概念」我对它的困惑太多了，另一方面真正「落地」并实践起来的经验有很少是可以直接借鉴的，再结合一些实际的场景（没有人解答），我感到更加困惑。 传统开发面临的问题我们先来讨论一下传统开发面临的一些问题吧，就先从传统开发中被广泛应用于 Web 开发的传统三层框架：「MVC」 开始说起吧。 图片来源：https://draveness.me/mvx 传统的「MVC」模型把框架分成了三层：显示层、控制层、模型层，而传统的模型层又被拆分成了业务层（Service）和数据访问层（DAO,Data Access Object）。 显示层负责显示用户界面、控制层负责处理业务逻辑、而模型则负责与数据库通信，对数据进行持久化的操作。这样的结构不仅结构松散，而且各个模块职责分离，有什么问题呢？ 让我们来看一个实际的例子吧。 假设我们做了一个会议室预定系统，我们的一个设备坏了。我们需要通知预定这个会议室的所有人，于是我们需要发邮件，伪代码如下： @Service public class EquipmentServiceImpl implements EquipmentService { @Autowired private EmailService emailService; @Autowired private EquipmentRepository equipmentRepository; public void setEquipmentBroken(Long id) { Equipment equipment = equipmentRepository.findById(id); equipment.setStatus(Equipment.StatusEnum.BROKEN); emailService.sendEmail(); } } 问题来了，如果我们后来发现设备坏了并且需要更改可用库存的数量，这时候我们是不是要在这里加入 InventoryService 库存服务的代码呢？后来如果经理说设备坏了应该通知他才对啊，所以我们要不要加入 emailService.sendEmailTo(Manager) 这样的代码呢？ 就算不考虑职责单一原则和关注分离原则，程序员也会疯掉的，这样做 Service 太重了，并且糟糕的是它可能还不止考虑这些，还有权限、事务等等一系列的事情等着 Service 层去做，如此产生了大量的依赖和循环依赖，当业务复杂度上升时，直接导致了服务层所含的代码过于庞大和复杂、测试成本直线上升，并且各个 Service 的逻辑散落在各处，维护的成本也非常大。 我相信很多公司正在经历这样的事情，并且问题还远不止于此。 最近我就经历过另一种问题。作为实习生刚入公司的我接到产品了一个需求，虽然有正规的需求文档可以供我阅读，但对于业务还不熟悉的我读起来就感觉是：摁，我想要这个页面这样。 当产品经历耐心的过来给我解释的时候，我仍然感到无奈，因为他尽可能详细地在描述他想要在哪一个页面的哪一个地方加上什么东西的同时，我看着眼前屏幕上的一堆模型和代码，感到无从下手，只能找来大佬帮忙充当一下 “翻译”。 必须承认自己对业务的生疏是主要的原因，但根本原因还是：开发与产品之间的「沟通」不能保持一致，双方对于同一事物的「表达和理解」有很大的区别。产品看到的是实际的「业务场景」，而开发则更关注背后的「实现逻辑」。 CRUD 的各种问题上面或许有说得不对的地方，但这样的现象确实的存在。（例如我审视了一下我之前写过的代码，突然感慨幸好自己之前都是独立开发且功能简单，嘻嘻嘻） 另一个想要讨论的问题是关于后端开发者常常拿来自嘲的「CRUD」。经常有开发人员苦着脸说：每天除了写「BUG」，就一直在写「CRUD」代码，没有很大长进。当然这只是一种自嘲，但可能写「BUG」是真的，也可能没有长进是真的，当然两个都可能都是真的。 「CRUD」 其实对应的是数据库中的增删改查的操作。现实的情况中，只有极少有企业不用到数据库，数据库就像是现代软件开发的一剂灵丹妙药，不仅提供可靠、快速、大容量的存储服务，还支持强大的事务管理机制，满足了大部分场景中对数据的一致性需求。 数据库如此的强大，以至于我们从接触软件开发开始就一直使用「CRUD」的模式进行开发。我们的「潜意识」中就形成了「以数据为中心」的开发模式，这没有什么不好，并且大多数情况下是适用的，这里只是讨论：「CRUD」有什么问题？ 问题一：面向对象和数据库天然阻抗面向对象编程的语言和数据库都是我们几乎“最熟悉”的东西了，我们甚至使用他们编织出了绝大多数复杂多样的网络应用，为什么说它们之间存在着天然阻抗？ 当然我觉得这里有一点「强行找不同」的味道，但也不失为一种思考和讨论。并且我觉得还是有点道理的。 A1：对象和关系数据库累赘转换 在一个面向对象的系统中，对象是数据的承载方式，每一个 DAO 对象都对应着关系数据库中的一条数据。 但通常视图层只显示完整实体对象的一小部分数据，那么其余的「无关数据」你准备怎么处理呢？ 是否要把对象中包含的「所有数据」一起返回给视图层？ 是否需要创建一个新的专用的「数据传输对象」？ 或者你想直接把「无关数据」字段设置成 null？ 显然，在绝大多数应用中都采取了第二种方案，于是我们看到各种冗余、繁多的「传输层对象」，随着时间的推移，系统中堆积的「传输层对象」越来越多，不仅增加了系统的「复杂度」，而且还降低了我们的「开发效率」。我猜这也是人们说 Java 复杂的一方面原因吧。 更重要的是，万一有一个字段发生变化，更改量就很大。（当然这也有解决方案） A2：继承关系的尴尬实现 继承是面向对象的一个重要特性，而关系数据库却难以复现对象世界中的继承关系。 我们来试着还原一下上面的继承关系吧。 如果我们按照把 Student 和 Professor 建成两张表，问题就是：关系数据库分割了两个对象的共性 Person。从语义上说：也就是将一个对象分割成两个部分了；而且当你要获取这个对象时，需要两次Select。同样道理增删改查都要两次。 如果我们把 Student 和 Professor 合并成一张表，问题就是：会产生许多空白字段。这很容易理解。 这些都反映了面向对象和关系数据库天然不匹配，只能一方作出妥协，并且大部分情况是面相对象作出妥协。 A3：类的复杂关系实现 当我们需要创建一个部门（Department），而一个部门将拥有多个教授（Professor）这样一个模型的时候，我们发现面向对象和关系数据库「表达方式」的是两种不同的形式： 面向对象：我是一个部门，在我里面有很多的教授； 关系数据库，由于外键会在 Professor 上：我是一个教授，我属于那个部门。 问题二：是一种数据模型，与业务脱节没有一个「真实的人」会在支付一笔订单的时候说：（大概意思..） =&gt; 先通过我这个订单的编号找到原始在系统上的记录；=&gt; 把支付金额改成我实际支付的金额；=&gt; 把这个订单的状态修改成已支付=&gt; …….. 而一个「真实的人」会直接说：我为这笔订单付了xxx钱。 关系型数据库（Relational Database）的核心实体就是数据表，核心操作就是在定义好的数据表上的「CRUD」操作。这套东西实在是太好用了，也太深入人心了，以至于你能在好多地方都能看到这种将关系模式直接用作业务模式的系统： 比如我之前写的所有东西。（就拿我写的个人博客为例吧：https://github.com/wmyskxz/MyBlog） 问题出在：我的「Entity层」只是数据库表结构的一种映射用于承载数据，我的「DAO层」只是封装了对「Entity层」的增删改查，我的「Controller层」只是简单的把地址和对应「Service层」的对应方法做了关联返回结果给「视图层」，而我的「Service层」则大部分工作也只是在做一些「查询」、「拼接数据」的工作，这样的系统是声称套上了业务的外衣，而实则只是「皇帝的新衣」，几乎无法保证业务逻辑的正确性、完整性。 我还记得朋友问过我一个问题，大意就是有一部分的系统其实只是对数据库的简单封装，感觉就像是系统只是数据库的「简单代理」一样。我一开始有点儿感同身受，但现在回过头想，只是我们当时做的东西太简单了而已。简单的系统也就是对数据库的「CRUD」。 但这还不是重点，重点是大部分的「CRUD工程师」对「业务理解」出了问题。 让我们拿国际象棋举个例子： 图片引自：https://zhuanlan.zhihu.com/p/25442175 作为一枚「CRUD工程师」，在完成了左边部分的数据库设计和右边的数据展现之后，往往就认为已经万事大吉了。但这样的产品交付之后，对现实中使用它的用户提出了很多的潜在要求。「CRUD工程师」从来不会提示你这些潜在需求，谁会对自己并不知道的事情加以说明呢？ 简而言之，这样的一个国际象棋程序，自身对国际象棋规则完全是一窍不通的。就是拿出个表格给你，随你填成啥样。在这件事情上，完全指望使用者不犯错，这是何等的心大！ 图片引自：https://zhuanlan.zhihu.com/p/25442175 于是，这个国际象棋程序完全有可能出现 Bad case 的这种诡异情况：黑色骑士（knight）走出一个华丽的斜线，和其中一个白色兵（pawn）共处一室（什么鬼？！）「国际象棋填表系统」并不会阻止你这样做，因为它并没有正确与错误之分。 这时候，「CRUD工程师」被客户、老板抓出来收拾残局了。经过一番调研，原来客户是想把黑色骑士走到 6d，并吃掉（capture）另一个白色兵。“产品已经够简单的了，客户怎么都这么蠢？”「CRUD工程师」嘀咕道，“哎，这工作坑真是多啊”。 原片段摘自：https://zhuanlan.zhihu.com/p/25442175 问题三：CRUD 缺少意图（intent）事实上我们可以使用「CRUD」架构很好的服务绝大多数的应用。但是正如上面提到的问题所说的那样，当系统的「复杂度」上升的时候，「CRUD」可能会缺少一件事：意图（intent）。 例如： 我们想要改变一个 Customer 的地址，在「CRUD」体系中，我们只需要发出更新语句就能实现。但是我们无法弄清楚这种变化是由不正确的操作引起的，还是客户真的转移到了另一个城市。也许我们有一个业务场景，需要再重新定位时触发对外部系统的通知。在这种情况下，「CRUD」显得有所缺失。 问题四：实施协作“困难”在大多数的「CRUD」应用中，最新的更改将覆盖其他用户并行执行的其他更改。也就是说如果一个团队中的两个人同时对同一个文件的同一行进行修改，那么合并代码的时候就会产生「冲突」。 在上面我们论述了在传统「CRUD」这样的矛盾是如何产生的：散落在各处分散的逻辑代码。 问题五：被人诟病的「U」「CRUD」中的「U」指的是「更新」操作。通常在我们的系统中「U」作为一种通用的方法可以更新资源的任何字段，然后使用新版本覆盖掉旧版本。 并且现在由于「REST」的流行，大多数的「API」都是围绕「资源模型」来进行「CRUD」操作的，这样做不仅确实极大地方便了开发人员的工作，并且借由「HTTP动词」和「资源URI」结合起来有很好的可读性。 但这有什么问题呢？ 我们考虑一个简单的「银行账户」资源的问题。当我们需要把账户的余额更新为想要的数量的时候，我们应该允许客户端直接调用更新方法吗？任何余额调整的动作都应该作为某种类型的交易事务被记录下来才对，例如「充值」、「取钱」，还是「转账」？另外账户是否存在？可能变更吗？等等一系列问题都可能使你的通用「U」变得臃肿难以维护。 基于上述的多种多样的「场景」，我们的通用「U」方法被推向了尴尬的境地。事实上这可能属于设计的问题，不知道一般的公司中是如何解决的，至少在我之前写的代码中，我是这样实现的。（并且可能觉得没有什么问题） 另外也有的人说「CRUD」限制了描述业务的语言的问题。因为增删改查只有四个动词，而我们实际的业务场景可能更加复杂。 问题六：提供变更历史记录的操作很复杂还有一个问题：「CRUD」会丢失应用程序的历史记录。例如，如果用户在一段时间内多次变更记录，我们则无法再跟踪单个更改。更糟糕的是，甚至无法确定该条目是否曾经被改变过。 当然，这可以通过为最后更新的时间戳添加字段来处理，但这只会帮助我们能够获得最新的更新。如果你对整个历史感兴趣，事情就会变得复杂：你必须从一开始就额外引入一组字段or一张新表。 这里的问题是：由于你不知道将来会询问哪些关于你数据的问题，因此你无法针对相应的情况对表做出优化。因为你收集太多或者太少的数据，似乎都存在一定问题。 总结现在早已经不再是 PC Web 的时代了，原生 APP、移动 Web 等等多种客户端技术在近几年爆发（IOS、Android、JavaScript、…），青出于蓝而胜于蓝。原先「MVC」中的视图（Web页面）渲染工作，面临被新技术的完全替代。「CRUD工程师」手中的系统们，面临向「SOA」的转型。 夜深人静，四下无人的时候，「CRUD工程师」再次陷入深深的困惑：一边是臃肿不堪的模型和控制器层，另一边是逐渐收缩和服务化的视图层，难道建表、写表、读表就要成为我的唯一主题了吗？ 「CRUD工程师」认为自己没有创造任何东西，他们只是数据库表的搬运工。而如果不是「CRUD」，业务系统后端工程师的价值在哪里？ 理解并抽象出业务逻辑，建立满足需求的业务模型，以此设计实现出可靠的系统，并有效地控制复杂性。这才是大部分业务系统后端工程师的工作重点，也是解决他们工作中遇到的问题和难点的关键。 观点来自：https://zhuanlan.zhihu.com/p/25442175 爱因斯坦说：“如果给我 1 个小时解答一道决定我生死的问题，我会花 55 分钟来弄清楚这道题到底是在问什么。一旦清楚了它到底在问什么，剩下的 5 分钟足够回答这个问题。” 虽然目前为止我们还不太了解「DDD」是如何帮助我们解决传统开发中的各种问题，但是听说「DDD - 领域驱动设计」似乎是能够用来设计和实现业务逻辑的一剂良药。 所以「Hello - DDD」。 二、DDD 是什么？ 「DDD」的全称是「Domain-driven Design」，即「领域驱动设计」。是由「Eric Evans」最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展为一种针对大型复杂系统的领域建模与分析方法。 它完全改变了传统软件开发工程师针对数据库进行的建模方法，从而将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承、多态等设计要素，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。 总结： 目前为止，您只需要知道「DDD」是一种致力于降低或隐藏整个系统业务复杂性，让系统具有更好扩展，应对纷杂繁多的现实也问题的架构方法就行了。 DDD 简史 图片引自：https://www.jianshu.com/p/e1b32a5ee91c 领域驱动设计这个概念出现在 2003 年，那个时候的软件还处在从 CS 到 BS 转换的时期，敏捷宣言也才发表 2 年。但是「Eric Evans」作为在企业级应用工作多年的技术顾问，敏锐的发现了在软件开发业界内（尤其是企业级应用）开始涌现的一股思潮，他把这股思潮称为领域驱动设计，同时还出版了一本书，在书中分享了自己在设计软件项目时采用的建模方法，并为设计决策者提供了一个框架。 但是从那以后「DDD」并没有和「敏捷」一样变得更加流行，如果要问原因，我觉得一方面是这套方法里面有很多的新名词新概念，比如说「聚合」，「限界上下文」，「值对象」等等，要理解这些抽象概念本身就比较困难，所以学习和应用「DDD」的曲线是非常陡峭的。另一方面，做为当时唯一的“官方教材”《领域驱动设计》，阅读这本书是一个非常痛苦的过程，在内容组织上经常会出现跳跃，所以很多人都是刚读了几页就放下了。 虽然入门门槛有些高，但是对于喜欢智力挑战的软件工程师们来说，这就是一个难度稍为有一点高的玩具，所以在小范围群体内，逐渐有一批人开始能够掌控这个玩具，并且可以用它来指导设计能够控制业务复杂性的软件应用出来了。虽然那时候大部分的软件应用都是单体的，但是使用「DDD」依然可以设计出来容易维护而且快速响应需求变化的单体应用出来。 到了 2013 年，随着各种分布式的基础设施逐渐成熟，而「SOA架构」应用在实践中又不是那么顺利，Martin Fowler 和 James Lewis 把当时出现的一种新型分布式架构风潮总结成微服务架构。 然后微服务这股风就呼呼的吹了起来，这时候软件工程师们发现一个问题，就是虽然指导微服务架构的应用具有什么特征，但是如何把原来的大单体拆分成微服务是完全不知道怎么做了。 然后熟悉「DDD」方法的工程师发现，由于「DDD」可以有效的从业务视角对软件系统进行拆解，并且「DDD」特别契合微服务的一个特征：围绕业务能力构建。所以用「DDD」拆分出来的微服务是比较合理的而且能够实现高内聚低耦合，这样接着微服务「DDD」迎来了它的第二春。 DDD 思辨从计算机发明以来，人类用过表达世界变化的词有：电子化，信息化，数字化。这些词里面都有一个 “化” 字，代表着转变，而这些转变就是人类在逐渐的把原来在物理世界中的一个个概念一个个工作，迁移到虚拟的计算机世界。 但是在转变的过程中，由于两个世界的底层逻辑以及底层语言不一致，就必须要有一个翻译和设计的过程。这个翻译过程从软件诞生的第一天起就天然存在，而由于有了这个翻译过程，业务和开发之间才总是想两个对立的阶级一样，觉得对方是难以沟通的。 于是乎有些软件工程界的大牛就开始思考，能不能有一种方式来减轻这个翻译过程呢。然后就发明了「面向对象语言」，开始尝试让计算机世界有物理世界的对象概念。面向对象还不够，这就有了「DDD」，「DDD」定义了一些基本概念，然后尝试让业务和开发都能够理解这些概念名词，然后让「领域专家」（这里你可以理解为熟悉业务的人）使用这些概念名词来描述业务，而由于使用了规定的概念名词，开发就可以很好的理解领域业务，并能够按照领域业务设计的方式进行软件实现。 这就是DDD的初衷：让业务架构绑定系统架构。 后来发现这个方法不仅仅可以做好翻译，还可以帮助业务划分领域边界，可以明确哪个领域是自己的核心价值所在，以后应该重点发展哪个领域。甚至可以作为组织进行战略规划的参考。而能够做到这点，其实背后的原因是物理世界和虚拟世界的融合。 三、为什么使用 DDD？ DDD 帮助解决微服务拆分困境上面介绍了使用DDD可以做到绑定业务架构和系统架构，这种绑定对于微服务来说有什么关系呢。所谓的微服务拆分困难，其实根本原因是不知道边界在什么地方。而使用DDD对业务分析的时候，首先会使用「聚合」这个概念把关联性强的业务概念划分在一个边界下，并限定「聚合」和「聚合」之间只能通过「聚合根」来访问，这是第一层边界。 然后在「聚合」基础之上根据「业务相关性」、「业务变化频率」、「组织结构」等等约束条件来定义「限界上下文」，这是第二层边界。有了这两层边界作为约束和限制，微服务的边界也就清晰了，拆分微服务也就不再困难了。 DDD 帮助应对系统复杂性解决复杂和大规模软件的武器可以被粗略地归为三类：「抽象」、「分治」和「知识」。 分治： 把问题空间分割为规模更小且易于处理的若干子问题。分割后的问题需要足够小，以便一个人单枪匹马就能够解决他们；其次，必须考虑如何将分割后的各个部分装配为整体。分割得越合理越易于理解，在装配成整体时，所需跟踪的细节也就越少。即更容易设计各部分的协作方式。评判什么是分治得好，即高内聚低耦合。 抽象： 使用抽象能够精简问题空间，而且问题越小越容易理解。举个例子，从北京到上海出差，可以先理解为使用交通工具前往，但不需要一开始就想清楚到底是高铁还是飞机，以及乘坐它们需要注意什么。 知识： 顾名思义，「DDD」可以认为是知识的一种。 「DDD」提供了这样的知识手段，让我们知道如何抽象出「限界上下文」以及如何去「分治」。 图片来源：https://servicecomb.apache.org/cn/docs/crm-part-I/ 另外一个感受就是我们可以使用「领域事件」来应对多样的变化。参考上面提到发邮件的例子，我们可以把它改造成这样： public void setEquipmentBroken(Long id) { Equipment equipment = equipmentRepository.findById(id); equipment.broken(); eventBus.publish(new EquipmentBrokenEvent(equipment.id)); } 这样，通知会议室预订者的模块就会去通知相应的人员，而不用我们自己操心了。 更为重要的是，「DDD」架构区别于传统的方式。 图片引自：https://blog.pragmatists.com/domain-driven-design-vs-anemic-model-how-do-they-differ-ffdee9371a86 我们需要先了解一个概念：「贫血模型」。也就是只有属性的类，贫血的意思就是没有行为，像木乃伊一样。这种模型唯一的作用就是将一些 ORM 映射到对应的数据库上，而我们的「服务层」通过「DAO层」加载这些「贫血模型」进行一些拼接之类的操作，功能越复杂，这种操作就越频繁，这是我们的软件复杂度上升的直接原因。 而「DDD」则把大多数的业务逻辑都包含在了「聚合」、「实体」、「值对象」里面，简单理解也就是实现了对象自治，把之前暴露出来的一些业务操作隐藏进了「域」之中。每个不同的区域之间只能通过对外暴露的统一的聚合根来访问，这样就做了收权的操作，这样数据的定义和更改的地方就聚集在了一处，很好的解决了复杂度的问题。 DDD 帮助统一语言在UML作为建模主流的时代，软件设计被明确分为面向对象分析（OOA），面向对象设计（OOD）和面向对象编码（OOP）阶段。实际操作中OOD的工作往往被OOA和OOP各自承担一部分，并同时存在分析模型和设计模型两个割裂的模型。 而领域驱动设计的核心是建立统一的领域模型。领域模型在软件架构中处于核心地位，软件开发过程中，必须以建立领域模型为中心，以保障领域模型的忠实体现。 图片来源：http://kaelzhang81.github.io/2017/10/20/DDD%E4%B9%8B-%E9%81%93%E6%9C%AF%E5%99%A8/ 简单理解起来的话，也就是把业务人员和开发人员的语言统一起来，用代码来感受一下大概就是： userService.love(Jack, Rose) => Jack.love(Rose) companyService.hire(company,employee) => Company.hire(employee) 四、领域驱动设计过程 领域驱动设计强调领域模型的重要性，并通过模型驱动设计来保障领域模型与程序设计的一致。从业务需求中提炼出统一语言（Ubiquitous Language），再基于统一语言建立领域模型；这个领域模型会指导着程序设计以及编码实现；最后，又通过重构来发现隐式概念，并运用设计模式改进设计与开发质量。这个过程如下图所示： 图片来源：http://zhangyi.xyz/overview-of-ddd/ 这个过程是一个覆盖软件全生命周期的设计闭环，每个环节的输出都可以作为下一个环节的输入，而在其中扮演重要指导作用的则是“领域模型”。这个设计闭环是一个螺旋上升的迭代设计过程，领域模型会在这个迭代过程中逐渐演进，在保证模型完整性与正确性的同时，具有新鲜的活力，使得领域模型能够始终如一的贯穿领域驱动设计过程，阐释着领域逻辑，指导着程序设计，验证着编码质量。 如果仔细审视这个设计闭环，我们发现在针对问题域和业务期望提炼统一语言，并通过统一语言进行领域建模时，可能会面临高复杂度的挑战。这是因为对于一个复杂的软件系统而言，我们要处理的问题域实在太庞大了。在为问题域寻求解决方案时，需要从宏观层次划分不同业务关注点的子领域，然后再深入到子领域中从微观层次对领域进行建模。宏观层次是战略的层面，微观层次是战术的层面，只有将战略设计与战术设计结合起来，才是完整的领域驱动设计。 战略设计 (Do Right Things)Ubiquitous language领域驱动开发让业务专家(Domain Expert)和开发人员一起来梳理业务，而双方有效沟通的方式是使用通用语言，在这个项目里，一开始我们就定义了很多词汇表, 就是我们自己的通用语言。 Bounded Context 和 Domain有了通用语言，词汇表 每一个词汇一定是有边界的，不同的边界内是不一样，比如你爱人在你家这个 Bounded Context 是你的 Wife, 但是如果她是一个老师，那么在学校这个边界里就是一个 Teacher. 我们经过多次讨论，采取的方法是拆成多个子系统（Bounded Context,是不是很像现在的微服务？)，每个子系统进行自治。 随后我们把一个个业务抽象为领域对象(Domain Model), 每一个 Domain 对领域进行自治。而模型里的属性和行为表达为业务专家都可以理解的代码，用比如Job.Publish(). 虽然这里面最终产生了聚合根、实体、值对象等，但是我们和业务专家沟通的时候尽量不要说这些词汇，比如我们可以说， 在招聘这块儿，职位是不是必须经过公司进行管理，那样我们就知道 Job 是属于公司这个聚合根。 对领域进行“通用”（类名，方法名等都用自然语言表达）建模，业务人员可以直接读懂我们的代码，从而可以知道是否表达了业务需求。 战术设计 (Do Things Right)在战术设计方面，由于业务行为和规则都在领域里，而且系统被拆分成多个子系统，这对技术实现上带来了非常大的挑战，尤其是大部分人都是有牢固的基于数据驱动开发的思想。 技术上有不同实现方式。 Event Sourcing Event Sourcing 就是我们不记录数据的最终状态，我们记录对数据的每一次改变(Event)，而读取的时候我们把这些改变从头再来一遍来取得数据状态，比如你有100块钱，现在剩下10块了，我们记录的不是money.total=10, 而是记录你每一次取钱的记录，然后从100块开始一步步重放你取钱的过程，来得到10. 一开始，我们写的过程中，时常回想起数据驱动的好，（每次开始一个新东西的时候，是不是很熟悉的感觉？)，觉得用Event Sourcing各种麻烦，直到后来随着系统的复杂性不断增加，我们才感觉到带来了非常大的好处, 这个随后单独来说。 CQRS由于使用了 Event Sourcing, 对数据查询，尤其是跨业务(Aggregate)的查询非常麻烦，很难像关系数据那样有查询优势，CQRS是解决这一问题非常好的方法，CQRS让查询和写入分开，把界面需要查询的数据进行原样写入，原样的意思就是界面显示什么样的，就提前保存成什么样的，类似于原来的缓存，没有任何join操作，这样查询是非常高效的。 图片来源：http://vitiy.info/how-to-make-simple-cqrs-implementation-without-event-sourcing/ 演进的领域驱动设计过程战略设计会控制和分解战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性与一致性，进而以演进的方式对之前的战略设计阶段进行迭代，从而形成一种螺旋式上升的迭代设计过程，如下图所示： 面对客户的业务需求，由领域专家与开发团队展开充分的交流，经过需求分析与知识提炼，获得清晰的问题域。通过对问题域进行分析和建模，识别限界上下文，利用它划分相对独立的领域，再通过上下文映射建立它们之间的关系，辅以分层架构与六边形架构划分系统的逻辑边界与物理边界，界定领域与技术之间的界限。之后，进入战术设计阶段，深入到限界上下文内对领域进行建模，并以领域模型指导程序设计与编码实现。若在实现过程中，发现领域模型存在重复、错位或缺失时，再进而对已有模型进行重构，甚至重新划分限界上下文。 两个不同阶段的设计目标是保持一致的，它们是一个连贯的过程，彼此之间又相互指导与规范，并最终保证一个有效的领域模型和一个富有表达力的实现同时演进。 总结 结合自己的学习经过，本篇有意识的避免了繁杂纷乱的「新概念」。如果有兴趣详细了解「DDD」中的那些概念，可以参照这篇文章：http://qinghua.github.io/ddd/ 借大佬的总结来收个尾吧：领域驱动开发好处多多，概念比较多，门槛相对较高，对人员要求较高，团队里至少需要有领路人，不然代价会比较大。 尤其慎用Event Sourcing, 而领域驱动尤其适合业务相对复杂的项目。 对那些很小的项目，CRUD仍然是好的选择。 参考文章 浅谈 MVC、MVP 和 MVVM 架构模式：https://draveness.me/mvx 上善若水的博客：http://deshui.wang/ CRUD工程师晋级之路：https://zhuanlan.zhihu.com/p/25442175 对象和数据库的天然阻抗：https://www.jdon.com/mda/oo-reltaion2.html Commands &amp; Events instead of CRUD — Part 1: Commands：https://hackernoon.com/commands-events-instead-of-crud-part-1-commands-17f4c7aee33b 汤雪华的博客：https://www.cnblogs.com/netfocus/ There is No U in CRUD：http://jlhood.com/there-is-no-u-in-crud/ Event sourcing vs CRUD：https://community.risingstack.com/event-sourcing-vs-crud/ 阿里盒马领域驱动设计实践：https://www.infoq.cn/article/alibaba-freshhema-ddd-practice DDD战略篇：架构设计的响应力：https://zhuanlan.zhihu.com/p/30878497 使用DDD来构建你的REST API，而不是CRUD：http://blog.didispace.com/use-ddd-design-rest-api/ DDD &amp; co., part 1: What’s wrong with CRUD：https://www.thenativeweb.io/blog/2017-10-25-09-46-ddd-and-co-part-1-whats-wrong-with-crud/ DDD的终极大招——By Experience：https://insights.thoughtworks.cn/ddd-by-experience/ 领域驱动设计概览：http://zhangyi.xyz/overview-of-ddd/ Refactoring from anemic model to DDD：https://blog.pragmatists.com/refactoring-from-anemic-model-to-ddd-880d3dd3d45f 为什么DDD是设计微服务的最佳实践：https://www.jianshu.com/p/e1b32a5ee91c 领域驱动设计在互联网业务开发中的实践：https://kb.cnblogs.com/page/586236/ 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"领域驱动设计","slug":"后端/领域驱动设计","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"十四亿人的口腹之欲，是如何被满足的？","slug":"十四亿人的口腹之欲，是如何被满足的？","date":"2019-06-11T02:50:00.000Z","updated":"2020-12-09T04:58:30.480Z","comments":true,"path":"2019/06/11/shi-si-yi-ren-de-kou-fu-zhi-yu-shi-ru-he-bei-man-zu-de/","link":"","permalink":"http://www.wmyskxz.com/2019/06/11/shi-si-yi-ren-de-kou-fu-zhi-yu-shi-ru-he-bei-man-zu-de/","excerpt":"","text":"​​转自公众号“观方翻译” 今天分享一个我逛Quora看到的帖子。有人问了个问题：中国是怎么生产这么多粮食，足够养活十多亿人的？是靠进口还是自给自足？ 剑桥大学博士 Janus Dongye 的回答（和他以前许多回答一样）让人拍案叫绝。 以下为正文： 眼见方为实。打开你的谷歌地球，从天上看看中国大地上到底在发生什么。西方媒体一般不会报道这些东西。 哪些地方值得留意，我会一一指给你看。 包括以下这些坐标点： 地点一：福建宁德港（东经119°57’45.2”，北纬26°43’02.8”） 我们的第一站是福建省的沿海地区。 把地图放大一点，可以看到海面上漂着上百万个房子和网箱 从浙江到广东，这段1000多英里的海岸线上，你几乎到处都可以看到类似的网箱。 那是什么？那是中国的“海鲜农场”。 与其出海捕野生海鲜，不如在同一个地方养海鲜。这样一来花较少的精力就能养出鱼、虾、蟹、龙虾、贝类等，挣的钱还多。 中国农民不只海水养殖，任何开阔的水域，水库、河流、湖泊都能养水产品。 想象一下，每个网箱养几十条鱼或螃蟹，加在一起是多大的规模。 那中国的海鲜消费量是多少呢？ 据估计每年全球海鲜消费总量1.44亿吨，中国是最大的海鲜消费国，以6500万吨占全球总量的45%，接下去是欧盟（1300万吨）、日本（740万吨）、美国（710万吨）和印度（480万吨）。 中国和印度人口差不多，但中国的海鲜消费量是印度的12倍——尽管印度的地理条件更理想，位于渔业资源丰富热带，两面围绕着温暖的海洋。 在中国每年消费的6500万吨海鲜里，只有1500万吨是捕捞的，其余5000万吨都来自水产养殖农场。而日本90%的海鲜都来自捕捞。多亏了海鲜养殖，普通中国百姓可以买到便宜的海鲜，日常三餐可以吃得起海鲜。下面是典型中国家庭的团圆饭，你可以看到很多食材都是海鲜。 这样一桌供全家人享用的海鲜大餐，价格仅在120美元左右。 地点二：浙江湖州南浔（东经120°09’02.9”，北纬30°46’14.5”） 下一站是长江、太湖和钱塘江一带的洪泛平原。丰富的淡水资源带来了河流上游大量的养分，使这个地区成为养育1亿人口的鱼米之乡。这也是中国人口密度最高的地区之一。它比较类似孟加拉国、印度西孟加拉邦和越南西贡的洪泛平原。 与另外那些人口稠密的洪泛平原相比，中国人做了什么不寻常的事呢？ 与种植水稻相比，养殖水产品可以卖出更高的价格，致富更快。拉近一点，你会看到这里有上百万个鱼塘。除了鱼塘，你还可以看到周围种了很多树。 这些树是桑树，是用来养蚕的。两千年来，这片地区的中国人发展出许多高度复杂且可持续的农业生态系统。其中最著名的当属桑基鱼塘，见下图： 在完全不知道“可持续发展”这个概念的情况下，中国农民利用这个鱼-桑-蚕组成的生态系统已经有几千年历史。如今，这个系统发展成对同一片土地的多次循环利用： 但要在鱼塘里养更多鱼，你得有增氧泵才行。它能向水里注入空气，使鱼有足够的氧气维持呼吸。下图中，每个鱼塘中间的白点就是一个增氧泵。 要在每个鱼塘里安装增氧泵，就必须处处通电。怎么向增氧泵供电呢？当然是太阳能电池板。 在地方政府的推动和专家的帮助下，农民和渔民开始学习最先进的太阳能技术和可持续发展技术。 中国地方政府为什么对推广高科技这么上心？因为官员晋升和政绩挂钩。光伏鱼塘完全符合可持续发展的理念，所以有利于地方官员晋升。 从这一点你就可以理解中国为何能生产全球84%的丝绸、66%的淡水鱼，太阳能发电量占全球总量25.8%。在浙江和江苏的农村地区，人们几乎每天都吃鱼。有人说这是他们脑子聪明的秘诀。 另一种生态循环是莲藕和养鱼。 在某些鱼塘里，你可以同时种菜，其中最常见的是种莲藕。中国每年莲藕产量达1100万吨，占全球总产量90%，出口量占全球60%。不光中国人爱吃藕，韩国、日本、越南也是进口莲藕的大户。 藕是我最喜欢的素菜之一，希望中国能加大推广力度，让全世界人民都吃上这种美味。 第三种生态循环是芥菜-蜜蜂-鱼虾。 同样的方法也可以用来种油菜。农民们冬天从河床上把养分含量高的淤泥挖出来堆在岸边，然后在这种泥里种不同的作物，比如油菜或芋头，不用施化肥。经过上千年的耕种，这里的农田是这样的： 地点三：江苏省兴化市垛田镇（东经119°51’50.4”，北纬32°56’51.9”） 这里没有路，你得坐船才能在里面穿行。也正是因为这种生态系统，中国才成为全世界头号菜籽油生产国，产量占全球总量的22%。 有了油菜花，就能大规模养蜂。中国蜂蜜产量占全球30%。 实际上，美国消费的蜂蜜有1/3直接或间接来自中国。为了避免关税，中国蜂蜜出口商先出口到印度、菲律宾和马来西亚，再在当地重新贴标改成当地产品，然后再出口到美国。其他产业也有类似的操作。 除了蜂蜜，这里还是中国著名的大闸蟹产区。大闸蟹的价格可以卖到每公斤60美元左右，只有中等收入人群才吃得起。 地点四：山东省寿光市（东经118°44’14.7”，北纬36°44’15.9”） 接下来要去的是山东平原。 放大一点，我们就能在平原上找到上百万个“闪光”的小屋。看看周围，它们无处不在。 这是什么？原来是控制温度湿度的蔬菜水果大棚。 大棚里，不管什么季节都能做到蔬菜水果一年多熟。这意味着蔬菜水果产量比传统农田高出几倍。 比方说，大棚里种莴笋，从播种到收割需要52天，这样一年可以种七轮，效率高了七倍。 所以，大棚种植在有限空间内极大提高了农作物产量，这对中国人而言简直太棒了。为了推广这种方法，华北地区地方政府要求农民从农村合作银行贷款搭建大棚。 此外，还要求农民在大棚内安装物联网监控系统。通过再教育培训，农民们学会了用手机监控温室内部环境参数，比如二氧化碳浓度、光线强度、土壤温度等等。 联合国粮农组织的数据显示，中国蔬果产量和消费量在7亿吨左右，是世界总量的40%。印度大部分国民是素食者，可耕地面积大于中国，但全国蔬果产量是1.8亿吨，中国是它的3.8倍。秘诀就是大棚种植。 有了大棚蔬菜，中国人享用的蔬菜品种比世界任何地方的人都要多，价格还更便宜。查询维基百科就会发现，除了热带特产以外，中国每一种蔬菜产量几乎都是世界第一，而且跟第二名拉开的差距还不小。许多东亚特有的蔬菜甚至都没有上榜，比如韭菜。 与蔬菜类似，中国除热带水果外的各种水果产量几乎都是世界第一，远超第二名。 有一次我邀请一个黑人朋友来我家夏夜烧烤，拿了很多西瓜招待他，被开玩笑说我种族歧视，我给他看了这张统计表： 在日本，一只西瓜大约卖2000日元（18美元），在中国，买一只更大的瓜只要10块人民币（1.5美元）。中国新疆的西瓜特别甜，如果你喜欢吃西瓜或任何一种瓜果，都应该去一趟哈密。 地点五：西藏拉萨（东经91°09’18.6”，北纬29°41’52.3”） 下面还是大棚，但是是西藏的大棚。把谷歌地球移到西藏任何城镇，都能看到大棚。 政府让藏民在青藏高原上建了很多大棚，藏民们在大棚里种番茄种得不亦乐乎，去寺庙的时间少了，让某个大和尚觉得不高兴了。 结果呢？过去十年西藏蔬菜价格下降90%，不用再从邻省运了。多数西藏人终于吃得起西瓜了。谁不喜欢吃瓜呢？ 历史上多数藏人只吃牦牛肉、奶、乳制品和面食。在那样的恶劣气候条件下什么都种不出来。只有喇嘛才吃得起蔬菜。现在中国政府让大家都吃得上蔬菜水果了。 地点六：新疆伊犁可克达拉（东经80°35’21.5”，北纬43°43’51.2”） 可克达拉是北疆的一个县级市，西边是哈萨克斯坦的阿拉木图地区。下图黄线标出的是中哈边境线。 明显看出，中国一侧的绿色农田更多，哈萨克斯坦一侧基本就是荒原。 其实这里的土地很贫瘠，土壤酸性太高，水资源太少，种不了什么农作物。只能指望雪山上冰川融化时流下来的水。对哈萨克斯坦人来说，这样的种植业成本太高，而且本身市场也不大。所以哈萨克斯坦人决定干脆啥也不种。 中国这一侧呢，所有荒地都被一支特别的政府组织——新疆生产建设兵团给耕种了。现在新疆生产建设兵团成了一个管辖260万员工和农民的国企，里面有汉族人也有维吾尔族人。因为有了如此庞大的规模，边际运营成本下降，而且跟内地广大市场直接对接。 过去30年来，新疆生产建设兵团每年都派农业学生去以色列学习沙漠气候条件下最先进的农业技术。这些学生回到中国后把滴灌法等先进技术付诸实践。当技术条件成熟可以市场应用时，他们把新开垦的土地卖给当地各族农民，或直接请他们加入合作社。 当地的维吾尔族和哈萨克族人为了节约水资源和降低农业成本，接受培训学习汉语和最新的农业技术。每个村都有党员指导他们如何科学耕作。 滴灌法可以大大减少用水量，从而节约成本。在以色列和中国本土技术的帮助下，新疆的荒地成了高产的沃土。 那他们在这些新开辟的土地上种什么呢？ 番茄、辣椒、瓜果、葡萄和棉花。这些作物都比麦子利润高。 新疆有充沛的日照和凉爽的夜晚，这使作物更加甘甜可口，买到内地和国外市场上的价格也就更高。中国消费者喜欢买新疆水果，因为它就是更好吃。 新疆的农业生产效率非常高，高到产量国内市场已经消化不了了。为了不让维吾尔农民吃价格下跌的亏，新疆生产建设兵团不依赖“自由市场”，而是积极开拓海外市场渠道，把农产品高价卖到国外去。 如果国内市场不需要这些农产品呢？ 中国向美国学习，向国际商贸伙伴提要求，让它们买。这就是所谓的国家资本主义。中国领导人去哪个国家，都争取签自贸协议，让它们买中国产品。 不信吗？接下来便是证据。 地点七：新疆巴音郭楞蒙古自治州和静县（东经86°36’15.4”，北纬42°18’36.1”） 沙漠里这些红色的地块是什么呢？ 放大一点，你会看到这些是番茄田，种着无数番茄。这么大的规模，想象一下产量有多高。 你吃意大利面、土耳其烤肉或薯条的时候，可能就在吃新疆番茄。当然，可能不是从新疆直接进口的，而是跟蜂蜜一样，经由第三国转销的。 中国每年番茄产量达5630万吨，出口量占全球1/3。其中1400万吨来自新疆。从全球最大的番茄酱生产商就能看出来：中粮集团（第2）、新疆中基实业（第3）、内蒙富源农产品（第6）、亨氏（第7）、新疆天业（第15）。 这些公司基本都是新疆生产建设兵团和中国政府的分销商，这部分利润多数返还给了新疆农民。最近中国政府还试图通过一带一路把新疆番茄卖到东欧去。2019年3月习近平主席访问意大利，说不定今后意大利也会对新疆番茄感兴趣。这些事西方媒体是不会报道的。 除了番茄和辣椒，中国还是世界最大的葡萄产国，产量占全球19.1%，最好的葡萄来自新疆吐鲁番。当然，酿造葡萄酒的技术确实不怎么样。 最后，聊聊水稻、小麦和玉米等主要作物吧。这是最重要的粮食，因为不只人要吃，还是猪、鸡、牛等产肉产奶的禽类畜类的饲料。 我们来比较一下全球最大的粮食产区吧： 可耕地（千平方公里）：中国1086、印度1579、欧盟1091、美国1631 大米（百万吨）：中国208.1、印度169.5、欧盟3.1、美国9.2 小麦（百万吨）：中国134.3、印度98.5、欧盟150.2、美国47.3 玉米（百万吨）：中国257.3、印度26.0、欧盟60.9、美国366.2 可以看出，中国总体上是最大的粮食生产国。但对14亿人口而言，这个量足够让人“吃得饱”，但离“吃得好”、人均粮食消耗量达到欧美发达国家水平，还有很长的路要走。 目前，中国可耕地面积不足以支持让14亿人都“吃得好”，而且随着工业化和城镇化，可耕地面积还在减少。 地点八：河北省邢台市（东经 114°55’20.8”，北纬 37°35’54.1”） 中国宝贵的土地资源是怎么使用的呢？下一站我们访问华北平原。这是中国大部分农作物的产地。（下图从上到下距离1500公里） 这片平原上随便选个地方，比如四线城市邢台，这是个有700万人的“小”城市。（下图从上到下距离60公里） 这听起来有点吓人，但实际上绿色的是农田，白色的点是村庄，每个村大约500人。比较大的白色区域是镇，人口从1万到10万不等。 可以看出，随着越来越多的人挣了钱，他们开始在原来的农田上盖房子，绿色的田野会越来越少。据估计，中国每年减少的可耕地面积在3000平方公里左右。这些农田变成了白色的混凝土。长期这样下去将造成灾难，因此中国政府在极力控制规管土地使用。但这种“城镇化”的势头巨大，管理起来难度相当高。 地点九：甘肃省庆阳市（东经107°40’38.3”，北纬35°41’00.7”） 从建国之初开始，可耕地资源匮乏的现实一直受到党和国家的高度重视。从毛泽东时代起，中共就组织群众开垦山地。这样的例子太多，就以黄土高原为例吧。 64万平方公里的黄土高原其实不适合种植农作物。但如果你放大看看，就会发现所有山谷、山坡都被开辟成了可耕地。从天上往下看，类似植物根须的地方便是农田。 再靠近一点，你可以看到所有的山丘都被改造成了梯田。 可人们发现，梯田太多会导致土地退化，雨季会发生泥石流等灾难。从1999年开始，中共意识到开辟太多农田不会显著提高产量，却会引发洪水和泥石流等自然灾害，所以发起了“退耕还林”运动。 农民们放弃那些产量低的农田，改在上面植树。放弃土地的农民会得到政府补贴，维持他们原来的收入。 上图可以看出造林的效果。这说明中国政府吸取了过去的经验教训，逐渐理解了可持续发展的的关键。 中国领导人曾经指出，“中国高度重视生态环境保护，秉持绿水青山就是金山银山的理念，倡导人与自然和谐共生，坚持走绿色发展和可持续发展之路。” 这可不是空话，可以说每个字都落到了实处。许多外国人不清楚中国人民为什么支持领导人。其中一个原因就是他重组了中国政府机构，更关注环境了。比如说，如果某个地方环境太差，没有走可持续发展道路，负责环境的官员是可以“弹劾”市长的。 尽管退耕还林工程减少了中国的可耕地面积，尽管存在土地退化现象，但在大规模投资农业技术的帮助下，农业生产效率仍然得到了提升，国内粮食产量仍然在增长。 其中一项技术是耐盐碱水稻，使农民可以在盐碱地里种出水稻来。 尽管国内农作物产量提升，但中国仍然没有实现大米、小麦和玉米的自给自足，大约10%的粮食还是得靠从世界其他地区进口。但其实这部分进口粮食多数不是直接供人食用的。 例一：酿制啤酒和白酒 从2006年起，中国便成为了全球第一大啤酒生产国，每年产量达4654万千升，是美国产量的两倍有余。这个数字还在以每年4.9%的速度增长。除了进口小麦，中国的啤酒花也大部分靠从德国和美国进口。 中国同时也是全球最大的烈酒生产国。多数中国人喝不惯威士忌和伏特加，而比较青睐味道更芬芳浓郁的白酒。中国每年的白酒产量大约在1360万千升左右，比西方人喝的烈酒多得多。这还没有把私人酿的米酒算进去。 所以，中国有些地方的饮酒文化是外界根本不知道的，反正比英国和俄国人能喝。 例二：生猪和猪肉 上图反映出中国人有多喜欢吃猪肉。中国从美国和巴西进口的玉米有一部分被拿来做猪饲料，当然也有的用于鸡、牛等禽类畜类的养殖。 结论 中国可以喂饱中国人，而且不是让人吃米面等主食填饱肚子。中国与大多数发达国家相比，美食品种更多、价格更低。对社会上的穷人来说也是一样。这是我去过欧洲、美国、日本等许多地方之后的感受。 比方说，中国八人一桌吃20个菜，包括各种肉类、蔬菜和甜点，大家毫无宗教顾忌，过敏忌口，也不管什么个人空间。 在山东，这样一桌菜大概要50美元左右。同样一桌菜在北京、上海、台北大概要150美元左右，在加州、日本、香港要300美元左右。这还没有算各种饮料和酒类。实际上，日本和美国加州大多数人基本不会有一次享受20道菜这种奢侈体验，但这在中国再正常不过了。 写了这么长的帖子，希望有助于大家涨知识，中国生产的粮食可远远不止“养活”十几亿口人而已。 谢谢阅读。 （完）","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"你想了解的「SpringCloud」都在这里","slug":"你想了解的「SpringCloud」都在这里","date":"2019-06-09T07:45:00.000Z","updated":"2020-12-09T04:56:24.411Z","comments":true,"path":"2019/06/09/ni-xiang-liao-jie-de-springcloud-du-zai-zhe-li/","link":"","permalink":"http://www.wmyskxz.com/2019/06/09/ni-xiang-liao-jie-de-springcloud-du-zai-zhe-li/","excerpt":"","text":"前言： 之前我们已经了解了「什么是微服务？」，现在我们开始了解「微服务」关键字下比较热门的「Spring Cloud」… 一、传统架构发展史 部分引用自：从架构演进的角度聊聊Spring Cloud都做了些什么？ - 纯洁的微笑 单体架构单体架构在小微企业比较常见，典型代表就是一个应用、一个数据库、一个web容器就可以跑起来。 在两种情况下可能会选择单体架构：一是在企业发展的初期，为了保证快速上线，采用此种方案较为简单灵活；二是传统企业中垂直度较高，访问压力较小的业务。在这种模式下对技术要求较低，方便各层次开发人员接手，也能满足客户需求。 下面是单体架构的架构图： 在单体架构中，技术选型非常灵活，优先满足快速上线的要求，也便于快速跟进市场。 垂直架构在单体架构发展一段时间后，公司的业务模式得到了认可，交易量也慢慢的大起来，这时候有些企业为了应对更大的流量，就会对原有的业务进行拆分，比如说：后台系统、前端系统、交易系统等。 在这一阶段往往会将系统分为不同的层级，每个层级有对应的职责，UI层负责和用户进行交互、业务逻辑层负责具体的业务功能、数据库层负责和上层进行数据交换和存储。 下面是垂直架构的架构图： 服务化架构如果公司进一步的做大，垂直子系统会变的越来越多，系统和系统之间的调用关系呈指数上升的趋势。在这样的背景下，很多公司都会考虑服务的 SOA 化。SOA 代表面向服务的架构，将应用程序根据不同的职责划分为不同的模块，不同的模块直接通过特定的协议和接口进行交互。这样使整个系统切分成很多单个组件服务来完成请求，当流量过大时通过水平扩展相应的组件来支撑，所有的组件通过交互来满足整体的业务需求。 SOA服务化的优点是，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。 服务化架构是一套松耦合的架构，服务的拆分原则是服务内部高内聚，服务之间低耦合。 下面是服务化架构图： 在这个阶段可以使用 WebService 或者 Dubbo 来服务治理。 我们发现从单体架构到服务化架构，应用数量都在不断的增加，慢慢的下沉的就成了基础组建，上浮的就成为业务系统。从上述也可以看出架构的本质就是不断的拆分重构：分的过程是把系统拆分为各个子系统/模块/组件，拆的时候，首先要解决每个组件的定位问题，然后才能划分彼此的边界，实现合理的拆分。合就是根据最终要求，把各个分离的组件有机整合在一起。拆分的结果使开发人员能够做到业务聚焦、技能聚焦，实现开发敏捷，合的结果是系统变得柔性，可以因需而变，实现业务敏捷。 微服务架构微服务是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模组化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API（例如 REST）集相互通讯，且每个服务可以被单独部署，它具备以下三个核心特点： 微服务为大型系统而生。随着业务的快速增长，会带来系统流量压力和复杂度的上升，系统的可维护性和可扩展性成为架构设计的主要考虑因素，微服务架构设计理念通过小而美的业务拆分，通过分而自治来实现复杂系统的优雅设计实现。 微服务架构是面向结果的。微服务架构设计风格的产生并非是出于学术或为标准而标准的设计，而是在软件架构设计领域不断演进过程中，面对实际工业界所遇到问题，而出现的面向解决实际问题的架构设计风格。 专注于服务的可替代性来设计。微服务架构设计风格核心要解决的问题之一便是如何便利地在大型系统中进行系统组件的维护和替换，且不影响整体系统稳定性。 SOA 与 微服务 的不同在于： 服务拆分粒度更细。微服务可以说是更细维度的服务化，小到一个子子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分成一个微服务。 服务独立部署。每个服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码。 服务独立维护。每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。 服务治理能力要求高。因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。 二、引入 Spring Cloud 什么是 Spring Cloud?Spring 全家桶在 Java 开发中拥有举足轻重的地位，其中的一系列产品不仅仅大大简化和方便了 Java 的开发，其中的 AOP 和 IoC 等一系列的理念也深刻地影响着 Java 程序员们。 Spring 全家桶产品众多，总结起来大概就是： Spring 通常指 Spring IOC。 Spring Framework 包含了 Spring IOC，同时包含了 Spring AOP，并实现与其它 J2EE 框架的整合。 Spring Boot 是对 Spring Framework 的补充，让框架的集成变得更简单，致力于快速开发 独立的 Spring 应用。 Spring Cloud 是基于 Spring Boot 设计的一套微服务规范，并增强了应用上下文。 我们也不妨来看看官网的介绍： 总结起来就是： Spring Cloud 是一系列框架的有序集合。我们能够使用基于 Spring Boot 设计的 Spring Cloud 方便快速的搭建起自己的可靠、协调一致的分布式系统。 为什么是 Spring Cloud？微服务的框架那么多比如：Dubbo、Kubernetes，为什么就要使用 Spring Cloud 的呢？ 产出于 Spring 大家族，Spring 在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善。比如 Dubbo 现在就差不多死了 有 Spring Boot 这个独立干将可以省很多事，大大小小的活 Spring Boot 都搞的挺不错。 作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了，方便开发开箱即用。 Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案。 轻轻松松几行代码就完成了熔断、均衡负载、服务中心的各种平台功能。 三、Spring Cloud 能够帮我们做什么？ 前面我们说到了，「Spring Cloud」是一系列框架的集合，可以帮助我们解决分布式/微服务的各种问题，那么「Spring Cloud」究竟能帮助我们做什么呢？ SpringCloud的基础功能包括： 服务治理： Spring Cloud Eureka 客户端负载均衡： Spring Cloud Ribbon 服务容错保护： Spring Cloud Hystrix 声明式服务调用： Spring Cloud Feign API网关服务： Spring Cloud Zuul 分布式配置中心： Spring Cloud Config 当然 Spring Cloud 还包括一些高级的功能： 消息总线： Spring Cloud Bus 消息驱动的微服务： Spring Cloud Stream 分布式服务跟踪： Spring Cloud Sleuth 服务治理：Eureka微服务很重要的一点就是「无状态」，也就是说每一个服务之间应该是独立的，所以当微服务架构搭起来之后各个独立的「微服务」之间应该如何通讯成了首要的问题。 假设我们的 A服务 需要访问 B服务，那么我们首先需要知道对方的 ip地址，所以我们调用起来可能就像： 似乎并没有什么问题，但是如果 B服务 的 ip地址 变更了，那么我们就只能手动的去更改 A服务 的配置，如果我们的服务有很多，并且不止 A服务 调用了 B服务，那么手动更改这些配置将会是一场噩梦。 Eureka 是 Netflix 开源的一款提供服务注册和发现的产品，它提供了完整的 Service Registry 和 Service Discovery 实现。也是 Spring Cloud 体系中最重要最核心的组件之一。 用大白话讲，Eureka 就是一个服务中心，将所有的可以提供的服务都注册到它这里来管理，其它各调用者需要的时候去注册中心获取，然后再进行调用，避免了服务之间的直接调用，方便后续的水平扩展、故障转移等。如下图： 当然服务中心这么重要的组件一但挂掉将会影响全部服务，因此需要搭建 Eureka 集群来保持高可用性，生产中建议最少两台。随着系统的流量不断增加，需要根据情况来扩展某个服务，Eureka 内部已经提供均衡负载的功能，只需要增加相应的服务端实例既可。那么在系统的运行期间某个实例挂了怎么办？Eureka 内容有一个心跳检测机制， 如果某个实例在规定的时间内没有进行通讯则会自动被剔除掉，避免了某个实例挂掉而影响服务。 因此使用了Eureka就自动具有了注册中心、负载均衡、故障转移的功能。如果想对Eureka进一步了解可以参考这篇文章：注册中心Eureka 客户端负载均衡： RibbonRibbon 是一个基于 HTTP 和 TCP 客户端的负载均衡器。Ribbon 可以在通过客户端中配置的 ribbonServerList 服务端列表去轮询访问以达到均衡负载的作用。 当 Ribbon 与 Eureka 联合使用时，ribbonServerList 会被 DiscoveryEnabledNIWSServerList 重写，扩展成从 Eureka 注册中心中获取服务端列表。同时它也会用 NIWSDiscoveryPing 来取代 IPing，它将职责委托给 Eureka 来确定服务端是否已经启动。 实战： Spring Cloud构建微服务架构（二）服务消费者 - http://blog.didispace.com/springcloud2/ 服务容错保护： Hystrix在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。 如下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。 在这种情况下就需要整个服务机构具有故障隔离的功能，避免某一个服务挂掉影响全局。在 Spring Cloud 中 Hystrix 组件就扮演这个角色。 Hystrix 会在某个服务连续调用 N 次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix 间隔时间会再次检查此服务，如果服务恢复将继续提供服务。 继续了解Hystrix可以参考：熔断器Hystrix Hystrix Dashboard 和 Turbine当熔断发生的时候需要迅速的响应来解决问题，避免故障进一步扩散，那么对熔断的监控就变得非常重要。熔断的监控现在有两款工具：Hystrix-dashboard 和 Turbine Hystrix-dashboard 是一款针对Hystrix进行实时监控的工具，通过 Hystrix Dashboard 我们可以直观地看到各 Hystrix Command 的请求响应时间, 请求成功率等数据。但是只使用 Hystrix Dashboard 的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到 Hystrix Dashboard 上, 这个工具就是 Turbine. 监控的效果图如下： 想了解具体都监控了哪些指标，以及如何监控可以参考这篇文章：熔断监控Hystrix Dashboard和Turbine 声明式服务调用：Feign上面我们介绍了 Ribbon 和 Hystrix 了，可以发现：这两个可以作为基础工具类广泛的嵌入到各个微服务中。为了简化我们的开发，Spring Cloud Feign 出现了！它基于 Netflix Feign 实现，整合了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了整合这两者的强大功能之外，它还提供了声明式的服务调用(不再通过RestTemplate)。 Feign 是一种声明式、模板化的HTTP客户端。在 Spring Cloud 中使用 Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。 下面就简单看看Feign是怎么优雅地实现远程调用的： 服务绑定： // value --->指定调用哪个服务 // fallbackFactory--->熔断器的降级提示 @FeignClient(value = \"MICROSERVICECLOUD-DEPT\", fallbackFactory = DeptClientServiceFallbackFactory.class) public interface DeptClientService { // 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！ @RequestMapping(value = \"/dept/get/{id}\", method = RequestMethod.GET) public Dept get(@PathVariable(\"id\") long id); @RequestMapping(value = \"/dept/list\", method = RequestMethod.GET) public List&lt;Dept> list(); @RequestMapping(value = \"/dept/add\", method = RequestMethod.POST) public boolean add(Dept dept); } Feign 中使用熔断器： /** * Feign中使用断路器 * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来) */ @Component // 不要忘记添加，不要忘记添加 public class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService> { @Override public DeptClientService create(Throwable throwable) { return new DeptClientService() { @Override public Dept get(long id) { return new Dept().setDeptno(id).setDname(\"该ID：\" + id + \"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭\") .setDb_source(\"no this database in MySQL\"); } @Override public List&lt;Dept> list() { return null; } @Override public boolean add(Dept dept) { return false; } }; } } 调用： 引用自：外行人都能看懂的 Spring Cloud - https://juejin.im/post/5b83466b6fb9a019b421cecc#heading-12 API 网关服务：Zuul在微服务架构模式下，后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入 API Gateway 作为轻量级网关，同时 API Gateway 中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。 Spring Cloud 体系中支持 API Gateway 落地的技术就是 Zuul。Spring Cloud Zuul 路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul 是 Netflix 出品的一个基于 JVM 路由和服务端的负载均衡器。 它的具体作用就是服务转发，接收并转发所有内外部的客户端调用。使用 Zuul 可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能。 具体使用参考这篇文章：服务网关zuul 分布式配置中心：Config随着业务的不断发展，我们的「微服务」可能会越来越多，而每一个微服务都会有自己的配置文件，在研发过程中有测试环境、UAT环境、生产环境，因此每个微服务又对应至少三个不同环境的配置文件。这么多的配置文件，如果需要修改某个公共服务的配置信息，如：缓存、数据库等，难免会产生混乱，这个时候就需要引入 Spring Cloud 另外一个组件：Spring Cloud Config。 Spring Cloud Config 是一个解决分布式系统的配置管理方案。它包含了 Client 和 Server 两个部分，Server 提供配置文件的存储、以接口的形式将配置文件的内容提供出去，Client 通过接口获取数据、并依据此数据初始化自己的应用。 其实就是 Server 端将所有的配置文件服务化，需要配置文件的服务实例去 Config Server 获取对应的数据。将所有的配置文件统一整理，避免了配置文件碎片化。配置中心git实例参考：配置中心git示例； 如果服务运行期间改变配置文件，服务是不会得到最新的配置信息，需要解决这个问题就需要引入 Refresh。可以在服务的运行期间重新加载配置文件，具体可以参考这篇文章：配置中心svn示例和refresh 当所有的配置文件都存储在配置中心的时候，配置中心就成为了一个非常重要的组件。如果配置中心出现问题将会导致灾难性的后果，因此在生产中建议对配置中心做集群，来支持配置中心高可用性。具体参考：配置中心服务化和高可用 消息总线：Bus上面的 Refresh 方案虽然可以解决单个微服务运行期间重载配置信息的问题，但是在真正的实践生产中，可能会有 N 多的服务需要更新配置，如果每次依靠手动 Refresh 将是一个巨大的工作量，这时候 Spring Cloud 提出了另外一个解决方案：Spring Cloud Bus Spring Cloud Bus 通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其它的消息指令中。Spring Cloud Bus 的一个核心思想是通过分布式的启动器对Spring Boot应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。目前唯一实现的方式是用 AMQP 消息代理作为通道。 Spring Cloud Bus 是轻量级的通讯组件，也可以用在其它类似的场景中。有了 Spring Cloud Bus 之后，当我们改变配置文件提交到版本库中时，会自动的触发对应实例的 Refresh，具体的工作流程如下： 也可以参考这篇文章来了解：配置中心和消息总线 消息驱动的微服务：StreamSpring Cloud Stream 是一个用来为微服务应用构建消息驱动能力的框架。它可以基于 Spring Boot 来创建独立的、可用于生产的 Spring 应用程序。它通过使用 Spring Integration 来连接消息代理中间件以实现消息事件驱动的微服务应用。 下图是官方文档中对于 Spring Cloud Stream 应用模型的结构图。从中我们可以看到，Spring Cloud Stream 构建的应用程序与消息中间件之间是通过绑定器 Binder 相关联的，绑定器对于应用程序而言起到了隔离作用，它使得不同消息中间件的实现细节对应用程序来说是透明的。所以对于每一个 Spring Cloud Stream 的应用程序来说，它不需要知晓消息中间件的通信细节，它只需要知道 Binder 对应用程序提供的概念去实现即可。如下图案例，在应用程序和 Binder 之间定义了两条输入通道和三条输出通道来传递消息，而绑定器则是作为这些通道和消息中间件之间的桥梁进行通信。 Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。简单的说，Spring Cloud Stream 本质上就是整合了 Spring Boot 和 Spring Integration，实现了一套轻量级的消息驱动的微服务框架。通过使用 Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。由于 Spring Cloud Stream 基于 Spring Boot 实现，所以它秉承了 Spring Boot 的优点，实现了自动化配置的功能帮忙我们可以快速的上手使用，但是目前为止 Spring Cloud Stream 只支持 RabbitMQ 和 Kafka 两个著名的消息中间件的自动化配置： 实战：Spring Cloud构建微服务架构：消息驱动的微服务（入门）【Dalston版】 - http://blog.didispace.com/spring-cloud-starter-dalston-7-1/ 分布式服务跟踪：Sleuth随着服务的越来越多，对调用链的分析会越来越复杂，如服务之间的调用关系、某个请求对应的调用链、调用之间消费的时间等，对这些信息进行监控就成为一个问题。在实际的使用中我们需要监控服务和服务之间通讯的各项指标，这些数据将是我们改进系统架构的主要依据。因此分布式的链路跟踪就变的非常重要，Spring Cloud 也给出了具体的解决方案：Spring Cloud Sleuth 和 Zipkin Spring Cloud Sleuth 为服务之间调用提供链路追踪。通过 Sleuth 可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长时间。从而让我们可以很方便的理清各微服务间的调用关系。 Zipkin 是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口 分布式链路跟踪需要 Sleuth + Zipkin 结合来实现，具体操作参考这篇文章：分布式链路跟踪(Sleuth) 总结我们从整体上来看一下Spring Cloud各个组件如何来配套使用： 从上图可以看出 Spring Cloud 各个组件相互配合，合作支持了一套完整的微服务架构。 其中 Eureka 负责服务的注册与发现，很好将各服务连接起来 Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。 Hystrix dashboard,Turbine 负责监控 Hystrix 的熔断情况，并给予图形化的展示 Spring Cloud Config 提供了统一的配置中心服务 当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息 所有对外的请求和服务，我们都通过 Zuul 来进行转发，起到 API 网关的作用 最后我们使用 Sleuth + Zipkin 将所有的请求数据记录下来，方便我们进行后续分析 Spring Cloud 从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利。 微服务架构是一种趋势，Spring Cloud 提供了标准化的、全站式的技术方案，意义可能会堪比当前 Servlet 规范的诞生，有效推进服务端软件系统技术水平的进步。 引用自：从架构演进的角度聊聊Spring Cloud都做了些什么？ - http://www.ityouknow.com/springcloud/2017/11/02/framework-and-springcloud.html 四、Spring Cloud 版本 刚接触的「Spring Cloud」的童鞋可能会对它的版本感到奇怪，什么 Angle、Brixton、Finchley，这些都是啥啊？「为什么会有这么多种看起来不同的 Spring Cloud？」 从上面我们可以知道：Spring Cloud 是一个拥有诸多子项目的大型综合项目（功能不止上面的介绍），原则上其子项目也都维护着自己的发布版本号。那么每一个Spring Cloud的版本都会包含不同的子项目版本，为了要管理每个版本的子项目清单，避免版本名与子项目的发布号混淆，所以没有采用版本号的方式，而是通过命名的方式。 这些版本名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，比如：最早的Release版本：Angel，第二个Release版本：Brixton，以此类推…… 当一个项目到达发布临界点或者解决了一个严重的 BUG 后就会发布一个 “service Release” 版本， 简称 SR（X）版本，x 代表一个递增数字。 引用自：聊聊Spring Cloud版本的那些事儿 - http://blog.didispace.com/springcloud-version/ Spring Cloud &amp; Spring Boot 版本对照表通过查阅官网：https://spring.io/projects/spring-cloud，我们可以看到一个「Release train Spring Boot compatibility」表： Release Train Boot Version Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x 上表可以看出，最新的「Spring Cloud」版本已经出到了 Greenwich… 每个版本都能查阅到当前版本所包含的子项目，以及子项目的版本号，我们可以通过此来决定需要选择怎么样的版本。 参考资料 1. 外行人都能看懂的SpringCloud，错过了血亏！ - https://juejin.im/post/5b83466b6fb9a019b421cecc#heading-192. 从架构演进的角度聊聊Spring Cloud都做了些什么？ - http://www.ityouknow.com/springcloud/2017/11/02/framework-and-springcloud.html3. 聊聊Spring Cloud版本的那些事儿 - http://blog.didispace.com/springcloud-version/4. Spring Cloud 从入门到精通 - http://blog.didispace.com/spring-cloud-learning/5. Spring Cloud 中文网 - https://springcloud.cc/ 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringCloud","slug":"后端/Java/SpringCloud","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringCloud/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"《重构:改善既有代码的设计》读书笔记","slug":"《重构-改善既有代码的设计》读书笔记","date":"2019-06-07T23:37:00.000Z","updated":"2020-12-09T03:20:59.284Z","comments":true,"path":"2019/06/08/chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-du-shu-bi-ji/","link":"","permalink":"http://www.wmyskxz.com/2019/06/08/chong-gou-gai-shan-ji-you-dai-ma-de-she-ji-du-shu-bi-ji/","excerpt":"","text":"前言： 捧读像这一类的书对于自己来说总带着一些神圣感，感谢自己并没有被这么宏大的主题吓退，看完了这里分享输出一下自己的笔记。 一、理解重构 什么是重构？按书中 P45 中的说法，重构这个概念被分成了动词和名词的方面被分别阐述： 重构（名词）： 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 重构（动词）： 使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 在过去的几十年时间里，重构这个词似乎被用来代指任何形式的代码清理，但上面的定义所指的是一种特定的清理代码的方式。重构的关键在于运用大量微小且保持软件行为的步骤，一步一步达成大规模的修改。 每一次的重构要么很小，要么包含了若干个小步骤，即使重构没有完成，也应当可以在任何时刻停下来，所以如果有人说它们的代码在重构过程中有一两天时间不可用，基本上可以确定，他们做的事不是重构。 与性能优化的区别重构与性能优化有很多相似的地方：两者都需要修改代码，并且两者都不会改变程序的整体功能。 两者的差别在于起目的： 重构是为了让代码 “更容易理解，更容易修改”。这可能使程序运行得更快，也可能使程序运行的更慢。 性能优化则只关心程序是否运行的更快。对于最终得到的代码是否容易理解和维护就不知道了。 为什么重构？重构不是包治百病的灵丹妙药，也绝对不是所谓的“银弹”。重构只是一种工具，能够帮助你始终良好的控制代码而已。使用它，可能基于下面的几个目的。 这里有一个有意思的科普（引用自百度百科：没有银弹）：在民俗传说里，所有能让我们充满梦靥的怪物之中，没有比狼人更可怕的了，因为它们会突然地从一般人变身为恐怖的怪兽，因此人们尝试着查找能够奇迹似地将狼人一枪毙命的银弹。我们熟悉的软件项目也有类似的特质（以一个不懂技术的管理者角度来看），平常看似单纯而率直，但很可能一转眼就变成一只时程延误、预算超支、产品充满瑕疵的怪兽，所以，我们听到了绝望的呼唤，渴望有一种银弹，能够有效降低软件开发的成本，就跟电脑硬件成本能快速下降一样。 1. 改进软件的设计当人们只为短期目的而修改代码时，他们经常没有完全理解架构的整体设计。于是代码逐渐失去了自己的结构。程序员越来越难以通过阅读代码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计企图，就越难以保护其设计，于是设计就腐败得越快。 完成同样一件事，设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事情，因此改进设计的一个重要方向就是消除重复代码。消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。 2. 使软件更容易理解所谓程序设计，很大程度上就是与计算机对话：我编写代码告诉计算机做什么，而它的响应是按照我的指示精确行动。一言以蔽之，我所做的就是填补“我想要它做什么”和“我告诉它做什么”之间的缝隙。编程的核心就在于“准确说出我想要的”。 然而别忘了，除计算机之外，源码还有其他读者，并且很大概率还是几个月后的自己，如何更清晰地表达我想要做的，这可能就需要一些重构的手法。 这里我联想到了软件设计的 KISS 原则：KISS 原则，Keep It Simple and Stupid ，简单的理解这句话就是，要把一个系统做的连白痴都会用。 3. 帮助找到 BUG对代码的理解，可以帮助找到系统中存在的一些 BUG。搞清楚程序结构的同时，也可以对自己的假设做一些验证，这样一来 BUG 想不发现都难。 Kent Beck 经常形容自己的一句话是：“我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的的程序员。”重构能够帮助我们更有效地写出健壮的代码。 4. 提高编程速度听起来可能有些反直觉，因为重构可能会花大量的时间改善设计、提高阅读性、修改 BUG，难道不是在降低开发速度嘛？ 软件开发者交谈时的故事：一开始他们进展很快，但如今想要添加一个新功能需要的时间就要长得多。他们需要花越来越多的时间去考虑如何把新功能塞进现有的代码库，不断蹦出来的bug修复起来也越来越慢。代码库看起来就像补丁摞补丁，需要细致的考古工作才能弄明白整个系统是如何工作的。这份负担不断拖慢新增功能的速度，到最后程序员恨不得从头开始重写整个系统。 下面这幅图可以描绘他们经历的困境。 但有些团队的境遇则截然不同。他们添加新功能的速度越来越快，因为他们能利用已有的功能，基于已有的功能快速构建新功能。 两种团队的区别就在于软件的内部质量。需要添加新功能时，内部质量良好的软件让我可以很容易找到在哪里修改、如何修改。良好的模块划分使我只需要理解代码库的一小部分，就可以做出修改。如果代码很清晰，我引入 BUG 的可能性就会变小，即使引入了 BUG，调试也会容易得多。理想情况下，代码库会逐步演化成一个平台，在其上可以很容易地构造与其领域相关的新功能。 这种现象被作者称为“设计耐久性假说”：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。目前还无法科学地证明这个理论，所以说它是一个“假说”。 20年前，行业的陈规认为：良好的设计必须在开始编程之前完成，因为一旦开始编写代码，设计就只会逐渐腐败。重构改变了这个图景。现在我们可以改善已有代码的设计，因此我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生着变化。由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。 什么时候重构？ 三次法则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。 什么时候不应该重构？重构并不是必要，当然也有一些不那么需要重构的情况： 不需要修改，那些丑陋的代码能隐藏在一个 API 之下。 只有当我需要理解其工作原理时，对其进行重构才会有价值； 重写比重构容易。 这可能就需要良好的判断力和丰富的经验才能够进行抉择了。 二、重构的几种姿势 预备性重构：让添加新功能更容易重构的最佳时机就在添加新功能之前。在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。也许已经有个函数提供了我需要的大部分功能，但有几个字面量的值与我的需要略有冲突。如果不做重构，我可能会把整个函数复制过来，修改这几个值，但这就会导致重复代码—如果将来我需要做修改，就必须同时修改两处（更麻烦的是，我得先找到这两处）。而且，如果将来我还需要一个类似又略有不同的功能，就只能再复制粘贴一次，这可不是个好主意。 这就好像我要往东去100公里。我不会往东一头把车开进树林，而是先往北开20公里上高速，然后再向东开100公里。后者的速度比前者要快上3倍。如果有人催着你“赶快直接去那儿”，有时你需要说：“等等，我要先看看地图，找出最快的路径。”这就是预备性重构于我的意义。 ——Jessica Kerr 修复bug时的情况也是一样。在寻找问题根因时，我可能会发现：如果把3段一模一样且都会导致错误的代码合并到一处，问题修复起来会容易得多。或者，如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样bug的概率也会降低。 帮助理解的重构：使代码更易懂我需要先理解代码在做什么，然后才能着手修改。这段代码可能是我写的，也可能是别人写的。一旦我需要思考“这段代码到底在做什么”，我就会自问：能不能重构这段代码，令其一目了然？我可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。 看代码时，我会在脑海里形成一些理解，但我的记性不好，记不住那么多细节。正如 Ward Cunningham 所说，通过重构，我就把脑子里的理解转移到了代码本身。随后我运行这个软件，看它是否正常工作，来检查这些理解是否正确。如果把对代码的理解植入代码中，这份知识会保存得更久，并且我的同事也能看到。 重构带来的帮助不仅发生在将来——常常是立竿见影。是我会先在一些小细节上使用重构来帮助理解，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。当代码变得更清晰一些时，我就会看见之前看不见的设计问题。如果不做前面的重构，我可能永远都看不见这些设计问题，因为我不够聪明，无法在脑海中推演所有这些变化。Ralph Johnson说，这些初步的重构就像扫去窗上的尘埃，使我们得以看到窗外的风景。在研读代码时，重构会引领我获得更高层面的理解，如果只是阅读代码很难有此领悟。有些人以为这些重构只是毫无意义地把玩代码，他们没有意识到，缺少了这些细微的整理，他们就无法看到隐藏在一片混乱背后的机遇。 捡垃圾式重构帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之。这里有一个取舍：我不想从眼下正要完成的任务上跑题太多，但我也不想把垃圾留在原地，给将来的修改增加麻烦。如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。 当然，有时这样的垃圾需要好几个小时才能解决，而我又有更紧急的事要完成。不过即便如此，稍微花一点工夫做一点儿清理，通常都是值得的。正如野营者的老话所说：至少要让营地比你到达时更干净。如果每次经过这段代码时都把它变好一点点，积少成多，垃圾总会被处理干净。重构的妙处就在于，每个小步骤都不会破坏代码——所以，有时一块垃圾在好几个月之后才终于清理干净，但即便每次清理并不完整，代码也不会被破坏。 有计划的重构和见机行事的重构上面的例子——预备性重构、帮助理解的重构、捡垃圾式重构——都是见机行事的：我并不专门安排一段时间来重构，而是在添加功能或修复 BUG 的同时顺便重构。这是我自然的编程流的一部分。不管是要添加功能还是修复 BUG，重构对我当下的任务有帮助，而且让我未来的工作更轻松。这是一件很重要而又常被误解的事：重构不是与编程割裂的行为。你不会专门安排时间重构，正如你不会专门安排时间写 if 语句。我的项目计划上没有专门留给重构的时间，绝大多数重构都在我做其他事的过程中自然发生。 还有一种常见的误解认为，重构就是人们弥补过去的错误或者清理肮脏的代码。当然，如果遇上了肮脏的代码，你必须重构，但漂亮的代码也需要很多重构。在写代码时，我会做出很多权衡取舍：参数化需要做到什么程度？函数之间的边界应该划在哪里？对于昨天的功能完全合理的权衡，在今天要添加新功能时可能就不再合理。好在，当我需要改变这些权衡以反映现实情况的变化时，整洁的代码重构起来会更容易。 长久以来，人们认为编写软件是一个累加的过程：要添加新功能，我们就应该增加新代码。但优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入。所以，软件永远不应该被视为“完成”。每当需要新能力时，软件就应该做出相应的改变。越是在已有代码中，这样的改变就越显重要。 不过，说了这么多，并不表示有计划的重构总是错的。如果团队过去忽视了重构，那么常常会需要专门花一些时间来优化代码库，以便更容易添加新功能。在重构上花一个星期的时间，会在未来几个月里发挥价值。有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来解决。但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。 长期重构大多数重构可以在几分钟—最多几小时—内完成。但有一些大型的重构可能要花上几个星期，例如要替换一个正在使用的库，或者将整块代码抽取到一个组件中并共享给另一支团队使用，再或者要处理一大堆混乱的依赖关系，等等。 即便在这样的情况下，我仍然不愿让一支团队专门做重构。可以让整个团队达成共识，在未来几周时间里逐步解决这个问题，这经常是一个有效的策略。每当有人靠近“重构区”的代码，就把它朝想要改进的方向推动一点。这个策略的好处在于，重构不会破坏代码—每次小改动之后，整个系统仍然照常工作。例如，如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。（这个策略叫作Branch By Abstraction[mf-bba]。） 复审代码时重构至于如何在代码复审的过程中加入重构，这要取决于复审的形式。在常见的pull request模式下，复审者独自浏览代码，代码的作者不在旁边，此时进行重构效果并不好。如果代码的原作者在旁边会好很多，因为作者能提供关于代码的上下文信息，并且充分认同复审者进行修改的意图。对我个人而言，与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审。 三、坏代码长什么样？ 这让我想起之前在捧读《阿里巴巴 Java 开发手册》时学习的代码规范的问题（传送门），只不过当时学习的是好的代码应该长什么样，而现在讨论的事情是：坏的代码长什么样？ 其实大部分的情况应该作为程序员的我们都有一定的共识，所以我觉得简单列一下书中提到的情况就足以说明： 神秘命名 重复代码 过长函数 过长参数列表 全局数据： 全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了一些诡异的 BUG，而问题的根源却在遥远的别处。 可变数据： 对数据的修改经常导致出乎意料的结果和难以发现的 BUG。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据。 发散式变化： 模块经常因为不同的原因在不同的方向上发生变化。 散弹式修改： 每遇到某种变化，你都必须在许多不同的类内做出许多小修改。 依恋情结： 所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流。 数据泥团： 你经常在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。 基本类型偏执： 很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。 重复的 switch： 在不同的地方反复使用相同的 switch 逻辑。问题在于：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新。 循环语句： 我们发现，管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素一级处理它们的动作。 冗余的元素 夸夸其谈通用性： 函数或类的唯一用户是测试用例。 临时字段： 有时你会看到这样的类：其内部某个字段仅为某种特定情况而定。这样的代码让人不理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使用的情况下猜测当初设置它的目的，会让你发疯。 过长的消息链 中间人： 过度运用委托。 内幕交易： 软件开发者喜欢在模块之间筑起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。 过大的类 异曲同工的类 纯数据类： 所谓纯数据类是指：他们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。纯数据类常常意味着行为被放在了错误的地方。也就是说，只要把处理数据的行为从客户端搬移到纯数据类里来，就能使情况大为改观。 被拒绝的遗赠： 拒绝继承超类的实现，我们不介意：但如果拒绝支持超类的接口，这就难以接受了。 注释： 当你感觉需要纂写注释时，请先尝试重构，试着让所有注释都变得多余。 四、重构的一些方法 书中花了大量的章节介绍我们应该如何重构我们的程序，有几个关键的点是我自己能够提炼出来的：找出代码中不合理的地方、结构化、容易理解、测试确保正确。总之围绕这几个点，书中介绍了大量的方法，下面结合自己的一些理解来简单概述一下吧。 结构化代码结构化的代码更加便于我们阅读和理解，例如最常使用的重构方法：提炼函数 动机：把意图和实现分开 void printOwing(double amount) { printBanner(); //print details System.out.println (\"name:\" + _name); System.out.println (\"amount\" + amount); } =&gt; void printOwing(double amount) { printBanner(); printDetails(amount); } void printDetails (double amount) { System.out.println (\"name:\" + _name); System.out.println (\"amount\" + amount); } 更清楚的表达用意要保持软件的 KISS 原则是不容易的，但是也有一些方法可以借鉴，例如：引入解释性变量 动机：用一个良好命名的临时变量来解释对应条件子句的意义，使语义更加清晰。 if ( (platform.toUpperCase().indexOf(\"MAC\") > -1) &amp;&amp; (browser.toUpperCase().indexOf(\"IE\") > -1) &amp;&amp; wasInitialized() &amp;&amp; resize > 0 ) { // do something } =&gt; final boolean isMacOs = platform.toUpperCase().indexOf(\"MAC\") > -1; final boolean isIEBrowser = browser.toUpperCase().indexOf(\"IE\") > -1; final boolean wasResized = resize > 0; if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) { // do something } 另外由于 lambda 表达式的盛行，我们现在有一些更加优雅易读的方法使我们的代码保持可读：以管道取代循环就是这样一种方法。 const names = []; for (const i of input) { if (i.job === \"programer\") names.push(i.name); } =&gt; const names = input .filter(i => i.job === \"programer\") .map(i => i.name) ; 合理的组织结构例如上面介绍的提炼函数的方法，固然是一种很好的方式，但也应该避免过度的封装，如果别人使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托（delegation），造成我在这些委托动作之间晕头转向，并且内部代码和函数名称同样清晰易读，那么就应该考虑内联函数。 动机：①去处不必要的间接性；②可以找出有用的间接层。 int getRating() { return (moreThanFiveLateDeliveries()) ? 2 : 1; } boolean moreThanFiveLateDeliveries() { return _numberOfLateDeliveries > 5; } =&gt; int getRating() { return (_numberOfLateDeliveries > 5) ? 2 : 1; } 合理的封装封装能够帮助我们隐藏细节并且，能够更好的应对变化，当我们发现我们的类太大而不容易理解的时候，可以考虑使用提炼类的方法。 动机：类太大而不容易理解。 class Person { get officeAreaCode() { return this._officeAreaCode; } get officeNumber() { return this._officeNumber; } } =&gt; class Person { get officeAreaCode() { return this._telephoneNumber.areaCode; } get officeNumber() { return this._telephoneNumber.number; } } class TelephoneNumber { get areaCode() { return this._areaCode; } get number() { return this._number; } } 反过来，如果我们发现一个类不再承担足够责任，不再有单独存在的理由的时候，我们会进行反向重构：内敛类 class Person { get officeAreaCode() { return this._telephoneNumber.areaCode; } get officeNumber() { return this._telephoneNumber.number; } } class TelephoneNumber { get areaCode() { return this._areaCode; } get number() { return this._number; } } =&gt; class Person { get officeAreaCode() { return this._officeAreaCode; } get officeNumber() { return this._officeNumber; } } 简化条件表达式分解条件式： 我们能通过提炼代码，把一段 「复杂的条件逻辑」 分解成多个独立的函数，这样就能更加清楚地表达自己的意图。 if (date.before (SUMMER_START) || date.after(SUMMER_END)) charge = quantity * _winterRate + _winterServiceCharge; else charge = quantity * _summerRate; =&gt; if (notSummer(date)) charge = winterCharge(quantity); else charge = summerCharge (quantity); 另外一个比较受用的一条建议就是：以卫语句取代嵌套条件式。根据经验，条件式通常有两种呈现形式。第一种形式是：所有分支都属于正常行为。第二种形式则是：条件式提供的答案中只有一种是正常行为，其他都是不常见的情况。 精髓是：给某一条分支以特别的重视。如果使用 if-then-else 结构，你对 if 分支和 else 分支的重视是同等的。 这样的代码结构传递给阅读者的消息就是：各个分支有同样的重要性。卫语句（guard clauses）就不同了，它告诉阅读者：「这种情况很罕见，如果它真的发生了，请做 一些必要的整理工作，然后退出。」 「每个函数只能有一个入口和一个出口」的观念，根深蒂固于某些程序员的脑海里。 我发现，当我处理他们编写的代码时，我经常需要使用 Replace Nested Conditional with Guard Clauses。现今的编程语言都会强制保证每个函数只有一个入口， 至于「单一出口」规则，其实不是那么有用。在我看来，保持代码清晰才是最关键的：如果「单一出口」能使这个函数更清楚易读，那么就使用单一出口；否则就不必这么做。 double getPayAmount() { double result; if (_isDead) result = deadAmount(); else { if (_isSeparated) result = separatedAmount(); else { if (_isRetired) result = retiredAmount(); else result = normalPayAmount(); }; } return result; }; =&gt; double getPayAmount() { if (_isDead) return deadAmount(); if (_isSeparated) return separatedAmount(); if (_isRetired) return retiredAmount(); return normalPayAmount(); }; 自我测试代码如果认真观察程序员把最多时间耗在哪里，你就会发现，编写代码其实只占非常小的一部分。有些时间用来决定下一步干什么，另一些时间花在设计上面，最多的时间则是用来调试（debug)。每个程序员都能讲出「花一整天（甚至更多）时间只找出一只小小臭虫」的故事。修复错误通常是比较快的，但找出错误却是噩梦一场。当你修好一个错误，总是会有另一个错误出现，而且肯定要很久以后才会注意到它。 彼时你又要花上大把时间去寻找它。 「频繁进行测试」是极限编程（ extreme programming XP）[Beck, XP]的重要一 环。「极限编程」一词容易让人联想起那些编码飞快、自由而散漫的黑客（hackers)， 实际上极限编程者都是十分专注的测试者。他们希望尽可能快速开发软件，而他们也知道「测试」可协助他们尽可能快速地前进。 在重构之前，先保证一组可靠的测试用例（有自我检验的能力），这不仅有助于我们检测 BUG，其中也有一种以终为始的思想在里面，实际上，我们可以通过编写测试用例，更加清楚我们最终的函数应该长什么样子，提供什么样的服务。 结束语 感谢您的耐心阅读，以上就是整个学习的笔记了。 重构不是一个一蹴而就的事，需要长期的实践和经验才能够完成得很好。重构强调的是 Be Better，那在此之前我们首先需要先动起手来搭建我们的系统，而不要一味地“完美主义”，近些时间接触的敏捷式开发也正是这样的一种思想。 如果有兴趣阅读，这里只找到一份第一版可以在线阅读的地方，请自行食用吧：https://www.kancloud.cn/sstd521/refactor/194190 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"什么是微服务？","slug":"什么是微服务？","date":"2019-06-06T23:35:00.000Z","updated":"2020-12-09T04:58:06.369Z","comments":true,"path":"2019/06/07/shi-me-shi-wei-fu-wu/","link":"","permalink":"http://www.wmyskxz.com/2019/06/07/shi-me-shi-wei-fu-wu/","excerpt":"","text":"前言：起初没有意识到自己选了这么一个对自己来说有一些“宏大”的问题，因为里面涉及到好多知识..所以砍了一些内容.. 一、信息技术发展趋势 信息技术发展的三个阶段信息技术从出现到逐渐成为主流，主要经历了软件、开源、云三个阶段的发展。从软件到开源，再到云，这也是信息技术的发展趋势。 1. 软件改变世界纵观人类社会漫长的发展历史，农耕时代、工业时代与信息时代可谓是明显的三个分水岭，每个时代都会出现很多新兴的领域，作为信息时代最重要的载体，互联网越来越成为当今社会关注的焦点，互联网的基石之一——软件，正在迅速地改变着这个世界。 2. 开源改变软件随着软件行业的成熟，相比于“重复造轮子”，“站在巨人的肩膀上”明显可以更加容易和快速地创造出优秀的新产品。随着开源文化越来越被认可，以及社区文化越来越成熟，使用优秀的开源产品作为基础架构来快速搭建系统以实现市场战略，成为当今最优的资源配比方案。 3. 云吞噬开源仅通过开源产品搭建并运维一个高可用、高度弹性化的平台，进而实现互联网近乎100%的可用性，难度可想而知。因此，在提供技术思路的同时，进一步提供整套云解决方案以保证不断扩展的非功能需求，便成了当今新一代互联网平台的追求。 随着用户集群规模的进一步加大，单纯的分布式系统已经难以驾驭，因此技术圈开启了一个概念爆发的时代——SOA、DevOps、容器、CI/CD、微服务、Service Mesh等概念层出不穷，而 Docker、Kubernetes、Mesos、Spring Cloud、Istio 等一系列产品的出现，标志着云时代已真正到来。 互联网架构的核心问题1. 海量用户当今的互联网大潮，已经越来越难以估算用户量以及由此产生的自然数据增长有多少了，区别于我们日常的生活（例如商场，仅有 10 个人和有 1000 人的购物体验是明显不同的），企业如何做到无差别地为全世界所有的用户提供服务，成了一道难题。 2. 产品迅速迭代面对当今快速增长的业务和需求，敏捷开发成为了热门的选择。在不断迭代的过程中，时间成本就显得尤为重要。如何敏捷地探知市场需求并将其实现，是互联网行业的立命之本。产品快速升级必然会推动、测试、交付甚至系统迅速迭代。 3. 7x24 小时不间断服务我们要保证应用全天候不间断的可用，必须要考虑到随时可能发生的意外，例如光缆挖断、机房失火等，每一次宕机都可能会造成巨大的损失。另外，如果系统设计得不够健壮，对其升级和维护时就要停止服务。频繁的系统升级同样会对系统可用性产生很大的影响。 虽然随时随处可用的难度非常大，但互联网应用会尽量缩短宕机时间。通常使用 35 个 9（3 个 9 即 99.9%，4 个 9 即 99.99%，5 个 9 即 99.999%）作为衡量系统可用性的指标，表示系统在 1 年的运行过程中可以正常使用的时间与总运行时间的比值，下面分别计算 35 个 9 指标下的全年宕机时间，感受一下它们的可靠性差异： 3 个 9：（1 - 99.9%） x 365 x 24 = 8.76 小时4 个 9：（1 - 99.99&amp;） x 365 x 24 = 52.6 分钟4 个 9：（1 - 99.999&amp;） x 365 x 24 = 5.26 分钟 4. 流量突增流量突增分为可预期型徒增和不可预期型徒增，像促销活动、有计划的热点事件等引起的流量突增属于前者，可以通过提前扩容、预案演练等方式精心为这些流量突增准备应对方案。而意料之外的热点事件（如地震）往往事发突然，系统来不及准备应对措施，因此若系统本身的可用性、弹性等非功能需求十分成熟，便可以在某种程度上应对这种突增。 5. 业务组合复杂很多互联网公司都是跨界巨头，我们知道，即使不跨界，在单一领域编织一个大规模的成型业务系统也并不简单。 上图是我从 ProcessOn 模板里随便找的一张关于电商平台应用服务的架构图，可以看到里面交织了各种各样的业务，当行业的扩张速度超出预计的增长的时候，对底层支撑的考验要求也越来越高。 二、什么是微服务 需要注意，“微服务”与“微服务架构”有着本质的区别： “微服务”强调的是服务的大小，它关注的是某一个点。而“微服务架构”则是一种架构思想，需要从整体上对软件系统进行通盘的考虑。 架构的演变要了解微服务是如何诞生的，我们有必要对架构的演变过程有一定的了解。上面已经对架构主要面临的问题进行了阐述，下面我们来了解一下架构是如何一步一步升级并转化到“云”上的。 1. 单体架构单体架构比较初级，典型的三级架构，前端(Web/手机端)+中间业务逻辑层+数据库层。这是一种典型的 MVC 框架的应用。 单体架构的应用比较容易部署、测试， 在项目的初期，单体应用可以很好地运行。然而，随着需求的不断增加， 越来越多的人加入开发团队，代码库也在飞速地膨胀。慢慢地，单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高。下面是单体架构应用的一些缺点： 复杂性高： 以一个百万行级别的单体应用为例，整个项目包含的模块非常多、模块的边界模糊、 依赖关系不清晰、 代码质量参差不齐、 混乱地堆砌在一起。可想而知整个项目非常复杂。 每次修改代码都心惊胆战， 甚至添加一个简单的功能， 或者修改一个 Bug 都会带来隐含的缺陷。 技术债务： 随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务， 并且越积 越多。“ 不坏不修”， 这在软件开发中非常常见， 在单体应用中这种思想更甚。 已使用的系统设计或代码难以被修改，因为应用程序中的其他模块可能会以意料之外的方式使用它。 部署频率低： 随着代码的增多，构建和部署的时间也会增加。而在单体应用中， 每次功能的变更或缺陷的修复都会导致需要重新部署整个应用。全量部署的方式耗时长、 影响范围大、 风险高， 这使得单体应用项目上线部署的频率较低。 而部署频率低又导致两次发布之间会有大量的功能变更和缺陷修复，出错率比较高。 可靠性差： 某个应用Bug，例如死循环、内存溢出等， 可能会导致整个应用的崩溃。 扩展能力受限： 单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU； 有的模块则是IO密集型的，需要更大的内存。 由于这些模块部署在一起，不得不在硬件的选择上做出妥协。 阻碍技术创新： 单体应用往往使用统一的技术平台或方案解决所有的问题， 团队中的每个成员 都必须使用相同的开发语言和框架，要想引入新框架或新技术平台会非常困难。 2. 分布式架构中级架构，分布式应用，中间层分布式 + 数据库分布式，是单体架构的并发扩展，将一个大的系统划分为多个业务模块，业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。数据库也大量采用分布式数据库，如 Redis、Elasticsearch、Solor 等。通过 LVS/Nginx 代理应用，将用户请求均衡的负载到不同的服务器上。 该架构相对于单体架构来说，这种架构提供了负载均衡的能力，大大提高了系统负载能力，解决了网站高并发的需求。另外还有以下特点： 降低了耦合度： 把模块拆分,使用接口通信,降低模块之间的耦合度。 责任清晰： 把项目拆分成若干个子项目,不同的团队负责不同的子项目。 扩展方便： 增加功能时只需要再增加一个子项目,调用其他系统的接口就可以。 部署方便： 可以灵活的进行分布式部署。 提高代码的复用性： 比如 service 层，如果不采用分布式 REST 服务方式架构就会在手机 wap 商城，微信商城，PC，Android，IOS 每个端都要写一个 service 层逻辑，开发量大，难以维护一起升级，这时候就可以采用分布式 REST 服务方式，公用一个 service 层。 缺点： 系统之间的交互要使用远程通信,接口开发增大工作量,但是利大于弊。 3. 微服务架构微服务架构，主要是中间层分解，将系统拆分成很多小应用（微服务），微服务可以部署在不同的服务器上，也可以部署在相同的服务器不同的容器上。当应用的故障不会影响到其他应用，单应用的负载也不会影响到其他应用，其代表框架有 Spring cloud、Dubbo 等。 易于开发和维护： 一个微服务只会关注一个特定的业务功能，所以它业务清晰、代码量较少。 开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成的，所以整个应用也会被维持在一个可控状态。 单个微服务启动较快： 单个微服务代码量较少， 所以启动会比较快。 局部修改容易部署： 单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题。 一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。 技术栈不受限： 在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈。例如某些服务可使用关系型数据库MySQL；某些微服务有图形计算的需求，可以使用Neo4j；甚至可根据需要，部分微服务使用Java开发，部分微服务使用Node.js开发。 微服务虽然有很多吸引人的地方，但它并不是免费的午餐，使用它是有代价的。使用微服务架构面临的挑战。 运维要求较高： 更多的服务意味着更多的运维投入。在单体架构中，只需要保证一个应用的正常运行。而在微服务中，需要保证几十甚至几百个服务服务的正常运行与协作，这给运维带来了很大的挑战。 分布式固有的复杂性： 使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。 接口调整成本高： 微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有使用了该接口的微服务都需要做调整。 重复劳动： 很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复。尽管可以使用共享库来解决这个问题（例如可以将这个功能封装成公共组件，需要该功能的微服务引用该组件），但共享库在多语言环境下就不一定行得通了。 4. Serverless 架构当我们还在容器的浪潮中前行时，已经有一些革命先驱悄然布局另外一个云计算战场：Serverless 架构。 Serverless 架构能够让开发者在构建应用的过程中无需关注计算资源的获取和运维，由平台来按需分配计算资源并保证应用执行的SLA（服务等级协议），按照调用次数进行计费，有效的节省应用成本。 由于该架构有一定的超前性，这里不做过多介绍，感兴趣的童鞋可以戳这里：https://jimmysong.io/posts/what-is-serverless/ 微服务定义通过上面简单的介绍，我们了解了我们的架构是如何一步一步过渡到微服务的，为了解决单体应用的诸多问题，我们提出了分布式的概念，通过将单体应用拆分成诸多单独的模块来降低耦合以及提升系统性能，其实这里就涉及到一个服务化的概念，而微服务与之不同的是： 服务拆分粒度更细。微服务可以说是更细维度的服务化，小到一个子子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分成一个微服务。 服务独立部署。每个服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码。 服务独立维护。每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。 服务治理能力要求高。因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。 尽管微服务和微服务架构有所不同，但我们通常也可以简单理解为： 微服务是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模组化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API（例如 REST）集相互通讯，且每个服务可以被单独部署，它具备以下三个核心特点： 微服务为大型系统而生。随着业务的快速增长，会带来系统流量压力和复杂度的上升，系统的可维护性和可扩展性成为架构设计的主要考虑因素，微服务架构设计理念通过小而美的业务拆分，通过分而自治来实现复杂系统的优雅设计实现。 微服务架构是面向结果的。微服务架构设计风格的产生并非是出于学术或为标准而标准的设计，而是在软件架构设计领域不断演进过程中，面对实际工业界所遇到问题，而出现的面向解决实际问题的架构设计风格。 专注于服务的可替代性来设计。微服务架构设计风格核心要解决的问题之一便是如何便利地在大型系统中进行系统组件的维护和替换，且不影响整体系统稳定性。 参考资料 1. 浅谈web网站架构演变过程 - https://www.cnblogs.com/xiaoMzjm/p/5223799.html2. 互联网架构演进之路 - https://zhuanlan.zhihu.com/p/421157573. 四种软件架构演进史 - https://blog.csdn.net/xinyuan_java/article/details/883943324. 《未来架构 从服务化到云原生》 - 张亮 等著 扩展阅读：1.微服务的4个设计原则和19个解决方案 - http://p.primeton.com/articles/59b0f9244be8e61fea00be67 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"微服务","slug":"后端/微服务","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"五子棋先下一定赢？","slug":"五子棋先下一定赢？","date":"2019-06-06T02:35:00.000Z","updated":"2020-12-09T05:00:47.585Z","comments":true,"path":"2019/06/06/wu-zi-qi-xian-xia-yi-ding-ying/","link":"","permalink":"http://www.wmyskxz.com/2019/06/06/wu-zi-qi-xian-xia-yi-ding-ying/","excerpt":"原文地址：https://www.zhihu.com/question/24053236/answer/32848231引用自：知乎 - 五子棋先下的一定赢吗？如何证明？ - @胡天硕","text":"原文地址：https://www.zhihu.com/question/24053236/answer/32848231引用自：知乎 - 五子棋先下的一定赢吗？如何证明？ - @胡天硕 通常大家玩的五子棋分为带禁手和不带禁手两个版本（前者一般称之为五子棋Gomoku，后者称之为连珠Renju），无论哪一个版本，先手黑棋均必胜。 所谓黑必胜的意思是，只要黑棋按照一定的方式下，白棋选择棋盘上的任何一个点都不可能赢棋。 其实在电脑出现之前，五子棋的玩家就发现黑棋采取某些开局赢面的极大，也怀疑有先手必胜的方法。但没有人能够真正“证明”出来白棋无论怎么下都是必败的——这个结论最终还是通关电脑来证明的。 其中不带禁手是 1992 年 Victor Allis 通过编程证明黑必胜的，文章地址在这里： https://project.dke.maastrichtuniversity.nl/games/files/phd/SearchingForSolutions.pdf 禁手规则是只针对黑棋的，简而言之是黑棋只允许使用冲四活三这一种赢法（当然不排除白棋故意冲四不挡这种方法）。设计的目的也是为了限制黑棋的巨大优势，白棋也多了逼禁手这儿一种赢法。但后来人们也逐步发现带禁手后，黑棋依然似乎能不败。直到后来，也有人证明，带禁手执黑也可以必胜。 带禁手的是 2001 是 Janos Wagner 第一次证明黑必胜的，文章地址在这里： http://www.sze.hu/~gtakacs/download/wagnervirag_2001.pdf 这个后面的证明比前面的证明要强很多，因为按照带禁手的走法，不带禁手也一定必胜，但倒过来未必。 这还不说，为了进一步削弱黑棋的优势，国际上推出五手两打（就是黑棋的第三步需要下两个点，但由白棋挑选让其下较弱的哪一个）的规则。可是人们发现黑棋带禁手依然是必胜。也就是说，黑棋必胜不仅仅有一种方法，而是至少有两种以上（来回应各种变种的第四步）。 从实践的角度来讲，网上是可以搜索“地毯谱”（尤其是花月和蒲月都是五手两打必胜），一般在几百兆左右，可以用 renlib 软件打开，所谓地毯谱的意思就是黑棋会指定下法，但白棋每一步都可以选择棋盘任意位置，最后黑棋必胜。也就是说，只要按照此棋谱下棋，五子棋世界冠军都一定会输给你。 所以正式的比赛才会有三手交换五手两打，山口规则（五手 n 打）这些复杂的规则来平衡比赛。但这些规则也是逐渐被人破解，五子棋的比赛已经很大程度不是在考验自己的临场发挥，而是考验选手对于各种开局的记忆情况。 另外针对有人质疑既然五子棋必胜，为什么还要玩： 必胜并不代表去网上黑先开浦月、花月就一定人挡杀人，佛挡杀佛。 必胜的各种分支套路也不是那么容易记住的，诸位可以和 tito2014 或者弈心执黑体验一下（高手绕道）。所以各种对战平台上，就算是在非禁手区拿到胜率远超 50%也不是不可能的。 另外不带禁手的五子棋是属于一类更为普遍的 m,n,k 游戏（m,n,k-game）的一种特例，即 15,15,5。m,n,k 游戏是指 m 行 n 列，轮流下子，连成 k 个算赢。这个在数学中专门有研究如果在最理想下法（Perfect Play）的情况下有什么样不同的结果，比如标准的三连棋（Tic-tac-toe）是 3,3,3 是一个平局，同样只有六路棋盘的五子棋也是平局，当然上面我们已经说明了 15,15,5 是先手必胜。m,n,k 游戏只有先手必胜和平局两种结果。由于每下一个子都一定会对下子一方那一方有优势，所以可以通过反证法证明 m,n,k 游戏里不可能有后手胜利的情况。如果后手有胜利的方法，那么先手可以提前“借鉴”过来实现必胜（Strategy stealing）。 另外除了规定复杂的开局和禁手规则，其实还有一个出路： 除了采取对先手采取各种限制的方法，2003 年被吴毅成教授发明的連六棋(Connect6)也非常类似五子棋，难度很高，但六子棋没有先手优势——因为每一步都下两个子，除了第一步下一个子，这样保证双方每次下棋时，都可以比对方多一个子。AI 目前计算的结果也是，没有发现先手比后手有更大的优势。 既然双方都没有优势，六子棋下满整个（围棋 19x19 棋盘）都没有分出高低都是有可能的。（这个游戏已经不再是 m,n,k 游戏了） 不得不说的是，虽然有个别比赛（gomocup 说你呢）还是在用限定规则的五子棋做 ai 比赛，但是正经的编程奥赛是没有五子棋的比赛（93 年就没了好不好），而被 connect6 这种简约的规则所取代。Connect6 的解决难度几乎与围棋相当。 感兴趣传统五子棋和连珠的 AI 算法的可以参考这个问题：现在的五子棋 AI 在职业比赛规则下与人对决是什么水平？ - 人工智能:https://www.zhihu.com/question/27077916和这个页面（英文）:AI EXP - https://www.aiexp.info/pages/yixin-cn.html","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"了解【Docker】从这里开始","slug":"了解【Docker】从这里开始","date":"2019-05-28T23:33:00.000Z","updated":"2020-12-09T04:54:43.556Z","comments":true,"path":"2019/05/29/liao-jie-docker-cong-zhe-li-kai-shi/","link":"","permalink":"http://www.wmyskxz.com/2019/05/29/liao-jie-docker-cong-zhe-li-kai-shi/","excerpt":"","text":"一、环境配置的难题 软件开发最大的难题之一就是环境配置的问题。现在用户环境纷乱复杂，并且由于开源社区的进一步推广和许多开源项目不停地迭代更新，项目可能会有越来越多的依赖以及越来越难管理的依赖版本，如何保证编写的程序能不只是在“我的电脑上能运行”（It works on my machine）成了一个复杂麻烦的事情。 于是就有人提出：能不能从根本上解决问题，让软件可以自带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。 虚拟机虚拟机（virtual machine）就是一种自带环境安装的解决方案。它可以在一个操作系统里面运行另一个操作系统，比如在 Windows 系统里运行一个 Linux 的操作系统。 应用程序对虚拟机是毫无感知的，因为虚拟机看上去跟真实的操作系统一模一样，而且对于底层的系统来说，虚拟机就是一个普通文件，不需要了就删除，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，该方案有以下的几个缺点： 1. 资源占用多 虚拟机会独占一部分本属于操作系统的内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕你想在虚拟机里面使用的应用程序它实际只会占用 1MB 的内存，虚拟机仍然需要几百 MB 的内存才能运行。 2. 冗余步骤多 虚拟机是完整的操作系统，一些系统层面上的操作步骤，往往无法调过，比如用户登录。 3. 启动慢 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，才能让应用程序真正的运行起来。 Linux 容器由于虚拟机存在上述的这些缺点，Linux 提出了另一种虚拟机化技术：Linux 容器（Linux Containers，缩写 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 1. 启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 2. 资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 3. 体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 二、什么是 Docker？ Enterprise Container Platform for High-Velocity InnovationSecurely build, share and run any application, anywhere 译：企业高速容器平台在任何地方安全的建造、分享、运行你的应用程序 官方对 Docker 的定义是一个容器平台。简单来说，Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。开发人员可以利用 Docker 来消除协作编码时 “在我的电脑上可以正常工作” 的问题。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 为什么要使用 Docker？Docker 是一个为开发者和运维者去开发、发布和在容器中运行应用的平台。使用 Linux 容器来部署应用程序被称为容器化。 容器不是新的概念，它的优势在于很容易发布一个应用。 容器化变得非常的流行，因为容器化具有以下的优点： 灵活：即使最复杂的应用也能够被容器化。 轻量：容器最大化利用和分享主机的内核。 可互换：你可以即时部署更新和升级应用。 便捷：你可以在本地构建应用，并部署到容器云，并在任何地方运行。 可扩展：你可以增加和自动分发容器的个数。 可堆叠：您可以垂直堆叠服务并即时堆叠服务。 容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。 具体说来，Docker 在如下几个方面具有较大的优势。 1. 更快速的交付和部署 对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。 2. 更高效的虚拟化 Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。 3. 更轻松的迁移和扩展 Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。 4. 更简单的管理 使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。 Docker VS VM容器和虚拟机对资源的隔离和分配有相同的优势，但不同的是容器虚拟化操作系统而不是硬件，这使得容器更加的方便和高效。 一个容器是在 Linux 服务本地运行，并和其他的容器共享主机的内核。它运行在一个独立的进程中，相对于其他可执行的进程（比如虚拟机）来说，容器的内存占用空间更小，更加的轻量化。 相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序虚拟访问主机资源。 一般来说，虚拟机提供的环境比大多数应用程序需要的资源更多。 由于 Docker 轻量、资源占用少，使得 Docker 可以轻易的应用到构建标准化的应用中。但 Docker 目前还不够完善，比如隔离效果不如 VM，共享宿主机操作系统的一些基础库等；网络配置功能相对简单，主要以桥接方式为主；查看日志也不够方便灵活。 Docker 的用途Docker 的主要用途，目前有三大类。 1. 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 2. 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 3. 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 三、Docker 基本概念 下面这张图非常的经典，很形象地展示了，什么是容器，什么是镜像，什么是仓库，以及三者之间的联系。 接下来我们来解释一下这张图。现在我们要造一间厨房，在造之前我们首先要干的一件事，就是先列举出我们造厨房需要的东西。我们可能需要一个通了水电煤的房子以及一些必需的厨房用具诸如锅碗瓢勺、煤气灶、冰箱、水槽等等这些东西。现在我们知道需要了什么东西之后，我们就去找这些东西。首先我们先去京东购买一些厨房用具，这些用具就好比我们的Docker镜像，我们厨房的用具到了之后得找个地方把它们放在，不可能随处丢吧，不然后面用的时候就找不到它了，那么我们Docker镜像也是这样，需要一个Docker仓库去存储这些镜像。现在我们有了这些厨房用具之后就可以做饭了吗？答案当然是不能，没水没电没火啊！这时候我们得把厨房用具给装到一个通了水电煤的房子才行，那么Docker镜像也是这样，单纯的Docker镜像是不能用的，它得装到Docker容器中通了水电煤才能使用。等我们装好了厨房用具之后我们就可以开始做饭，那么我们的Docker镜像装到Docker容器之后，我们应用就可以跑起来了。 概念详解Docker是CS架构，主要有两个概念： Docker daemon: 运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互 Docker client: Docker 命令行工具，是用户使用Docker的主要方式，Docker client与Docker daemon通信并将结果返回给用户，Docker client也可以通过socket或者RESTful api访问远程的Docker daemon 了解了Docker的组成，再来了解一下Docker的三个主要概念： Docker image： 镜像是只读的，镜像中包含有需要运行的文件。镜像用来创建container，一个镜像可以运行多个container；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载。 Docker container： 容器是Docker的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。 Docker hub/registry: 共享和管理Docker镜像，用户可以上传或者下载上面的镜像，官方地址为https://registry.hub.docker.com/，也可以搭建自己私有的Docker registry。 镜像就相当于打包好的版本，镜像启动之后运行在容器中，仓库就是装存储镜像的地方。 三、Docker 安装 安装过程都大同小异，这里就不细说了，详细的可以参考这里：https://www.runoob.com/docker/macos-docker-install.html 唯一需要注意的就是由于国内网络问题，需要给 Docker 镜像加个速（详细的可以戳上面链接，最后有…） 四、Docker Hello World 首先，运行下面的命令，将 image 文件从仓库抓取到本地。 $ docker image pull library/hello-world 上面代码中，docker image pull是抓取 image 文件的命令。library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。 $ docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了。 $ docker image ls 现在，运行这个 image 文件 $ docker container run hello-world docker container run 命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。 $ docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. ... ... 输出这段提示以后，hello world 就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。 $ docker container run -it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。 $ docker container kill [containID] 五、常用命令 杀死所有正在运行的容器docker kill $(docker ps -a -q) 删除所有已经停止的容器docker rm $(docker ps -a -q) 删除所有镜像docker rmi $(docker images -q) 关闭容器docker stop CONTAINER ID或者NAMES 重新启动关闭的容器docker start CONTAINER ID或者NAMES 移除本地容器docker rm CONTAINER ID或者NAMES 查看本地容器docker ps //查看正在运行的容器docker ps -a //查看所有容器 查看本地镜像docker images 创建镜像docker build -t name:tag Dockerfile路径 修改本地镜像标记docker tag IMAGE ID name:tagdocker rmi name:tag 删除本地镜像docker rmi name:tag或者IMAGE ID 进入容器docker exec -it IMAGE ID或者NAMES /bin/bash 获取镜像中心的镜像docker pull name:tag 获取容器的端口映射配置docker port CONTAINER ID或者NAMES 参考资料 1. Docker入门教程(阮一峰) - http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html2. Docker(一)：Docker入门教程(纯洁的微笑) - https://www.cnblogs.com/ityouknow/p/8520296.html3. Docker教程(菜鸟教程) - https://www.runoob.com/docker/docker-tutorial.html4. - Docker入门，看这篇就够了 - https://segmentfault.com/a/1190000009544565#articleHeader65. 官方文档 - https://www.docker.com 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Docker","slug":"后端/中间件/Docker","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Docker/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"《Effective-Ruby》读书笔记","slug":"《Effective-Ruby》读书笔记","date":"2019-05-11T23:32:00.000Z","updated":"2020-12-09T03:21:05.346Z","comments":true,"path":"2019/05/12/effective-ruby-du-shu-bi-ji/","link":"","permalink":"http://www.wmyskxz.com/2019/05/12/effective-ruby-du-shu-bi-ji/","excerpt":"","text":"本篇是在我接触了 Ruby 很短一段时间后有幸捧起的一本书，下面结合自己的一些思考，来输出一下自己的读书笔记 前言学习一门新的编程语言通常需要经过两个阶段： 第一个阶段是学习这门编程语言的语法和结构，如果我们具有其他编程语言的经验，那么这个过程通常只需要很短的时间； 第二个阶段是深入语言、学习语言风格，许多编程语言在解决常见的问题时都会使用独特的方法，Ruby 也不例外。 《Effictive Ruby》就是一本致力于让你在第二阶段更加深入和全面的了解 Ruby，编写出更具可读性、可维护性代码的书，下面我就着一些我认为的重点和自己的思考来进行一些精简和说明 第一章：让自己熟悉 Ruby第 1 条：理解 Ruby 中的 True 每一门语言对于布尔类型的值都有自己的处理方式，在 Ruby 中，除了 false 和 nil，其他值都为真值，包括数字 0 值。 如果你需要区分 false 和 nil，可以使用 nil? 的方式或 “==“ 操作符并将 false 作为左操作对象。# 将 false 放在左边意味着 Ruby 会将表达式解析为 FalseClass#== 方法的调用（该方法继承自 Object 类） # 这样我们可以很放心地知道：如果右边的操作对象也是 false 对象，那么返回值为 true if false == x ... end 换句话说，把 false 置为有操作对象是有风险的，可能不同于我们的期望，因为其他类可能覆盖 Object#== 方法从而改变下面这个比较class Bad def == (other) true endend irb&gt; false == Bad.new—&gt; falseirb&gt; Bad.new == false—&gt; true ## 第 2 条：所有对象的值都可能为 nil 在 Ruby 中倡导接口高于类型，也就是说预期要求对象是某个给定类的实例，不如将注意力放在该对象能做什么上。没有什么会阻止你意外地把 Time 类型对象传递给接受 Date 对象的方法，这些类型的问题虽然可以通过测试避免，但仍然有一些多态替换的问题使这些经过测试的应用程序出现问题： ```ruby undefined method &#39;fubar&#39; for nil:NilClass (NoMethodError)当你调用一个对象的方法而其返回值刚好是讨厌的 nil 对象时，这种情况就会发生···nil 是类 NilClass 的唯一对象。这样的错误会悄然逃过测试而仅在生产环境下出现：如果一个用户做了些超乎寻常的事。 另一种导致该结果的情况是，当一个方法返回 nil 并将其作为参数直接传给一个方法时。事实上存在数量惊人的方式可以将 nil 意外地引入你运行中的程序。最好的防范方式是：假设任何对象都可以为 nil，包括方法参数和调用方法的返回值。 # 最简单的方式是使用 nil? 方法 # 如果方法接受者（receiver）是 nil，该方法将返回真值，否则返回假值。 # 以下几行代码是等价的： person.save if person person.save if !person.nil? person.save unless person.nil? # 将变量显式转换成期望的类型常常比时刻担心其为 nil 要容易得多 # 尤其是在一个方法即使是部分输入为 nil 时也应该产生结果的时候 # Object 类定义了几种转换方法，它们能在这种情况下派上用场 # 比如，to_s 方法会将方法接受者转化为 string： irb> 13.to_s ---> \"13\" irb> nil.to_s ---> \"\" # to_s 如此之棒的原因在于 String#to_s 方法只是简单返回 self 而不做任何转换和复制 # 如果一个变量是 string，那么调用 to_s 的开销最小 # 但如果变量期待 string 而恰好得到 nil，to_s 也能帮你扭转局面： def fix_title (title) title.to_s.capitalize end 这里还有一些适用于 nil 的最有用的例子： irb> nil.to_a ---> [] irb> nil.to_i ---> 0 irb> nil.to_f ---> 0.0 当需要同时考虑多个值的时候，你可以使用类 Array 提供的优雅的讨巧方式。Array#compact 方法返回去掉所有 nil 元素的方法接受者的副本。这在将一组可能为 nil 的变量组装成 string 时很常用。比如：如果一个人的名字由 first、middle 和 last 组成（其中任何一个都可能为 nil），那么你可以用下面的代码组成这个名字： name = [first, middle, last].compact.join(\" \") nil 对象的嗜好是在你不经意间偷偷溜进正在运行的程序中。无论它来自用户输入、无约束数据库，还是用 nil 来表示失败的方法，意味着每个变量都可能为 nil。 第 3 条：避免使用 Ruby 中古怪的 Perl 风格语法 推荐使用 String#match 替代 String#=~。前者将匹配信息以 MatchDate 对象返回，而非几个特殊的全局变量。 使用更长、更表意的全局变量的别名，而非其短的、古怪的名字（比如，用 $LOAD_PATH 替代 $: ）。大多数长的名字需要在加载库 English 之后才能使用。 避免使用隐式读写全局变量 $_ 的方法（比如，Kernel#print、Regexp#~ 等） # 这段代码中有两个 Perl 语法。 # 第一个：使用 String#=~ 方法 # 第二个：在上述代码中看起来好像是使用了一个全局变量 $1 导出第一个匹配组的内容，但其实不是... def extract_error (message) if message =~ /^ERROR:\\s+(.+)$/ $1 else \"no error\" end end # 以下是替代方法： def extract_error (message) if m = message.match(/^ERROR:\\s+(.+)$/) m[1] else \"no error\" end end 第 4 条：留神，常量是可变的最开始接触 Ruby 时，对于常量的认识大概可能就是由大写字母加下划线组成的标识符，例如 STDIN、RUBY_VERSION。不过这并不是故事的全部，事实上，由大写字母开头的任何标识符都是常量，包括 String 或 Array，来看看这个： module Defaults NOTWORKS = [\"192.168.1\",\"192.168.2\"] end def purge_unreachable (networks=Defaults::NETWORKS) networks.delete_if do |net| !ping(net + \".1\") end end 如果调用方法 unreadchable 时没有加参数的话，会意外的改变一个常量的值。在 Ruby 中这样做甚至都不会警告你。好在有一种解决这个问题的方法——freeze 方法： module Defaults NOTWORKS = [\"192.168.1\",\"192.168.2\"].freeze end 加入你再想改变常量 NETWORKS 的值，purge_unreadchable 方法就会引入 RuntimeError 异常。根据一般的经验，总是通过冻结常量来阻止其被改变，然而不幸的是，冻结 NETWORKS 数组还不够，来看看这个： def host_addresses (host, networks=Defaults::NETWORKS) networks.map {|net| net &lt;&lt; \".#{host}\"} end 如果第二个参数没有赋值，那么 host_addresses 方法会修改数组 NETWORKS 的元素。即使数组 NETWORKS 自身被冻结，但是元素仍然是可变的，你可能无法从数组中增删元素，但你一定可以对存在的元素加以修改。因此，如果一个常量引用了一个集合，比如数组或者是散列，那么请冻结这个集合以及其中的元素： module Defaults NETWORKS = [ \"192.168.1\", \"192.168.2\" ].map(&amp;:freeze).freeze end 甚至，要达到防止常量被重新赋值的目的，我们可以冻结定义它的那个模块： module Defaults TIMEOUT = 5 end Defaults.freeze 第 5 条：留意运行时警告 使用命令行选项 ”-w“ 来运行 Ruby 解释器以启用编译时和运行时的警告。设置环境变量 RUBYOPT 为 ”-w“ 也可以达到相同目的。 如果必须禁用运行时的警告，可以临时将全局变量 $VERBOSE 设置为 nil。 # test.rb def add (x, y) z = 1 x + y end puts add 1, 2 # 使用不带 -w 参数的命令行 irb> ruby test.rb ---> 3 # 使用带 -w 参数的命令行 irb&lt; ruby -w test.rb ---> test.rb:1: warning: parentheses after method name is interpreted as an argument list, not a decomposed argument ---> test.rb:2: warning: assigned but unused variable - z ---> 3 第二章：类、对象和模块第 6 条：了解 Ruby 如何构建集成体系让我们直接从代码入手吧： class Person def name ... end end class Customer &lt; Person ... end irb> customer = Customer.new ---> #&lt;Customer> irb> customer.superclass ---> Person irb> customer.respond_to?(:name) ---> true 上面的代码几乎就和你预想的那样，当调用 customer 对象的 name 方法时，Customer 类会首先检查自身是否有这个实例方法，没有那么就继续搜索。 顺着集成体系向上找到了 Person 类，在该类中找到了该方法并将其执行。（如果 Person 类中没有找到的话，Ruby 会继续向上直到到达 BasicObject） 但是如果方法在查找过程中直到类树的根节点仍然没有找到匹配的办法，那么它将重新从起点开始查找，不过这一次会查找 method_missing 方法。 下面我们开始让事情变得更加有趣一点： module ThingsWithNames def name ... end end class Person include(ThingsWithNames) end irb> Person.superclass ---> Object irb> customer = Customer.new ---> #&lt;Customer> irb> customer.respond_to?(:name) ---> true 这里把 name 方法从 Person 类中取出并移到一个模块中，然后把模块引入到了 Person 类。Customer 类的实例仍然可以如你所料响应 name 方法，但是为什么呢？显然，模块 ThingsWithNames 并不在集成体系中，因为 Person 类的超类仍然是 Object 类，那会是什么呢？其实，Ruby 在这里对你撒谎了！当你 include 方法来将模块引入类时，Ruby 在幕后悄悄地做了一些事情。它创建了一个单例类并将它插入类体系中。这个匿名的不可见类被链向这个模块，因此它们共享了实力方法和常量。 当每个模块被类包含时，它会立即被插入集成体系中包含它的类的上方，以后进先出（LIFO）的方式。每个对象都通过变量 superclass 链接，像单链表一样。这唯一的结果就是，当 Ruby 寻找一个方法时，它将以逆序访问访问每个模块，最后包含的模块最先访问到。很重要的一点是，模块永远不会重载类中的方法，因为模块插入的位置是包含它的类的上方，而 Ruby 总是会在向上检查之前先检查类本身。（好吧······这不是全部的事实。确保你阅读了第 35 条，来看看 Ruby 2.0 中的 prepend 方法是如何使其复杂化的） 要点回顾： 要寻找一个方法，Ruby 只需要向上搜索类体系。如果没有找到这个方法，就从起点开始搜搜 method_missing 方法。 包含模块时 Ruby 会悄悄地创建单例类，并将其插入在继承体系中包含它的类的上方。 单例方法（类方法和针对对象的方法）存储于单例类中，它也会被插入继承体系中。 第 7 条：了解 super 的不同行为 当你想重载继承体系中的一个方法时，关键字 super 可以帮你调用它。 不加括号地无参调用 super 等价于将宿主方法的素有参数传递给要调用的方法。 如果希望使用 super 并且不向重载方法传递任何参数，必须使用空括号，即 super()。 当 super 调用失败时，自定义的 method_missing 方法将丢弃一些有用的信息。在第 30 条中有 method_missing 的替代解决方案。 第 8 条：初始化子类时调用 super 当创建子类对象时，Ruby 不会自动调用超类中的 initialize 方法。作为替代，常规的方法查询规则也适用于 initialize 方法，只有第一个匹配的副本会被调用。 当为显式使用继承的类定义 initialize 方法时，使用 super 来初始化其父类。在定义 initialize_copy 方法时，应使用相同的规则 class Parent def initialize (name) @name = name end end class Child &lt; Parent def initialize (grade) @grade = grade end end # 你能看到上面的窘境，Ruby 没有提供给子类和其超类的 initialize 方法建立联系的方式 # 我们可以使用通用意义上的 super 关键字来完成继承体系中位于高层的办法： class Child &lt; Parent def initialize (name, grade) super(name) # Initialize Parent. @grade = grade end end 第 9 条：提防 Ruby 最棘手的解析这是一条关于 Ruby 可能会戏弄你的另一条提醒，要点在于：Ruby 在对变量赋值和对 setter 方法调用时的解析是有区别的！直接看代码吧： # 这里把 initialize 方法体中的内容当做第 counter= 方法的调用也不是毫无道理 # 事实上 initialize 方法会创建一个新的局部变量 counter，并将其赋值为 0 # 这是因为 Ruby 在调用 setter 方法时要求存在一个显式接受者 class Counter attr_accessor(:counter) def initialize counter = 0 end ... end # 你需要使用 self 充当这个接受者 class Counter attr_accessor(:counter) def initialize self.counter = 0 end ... end # 而在你调用非 setter 方法时，不需要显式指定接受者 # 换句话说，不要使用不必要的 self，那会弄乱你的代码： class Name attr_accessor(:first, :last) def initialize (first, last) self.first = first self.last = last end def full self.first + \" \" + self.last # 这里没有调用 setter 方法使用 self 多余了 end end # 就像上面 full 方法里的注释，应该把方法体内的内容改为 first + \" \" + last 第 10 条：推荐使用 Struct 而非 Hash 存储结构化数据看代码吧： # 假设你要对一个保存了年度天气数据的 CSV 文件进行解析并存储 # 在 initialize 方法后，你会获得一个固定格式的哈希数组，但是存在以下的问题： # 1.不能通过 getter 方法访问其属性，也不应该将这个哈希数组通过公共接口向外暴露，因为其中包含了实现细节 # 2.每次你想在类内部使用该哈希时，你不得不回头来看 initialize 方法 # 因为你不知道CSV具体的对应是怎样的，而且当类成熟情况可能还会发生变化 require('csv') class AnnualWeather def initialize (file_name) @readings = [] CSV.foreach(file_name, headers: true) do |row| @readings &lt;&lt; { :date => Date.parse(row[2]), :high => row[10].to_f, :low => row[11].to_f, } end end end # 使用 Struct::new 方法的返回值赋给一个常量并利用它创建对象的实践： class AnnualWeather # Create a new struct to hold reading data. Reading = Struct.new(:date, :high, :low) def initialize (file_name) @readings = [] CSV.foreach(file_name, headers: true) do |row| @readings &lt;&lt; Reading.new(Date.parse(row[2]), row[10].to_f, row[11].to_f) end end end # Struct 类本身比你第一次使用时更加强大。除了属性列表，Struct::new 方法还能接受一个可选的块 # 也就是说，我们能在块中定义实例方法和类方法。比如，我们定义一个返回平均每月平均温度的 mean 方法： Reading = Struct.new(:date, :high, :low) do def mean (high + low) / 2.0 end end 另外从其他地方看到了关于 Struct::new 的实践 考虑使用 Struct.new, 它可以定义一些琐碎的 accessors, constructor（构造函数） 和 comparison（比较） 操作。 # good class Person attr_reader :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end end betterclass Person &lt; Struct.new(:first_name, :last_name)end - 考虑使用 Struct.new，它替你定义了那些琐碎的存取器（accessors），构造器（constructor）以及比较操作符（comparison operators）。 ```ruby # good class Person attr_accessor :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end end # better Person = Struct.new(:first_name, :last_name) do end 要去 extend 一个 Struct.new - 它已经是一个新的 class。扩展它会产生一个多余的 class 层级 并且可能会产生怪异的错误如果文件被加载多次。 第 11 条：通过在模块中嵌入代码来创建命名空间 通过在模块中嵌入代码来创建命名空间 让你的命名空间结构和目录结构相同 如果使用时可能出现歧义，可使用 ”::” 来限定顶级常量（比如，::Array） 第 12 条：理解等价的不同用法看看下面的 IRB 回话然后自问一下：为什么方法 equal? 的返回值和操作符 “==” 的不同呢？ irb> \"foo\" == \"foo\" ---> true irb> \"foo\".equal?(\"foo\") ---> false 事实上，在 Ruby 中有四种方式来检查对象之间的等价性，下面来简单总个结吧： 绝不要重载 equal? 方法。该方法的预期行为是，严格比较两个对象，仅当它们同时指向内存中同一对象时其值为真（即，当它们具有相同的 object_id 时） Hash 类在冲突检查时使用 eql? 方法来比较键对象。默认实现可能和你的想像不同。遵循第 13 条建议之后再使用别名 eql? 来替代 “==” 书写更合理的 hash 方法 使用 “==” 操作符来测试两个对象是否表示相同的值。有些类比如表示数字的类会有一个粗糙的等号操作符进行类型转换 case 表达式使用 “===“ 操作符来测试每个 when 语句的值。左操作数是 when 的参数，右操作数是 case 的参数 第 13 条：通过 “&lt;=&gt;” 操作符实现比较和比较模块要记住在 Ruby 语言中，二元操作符最终会被转换成方法调用的形式，左操作数对应着方法的接受者，右操作数对应着方法第一个也是唯一的那个参数。 通过定义 “&lt;=&gt;” 操作符和引入 Comparable 模块实现对象的排序 如果左操作数不能与右操作数进行比较，”&lt;=&gt;” 操作符应该返回 nil 如果要实现类的 “&lt;=&gt;” 运算符，应该考虑将 eql? 方法设置为 “==” 操作符的别名，特别是当你希望该类的所有实例可以被用来作为哈希键的时候，就应该重载哈希方法 第 14 条：通过 protected 方法共享私有状态 通过 protected 方法共享私有状态 一个对象的 protected 方法若要被显式接受者调用，除非该对象与接受者是同类对象或其具有相同的定义该 protected 方法的超类 # Ruby 语言中，私有方法的行为和其他面向对象的编程语言中不太相同。Ruby 语言仅仅在私有方法上加了一条限制————它们不能被显式接受者调用 # 无论你在继承关系中的哪一级，只要你没有使用接受者，你都可以调用祖先方法中的私有方法，但是你不能调用另一个对象的私有方法 # 考虑下面的例子： # 方法 Widget#overlapping? 会检测其本身是否和另一个对象在屏幕上重合 # Widget 类的公共接口并没有将屏幕坐标对外暴露，它们的具体实现都隐藏在了内部 class Widget def overlapping? (other) x1, y1 = @screen_x, @screen_y x2, y2 = other.instance_eval {[@screen_x, @screen_y]} ... end end # 可以定义一个暴露私有屏幕坐标的方法，但并不通过公共接口来实现，其实现方式是声明该方法为 protected # 这样我们既保持了原有的封装性，也使得 overlapping? 方法可以访问其自身以及其他传入的 widget 实例的坐标 # 这正式设计 protected 方法的原因————在相关类之间共享私有信息 class Widget def overlapping? (other) x1, y1 = @screen_x, @screen_y x2, y2 = other.screen_coordinates ... end protected def screen_coordinates [@screen_x, @screen_y] end end 第 15 条：优先使用实例变量而非类变量 优先使用实例变量(@)而非类变量(@@) 类也是对象，所以它们拥有自己的私有实例变量集合 第三章：集合第 16 条：在改变作为参数的集合之前复制它们在 Ruby 中多数对象都是通过引用而不是通过实际值来传递的，当将这种类型的对象插入容器时，集合类实际存储着该对象的引用而不是对象本身。（值得注意的是，这条准则是个例如：Fixnum 类的对象在传递时总是通过值而不是引用传递） 这也就意味着当你把集合作为参数传入某个方法并进行修改时，原始集合也会因此被修改，有点间接，不过很容易看到这种情况的发生。 Ruby 语言自带了两个用来复制对象的方法：dup 和 clone。 它们都会基于接收者创建新的对象，但是与 dup 方法不同的是，clone 方法会保留原始对象的两个附加特性。 首先，clone 方法会保留接受者的冻结状态。如果原始对象的状态是冻结的，那么生成的副本也会是冻结的。而 dup 方法就不同了，它永远不会返回冻结的对象。 其次，如果接受这种存在单例方法，使用 clone 也会复制单例类。由于 dup 方法不会这样做，所以当使用 dup 方法时，原始对象和使用 dup 方法创建的副本对于相同消息的响应可能是不同的。 # 也可以使用 Marshal 类将一个集合及其所持有的元素序列化，然后再反序列化： irb> a = [\"Monkey\", \"Brains\"] irb> b = Marshal.load(Marshal.dump(a)) irb> b.each(&amp;:upcasel); b.first ---> \"MONKEY\" irb> a.last ---> \"Brains\" 第 17 条：使用 Array 方法将 nil 及标量对象转换成数组 使用 Array 方法将 nil 及标量对象转换成数组 不要将哈希传给 Array 方法，它会被转化成一个嵌套数组的集合 # 考虑下面这样一个订披萨的类： class Pizza def initialize (toppings) toppings.each do |topping| add_and_price_topping(topping) end end end # 上面的 initialize 方法期待的是一个 toppings 数组，但我们能传入单个 topping，甚至是在没有 topping 对象的时候直接传入 nil # 你可能会想到使用可变长度参数列表来实现它，并将参数类型改为 *topping，这样会把所有的参数整合成一个数组。 # 尽管这样做可以让我们传入单个 topping 对象，担当传入一组对象给 initialize 方法的时候必须使用 \"*\" 显式将其拓展成一个数组。 # 所以这样做仅仅是拆东墙补西墙罢了，一个更好的解决方式是将传入的参数转换成一个数组，这样我们就明确地知道我要做的是什么了 # 先对 Array() 做一些探索： irb> Array('Betelgeuse') ---> [\"Betelgeuse\"] irb> Array(nil) ---> [] irb> Array(['Nadroj', 'Retep']) ---> [\"Nadroj\", \"Retep\"] irb> h = {pepperoni: 20,jalapenos: 2} irb> Array(h) ---> [[:pepperoni, 20], [:jalapenos, 2]] # 如果你想处理一组哈希最好采用第 10 条的建议那样 # 回答订披萨的问题上： # 经过一番改造，它现在能够接受 topping 数组、单个 topping，或者没有 topping(nil or []) class Pizza def initialize (toppings) Array(toppings).each do |topping| add_and_price_topping(topping) end end ... end 第 18 条：考虑使用集合高效检查元素的包含性（书上对于这一条建议的描述足足有 4 页半，但其实可以看下面结论就ok，结尾有实例代码） 考虑使用 Set 来高效地检测元素的包含性 插入 Set 的对象必须也被当做哈希的键来用 使用 Set 之前要引入它 # 原始版本 class Role def initialize (name, permissions) @name, @permissions = name, permissions end def can? (permission) @permissions.include?(permission) end end # 版本1.0：使用 Hash 替代 Array 的 Role 类： # 这样做基于两处权衡，首先，因为哈希只存储的键，所以数组中的任何重复在转换成哈希的过程中都会丢失。 # 其次，为了能够将数组转换成哈希，需要将整个数组映射，构建出一个更大的数组，从而转化为哈希。这将性能问题从 can? 方法转移到了 initialize 方法 class Role def initialize (name, permissions) @name = name @permissions = Hash[permissions.map {|p| [p, ture]}] end def can? (permission) @permissions.include?(permission) end end # 版本2.0：引入 Set： # 性能几乎和上一个哈希版本的一样 require('set') class Role def initialize (name, permissions) @name, @permissions = name, Set.new(permissions) end def can? (permission) @permissions.include?(permission) end end # 最终的例子 # 这个版本自动保证了集合中没有重复的记录，且重复条目是很快就能被检测到的 require('set') require('csv') class AnnualWeather Reading = Struct.new(:date, :high, :low) do def eql? (other) date.eql?(other.date); end def hash; date.hash; end end def initialize (file_name) @readings = Set.new CSV.foreach(file_name, headers: true) do |row| @readings &lt;&lt; Reading.new(Date.parse(row[2]), row[10].to_f, row[11].to_f) end end end 第 19 条：了解如何通过 reduce 方法折叠集合尽管可能有点云里雾里，但还是考虑考虑先食用代码吧： # reduce 方法的参数是累加器的起始值，块的目的是创建并返回一个适用于下一次块迭代的累加器 # 如果原始集合为空，那么块永远也不会被执行，reduce 方法仅仅是简单地返回累加器的初始值 # 要注意块并没有做任何赋值。这是因为在每个迭代后，reduce 丢弃上次迭代的累加器并保留了块的返回值作为新的累加器 def sum (enum) enum.reduce(0) do |accumulator, element| accumulator + element end end # 另一个快捷操作方式对处理块本身很方便：可以给 reduce 传递一个符号（symbol）而不是块。 # 每个迭代 reduce 都使用符号作为消息名称发送消息给累加器，同时将当前元素作为参数 def sum (enum) enum.reduce(0, :+) end # 考虑一下把一个数组的值全部转换为哈希的键，而它们的值都是 true 的情况： Hash[array.map {|x| [x, true]}] # reduce 可能会提供更加完美的方案（注意此时 reduce 的起始值为一个空的哈希）： array.reduce({}) do |hash, element| hash.update(element => true) end # 再考虑一个场景：我们需要从一个存储用户的数组中筛选出那些年龄大于或等于 21 岁的人群，之后我们希望将这个用户数组转换成一个姓名数组 # 在没有 reduce 的时候，你可能会这样写： users.select {|u| u.age >= 21}.map(&amp;:name) # 上面这样做当然可以，但并不高效，原因在于我们使用上面的语句时对数组进行了多次遍历 # 第一次是通过 select 筛选出了年龄大于或等于 21 岁的人，第二次则还需要映射成只包含名字的新数组 # 如果我们使用 reduce 则无需创建或遍历多个数组： users.reduce([]) do |names, user| names &lt;&lt; user.name if user.age >= 21 names end 引入 Enumerable 模块的类会得到很多有用的实例方法，它们可用于对对象的集合进行过滤、遍历和转化。其中最为常用的应该是 map 和 select 方法，这些方法是如此强大以至于在几乎所有的 Ruby 程序中你都能见到它们的影子。 像数组和哈希这样的集合类几乎已经是每个 Ruby 程序不可或缺的了，如果你还不熟悉 Enumberable 模块中定义的方法，你可能已经自己写了相当多的 Enumberable 模块已经具备的方法，知识你还不知道而已。 Enumberable 模块 戳开 Array 的源码你能看到 include Enumberable 的字样（引入的类必须实现 each 方法不然报错），我们来简单阐述一下 Enumberable API： irb> [1, 2, 3].map {|n| n + 1} ---> [2, 3, 4] irb> %w[a l p h a b e t].sort ---> [\"a\", \"a\", \"b\", \"e\", \"h\", \"l\", \"p\", \"t\"] irb> [21, 42, 84].first ---> 21 上面的代码中： 首先，我们使用了流行的 map 方法遍历每个元素，并将每个元素 +1 处理，然后返回新的数组； 其次，我们使用了 sort 方法对数组的元素进行排序，排序采用了 ASCII 字母排序 最后，我们使用了查找方法 select 返回数组的第一个元素 reduce 方法到底干了什么？它为什么这么特别？在函数式编程的范畴中，它是一个可以将一个数据结构转换成另一种结构的折叠函数。 让我们先从宏观的角度来看折叠函数，当使用如 reduce 这样的折叠函数时你需要了解如下三部分： 枚举的对象是 reduce 消息的接受者。某种程度上这是你想转换的原始集合。显然，它的类必须引入 Enumberable 模块，否则你无法对它调用 reduce 方法； 块会被源集合中的每个元素调用一次，和 each 方法调用块的方式类似。但和 each 不同的是，传入 reduce 方法的块必须产生一个返回值。这个返回值代表了通过当前元素最终折叠生成的数据结构。我们将会通过一些例子来巩固这一知识点。 一个代表了目标数据结构起始值的对象，被称为累加器。每一次块的调用都会接受当前的累加器值并返回新的累加器值。在所有元素都被折叠进累加器后，它的最终结构也就是 reduce 的返回值。 此时了解了这三部分你可以回头再去看一看代码。 试着回想一下上一次使用 each 的场景，reduce 能够帮助你改善类似下面这样的模式： hash = {} array.each do |element| hash[element] = true end 第 20 条：考虑使用默认哈希值我确定你是一个曾经在块的语法上徘徊许久的 Ruby 程序员，那么请告诉我，下面这样的模式在代码中出现的频率是多少？ def frequency (array) array.reduce({}) do |hash, element| hash[element] ||= 0 # Make sure the key exists. hash[element] += 1 # Then increment it. hash # Return the hash to reduce. end end 这里特地使用了 “||=” 操作符以确保在修改哈希的值时它是被赋过值的。这样做的目的其实也就是确保哈希能有一个默认值，我们可以有更好的替代方案： def frequency (array) array.reduce(Hash.new(0)) do |hash, element| hash[element] += 1 # Then increment it. hash # Return the hash to reduce. end end 看上去还真是那么一回事儿，但是小心，这里埋藏着一个隐蔽的关于哈希的陷阱。 # 先来看一下这个 IRB 会话： irb> h = Hash.new(42) irb> h[:missing_key] ---> 42、 irb> h.keys # Hash is still empty! ---> [] irb> h[:missing_key] += 1 ---> 43 irb> h.keys # Ah, there you are. ---> [:missing_key] # 注意，当访问不存在的键时会返回默认值，但这不会修改哈希对象。 # 使用 \"+=\" 操作符的确会像你想象中那般更新哈希，但并不明确，回顾一下 \"+=\" 操作符会展开成什么可能会很有帮助： # Short version: hash[key] += 1 # Expands to: hash[key] = hash[key] + 1 # 现在赋值的过程就很明确了，先取得默认值再进行 +1 的操作，最终将其返回的结果以同样的键名存入哈希 # 我们并没有以任何方式改变默认值，当然，上面一段代码的默认值是数字类型，它是不能修改的 # 但是如果我们使用一个可以修改的值作为默认值并在之后使用了它情况将会变得更加有趣： irb> h = Hash.new([]) irb> h[:missing_key] ---> [] irb> h[:missing_key] &lt;&lt; \"Hey there!\" ---> [\"Hey there!\"] irb> h.keys # Wait for it... ---> [] irb> h[:missing_key] ---> [\"Hey there!\"] # 看到上面关于 \"&lt;&lt;\" 的小骗局了吗？我从没有改变哈希对象，当我插入一个元素之后，哈希并么有改变，但是默认值改变了 # 这也是 keys 方法提示这个哈希是空但是访问不存在的键时却反悔了最近修改的值的原因 # 如果你真想插入一个元素并设置一个键，你需要更深入的研究，但另一个不明显的副作用正等着你： irb> h = Hash.new([]) irb> h[:weekdays] = h[:weekdays] &lt;&lt; \"Monday\" irb> h[:months] = h[:months] &lt;&lt; \"Januray\" irb> h.keys ---> [:weekdays, :months] irb> h[:weekdays] ---> [\"Monday\", \"January\"] irb> h.default ---> [\"Monday\", \"Januray\"] # 两个键共享了同一个默认数组，多数情况你并不想这么做 # 我们真正想要的是当我们访问不存在的键时能返回一个全新的数组 # 如果给 Hash::new 一个块，当需要默认值时这个块就会被调用，并友好地返回一个新创建的数组： irb> h = Hash.new{[]} irb> h[:weekdays] = h[:weekdays] &lt;&lt; \"Monday\" ---> [\"Monday\"] irb> h[:months] = h[:months] &lt;&lt; \"Januray\" ---> [\"Januray\"] irb> h[:weekdays] ---> [\"Monday\"] # 这样好多了，但我们还可以往前一步。 # 传给 Hash::new 的块可以有选择地接受两个参数：哈希本身和将要访问的键 # 这意味着我们如果想去改变哈希也是可的，那么当访问一个不存在的键时，为什么不将其对应的值设置为一个新的空数组呢？ irb> h = Hash.new{|hash, key| hash[key] = []} irb> h[:weekdays] &lt;&lt; \"Monday\" irb> h[:holidays] ---> [] irb> h.keys ---> [:weekdays, :holidays] # 你可能发现上面这样的技巧存在着重要的不足：每当访问不存在的键时，块不仅会在哈希中创建新实体，同时还会创建一个新的数组 # 重申一遍：访问一个不存在的键会将这个键存入哈希，这暴露了默认值存在的通用问题： # 正确的检查一个哈希是否包含某个键的方式是使用 hash_key? 方法或使用它的别名，但是深感内疚的是通常情况下默认值是 nil： if hash[key] ... end # 如果一个哈希的默认值不是 nil 或者 false，这个条件判断会一直成功：将哈希的默认值设置成非 nil 可能会使程序变得不安全 # 另外还要提醒的是：通过获取其值来检查哈希某个键存在与否是草率的，其结果也可能和你所预期的不同 # 另一种处理默认值的方式，某些时候也是最好的方式，就是使用 Hash#fetch 方法 # 该方法的第一个参数是你希望从哈希中查找的键，但是 fetch 方法可以接受一个可选的第二个参数 # 如果指定的 key 在当前的哈希中找不到，那么取而代之，fetch 的第二个参数会返回 # 如果你省略了第二个参数，在你试图获取一个哈希中不存在的键时，fetch 方法会抛出一个异常 # 相比于对整个哈希设置默认值，这种方式更加安全 irb> h = {} irb> h[:weekdays] = h.fetch(:weekdays, []) &lt;&lt; \"Monday\" ---> [\"Monday\"] irb> h.fetch(:missing_key) keyErro: key not found: :missing_key 所以看过上面的代码框隐藏的内容后你会发现： 如果某段代码在接受哈希的非法键时会返回 nil，不要为传入该方法的哈希使用默认值 相比使用默认值，有些时候用 Hash#fetch 方法能更加安全 第 21 条：对集合优先使用委托而非继承这一条也可以被命名为“对于核心类，优先使用委托而非继承”，因为它同样适用于 Ruby 的所有核心类。 Ruby 的所有核心类都是通过 C语言 来实现的，指出这点是因为某些类的实例方法并没有考虑到子类，比如 Array#reverse 方法，它会返回一个新的数组而不是改变接受者。 猜猜如果你继承了 Array 类并调用了子类的 reverse 方法后会发生什么？ # 是的，LikeArray#reverse 返回了 Array 实例而不是 LikeArray 实例 # 但你不应该去责备 Array 类，在文档中有写的很明白会返回一个新的实例，所以达不到你的预期是很自然的 irb> class LikeArray &lt; Array; end irb> x = LikeArray.new([1, 2, 3]) ---> [1, 2, 3] irb> y = x.reverse ---> [3, 2, 1] irb> y.class ---> Array 当然还不止这些，集合上的许多其他实例方法也是这样，集成比较操作符就更糟糕了。 比如，它们允许子类的实例和父类的实例相比较，这说得通嘛？ irb> LikeArray.new([1, 2, 3]) == [1, 2, 3,] ---> true 继承并不是 Ruby 的最佳选择，从核心的集合类中继承更是毫无道理的，替代方法就是使用“委托”。 让我们来编写一个基于哈希但有一个重要不同的类，这个类在访问不存在的键时会抛出一个异常。 实现它有很多不同的方式，但编写一个新类让我们可以简单的重用同一个实现。 与继承 Hash 类后为保证正确而到处修修补补不同，我们这一次采用委托。我们只需要一个实例变量 @hash，它会替我们干所有的重活： # 在 Ruby 中实现委托的方式有很多，Forwardable 模块让使用委托的过程非常容易 # 它将一个存有要代理的方法的链表绑定到一个实例变量上，它是标准库的一部分（不是核心库），这也是需要显式引入的原因 require（'forwardable') class RaisingHash extend(Forwardable) include(Enumerbale) def_delegators(:@hash, :[], :[]=, :delete, :each, :keys, :values, :length, :empty?, :hash_key?) end （更多的探索在书上.这里只是简单给一下结论.感兴趣的童鞋再去看看吧!） 所以要点回顾一下： 对集合优先使用委托而非继承 不要忘记编写用来复制委托目标的 initialize_copy 方法 编写 freeze、taint 以及 untaint 方法时，先传递信息给委托目标，之后调用 super 方法。 第四章：异常第 22 条：使用定制的异常而不是抛出字符串 避免使用字符串作为异常，它们会被转换成原生的 RuntimeError 对象。取而代之，创建一个定制的异常类 定制的异常类应该继承自 StandardError，且类名应该以 “Error” 结尾 当为一个工程创建了不止一个异常类时，从创建一个继承自 StandardError 的基类开始。其他的异常类应该继承自该定制的基类 如果你对你的定制异常类编写了 initialize 方法，务必确保其调用了 super 方法，最好在调用时以错误信息作为参数 在 initialize 方法中设置错误信息时，请牢记：如果在 raise 方法中再度设置错误信息会覆盖原本在 initialize 中设置的那一条 class TemperatureError &lt; StandardError attr_reader(:temperature) def initialize(temperature) @temperature = temperature super(\"invalid temperature: #@temperature\") end end 第 23 条：捕获可能的最具体的异常 只捕获那些你知道如何恢复的异常 当捕获异常时，首先处理最特殊的类型。在异常的继承关系中位置越高的，越应该排在 rescue 链的后面 避免捕获如 StandardError 这样的通用异常。如果你已经这么做了，就应该想想你真正想做的是不是可以通过 ensure 语句来实现 在异常发生的情况下，从 resuce 语句中抛出的异常将会替换当前异常并离开当前的作用域 第 24 条：通过块和 ensure 管理资源 通过 ensure 语句来释放任何已获得的资源 通过在类方法上使用块和 ensure 语句将资源管理的逻辑抽离出来 确保 ensure 语句中使用的变量已经被初始化过了 第 25 条：通过临近的 end 退出 ensure 语句 避免在 ensure 语句中显式使用 return 语句，这意味着方法体内存在着某些错误的逻辑 同样，不要在 ensure 语句中直接使用 throw，你应该将 throw 放在方法主体内 当执行迭代时，不要在 ensure 语句中执行 next 或 break。仔细想想在迭代内到底需不需要 begin 块。将关系反转或许更加合理，就是将迭代放在 begin 块中 一般来说，不要再 ensure 语句中改变控制流，在 rescue 语句中完成这样的工作，你的意图会更加清晰 第 26 条：限制 retry 次数，改变重试频率并记录异常信息 永远不要无条件 retry，要把它看做代码中的隐式循环；在代码块的外围定义重试次数，当超出最大重试次数时重新抛出异常 retry 时记录具有审计作用的异常信息，如果重试有问题的代码解决不了问题，需要追根溯源地去了解异常是如何发生的 当在 retry 之前使用延时时，需要考虑增加延时避免加剧问题 第 27 条：throw 比 raise 更适合用来跳出作用域 在复杂的流程控制中，可以考虑使用 throw 和 raise，这种方法一个额外的好处是可以把一个对象传递到上层调用栈并作为 catch 的最终返回值 尽量使用简单的方法来控制程序结果，可以通过方法调用和 return 重写 catch 和 throw 第五章：元编程第 28 条：熟悉 Ruby 模块和类的钩子方法 所有的钩子方法都需要被定义为单例方法 添加、删除、取消定义方法的钩子方法参数是方法名，而不是类名，如果需要，使用 self 去获取类的信息 定义 singleton_method_added 会出发自身 不要覆盖 extend_object、append_features 和 prepend_features 方法，使用 extended、included 和 prepended 替代 第 29 条：在类的钩子方法中执行 super 方法 在类的钩子方法中执行 super 方法 第 30 条：推荐使用 define_method 而非 method_missing define_method 优于 method_missing 如果必须使用 method_missing，最好也定义 respond_to_missing? 方法 第 31 条：了解不同类型的 eval 间的差异 使用 instance_eval 和 instance_exec 定义的单例方法 class_eval、module_eval、class_exec 和 module_exec 方法只可以被模块或者方法使用。通过这些定义的方法都是实例方法 第 32 条：慎用猴子补丁 尽管 refinement 已经不再是实验性的功能，它仍然有可能被修改得更加成熟 在不同的语法作用域，在使用 refinement 之前必须先激活它 第 33 条：使用别名链执行被修改的方法 在设置别名链时，需要确保别名是独一无二的 必要的时候要考虑提供一个撤销别名链的方法 第 34 条：支持多种 Proc 参数数量 与弱 Proc 对象不同，在参数数量不匹配时，强 Proc 对象会抛出 ArgumentError 异常 可以使用 Proc#arity 方法得到 Proc 期望的参数数量，如果返回的是正数，则意味着有多少参数是必须的。如果返回的是负数，则意味着 Proc 有些参数是可选的，可以通过 “~” 来得到有多少是必须参数 第 35 条：使用模块前置时请谨慎思考 prepend 方法在使用时对类体系机构的影响是：它将模块插入到接受者之前。这和 include 方法有很大不同：include 则是将模块插入到接受者和其超类之间 与 included 和 extended 模块钩子一样，前置模块也会出发 prepended 钩子 第六章：测试第 36 条：熟悉单元测试工具 MiniTest 测试方法需要以 “test_” 作为前缀 简短的测试更容易理解，也更容易维护 使用合适的断言方法生成更易读的出错信息 断言（Assertion）和反演（refutation）的文档在 MiniTest::Assertions 中 第 37 条：熟悉 MiniTest 的需求测试 使用 describe 方法创建测试类，使用 it 定义测试用例 虽然在需求说明测试中，断言仍然可用，但是更推荐使用注入到 Object 中的期望方法 在 MiniTest::Expectations 模块中，可以找到关于期望方法更详细的文档 第 38 条：使用 Mock 模拟特定对象 使用 Mock 来隔离外部系统的不稳定因素 Mock 或者替换没有被测试过得方法，有可能会让这些被 Mock 的代码在生产环境中出现问题 请确保在测试方法代码的最后调用了 MiniTest::Mock#verity 方法 第 39 条：力争代码被有效测试过 使用模糊测试和属性测试工具，帮助测试代码的快乐路径和异常路径。 测试覆盖率工具会给你一种虚假的安全感，因为被执行过的代码不代表这行代码是正确的 在编写特性的同时就加上测试，会让测试容易得多 在你开始寻找导致 bug 的根本原因之前，先写一个针对该 bug 的测试尽可能多地自动化你的测试 第七章：工具与库第 40 条：学会使用 Ruby 文档 ri 工具用来读取文档，rdoc 工具用来生成文档 使用命令行选项 “-d doc” 来为 RI 工具制定在 “doc” 路径下查找文档运行 rdoc 时，后面跟上命令行选项 “-f ri” 来为 RI 工具生成文档。另外，用 “-f darkfish” 来生成 HTML 格式的文档(自己测试过..对于大型项目生成的 HTML 文档不是很友好..) 完整的 RDoc 文档可以在 RDoc::Markup 类中找到（使用 RI 查阅） 第 41 条：认识 IRB 的高级特性 在 IRB::ExtendCommandBundle 模块，或者一个会被引入 IRB::ExtendCommandBundle 中的模块中自定义 IRB 命令 利用下划线变量（”_”）来获取上一个表达式的结果（例如，last_elem = _） irb 命令可以用来创建一个新的会话，并将当前的评估上下文改变成任意对象考虑 Pry gem 作为 IRB 的替代品 第 42 条：用 Bundler 管理 Gem 依赖 在加载完 Bundler 之后，使用 Bundler.require 会牺牲一点点灵活性，但是可以加载 Gemfile 中所有的 gem 当开发应用时，在 Gemfile 中列出所有的 gem，然后把 Gemfile.lock 添加到版本控制系统中 当打包 RubyGem，在 gem 规格文件中列出 gem 所有依赖，但不要把 Gemfile.lock 添加到你的版本系统中 第 43 条：为 Gem 依赖设定版本上限 忽略掉版本上限需求相当于你说了你可以支持未来所有的版本 相对于悲观版本操作符，更加倾向于使用明确的版本范围 当公布发布一个 gem 时，指明依赖包的版本限制要求，在安全的范围内越宽越好，上限可以扩展到下一个主要发布版本之前 第八章：内存管理与性能第 44 条：熟悉 Ruby 的垃圾收集器 扩展阅读：Ruby GC 自述 · Ruby ChinaRuby 2.1:RGenGC 垃圾收集器是个复杂的软件工程。从很高的层次看，Ruby 垃圾收集器使用一种被称为 标记-清除（mark and sweep）的过程。（熟悉 Java 的童鞋应该会感到一丝熟悉） 首先，遍历对象图，能被访问到的对象会被标记为存活的。接着，任何未在第一阶段标记过的对象会被视为垃圾并被清楚，之后将内存释放回 Ruby 或操作系统。 遍历整个对象图并标记可访问对象的开销太大。Ruby 2.1 通过新的分代式垃圾收集器对性能进行了优化。对象被分为两类，年轻代和年老代。 分代式垃圾收集器基于一个前提：大多数对象的生存时间都不会很长。如果我们知道了一个对象可以存活很久，那么就可以优化标记阶段，自动将这些老的对象标记为可访问，而不需要遍历整个对象图。 如果年轻代对象在第一阶段的标记中存活了下来，那么 Ruby 的分代式垃圾收集器就把它们提升为年老代。也就是说，他们依然是可访问的。 在年轻代对象和年老代对象的概念下，标记阶段可以分为两种模式：主要标记阶段（major）和次要标记阶段（minor）。 在主要标记阶段，所有的对象（无论新老）都会被标记。该模式下，垃圾收集器不区分新老两代，所以开销很大。 次要标记阶段，仅仅考虑年轻代对象，并自动标记年老代对象，而不检查能否被访问。这意味着年老代对象只会在主要标记阶段之后才会被清除。除非达到了一些阈值，保证整个过程全部作为主要标记之外，垃圾收集器倾向于使用次要标记。 垃圾收集器的清除阶段也有优化机制，分为两种模式：即使模式和懒惰模式。 在即使模式中，垃圾收集器会清除所有的未标记的对象。如果有很多对象需要被释放，那这种模式开销就很大。 因此，清除阶段还支持懒惰模式，它将尝试释放尽可能少的对象。 每当 Ruby 中创建一个新对象时，它可能尝试触发一次懒惰清除阶段，去释放一些空间。为了更好的理解这一点，我们需要看看垃圾收集器如何管理存储对象的内存。（简单概括：垃圾收集器通过维护一个由页组成的堆来管理内存。页又由槽组成。每个槽存储一个对象。） 我们打开一个新的 IRB 会话，运行如下命令： `IRB``> ``GC``.stat` `---> {``:count``=>``9``, ``:heap_length``=>``126``, ...}` GC::stat 方法会返回一个散列，包含垃圾收集器相关的所有信息。请记住，该散列中的键以及它们对应垃圾收集器的意义可能在下一个版本发生变化。 好了，让我们来看一些有趣的键： 键名 说明 count 垃圾收集器运行的总次数 major_gc_count 主要模式下的运行次数 minor_gc_count 次要模式下的运行次数 total_allocated_object 程序开始时分配的对象总数 total_freed_object Ruby 释放的对象总数。与上面之差表示存活对象的数量，这可以通过 heap_live_slot 键来计算 heap_length 当前堆中的页数 heap_live_slot 和 heap_free_slot 表示全部页中被使用的槽数和未被使用的槽数 old_object 年老代的对象数量，在次要标记阶段不会被处理。年轻代的对象数量可以用 heap_live_slot 减去 old_object 来获得 该散列中还有几个有趣的数字，但在介绍之前，让我们来学习垃圾收集器的最后一个要点。还记得对象是存在槽中的吧。Ruby 2.1 的槽大小为 40 字节，然而并不是所有的对象都是这么大。 比如，一个包含 255 个字节的字符串对象。如果对象的大小超过了槽的大小，Ruby 就会额外向操作系统申请一块内存。 当对象被销毁，槽被释放后，Ruby 会把多余的内存还给操作系统。现在让我们看看 GC::stat 散列中的这些键： 键名 说明 malloc_increase 所有超过槽大小的对象所占用的总比特数 malloc_limit 阈值。如果 malloc_increase 的大小超过了 malloc_limit，垃圾收集器就会在次要模式下运行。一个 Ruby 应用程序的生命周期里，malloc_limit 是被动调整的。它的大小是当前 malloc_increase 的大小乘以调节因子，这个因子默认是 1.4。你可以通过环境变量 RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR 来设定这个因子 oldmalloc_increase 和 oldmalloc_limit 是上面两个对应的年老代值。如果 oldmalloc_increase 的大小超过了 oldmalloc_limit，垃圾收集器就会在主要模式下运行。oldmalloc_limit 的调节因子more是 1.2。通过环境变量 RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR 可以设定它 作为最后一部分，让我们来看针对特定应用程序进行垃圾收集器调优的环境变量。 在下一个版本的 Ruby 中，GC::stat 散列中的值对应的环境变量可能会发生变化。好消息是 Ruby 2.2 将支持 3 个分代，Ruby 2.1 只支持两个。这可能会影响到上述变量的设定。 有关垃圾收集器调优的环境变量的权威信息保存在 “gc.c” 文件中，是 Ruby 源程序的一部分。 下面是 Ruby 2.1 中用于调优的环境变量（仅供参考）： 环境变量名 说明 RUBY_GC_HEAP_INIT_SLOTS 初始槽的数量。默认为 10k，增加它的值可以让你的应用程序启动时减少垃圾收集器的工作效率 RUBY_GC_HEAP_FREE_SLOTS 垃圾收集器运行后，空槽数量的最小值。如果空槽的数量小于这个值，那么 Ruby 会申请额外的页，并放入堆中。默认值是 4096 RUBY_GC_HEAP_GROWTH_FACTOR 当需要额外的槽时，用于计算需要增加的页数的乘数因子。用已使用的页数乘以这个因子算出还需要增加的页数、默认值是 1.8 RUBY_GC_HEAP_GROWTH_MAX_SLOTS 一次添加到堆中的最大槽数。默认值是0，表示没有限制。 RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR 用于计算出发主要模式垃圾收集器的门限值的乘数因子。门限由前一次主要清除后年老代对象数量乘以该因子得到。该门限与当前年老代对象数量成比例。默认值是 2.0。这意味着如果年老代对象在上次主要标记阶段过后的数量翻倍的话，新一轮的主要标记过程将被出发。 RUBY_GC_MALLOC_LIMIT GC::stat 散列中 malloc_limit 的最小值。如果 malloc_increase 超过了 malloc_limit 的值，那么次要模式垃圾收集器就会运行一次。该设定用于确保 malloc_increase 不会小于特定值。它的默认值是 16 777 216（16MB） RUBY_GC_MALOC_LIMIT_MAX 与 RUBY_GC_MALLOC_LIMIT 相反的值，这个设定保证 malloc_limit 不会变得太高。它可以被设置成 0 来取消上限。默认值是 33 554 432（32MB） RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR 控制 malloc_limit 如何增长的乘数因子。新的 malloc_limit 值由当前 malloc_limit 值乘以这个因子来获得，默认值为 1.4 RUBY_GC_OLDMALLOC_LIMIT 年老代对应的 RUBY_GC_MALLOC_LIMIT 值。默认值是 16 777 216（16MB） RUBY_GC_OLDMALLOC_LIMIT_MAX 年老代对应的 RUBY_GC_MALLOC_LIMIT_MAX 值。默认值是 134 217 728（128MB） RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR 年老代对应的 RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR 值。默认值是 1.2 第 45 条：用 Finalizer 构建资源安全网 最好使用 ensure 子句来保护有限的资源。 如果必须要在 ensure 子句外报录一个资源（resource），那么就给它创建一个 finalizer（终结方法） 永远不要再这样一个绑定中创建 finalizer Proc，该绑定引用了一个注定会被销毁的对象，这会造成垃圾收集器无法释放该对象 记住，finalizer 可能在一个对象销毁后以及程序终止前的任何时间被调用 第 46 条：认识 Ruby 性能分析工具 在修改性能差的代码之前，先使用性能分析工具收集性能相关的信息。 在 ruby-prof gem 和 Ruby 自带的标准 profile 库之间，选择前者，因为前者更快而且可以提供多种不同的报告。 如果使用 Ruby 2.1 或者更新的版本，应该考虑使用 stackprof gem 和 memory_profiler gem。 第 47 条：避免在循环中使用对象字面量 将循环中的不会变化的对象字面量变成常量。 在 Ruby 2.1 及更高的版本中冻结字符串字面量，相当于把它作为常量，可以被整个运行程序共享。 第 48 条：考虑记忆化大开销计算 考虑提供一个方法通过将缓存的变量职位 nil 来重置记忆化。 确保时钟认真考虑过这些由记忆化而跳过副作用所导致的后果。 如果不希望调用者修改缓存的变量，那应该考虑让被记忆化的方法返回冻结对象。 先用工具分析程序的性能，再考虑是否需要记忆化。 总结周末学习了两天才勉强看完了一遍，对于 Ruby 语言的有一些高级特性还是比较吃力的，需要自己反反复复的看才能理解一二。不过好在也是有收获吧，没有白费自己的努力，特地总结一个精简版方便后面的童鞋学习。 另外这篇文章最开始是使用公司的文档空间创建的，发现 Markdown 虽然精简易于使用，但是功能性上比一些成熟的写文工具要差上很多，就比如对代码的支持吧，用公司的代码块还支持自定义标题、显示行号、是否能缩放、主题等一系列自定义的东西，写出来的东西也更加友好… 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java转Ruby【快速入门】","slug":"Java转Ruby【快速入门】","date":"2019-04-25T23:23:00.000Z","updated":"2020-12-09T05:07:04.701Z","comments":true,"path":"2019/04/26/java-zhuan-ruby-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2019/04/26/java-zhuan-ruby-kuai-su-ru-men/","excerpt":"最近参加实习了，公司的技术栈中需要用到 Ruby 以及 Rails 框架，所以算是开始了踩坑之旅吧..","text":"最近参加实习了，公司的技术栈中需要用到 Ruby 以及 Rails 框架，所以算是开始了踩坑之旅吧.. Ruby 简介网上的简介要搜都能搜到，具体涉及的包括历史啦之类这里不再赘述，提几个关键词吧： 1993 年由日本的松本行弘创建 纯粹面相对象编程/ 脚本语言/ 解释型/ 动态类型 对于准备迈入 Ruby 的 Java 程序员来说，有几个地方需要特别的去了解一下。 纯粹面相对象其实经过论证，Java 同 Ruby 一样都是纯粹的面相对象的语言，这也就意味着包含所有的数字等在内都是对象，注意所有的都是。 脚本语言这意味着你写的程序不用编译就能运行，甚至实时生效。 解释型同 Java 一样，Ruby 有自己的虚拟机，运行需要一定的环境，也就是 Ruby 解释器，它会负责把 Ruby 翻译成及其能够执行的代码。 动态类型Ruby 中的数据更像是一种符号，在使用的时候不检查类型，而是在运行时动态的检查。 为什么是 Ruby ？ 原因很简单：高效/ 灵活/ 优雅/ 简单 如果你再稍微花一些心思搜索一下 Ruby on Rails 这个 Web 开发框架，并且打开一些详细说明了体验之后的文章或者是多年经验开发者的分享，你可能会对它产生一些兴趣，这一Part就留着之后介绍了，这也是为以后学习 RoR 框架做准备的。 总之我们要明确我们目的：知道最基本的语法，理解其中的一些关键概念即可。 Ruby 初体验Mac OX 中有默认的 Ruby 环境，我们可以来一个最短的 “Hello World” 程序，首先在控制台中输入 irb 命令，然后输入 puts &quot;Hello World!&quot; 命令： irb irb(main):001:0> puts \"Hello World!\" Hello World! => nil 你就能看到紧跟着你的输入会有一个 Hello World! 的输出以及一个 nil （对应 Java 中的 null）的返回。 再来一个更加复杂的例子，我们这一次来创建一个数组然后循环输出它： irb(main):002:0> properties = ['name','age','sex'] => [\"name\", \"age\", \"sex\"] irb(main):003:0> properties => [\"name\", \"age\", \"sex\"] irb(main):005:0> properties.each {|property| puts \"This is #{property}.\"} This is name. This is age. This is sex. => [\"name\", \"age\", \"sex\"] 不知道感觉如何？至少我们可以直观的感受到： 不用生命变量，直接 = 就好 每条 Ruby 代码都会返回某个值 从 Java 到 RubyJava 非常成熟，并且通过 Spring 的加持得到了许多企业的青睐，但是不知道大家有没有感受到一点：它或许有些啰嗦…（我乱说的啊，我也不知道，别问我啊..）从 Java 到 Ruby 据说可以预见性的将代码的规模量大大缩小，因此也能使用更少的时间来输出产品原型。 相似点Ruby 与 Java 有一些相似的地方… 垃圾回收器帮你管理内存。 强类型对象。 有 public、 private 和 protected 方法。 拥有嵌入式文档工具（Ruby 的工具叫 rdoc）。rdoc 生成的文档与 javadoc 非常相似。 不同点Ruby 与 Java 不同的地方… 你不需要编译你的代码。你只需要直接运行它。 有几个不同的流行的第三方GUI工具包。Ruby 用户可以尝试 WxRuby、 FXRuby、 Ruby-GNOME2、 Qt 或 Ruby 内置的 Tk。 定义像类这样的东西时，可以使用 end 关键字，而不使用花括号包裹代码块。 使用 require 代替 import。 所有成员变量为私有。在外部，使用方法获取所有你需要的一切。 方法调用的括号通常是可选的，经常被省略。 一切皆对象，包括像 2 和 3.14159 这样的数字。 没有静态类型检查。 变量名只是标签。它们没有相应的类型。 没有类型声明。按需分配变量名，及时可用（如：a = [1,2,3] 而不是 int[] a = {1,2,3};）。 没有显式转换。只需要调用方法。代码运行之前，单元测试应该告诉你出现异常。 使用 foo = Foo.new(&quot;hi&quot;) 创建新对象，而非 Foo foo = new Foo(&quot;hi&quot;)。 构造器总是命名为“initialize” 而不是类名称。 作为接口的替代，你将获得“混入（mixins）”。 相比 XML，倾向于使用 YAML。 nil 替代 null。 Ruby 对 == 和 equals() 的处理方式与 Java 不一样。测试相等性使用 ==（Java 中是 equals()）。测试是否为同一对象使用 equals?()（Java 中是 ==）。 以上的相同与不同来自：https://www.ruby-lang.org/zh_cn/documentation/ruby-from-other-languages/to-ruby-from-java/延伸阅读：https://gquintana.github.io/2017/01/08/From-Java-to-Ruby.html Ruby 基础在大致了解了 Ruby 一些基础信息之后，我们开始 Ruby 基础语法的学习，虽然面对一门新的语言，语法啊特性啊之类的了解很有必要，但还是想在了解之前看一看 Ruby 的一些代码规范，好让自己能快速了解 Ruby 的基础上还能养成一个良好的编码习惯。 学习之前必备 - 代码规范或许有些语句还不能理解，没关系，有一个基础印象就好。 一般来讲，Ruby 中的变量名和方法名使用下划线命名法(小写字母 + _)，类名和模块名使用 Java 类似的驼峰命名法 每个缩进级别使用两个 space（又名软 tabs），不要使用硬 tabs # bad - four spaces def some_method do_something end # good def some_method do_something end 不用使用 ; 来分割语句和表达式。以此推论 - 一行使用一个表达式 # bad puts 'foobar'; # superfluous semicolon puts 'foo'; puts 'bar' # two expression on the same line # good puts 'foobar' puts 'foo' puts 'bar' puts 'foo', 'bar' # this applies to puts in particular 避免单行方法。即便还是会受到一些人的欢迎，这里还是会有一些古怪的语法用起来很容易犯错. 无论如何 - 应该一行不超过一个单行方法. # bad def too_much; something; something_else; end # okish - notice that the first ; is required def no_braces_method; body end # okish - notice that the second ; is optional def no_braces_method; body; end # okish - valid syntax, but no ; make it kind of hard to read def some_method() body end # good def some_method body end 空方法是这个规则的例外。 # good def no_op; end 当赋值一个条件表达式的结果给一个变量时，保持分支的缩排在同一层。 # bad - pretty convoluted kind = case year when 1850..1889 then 'Blues' when 1890..1909 then 'Ragtime' when 1910..1929 then 'New Orleans Jazz' when 1930..1939 then 'Swing' when 1940..1950 then 'Bebop' else 'Jazz' end result = if some_cond calc_something else calc_something_else end # good - it's apparent what's going on kind = case year when 1850..1889 then 'Blues' when 1890..1909 then 'Ragtime' when 1910..1929 then 'New Orleans Jazz' when 1930..1939 then 'Swing' when 1940..1950 then 'Bebop' else 'Jazz' end result = if some_cond calc_something else calc_something_else end # good (and a bit more width efficient) kind = case year when 1850..1889 then 'Blues' when 1890..1909 then 'Ragtime' when 1910..1929 then 'New Orleans Jazz' when 1930..1939 then 'Swing' when 1940..1950 then 'Bebop' else 'Jazz' end result = if some_cond calc_something else calc_something_else end 在方法定义之间使用空行并且一个方法根据逻辑段来隔开。 def some_method data = initialize(options) data.manipulate! data.result end def some_methods result end 不要使用区块注释。它们不能由空白引导（=begin 必须顶头开始），并且不如普通注释容易辨认。 # bad == begin comment line another comment line == end # good # comment line # another comment line 使用括号将def的参数括起来。当方法不接收任何参数的时候忽略括号。# bad def some_method() # body omitted end gooddef some_method body omittedend baddef some_method_with_arguments arg1, arg2 body omittedend gooddef some_method_with_arguments(arg1, arg2) body omittedend - 从来不要使用 `for`， 除非你知道使用它的准确原因。大多数时候迭代器都可以用来替 `for`。`for` 是由一组 `each` 实现的 (因此你正间接添加了一级)，但是有一个小道道 - `for` 并不包含一个新的 scope (不像 `each`)并且在它的块中定义的变量在外面也是可以访问的。（这里有些像 Java 中不用 for-each 语句类似，感兴趣的也可以去搜一搜） ```ruby arr = [1, 2, 3] # bad for elem in arr do puts elem end # note that elem is accessible outside of the for loop elem #=&gt; 3 # good arr.each { |elem| puts elem } # elem is not accessible outside each&#39;s block elem #=&gt; NameError: undefined local variable or method `elem&#39; 利用 if and case 是表达式这样的事实它们返回一个结果。 # bad if condition result = x else result = y end # good result = if condition x else y end 布尔表达式使用&amp;&amp;/||, and/or用于控制流程。（经验Rule:如果你必须使用额外的括号（表达逻辑），那么你正在使用错误的的操作符。） # boolean expression if some_condition &amp;&amp; some_other_condition do_something end # control flow document.save? or document.save! 永远不要使用 unless 和 else 组合。将它们改写成肯定条件。 # bad unless success? puts 'failure' else puts 'success' end # good if success? puts 'success' else puts 'failure' end 不用使用括号包含 if/unless/while 的条件。 # bad if (x > 10) # body omitted end # good if x > 10 # body omitted end 倾向使用 module，而不是只有类方法的 class。类别应该只在创建实例是合理的时候使用。 # bad class SomeClass def self.some_method # body omitted end def self.some_other_method end end # good module SomeClass module_function def some_method # body omitted end def some_other_method end end 当你希望将模块的实例方法变成 class 方法时，偏爱使用 module_function 胜过 extend self。 module Utilities extend self def parse_something(string) # do stuff here end def other_utility_method(number, string) # do some more stuff end end # good module Utilities module_function def parse_something(string) # do stuff here end def other_utility_method(number, string) # do some more stuff end end 总是为你自己的类提供 to_s 方法, 用来表现这个类（实例）对象包含的对象. class Person attr_reader :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end def to_s \"#@first_name #@last_name\" end end 考虑使用 Struct.new, 它可以定义一些琐碎的 accessors, constructor（构造函数） 和 comparison（比较） 操作。 # good class Person attr_reader :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end end # better class Person &lt; Struct.new(:first_name, :last_name) end 考虑使用 Struct.new，它替你定义了那些琐碎的存取器（accessors），构造器（constructor）以及比较操作符（comparison operators）。 # good class Person attr_accessor :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end end # better Person = Struct.new(:first_name, :last_name) do end 不要去 extend 一个 Struct.new - 它已经是一个新的 class。扩展它会产生一个多余的 class 层级 并且可能会产生怪异的错误如果文件被加载多次。 鸭子类型（duck-typing）优于继承。 # bad class Animal # abstract method def speak end end # extend superclass class Duck &lt; Animal def speak puts 'Quack! Quack' end end # extend superclass class Dog &lt; Animal def speak puts 'Bau! Bau!' end end # good class Duck def speak puts 'Quack! Quack' end end class Dog def speak puts 'Bau! Bau!' end end 当访问一个数组的第一个或者最后一个元素，倾向使用 first 或 last 而不是 [0] 或 [-1]。 优先使用 字符串插值 来代替 字符串串联。 # bad email_with_name = user.name + ' &lt;' + user.email + '>' # good email_with_name = \"#{user.name} &lt;#{user.email}>\" # good email_with_name = format('%s &lt;%s>', user.name, user.email) 在对象插值的时候不要使用 Object#to_s，它将会被自动调用。 操作较大的字符串时, 避免使用 String#+ 做为替代使用 String#&lt;&lt;。就地级联字符串块总是比 String#+ 更快，它创建了多个字符串对象。 # good and also fast html = '' html &lt;&lt; '&lt;h1>Page title&lt;/h1>' paragraphs.each do |paragraph| html &lt;&lt; \"&lt;p>#{paragraph}&lt;/p>\" end RuboCopRuboCop 是一个基于本指南的 Ruby 代码风格检查工具。 RuboCop 涵盖了本指南相当大的部分，支持 MRI 1.9 和 MRI 2.0，而且与 Emacs 整合良好。 RubyMineRubyMine 的代码检查是 部分基于 本指南的。 基于下面链接简化了大部分，因为有一些编码风格能从 Java 自然的切换过来，而且我们也可以使用相应的工具来检查我们的代码，更多可以看这里：https://ruby-china.org/wiki/coding-style Ruby 语言基础其实通过上面的语法规范，我们或多或少能感知到一些 Ruby 的语法，有一些细节的地方可以自行去菜鸟教程or其他网站能看到，下面我们就着一些重要的东西快速的学习一遍吧.. 数据类型Ruby 中有以下几种不同的数据类型： 数字/ 字符串/ 符号/ 哈希/ 数组/ 布尔比较在意的是 Ruby 并没有 Java 中的枚举类型，可能是出于安全方面的考虑吧..（我也不知道…） 符号就像字符串。一个符号之前是冒号（:）。例如： :abcd 它们不包含空格。 含有多个单词的符号用(_)写成。 字符串和符号之间的一个区别是，如果文本是一个数据，那么它是一个字符串，但如果它是一个代码，它是一个符号。 符号是唯一的标识符，表示静态值，而字符串表示更改的值。 示例： irb(main):011:0> \"string\".object_id => 26922000 irb(main):012:0> \"string\".object_id => 29115220 irb(main):013:0> :symbol.object_id => 788188 irb(main):014:0> :symbol.object_id => 788188 哈希将其值分配给其键。 它们可以用键关联指定值。键的值由 =&gt; 符号分配。 键/值对之间用逗号分隔，所有对都用大括号括起来。 例如： {\"key1\" => \"value1\", \"key2\" => \"Chemistry\", \"key3\" => \"Maths\"} 示例： data = {\"key1\" => \"Physics\", \"key2\" => \"Chemistry\", \"key3\" => \"Maths\"} puts data[\"key1\"] puts data[\"key2\"] puts data[\"key3\"] 执行上述代码，得到以下结果： Physics Chemistry Maths 变量Ruby 有四种类型的变量，变量的命名方式决定了变量的种类： 局部变量以英文小写字母或者 _ 开头，作用域等同于 Java 局部变量。 全局变量以 $ 开头，作用域等同于 Java 全局变量。只要全局变量的名称相同，不管变量在程序的哪个部分使用，程序都认为是它们是同一个变量。未初始化的全局变量的值会被初始化为：nil。建议不要使用全局变量，因为它们使程序变得秘密和复杂。 示例： $global_var = \"GLOBAL\" class One def display puts \"Global variable in One is #$global_var\" end end class Two def display puts \"Global variable in Two is #$global_var\" end end oneobj = One.new oneobj.display twoobj = Two.new twoobj.display 执行代码输出结果如下： Total number of states written: 4 Total number of states written: 4 Total number of states written: 4 Total number of states written: 4 实例变量以 @ 开头，在同一个实例中，程序可以超越方法定义，任意引用、修改实例变量。它属于类的一个实例，可以从方法中的类的任何实例访问。 它们只能访问一个特定的类的实例。它们不需要初始化，未初始化的实例变量的值是：nil 。 示例： class States def initialize(name) @states_name=name end def display() puts \"States name #@states_name\" end end # Create Objects first=States.new(\"Hainan\") second=States.new(\"GuangDong\") third=States.new(\"Beijing\") fourth=States.new(\"ShangDong\") # Call Methods first.display() second.display() third.display() fourth.display() 执行代码输出结果如下： States name GuangDong States name Beijing States name ShangDong 类变量以 @@ 开头，作用域为该类的所有实例。需要在使用前进行初始化，由类的所有后代共享，未初始化的变量将导致错误。 示例： class States @@no_of_states=0 def initialize(name) @states_name=name @@no_of_states += 1 end def display() puts \"State name #@state_name\" end def total_no_of_states() puts \"Total number of states written: #@@no_of_states\" end end # Create Objects first=States.new(\"Assam\") second=States.new(\"Meghalaya\") third=States.new(\"Maharashtra\") fourth=States.new(\"Pondicherry\") # Call Methods first.total_no_of_states() second.total_no_of_states() third.total_no_of_states() fourth.total_no_of_states() 执行上面代码输出结果如下： Total number of states written: 4 Total number of states written: 4 Total number of states written: 4 Total number of states written: 4 类和对象Object 类是所有 Ruby 对象的默认根。 Ruby 对象继承自 BasicObject(它是Ruby中所有类的父类)类，允许创建替代对象层次结构。 首先与 Java 很不同的是创建对象： Object newObject = new Object(); // Java 中新建对象 对比 Ruby： objectName = className.new 每个 Ruby 类都是 Class 类的一个实例。通常对于类名，使用驼峰命名规则，类的名称始终以大写字母开头。定义类是用 end 关键字完成的。 语法 class ClassName codes... end 我们使用上面学习过的语法规范来创建一个 Person 类（写上 to_s 方法）： class Person attr_reader :first_name, :last_name def initialize(first_name, last_name) @first_name = first_name @last_name = last_name end def to_s \"#@first_name #@last_name\" end end 注意这里的 attr_reader 对应在 Java 中相当于为 first_name 和 last_name 定义了 getter ，在 Ruby 中，从对象外部不能直接访问实例变量或对实例变量赋值，需要通过方法来访问对象的内部，如果像 Java 那样一遍一遍为每一个变量写 getter/setter 就有些冗杂了，Ruby 为我们提供了一些方便的存取器。 定义 意义 attr_reader :name 只读（定义 name 方法） attr_writer :name 只写（定义 name= 方法） attr_accessor :name 读写（定义以上两个方法） 另外一点上面有一个非常有趣的规范是使用 Struct.new 来简化代码，我觉得很酷也想把它应用在上述 Person 类的创建中，但是发现失败了（不能在其中定义其他功能性的代码），所以可能结论是：这样的简化只适用于一些实体类保存数据的类吧。 方法Ruby 方法使用 def 关键字开始，最后还需要使用 end 关键字来表示方法定义结束。 语法： def methodName code... end 示例： def method_defining(a1 = \"Ruby\", a2 = \"Python\") puts \"The programming language is #{a1}\" puts \"The programming language is #{a2}\" end method_defining \"C\", \"C++\" method_defining 运行上面的代码执行结果如下： The programming language is C The programming language is C++ The programming language is Ruby The programming language is Python 方法返回值： 在初探 Ruby 的时候我们就感受到，貌似每一条指令都会返回一个返回值，方法也是这样，在 Ruby 中每个方法都有一个返回值，这个返回的值将是最后一个语句的值。例如： def my_method i = 100 j = 10 k = 1 end 上面代码中，最后方法的返回值是 1。 Ruby return 语句 Ruby 中的 return 语句用于从 Ruby 方法中返回一个或多个值 示例： def method i = 100 j = 200 k = 300 return i, j, k end var = method puts var 上面代码结果如下： 100 200 300 可变参数： 假设声明一个方法需要两个参数，每当调用这个方法时，需要传递两个参数。但是，Ruby允许您声明使用可变数量参数的方法。 让我们来看一下这个示例： def sample (*test) puts \"The number of parameters is #{test.length}\" for i in 0...test.length puts \"The parameters are #{test[i]}\" end end sample \"Maxsu\", \"6\", \"F\" sample \"Mac\", \"38\", \"M\", \"MCA\" 执行上面代码，得到如下结果： The number of parameters is 3 The parameters are Maxsu The parameters are 6 The parameters are F The number of parameters is 4 The parameters are Mac The parameters are 38 The parameters are M The parameters are MCA 类方法： 当方法在类定义之外定义时，默认情况下该方法被标记为 private。 另一方面，默认情况下，类定义中定义的方法被标记为 public。模块的默认可见性和 private 标记可以通过模块的 public 或 private 更改。 Ruby 给出一种不用实例化一个类就可以访问一个方法。下面来看看看如何声明和访问类方法 - class Accounts def reading_charge end def Accounts.return_date end end 访问类方法 - Accounts.return_date 模板Ruby 模块是方法和常量的集合。暂时你可简单的理解为一个不能实例化的类，这样做的好处是一来可以提供一个命名空间避免名字冲突，另一个是实现了 mixin 的功能。 不知道您有没有发现，Ruby 没有提供多重继承的功能，但 Ruby 的模板几乎消除了多重继承的需要，提供了一种名为 mixin 的装置。 示例： module A def a1 end def a2 end end module B def b1 end def b2 end end class Sample include A include B def s1 end end samp=Sample.new samp.a1 samp.a2 samp.b1 samp.b2 samp.s1 块Ruby 代码在其他编程语言中被称为闭包。它由一组代码组成，它们始终用大括号括起来，或者在 do..end 之间书写。大括号语法总是具有比 do..end 语法更高的优先级。也就是说大括号优先级高，do..end 优先级低。 语法： block_name{ statement1 statement2 .......... } yield语句： def test puts \"在 test 方法内\" yield puts \"你又回到了 test 方法内\" yield end test {puts \"你在块内\"} 上面代码运行结果如下： 在 test 方法内 你在块内 你又回到了 test 方法内 你在块内 块和方法： def test yield end test{ puts \"Hello world\"} 本实例是实现块的最简单的方式。您使用 yield 语句调用 test 块。 但是如果方法的最后一个参数前带有 &amp;，那么您可以向该方法传递一个块，且这个块可被赋给最后一个参数。如果 * 和 &amp; 同时出现在参数列表中，&amp; 应放在后面。 def test(&amp;block) block.call end test { puts \"Hello World!\"} 上述代码运行结果如下： Hello World! 这一部分建议再去看一下慕课网上的教程，看关于第三章的内容即可：Ruby语言快速入门：https://www.imooc.com/learn/765 总结经过以上简单的学习，我们对 Ruby 有了一个大致的了解，算是简单入了个门（有一些简单的例如循环啊，判断啊，运算符之类的简单我就没有写了），更多的东西需要自己平时的编码中去总结学习（肯定有一些坑需要自己去填的）。 参考文章：1.Ruby 教程 - 菜鸟驿站 - http://www.runoob.com/ruby/ruby-intro.html2.Ruby 教程 - 易百教程 - https://www.yiibai.com/ruby3.20分钟体验 Ruby - https://www.ruby-lang.org/zh_cn/documentation/quickstart/4.笨方法学 Ruby - https://lrthw.github.io/intro/5.Ruby 快速入门 - https://wdxtub.com/2016/03/30/ruby-first-step/ 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Ruby","slug":"后端/Ruby","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Ruby/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"MongoDB【快速入门】","slug":"MongoDB【快速入门】","date":"2019-04-24T23:21:00.000Z","updated":"2020-12-09T05:07:49.660Z","comments":true,"path":"2019/04/25/mongodb-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2019/04/25/mongodb-kuai-su-ru-men/","excerpt":"","text":"1.MongDB 简介MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。作为一个适用于敏捷开发的数据库，MongoDB 的数据模式可以随着应用程序的发展而灵活地更新。与此同时，它也为开发人员 提供了传统数据库的功能：二级索引，完整的查询系统以及严格一致性等等。 MongoDB 能够使企业更加具有敏捷性和可扩展性，各种规模的企业都可以通过使用 MongoDB 来创建新的应用，提高与客户之间的工作效率，加快产品上市时间，以及降低企业成本。 MongoDB 是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB 能够提供高性能的数据读写操作。 MongoDB 的本地复制和自动故障转移功能使您的应用程序具有企业级的可靠性和操作灵活性。 以上内容摘自官网： 1.1 文档型数据库简而言之，MongoDB是一个免费开源跨平台的 NoSQL 数据库，与关系型数据库不同，MongoDB 的数据以类似于 JSON 格式的二进制文档存储： { name: \"我没有三颗心脏\", age: 22, } 文档型的数据存储方式有几个重要好处： 文档的数据类型可以对应到语言的数据类型，如数组类型（Array）和对象类型（Object）； 文档可以嵌套，有时关系型数据库涉及几个表的操作，在 MongoDB 中一次就能完成，可以减少昂贵的连接花销； 文档不对数据结构加以限制，不同的数据结构可以存储在同一张表； MongoDB 的文档数据模型和索引系统能有效提升数据库性能； 复制集功能提供数据冗余，自动化容灾容错，提升数据库可用性； 分片技术能够分散单服务器的读写压力，提高并发能力，提升数据库的可拓展性； MongoDB 高性能，高可用性、可扩展性等特点，使其至 2009 年发布以来，逐渐被认可，并被越来越多的用于生产环境中。AWS、GCP、阿里云等云平台都提供了十分便捷的 MongoDB 云服务。 1.2 MongoDB 基础概念可以使用我们熟悉的 MySQL 数据库来加以对比： MySQL 基础概念 MongoDB 对应概念 数据库（database） 容器（database） 表（table） 集合（collection） 行（row） 文档（document） 列（column） 域（filed） 索引（index） 索引（index） 也借用一下菜鸟教程的图来更加形象生动的说明一下： 这很容易理解，但是问题在于：我们为什么要引入新的概念呢？（也就是为什么我们要把“表”替换成“集合”，“行”替换成“文档”，“列”替换成“域”呢？）原因在于，其实在 MySQL 这样的典型关系型数据中，我们是在定义表的时候定义列的，但是由于上述文档型数据库的特点，它允许文档的数据类型可以对应到语言的数据类型，所以我们是在定义文档的时候才会定义域的。 也就是说，集合中的每个文档都可以有独立的域。因此，虽说集合相对于表来说是一个简化了的容器，而文档则包含了比行要多得多的信息。 2 搭建环境怎么样都好，搭建好环境就行，这里以 OS 环境为例，你可以使用 OSX 的 brew 安装 mongodb： brew install mongodb 在运行之前我们需要创建一个数据库存储目录 /data/db： sudo mkdir -p /data/db 然后启动 mongodb，默认数据库目录即为 /data/db（如果不是，可以使用 --dbpath 指令来指定）： sudo mongd 过一会儿你就能看到你的 mongodb 运行起来的提示： 具体的搭建过程可以参考菜鸟的教程：http://www.runoob.com/mongodb/mongodb-window-install.html 3 基于 Shell 的 CRUD3.1 连接实例通过上面的步骤我们在系统里运行了一个 mongodb 实例，接下来通过 mongo 命令来连接它： mongo [options] [db address] [file names] 由于上面运行的 mongodb 运行在 27017 端口，并且灭有启动安全模式，所以我们也不需要输入用户名和密码就可以直接连接： mongo 127.0.0.1:27017 或者通过 --host 和 --port 选项指定主机和端口。一切顺利的话，就进入了 mongoDB shell，shell 会报出一连串权限警告，不过不用担心，这并不会影响之后的操作。在添加授权用户和开启认证后，这些警告会自动消失。 3.2 CRUD 操作在进行增删改查操作之前，我们需要先了解一下常用的 shell 命令： db 显示当前所在数据库，默认为 test show dbs 列出可用数据库 show tables show collections 列出数据库中可用集合 use &lt;database&gt; 用于切换数据库 mongoDB 预设有两个数据库，admin 和 local，admin 用来存放系统数据，local 用来存放该实例数据，在副本集中，一个实例的 local 数据库对于其它实例是不可见的。使用 use 命令切换数据库： > use admin > use local > use newDatabase 可以 use 一个不存在的数据库，当你存入新数据时，mongoDB 会创建这个数据库： > use newDatabase > db.newCollection.insert({x:1}) WriteResult({ \"nInserted\" : 1 }) 以上命令向数据库中插入一个文档，返回 1 表示插入成功，mongoDB 自动创建 newCollection 集合和数据库 newDatabase。下面将对增查改删操作进行一个简单的演示。 3.2.1 创建（Create）MongoDB 提供 insert 方法创建新文档： db.collection.inserOne() 插入单个文档WriteResult({ “nInserted” : 1 }) db.collection.inserMany() 插入多个文档 db.collection.insert() 插入单条或多条文档 我们接着在刚才新创建的 newDatabase 下面新增数据吧： db.newCollection.insert({name:\"wmyskxz\",age:22}) 根据以往经验应该会觉得蛮奇怪的，因为之前在这个集合中插入的数据格式是 {x:1} 的，而这里新增的数据格式确是 {name:&quot;wmyskxz&quot;,age:22} 这个样子的。还记得吗，文档型数据库的与传统型的关系型数据的区别就是在这里！ 并且要注意，age:22 和 age:&quot;22&quot; 是不一样的哦，前者插入的是一个数值，而后者是字符串，我们可以通过 db.newCollection.find() 命令查看到刚刚插入的文档： > db.newCollection.find() { \"_id\" : ObjectId(\"5cc1026533907ae66490e46c\"), \"x\" : 1 } { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } 这里有一个神奇的返回，那就是多了一个叫做 _id 的东西，这是 MongoDB 为你自动添加的字段，你也可以自己生成。大部分情况下还是会让 MongoDB 为我们生成，而且默认情况下，该字段是被加上了索引的。 3.2.2 查找（Read）MongoDB 提供 find 方法查找文档，第一个参数为查询条件： > db.newCollection.find() # 查找所有文档 { \"_id\" : ObjectId(\"5cc1026533907ae66490e46c\"), \"x\" : 1 } { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } > db.newCollection.find({name:\"wmyskxz\"}) # 查找 name 为 wmyskxz 的文档 { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } > db.newCollection.find({age:{$gt:20}}) # 查找 age 大于 20 的文档 { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } 上述代码中的$gt对应于大于号&gt;的转义。 第二个参数可以传入投影文档映射数据： > db.newCollection.find({age:{$gt:20}},{name:1}) { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\" } 上述命令将查找 age 大于 20 的文档，返回 name 字段，排除其他字段。投影文档中字段为 1 或其他真值表示包含，0 或假值表示排除，可以设置多个字段位为 1 或 0，但不能混合使用。 为了测试，我们为这个集合弄了一些奇奇怪怪的数据： > db.newCollection.find() { \"_id\" : ObjectId(\"5cc1026533907ae66490e46c\"), \"x\" : 1 } { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"name\" : \"wmyskxz-test\", \"age\" : 22, \"x\" : 1, \"y\" : 30 } 然后再来测试： > db.newCollection.find({age:{$gt:20}},{name:1,x:1}) { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\" } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"name\" : \"wmyskxz-test\", \"x\" : 1 } > db.newCollection.find({age:{$gt:20}},{name:0,x:0}) { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"age\" : 22 } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"age\" : 22, \"y\" : 30 } > db.newCollection.find({age:{$gt:20}},{name:0,x:1}) Error: error: { \"ok\" : 0, \"errmsg\" : \"Projection cannot have a mix of inclusion and exclusion.\", \"code\" : 2, \"codeName\" : \"BadValue\" } 从上面的命令我们就可以把我们的一些想法和上面的结论得以验证，perfect！ 除此之外，还可以通过 count、skip、limit 等指针（Cursor）方法，改变文档查询的执行方式： > db.newCollection.find().count() 3 > db.newCollection.find().skip(1).limit(10).sort({age:1}) { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"name\" : \"wmyskxz-test\", \"age\" : 22, \"x\" : 1, \"y\" : 30 } 上述查找命令跳过 1 个文档，限制输出 10 个，以 age 子段正序排序（大于 0 为正序，小于 0 位反序）输出结果。最后，可以使用 Cursor 方法中的 pretty 方法，提升查询文档的易读性，特别是在查看嵌套的文档和配置文件的时候： > db.newCollection.find().pretty() { \"_id\" : ObjectId(\"5cc1026533907ae66490e46c\"), \"x\" : 1 } { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 22 } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"name\" : \"wmyskxz-test\", \"age\" : 22, \"x\" : 1, \"y\" : 30 } 3.2.3 更新（Update）MongoDB 提供 update 方法更新文档： db.collection.updateOne() 更新最多一个符合条件的文档 db.collection.updateMany() 更新所有符合条件的文档 db.collection.replaceOne() 替代最多一个符合条件的文档 db.collection.update() 默认更新一个文档，可配置 multi 参数，跟新多个文档 以 update() 方法为例。其格式： > db.collection.update( , , { upsert: , multi: } ) 各参数意义： query 为查询条件 update 为修改的文档 upsert 为真，查询为空时插入文档 multi 为真，更新所有符合条件的文档 下面我们测试把 name 字段为 wmyskxz 的文档更新一下试试： > db.newCollection.update({name:\"wmyskxz\"},{name:\"wmyskxz\",age:30}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) 要注意的是，如果更新文档只传入 age 字段，那么文档会被更新为{age: 30}，而不是{name:&quot;wmyskxz&quot;, age:30}。要避免文档被覆盖，需要用到 $set 指令，$set 仅替换或添加指定字段： > db.newCollection.update({name:\"wmyskxz\"},{$set:{age:30}}) 如果要在查询的文档不存在的时候插入文档，要把 upsert 参数设置真值： > db.newCollection.update({name:\"wmyskxz11\"},{$set:{age:30}},{upsert:true}) update 方法默认情况只更新一个文档，如果要更新符合条件的所有文档，要把 multi 设为真值，并使用 $set 指令： > db.newCollection.update({age:{$gt:20}},{$set:{test:\"A\"}},{multi:true}) WriteResult({ \"nMatched\" : 3, \"nUpserted\" : 0, \"nModified\" : 3 }) > db.newCollection.find() { \"_id\" : ObjectId(\"5cc1026533907ae66490e46c\"), \"x\" : 1 } { \"_id\" : ObjectId(\"5cc102fb33907ae66490e46d\"), \"name\" : \"wmyskxz\", \"age\" : 30, \"test\" : \"A\" } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"name\" : \"wmyskxz-test\", \"age\" : 22, \"x\" : 1, \"y\" : 30, \"test\" : \"A\" } { \"_id\" : ObjectId(\"5cc110148d0a578f03d43e81\"), \"name\" : \"wmyskxz11\", \"age\" : 30, \"test\" : \"A\" } 3.2.4 删除（Delete）MongoDB 提供了 delete 方法删除文档： db.collection.deleteOne() 删除最多一个符合条件的文档 db.collection.deleteMany() 删除所有符合条件的文档 db.collection.remove() 删除一个或多个文档 以 remove 方法为例： > db.newCollection.remove({name:\"wmyskxz11\"}) > db.newCollection.remove({age:{$gt:20}},{justOne:true}) > db.newCollection.find() { \"_id\" : ObjectId(\"5cc1026533907ae66490e46c\"), \"x\" : 1 } { \"_id\" : ObjectId(\"5cc108fb33907ae66490e46e\"), \"name\" : \"wmyskxz-test\", \"age\" : 22, \"x\" : 1, \"y\" : 30, \"test\" : \"A\" } MongoDB 提供了 drop 方法删除集合，返回 true 表面删除集合成功： > db.newCollection.drop() 3.2.5 小结相比传统关系型数据库，MongoDB 的 CURD 操作更像是编写程序，更符合开发人员的直觉，不过 MongoDB 同样也支持 SQL 语言。MongoDB 的 CURD 引擎配合索引技术、数据聚合技术和 JavaScript 引擎，赋予 MongoDB 用户更强大的操纵数据的能力。 参考文章：简明 MongoDB 入门教程 - https://segmentfault.com/a/1190000010556670 4 MongoDB 数据模型的一些讨论 前置申明：这一部分基于以下链接整理 https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md#%E8%AE%B8%E5%8F%AF%E8%AF%81 这是一个抽象的话题，与大多数NoSQL方案相比,在建模方面,面向文档的数据库算是和关系数据库相差最小的。这些差别是很小，但是并不是说不重要。 4.1 没有连接（Join）您要接受的第一个也是最基本的一个差别，就是 MongoDB 没有连接（join）。我不知道MongoDB不支持某些类型连接句法的具体原因，但是我知道一般而言人们认为连接是不可扩展的。也就是说，一旦开始横向分割数据，最终不可避免的就是在客户端（应用程序服务器）使用连接。且不论MongoDB为什么不支持连接，事实是数据是有关系的，可是MongoDB不支持连接。（译者：这里的关系指的是不同的数据之间是有关联的，对于没有关系的数据，就完全不需要连接。） 为了在没有连接的MongoDB中生存下去，在没有其他帮助的情况下，我们必须在自己的应用程序中实现连接。 基本上我们需要用第二次查询去找到相关的数据。找到并组织这些数据相当于在关系数据库中声明一个外来的键。现在先别管什么独角兽了，我们来看看我们的员工。首先我们创建一个员工的数据（这次我告诉您具体的_id值，这样我们的例子就是一样的了）： db.employees.insert({_id: ObjectId(\"4d85c7039ab0fd70a117d730\"), name: 'Leto'}) 然后我们再加入几个员工并把 Leto 设成他们的老板： db.employees.insert({_id: ObjectId(\"4d85c7039ab0fd70a117d731\"), name: 'Duncan', manager: ObjectId(\"4d85c7039ab0fd70a117d730\")}); db.employees.insert({_id: ObjectId(\"4d85c7039ab0fd70a117d732\"), name: 'Moneo', manager: ObjectId(\"4d85c7039ab0fd70a117d730\")}); （有必要再强调一下，_id可以是任何的唯一的值。在实际工作中你很可能会用到ObjectId， 所以我们在这里也使用它） 显然，要找到Leto的所有员工，只要执行： db.employees.find({manager: ObjectId(\"4d85c7039ab0fd70a117d730\")}) 没什么了不起的。在最糟糕的情况下，为弥补连接的缺失需要做的只是再多查询一次而已，该查询很可能是经过索引了的。 4.1.1 数组和嵌入文档（Embedded Documents）MongoDB 没有连接并不意味着它没有其他的优势。还记得我们曾说过 MongoDB 支持数组并把它当成文档中的一级对象吗？当处理多对一或是多对多关系的时候，这一特性就显得非常好用了。用一个简单的例子来说明，如果一个员工有两个经理，我们可以把这个关系储存在一个数组当中： ({name: 'Siona', manager: [ObjectId(\"4d85c7039ab0fd70a117d730\"), ObjectId(\"4d85c7039ab0fd70a117d732\")] }) 需要注意的是，在这种情况下，有些文档中的 manager 可能是一个向量，而其他的却是数组。在两种情况下，前面的 find 还是一样可以工作： db.employees.find({manager: ObjectId(\"4d85c7039ab0fd70a117d730\")}) 很快您就会发现数组中的值比起多对多的连接表（join-table）来说要更容易处理。 除了数组，MongoDB 还支持嵌入文档。尝试插入含有内嵌文档的文档，像这样： db.employees.insert({_id: ObjectId(\"4d85c7039ab0fd70a117d734\"), name: 'Ghanima', family: {mother: 'Chani', father: 'Paul', brother: ObjectId(\"4d85c7039ab0fd70a117d730\")}}) 也许您会这样想，确实也可以这样做：嵌入文档可以用‘.’符号来查询： db.employees.find({'family.mother': 'Chani'}) 就这样，我们简要地介绍了嵌入文档适用的场合以及您应该怎样使用它。 4.1.2 DBRefMongoDB 支持一个叫做 DBRef 的功能，许多 MongoDB 的驱动都提供对这一功能的支持。当驱动遇到一个 DBRef 时它会把当中引用的文档读取出来。DBRef 包含了所引用的文档的 ID 和所在的集合。它通常专门用于这样的场合：相同集合中的文档需要引用另外一个集合中的不同文档。例如，文档 1 的 DBRef 可能指向 managers 中的文档，而文档 2 中的 DBRef 可能指向 employees 中的文档。 4.1.3 范规范化（Denormalization）代替连接的另一种方法就是反规范化数据。在过去，反规范化是为性能敏感代码所设，或者是需要数据快照（例如审计日志）的时候才应用的。然而，随着NoSQL的日渐普及，有许多这样的数据库并不提供连接操作，于是作为规范建模的一部分，反规范化就越来越常见了。这样说并不是说您就需要为每个文档中的每一条信息创建副本。与此相反，与其在设计的时候被复制数据的担忧牵着走，还不如按照不同的信息应该归属于相应的文档这一思路来对数据建模。 比如说，假设您在编写一个论坛的应用程序。把一个 user 和一篇 post 关联起来的传统方法是在 posts 中加入一个 userid 的列。这样的模型中，如果要显示 posts 就不得不读取（连接）users。一种简单可行的替代方案就是直接把 name 和 userid 存储在 post 中。您甚至可以用嵌入文档来实现，比如说 user: {id: ObjectId(&#39;Something&#39;), name: &#39;Leto&#39;}。当然，如果允许用户更改他们的用户名，那么每当有用户名修改的时候，您就需要去更新所有的文档了（这需要一个额外的查询）。 对一些人来说改用这种方法并非易事。甚至在一些情况下根本行不通。不过别不敢去尝试这种方法：有时候它不仅可行，而且就是正确的方法。 4.1.4 应该选择哪一种？当处理一对多或是多对多问题的时候，采用id数组往往都是正确的策略。可以这么说，DBRef 并不是那么常用，虽然您完全可以试着采用这项技术。这使得新手们在面临选择嵌入文档还是手工引用（manual reference）时犹豫不决。 首先，要知道目前一个单独的文档的大小限制是 4MB，虽然已经比较大了。了解了这个限制可以为如何使用文档提供一些思路。目前看来多数的开发者还是大量地依赖手工引用来维护数据的关系。嵌入文档经常被使用，but mostly for small pieces of data which we want to always pull with the parent document。一个真实的例子，我把 accounts 文档嵌入存储在用户的文档中，就像这样： db.users.insert({name: 'leto', email: 'leto@dune.gov', account: {allowed_gholas: 5, spice_ration: 10}}) 这不是说您就应该低估嵌入文档的作用，也不是说应该把它当成是鲜少用到的工具并直接忽略。将数据模型直接映射到目标对象上可以使问题变得更加简单，也往往因此而不再需要连接操作。当您知道 MongoDB 允许对嵌入文档的域进行查询并做索引后，这个说法就尤其显得正确了。 4.2 集合：少一些还是多一些？既然集合不强制使用模式，那么就完全有可能用一个单一的集合以及一个不匹配的文档构建一个系统。以我所见过的情况，大部分的 MongoDB 系统都像您在关系数据库中所见到的那样布局。换句话说，如果在关系数据库中会用表，那么很有可能在 MongoDB 中就要用集合（多对多连接表在这里是一个不可忽视的例外） 当把嵌入文档引进来的时候，讨论就会变得更加有意思了。最常见的例子就是博客系统。是应该分别维护 posts 和 comments 两个集合，还是在每个 post 中嵌入一个 comments 数组？暂且不考虑那个 4MB 的限制（哈姆雷特所有的评论也不超过200KB，谁的博客会比他更受欢迎？），大多数的开发者还是倾向于把数据划分开。因为这样既简洁又明确。 没有什么硬性的规定（呃，除了 4MB 的限制）。做了不同的尝试之后您就可以凭感觉知道怎样做是对的了。 总结至此已经对 MongoDB 有了一个基本的了解和入门，但是要运用在实际的项目中仍然有许多实践需要自己去完成 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"MongoDB","slug":"后端/中间件/MongoDB","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Elasticsearch【快速入门】","slug":"Elasticsearch【快速入门】","date":"2019-01-07T23:19:00.000Z","updated":"2020-12-09T05:02:31.592Z","comments":true,"path":"2019/01/08/elasticsearch-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2019/01/08/elasticsearch-kuai-su-ru-men/","excerpt":"","text":"前言：毕设项目还要求加了这个做大数据搜索，正好自己也比较感兴趣，就一起来学习学习吧！ Elasticsearch 简介Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。 查询保持好奇心。从数据中探寻各种问题的答案。 通过 Elasticsearch，您能够执行及合并多种类型的搜索（结构化数据、非结构化数据、地理位置、指标），搜索方式随心而变。先从一个简单的问题出发，试试看能够从中发现些什么。 分析大处着眼，全局在握。 找到与查询最匹配的十个文档是一回事。但如果面对的是十亿行日志，又该如何解读呢？Elasticsearch 聚合让您能够从大处着眼，探索数据的趋势和模式。 速度 可扩展性 弹性 灵活性 操作的乐趣 客户端库使用您自己的编程语言与 Elasticsearch 进行交互 Elasticsearch 使用的是标准的 RESTful 风格的 API 和 JSON。此外，我们还构建和维护了很多其他语言的客户端，例如 Java、Python、.NET、SQL 和 PHP。与此同时，我们的社区也贡献了很多客户端。这些客户端使用起来简单自然，而且就像 Elasticsearch 一样，不会对您的使用方式进行限制。 Java： RestHighLevelClient client = new RestHighLevelClient(RestClient.builder( new HttpHost(\"localhost\", 9200, \"http\"))); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); searchSourceBuilder.query(QueryBuilders.matchAllQuery()); searchSourceBuilder.aggregation(AggregationBuilders.terms(\"top_10_states\").field(\"state\").size(10)); SearchRequest searchRequest = new SearchRequest(); searchRequest.indices(\"social-*\"); searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = client.search(searchRequest); 尽享强大功能 HADOOP 和 SPRAK 照例来说应该是去扒官网，结果一搜就惊了，这官网也忒得劲儿了吧，竟然提供中文版本而且还有中文版本的文档，友好友好，我看了好长一会儿才反应过来自己还有博客要写.咳咳，上面的内容都是摘自官网顺便附一个官网链接：https://www.elastic.co/cn/products/elasticsearch 另外还有一个关于 Elasticsearch 来源很有趣的故事在这里分享一下： 回忆时光 许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。 直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。 后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。 第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。 据说，Shay 的妻子还在等着她的食谱搜索引擎… 安装 Elasticsearch官网最新版本 Elasticsearch （6.5.4），但是由于自己的环境使用最新版本的有问题（配合下面的工具 Kibana 有问题..Kibana 启动不了），所以不得不换成更低版本的 6.2.2，下载外链：戳这里，当然你也可以试一下最新的版本： 顺带一提：在下载之前你应该确保你的 Java 版本保持在 1.8 及以上（就 1.8 吧..），这是 Elasticsearch 的硬性要求，可以自行打开命令行输入 java -version 来查看 Java 的版本 下载完成后，可以看到是一个压缩包，我们直接解压在 D 盘上，然后打开 bin 目录下的 elasticsearch.bat 文件 等待一段时间后，可以看到小黑框输出一行 start ，就说明我们的 Elasticsearch 已经跑起来了，我们访问地址：http://127.0.0.1:9200/，看到返回一串 JSON 格式的代码就说明已经成功了： 安装 Kibana这是一个官方推出的把 Elasticsearch 数据可视化的工具，官网在这里：【传送门】，不过我们现在暂时还用不到那些数据分析的东西，不过里面有一个 Dev Tools 的工具可以方便的和 Elasticsearch 服务进行交互，去官网下载了最新版本的 Kibana（6.5.4） 结果不知道为什么总是启动不起来，所以换一了一个低版本的（6.2.2）正常，给个下载外链：下载点这里，你们也可以去官网试试能不能把最新的跑起来： 解压到 D 盘（意外的有点慢..），同样打开目录下的bin\\kibana.bat： 等待一段时间后就可以看到提示信息，运行在 5601 端口，我们访问地址 http://localhost:5601/app/kibana#/dev_tools/console?_g=() 可以成功进入到 Dev-tools 界面： 点击 【Get to work】，然后在控制台输入 GET /_cat/health?v 查看服务器状态，可以在右侧返回的结果中看到 green 即表示服务器状态目前是健康的： 快速入门一、基础概念-快速入门节点 Node、集群 Cluster 和分片 ShardsElasticSearch 是分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个实例。单个实例称为一个节点（node），一组节点构成一个集群（cluster）。分片是底层的工作单元，文档保存在分片内，分片又被分配到集群内的各个节点里，每个分片仅保存全部数据的一部分。 索引 Index、类型 Type 和文档 Document对比我们比较熟悉的 MySQL 数据库： index → dbtype → tabledocument → row 如果我们要访问一个文档元数据应该包括囊括 index/type/id 这三种类型，很好理解。 二、使用 RESTful API 与 Elasticsearch 进行交互所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成： curl -X&lt;VERB&gt; &#39;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#39; -d &#39;&lt;BODY&gt;&#39; 被 &lt; &gt; 标记的部件： 部件名 作用 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE。 PROTOCOL http 或者 https（如果你在 Elasticsearch 前面有一个 https 代理） HOST Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm 。 QUERY_STRING 任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读) BODY 一个 JSON 格式的请求体 (如果请求需要的话) 就比如计算集群中文档的数量，我们可以用这个: curl -XGET 'http://localhost:9200/_count?pretty' -d ' { \"query\": { \"match_all\": {} } } ' 不过对于安装了 Kibana 的我们，可以直接在 Kibana 的控制台输出以下语句，也是同样的效果： GET /_count?pretty { \"query\": { \"match_all\": {} } } 文档管理（CRUD）如果对于 RESTful 不太熟悉的童鞋请右转：【传送门】 增加： POST /db/user/1 { \"username\": \"wmyskxz1\", \"password\": \"123456\", \"age\": \"22\" } POST /db/user/2 { \"username\": \"wmyskxz2\", \"password\": \"123456\", \"age\": \"22\" } 这一段代码稍微解释一下，这其实就往索引为 db 类型为 user 的数据库中插入一条 id 为 1 的一条数据，这条数据其实就相当于一个拥有 username/password/age 三个属性的一个实体，就是 JSON 数据 执行命令后，Elasticsearch 返回如下数据： # POST /db/user/1 { \"_index\": \"db\", \"_type\": \"user\", \"_id\": \"1\", \"_version\": 1, \"result\": \"created\", \"_shards\": { \"total\": 2, \"successful\": 1, \"failed\": 0 }, \"_seq_no\": 2, \"_primary_term\": 1 } # POST /db/user/2 { \"_index\": \"db\", \"_type\": \"user\", \"_id\": \"2\", \"_version\": 1, \"result\": \"created\", \"_shards\": { \"total\": 2, \"successful\": 1, \"failed\": 0 }, \"_seq_no\": 1, \"_primary_term\": 1 } version 是版本号的意思，当我们执行操作会自动加 1 删除： DELETE /db/user/1 Elasticsearch 返回数据如下： { \"_index\": \"db\", \"_type\": \"user\", \"_id\": \"1\", \"_version\": 2, \"result\": \"deleted\", \"_shards\": { \"total\": 2, \"successful\": 1, \"failed\": 0 }, \"_seq_no\": 1, \"_primary_term\": 1 } 这里就可以看到 version 变成了 2 修改： PUT /db/user/2 { \"username\": \"wmyskxz3\", \"password\": \"123456\", \"age\": \"22\" } Elasticsearch 返回数据如下： { \"_index\": \"db\", \"_type\": \"user\", \"_id\": \"2\", \"_version\": 2, \"result\": \"updated\", \"_shards\": { \"total\": 2, \"successful\": 1, \"failed\": 0 }, \"_seq_no\": 2, \"_primary_term\": 1 } 查询： GET /db/user/2 返回数据如下： { \"_index\": \"db\", \"_type\": \"user\", \"_id\": \"2\", \"_version\": 2, \"found\": true, \"_source\": { \"username\": \"wmyskxz3\", \"password\": \"123456\", \"age\": \"22\" } } 搜索上面我们已经演示了基本的文档 CRUD 功能，然而 Elasticsearch 的核心功能是搜索，所以在学习之前，为更好的演示这个功能，我们先往 Elasticsearch 中插入一些数据： PUT /movies/movie/1 { \"title\": \"The Godfather\", \"director\": \"Francis Ford Coppola\", \"year\": 1972, \"genres\": [ \"Crime\", \"Drama\" ] } PUT /movies/movie/2 { \"title\": \"Lawrence of Arabia\", \"director\": \"David Lean\", \"year\": 1962, \"genres\": [ \"Adventure\", \"Biography\", \"Drama\" ] } PUT /movies/movie/3 { \"title\": \"To Kill a Mockingbird\", \"director\": \"Robert Mulligan\", \"year\": 1962, \"genres\": [ \"Crime\", \"Drama\", \"Mystery\" ] } PUT /movies/movie/4 { \"title\": \"Apocalypse Now\", \"director\": \"Francis Ford Coppola\", \"year\": 1979, \"genres\": [ \"Drama\", \"War\" ] } PUT /movies/movie/5 { \"title\": \"Kill Bill: Vol. 1\", \"director\": \"Quentin Tarantino\", \"year\": 2003, \"genres\": [ \"Action\", \"Crime\", \"Thriller\" ] } PUT /movies/movie/6 { \"title\": \"The Assassination of Jesse James by the Coward Robert Ford\", \"director\": \"Andrew Dominik\", \"year\": 2007, \"genres\": [ \"Biography\", \"Crime\", \"Drama\" ] } _search端点 现在已经把一些电影信息放入了索引，可以通过搜索看看是否可找到它们。 为了使用 ElasticSearch 进行搜索，我们使用 _search 端点，可选择使用索引和类型。也就是说，按照以下模式向URL发出请求：&lt;index&gt;/&lt;type&gt;/_search。其中，index 和 type 都是可选的。 换句话说，为了搜索电影，可以对以下任一URL进行POST请求： http://localhost:9200/_search - 搜索所有索引和所有类型。 http://localhost:9200/movies/_search - 在电影索引中搜索所有类型 http://localhost:9200/movies/movie/_search - 在电影索引中显式搜索电影类型的文档。 搜索请求正文和ElasticSearch查询DSL 如果只是发送一个请求到上面的URL，我们会得到所有的电影信息。为了创建更有用的搜索请求，还需要向请求正文中提供查询。 请求正文是一个JSON对象，除了其它属性以外，它还要包含一个名称为 “query” 的属性，这就可使用ElasticSearch的查询DSL。 { \"query\": { //Query DSL here } } 你可能想知道查询DSL是什么。它是ElasticSearch自己基于JSON的域特定语言，可以在其中表达查询和过滤器。你可以把它简单同SQL对应起来，就相当于是条件语句吧。 基本自由文本搜索： 查询DSL具有一长列不同类型的查询可以使用。 对于“普通”自由文本搜索，最有可能想使用一个名称为“查询字符串查询”。 查询字符串查询是一个高级查询，有很多不同的选项，ElasticSearch将解析和转换为更简单的查询树。如果忽略了所有的可选参数，并且只需要给它一个字符串用于搜索，它可以很容易使用。 现在尝试在两部电影的标题中搜索有“kill”这个词的电影信息： GET /_search { \"query\": { \"query_string\": { \"query\": \"kill\" } } } 执行上面的请求并查看结果，如下所示 - 正如预期的，得到两个命中结果，每个电影的标题中都带有“kill”单词。再看看另一种情况，在特定字段中搜索。 指定搜索的字段 在前面的例子中，使用了一个非常简单的查询，一个只有一个属性 “query” 的查询字符串查询。 如前所述，查询字符串查询有一些可以指定设置，如果不使用，它将会使用默认的设置值。 这样的设置称为“fields”，可用于指定要搜索的字段列表。如果不使用“fields”字段，ElasticSearch查询将默认自动生成的名为 “_all” 的特殊字段，来基于所有文档中的各个字段匹配搜索。 为了做到这一点，修改以前的搜索请求正文，以便查询字符串查询有一个 fields 属性用来要搜索的字段数组： GET /_search { \"query\": { \"query_string\": { \"query\": \"ford\", \"fields\": [ \"title\" ] } } } 执行上面查询它，看看会有什么结果(应该只匹配到 1 行数据)： 正如预期的得到一个命中，电影的标题中的单词“ford”。现在，从查询中移除fields属性，应该能匹配到 3 行数据： 过滤前面已经介绍了几个简单的自由文本搜索查询。现在来看看另一个示例，搜索 “drama”，不明确指定字段，如下查询 - GET /_search { \"query\": { \"query_string\": { \"query\": \"drama\" } } } 因为在索引中有五部电影在 _all 字段(从类别字段)中包含单词 “drama”，所以得到了上述查询的 5 个命中。 现在，想象一下，如果我们想限制这些命中为只是 1962 年发布的电影。要做到这点，需要应用一个过滤器，要求 “year” 字段等于 1962。要添加过滤器，修改搜索请求正文，以便当前的顶级查询(查询字符串查询)包含在过滤的查询中： { \"query\": { \"filtered\": { \"query\": { \"query_string\": { \"query\": \"drama\" } }, \"filter\": { //Filter to apply to the query } } } } 过滤的查询是具有两个属性(query和filter)的查询。执行时，它使用过滤器过滤查询的结果。要完成这样的查询还需要添加一个过滤器，要求year字段的值为1962。 ElasticSearch查询DSL有各种各样的过滤器可供选择。对于这个简单的情况，某个字段应该匹配一个特定的值，一个条件过滤器就能很好地完成工作。 \"filter\": { \"term\": { \"year\": 1962 } } 完整的搜索请求如下所示： GET /_search { \"query\": { \"filtered\": { \"query\": { \"query_string\": { \"query\": \"drama\" } }, \"filter\": { \"term\": { \"year\": 1962 } } } } } 当执行上面请求，只得到两个命中，这个两个命中的数据的 year 字段的值都是等于 1962。 无需查询即可进行过滤 在上面的示例中，使用过滤器限制查询字符串查询的结果。如果想要做的是应用一个过滤器呢？ 也就是说，我们希望所有电影符合一定的标准。 在这种情况下，我们仍然在搜索请求正文中使用 “query” 属性。但是，我们不能只是添加一个过滤器，需要将它包装在某种查询中。 一个解决方案是修改当前的搜索请求，替换查询字符串 query 过滤查询中的 match_all 查询，这是一个查询，只是匹配一切。类似下面这个： GET /_search { \"query\": { \"filtered\": { \"query\": { \"match_all\": {} }, \"filter\": { \"term\": { \"year\": 1962 } } } } } 另一个更简单的方法是使用常数分数查询： GET /_search { \"query\": { \"constant_score\": { \"filter\": { \"term\": { \"year\": 1962 } } } } } 参考文章：Elasticsearch入门教程、Elasticsearch官方文档、 ElasticSearch 快速上手学习入门教程 三、集成 SpringBoot 简单示例第一步：新建 SpringBoot 项目pom包依赖： &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- Elasticsearch支持 --> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-elasticsearch&lt;/artifactId> &lt;/dependency> application.properties： spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 第二步：新建实体类User类： @Document(indexName = \"users\", type = \"user\") public class User { private int id; private String username; private String password; private int age; /** getter and setter */ } 第三步：Dao 层UserDao： import com.wmyskxz.demo.domain.User; import org.springframework.data.elasticsearch.repository.ElasticsearchRepository; public interface UserDao extends ElasticsearchRepository&lt;User, Integer> { } 第四步：Controller 层这里紧紧是为了演示，所以就省略 service 层，当然 CRUD 不能少： @RestController public class UserController { @Autowired UserDao userDao; @PostMapping(\"/addUser\") public String addUser(String username, String password, Integer age) { User user = new User(); user.setUsername(username); user.setPassword(password); user.setAge(age); return String.valueOf(userDao.save(user).getId());// 返回id做验证 } @DeleteMapping(\"/deleteUser\") public String deleteUser(Integer id) { userDao.deleteById(id); return \"Success!\"; } @PutMapping(\"/updateUser\") public String updateUser(Integer id, String username, String password, Integer age) { User user = new User(); user.setId(id); user.setUsername(username); user.setPassword(password); user.setAge(age); return String.valueOf(userDao.save(user).getId());// 返回id做验证 } @GetMapping(\"/getUser\") public User getUser(Integer id) { return userDao.findById(id).get(); } @GetMapping(\"/getAllUsers\") public Iterable&lt;User> getAllUsers() { return userDao.findAll(); } } 第五步：测试使用 REST 测试工具测试没有问题，过程我就不给了..bingo！ 总结其实使用 SpringBoot 来操作 Elasticsearch 的话使用方法有点类似 JPA 了，而且完全可以把 Elasticsearch 当做 SQL 服务器来用，也没有问题…在各种地方看到了各个大大特别是官方，都快把 Elasticsearch 这款工具吹上天了，对于它方便的集成这一点我倒是有感受，关于速度这方面还没有很深的感受，慢慢来吧… 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Elasticserch","slug":"后端/中间件/Elasticserch","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticserch/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Java消息系统简单设计与实现","slug":"Java消息系统简单设计与实现","date":"2019-01-06T23:17:00.000Z","updated":"2020-12-09T05:06:10.979Z","comments":true,"path":"2019/01/07/java-xiao-xi-xi-tong-jian-dan-she-ji-yu-shi-xian/","link":"","permalink":"http://www.wmyskxz.com/2019/01/07/java-xiao-xi-xi-tong-jian-dan-she-ji-yu-shi-xian/","excerpt":"","text":"前言：由于导师在我的毕设项目里加了消息系统（本来想水水就过的..），没办法…来稍微研究研究吧..简单简单… 需求分析我的毕设是一个博客系统，类似于简书这样的，所以消息系统也类似，在用户的消息里包含了有：喜欢和赞、评论、关注、私信这样的一类东西，这样的一个系统应该包含以下的功能： 当用户评论/关注/点赞时能够通知到被评论/关注/点赞的用户，并生成像如下格式的提示信息（允许取消关注/点赞但不收到通知）： 我没有 关注了 你三颗 喜欢了你的文章 《Java消息系统简单设计与实现》心脏 评论了你的文章 《Java消息系统简单设计与实现》 用户之间能够发送/接受私信，不需要像QQ那样建立长连接实现实时通信，但刷新列表能看到新消息，并且界面类似QQ聊天界面一左一右，允许删除私信； 管理员能发送通告，其实就像是用管理员的账号给每一个用户发送私信； 可以查看关注的用户最新发表的文章，得到类似推送的效果； 所有消息当然也要标注好消息已读or未读，登录就能得到消息提醒标识好有多少未读消息，像是QQ消息右上角的小红点那样类似； OK，大致就是以上的功能，那么问题来了：这要怎么设计啊？ 进一步分析其实可以根据上面的需求分析，把上面的消息大致可以分为公告（Announcement）、提醒（Remind）、私信（Message）三类，我们可以大致抽象出一个 通知（Notify） 模型： 发送者 接受者 信息类型 动作类型 通知内容 是否已读 消息创建时间 粉丝1号 我没有三颗心脏 提醒 关注 粉丝1号 关注了 你 是 xx:xx:xx 粉丝1号 我没有三颗心脏 提醒 喜欢和赞 粉丝1号 喜欢了你的文章 《Java消息系统简单设计与实现》 是 xx:xx:xx 粉丝1号 我没有三颗心脏 提醒 评论 粉丝1号 评论了你的文章 《Java消息系统简单设计与实现》 是 xx:xx:xx 粉丝2号 我没有三颗心脏 私信 无 你收到了来自 粉丝2号 的 1 条私信 是 xx:xx:xx 上面加了一些数据以便理解，不过话说粉丝1号果然是真爱粉，又关注又喜欢又评论，嘻嘻嘻嘻… emm.这样的模型能够胜任我们的工作吗？我也不知道..不过根据这个模型能够想出大概的这样的创建通知的逻辑： 似乎看上去也没有什么大问题..不过既然消息内容都可以根据动作类型自动生成的了，加上私信和公告的内容因为长度问题也肯定不保存在这张表里的好，所以我们在设计数据库时干脆把通知内容这条去掉不要，当信息类型是公告或者私信时可以根据这条通知的 id 在相应的表中找到相应的数据就可以了，emm..我觉得可以 顺下去想想其实脑中有了一个大概，这样的模型还容易设计和想到，其实主要的问题还是下面的那些 问题一：单表数据大了怎么办？如果当用户量上去到一定量的时候，那么这张 通知表 势必会变得巨大，因为不管是我们的公告、提醒还是私信都会在这个通知表上创建一条数据，到时候就会面临查询慢的问题，问题的答案是：我也不知道.. 所以我们的规定是：不考虑像简书这样超大用户量，能够应付毕设就好啦..简单设计，嘻嘻嘻..不过也不要太不相信MySQL的性能，还是有一定容纳能力的！ 问题二：用户要怎样正确得到自己的未读消息呢？暴力一点方法是，反正通知表里有用户所有的消息，直接读取完，然后通过是否已读字段就能够找到正确的所有未读消息了，这..这么简单吗？ 其实有思考过使用时间或者另建一张保存有最新已读到哪条消息的表，但用户可以选择有一些读有一些不读，这两个似乎都很难达到目的…还是暴力吧 问题三：私信消息该怎么设计？ 发送者 接受者 内容 发送时间 粉丝1号 我没有三颗心脏 我是你的真爱粉啊！我要给你生猴子！ 2019年1月7日11:34:23 我没有三颗心脏 粉丝1号 已阅…下一个… 2019年1月7日11:34:53 就像 QQ消息 一样嘛，包含一个内容、时间、发送者和接受者，然后前端直接根据时间或者 id 排序生成一左一右的消息对话框，不过比较特殊的一点就是私信是一个双向交流的过程，在一个对话框中我可能既是接受者也是发送者，这也无所谓嘛，稍微分析分析场景： 读取私信列表时：按照接受者和发送者一起查询的原则，也就是查询接受者是自己和发送者是自己的数据，然后根据时间和已读未读来建立私信列表； 读取私信时：这时已经有了明确的接受者和发送者，那就查询所有 发送者是对方接受者是自己 Or 发送者是自己接受者是对方 的数据，然后在前端拼凑出一左一右的聊天框； 发送私信时：先查询之前是否有记录，然后同上建立聊天框，点击发送之后把发送方设为自己接收方设为私信对象，然后在通知表中新建一条未读数据通知私信对象有私信来了； 这完全能满足要求，只不过感觉查询多了些.. 数据库设计 简单弄了弄弄..看着挺难受的，不过能简单实现功能，并且为了演示，这里是做了一张user_follow表，表示用户之间的关联关系，点赞和评论与这个类似，就不多弄了..下面给一下建表语句吧： user表： CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `username` varchar(50) NOT NULL COMMENT '用户姓名', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; user_follow表： CREATE TABLE `user_follow` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `uid` bigint(20) NOT NULL COMMENT '用户ID', `follow_uid` bigint(20) NOT NULL COMMENT '关注的用户id', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户关注表,记录了所有用户的关注信息'; notify表： CREATE TABLE `notify` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `sender_id` bigint(20) NOT NULL COMMENT '发送者用户ID', `reciver_id` bigint(20) NOT NULL COMMENT '接受者用户ID', `type` varchar(50) NOT NULL COMMENT '消息类型:announcement公告/remind提醒/message私信', `is_read` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否已读,0未读,1已读', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间:按当前时间自动创建', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户通知表,包含了所有用户的消息'; message表： CREATE TABLE `message` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `notify_id` bigint(20) NOT NULL COMMENT '对应通知消息的id', `sender_id` bigint(20) NOT NULL COMMENT '发送者用户ID', `reciver_id` bigint(20) NOT NULL COMMENT '接受者用户ID', `content` varchar(1000) NOT NULL COMMENT '消息内容,最长长度不允许超过1000', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间:按当前时间自动创建', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='私信信息表,包含了所有用户的私信信息'; 根据《Java开发手册》5.3 第六条 没有使用任何级联和外键，bingo！ Spring Boot + MyBatis 实例第一步：基础环境搭建SpringBoot项目怎么搭就不说了吧，给一给几个关键的配置文件： pom包依赖： &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>1.3.2&lt;/version> &lt;/dependency> &lt;!-- SpringBoot - MyBatis 逆向工程 --> &lt;dependency> &lt;groupId>org.mybatis.generator&lt;/groupId> &lt;artifactId>mybatis-generator-core&lt;/artifactId> &lt;version>1.3.6&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>5.1.18&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> 这里有一个巨坑，耗费了我好半天的时间，不知道为什么我明明引入的 5.1.18 版本的 mysql-connector-java，可 Maven 就是非要给我比较新版本的 8.0.13，这导致了在我使用 MyBatis 逆向工程生成 domain 和 mapper 的过程中出现了以下的问题： 1、提示我数据库连接的驱动名称需要改成com.mysql.cj.jdbc.Driver而不是之前的com.mysql.jdbc.Driver，不然就报错： Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 2、还需要设置 mysql 的时区，也就是需要将connectionURL属性写成&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&quot;。如果不指定serverTimezone=UTC（还必须大写），将报错： java.sql.SQLException: The server time zone value ‘?й???????’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.&emsp;&emsp;at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:695)&emsp;&emsp;at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:663) 3、逆向工程会去找 MySQL 其他库的相同表名的表，然后生成一堆乱七八糟的东西，还由于找不到主键 id 生成了只含 inser() 方法而不含删除、更新方法的 Mapper 文件； 解决方法就只有自己手动去调低 mysql-connector-java 的版本到 5.xx，还找到一个跟我情况类似：https://blog.csdn.net/angel_xiaa/article/details/52474022 application.properties： ## 数据库连接配置 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://127.0.0.1:3306/message_system?characterEncoding=UTF-8 spring.datasource.username=root spring.datasource.password=123456 ## MyBatis相关配置 mybatis.type-aliases-package=com.wmyskxz.demo.messagesystem.domain mybatis.mapper-locations=classpath:mapper/*.xml 在启动类上加上注解： @EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /> @MapperScan(\"com.wmyskxz.demo.messagesystem.dao\") @SpringBootApplication public class MessageSystemApplication { .... } 第二步：MyBatis 逆向工程新建【util】包，在下面新建两个类： MybatisGenerator类： public class MybatisGenerator { public static void main(String[] args) throws Exception { String today = \"2019-1-7\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date now = sdf.parse(today); Date d = new Date(); if (d.getTime() > now.getTime() + 1000 * 60 * 60 * 24) { System.err.println(\"——————未成成功运行——————\"); System.err.println(\"——————未成成功运行——————\"); System.err.println(\"本程序具有破坏作用，应该只运行一次，如果必须要再运行，需要修改today变量为今天，如:\" + sdf.format(new Date())); return; } if (false) return; List&lt;String> warnings = new ArrayList&lt;String>(); boolean overwrite = true; InputStream is = MybatisGenerator.class.getClassLoader().getResource(\"generatorConfig.xml\").openStream(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(is); is.close(); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); System.out.println(\"生成代码成功，只能执行一次，以后执行会覆盖掉mapper,pojo,xml 等文件上做的修改\"); } } OverIsMergeablePlugin类： /** * 解決 MyBatis 逆向工程重复生成覆盖问题的工具类 */ public class OverIsMergeablePlugin extends PluginAdapter { @Override public boolean validate(List&lt;String> warnings) { return true; } @Override public boolean sqlMapGenerated(GeneratedXmlFile sqlMap, IntrospectedTable introspectedTable) { try { Field field = sqlMap.getClass().getDeclaredField(\"isMergeable\"); field.setAccessible(true); field.setBoolean(sqlMap, false); } catch (Exception e) { e.printStackTrace(); } return true; } } 在【resrouces】资源文件下新建逆向工程配置文件【generatorConfig.xml】： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"> &lt;generatorConfiguration> &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"> &lt;!--避免生成重复代码的插件--> &lt;plugin type=\"com.wmyskxz.demo.messagesystem.util.OverIsMergeablePlugin\"/> &lt;!-- 是否去除自动生成的代码中的注释 true：是 false：否--> &lt;commentGenerator> &lt;property name=\"suppressDate\" value=\"true\"/> &lt;property name=\"suppressAllComments\" value=\"true\"/> &lt;/commentGenerator> &lt;!--数据库链接地址账号密码--> &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/message_system?serverTimezone=UTC\" userId=\"root\" password=\"123456\"> &lt;/jdbcConnection> &lt;!-- 默认 false，把 JDBC DECIMAL 和 NUMERIC 类型解析为 Integer 为 true 时解析为 java.math.BigDecimal --> &lt;javaTypeResolver> &lt;property name=\"forceBigDecimals\" value=\"false\"/> &lt;/javaTypeResolver> &lt;!--生成pojo类存放位置--> &lt;javaModelGenerator targetPackage=\"com.wmyskxz.demo.messagesystem.domain\" targetProject=\"src/main/java\"> &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--> &lt;property name=\"enableSubPackages\" value=\"true\"/> &lt;!-- trimStrings：从数据库返回的值被清理前后的空格 --> &lt;property name=\"trimStrings\" value=\"true\"/> &lt;!-- 是否对model添加 构造函数 --> &lt;property name=\"constructorBased\" value=\"true\"/> &lt;/javaModelGenerator> &lt;!--生成xml映射文件存放位置--> &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"> &lt;property name=\"enableSubPackages\" value=\"true\"/> &lt;/sqlMapGenerator> &lt;!--生成mapper类存放位置--> &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.wmyskxz.demo.messagesystem.dao\" targetProject=\"src/main/java\"> &lt;property name=\"enableSubPackages\" value=\"true\"/> &lt;/javaClientGenerator> &lt;!--生成对应表及类名 tableName:要生成的表名 domainObjectName:生成后的实例名 enableCountByExample:Count语句中加入where条件查询，默认为true开启 enableUpdateByExample:Update语句中加入where条件查询，默认为true开启 enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启 enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启 selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启 --> &lt;table tableName=\"user\" domainObjectName=\"User\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\" enableDeleteByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"false\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"notify\" domainObjectName=\"Notify\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\" enableDeleteByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"false\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"user_follow\" domainObjectName=\"UserFollow\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\" enableDeleteByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"false\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"message\" domainObjectName=\"Message\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\" enableDeleteByPrimaryKey=\"true\" enableUpdateByPrimaryKey=\"true\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"false\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;/context> &lt;/generatorConfiguration> 运行我们的【MybatisGenerator】类中的 main 方法就能看到自动生成的实体、Xml文件以及 Mapper 类 第三步：Service 层不给接口了，直接给实现吧，方法都很简单，而且没有做任何的安全限制，只是为了实现简单的消息系统，看效果 UserServiceImpl： @Service public class UserServiceImpl implements UserService { @Resource UserMapper userMapper; @Override public void addUserByUsername(String username) { userMapper.insert(new User(null, username));// 主键自增长. } @Override public User findUserById(Long id) { return userMapper.selectByPrimaryKey(id); } } UserFollowServiceImpl： @Service public class UserFollowServiceImpl implements UserFollowService { @Resource UserFollowMapper userFollowMapper; @Autowired NotifyService notifyService; @Override public void userAFollowUserBById(Long userAId, Long userBId) { // 先要创建一条提示消息 notifyService.addNotify(userAId, userBId, \"follow\");// 关注信息 UserFollow userFollow = new UserFollow(); userFollow.setUid(userAId); userFollow.setFollowUid(userBId); userFollowMapper.insertSelective(userFollow); } @Override public void userAUnfollowUserBById(Long userAId, Long userBId) { // 首先查询到相关的记录 UserFollowExample example = new UserFollowExample(); example.or().andUidEqualTo(userAId).andFollowUidEqualTo(userBId); UserFollow userFollow = userFollowMapper.selectByExample(example).get(0); // 删除关注数据 userFollowMapper.deleteByPrimaryKey(userFollow.getId()); } } NotifyServiceImpl： @Service public class NotifyServiceImpl implements NotifyService { @Resource NotifyMapper notifyMapper; @Override public int addNotify(Long senderId, Long reciverId, String type) { Notify notify = new Notify(null, senderId, reciverId, type, false, null); return notifyMapper.insertSelective(notify);// id和creatTime自动生成. } @Override public void readNotifyById(Long id) { Notify notify = notifyMapper.selectByPrimaryKey(id); notify.setIsRead(true); notifyMapper.updateByPrimaryKey(notify); } @Override public List&lt;Notify> findAllNotifyByReciverId(Long id) { List&lt;Notify> notifies = new LinkedList&lt;>(); NotifyExample example = new NotifyExample(); example.setOrderByClause(\"`id` DESC\");// 按id倒叙,也就是第一个数据是最新的. example.or().andReciverIdEqualTo(id); notifies.addAll(notifyMapper.selectByExample(example)); return notifies; } @Override public List&lt;Notify> findAllUnReadNotifyByReciverId(Long id) { List&lt;Notify> notifies = new LinkedList&lt;>(); NotifyExample example = new NotifyExample(); example.setOrderByClause(\"`id` DESC\");// 按id倒叙,也就是第一个数据是最新的. example.or().andReciverIdEqualTo(id).andIsReadEqualTo(false); notifies.addAll(notifyMapper.selectByExample(example)); return notifies; } } MessageServiceImpl： @Service public class MessageServiceImpl implements MessageService { @Resource MessageMapper messageMapper; @Resource NotifyService notifyService; @Override public void addMessage(Long senderId, Long reciverId, String content) { // 先创建一条 notify 数据 Long notifyId = (long) notifyService.addNotify(senderId, reciverId, \"message\");// message表示私信 // 增加一条私信信心 Message message = new Message(null, notifyId, senderId, reciverId, content, null); messageMapper.insertSelective(message);// 插入非空项,id/createTime数据库自动生成 } @Override public void deleteMessageById(Long id) { messageMapper.deleteByPrimaryKey(id); } @Override public Message findMessageByNotifyId(Long id) { // 触发方法时应把消息置为已读 notifyService.readNotifyById(id); MessageExample example = new MessageExample(); example.or().andNotifyIdEqualTo(id); return messageMapper.selectByExample(example).get(0); } } 第四步：Controller 层也很简单，只是为了看效果 UserController： @RestController public class UserController { @Autowired UserService userService; @PostMapping(\"/addUser\") public String addUser(@RequestParam String username) { userService.addUserByUsername(username); return \"Success!\"; } @GetMapping(\"/findUser\") public User findUser(@RequestParam Long id) { return userService.findUserById(id); } } UserFollowController ： @RestController public class UserFollowController { @Autowired UserFollowService userFollowService; @PostMapping(\"/follow\") public String follow(@RequestParam Long userAId, @RequestParam Long userBId) { userFollowService.userAFollowUserBById(userAId, userBId); return \"Success!\"; } @PostMapping(\"/unfollow\") public String unfollow(@RequestParam Long userAId, @RequestParam Long userBId) { userFollowService.userAUnfollowUserBById(userAId, userBId); return \"Success!\"; } } NotifyController ： @RestController public class NotifyController { @Autowired NotifyService notifyService; @PostMapping(\"/addNotify\") public String addNotify(@RequestParam Long senderId, @RequestParam Long reciverId, @RequestParam String type) { notifyService.addNotify(senderId, reciverId, type); return \"Success!\"; } @PostMapping(\"/readNotify\") public String readNotify(@RequestParam Long id) { notifyService.readNotifyById(id); return \"Success!\"; } @GetMapping(\"/listAllNotify\") public List&lt;Notify> listAllNotify(@RequestParam Long id) { return notifyService.findAllNotifyByReciverId(id); } @GetMapping(\"/listAllUnReadNotify\") public List&lt;Notify> listAllUnReadNotify(@RequestParam Long id) { return notifyService.findAllUnReadNotifyByReciverId(id); } } MessageController ： @RestController public class MessageController { @Autowired MessageService messageService; @PostMapping(\"/addMessage\") public String addMessage(@RequestParam Long senderId, @RequestParam Long reciverId, @RequestParam String content) { messageService.addMessage(senderId, reciverId, content); return \"Success!\"; } @DeleteMapping(\"/deleteMessage\") public String deleteMessage(@RequestParam Long id) { messageService.deleteMessageById(id); return \"Success!\"; } @GetMapping(\"/findMessage\") public Message findMessage(@RequestParam Long id) { return messageService.findMessageByNotifyId(id); } } 第五步：测试通过 REST 测试工具，可以看到正确的效果，这里就不给出所有的测试了。 总结以上的项目简单而且没有任何的安全验证，不过能够基本完成我们的需求，还有一些功能没有实现，例如管理员发通告（上面只演示了私信和关注信息），按照上面的系统就直接暴力给每个用户都加一条通知消息，感觉有点自闭..我也不知道怎么设计好..希望有经验的大大能指条路啊！ 其实关于这个简单的系统我查了好多好多资料..把自己都看自闭了，后来我干脆把所有网页都关掉，开始用 JPA 自己开始抽象实体，把各个实体写出来并把所有实体需要的数据啊相互之间的关联关系啊写清楚，然后再从自动生成的数据库中找思路…hhh…要不是我 JPA 不是很熟我觉得用 JPA 就能写出来了，不用 JPA 的原因在于一些数据的懒加载不知道怎么处理，还有就是查询语句太复杂，免不了要浪费一些资源…emmm..说到底还是不是特别懂 JPA，下面给一张复杂的用 JPA 建立的 User 实体吧（随手截的..hhh…很乱..）： 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"Shiro安全框架【快速入门】就这一篇！","slug":"Shiro安全框架【快速入门】就这一篇！","date":"2019-01-05T23:14:00.000Z","updated":"2020-12-09T05:10:39.490Z","comments":true,"path":"2019/01/06/shiro-an-quan-kuang-jia-kuai-su-ru-men-jiu-zhe-yi-pian/","link":"","permalink":"http://www.wmyskxz.com/2019/01/06/shiro-an-quan-kuang-jia-kuai-su-ru-men-jiu-zhe-yi-pian/","excerpt":"","text":"Shiro 简介照例又去官网扒了扒介绍： Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.Apache Shiro™是一个强大且易用的Java安全框架,能够用于身份验证、授权、加密和会话管理。Shiro拥有易于理解的API,您可以快速、轻松地获得任何应用程序——从最小的移动应用程序到最大的网络和企业应用程序。 简而言之，Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。 Shiro能到底能做些什么呢？ 验证用户身份 用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限 在非 Web 或 EJB 容器的环境下可以任意使用Session API 可以响应认证、访问控制，或者 Session 生命周期中发生的事件 可将一个或以上用户安全数据源数据组合成一个复合的用户 “view”(视图) 支持单点登录(SSO)功能 支持提供“Remember Me”服务，获取用户关联信息而无需登录··· 为什么是 Shiro？使用 Shiro 官方给了许多令人信服的原因，因为 Shiro 具有以下几个特点： 易于使用——易用性是项目的最终目标。应用程序安全非常令人困惑和沮丧,被认为是“不可避免的灾难”。如果你让它简化到新手都可以使用它,它就将不再是一种痛苦了。 全面——没有其他安全框架的宽度范围可以同Apache Shiro一样,它可以成为你的“一站式”为您的安全需求提供保障。 灵活——Apache Shiro可以在任何应用程序环境中工作。虽然在网络工作、EJB和IoC环境中可能并不需要它。但Shiro的授权也没有任何规范,甚至没有许多依赖关系。 Web支持——Apache Shiro拥有令人兴奋的web应用程序支持,允许您基于应用程序的url创建灵活的安全策略和网络协议(例如REST),同时还提供一组JSP库控制页面输出。 低耦合——Shiro干净的API和设计模式使它容易与许多其他框架和应用程序集成。你会看到Shiro无缝地集成Spring这样的框架, 以及Grails, Wicket, Tapestry, Mule, Apache Camel, Vaadin…等。 被广泛支持——Apache Shiro是Apache软件基金会的一部分。项目开发和用户组都有友好的网民愿意帮助。这样的商业公司如果需要Katasoft还提供专业的支持和服务。 有兴趣的可以去仔细看看官方的文档：【传送门】 Apache Shiro Features 特性Apache Shiro是一个全面的、蕴含丰富功能的安全框架。下图为描述Shiro功能的框架图： Authentication（认证）, Authorization（授权）, Session Management（会话管理）, Cryptography（加密）被 Shiro 框架的开发团队称之为应用安全的四大基石。那么就让我们来看看它们吧： Authentication（认证）：用户身份识别，通常被称为用户“登录” Authorization（授权）：访问控制。比如某个用户是否具有某个操作的使用权限。 Session Management（会话管理）：特定于用户的会话管理,甚至在非web 或 EJB 应用程序。 Cryptography（加密）：在对数据源使用加密算法加密的同时，保证易于使用。 还有其他的功能来支持和加强这些不同应用环境下安全领域的关注点。特别是对以下的功能支持： Web支持：Shiro的Web支持API有助于保护Web应用程序。 缓存：缓存是Apache Shiro API中的第一级，以确保安全操作保持快速和高效。 并发性：Apache Shiro支持具有并发功能的多线程应用程序。 测试：存在测试支持，可帮助您编写单元测试和集成测试，并确保代码按预期得到保障。 “运行方式”：允许用户承担另一个用户的身份(如果允许)的功能，有时在管理方案中很有用。 “记住我”：记住用户在会话中的身份，所以用户只需要强制登录即可。 注意： Shiro不会去维护用户、维护权限，这些需要我们自己去设计/提供，然后通过相应的接口注入给Shiro High-Level Overview 高级概述在概念层，Shiro 架构包含三个主要的理念：Subject,SecurityManager和 Realm。下面的图展示了这些组件如何相互作用，我们将在下面依次对其进行描述。 Subject：当前用户，Subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它–当前和软件交互的任何事件。 SecurityManager：管理所有Subject，SecurityManager 是 Shiro 架构的核心，配合内部安全组件共同组成安全伞。 Realms：用于进行权限信息的验证，我们自己实现。Realm 本质上是一个特定的安全 DAO：它封装与数据源连接的细节，得到Shiro 所需的相关的数据。在配置 Shiro 的时候，你必须指定至少一个Realm 来实现认证（authentication）和/或授权（authorization）。 我们需要实现Realms的Authentication 和 Authorization。其中 Authentication 是用来验证用户身份，Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。 Shiro 认证过程 上图展示了 Shiro 认证的一个重要的过程，为了加深我们的印象，我们来自己动手来写一个例子，来验证一下，首先我们新建一个Maven工程，然后在pom.xml中引入相关依赖： &lt;dependency> &lt;groupId>org.apache.shiro&lt;/groupId> &lt;artifactId>shiro-core&lt;/artifactId> &lt;version>1.4.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> 新建一个【AuthenticationTest】测试类： import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.mgt.DefaultSecurityManager; import org.apache.shiro.realm.SimpleAccountRealm; import org.apache.shiro.subject.Subject; import org.junit.Before; import org.junit.Test; public class AuthenticationTest { SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); @Before // 在方法开始前添加一个用户 public void addUser() { simpleAccountRealm.addAccount(\"wmyskxz\", \"123456\"); } @Test public void testAuthentication() { // 1.构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(simpleAccountRealm); // 2.主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); // 设置SecurityManager环境 Subject subject = SecurityUtils.getSubject(); // 获取当前主体 UsernamePasswordToken token = new UsernamePasswordToken(\"wmyskxz\", \"123456\"); subject.login(token); // 登录 // subject.isAuthenticated()方法返回一个boolean值,用于判断用户是否认证成功 System.out.println(\"isAuthenticated:\" + subject.isAuthenticated()); // 输出true subject.logout(); // 登出 System.out.println(\"isAuthenticated:\" + subject.isAuthenticated()); // 输出false } } 运行之后可以看到预想中的效果，先输出isAuthenticated:true表示登录认证成功，然后再输出isAuthenticated:false表示认证失败退出登录，再来一张图加深一下印象： 流程如下： 首先调用 Subject.login(token) 进行登录，其会自动委托给 Security Manager，调用之前必须通过 SecurityUtils.setSecurityManager() 设置； SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证； Authenticator 才是真正的身份验证者，Shiro API 中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证； Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回 / 抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。 Shiro 授权过程 跟认证过程大致相似，下面我们仍然通过代码来熟悉一下过程（引入包类似这里节约篇幅就不贴出来了）： public class AuthenticationTest { SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); @Before // 在方法开始前添加一个用户,让它具备admin和user两个角色 public void addUser() { simpleAccountRealm.addAccount(\"wmyskxz\", \"123456\", \"admin\", \"user\"); } @Test public void testAuthentication() { // 1.构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(simpleAccountRealm); // 2.主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); // 设置SecurityManager环境 Subject subject = SecurityUtils.getSubject(); // 获取当前主体 UsernamePasswordToken token = new UsernamePasswordToken(\"wmyskxz\", \"123456\"); subject.login(token); // 登录 // subject.isAuthenticated()方法返回一个boolean值,用于判断用户是否认证成功 System.out.println(\"isAuthenticated:\" + subject.isAuthenticated()); // 输出true // 判断subject是否具有admin和user两个角色权限,如没有则会报错 subject.checkRoles(\"admin\",\"user\"); // subject.checkRole(\"xxx\"); // 报错 } } 运行测试，能够正确看到效果。 自定义 Realm从上面我们了解到实际进行权限信息验证的是我们的 Realm，Shiro 框架内部默认提供了两种实现，一种是查询.ini文件的IniRealm，另一种是查询数据库的JdbcRealm，这两种来说都相对简单，感兴趣的可以去【这里】瞄两眼，我们着重就来介绍介绍自定义实现的 Realm 吧。 有了上面的对认证和授权的理解，我们先在合适的包下创建一个【MyRealm】类，继承 Shirot 框架的 AuthorizingRealm 类，并实现默认的两个方法： package com.wmyskxz.demo.realm; import org.apache.shiro.authc.*; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import java.util.*; public class MyRealm extends AuthorizingRealm { /** * 模拟数据库数据 */ Map&lt;String, String> userMap = new HashMap&lt;>(16); { userMap.put(\"wmyskxz\", \"123456\"); super.setName(\"myRealm\"); // 设置自定义Realm的名称，取什么无所谓.. } /** * 授权 * * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { String userName = (String) principalCollection.getPrimaryPrincipal(); // 从数据库获取角色和权限数据 Set&lt;String> roles = getRolesByUserName(userName); Set&lt;String> permissions = getPermissionsByUserName(userName); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.setStringPermissions(permissions); simpleAuthorizationInfo.setRoles(roles); return simpleAuthorizationInfo; } /** * 模拟从数据库中获取权限数据 * * @param userName * @return */ private Set&lt;String> getPermissionsByUserName(String userName) { Set&lt;String> permissions = new HashSet&lt;>(); permissions.add(\"user:delete\"); permissions.add(\"user:add\"); return permissions; } /** * 模拟从数据库中获取角色数据 * * @param userName * @return */ private Set&lt;String> getRolesByUserName(String userName) { Set&lt;String> roles = new HashSet&lt;>(); roles.add(\"admin\"); roles.add(\"user\"); return roles; } /** * 认证 * * @param authenticationToken 主体传过来的认证信息 * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { // 1.从主体传过来的认证信息中，获得用户名 String userName = (String) authenticationToken.getPrincipal(); // 2.通过用户名到数据库中获取凭证 String password = getPasswordByUserName(userName); if (password == null) { return null; } SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(\"wmyskxz\", password, \"myRealm\"); return authenticationInfo; } /** * 模拟从数据库取凭证的过程 * * @param userName * @return */ private String getPasswordByUserName(String userName) { return userMap.get(userName); } } 然后我们编写测试类，来验证是否正确： import com.wmyskxz.demo.realm.MyRealm; import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.mgt.DefaultSecurityManager; import org.apache.shiro.subject.Subject; import org.junit.Test; public class AuthenticationTest { @Test public void testAuthentication() { MyRealm myRealm = new MyRealm(); // 实现自己的 Realm 实例 // 1.构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(myRealm); // 2.主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); // 设置SecurityManager环境 Subject subject = SecurityUtils.getSubject(); // 获取当前主体 UsernamePasswordToken token = new UsernamePasswordToken(\"wmyskxz\", \"123456\"); subject.login(token); // 登录 // subject.isAuthenticated()方法返回一个boolean值,用于判断用户是否认证成功 System.out.println(\"isAuthenticated:\" + subject.isAuthenticated()); // 输出true // 判断subject是否具有admin和user两个角色权限,如没有则会报错 subject.checkRoles(\"admin\", \"user\"); // subject.checkRole(\"xxx\"); // 报错 // 判断subject是否具有user:add权限 subject.checkPermission(\"user:add\"); } } 运行测试，完美。 Shiro 加密在之前的学习中，我们在数据库中保存的密码都是明文的，一旦数据库数据泄露，那就会造成不可估算的损失，所以我们通常都会使用非对称加密，简单理解也就是不可逆的加密，而 md5 加密算法就是符合这样的一种算法。 如上面的 123456 用 Md5 加密后，得到的字符串：e10adc3949ba59abbe56e057f20f883e，就无法通过计算还原回 123456，我们把这个加密的字符串保存在数据库中，等下次用户登录时我们把密码通过同样的算法加密后再从数据库中取出这个字符串进行比较，就能够知道密码是否正确了，这样既保留了密码验证的功能又大大增加了安全性，但是问题是：虽然无法直接通过计算反推回密码，但是我们仍然可以通过计算一些简单的密码加密后的 Md5 值进行比较，推算出原来的密码 比如我的密码是 123456，你的密码也是，通过 md5 加密之后的字符串一致，所以你也就能知道我的密码了，如果我们把常用的一些密码都做 md5 加密得到一本字典，那么就可以得到相当一部分的人密码，这也就相当于“破解”了一样，所以其实也没有我们想象中的那么“安全”。 加盐 + 多次加密既然相同的密码 md5 一样，那么我们就让我们的原始密码再加一个随机数，然后再进行 md5 加密，这个随机数就是我们说的盐(salt)，这样处理下来就能得到不同的 Md5 值，当然我们需要把这个随机数盐也保存进数据库中，以便我们进行验证。 另外我们可以通过多次加密的方法，即使黑客通过一定的技术手段拿到了我们的密码 md5 值，但它并不知道我们到底加密了多少次，所以这也使得破解工作变得艰难。 在 Shiro 框架中，对于这样的操作提供了简单的代码实现： String password = \"123456\"; String salt = new SecureRandomNumberGenerator().nextBytes().toString(); int times = 2; // 加密次数：2 String alogrithmName = \"md5\"; // 加密算法 String encodePassword = new SimpleHash(alogrithmName, password, salt, times).toString(); System.out.printf(\"原始密码是 %s , 盐是： %s, 运算次数是： %d, 运算出来的密文是：%s \",password,salt,times,encodePassword); 输出： 原始密码是 123456 , 盐是： f5GQZsuWjnL9z585JjLrbQ==, 运算次数是： 2, 运算出来的密文是：55fee80f73537cefd6b3c9a920993c25 SpringBoot 简单实例通过上面的学习，我们现在来着手搭建一个简单的使用 Shiro 进行权限验证授权的一个简单系统 第一步：新建SpringBoot项目，搭建基础环境pom包： &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.shiro&lt;/groupId> &lt;artifactId>shiro-spring&lt;/artifactId> &lt;version>1.4.0&lt;/version> &lt;/dependency> application.properties文件： #thymeleaf 配置 spring.thymeleaf.mode=HTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.servlet.content-type=text/html #缓存设置为false, 这样修改之后马上生效，便于调试 spring.thymeleaf.cache=false #数据库 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testdb?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.properties.hibernate.hbm2ddl.auto=update #显示SQL语句 spring.jpa.show-sql=true #不加下面这句则不会默认创建MyISAM引擎的数据库 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect #自己重写的配置类，默认使用utf8编码 spring.jpa.properties.hibernate.dialect=com.wmyskxz.demo.shiro.config.MySQLConfig 第二步：新建实体类新建一个【entity】包，在下面创建以下实体： 用户信息： @Entity public class UserInfo { @Id @GeneratedValue private Long id; // 主键. @Column(unique = true) private String username; // 登录账户,唯一. private String name; // 名称(匿名或真实姓名),用于UI显示 private String password; // 密码. private String salt; // 加密密码的盐 @JsonIgnoreProperties(value = {\"userInfos\"}) @ManyToMany(fetch = FetchType.EAGER) // 立即从数据库中进行加载数据 @JoinTable(name = \"SysUserRole\", joinColumns = @JoinColumn(name = \"uid\"), inverseJoinColumns = @JoinColumn(name = \"roleId\")) private List&lt;SysRole> roles; // 一个用户具有多个角色 /** getter and setter */ } 角色信息： @Entity public class SysRole { @Id @GeneratedValue private Long id; // 主键. private String name; // 角色名称,如 admin/user private String description; // 角色描述,用于UI显示 // 角色 -- 权限关系：多对多 @JsonIgnoreProperties(value = {\"roles\"}) @ManyToMany(fetch = FetchType.EAGER) @JoinTable(name = \"SysRolePermission\", joinColumns = {@JoinColumn(name = \"roleId\")}, inverseJoinColumns = {@JoinColumn(name = \"permissionId\")}) private List&lt;SysPermission> permissions; // 用户 -- 角色关系：多对多 @JsonIgnoreProperties(value = {\"roles\"}) @ManyToMany @JoinTable(name = \"SysUserRole\", joinColumns = {@JoinColumn(name = \"roleId\")}, inverseJoinColumns = {@JoinColumn(name = \"uid\")}) private List&lt;UserInfo> userInfos;// 一个角色对应多个用户 /** getter and setter */ } 权限信息： @Entity public class SysPermission { @Id @GeneratedValue private Long id; // 主键. private String name; // 权限名称,如 user:select private String description; // 权限描述,用于UI显示 private String url; // 权限地址. @JsonIgnoreProperties(value = {\"permissions\"}) @ManyToMany @JoinTable(name = \"SysRolePermission\", joinColumns = {@JoinColumn(name = \"permissionId\")}, inverseJoinColumns = {@JoinColumn(name = \"roleId\")}) private List&lt;SysRole> roles; // 一个权限可以被多个角色使用 /** getter and setter */ } 注意：这里有一个坑，还缠了我蛮久感觉，就是当我们想要使用RESTful风格返回给前台JSON数据的时候，这里有一个关于多对多无限循环的坑，比如当我们想要返回给前台一个用户信息时，由于一个用户拥有多个角色，一个角色又拥有多个权限，而权限跟角色也是多对多的关系，也就是造成了 查用户→查角色→查权限→查角色→查用户… 这样的无限循环，导致传输错误，所以我们根据这样的逻辑在每一个实体类返回JSON时使用了一个@JsonIgnoreProperties注解，来排除自己对自己无线引用的过程，也就是打断这样的无限循环。 根据以上的代码会自动生成user_info（用户信息表）、sys_role（角色表）、sys_permission（权限表）、sys_user_role（用户角色表）、sys_role_permission（角色权限表）这五张表，为了方便测试我们给这五张表插入一些初始化数据： INSERT INTO `user_info` (`id`,`name`,`password`,`salt`,`username`) VALUES (1, '管理员','951cd60dec2104024949d2e0b2af45ae', 'xbNIxrQfn6COSYn1/GdloA==', 'wmyskxz'); INSERT INTO `sys_permission` (`id`,`description`,`name`,`url`) VALUES (1,'查询用户','userInfo:view','/userList'); INSERT INTO `sys_permission` (`id`,`description`,`name`,`url`) VALUES (2,'增加用户','userInfo:add','/userAdd'); INSERT INTO `sys_permission` (`id`,`description`,`name`,`url`) VALUES (3,'删除用户','userInfo:delete','/userDelete'); INSERT INTO `sys_role` (`id`,`description`,`name`) VALUES (1,'管理员','admin'); INSERT INTO `sys_role_permission` (`permission_id`,`role_id`) VALUES (1,1); INSERT INTO `sys_role_permission` (`permission_id`,`role_id`) VALUES (2,1); INSERT INTO `sys_user_role` (`role_id`,`uid`) VALUES (1,1); 第三步：配置 Shiro新建一个【config】包，在下面创建以下文件： MySQLConfig： public class MySQLConfig extends MySQL5InnoDBDialect { @Override public String getTableTypeString() { return \"ENGINE=InnoDB DEFAULT CHARSET=utf8\"; } } 这个文件关联的是配置文件中最后一个配置，是让 Hibernate 默认创建 InnoDB 引擎并默认使用 utf-8 编码 MyShiroRealm： public class MyShiroRealm extends AuthorizingRealm { @Resource private UserInfoService userInfoService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { // 能进入这里说明用户已经通过验证了 UserInfo userInfo = (UserInfo) principalCollection.getPrimaryPrincipal(); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); for (SysRole role : userInfo.getRoles()) { simpleAuthorizationInfo.addRole(role.getName()); for (SysPermission permission : role.getPermissions()) { simpleAuthorizationInfo.addStringPermission(permission.getName()); } } return simpleAuthorizationInfo; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { // 获取用户输入的账户 String username = (String) authenticationToken.getPrincipal(); System.out.println(authenticationToken.getPrincipal()); // 通过username从数据库中查找 UserInfo 对象 // 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 UserInfo userInfo = userInfoService.findByUsername(username); if (null == userInfo) { return null; } SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo( userInfo, // 用户名 userInfo.getPassword(), // 密码 ByteSource.Util.bytes(userInfo.getSalt()), // salt=username+salt getName() // realm name ); return simpleAuthenticationInfo; } } 自定义的 Realm ，方法跟上面的认证授权过程一致 ShiroConfig： @Configuration public class ShiroConfig { @Bean public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) { System.out.println(\"ShiroConfiguration.shirFilter()\"); ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); // 拦截器. Map&lt;String, String> filterChainDefinitionMap = new LinkedHashMap&lt;String, String>(); // 配置不会被拦截的链接 顺序判断 filterChainDefinitionMap.put(\"/static/**\", \"anon\"); // 配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put(\"/logout\", \"logout\"); // &lt;!-- 过滤链定义，从上向下顺序执行，一般将/**放在最为下边 -->:这是一个坑呢，一不小心代码就不好使了; // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--> filterChainDefinitionMap.put(\"/**\", \"authc\"); // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面 shiroFilterFactoryBean.setLoginUrl(\"/login\"); // 登录成功后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl(\"/index\"); //未授权界面; shiroFilterFactoryBean.setUnauthorizedUrl(\"/403\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; } /** * 凭证匹配器 * （由于我们的密码校验交给Shiro的SimpleAuthenticationInfo进行处理了） * * @return */ @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() { HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName(\"md5\"); // 散列算法:这里使用MD5算法; hashedCredentialsMatcher.setHashIterations(2); // 散列的次数，比如散列两次，相当于 md5(md5(\"\")); return hashedCredentialsMatcher; } @Bean public MyShiroRealm myShiroRealm() { MyShiroRealm myShiroRealm = new MyShiroRealm(); myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return myShiroRealm; } @Bean public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); return securityManager; } /** * 开启shiro aop注解支持. * 使用代理方式;所以需要开启代码支持; * * @param securityManager * @return */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } @Bean(name = \"simpleMappingExceptionResolver\") public SimpleMappingExceptionResolver createSimpleMappingExceptionResolver() { SimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver(); Properties mappings = new Properties(); mappings.setProperty(\"DatabaseException\", \"databaseError\"); // 数据库异常处理 mappings.setProperty(\"UnauthorizedException\", \"403\"); r.setExceptionMappings(mappings); // None by default r.setDefaultErrorView(\"error\"); // No default r.setExceptionAttribute(\"ex\"); // Default is \"exception\" //r.setWarnLogCategory(\"example.MvcLogger\"); // No default return r; } } Apache Shiro 的核心通过 Filter 来实现，就好像 SpringMvc 通过 DispachServlet 来主控制一样。 既然是使用 Filter 一般也就能猜到，是通过URL规则来进行过滤和权限校验，所以我们需要定义一系列关于URL的规则和访问权限。 Filter Chain定义说明： 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过 3、部分过滤器可指定参数，如perms，roles Shiro内置的FilterChain Filter Name Class anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl org.apache.shiro.web.filter.authz.SslFilter user org.apache.shiro.web.filter.authc.UserFilter anon:所有url都都可以匿名访问 authc: 需要认证才能进行访问 user:配置记住我或认证通过可以访问 第四步：准备 DAO 层和 Service 层新建【dao】包，在下面创建【UserInfoDao】接口： public interface UserInfoDao extends JpaRepository&lt;UserInfo, Long> { /** 通过username查找用户信息*/ public UserInfo findByUsername(String username); } 新建【service】包，创建【UserInfoService】接口： public interface UserInfoService { /** 通过username查找用户信息；*/ public UserInfo findByUsername(String username); } 并在该包下再新建一个【impl】包，新建【UserInfoServiceImpl】实现类： @Service public class UserInfoServiceImpl implements UserInfoService { @Resource UserInfoDao userInfoDao; @Override public UserInfo findByUsername(String username) { return userInfoDao.findByUsername(username); } } 第五步：controller层新建【controller】包，然后在下面创建以下文件： HomeController： @Controller public class HomeController { @RequestMapping({\"/\",\"/index\"}) public String index(){ return\"/index\"; } @RequestMapping(\"/login\") public String login(HttpServletRequest request, Map&lt;String, Object> map) throws Exception{ System.out.println(\"HomeController.login()\"); // 登录失败从request中获取shiro处理的异常信息。 // shiroLoginFailure:就是shiro异常类的全类名. String exception = (String) request.getAttribute(\"shiroLoginFailure\"); System.out.println(\"exception=\" + exception); String msg = \"\"; if (exception != null) { if (UnknownAccountException.class.getName().equals(exception)) { System.out.println(\"UnknownAccountException -- > 账号不存在：\"); msg = \"UnknownAccountException -- > 账号不存在：\"; } else if (IncorrectCredentialsException.class.getName().equals(exception)) { System.out.println(\"IncorrectCredentialsException -- > 密码不正确：\"); msg = \"IncorrectCredentialsException -- > 密码不正确：\"; } else if (\"kaptchaValidateFailed\".equals(exception)) { System.out.println(\"kaptchaValidateFailed -- > 验证码错误\"); msg = \"kaptchaValidateFailed -- > 验证码错误\"; } else { msg = \"else >> \"+exception; System.out.println(\"else -- >\" + exception); } } map.put(\"msg\", msg); // 此方法不处理登录成功,由shiro进行处理 return \"/login\"; } @RequestMapping(\"/403\") public String unauthorizedRole(){ System.out.println(\"------没有权限-------\"); return \"403\"; } } 这里边的地址对应我们在设置 Shiro 时设置的地址 UserInfoController： @RestController public class UserInfoController { @Resource UserInfoService userInfoService; /** * 按username账户从数据库中取出用户信息 * * @param username 账户 * @return */ @GetMapping(\"/userList\") @RequiresPermissions(\"userInfo:view\") // 权限管理. public UserInfo findUserInfoByUsername(@RequestParam String username) { return userInfoService.findByUsername(username); } /** * 简单模拟从数据库添加用户信息成功 * * @return */ @PostMapping(\"/userAdd\") @RequiresPermissions(\"userInfo:add\") public String addUserInfo() { return \"addUserInfo success!\"; } /** * 简单模拟从数据库删除用户成功 * * @return */ @DeleteMapping(\"/userDelete\") @RequiresPermissions(\"userInfo:delete\") public String deleteUserInfo() { return \"deleteUserInfo success!\"; } } 第六步：准备页面新建三个页面用来测试： index.html：首页 &lt;!DOCTYPE html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>首页&lt;/title> &lt;/head> &lt;body> index - 首页 &lt;/body> &lt;/html> login.html：登录页 &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.w3.org/1999/xhtml\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>登录页&lt;/title> &lt;/head> &lt;body> 错误信息：&lt;h4 th:text=\"${msg}\">&lt;/h4> &lt;form action=\"\" method=\"post\"> &lt;p>账号：&lt;input type=\"text\" name=\"username\" value=\"wmyskxz\"/>&lt;/p> &lt;p>密码：&lt;input type=\"text\" name=\"password\" value=\"123456\"/>&lt;/p> &lt;p>&lt;input type=\"submit\" value=\"登录\"/>&lt;/p> &lt;/form> &lt;/body> &lt;/html> 403.html：没有权限的页面 &lt;!DOCTYPE html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>403错误页&lt;/title> &lt;/head> &lt;body> 错误页面 &lt;/body> &lt;/html> 第七步：测试 编写好程序后就可以启动，首先访问http://localhost:8080/userList?username=wmyskxz页面，由于没有登录就会跳转到我们配置好的http://localhost:8080/login页面。登陆之后就会看到正确返回的JSON数据，上面这些操作时候触发MyShiroRealm.doGetAuthenticationInfo()这个方法，也就是登录认证的方法。 登录之后，我们还能访问http://localhost:8080/userAdd页面，因为我们在数据库中提前配置好了权限，能够看到正确返回的数据，但是我们访问http://localhost:8080/userDelete时，就会返回错误页面. 注意：以上测试需要在REST工具中测试，因为在Controller层中配置了方法，大家也可以不用REST风格来测试一下看看！ 完成了以上的学习，我们就差不多对 Shiro 框架有了一定了解了，更多的东西以后再分享再学习吧. 参考资料：springboot(十四)：springboot整合shiro-登录认证和权限管理——纯洁的微笑Shiro安全框架入门 - 慕课视频教程Shiro 系列教程 —— how2j网站 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"Shiro","slug":"后端/Java/Shiro","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Shiro/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Spring-Data-JPA尝鲜：快速搭建CRUD+分页后台实例","slug":"Spring-Data-JPA尝鲜：快速搭建CRUD-分页后台实例","date":"2019-01-04T23:11:00.000Z","updated":"2020-12-09T05:12:11.156Z","comments":true,"path":"2019/01/05/spring-data-jpa-chang-xian-kuai-su-da-jian-crud-fen-ye-hou-tai-shi-li/","link":"","permalink":"http://www.wmyskxz.com/2019/01/05/spring-data-jpa-chang-xian-kuai-su-da-jian-crud-fen-ye-hou-tai-shi-li/","excerpt":"","text":"前言：由于之前没有接触过Hibernate框架，但是最近看一些博客深深被它的“效率”所吸引，所以这就来跟大家一起就着一个简单的例子来尝尝Spring全家桶里自带的JPA的鲜 Spring-DATA-JPA 简介JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。他的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，JPA受到了极大的支持和赞扬，其中就包括了Spring与EJB3.0的开发团队。 注意：JPA是一套规范，不是一套产品，那么像Hibernate,TopLink,JDO他们是一套产品，如果说这些产品实现了这个JPA规范，那么我们就可以叫他们为JPA的实现产品。 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！（spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现） 摘自：springboot(五)：spring data jpa的使用——纯洁的微笑 Hibernate 和 MyBatis 简单对比由于JPA底层干活的仍然是Hibernate框架，而我们之前学习的只有MyBatis相关的东西，所以在尝鲜之前还是有必要简单了解一下两者的区别： Hibernate的优势： Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 MyBatis的优势： MyBatis可以进行更为细致的SQL优化，可以减少查询字段。 MyBatis容易掌握，而Hibernate门槛较高。 简单总结： MyBatis：小巧、方便、高效、简单、直接、半自动化 Hibernate：强大、方便、高效、复杂、间接、全自动化 引用自：【持久化框架】Mybatis与Hibernate的详细对比——高亮 CRUD + 分页后台实例下面我们来快速搭建一个使用Spring-DATA-JPA的CRUD+分页后台实例，并且我们会直接使用到RESTful API（不熟悉的同学戳这里） 第一步：新建SpringBoot项目打开IDEA新建一个SpringBoot项目，不熟悉SpringBoot的同学请右转：【传送门】，然后在pom.xml中添加以下依赖： &lt;!-- mysql--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.21&lt;/version> &lt;/dependency> &lt;!-- jpa--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId> &lt;/dependency> 然后把application.properties弄成这个样子： #数据库 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testdb?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.properties.hibernate.hbm2ddl.auto=update #显示SQL语句 spring.jpa.show-sql=true #不加下面这句则默认创建MyISAM引擎的数据库 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect #自己重写的配置类，默认使用utf8编码 spring.jpa.properties.hibernate.dialect=com.wmyskxz.demo.config.MySQLConfig spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 然后新建一个【config】包，创建一个【MySQLConfig】类（上面的spring.jpa.properties.hibernate.dialect属性就要配置这里的类全路径）： package com.wmyskxz.demo.config; import org.hibernate.dialect.MySQL5InnoDBDialect; public class MySQLConfig extends MySQL5InnoDBDialect { @Override public String getTableTypeString() { return \"ENGINE=InnoDB DEFAULT CHARSET=utf8\"; } } 第二步：创建好需要的数据库打开SQL服务，建表语句也很简单啦： create database testdb; 第三步：创建实体类实体类映射的实际上是数据库表的结构，在适当的包目录下（例如【entity】）下创建好实体类： package com.wmyskxz.demo.entity; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity // 表明这是个实体类 public class User { @Id // 表明这个属性是主键 @GeneratedValue // 自增长 private long id; @Column(nullable = false, unique = true) // 不允许为空，属性唯一 private String username; @Column(nullable = false) // 不允许为空 private String password; // getter and setter } 第四步：DAO层新建一个【repository】包，然后新建一个【UserRepository】接口，并继承JpaRepository类： package com.wmyskxz.demo.repository; import com.wmyskxz.demo.entity.User; import org.springframework.data.jpa.repository.JpaRepository; public interface UserRepository extends JpaRepository&lt;User, Long> { } 继承JpaRepository需要传入两个参数，一个是实体类User一个是主键的类型Long，而凡是继承了JpaRepository类的就会自动实现很多内置的方法，包括增删改查，以及使用默认支持的Pageable对象来进行分页，默认的方法大致如下： public interface JpaRepository&lt;T, ID> extends PagingAndSortingRepository&lt;T, ID>, QueryByExampleExecutor&lt;T> { List&lt;T> findAll(); List&lt;T> findAll(Sort var1); List&lt;T> findAllById(Iterable&lt;ID> var1); &lt;S extends T> List&lt;S> saveAll(Iterable&lt;S> var1); void flush(); &lt;S extends T> S saveAndFlush(S var1); void deleteInBatch(Iterable&lt;T> var1); void deleteAllInBatch(); T getOne(ID var1); &lt;S extends T> List&lt;S> findAll(Example&lt;S> var1); &lt;S extends T> List&lt;S> findAll(Example&lt;S> var1, Sort var2); } 第五步：Controller层新建【controller】包，新建一个【UserController】类，编写简单的增删改查代码： package com.wmyskxz.demo.controoler; import com.wmyskxz.demo.entity.User; import com.wmyskxz.demo.repository.UserRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.PageRequest; import org.springframework.data.domain.Sort; import org.springframework.web.bind.annotation.*; import java.util.Optional; @RestController // 表明这是一个Controller并返回JSON格式 public class UserController { @Autowired private UserRepository userRepository; @GetMapping(\"/getOne\") public Optional&lt;User> getOneUserById(@RequestParam long id) { return userRepository.findById(id); } @GetMapping(\"/all\") public Iterable&lt;User> getAllUsers(@RequestParam(value = \"page\", defaultValue = \"0\") int page, @RequestParam(value = \"size\", defaultValue = \"5\") int size) { page = page &lt; 0 ? 0 : page;// 如果page为负数则修改为0，防止在首页点击上一页发生错误 Sort sort = new Sort(Sort.Direction.DESC, \"id\");// 按id倒叙排列 return userRepository.findAll(new PageRequest(page, size, sort)); } @PostMapping(\"/add\") public String addUser(@RequestParam String username, @RequestParam String password) { User user = new User(); user.setUsername(username); user.setPassword(password); userRepository.save(user);// 注意这里是save return \"Saved\"; } @DeleteMapping(\"/delete\") public String deleteUserById(@RequestParam long id) { userRepository.deleteById(id); return \"Deleted\"; } @PutMapping(\"/update\") public String updateUser(User user) { // User user = new User(); // user.setId(id); // user.setUsername(username); // user.setPassword(password); userRepository.save(user); return \"Updated\"; } } 上面就直接使用@Autowired自动引入了继承了JpaRepository的UserRepository接口，我们使用它默认的方法已经足够完成我们的基础功能了，值得一提的是我们的getAllUsers(...)方法，它往findAll()方法里传入了一个Pageable对象，这是Spring Data库中定义的一个接口，是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关的所有信息（例如pageNumber、pageSize等），这样Jpa就能够通过Pageable参数来得到一个带分页信息的Sql语句。 当然上面我们是通过自己创建了一个Pageable对象，Spring也支持直接获取Pageable对象，可以把上面的getAllUsers(...)方法改写成下面这样： @GetMapping(\"/all\") public Iterable&lt;User> getAllUsers(@PageableDefault(value = 5, sort = {\"id\"}, direction = Sort.Direction.DESC) Pageable pageable) { return userRepository.findAll(pageable); } 默认从第0页开始，也可以自己传入一个page参数，跟上面的是一样的。 第六步：运行项目上面我们就快速搭建起来了一个基于Spring Boot和JPA的REST风格的后台增删改查实例，我们把项目跑起来，可以看到数据库自动创建了一些表： JPA帮我们创建的user表的创建SQL如下： CREATE TABLE `user` ( `id` bigint(20) NOT NULL, `password` varchar(255) NOT NULL, `username` varchar(255) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `UK_sb8bbouer5wak8vyiiy4pf2bx` (`username`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 使用REST测试工具测试完全符合我们的要求，然后我们使用一些REST的测试工具，来测试上面的功能是否都能正确运行，比如我这里使用的【Restlet Client】，在Chrome商店就可以下载到。 /all地址测试：首先先来测试一下http://localhost:8080/all地址，由于现在数据库还是空的，所以可以看到返回如下： { \"content\": [ ], \"pageable\": { \"sort\": { \"sorted\": true, \"unsorted\": false, \"empty\": false }, \"offset\": 0, \"pageNumber\": 0, \"pageSize\": 5, \"unpaged\": false, \"paged\": true }, \"totalElements\": 0, \"last\": true, \"totalPages\": 0, \"number\": 0, \"size\": 5, \"sort\": { \"sorted\": true, \"unsorted\": false, \"empty\": false }, \"numberOfElements\": 0, \"first\": true, \"empty\": true } 添加用户测试：然后我们使用http://localhost:8080/add?username=wmyskxz&amp;password=123地址，添加几个类似的用户信息： 可以看到返回正确的Saved信息： /getOne地址测试：我们就直接使用http://localhost:8080/getOne?id=1来获取刚才添加的用户，可以看到返回正确的数据： { \"id\": 1, \"username\": \"wmyskxz\", \"password\": \"123\" } 修改用户测试：然后我们使用http://localhost:8080/update?id=1&amp;username=wmyskxz&amp;password=123456来模拟进行用户密码的修改： 可以看到正确的更新信息Updated，再次查询用户，也能看到正确的数据： { \"id\": 1, \"username\": \"wmyskxz\", \"password\": \"123456\" } 分页测试：我们使用添加功能为数据库添加5条以上的数据，然后进行一次查询/all，可以看到能够按照id倒叙排列后返回5条数据： 返回的JSON数据如下： { \"content\": [ { \"id\": 10, \"username\": \"wmyskxz8\", \"password\": \"123\" }, { \"id\": 9, \"username\": \"wmyskxz7\", \"password\": \"123\" }, { \"id\": 8, \"username\": \"wmyskxz6\", \"password\": \"123\" }, { \"id\": 7, \"username\": \"wmyskxz5\", \"password\": \"123\" }, { \"id\": 6, \"username\": \"wmyskxz4\", \"password\": \"123\" } ], \"pageable\": { \"sort\": { \"sorted\": true, \"unsorted\": false, \"empty\": false }, \"offset\": 0, \"pageNumber\": 0, \"pageSize\": 5, \"unpaged\": false, \"paged\": true }, \"totalElements\": 9, \"last\": false, \"totalPages\": 2, \"number\": 0, \"size\": 5, \"sort\": { \"sorted\": true, \"unsorted\": false, \"empty\": false }, \"numberOfElements\": 5, \"first\": true, \"empty\": false } 删除用户测试：使用地址http://localhost:8080/delete?id=1来删除ID为1的用户： 能正确看到Deleted信息，并查看数据能够看到数据已经被删除了。 以上，我们就快速搭建好了一个CRUD+分页的后台实例，还用了比较流行的RESTful风格，粗略的感受了一下JPA的方便，还是挺爽的..没有复杂的Mapper文件，不用自动生成实体，甚至不用管SQL，只需要专注在逻辑上就行了，其实简单使用的话以上的东西也能应付一些常见的场景了，后期再深入了解了解吧！ 参考资料：springboot(五)：spring data jpa的使用——纯洁的微笑springboot(十五)：springboot+jpa+thymeleaf增删改查示例——纯洁的微笑Spring Boot中使用Spring-data-jpa让数据访问更简单、更优雅——程序猿DD 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringData","slug":"后端/Java/SpringData","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringData/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Thymeleaf【快速入门】","slug":"Thymeleaf【快速入门】","date":"2019-01-01T23:08:00.000Z","updated":"2020-12-09T05:13:19.713Z","comments":true,"path":"2019/01/02/thymeleaf-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2019/01/02/thymeleaf-kuai-su-ru-men/","excerpt":"","text":"前言：突然发现自己给自己埋了一个大坑，毕设好难..每一个小点拎出来都能当一个小题目（手动摆手..），没办法自己选的含着泪也要把坑填完..先一点一点把需要补充的知识学完吧.. Thymeleaf介绍稍微摘一摘【官网】上面的介绍吧（翻译是找到，有些增加的内容）： 1.Thymeleaf is a modern server-side Java template engine for both web and standalone environments. Thymeleaf是⾯向Web和独⽴环境的现代服务器端Java模板引擎，能够处理HTML，XML，JavaScript，CSS甚⾄纯⽂本。 2.Thymeleaf’s main goal is to bring elegant natural templates to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams. Thymeleaf旨在提供⼀个优雅的、⾼度可维护的创建模板的⽅式。 为了实现这⼀⽬标，Thymeleaf建⽴在⾃然模板的概念上，将其逻辑注⼊到模板⽂件中，不会影响模板设计原型。 这改善了设计的沟通，弥合了设计和开发团队之间的差距。 3.With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.对于Spring框架模块,一个允许你集成你最喜欢的工具的平台,并且能够插入自己的功能,Thymeleaf是理想的现代JVM HTML5 web开发工具,虽然它可以做得多。 然后官网还给出了一段看起来仍然像HTML一样工作的集成了Thymeleaf模版的代码，我们大致的来感受一下： 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP。 Thymeleaf与JSP的区别在于，不运行项目之前，Thymeleaf也是纯HTML（不需要服务端的支持）而JSP需要进行一定的转换，这样就方便前端人员进行独立的设计、调试。相较与其他的模板引擎，它有如下三个极吸引人的特点： 1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 摘自：spring boot(四):thymeleaf使用详解-纯洁的微笑 00#先把需要环境搭起来也就是SpringBoot项目的搭建，很常规，快速搭起来： 稍微改改包名还有描述，点击【Next】： 勾选上Web/Thymeleaf支持，然后点击【Next】： 选择项目保存位置，点击【Finish】： 至此就简单创建了一个用于学习Thymeleaf的简单环境。 01#创建一个Hello Thymeleaf页面第一步：新建一个HelloController在【com.wmyskxz.demo】下新建一个【controller】包，然后新建一个【HelloController】： package com.wmyskxz.demo.controoler; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloController { @RequestMapping(\"/hello\") public String hello(Model model) { model.addAttribute(\"name\", \"thymeleaf\"); return \"hello\"; } } 第二步：新建一个hello.html页面在【resources】下的【templates】下新建一个【hello.html】文件，使用这个目录的原因是当你使用模板引擎时Spring Boot会默认在src/main/resources/templates下去找，当然你也可以修改这个默认路径，这里就不做演示了： &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;/head> &lt;body> &lt;p th:text=\"${name}\">name&lt;/p> &lt;p th:text=\"'Hello！ ' + ${name} + '!'\">hello world&lt;/p> &lt;p th:text=\"|Hello！ ${name}!|\">hello world&lt;/p> &lt;/body> &lt;/html> 第三步：把项目跑起来事实上，上面已经展示了三种拼接字符串的方式，你应该也能看出thymeleaf的一点端倪，不过你第一件注意到的事应该是这是一个HTML5文件，可以由任何浏览器正确的显示，因为它不包含任何非HTML得标签（浏览器会忽略他们不明白的所有属性，如：th:text） 项目运行之后，我们在地址栏输入localhost:8080/hello，就会看到意料之中结果正确的页面： 但是你也可能会注意到，这个模板并不是一个真正有效的HTML5文档，因为HTML5规范不允许在th:*形式中使用这些非标准属性。事实上，我们甚至在我们的&lt;html&gt;标签中添加了一个xmlns:th属性，这绝对是非HTML5标准：&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 不管怎样，你已经看到了我们将如何使用Thymeleaf模板引擎访问model中的数据：“${}”，这和JSP极为相似，下面我们将进一步展示Thymeleaf的用法。 第四步：对项目做一些修改以方便调试现在我们基础的环境和第一个任务（一个Hello World）页面都已经开发完成了，但是有一点不好的是，每一次我们对页面的修改都不能得到及时的反应，我们需要不断的重启服务器以看到效果，这在实际开发过程中是十分糟糕的表现，我们需要做一些修改，让Thymeleaf页面能够实时的刷新而不需要重启服务器。 打开IDEA-&gt;Setting，将下面的选项【Build project automatically】给勾选上： 然后按下快捷键【Ctrl + Alt + Shift + /】，召唤出【Maintenance】菜单，进入【Registry】： 把【compiler.automake.allow.when.app.running】这个选项的 √ 给打上： 然后再把【application.properties】弄成这个样子： #thymeleaf 配置 spring.thymeleaf.mode=HTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.servlet.content-type=text/html #缓存设置为false, 这样修改之后马上生效，便于调试 spring.thymeleaf.cache=false 然后重启项目，对我们的hello.html稍稍做一些修改，稍等一会儿，你就能刷新页面看到效果，完美。 10#更多Thymeleaf的基础用法1. model 中的数据迭代Thymeleaf 的迭代和 JSP 的写法也很相似，我们将就上面的hello项目改一下： &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;/head> &lt;body> &lt;table> &lt;thead> &lt;tr> &lt;th>学生id&lt;/th> &lt;th>学生姓名&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr th:each=\"s:${students}\"> &lt;td th:text=\"${s.id}\">&lt;/td> &lt;td th:text=\"${s.name}\">&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/body> &lt;/html> 为了配合演示，在【com.wmyskxz.demo】下新建一个【pojo】包，然后新建一个【Student】类： package com.wmyskxz.demo.pojo; public class Student { private String name; private Integer id; public Student(String name, Integer id) { this.name = name; this.id = id; } // getter and setter } 再把controller改改，给前端添加几条数据： @RequestMapping(\"/hello\") public String hello(Model model) { List&lt;Student> students = new ArrayList&lt;>(); students.add(new Student(\"张三\", 1)); students.add(new Student(\"李四\", 2)); students.add(new Student(\"王五\", 3)); students.add(new Student(\"二麻子\", 4)); students.add(new Student(\"三棒子\", 5)); model.addAttribute(\"students\", students); return \"hello\"; } 重启项目，然后在地址栏输入：localhost:8080/hello，能看到正确的显示，完美： 代码解释： 使用th:each来做循环迭代（th:each=&quot;s:${students}&quot;），s作为迭代元素来使用，然后像上面一样访问迭代元素中的属性，相信这样的用法应该不会陌生。 进阶-带状态的遍历我们也可以使用th:each=&quot;s,status:${students}&quot;方式遍历，就可以把状态放在status里面了，同时还可以用th:class=&quot;${stauts.even}?&#39;even&#39;:&#39;odd&#39;&quot;来判断奇偶。 status里面包含的信息大致如下： 属性 说明 index 从0开始的索引值 count 从1开始的索引值 size 集合内元素的总量 current 当前的迭代对象 even/odd boolean类型的，用来判断是偶数个还是奇数个 first boolean类型，判断是否为第一个 last boolean类型，判断是否为最后一个 我们再次来修改一下我们的hello.html，让它多显示一行index属性，并增加一些简单的效果好让单双行区别开来： &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;/head> &lt;body> &lt;table> &lt;thead> &lt;tr> &lt;th>index&lt;/th> &lt;th>学生id&lt;/th> &lt;th>学生姓名&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr th:class=\"${status.even}?'even':'odd'\" th:each=\"s,status:${students}\"> &lt;td th:text=\"${status.index}\">&lt;/td> &lt;td th:text=\"${s.id}\">&lt;/td> &lt;td th:text=\"${s.name}\">&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/body> &lt;style> .even{ background-color: hotpink; } .odd{ background-color: cornflowerblue; } &lt;/style> &lt;/html> 不用重启，刷新一下页面就可以看到效果，完美： 2. 数据判断Thymeleaf 的条件判断是通过th:if来做的，只有条件为真的时候才会显示当前元素，取反可以用not（th:if=&quot;not 条件&quot;）或者th:unless，或者常见的三元判断符（x?y:z）也是适用的，我们动手再来修改我们的hello.html： &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;/head> &lt;body> &lt;!-- 当students集合为空则显示提示信息 --> &lt;div th:if=\"${#lists.isEmpty(students)}\">studnets集合为空！&lt;/div> &lt;!-- 当students集合不为空时才会显示下面的元素 --> &lt;div th:if=\"${not #lists.isEmpty(students)}\"> &lt;table> &lt;thead> &lt;tr> &lt;th>index&lt;/th> &lt;th>学生id&lt;/th> &lt;th>学生姓名&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;tr th:class=\"${status.even}?'even':'odd'\" th:each=\"s,status:${students}\"> &lt;td th:text=\"${status.index}\">&lt;/td> &lt;td th:text=\"${s.id}\">&lt;/td> &lt;td th:text=\"${s.name}\">&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> &lt;/div> &lt;/body> &lt;style> .even { background-color: hotpink; } .odd { background-color: cornflowerblue; } &lt;/style> &lt;/html> 然后我们相应的把Controller丢给hello.html的数据给清空： @RequestMapping(\"/hello\") public String hello(Model model) { List&lt;Student> students = new ArrayList&lt;>(); // students.add(new Student(\"张三\", 1)); // students.add(new Student(\"李四\", 2)); // students.add(new Student(\"王五\", 3)); // students.add(new Student(\"二麻子\", 4)); // students.add(new Student(\"三棒子\", 5)); model.addAttribute(\"students\", students); return \"hello\"; } 重启项目，刷新页面，能看到正确的错误提示信息（对于这样的，需要有错误提示的页面我也不知道应该怎么写好，这里就简单示范一下，如果知道怎么写好的小伙伴记得提示一下啊）： 代码解释： 通过${not #lists.isEmpty(students)}表达式，判断了students是否为空，Thymeleaf支持&gt;、&lt;、&gt;=、&lt;=、==、!=作为比较条件，同时也支持将SpringEL表达式语言用于条件中，表达式中的#lists.isEmpty()语法是Thymeleaf模板自带的一种内置工具，像这样的内置工具不仅方便而且能提高我们的效率，完整的内置工具在这里可以看到：【传送门】 3. 在 JavaScript 中访问 model首先我们需要学习如何在Thymeleaf中引用静态资源，很简单，使用@{}就可以，这在JSP下是极易出错的。我们在【main】目录下新建一个【webapp】目录，然后在【staitc/js】目录下新建一个【thymeleaf.js】文件： function testFunction(){ alert(\"test Thymeleaf.js!\"); } 在hello.html的&lt;head&gt;标签中添加上下面这句话： &lt;script type=\"text/javascript\" src=\"../../webapp/static/js/thymeleaf.js\" th:src=\"@{/static/js/thymeleaf.js}\">&lt;/script> 通过th:href=&quot;@{/static/js/thymeleaf.js}&quot;这种方式，可以在渲染后的html里自动生成上下文路径，为了方便我们调试，也就是能在显示器中直接打开html文件进行效果的查看，我们还添加了src属性（src=&quot;../../webapp/static/js/thymeleaf.js&quot;） 刷新项目，能正确得到提示信息： 然后我们把hello.html改写成下面这个样子： &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;script th:inline=\"javascript\"> var single = [[${student}]]; console.log(single.name + \"/\" + single.id); &lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> 再让Controller简单的传一个学生到前台： @RequestMapping(\"/hello\") public String hello(Model model) { model.addAttribute(\"student\", new Student(\"我没有三颗心脏\", 1)); return \"hello\"; } 刷新项目，按下F12，就可以在控制台中看到正确的信息了： 代码解释： 通过th:inline=&quot;javascript&quot;添加到script标签，这样JavaScript代码即可访问model中的属性，再通过[[${}]]格式来获得实际的值。 4. 包含我们在开发中常常都把页面共同的header和footer提取出来，弄成单独的页面，然后让该包含的页面包含进来，我们就拿footer举例，首先在【templates】下新建一个要背其他页面包含的footer页面【include】： &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;footer th:fragment=\"footer1\"> &lt;p>All Rights Reserved&lt;/p> &lt;/footer> &lt;footer th:fragment=\"footer2(start,now)\"> &lt;p th:text=\"|${start} - ${now} All Rights Reserved|\">&lt;/p> &lt;/footer> &lt;/html> 然后直接在我们的hello.html页面中分别引用上面页面定义好的两个foot： &lt;!DOCTYPE html> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;/head> &lt;body> &lt;div th:include=\"include::footer1\">&lt;/div> &lt;div th:replace=\"include::footer2(2015,2018)\">&lt;/div> &lt;/body> &lt;/html> 刷新页面，可以看到效果： 代码解释： 我们可以使用th:fragment属性来定义被包含的模板片段，然后使用th:include和th:replace两个标签来直接引用标记好的片段，上面hello.html其实就相当于： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;title>Thymeleaf快速入门-Hello Thymeleaf&lt;/title> &lt;/head> &lt;body> &lt;div> &lt;p>All Rights Reserved&lt;/p> &lt;/div> &lt;footer> &lt;p>2015 - 2018 All Rights Reserved&lt;/p> &lt;/footer> &lt;/body> &lt;/html> 也可以很明显感觉到两个标签的差别，include会保留自己的主标签，而replace会保留fragment的主标签。 11#一个CRUD+分页的实例接下来我们沿用上面的基础，把这个项目进行一定的扩展，变成一个CRUD+分页的完整项目，不过首先，我们需要把之前因为不好习惯写的pojo.student类里的id和name顺序交换一下，好匹配数据库里的结构： package com.wmyskxz.demo.pojo; public class Student { private Integer id; private String name; // getter and setter } 第一步：准备好数据库环境建表SQL： create database wmyskxz; use wmyskxz; CREATE TABLE student ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(30), PRIMARY KEY (id) ) DEFAULT CHARSET=UTF8; 第二步：修改application.properties和pom.xml增加数据库相关配置到application,properties中，完整的文件如下： #thymeleaf 配置 spring.thymeleaf.mode=HTML5 spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.servlet.content-type=text/html #缓存设置为false, 这样修改之后马上生效，便于调试 spring.thymeleaf.cache=false #数据库 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/wmyskxz?characterEncoding=UTF-8 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver 往pom.xml增加jdbc,mybatis,pageHelper的jar包： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.1.1.RELEASE&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;groupId>com.wmyskxz&lt;/groupId> &lt;artifactId>demo&lt;/artifactId> &lt;version>0.0.1-SNAPSHOT&lt;/version> &lt;name>demo&lt;/name> &lt;description>Demo project for Spring Boot + Thymeleaf&lt;/description> &lt;properties> &lt;java.version>1.8&lt;/java.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;!-- 这个需要为 true 热部署才有效 --> &lt;/dependency> &lt;!-- servlet依赖. --> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>javax.servlet-api&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>jstl&lt;/artifactId> &lt;/dependency> &lt;!-- tomcat的支持.--> &lt;dependency> &lt;groupId>org.apache.tomcat.embed&lt;/groupId> &lt;artifactId>tomcat-embed-jasper&lt;/artifactId> &lt;/dependency> &lt;!-- mybatis --> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>1.1.1&lt;/version> &lt;/dependency> &lt;!-- mysql --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.21&lt;/version> &lt;/dependency> &lt;!-- pageHelper --> &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper&lt;/artifactId> &lt;version>4.1.6&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 第三步：增加StudentMapper新建【mapper】包，并在其下新增StudentMapper接口： package com.wmyskxz.demo.mapper; import com.wmyskxz.demo.pojo.Student; import org.apache.ibatis.annotations.*; import java.util.List; @Mapper public interface StudentMapper { @Select(\"select * from student\") List&lt;Student> findAll(); @Insert(\"insert into student ( name ) values (#{name}) \") int save(Student student); @Delete(\"delete from student where id= #{id} \") void delete(int id); @Select(\"select * from student where id= #{id} \") Student get(int id); @Update(\"update student set name=#{name} where id=#{id} \") int update(Student student); } 第四步：新增StudentController类在【controller】包下新增一个【StudentController】类： package com.wmyskxz.demo.controoler; import com.github.pagehelper.PageHelper; import com.github.pagehelper.PageInfo; import com.wmyskxz.demo.mapper.StudentMapper; import com.wmyskxz.demo.pojo.Student; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import java.util.List; @Controller public class StudentController { @Autowired StudentMapper studentMapper; @RequestMapping(\"/addStudent\") public String listStudent(Student student) throws Exception { studentMapper.save(student); return \"redirect:listStudent\"; } @RequestMapping(\"/deleteStudent\") public String deleteStudent(Student student) throws Exception { studentMapper.delete(student.getId()); return \"redirect:listStudent\"; } @RequestMapping(\"/updateStudent\") public String updateStudent(Student student) throws Exception { studentMapper.update(student); return \"redirect:listStudent\"; } @RequestMapping(\"/editStudent\") public String listStudent(int id, Model m) throws Exception { Student student = studentMapper.get(id); m.addAttribute(\"student\", student); return \"editStudent\"; } @RequestMapping(\"/listStudent\") public String listStudent(Model m, @RequestParam(value = \"start\", defaultValue = \"0\") int start, @RequestParam(value = \"size\", defaultValue = \"5\") int size) throws Exception { PageHelper.startPage(start, size, \"id desc\"); List&lt;Student> students = studentMapper.findAll(); PageInfo&lt;Student> page = new PageInfo&lt;>(students); m.addAttribute(\"page\", page); return \"listStudent\"; } } 第五步：配置PageHelper新建【config】包，并在下面新建【PageHelperConfig】类： package com.wmyskxz.demo.config; import com.github.pagehelper.PageHelper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Properties; @Configuration public class PageHelperConfig { @Bean public PageHelper pageHelper() { PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(\"offsetAsPageNum\", \"true\"); p.setProperty(\"rowBoundsWithCount\", \"true\"); p.setProperty(\"reasonable\", \"true\"); pageHelper.setProperties(p); return pageHelper; } } 第六步：编写HTML文件为了演示，我们简单添加两个页面就好了，一个是【listStudent.html】： &lt;!DOCTYPE HTML> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;title>Thymeleaf快速入门-CRUD和分页实例&lt;/title> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;/head> &lt;body> &lt;div style=\"width:500px;margin:20px auto;text-align: center\"> &lt;table align='center' border='1' cellspacing='0'> &lt;tr> &lt;td>id&lt;/td> &lt;td>name&lt;/td> &lt;td>编辑&lt;/td> &lt;td>删除&lt;/td> &lt;/tr> &lt;tr th:each=\"student:${page.list}\"> &lt;td th:text=\"${student.id}\">&lt;/td> &lt;td th:text=\"${student.name}\">&lt;/td> &lt;td>&lt;a th:href=\"@{/editStudent(id=${student.id})}\">编辑&lt;/a>&lt;/td> &lt;td>&lt;a th:href=\"@{/deleteStudent(id=${student.id})}\">删除&lt;/a>&lt;/td> &lt;/tr> &lt;/table> &lt;br/> &lt;div> &lt;a th:href=\"@{/listStudent(start=0)}\">[首 页]&lt;/a> &lt;a th:href=\"@{/listStudent(start=${page.pageNum-1})}\">[上一页]&lt;/a> &lt;a th:href=\"@{/listStudent(start=${page.pageNum+1})}\">[下一页]&lt;/a> &lt;a th:href=\"@{/listStudent(start=${page.pages})}\">[末 页]&lt;/a> &lt;/div> &lt;br/> &lt;form action=\"addStudent\" method=\"post\"> name: &lt;input name=\"name\"/> &lt;br/> &lt;button type=\"submit\">提交&lt;/button> &lt;/form> &lt;/div> &lt;/body> &lt;/html> 另一个就是编辑Student的页面【editStudent.html】： &lt;!DOCTYPE HTML> &lt;html xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;title>Thymeleaf快速入门-CRUD和分页实例&lt;/title> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/> &lt;/head> &lt;body> &lt;div style=\"margin:0px auto; width:500px\"> &lt;form action=\"updateStudent\" method=\"post\"> name: &lt;input name=\"name\" th:value=\"${student.name}\"/> &lt;br/> &lt;input name=\"id\" type=\"hidden\" th:value=\"${student.id}\"/> &lt;button type=\"submit\">提交&lt;/button> &lt;/form> &lt;/div> &lt;/body> &lt;/html> 第七步：运行项目在添加了一些数据之后，可以观察到各项功能都是可以正常使用的，这个例子也是我直接借鉴how2j教程里的源码写的，原文在这里：【传送门】，运行之后，可以看到大概是这样的效果，完美： 至此，我们就差不多算是对Thymeleaf入了门。 按照惯例黏一个尾巴，话说有木有懂公众号运营的小伙伴啊？求指教！ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"2018年终总结","slug":"2018年终总结","date":"2018-12-31T23:07:00.000Z","updated":"2020-12-09T04:48:04.535Z","comments":true,"path":"2019/01/01/2018-nian-zhong-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2019/01/01/2018-nian-zhong-zong-jie/","excerpt":"","text":"回顾8102说着回顾8102年，我就想要从自己年前写下的日记、博客、发过的票圈里去寻找自己在这一年来的轨迹，发现虽然才短短一年时间，自己的心境却发生了很大的变化，回看那些日记、博客、发过的票圈，那个年前的我竟带着一丝陌生气和些许天真，但好在写的技术博客还是挺好的..（嘻嘻嘻..）不过一年来看，我很感谢年前那个一丝陌生的我，带着自己的天真一直(努力)奋斗到了年尾，今早刚好又看到一句杨绛老先生的话，非常喜欢，分享共勉之的同时，也写一写自己的年终总结： “我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容….我们曾如此期盼外界的认定，到最后才知道：世界是自己的，与他人毫无关系！” 00.改变 &amp; 成长七个星期零2天计划开通博客是在去年，初衷也只是想记录记录自己的学习经历，起初也只是三天打鱼两天晒网的零零碎碎的写，后来过完年翻了新学期，可能是感受到了大学的时光不多了吧，可能是看到了与某些大神之间的差距吧，也可能是想明白了自己想要的是什么了吧，whatever，反正我就开始算着日子给自己制定了一个7个星期零2天计划，从计划开始到学期结束，正好是这么长的时间。 现在想来也真是一段疯狂的日子，把自己裹在学校的实验室里，早出晚归，平均每天保持10小时以上的学习时间（当然有偷懒啦..），不管是博客书籍还是视频都不管不顾的汲取里面的东西然后总结成自己的博文，时间很快就过去，在最后的总结中天真的写道：“从七个星期之前，还只是懂一点点Java的小伙子，现在已经是对Java Web还有Java熟悉的技术人员了吧”（当然现在看起来蛮打脸的..），hhh…果然还是年轻 从Java Web文集开始写的3-14号一直到计划快结束的时候，我已经不知不觉收获了600+粉丝，收到过工作邀请、写书邀请以及各种粉丝的鼓励加油喜欢，在博客园一篇关于SpringBoot的文章也是突破了16W的阅读量..emmm，这些无不让我更加鼓舞更加奋勇，渐渐也觉得自己终于是能看到大神的尾灯了，很安心。 暑期计划 为了完成自己新年给自己许的“来年变成一只工作狗”的心愿，暑假就待在学校继续学习准备即将来临的秋招了，期间也把自己总结的一些面试的东西都发了博客，还有幸去参与了一次封闭式开发（虽然觉得蛮滑水的，但是有钱拿，还混吃混喝，嘻嘻嘻..），也是一次别样的体验吧.. 也为了更好的在自己简历中加上一些亮眼的东西，自己在深入学习了一些底层知识的同时，也从零开始搭建了自己的个人博客，虽然后来在阿里二面的时候被面试官分分钟找到安全漏洞（后来给修复了..）..但仍然在造轮子的过程中学习了很多。 然后，经历秋招，见识到了更多大牛们，意识到自己到底还是菜，并且自己还有许多想要继续学习的东西，考虑再三，跟老妈通了一个长电话，决定考研。 考研计划 大致跟家里人说了一下之后，然后在博客发了一篇致小伙伴们书之后，就一头挤进了考研大军之中。说实在的，考研的日子比我想象的要单调得多，三点一线，每一天按部就班，生活没有一点起伏，我并不觉得辛苦，但这样的日子对我来说太折磨了，好在我坚持了下来，并且好消息是：考研还算顺利！不出意外，应该在今年就能当研究生学长啦~ 考完，也没有想象中的狂欢，倒是更想写代码一些，hhhh… 以前总觉得日子是过不完的，未来是完全不一样的。说不上来自己经历过这些有多大的变化，梦想也还像小时候一样遥远，或许唯一不同的是，有一些想法我已经开始着手去实现它。 01.展望2019希望19年仍然是“奋斗”的一年吧！并且把自己的公众号从wmyskxz_javaweb改为了wmyskxz（我没有三颗心脏的缩写），希望公众号和博客都从记录学习变成记录学习和生活吧。 然后希望19年的关键字是：学习/健身/阅读/记录/独立。 10.矫情的部分关于学习18年算是读了一些书，技术类/文学类/考研类…个人觉得学习最重要的还是保持清醒吧，清楚自己要学到哪一种程度，自己还欠缺一些什么知识，最好采用什么样的方法去学。特别喜欢并且受用的一句话是：方向不对，努力白费。开始行动之前多思考，不要把时间浪费在一些“无所谓”的事情身上。这样的清醒还应该延展到生活中，时刻提醒自己想要的是什么，为自己创造需要的环境，至少我是这样粗浅的以为的。 还喜欢一个知识边界的理论，比如我们把整个IT知识领域用一个与安全来表示，黑色实体部分就是我们刚开始认知的区域，因为我们刚开始知道的少，了解的少，里面的圆的周长就会小很多，我们感觉到自己需要了解的东西也相对小。（就像我在自己的总结里面写：自己是熟悉Java的编程人员一样） 当我们通过不断的学习、扩宽自己知识的边界，就像里面的小圆不断的长大一些，我们感受到的未知也越来越多，认识到自己了解的内容占整个体系只是很小的一部分。 另外分享一篇喜欢的文章：思维的局限 关于朋友 &amp; 家人18年的节奏一直是在学习、学习、学习，一直圈在学校的一方小天地，习惯了这样奇怪的节奏，对家人和朋友没有过多的关心，考完研了跟朋友聊天发现自己都快搭不上他们的话了，其实有些让我不知所措，但好在他们仍然热气腾腾，仍然让我感到年节的暖，我只敢说谢谢。我知道人生花团锦簇，某一刻终于和自己有关。 关于自己 “我一向觉得，自身对于他人而言，是一种不可理喻的存在，并且向他人寻求理解，也是一种荒谬不堪的暴力。他人总是超乎想象的难以理解我，但正因为这份不理解，我才得以自由；正因为这份不理解，我才得以活下去。我之所以拥有感受他人可爱之处的能力，也必定出于相同的原因。” “说来矫情，总觉得自己生来就带着一中自己也无法完全理解的悲伤，他无时无刻的折磨我，巨大到无法化解，任何感情也都无法慰藉，让我哭笑不得，更不得与之独处。而可喜的是，我同样深信不论最重我是否孑然一身，一定也只有它不会弃我而去，每每想到这儿的时候又让我无比安心。” 最后 感谢您一直看到了最后，分享我一直在用并且很喜欢的一张壁纸吧，Somewhere或许我还不能确定在哪里，但我知道此刻，对于我心中的Somewhere，我一定在路上！共勉！2019！ 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"致小伙伴们书","slug":"致小伙伴们书","date":"2018-09-26T23:05:00.000Z","updated":"2020-12-09T05:02:09.251Z","comments":true,"path":"2018/09/27/zhi-xiao-huo-ban-men-shu/","link":"","permalink":"http://www.wmyskxz.com/2018/09/27/zhi-xiao-huo-ban-men-shu/","excerpt":"","text":"致小伙伴们：你们好，感谢你们对于我的支持与喜爱，在很大一部分自学的时间里，都是因为你们的相伴你们的支持才使我走得更远看得更多，感谢； 经过诸多方面的考虑，也经历过提前批和秋招的洗礼，觉得自己有更多想要学习的东西，也有更多想要分享的内容，我决定踏上考研的道路，尽管可能时间不多，但还是想要去努力试试，所以会有很长一段时间不会跟大家见面了，但是请小伙伴们相信我，也请大家继续关注我，我的学习之路还没有停止，而是在准备着踏上一段更长更远的路，在这条路上我仍然希望有你们的支持.. 以上，感恩；","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"【面试必备】手撕代码，你怕不怕？","slug":"【面试必备】手撕代码，你怕不怕？","date":"2018-08-25T23:03:00.000Z","updated":"2020-12-09T04:42:34.269Z","comments":true,"path":"2018/08/26/mian-shi-bi-bei-shou-si-dai-ma-ni-pa-bu-pa/","link":"","permalink":"http://www.wmyskxz.com/2018/08/26/mian-shi-bi-bei-shou-si-dai-ma-ni-pa-bu-pa/","excerpt":"","text":"前言：不管是远程的视频面试，还是现场的面试，都有可能会有手撕代码的环节，这也是很多童鞋包括我(虽然还没遇到过..)都很头疼的东西，可能是因为 IDE 自动提示功能用惯了或是其他一些原因，总之让我手写代码就是感觉很奇怪..但是我想的话，这应该侧重考察的是一些细节或者是习惯方面的一些东西，所以还是防患于未然吧，把一些可能手撕的代码给准备准备，分享分享，希望可以得到各位的指正，然后能有一些讨论，由于我字太丑就不上传自己默写的代码了，但还是希望各位潦草写一遍加深一下印象吧，以上； Part 1.生产者-消费者问题这绝对是属于重点了，不管是考察对于该重要模型的理解还是考察代码能力，这都是一道很好的考题，所以很有必要的，我们先来回顾一下什么是生产者-消费者问题； 问题简单回顾 生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。(摘自维基百科：生产者消费者问题) 注意： 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差； 几种实现方式上面说到该问题的关键是：如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据；解决思路可以简单概括为： 生产者持续生产，直到缓冲区满，满时阻塞；缓冲区不满后，继续生产； 消费者持续消费，直到缓冲区空，空时阻塞；缓冲区不空后，继续消费； 生产者和消费者都可以有多个； 那么在 Java 语言中，能达到上述要求的，自然而然的就会有如下的几种写法，但是问题的核心都是能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用： wait()/notify()方式； await()/signal()方式； BlockingQueue阻塞队列方式； PipedInputStream/PipedOutputStream方式； 手写代码，我们着重掌握上面对应的第一种和第三种写法就足够了； wait()/notify()方式实现在手写代码之前，我们需要现在 IDE 上实现一遍，理解其中的过程并且找到一些重点/细节，我们先来代码走一遍，然后我把我理解的重点给圈儿出来： 生产者代码public class Producer implements Runnable { private volatile boolean isRunning = true; private final Vector sharedQueue; // 内存缓冲区 private final int SIZE; // 缓冲区大小 private static AtomicInteger count = new AtomicInteger(); // 总数，原子操作 private static final int SLEEPTIME = 1000; public Producer(Vector sharedQueue, int SIZE) { this.sharedQueue = sharedQueue; this.SIZE = SIZE; } @Override public void run() { int data; Random r = new Random(); System.out.println(\"start producer id = \" + Thread.currentThread().getId()); try { while (isRunning) { // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 当队列满时阻塞等待 while (sharedQueue.size() == SIZE) { synchronized (sharedQueue) { System.out.println(\"Queue is full, producer \" + Thread.currentThread().getId() + \" is waiting, size：\" + sharedQueue.size()); sharedQueue.wait(); } } // 队列不满时持续创造新元素 synchronized (sharedQueue) { data = count.incrementAndGet(); // 构造任务数据 sharedQueue.add(data); System.out.println(\"producer create data:\" + data + \", size：\" + sharedQueue.size()); sharedQueue.notifyAll(); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupted(); } } public void stop() { isRunning = false; } } 有了上面的提到的解决思路，应该很容易实现，但是这里主要提一下一些细节和重点： 创造数据：生产者-消费者解决的问题就是数据在多线程间的共享，所以我们首要关心的问题就应该是数据，我们这里采用的是使用一个AtomicInteger类来为我们创造数据，使用它的好处是该类是一个保证原子操作的类，我们使用其中的incrementAndGet()方法不仅能够保证线程安全，还可以达到一个计数的效果，所以是一个既简单又实用的选择，当然也可以使用其他的数据来代替，这里注意的是要保证该类在内存中只存在一份，使用static修饰； 内存缓冲区：要保证在多线程环境下内存缓冲区的安全，所以我们考虑使用简单的Vector类来作为我们的内存缓冲区，并且使用final修饰保证内存缓冲区的唯一，然后的话我们需要判断队列是否满，需要手动添加一个标识缓冲区大小的变量SIZE，注意也是final修饰； 模拟延迟：这里主要模拟的是一个网络延迟，我们首先定义了一个SLEEPTIME的延迟范围，注意使用的是static final修饰，然后使用Random()类的nextInt()方法来随机选取一个该范围内的值来模拟网络环境中的延迟； 停止方法：首先需要知道在Thread类中有一个弃用的stop()方法，我们自己增加一个标志位isRunning来完成我们自己的stop()功能，需要注意的是使用volatile来修饰，保证该标志位的可见性； 错误处理：当捕获到错误时，我们应该使用Thread类中的interrupted()方法来终止当前的进程； 消息提示：我们主要是要在控制台输出该生产者的信息，包括当前队列的状态，大小，当前线程的生产者信息等，注意的是信息格式的统一(后面的消费者同样的)； 消费者代码public class Consumer implements Runnable { private final Vector sharedQueue; // 内存缓冲区 private final int SIZE; // 缓冲区大小 private static final int SLEEPTIME = 1000; public Consumer(Vector sharedQueue, int SIZE) { this.sharedQueue = sharedQueue; this.SIZE = SIZE; } @Override public void run() { Random r = new Random(); System.out.println(\"start consumer id = \" + Thread.currentThread().getId()); try { while (true) { // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 当队列空时阻塞等待 while (sharedQueue.isEmpty()) { synchronized (sharedQueue) { System.out.println(\"Queue is empty, consumer \" + Thread.currentThread().getId() + \" is waiting, size：\" + sharedQueue.size()); sharedQueue.wait(); } } // 队列不空时持续消费元素 synchronized (sharedQueue) { System.out.println(\"consumer consume data：\" + sharedQueue.remove(0) + \", size：\" + sharedQueue.size()); sharedQueue.notifyAll(); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } } } 跟生产者相同的，你需要注意内存缓冲区/ 模拟延迟/ 错误处理/ 消息提示这些方面的细节问题，总体来说消费者就是持续不断的消费，也比较容易实现； 主线程代码有了我们的消费者和生产者代码，我们需要来验证一下它们的正确性，照常理来说我们直接创建一些消费者和生产者的线程让它们执行就可以了啊，但是为了“加分”考虑呢，我们还是使用线程池吧..也不是特别复杂： public static void main(String args[]) throws InterruptedException { // 1.构建内存缓冲区 Vector sharedQueue = new Vector(); int size = 4; // 2.建立线程池和线程 ExecutorService service = Executors.newCachedThreadPool(); Producer prodThread1 = new Producer(sharedQueue, size); Producer prodThread2 = new Producer(sharedQueue, size); Producer prodThread3 = new Producer(sharedQueue, size); Consumer consThread1 = new Consumer(sharedQueue, size); Consumer consThread2 = new Consumer(sharedQueue, size); Consumer consThread3 = new Consumer(sharedQueue, size); service.execute(prodThread1); service.execute(prodThread2); service.execute(prodThread3); service.execute(consThread1); service.execute(consThread2); service.execute(consThread3); // 3.睡一会儿然后尝试停止生产者 Thread.sleep(10 * 1000); prodThread1.stop(); prodThread2.stop(); prodThread3.stop(); // 4.再睡一会儿关闭线程池 Thread.sleep(3000); service.shutdown(); } 大家可以自行去看看运行的结果，是没有问题的，不会出现多生产或者多消费之类的多线程问题，运行一段时间等生产者都停止之后，我们可以观察到控制台三个消费者都在等待数据的情况： Queue is empty, consumer 17 is waiting, size：0 Queue is empty, consumer 15 is waiting, size：0 Queue is empty, consumer 16 is waiting, size：0 BlockingQueue阻塞队列方式实现该方式对比起上面一种方式实现起来要简单一些，因为不需要手动的去通知其他线程了，生产者直接往队列中放数据直到队列满，消费者直接从队列中获取数据直到队列空，BlockingQueue会自动帮我们完成阻塞这个动作，还是先来看看代码 生产者代码public class Producer implements Runnable { private volatile boolean isRunning = true; private BlockingQueue&lt;Integer> queue; // 内存缓冲区 private static AtomicInteger count = new AtomicInteger(); // 总数，原子操作 private static final int SLEEPTIME = 1000; public Producer(BlockingQueue&lt;Integer> queue) { this.queue = queue; } @Override public void run() { int data; Random r = new Random(); System.out.println(\"start producer id = \" + Thread.currentThread().getId()); try { while (isRunning) { // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 往阻塞队列中添加数据 data = count.incrementAndGet(); // 构造任务数据 System.out.println(\"producer \" + Thread.currentThread().getId() + \" create data：\" + data + \", size：\" + queue.size()); if (!queue.offer(data, 2, TimeUnit.SECONDS)) { System.err.println(\"failed to put data：\" + data); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupted(); } } public void stop() { isRunning = false; } } 跟上面一种方式没有很大的差别，倒是代码更加简单通透，不过需要注意的是对阻塞队列添加失败的错误处理； 消费者代码public class Consumer implements Runnable { private BlockingQueue&lt;Integer> queue; // 内存缓冲区 private static final int SLEEPTIME = 1000; public Consumer(BlockingQueue&lt;Integer> queue) { this.queue = queue; } @Override public void run() { int data; Random r = new Random(); System.out.println(\"start consumer id = \" + Thread.currentThread().getId()); try { while (true) { // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 从阻塞队列中获取数据 if (!queue.isEmpty()) { data = queue.take(); System.out.println(\"consumer \" + Thread.currentThread().getId() + \" consume data：\" + data + \", size：\" + queue.size()); } else { System.out.println(\"Queue is empty, consumer \" + Thread.currentThread().getId() + \" is waiting, size：\" + queue.size()); } } } catch (InterruptedException e) { e.printStackTrace(); Thread.currentThread().interrupt(); } } } 主线程代码public static void main(String args[]) throws InterruptedException { // 1.构建内存缓冲区 BlockingQueue&lt;Integer> queue = new LinkedBlockingDeque&lt;>(); // 2.建立线程池和线程 ExecutorService service = Executors.newCachedThreadPool(); Producer prodThread1 = new Producer(queue); Producer prodThread2 = new Producer(queue); Producer prodThread3 = new Producer(queue); Consumer consThread1 = new Consumer(queue); Consumer consThread2 = new Consumer(queue); Consumer consThread3 = new Consumer(queue); service.execute(prodThread1); service.execute(prodThread2); service.execute(prodThread3); service.execute(consThread1); service.execute(consThread2); service.execute(consThread3); // 3.睡一会儿然后尝试停止生产者 Thread.sleep(10 * 1000); prodThread1.stop(); prodThread2.stop(); prodThread3.stop(); // 4.再睡一会儿关闭线程池 Thread.sleep(3000); service.shutdown(); } 因为队列中添加和删除的操作比较频繁，所以这里使用LinkedBlockingQueue来作为阻塞队列，所以这里除了内存缓冲区有所不同以外，其他的都差不多…当然你也可以指定一个队列的大小； 总结以及改进生产者-消费者模式很好地对生产者线程和消费者线程进行解耦，优化了系统整体的结构，同时由于缓冲区的作用，允许生产者线程和消费者线程存在执行上的性能差异，从一定程度上缓解了性能瓶颈对系统性能的影响；上面两种写法都是非常常规的写法，只能说能起码能在及格的基础上加个那么点儿分数，如果想要得高分可以去搜索搜搜 Disruptor 来实现一个无锁的生产者-消费者模型….这里就不提及了.. 改进：上面的线程输出可能会有点儿不友好（不直观），因为我们这里是直接使用的线程的 ID 来作为输出，我们也可以给线程弄一个名字来作为输出，以上； Part 2.排序算法排序算法当然也算是重点考察的对象之一了，毕竟基础且偏算法，当然我们有必要去了解常见的排序算法以及它们采取了怎样的思想又是如何实现的还有复杂度的问题，但是这里的话，主要就提及两种考的比较常见的排序算法：冒泡和快排，以及分别对它们进行的一些优化； 冒泡排序冒泡应该是比较基础的一种算法，我们以从小到大排序为例，它的基础思想是：从第一个数开始直到数组倒数第二个数，每一轮都去比较数组中剩下的数，如果后面的数据更小则两数交换，这样一轮一轮的比较交换下来，最大的那个数也就“沉到”了数组的最后，最小的“冒”到了数组的最前面，这样就完成了排序工作； 基础算法代码（未优化）很简单，直接上代码： /** * 冒泡排序 * * @param nums 待排序的数组 */ public void bubbleSort(int[] nums) { // 正确性判断 if (null == nums || nums.length &lt;= 1) { return; } // 从小到大排序 for (int i = 0; i &lt; nums.length - 1; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] > nums[j]) { nums[i] = nums[i] + nums[j]; nums[j] = nums[i] - nums[j]; nums[i] = nums[i] - nums[j]; } } } } 这里需要注意：加上正确性判断；（讨论：其实我看大多数地方都是没有这个的，不知道有没有加上的必要…求讨论） 另外光写完实现冒泡排序的算法是不算完的，还要养成良好的习惯去写测试单元用例，而且尽可能要考虑到多的点，例如这里的负数、多个相同的数之类的特殊情况，我就大概写一个吧，也欢迎指正： @Test public void bubbleSortTester() { // 测试用例1：验证负数是否满足要求 int[] nums = {1, 4, 2, -2, 5, 11, -7, 0}; bubbleSort(nums); // 输出测试结果 for (int i = 0; i &lt; nums.length; i++) { System.out.print(nums[i] + \", \"); } System.out.println(); // 测试用例2：验证多个相同的数是否满足要求 nums = new int[]{1, 1, 5, 7, 7, 3, 1}; bubbleSort(nums); // 输出测试结果 for (int i = 0; i &lt; nums.length; i++) { System.out.print(nums[i] + \", \"); } } 冒泡排序优化想象一个这样的场景：如果该数组基本有序，或者在数组的后半段基本有序，上面的算法就会浪费许多的时间开销，所以我们不再使用双重嵌套去比较每两个元素的值，而只是不断比较数组每前后两个数值，让大的那个数不断“冒”到数组的最后，然后缩小尾边界的范围，并且增加一个标志位，表示这一趟是否发生了交换，如果没有那么证明该数组已经有序则完成了排序了： /** * 改进的冒泡排序 * * @param nums 待排序的数组 */ public void bubbleSort2(int[] nums) { // 正确性判断 if (null == nums || nums.length &lt;= 1) { return; } // 使用一个数来记录尾边界 int length = nums.length; boolean flag = true;// 发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。 while (flag) { flag = false;// 每次开始排序前，都设置flag为未排序过 for (int i = 1; i &lt; length; i++) { if (nums[i - 1] > nums[i]) {// 前面的数字大于后面的数字就交换 int temp; temp = nums[i - 1]; nums[i - 1] = nums[i]; nums[i] = temp; // 表示交换过数据; flag = true; } } length--; // 减小一次排序的尾边界 } } 同样的记得写单元测试函数； 冒泡排序进一步优化顺着这个思路，我们进一步想象一个场景：现在有一个包含 1000 个数的数组，仅有前面 100 个数无序，后面的 900 个数都比前面的 100 个数更大并且已经排好序，那么上面优化的方法又会造成一定的时间浪费，所以我们进一步增加一个变量记录最后发生交换的元素的位置，也就是排序的尾边界了： /** * 冒泡算法最优解 * * @param nums 待排序的数组 */ public static void bubbleSort3(int[] nums) { int j, k; int flag = nums.length;// flag来记录最后交换的位置，也就是排序的尾边界 while (flag > 0) {// 排序未结束标志 k = flag;// k 来记录遍历的尾边界 flag = 0; for (j = 1; j &lt; k; j++) { if (nums[j - 1] > nums[j]) {// 前面的数字大于后面的数字就交换 // 交换a[j-1]和a[j] int temp; temp = nums[j - 1]; nums[j - 1] = nums[j]; nums[j] = temp; // 表示交换过数据; flag = j;// 记录最新的尾边界. } } } } 这应该是最优的冒泡排序了，同时也别忘记了最后要写测试单元用例代码； 快速排序快排也是一种很经典的算法，它使用了一种分治的思想，基本思想是：通过一趟排序将待排序的数组分成两个部分，其中一部分记录的是比关键字更小的，另一部分是比关键字更大的，然后再分别对着两部分继续进行排序，直到整个序列有序； 基础实现非常经典的代码，直接上吧： public static void quickSort(int[] arr) { qsort(arr, 0, arr.length - 1); } private static void qsort(int[] arr, int low, int high) { if (low &lt; high) { int pivot = partition(arr, low, high); // 将数组分为两部分 qsort(arr, low, pivot - 1); // 递归排序左子数组 qsort(arr, pivot + 1, high); // 递归排序右子数组 } } private static int partition(int[] arr, int low, int high) { int pivot = arr[low]; // 枢轴记录 while (low &lt; high) { while (low &lt; high &amp;&amp; arr[high] >= pivot) --high; arr[low] = arr[high]; // 交换比枢轴小的记录到左端 while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) ++low; arr[high] = arr[low]; // 交换比枢轴小的记录到右端 } // 扫描完成，枢轴到位 arr[low] = pivot; // 返回的是枢轴的位置 return low; } 当然，在手撕的时候需要注意函数上的 Java Doc 格式的注释，这里省略掉是为了节省篇幅，另外别忘了测试单元用例代码； 上面的代码也很容易理解，其实就是一个“填坑”的过程，第一个“坑”挖在每次排序的第一个位置arr[low]，从序列后面往前找第一个比pivot小的数来把这个“坑”填上，这时候的“坑”就变成了当前的arr[high]，然后再从序列前面往后用第一个比pivot大的数把刚才的“坑”填上，如此往复，始终有一个“坑”需要我们填上，直到最后一个“坑”出现，这个“坑”使用一开始的pivot填上就可以了，而这个“坑”的位置也就是pivot该填上的正确位置，我们再把这个位置返回，就可以把当前序列分成两个部分再依次这样操作最终就达到排序的目的了，不得不说这样的思想挺神奇的； 算法优化上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是O(n㏒n)，而是O(n^2)了。 究其根源，在于我们的代码实现中，每次只从数组第一个开始取。如果我们采用“三者取中”，即 arr[low], arr[high], arr[(low+high)/2] 三者的中值作为枢轴记录，则可以大大提高快速排序在最坏情况下的性能。但是，我们仍然无法将它在数组有序情形下的性能提高到O(n)。还有一些方法可以不同程度地提高快速排序在最坏情况下的时间性能。 此外，快速排序需要一个递归栈，通常情况下这个栈不会很深，为log(n)级别。但是，如果每次划分的两个数组长度严重失衡，则为最坏情况，栈的深度将增加到O(n)。此时，由栈空间带来的空间复杂度不可忽略。如果加上额外变量的开销，这里甚至可能达到恐怖的O(n^2)空间复杂度。所以，快速排序的最差空间复杂度不是一个定值，甚至可能不在一个级别。 为了解决这个问题，我们可以在每次划分后比较两端的长度，并先对短的序列进行排序（目的是先结束这些栈以释放空间），可以将最大深度降回到O(㏒n)级别。 关于优化的话，了解一个大概的思路就可以了，那在这里稍微总结一下： ①三数取中作为枢轴记录； ②当待排序序列的长度分割到一定大小之后，使用插入排序； ③在一次分割结束后，可以把与pivot相等的元素聚在一起，继续下次分割时，不用再对与pivot相等的元素分割； ④优化递归操作； 参考文章：http://blog.51cto.com/flyingcat2013/1281614想要了解的更多的童鞋可以戳这里：https://blog.csdn.net/insistGoGo/article/details/7785038 Part 3.二叉树相关算法二叉树也是一个容易提及的概念和写算法的问题，特别是它的几种递归遍历和非递归遍历，都是基础且常考的点，那在这里就稍微整理整理吧… 二叉树的几种递归遍历前序、中序、后序遍历都是非常基础且容易的遍历方法，重点还是在后面的中序和后续的非递归遍历上，当然还有层序遍历，所以这里不多说，直接给代码； 前序遍历递归实现public void preOrderTraverse1(TreeNode root) { if (root != null) { System.out.print(root.val + \" \"); preOrderTraverse1(root.left); preOrderTraverse1(root.right); } } 中序遍历递归实现public void inOrderTraverse1(TreeNode root) { if (root != null) { preOrderTraverse1(root.left); System.out.print(root.val + \" \"); preOrderTraverse1(root.right); } } 后序遍历递归实现public void postOrderTraverse1(TreeNode root) { if (root != null) { preOrderTraverse1(root.left); preOrderTraverse1(root.right); System.out.print(root.val + \" \"); } } 前面三种遍历，也就是输出结点数据的位置不同而已，所以很容易，但是如果手写，建议问清楚面试官要求，是在遍历时直接输出还是需要函数返回一个List集合，然后注意写测试用例代码！ 二叉树的几种非递归遍历★★层序遍历★★层序遍历我们只需要增加使用一个队列即可，看代码很容易理解： public void levelTraverse(TreeNode root) { if (root == null) { return; } LinkedList&lt;TreeNode> queue = new LinkedList&lt;>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); System.out.print(node.val + \" \"); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } 前序遍历非递归实现public void preOrderTraverse2(TreeNode root) { if (root == null) { return; } LinkedList&lt;TreeNode> stack = new LinkedList&lt;>(); TreeNode pNode = root; while (pNode != null || !stack.isEmpty()) { if (pNode != null) { System.out.print(pNode.val + \" \"); stack.push(pNode); pNode = pNode.left; } else { //pNode == null &amp;&amp; !stack.isEmpty() TreeNode node = stack.pop(); pNode = node.right; } } } ★★中序遍历非递归实现★★/** * 非递归中序遍历二叉树 * * @param root 二叉树根节点 * @return 中序遍历结果集 */ public List&lt;Integer> inorderTraversal(TreeNode root) { List&lt;Integer> list = new ArrayList&lt;>(); ArrayDeque&lt;TreeNode> stack = new ArrayDeque&lt;>(); while (root != null || !stack.isEmpty()) { while (root != null) { stack.addFirst(root); root = root.left; } root = stack.removeFirst(); list.add(root.val); root = root.right; } return list; } ★★后续遍历非递归实现★★/** * 二叉树的后序遍历 * * @param root 二叉树根节点 * @return 后序遍历结果集 */ public List&lt;Integer> postorderTraversal(TreeNode root) { List&lt;Integer> list = new ArrayList&lt;>(); Deque&lt;TreeNode> stack = new ArrayDeque&lt;>(); TreeNode pre = null; while (!stack.isEmpty() || root != null) { while (root != null) { stack.push(root); root = root.left; } root = stack.peek(); // i ：判断如果右子树不为空且不为 if (root.right != null &amp;&amp; root.right != pre) { root = root.right; } else { root = stack.pop(); list.add(root.val); pre = root; root = null; } } return list; } 如果比较难以理解的话，可以自己尝试着跟跟 Debug 然后看看过程； 二叉树相关其他算法题另外的话还有一些比较常见的关于树的算法，在文章的末尾，这里就不再赘述了： 链接：https://www.jianshu.com/p/4ef1f50d45b5 Part 4.其他重要算法除了上面 3 Part 比较重要的点之外，还有一些其他的算法也是经常考到的，下面我们来说； 1.反转链表这是一道很经典的题，不仅考你对链表的理解，而且还有一些细节（例如正确性判断/ 测试用例）需要你从代码层面去展现，下面我们给出两段代码，读者可以自行去比较，我只是提供一个思路； 思路一：使用一个 Node 不断链接这是最经典的算法，也是需要我们牢牢掌握的方法，最重要的还是理解 while() 循环中的过程： public ListNode reverseList(ListNode head) { // 正确性判断 if (null == head || null == head.next) { return head; } ListNode pre = null; while (null != head) { ListNode temp = head; head = head.next; temp.next = pre; pre = temp; } return pre; } 思路二：反转元素值然后重新赋给 Node这是一个很简单的思路，比上个思路要多遍历一遍链表，但是好处是简单，思路清晰，实现起来容易，emm，像这一类问题我觉得另一个比较重要的就是举一反三的能力吧，在这里我只提供两个思路，其实还有很多种实现方法，当然也别忘了细节的东西~ public ListNode reverseList(ListNode head) { // 1.正确性判断 if (null == head || null == head.next) { return head; } // 2.遍历链表head并将结果保存在List集合中 List&lt;ListNode> list = new LinkedList(); ListNode tempNode = head; while (null != tempNode) { list.insert(tempNode.val); tempNode = tempNode.next; } // end while：遍历完了链表并将结果保存在了List集合中 // 3.反转集合，并将值依次复制给链表 Collections.reverse(list); tempNode = head; while (null != tempNode) { tempNode.val = list.remove(0); tempNode = tempNode.next; } return head; } 2.合并两个有序链表问题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的； 同样的经典算法，需要掌握： public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } if (l2 == null) { return l1; } ListNode head = null; if (l1.val &lt; l2.val) { head = l1; head.next = mergeTwoLists(l1.next, l2); } else { head = l2; head.next = mergeTwoLists(l1, l2.next); } return head; } 这道题也是 LeetCode 上的一道题，我当时的做法是下面这样的，虽然看起来代码量多了不少而且看起来蠢蠢的..但是经过 LeetCode 测试，甚至比上面的实现要快上那么 2ms，特别提醒：下面的代码只是用作一个思路的参考，着重掌握上面的代码 ： public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 定义一个虚拟头结点方便遍历 ListNode dummyHead = new ListNode(-1); dummyHead.next = l1; ListNode pre = dummyHead; // 遍历l1链表 int len1 = 0; while (null != pre.next) { len1++; pre = pre.next; } int[] nums1 = new int[len1]; // 保存l1链表的数据 pre = dummyHead; for (int i = 0; i &lt; len1; i++) { nums1[i] = pre.next.val; pre = pre.next; } // 遍历l2链表 int len2 = 0; dummyHead.next = l2; pre = dummyHead; while (null != pre.next) { len2++; pre = pre.next; } int[] nums2 = new int[len2]; // 保存l2链表的数据 pre = dummyHead; for (int i = 0; i &lt; len2; i++) { nums2[i] = pre.next.val; pre = pre.next; } int[] nums = new int[len1 + len2]; // 将两个链表的数据整合并排序 System.arraycopy(nums1, 0, nums, 0, len1); System.arraycopy(nums2, 0, nums, len1, len2); Arrays.sort(nums); // 拼接一个链表 ListNode dummy = new ListNode(-1); pre = dummy; for (int i = 0; i &lt; nums.length; i++) { ListNode node = new ListNode(nums[i]); pre.next = node; pre = pre.next; } return dummy.next; } 3.两个链表的第一个公共结点题目描述：找出两个链表的第一个公共结点； /** * 求两个链表中第一个公共结点 * * @param pHead1 链表1头结点 * @param pHead2 链表2头结点 * @return 链表第一个公共结点 */ public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { // 1.正确性判断 if (null == pHead1 || null == pHead2) { return null; } // 2.遍历链表1把所有结点保存在列表中中 Vector&lt;ListNode> nodeList1 = new Vector&lt;>(); while (null != pHead1) { nodeList1.add(pHead1); pHead1 = pHead1.next; // 判断是否成环，成环则退出循环 if (nodeList1.contains(pHead1)) { break; } } // end while：链表1中的所有结点都存入了nodeList1中 // 3.遍历链表2比较列表中的数据 Vector&lt;ListNode> nodeList2 = new Vector&lt;>(); while (null != pHead2) { // 先判断nodeList1中是否存在相同结点，存在则返回 if (nodeList1.contains(pHead2)) { return pHead2; } // 如果不存在则继续遍历，并判断是否成环 nodeList2.add(pHead2); pHead2 = pHead2.next; if (nodeList2.contains(pHead2)) { break; } } // end while：遍历完了链表2并将所有结点保存在了nodeList2中 // 如果遍历完链表2则返回null return null; } 需要注意的细节是：①正确性判断；②判断链表是否自己成环；③注释；④注意要自己写测试用例啊… 另外还有一些类似的题目像是：①链表入环结点；②链表倒数第k个结点；之类的都是需要掌握的… 4.二分查找算法二分查找也是一类比较常考的题目，其实代码也比较容易理解，直接上吧，再再再提醒一下：注意正确性判断还有测试用例… 普通实现/** * 二分查找普通实现。 * * @param srcArray 有序数组 * @param key 查找元素 * @return 不存在返回-1 */ public static int binSearch(int srcArray[], int key) { int mid; int start = 0; int end = srcArray.length - 1; while (start &lt;= end) { mid = (end - start) / 2 + start; if (key &lt; srcArray[mid]) { end = mid - 1; } else if (key > srcArray[mid]) { start = mid + 1; } else { return mid; } } return -1; } 递归实现/** * 二分查找递归实现。 * * @param srcArray 有序数组 * @param start 数组低地址下标 * @param end 数组高地址下标 * @param key 查找元素 * @return 查找元素不存在返回-1 */ public static int binSearch(int srcArray[], int start, int end, int key) { int mid = (end - start) / 2 + start; if (srcArray[mid] == key) { return mid; } if (start >= end) { return -1; } else if (key > srcArray[mid]) { return binSearch(srcArray, mid + 1, end, key); } else if (key &lt; srcArray[mid]) { return binSearch(srcArray, start, mid - 1, key); } return -1; } 5.斐波那契数列这也是一道很经典的题，通常是要要求 N 值的范围的，常规写法应该很简单，所以需要掌握的是优化之后的算法： public int Fibonacci(int n) { // 正确性判断 if (0 == n || 1 == n) { return n; } int nums1 = 0, nums2 = 1; int res = 0; for (int i = 2; i &lt;= n; i++) { res = nums1 + nums2; nums1 = nums2; nums2 = res; } return res; } 还是注意正确性判断然后写测试用例… 手撕代码总结如果用手写代码的话，确实是个挺麻烦的事儿，首先需要对代码有相当的熟悉程度，然后其次的话考察的都是一些细节的东西，例如： 编码规范：包括一些命名的规范/ 注释的规范等等； 缩进：这个我自己倒是挺在意的..关于这个可以去参考参考阿里出的那个规范手册； 注释：如果命名规范做得好的话其实是可以达到代码即注释的，但是仍然有一些需要标注的地方例如函数头之类的，最好还是做好注释； 代码的完整性：我觉得这个包括对于错误的处理/ 正确性判断这样一类的东西； 测试用例：每个函数都需要一定的测试来保证其正确性，所以这个还是挺有必要的，特别是一些边界情况，null 值判断之类的； 想好再下笔：这一点其实也蛮重要的，不管是在纸上还是在我们平时的编程中，思路永远都是更重要的； 说来说去还是关于代码的事，我觉得还是理清思路最重要，所以我们需要在一遍一遍熟悉代码的过程中，熟知这些代码的思路，只有搞清楚这些代码背后的原理了，我们才能正确且快速的写出我们心中想要的代码，而不是简单的去背诵，这样是没有很大效果的，以上… 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料想要交流的朋友也可以加qq群：3382693","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java I/O不迷茫，一文为您导航！","slug":"Java-I-O不迷茫，一文为您导航！","date":"2018-08-14T23:01:00.000Z","updated":"2020-12-09T05:04:16.374Z","comments":true,"path":"2018/08/15/java-i-o-bu-mi-mang-yi-wen-wei-nin-dao-hang/","link":"","permalink":"http://www.wmyskxz.com/2018/08/15/java-i-o-bu-mi-mang-yi-wen-wei-nin-dao-hang/","excerpt":"","text":"前言：在之前的面试中，每每问到关于Java I/O 方面的东西都感觉自己吃了大亏..所以这里抢救一下..来深入的了解一下在Java之中的 I/O 到底是怎么回事..文章可能说明类的文字有点儿多，希望能耐心读完.. 什么是 I/O?学习过计算机相关课程的童鞋应该都知道，I/O 即输入Input/ 输出Output的缩写，最容易让人联想到的就是屏幕这样的输出设备以及键盘鼠标这一类的输入设备，其广义上的定义就是：数据在内部存储器和外部存储器或其他周边设备之间的输入和输出； 我们可以从定义上看到问题的核心就是：数据/ 输入/ 输出，在Java中，主要就是涉及到磁盘 I/O 和网络 I/O 两种了； 简单理解Java 流（Stream）通常我们说 I/O 都会涉及到诸如输入流、输出流这样的概念，那么什么是流呢？流是一个抽象但形象的概念，你可以简单理解成一个数据的序列，输入流表示从一个源读取数据，输出流则表示向一个目标写数据，在Java程序中，对于数据的输入和输出都是采用 “流” 这样的方式进行的，其设备可以是文件、网络、内存等； 流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。 可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。 “流”，代表了任何有能力产出数据的数据源对象或有能力接受数据的接收端对象，它屏蔽了实际的 I/O 设备中处理数据的细节——摘自《Think in Java》 参考资料：深入理解 Java中的 流 (Stream)：https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html Java中的 I/O 类库的基本架构I/O 问题是任何编程语言都无法回避的问题，因为 I/O 操作是人机交互的核心，是机器获取和交换信息的主要渠道，所以如何设计 I/O 系统变成了一大难题，特别是在当今大流量大数据的时代，I/O 问题尤其突出，很容易称为一个性能的瓶颈，也正因为如此，在 I/O 库上也一直在做持续的优化，例如JDK1.4引入的 NIO，JDK1.7引入的 NIO 2.0，都一定程度上的提升了 I/O 的性能； Java的 I/O 操作类在包 java.io下，有将近80个类，这些类大概可以分成如下 4 组： 基于字节操作的 I/O 接口：InputStream 和 OutputStream； 基于字符操作的 I/O 接口：Writer 和 Reader； 基于磁盘操作的 I/O 接口：File； 基于网络操作的 I/O 接口：Socket； 前两组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket类并不在java.io包下，但这里仍然把它们划分在了一起；I/O 只是人机交互的一种手段，除了它们能够完成这个交互功能外，我们更多的应该是关注如何提高它的运行效率； 00.基于字节的 I/O 操作接口基于字节的 I/O 操作的接口输入和输出分别对应是 InputStream 和 OutputStream，InputStream 的类层次结构如下图： 输入流根据数据类型和操作方式又被划分成若干个子类，每个子类分别处理不同操作类型，OutputStream 输出流的类层次结构也是类似，如下图所示： 这里就不详细解释每个子类如何使用了，如果感兴趣可以自己去看一下JDK的源码，而且的话从类名也能大致看出一二该类是在处理怎样的一些东西..这里需要说明两点： 1）操作数据的方式是可以组合使用的： 例如： OutputStream out = new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream(\"fileName\"))； 2）必须要指定流最终写到什么地方： 要么是写到磁盘，要么是写到网络中，但重点是你必须说明这一点，而且你会发现其实SocketOutputStream是属于FileOutputStream下的，也就是说写网络实际上也是写文件，只不过写网络还有一步需要处理，就是让底层的操作系统知道我这个数据是需要传送到其他地方而不是本地磁盘上的； 01.基于字符的 I/O 操作接口不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是在我们日常的程序中操作的数据几乎都是字符，所以为了操作方便当然要提供一个可以直接写字符的 I/O 接口。而且从字符到字节必须经过编码转换，而这个编码又非常耗时，还经常出现乱码的问题，所以 I/O 的编码问题经常是让人头疼的问题，关于这个问题有一篇深度好文推荐一下：《深入分析 Java 中的中文编码问题》 下图是写字符的 I/O 操作接口涉及到的类，Writer 类提供了一个抽象方法 write(char cbuf[], int off, int len) 由子类去实现： 读字符的操作接口也有类似的类结构，如下图所示： 读字符的操作接口中也是 int read(char cbuf[], int off, int len)，返回读到的 n 个字节数，不管是 Writer 还是 Reader 类它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘和网络的工作机制。 01.字节与字符的转化接口另外数据持久化或网络传输都是以字节进行的，所以必须要有字符到字节或字节到字符的转化。字符到字节需要转化，其中读的转化过程如下图所示： InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。StreamDecoder 正是完成字节到字符的解码的实现类。也就是当你用如下方式读取一个文件时： try { StringBuffer str = new StringBuffer(); char[] buf = new char[1024]; FileReader f = new FileReader(\"file\"); while(f.read(buf)>0){ str.append(buf); } str.toString(); } catch (IOException e) {} FileReader 类就是按照上面的工作方式读取文件的，FileReader 是继承了 InputStreamReader 类，实际上是读取文件流，然后通过 StreamDecoder 解码成 char，只不过这里的解码字符集是默认字符集。 写入也是类似的过程如下图所示： 通过 OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程。 磁盘 I/O 的工作机制在介绍 Java 读取和写入磁盘文件之前，先来看看应用程序访问文件有哪几种方式； 几种访问文件的方式我们知道，读取和写入文件 I/O 操作都调用的是操作系统提供给我们的接口，因为磁盘设备是归操作系统管的，而只要是系统调用都可能存在内核空间地址和用户空间地址切换的问题，这是为了保证用户进程不能直接操作内核，保证内核的安全而设计的，现代的操作系统将虚拟空间划分成了内核空间和用户空间两部分并实现了隔离，但是这样虽然保证了内核程序运行的安全性，但是也必然存在数据可能需要从内核空间向用户用户空间复制的问题； 如果遇到非常耗时的操作，如磁盘 I/O，数据从磁盘复制到内核空间，然后又从内核空间复制到用户空间，将会非常耗时，这时操作系统为了加速 I/O 访问，在内核空间使用缓存机制，也就是将从磁盘读取的文件按照一定的组织方式进行缓存，入股用户程序访问的是同一段磁盘地址的空间数据，那么操作系统将从内核缓存中直接取出返回给用户程序，这样就可以减少 I/O 的响应时间； 00. 标准访问文件的方式 读取的方式是，当应用程序调用read()接口时： ①操作系统首先检查在内核的高速缓存中是否存在需要的数据，如果有，那么直接从缓存中返回； ②如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中； 写入的方式是，当应用程序调用write()接口时： 从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说写操作就已经完成了，至于什么时候在写到磁盘中由操作系统决定，除非显示地调用了 sync 同步命令； 01.直接 I/O 方式 所谓的直接 I/O 的方式就是应用程序直接访问磁盘数据，而不经过操作系统内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制； 这种访问文件的方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中，如在数据库管理系统中，系统明确地知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率，而这些情况如果是交给操作系统进行缓存，那么操作系统将不知道哪些数据是热点数据，哪些是只会访问一次的数据，因为它只是简单的缓存最近一次从磁盘读取的数据而已； 但是直接 I/O 也有负面影响，如果访问的数据不再应用程序缓存之中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢，因此直接 I/O 通常与 异步 I/O 进行结合以达到更好的性能； 10.内存映射的方式 内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。 同步和异步访问文件的方式另外还有两种方式，一种是数据的读取和写入都是同步操作的同步方式，另一种是是当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待的异步访问方式，但从笔者就《深入分析 Java Web技术内幕》一书中的内容来看，这两种方式更像是对标准访问方式的一个具体说明，是标准访问方式对应的两种不同处理方法，知道就好了… Java 访问磁盘文件我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。 何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。 下面以上文读取文件的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示： 当传入一个文件路径，将会根据这个路径创建一个 File 对象来标识这个文件，然后将会根据这个 File 对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符 FileDescriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要 StreamDecoder 类将 byte 解码为 char 格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。至于操作系统是如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答，至于文件系统的相关细节可以参考另外的文章。 参考文章：深入分析 Java I/O 的工作机制关于这一part，我们只需要了解一下就可以，我也是直接复制就完事儿… Java 序列化技术Java序列化就是将一个对象转化成一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的。需要持久化，对象必须继承 java.io.Serializable 接口，或者将其转为字节数组，用于网络传输； 一个实际的序列化例子第一步：创建一个用于序列化的对象 为了具体说明序列化在Java中是如何运作的，我们来写一个实际的例子，首先我们来写一个用于序列化的对象，然后实现上述的接口： /** * 用于演示Java中序列化的工作流程... * * @author: @我没有三颗心脏 * @create: 2018-08-15-下午 14:37 */ public class People implements Serializable{ public String name; public transient int age; public void sayHello() { System.out.println(\"Hello,My Name is \" + name); } } 注意：一个类的对象想要序列化成功，必须满足两个条件 ①实现上述的接口； ②保证该类的所有属性必须都是可序列化的，如果不希望某个属性序列化（例如一些敏感信息），可以加上transient关键字； 第二步：序列化对象 如下的代码完成了实例化一个 People 对象并其序列化到D盘的根目录下的一个操作，这里呢按照 Java 的标准约定将文件的后缀写成 .ser 的样子，你也可以写成其他的… People people = new People(); people.name = \"我没有三颗心脏\"; people.age = 21; try { FileOutputStream fileOutputStream = new FileOutputStream(\"D:/people.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOutputStream); out.writeObject(people); out.close(); fileOutputStream.close(); System.out.println(\"Serialized data is saved in D:/\"); } catch (IOException e) { e.printStackTrace(); } 第三步：反序列化对象 下面的程序完成了对刚才我们序列化的文件还原成一个People对象的过程，并获取了其中的参数，但是注意，由于我们希望 age 属性是短暂的加入了transient关键字， 所以我们无法获取到序列化时 People 的 age 属性： People people = null; try { FileInputStream fileIn = new FileInputStream(\"D:/people.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); people = (People) in.readObject(); in.close(); fileIn.close(); } catch (IOException i) { i.printStackTrace(); return; } catch (ClassNotFoundException c) { System.out.println(\"People class not found\"); c.printStackTrace(); return; } System.out.println(\"Deserialized People...\"); System.out.println(\"Name: \" + people.name); System.out.println(\"Age: \" + people.age); 输出结果如下： Deserialized People... Name: 我没有三颗心脏 Age: 0 serialVersionUID的作用上述的例子中我们完成了对一个 People 对象序列化和反序列化的过程，我们现在来做一点简单的修改，例如把age字段的transient关键字去掉： public class People implements Serializable { public String name; public int age; public void sayHello() { System.out.println(\"Hello,My Name is \" + name); } } 然后我们再运行我们刚才反序列化的代码，会发现，这个时候程序竟然报错了，说是serialVersionUID不一致： 事实上，如果你经常看别人的代码的话，或许会有留意到诸如这样的代码： private static final long serialVersionUID = 876323262645176354L; 就这一长串的东西也不知道是在干嘛的，但这其实是为了保证序列化版本的兼容性，即在版本升级后序列化仍保持对象的唯一性；我们通过上述的修改也感受到了其中的一二，但是问题是：我们并没有在需要序列化的对象中写任何关于这个UID的代码呀？ 这是个有趣的问题，通常情况下，如果我们实现了序列化接口，但是没有自己显式的声明这个UID的话，那么JVM就会根据该类的类名、属性名、方法名等自己计算出一个独一无二的变量值，然后将这个变量值一同序列化到文件之中，而在反序列化的时候同样，会根据该类计算出一个独一无二的变量然后进行比较，不一致就会报错，但是我怀着强烈的好奇心去反编译了一下.class文件，并没有发现编译器写了UDI这一类的东西，我看《深入分析 Java Web 技术内幕》中说，实际上是写到了二进制文件里面了； 不显式声明的缺点：一旦写好了某一个类，那么想要修改就不行了，所以我们最好自己显式的去声明； 显式声明的方式：①使用默认的1L作用UID；②根据类名、接口名等生成一个64位的哈希字段，现在的编译器如IDEA、Eclipse都有这样的功能，大家感兴趣去了解下； 序列化用来干什么？虽然我们上面的程序成功将一个对象序列化保存到磁盘，然后从磁盘还原，但是这样的功能到底可以应用在哪些场景？到底可以干一些什么样的事情呢？下面举一些在实际应用中的例子： Web服务器中保存Session对象，如Tomcat会在服务器关闭时把session序列化存储到一个名为session.ser的文件之中，这个过程称为session的钝化； 网络上传输对象，如分布式应用等； 关于序列化的一些细节1.如果一个类没有实现Serializable接口，但是它的基类实现了，那么这个类也是可以序列化的； 2.相反，如果一个类实现了Serializable接口，但是它的父类没有实现，那么这个类还是可以序列化（Object是所有类的父类），但是序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，会发现该变量数值与序列化时的数值不同（一般为null或者其他默认值），而且这个父类里面必须有无参的构造方法，不然子类反序列化的时候会报错。 了解到这里就可以了，更多的细节感兴趣的童鞋可以自行去搜索引擎搜索.. 网络 I/O 工作机制数据从一台主机发送到网络中的另一台主机需要经过很多步骤，首先双方需要有沟通的意向，然后要有能够沟通的物理渠道（物理链路），其次，还要保障双方能够正常的进行交流，例如语言一致的问题、说话顺序的问题等等等； Java Socket 的工作机制看到有地方说：网络 I/O 的实质其实就是对 Socket 的读取；那Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。 下图是典型的基于 Socket 的通信的场景： 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。 建立通信链路当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。 与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。 数据传输传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。 当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。 NIO 的工作方式BIO 带来的挑战BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。 NIO 的工作机制很多人都把NIO翻译成New IO，但我更觉得No-Block IO更接近它的本意，也就是非阻塞式IO，它虽然是非阻塞式的，但它是同步的，我们先看一下 NIO 涉及到的关联类图，如下： 上图中有两个关键类：Channel 和 Selector，它们是 NIO 中两个核心概念。我们还用前面的城市交通工具来继续比喻 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态。这里还有一个 Buffer 类，它也比 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 是汽车的话就是汽车上的座位，高铁上就是高铁上的座位，它始终是一个具体的概念，与 Stream 不同。Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是你在去上车之前并不知道，这个车上是否还有没有座位了，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了，对你是透明的。 NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度是需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的。而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制。 理解了这些概念后我们看一下，实际上它们是如何工作的，下面是典型的一段 NIO 代码： public void selector() throws IOException { ByteBuffer buffer = ByteBuffer.allocate(1024); Selector selector = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false);//设置为非阻塞方式 ssc.socket().bind(new InetSocketAddress(8080)); ssc.register(selector, SelectionKey.OP_ACCEPT);//注册监听的事件 while (true) { Set selectedKeys = selector.selectedKeys();//取得所有key集合 Iterator it = selectedKeys.iterator(); while (it.hasNext()) { SelectionKey key = (SelectionKey) it.next(); if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) { ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel(); SocketChannel sc = ssChannel.accept();//接受到服务端的请求 sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_READ); it.remove(); } else if ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) { SocketChannel sc = (SocketChannel) key.channel(); while (true) { buffer.clear(); int n = sc.read(buffer);//读取数据 if (n &lt;= 0) { break; } buffer.flip(); } it.remove(); } } } } 调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器。 在上面的这段程序中，是将 Server 端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在实际应用中，我们通常会把它们放在两个线程中，一个线程专门负责监听客户端的连接请求，而且是阻塞方式执行的；另外一个线程专门来处理请求，这个专门处理请求的线程才会真正采用 NIO 的方式，像 Web 服务器 Tomcat 和 Jetty 都是这个处理方式，关于 Tomcat 和 Jetty 的 NIO 处理方式可以参考文章《 Jetty 的工作原理和与 Tomcat 的比较》。 下图是描述了基于 NIO 工作方式的 Socket 请求的处理过程： 上图中的 Selector 可以同时监听一组通信信道（Channel）上的 I/O 状态，前提是这个 Selector 要已经注册到这些通信信道中。选择器 Selector 可以调用 select() 方法检查已经注册的通信信道上的是否有 I/O 已经准备好，如果没有至少一个信道 I/O 状态有变化，那么 select 方法会阻塞等待或在超时时间后会返回 0。上图中如果有多个信道有数据，那么将会将这些数据分配到对应的数据 Buffer 中。所以关键的地方是有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连接请求。 Buffer 的工作方式上面介绍了 Selector 将检测到有通信信道 I/O 有数据传输时，通过 selelct() 取得 SocketChannel，将数据读取或写入 Buffer 缓冲区。下面讨论一下 Buffer 如何接受和写出数据？ Buffer 可以简单的理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有四个索引。如下表所示： 索引 说明 capacity 缓冲区数组的总长度 position 下一个要操作的数据元素的位置 limit 缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity mark 用于记录当前 position 的前一个位置或者默认是 0 在实际操作数据时它们有如下关系图： 我们通过 ByteBuffer.allocate(11) 方法创建一个 11 个 byte 的数组缓冲区，初始状态如上图所示，position 的位置为 0，capacity 和 limit 默认都是数组长度。当我们写入 5 个字节时位置变化如下图所示： 这时底层操作系统就可以从缓冲区中正确读取这 5 个字节数据发送出去了。在下一次写数据之前我们在调一下 clear() 方法。缓冲区的索引状态又回到初始位置。 这里还要说明一下 mark，当我们调用 mark() 时，它将记录当前 position 的前一个位置，当我们调用 reset 时，position 将恢复 mark 记录下来的值。 还有一点需要说明，通过 Channel 获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区再将数据复制到 Buffer 中，这个的操作系统缓冲区就是底层的 TCP 协议关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较耗性能，Buffer 提供了另外一种直接操作操作系统缓冲区的的方式即 ByteBuffer.allocateDirector(size)，这个方法返回的 byteBuffer 就是与底层存储空间关联的缓冲区，它的操作方式与 linux2.4 内核的 sendfile 操作方式类似。 Java NIO 实例上面从 NIO 中引入了一些概念，下面我们对这些概念再来进行简单的复述和补充： 缓冲区Buffer：缓冲区是一个对象，里面存的是数据，NIO进行通讯，传递的数据，都包装到Buffer中，Buffer是一个抽象类。子类有ByteBuffer、CharBuffer等，常用的是字节缓冲区，也就是ByteBuffer； 通道Channel：channel是一个通道，通道就是通流某种物质的管道，在这里就是通流数据，他和流的不同之处就在于，流是单向的，只能向一个方向流动，而通道是一个管道，有两端，是双向的，可以进行读操作，也可以写操作，或者两者同时进行； 多路复用器Selector：多路复用器是一个大管家，他管理着通道，通道把自己注册到Selector上面，Selector会轮询注册到自己的管道，通过判断这个管道的不同的状态，来进行相应的操作； NIO 工作机制的核心思想就是：客户端和服务器端都是使用的通道，通道具有事件，可以将事件注册到多路复选器上，事件有就绪和非就绪两种状态，就绪的状态会放到多路复选器的就绪键的集合中，起一个线程不断地去轮询就绪的状态，根据不同的状态做不同的处理 参考资料：https://wangjingxin.top/2017/01/17/io/ NIO 和 IO 的主要区别 面向流与面向缓冲.Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。 阻塞与非阻塞IOJava IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 选择器（Selectors）Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 Java AIO 简单了解AIO就是异步非阻塞IO，A就是asynchronous的意思，因为NIO1.0虽然面向缓冲，利用多路复选器实现了同步非阻塞IO，可是在NIO1.0中需要使用一个线程不断去轮询就绪集合，开销也是比较大的，所以在jdk1.7中扩展了NIO，称之为NIO2.0，NIO2.0中引入了AIO，此外NIO2.0中还引入了异步文件通道，那么究竟是怎么实现异步的呢？ AIO 有三个特点，它的特点也可以说明它是如何完成异步这样的操作的： ①读完了再通知我； ②不会加快 I/O，只是在读完后进行通知； ③使用回调函数，进行业务处理； AIO 的核心原理就是：对客户端和服务器端的各种操作进行回调函数的注册（通过实现一个CompletionHandler接口，其中定义了一个completed的成功操作方法和一个fail的失败方法）。在完成某个操作之后，就会自己去调用该注册到该操作的回调函数，达到异步的效果。 BIO/ NIO/ AIO 的简单理解我们在这里假设一个烧了一排开水的场景，BIO（同步阻塞IO）的做法就是，叫一个线程停留在一个水壶那，直到这个水壶烧开我再去处理下一个水壶；NIO（准备好再通知我，同步非阻塞IO）的做法就是叫一个线程不断地去询问每个水壶的状态，看看是否有水壶的状态发生了变化，变化则再去做相应的处理；AIO（读完了再通知我，异步非阻塞IO）的做法是在每个水壶上都安装一个装置，当水壶烧开之后就会自动通知我水壶烧开了让我做相应的处理； 如果还觉得理解起来有困难的童鞋建议阅读以下这篇文章，相信会有收获：http://loveshisong.cn/编程技术/2016-06-25-十分钟了解BIO-NIO-AIO.html BIO、NIO、AIO适用场景分析 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 简单总结这篇文章大量复制粘贴到《深入分析 Java Web 技术内幕》第二节“深入分析 Java I/O 的工作机制”的内容，没办法确实很多描述性的概念以及说明，自己的说明也没有达到用简单语言能描述复杂事物的程度..所以可能看起来这篇文章会有那么点儿难以下咽..我自己的话也是为了写着一篇文章查了很多资料，书也是翻了很多很多遍才对Java 中的 I/O 相关的知识有所熟悉，不过耗费的时间也是值得的，同时也希望观看文章的你能够有所收获，也欢迎各位指正！ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"秋招提前批（CVTE一面挂、阿里三面挂）","slug":"秋招提前批（CVTE一面挂、阿里三面挂）","date":"2018-08-14T22:58:00.000Z","updated":"2020-12-09T04:56:54.850Z","comments":true,"path":"2018/08/15/qiu-zhao-ti-qian-pi-cvte-yi-mian-gua-a-li-san-mian-gua/","link":"","permalink":"http://www.wmyskxz.com/2018/08/15/qiu-zhao-ti-qian-pi-cvte-yi-mian-gua-a-li-san-mian-gua/","excerpt":"","text":"7月27日：CVTE一面 30分钟（挂） 自我介绍 有没有做过JavaWeb相关的项目？你觉得难点在哪里呢？ 你这个博客系统有没有加权限系统？如果被拦截封包获取了账号密码怎么办？（没加，凉拌..） 用过事务吗？怎么用的举一个实际的例子？ Spring中的@Transactional放在类级别和方法级别上有什么不同？（不知道..） 你对Java哪一个方面的知识熟悉？ List/ Set/ Map有什么区别？ 谈一下HashMap插入元素的过程？ HashMap安全吗？那有安全的Map吗？ 多线程并发有什么问题？刚才安全的Map是如何解决这个问题的？ Java中实现多线程有哪些方式？ 总体感觉CVTE一面还没开始问就已经结束了…所以面完感觉挺不好的，总觉得自己会凉凉…结果一查结果真凉了…懵逼… 7月30日：阿里一面 36分钟 自我介绍 面试官开始自己介绍他所属的部门然后平时的一些业务 说一下HashMap的底层结构？ 为什么1.8要引入红黑树这种结构呢？ HashMap线程安全吗？那有没有线程安全的Map？（ConcurrentHashMap还有一个Collections类中的静态内部类SynrhonizedMap） ConcurrentHashMap底层结构？ 对JDK1.5的concurrent包了解吗？（不了解…） Java中有两种错误你能说一下嘛？（想不起具体名字来了..解释了半天..） 说下JVM的内存结构？（本地方法栈打死没想起来…）堆、栈分别存储什么信息？ 说一下新生代和永久代有什么关系？ 平时学校学什么课？算法和数据结构学过吧？ 说一个你印象最深刻的数据结构，用来解决什么典型问题？（堆、TopK问题） 说一个典型的算法解决什么问题？再回答一个（答得不好…） 贪心算法有什么优点缺点？贪心算法可能不是最优解那什么算法能解决呢？（动态规划这个词老想不起来..） Spring了解吗？说一下装载Bean的过程？ 设计模式了解吗？说几个常用的 装饰器模式和代理模式有什么区别？ 看你做过这么多项目说一个你刚开始难以解决然后通过什么方式最终解决的？ 有没有什么要问我的？ 平时都怎么学习的？ 正在寝室收拾东西的时候预约了6分钟后面试，那个激动..总的来说感觉答得不好，确实是没啥面试经验，有很多东西自己知道没有表达，不过回答的时候倒是挺有自信的，电话一挂脑子一去回想.药丸…不过面试官还算是比较好的…希望能过吧… 8月5日：阿里二面 60分钟 面试官开场白：介绍部门、业务，上一轮面试的大概情况，今天准备聊一聊编程能力和项目的一些问题； 面向对象三大特点？你怎么理解多态？Java中是怎么实现多态的？ 序列化有了解过吗？ Java网络I/O了解吗？（不是很了解..）HTTP三次握手和四次挥手的详细过程能说下吗？ 设计题：一个网络聊天室有思路吗？不要求界面，只说思路（后来想了想回答的很一般..） ArrayList和LinkedList的区别？ArrayList是怎么扩容的？ Java中有两种异常，你能说说嘛（感觉是看了上一个面试官的评价来看我复习没有的感觉..）？Exception又分为两种你知道吗？举一个RunTimeException你遇到过的？（我说的NullPointer）除了这个你再说一个？再举一个非RunTimeException？ GC什么时候开始？我调用System.gc()能保证GC一定发生吗？ 你说一下类加载器是怎么回事？（我说了一下双亲委派模型..但后来想面试官好像问的是怎么加载class？…）怎么实现自己的类加载器？ 设计题：现在我的jar包在云上，怎么动态添加进我的项目中？（不知道..后来想了一下自己写ClassLoader应该可以..） 看你简历有前端的东西，那前端盒子模型有了解吗？ 可以给margin或者padding这样的属性赋值为负数吗？ 我想把border变成一个虚线该怎么写？（忘了具体的dashed，只记得border-style..） 平常都用什么数据库？（MySQL）那MySQL有两种引擎了解吗？有什么区别？（这个说得挺完整的）我要用SQL获得一个表级锁应该怎么写？（不了解..）我给一个表三个ABC列建了一个组合索引，我查询B会用到索引嘛？（不知道..） 事务了解吗？四大基本特性？什么是隔离性？数据库并发有几个隔离级别？（我说我从面临的问题开始说面试官说不用只用说几个级别就可以）MySQL默认级别？你确定？（确定..） 平时有用到什么框架？（Spring/ SpringMVC/ SpringBoot/ MyBatis） MyBatis问一个问题，在mapper文件中#{}和${}有什么区别？ Spring有两大特性，你是怎么理解IoC控制反转的？AOP实现原理你了解吗？JDK代理为什么非要实现一个接口呢？（这个一时间忘了…） MVC你是怎么理解的？ 什么时候需要重写equals()？什么时候需要重写hashCode()？ 项目相关，你博客是从0到有的？为什么要造这个轮子？ JavaWeb安全方面的问题，你这个留言啥的有没有啥问题？（XSS攻击）知道有问题为啥不搞一下？（我…） 我把面试结果报上去，一般两三天后出结果，拜拜； 因为是靠回忆，所以有些问题的顺序有点儿记不太清了，比较基础但是有些宽泛..问了我一些前端的问题..比较遗憾的是网络I/O这一块自己不是特别熟悉，然后那一道设计题自己没有回答得很好..面试官说看得出我基础还行就是深度不够，他说要看总体的面试情况如果靠前就安排下一轮面试，让我自己下去准备等通知，但总觉得他在套路我..早上转发了一只专属锦鲤，希望能带来好运吧.. 8月13日：阿里三面（P9钉钉视频面） 120分钟左右1.面试官让进一个链接做六道题，一个小时之后它来看代码，可以搜索资料啥的都可以，大概是这样六道题：①反转一串字符串；②从一串JSON字符串中提取所有的一个属性并输出；③统计一串字符串中的数字、英文字母、空格、其他字符的个数并打印输出；④计算N的阶乘；⑤数组排序算法随便写；⑥创建三个线程ABC，分别打印其线程名十次，并按照ABC的顺序执行；2.最近的项目有没有什么想说的？印象深刻的？3.项目有什么难点？怎么解决的？4.设计模式有了解过哪些？模板模式应用于什么样的场景？5.OSI七层模型知道吗？IP在哪一层？TCP在哪一层？6.对称加密与非对称加密有了解吗？7.谈谈对BIO/ NIO/ AIO的理解？（有点忘了..说的有点问题面试官给解释了一下..）分别用于什么样的场景？8.SpringBoot你觉得对于MVC有什么不一样的地方，有什么优点？9.平时怎么学习的？10.有什么要问的..然后问了一些自己关心的问题，并让面试官给我一些建议，感觉自己凉凉.. 第二天下午更新了状态显示已回绝了.. 简单总结其实自己投了蛮多公司的，但是目前接到电话并且面试的，就只有阿里和CVTE，特别是CVTE感觉还蛮效率的..投递了没过几天就打电话预约面试了，emm..虽然两家公司提前批的面试都挂了..但我已经重新申请了正常的网申流程..嘻嘻..感觉还是基础至上吧..而且的话，电话面试的经验也很重要，现在回想CVTE一面的时候确实自己也不知道是个啥状态..问题也没有回答很好..挂的那自然也是理所当然..对于阿里的话就比较可惜吧..特别是三面，问的问题都不是自己不知道的，而差不多都是自己有些遗忘或者不是很熟悉的..决定还是抓紧时间回炉锻造锻造.. 不过幸运的是这只是提前批吧..自己还是有一些时间去准备，通过上面的四次面试也是知道了自己的不足，另外想说的一点是：举一反三的能力，阿里三面也跟面试官有聊到，就是一个问题，你回答的时候最好能够引申出其他相关的一些东西，换位思考的角度讲，面试官希望这样，而你又能很好的展现自己的能力和基础知识，特别担心那种自己明明知道却说不好的问题，或者是遗漏了一些点的问题，还是下来需要多花时间准备吧..加油.. 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料想要交流的朋友也可以加qq群：3382693","categories":[{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java集合必会14问(精选面试题整理)","slug":"Java集合必会14问-精选面试题整理","date":"2018-07-27T22:56:00.000Z","updated":"2020-12-09T05:05:25.317Z","comments":true,"path":"2018/07/28/java-ji-he-bi-hui-14-wen-jing-xuan-mian-shi-ti-zheng-li/","link":"","permalink":"http://www.wmyskxz.com/2018/07/28/java-ji-he-bi-hui-14-wen-jing-xuan-mian-shi-ti-zheng-li/","excerpt":"前言：把这段时间复习的关于集合类的东西整理出来，特别是HashMap相关的一些东西，之前都没有很注意1.7 -&gt;&gt; 1.8的变化问题，但后来发现这其实变化挺大的，而且很多整理的面试资料都没有更新（包括我之前整理的…）","text":"前言：把这段时间复习的关于集合类的东西整理出来，特别是HashMap相关的一些东西，之前都没有很注意1.7 -&gt;&gt; 1.8的变化问题，但后来发现这其实变化挺大的，而且很多整理的面试资料都没有更新（包括我之前整理的…） 1）说说常见的集合有哪些吧？答：Map接口和Collection接口是所有集合框架的父接口： Collection接口的子接口包括：Set接口和List接口 Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等 Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等 List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等 2）HashMap与HashTable的区别？答： HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的； HashMap允许K/V都为null；后者K/V都不允许为null； HashMap继承自AbstractMap类；而Hashtable继承自Dictionary类； 3）HashMap的put方法的具体流程？ 图引用自：https://blog.csdn.net/u011240877/article/details/53358305 答：下面先来分析一下源码 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { HashMap.Node&lt;K,V>[] tab; HashMap.Node&lt;K,V> p; int n, i; // 1.如果table为空或者长度为0，即没有元素，那么使用resize()方法扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 2.计算插入存储的数组索引i，此处计算方法同 1.7 中的indexFor()方法 // 如果数组为空，即不存在Hash冲突，则直接插入数组 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 3.插入时，如果发生Hash冲突，则依次往下判断 else { HashMap.Node&lt;K,V> e; K k; // a.判断table[i]的元素的key是否与需要插入的key一样，若相同则直接用新的value覆盖掉旧的value // 判断原则equals() - 所以需要当key的对象重写该方法 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // b.继续判断：需要插入的数据结构是红黑树还是链表 // 如果是红黑树，则直接在树中插入 or 更新键值对 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value); // 如果是链表，则在链表中插入 or 更新键值对 else { // i .遍历table[i]，判断key是否已存在：采用equals对比当前遍历结点的key与需要插入数据的key // 如果存在相同的，则直接覆盖 // ii.遍历完毕后任务发现上述情况，则直接在链表尾部插入数据 // 插入完成后判断链表长度是否 > 8：若是，则把链表转换成红黑树 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 对于i 情况的后续操作：发现key已存在，直接用新value覆盖旧value&amp;返回旧value if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 插入成功后，判断实际存在的键值对数量size > 最大容量 // 如果大于则进行扩容 if (++size > threshold) resize(); // 插入成功时会调用的方法（默认实现为空） afterNodeInsertion(evict); return null; } 图片简单总结为： 4）HashMap的扩容操作是怎么实现的？答：通过分析源码我们知道了HashMap通过resize()方法进行扩容或者初始化的操作，下面是对源码进行的一些简单分析： /** * 该函数有2中使用情况：1.初始化哈希表；2.当前数组容量过小，需要扩容 */ final Node&lt;K,V>[] resize() { Node&lt;K,V>[] oldTab = table;// 扩容前的数组（当前数组） int oldCap = (oldTab == null) ? 0 : oldTab.length;// 扩容前的数组容量（数组长度） int oldThr = threshold;// 扩容前数组的阈值 int newCap, newThr = 0; if (oldCap > 0) { // 针对情况2：若扩容前的数组容量超过最大值，则不再扩容 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 针对情况2：若没有超过最大值，就扩容为原来的2倍（左移1位） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } // 针对情况1：初始化哈希表（采用指定或者使用默认值的方式） else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每一个bucket都移动到新的bucket中去 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V> loHead = null, loTail = null; Node&lt;K,V> hiHead = null, hiTail = null; Node&lt;K,V> next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 5）HashMap是怎么解决哈希冲突的？ 参考资料：https://juejin.im/post/5ab99afff265da23a2291dee 答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行； 什么是哈希？Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 什么是哈希冲突？当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。 HashMap的数据结构在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突： 这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化 hash()函数上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下： static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);// 与自己右移16位进行异或运算（高低位异或） } 这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）； JDK1.8新增红黑树 通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)； 总结简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的： 1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快； 6）HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置； 面试官：那怎么解决呢？ 答： HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均； 在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题； 面试官：为什么数组长度要保证为2的幂次方呢？ 答： 只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率； 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 面试官：那为什么是两次扰动呢？ 答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的； 7）HashMap在JDK1.7和JDK1.8中有哪些不同？答： 不同 JDK 1.7 JDK 1.8 存储结构 数组 + 链表 数组 + 链表 + 红黑树 初始化方式 单独函数：inflateTable() 直接集成到了扩容函数resize()中 hash值计算方式 扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算 扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算 存放数据的规则 无冲突时，存放数组；冲突时，存放链表 无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树 插入数据方式 头插法（先讲原位置的数据移到后1位，再插入数据到该位置） 尾插法（直接插入到链表尾部/红黑树） 扩容后存储位置的计算方式 全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)） 按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量） 8）为什么HashMap中String、Integer这样的包装类适合作为K？答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率 都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况 内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况； 面试官：如果我想要让自己的Object作为K应该怎么办呢？ 答：重写hashCode()和equals()方法 重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞； 重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性； 9）ConcurrentHashMap和Hashtable的区别？答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 面试官：ConcurrentHashMap的具体实现知道吗？ 参考资料：http://www.importnew.com/23610.html 答：在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下： 该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色； Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。 在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下： 插入元素过程（建议去看看源码）： 如果相应位置的Node还没有初始化，则调用CAS插入相应的数据； else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } 如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点； if (fh >= 0) { binCount = 1; for (Node&lt;K,V> e = f;; ++binCount) { K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V> pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V>(hash, key, value, null); break; } } } 如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值； 如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount； 10）Java集合的快速失败机制 “fail-fast”？答： 是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。 例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 1. 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。 2. 使用CopyOnWriteArrayList来替换ArrayList 11）ArrayList 和 Vector 的区别？答： 这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。 ArrayList 与 Vector 的区别主要包括两个方面： 同步性：Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 数据增长：ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 2 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 (0.5 倍 + 1) 个空间。 12）ArrayList和LinkedList的区别？答： LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；ArrayList 实现了 List 接口，动态数组； LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高； LinkedList 比 ArrayList 需要更多的内存； 面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？ 答：它们的区别是： Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 Array 大小是固定的，ArrayList 的大小是动态变化的。 ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 13）HashSet是如何保证数据不可重复的？答：HashSet的底层其实就是HashMap，只不过我们HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存，我们可以看到源码： public boolean add(E e) { return map.put(e, PRESENT)==null;// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值 } 由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性； 14）BlockingQueue是什么？答： Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"数据结构与算法(4)——优先队列和堆","slug":"数据结构与算法-4-——优先队列和堆","date":"2018-07-11T22:53:00.000Z","updated":"2020-12-09T04:59:30.436Z","comments":true,"path":"2018/07/12/shu-ju-jie-gou-yu-suan-fa-4-you-xian-dui-lie-he-dui/","link":"","permalink":"http://www.wmyskxz.com/2018/07/12/shu-ju-jie-gou-yu-suan-fa-4-you-xian-dui-lie-he-dui/","excerpt":"","text":"前言：题图无关，接下来开始简单学习学习优先队列和堆的相关数据结构的知识； 前序文章： 数据结构与算法(1)——数组与链表（https://www.jianshu.com/p/7b93b3570875） 数据结构与算法(2)——栈和队列(https://www.jianshu.com/p/5087c751cb42) 数据结构与算法(3)——树（二叉、二叉搜索树）(https://www.jianshu.com/p/4ef1f50d45b5) 什么是优先队列？听这个名字就能知道，优先队列也是一种队列，只不过不同的是，优先队列的出队顺序是按照优先级来的；在有些情况下，可能需要找到元素集合中的最小或者最大元素，可以利用优先队列ADT来完成操作，优先队列ADT是一种数据结构，它支持插入和删除最小值操作（返回并删除最小元素）或删除最大值操作（返回并删除最大元素）； 这些操作等价于队列的enQueue和deQueue操作，区别在于，对于优先队列，元素进入队列的顺序可能与其被操作的顺序不同，作业调度是优先队列的一个应用实例，它根据优先级的高低而不是先到先服务的方式来进行调度； 如果最小键值元素拥有最高的优先级，那么这种优先队列叫作升序优先队列（即总是先删除最小的元素），类似的，如果最大键值元素拥有最高的优先级，那么这种优先队列叫作降序优先队列（即总是先删除最大的元素）；由于这两种类型时对称的，所以只需要关注其中一种，如升序优先队列； 优先队列ADT下面操作组成了优先队列的一个ADT； 1.优先队列的主要操作优先队列是元素的容器，每个元素有一个相关的键值； insert(key, data)：插入键值为key的数据到优先队列中，元素以其key进行排序； deleteMin/deleteMax：删除并返回最小/最大键值的元素； getMinimum/getMaximum：返回最小/最大剑指的元素，但不删除它； 2.优先队列的辅助操作 第k最小/第k最大：返回优先队列中键值为第k个最小/最大的元素； 大小（size）：返回优先队列中的元素个数； 堆排序（Heap Sort）：基于键值的优先级将优先队列中的元素进行排序； 优先队列的应用 数据压缩：赫夫曼编码算法； 最短路径算法：Dijkstra算法； 最小生成树算法：Prim算法； 事件驱动仿真：顾客排队算法； 选择问题：查找第k个最小元素； 等等等等…. 优先队列的实现比较 实现 插入 删除 寻找最小值 无序数组 1 n n 无序链表 1 n n 有序数组 n 1 1 有序链表 n 1 1 二叉搜索树 logn(平均) logn(平均) logn(平均) 平衡二叉搜索树 logn logn logn 二叉堆 logn logn 1 堆和二叉堆什么是堆堆是一颗具有特定性质的二叉树，堆的基本要求就是堆中所有结点的值必须大于或等于（或小于或等于）其孩子结点的值，这也称为堆的性质；堆还有另一个性质，就是当 h &gt; 0 时，所有叶子结点都处于第 h 或 h - 1 层（其中 h 为树的高度，完全二叉树），也就是说，堆应该是一颗完全二叉树； 在下面的例子中，左边的树为堆（每个元素都大于其孩子结点的值），而右边的树不是堆（因为5大于其孩子结点2） 二叉堆在二叉堆中，每个结点最多有两个孩子结点，在实际应用中，二叉堆已经足够满足需求，因此接下来主要讨论二叉最小堆和二叉最大堆； 堆的表示：在描述堆的操作前，首先来看堆是怎样表示的，一种可能的方法就是使用数组，因为堆在形式上是一颗完全二叉树，用数组来存储它不会浪费任何空间，例如下图： 用数组来表示堆不仅不会浪费空间还具有一定的优势： 每个结点的左孩子为下标i的2倍：left child(i) = i * 2；每个结点的右孩子为下标i的2倍加1：right child(i) = i * 2 + 1 每个结点的父亲结点为下标的二分之一：parent(i) = i / 2，注意这里是整数除，2和3除以2都为1，大家可以验证一下； 注意：这里是把下标为0的地方空出来了的，主要是为了方便理解，如果0不空出来只需要在计算的时候把i值往右偏移一个位置就行了（也就是加1，大家可以试试，下面的演示也采取这样的方式）； 二叉堆的相关操作堆的基本结构public class MaxHeap&lt;E extends Comparable&lt;E>> { private Array&lt;E> data; public MaxHeap(int capacity){ data = new Array&lt;>(capacity); } public MaxHeap(){ data = new Array&lt;>(); } // 返回堆中的元素个数 public int size(){ return data.getSize(); } // 返回一个布尔值, 表示堆中是否为空 public boolean isEmpty(){ return data.isEmpty(); } // 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引 private int parent(int index){ if(index == 0) throw new IllegalArgumentException(\"index-0 doesn't have parent.\"); return (index - 1) / 2; } // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index){ return index * 2 + 1; } // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index){ return index * 2 + 2; } } 向堆中添加元素和Sift Up当插入一个元素到堆中时，它可能不满足堆的性质，在这种情况下，需要调整堆中元素的位置使之重新变成堆，这个过程称为堆化（heapifying）；在最大堆中，要堆化一个元素，需要找到它的父亲结点，如果不满足堆的基本性质则交换两个元素的位置，重复该过程直到每个结点都满足堆的性质为止，下面我们来模拟一下这个过程： 下面我们在该堆中插入一个新的元素26： 我们通过索引（上面的公式）可以很容易地找到新插入元素的父亲结点，然后比较它们的大小，如果新元素更大则交换两个元素的位置，这个操作就相当于把该元素上浮了一下： 重复该操作直到26到了一个满足堆条件的位置，此时就完成了插入的操作： 对应的代码如下： // 向堆中添加元素 public void add(E e){ data.addLast(e); siftUp(data.getSize() - 1); } private void siftUp(int k){ while(k > 0 &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; 0 ){ data.swap(k, parent(k)); k = parent(k); } } 取出堆中的最大元素和Sift Down如果理解了上述的过程，那么取出堆中的最大元素（堆顶元素）将变得容易，不过这里运用到一个小技巧，就是用最后一个元素替换掉栈顶元素，然后把最后一个元素删除掉，这样一来元素的总个数也满足条件，然后只需要把栈顶元素依次往下调整就好了，这个操作就叫做Sift Down（下沉）： 用最后元素替换掉栈顶元素，然后删除最后一个元素： 然后比较其孩子结点的大小： 如果不满足堆的条件，那么就跟孩子结点中较大的一个交换位置： 重复该步骤，直到16到达合适的位置： 完成取出最大元素的操作： 对应的代码如下： // 看堆中的最大元素 public E findMax(){ if(data.getSize() == 0) throw new IllegalArgumentException(\"Can not findMax when heap is empty.\"); return data.get(0); } // 取出堆中最大元素 public E extractMax(){ E ret = findMax(); data.swap(0, data.getSize() - 1); data.removeLast(); siftDown(0); return ret; } private void siftDown(int k){ while(leftChild(k) &lt; data.getSize()){ int j = leftChild(k); // 在此轮循环中,data[k]和data[j]交换位置 if( j + 1 &lt; data.getSize() &amp;&amp; data.get(j + 1).compareTo(data.get(j)) > 0 ) j ++; // data[j] 是 leftChild 和 rightChild 中的最大值 if(data.get(k).compareTo(data.get(j)) >= 0 ) break; data.swap(k, j); k = j; } } Replace 和 HeapifyReplace这个操作其实就是取出堆中最大的元素之后再新插入一个元素，常规的做法是取出最大元素之后，再利用上面的插入新元素的操作对堆进行Sift Up操作，但是这里有一个小技巧就是直接使用新元素替换掉堆顶元素，之后再进行Sift Down操作，这样就把两次O(logn）的操作变成了一次O(logn)： // 取出堆中的最大元素，并且替换成元素e public E replace(E e){ E ret = findMax(); data.set(0, e); siftDown(0); return ret; } Heapify翻译过来就是堆化的意思，就是将任意数组整理成堆的形状，通常的做法是遍历数组从0开始添加创建一个新的堆，但是这里存在一个小技巧就是把当前数组就看做是一个完全二叉树，然后从最后一个非叶子结点开始进行Sift Down操作就可以了，最后一个非叶子结点也很好找，就是最后一个结点的父亲结点，大家可以验证一下： 从22这个节点开始，依次开始Sift Down操作： 重复该过程直到堆顶元素： 完成堆化操作： 将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn)，而heapify的过程，算法复杂度为O(n)，这是有一个质的飞跃的，下面是代码： public MaxHeap(E[] arr){ data = new Array&lt;>(arr); for(int i = parent(arr.length - 1) ; i >= 0 ; i --) siftDown(i); } 基于堆的优先队列首先我们的队列仍然需要继承我们之前将队列时候声明的哪个接口Queue，然后实现这个接口中的方法就可以了，之类简单写一下： public class PriorityQueue&lt;E extends Comparable&lt;E>> implements Queue&lt;E> { private MaxHeap&lt;E> maxHeap; public PriorityQueue(){ maxHeap = new MaxHeap&lt;>(); } @Override public int getSize(){ return maxHeap.size(); } @Override public boolean isEmpty(){ return maxHeap.isEmpty(); } @Override public E getFront(){ return maxHeap.findMax(); } @Override public void enqueue(E e){ maxHeap.add(e); } @Override public E dequeue(){ return maxHeap.extractMax(); } } Java中的PriorityQueue在Java中也实现了自己的优先队列java.util.PriorityQueue，与我们自己写的不同之处在于，Java中内置的为最小堆，然后就是一些函数名不一样，底层还是维护了一个Object类型的数组，大家可以戳戳看有什么不同，另外如果想要把最小堆变成最大堆可以给PriorityQueue传入自己的比较器，例如： // 默认为最小堆 PriorityQueue&lt;Integer> pq = new PriorityQueue&lt;>(); pq.add(5); pq.add(2); pq.add(1); pq.add(10); pq.add(3); while (!pq.isEmpty()) { System.out.println(pq.poll() + \", \"); } System.out.println(); System.out.println(\"————————————————————————\"); // 使用Lambda表达式传入自己的比较器转换成最大堆 PriorityQueue&lt;Integer> pq2 = new PriorityQueue&lt;>((a, b) -> b - a); pq2.add(5); pq2.add(2); pq2.add(1); pq2.add(10); pq2.add(3); while (!pq2.isEmpty()) { System.out.println(pq2.poll() + \", \"); } LeetCode相关题目整理23. 合并K个排序链表 参考答案：（85ms） public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.length == 0) return null; PriorityQueue&lt;ListNode> q = new PriorityQueue&lt;>(Comparator.comparing(node -> node.val)); for (int i = 0; i &lt; lists.length; i++) { if (lists[i] != null) { q.add(lists[i]); } } ListNode dummy = new ListNode(0); ListNode tail = dummy; while (!q.isEmpty()) { tail.next = q.poll(); tail = tail.next; if (tail.next != null) { q.add(tail.next); } } return dummy.next; } 215. 数组中的第K个最大元素 我的答案：（75ms） public int findKthLargest(int[] nums, int k) { // 正确性判断 if (0 == nums.length || null == nums || k &lt;= 0 || k > nums.length) { return -1; } // 构造优先队列,默认为最小堆,传入自定义的比较器转换成最大堆 PriorityQueue&lt;Integer> pq = new PriorityQueue&lt;>((a, b) -> b - a); for (Integer num : nums) { pq.add(num); } for (int i = 0; i &lt; k - 1; i++) { pq.remove(); } return pq.peek(); } 参考答案：（5ms） public int findKthLargest(int[] nums, int k) { if (nums.length == 1) { return nums[0]; } int max = nums[0]; int min = nums[0]; for (int i : nums) { max = i > max ? i : max; min = i &lt; min ? i : min; } int[] arrs = new int[max - min + 1]; for (int i : nums) { arrs[max - i]++; } int pos = 0; for (int i = 0; i &lt; arrs.length; i++) { pos += arrs[i]; if (pos >= k) { return max - i; } } return nums[0]; } 还看到一个简单粗暴的，也是服了：（4ms） public int findKthLargest(int[] nums, int k) { Arrays.sort(nums); return nums[nums.length - k]; } 而且我随机生成了一个100万数据的随机数组，来测试这个简单粗暴的方法的效率，发现当数据量上去之后，排序这个操作变得繁琐，我自己测试的时候，上面三个方法，第三个大概比第一个（我自己写的方法）多花仅4倍的时间； 239. 滑动窗口最大值（类似剑指Offer面试题59） 参考答案：（88ms） public int[] maxSlidingWindow(int[] nums, int k) { if (nums == null || k &lt;= 0) return new int[0]; int[] res = new int[nums.length - k + 1]; ArrayDeque&lt;Integer> deque = new ArrayDeque&lt;Integer>(); int index = 0; for (int i = 0; i &lt; nums.length; i++) { while (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1) // Ensure deque's size doesn't exceed k deque.poll(); // Remove numbers smaller than a[i] from right(a[i-1]) to left, to make the first number in the deque the largest one in the window while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) deque.pollLast(); deque.offer(i);// Offer the current index to the deque's tail if (i >= k - 1)// Starts recording when i is big enough to make the window has k elements res[index++] = nums[deque.peek()]; } return res; } 参考答案2：（9ms） public int[] maxSlidingWindow(int[] nums, int k) { /* 思想：依次遍历数组，有效范围在长度k内寻找当前最大值，在用result数组来依次存储当前长度K内的最大值； 若在当前轮中出现新增的nums[end]大于curMax,直接替换即可； 如果当前轮curMax不是新增的nums[end]，在新的范围内重置curMax. */ if (nums.length == 0 || k &lt;= 0) return new int[0]; int curMax = Integer.MIN_VALUE; for (int i = 0; i &lt; k; i++) { if (nums[i] > curMax) curMax = nums[i]; } int[] ans = new int[nums.length - k + 1]; ans[0] = curMax; for (int start = 1; start + k - 1 &lt; nums.length; start++) { int end = start + k - 1; if (nums[end] > curMax) curMax = nums[end]; else if (nums[start - 1] == curMax) {//新增的不大于curMax，新范围内重置 curMax = Integer.MIN_VALUE; for (int i = start; i &lt;= end; i++) { if (nums[i] > curMax) curMax = nums[i]; } } ans[start] = curMax; } return ans; } 264. 丑数 II（剑指Offer面试题49） 参考答案：（7ms） public int nthUglyNumber(int n) { // 正确性判断 if (n &lt; 1 || n > 1690) { return -1; } int[] ugly = new int[n]; ugly[0] = 1; int index2 = 0, index3 = 0, index5 = 0; int factor2 = 2, factor3 = 3, factor5 = 5; for (int i = 1; i &lt; n; i++) { int min = Math.min(Math.min(factor2, factor3), factor5); ugly[i] = min; if (factor2 == min) factor2 = 2 * ugly[++index2]; if (factor3 == min) factor3 = 3 * ugly[++index3]; if (factor5 == min) factor5 = 5 * ugly[++index5]; } return ugly[n - 1]; } 如果采用逐个判断每个整数是不是丑数的解法，直观但不够高效，所以我们就需要换一种思路，我的第一反应就是这其中一定有什么规律，但是尝试着找了一下，没找到…看了看答案才幡然醒悟，前面提到的算法之所以效率低，很大程度上是因为不管一个数是不是丑数，我们都要对它进行计算，接下来我们试着找到一种只计算丑数的方法，而不在非丑数的整数上花费时间，根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此，我们可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的，也就是上面的算法了.. 295.数据流的中位数（剑指Offer面试题41） 参考答案：（219ms） public class MedianFinder { PriorityQueue&lt;Integer> maxHeap; PriorityQueue&lt;Integer> minHeap; /** * initialize your data structure here. */ public MedianFinder() { maxHeap = new PriorityQueue&lt;>(Collections.reverseOrder()); minHeap = new PriorityQueue&lt;>(); } public void addNum(int num) { maxHeap.add(num); minHeap.add(maxHeap.poll()); if (minHeap.size() - maxHeap.size() > 0) { maxHeap.add(minHeap.poll()); } } public double findMedian() { if (maxHeap.size() == minHeap.size()) { return (maxHeap.peek() + minHeap.peek()) / 2.0; } else { return maxHeap.peek(); } } } 思路：这道题的实现思路有很多，比如我们可以在插入的时候就将每个元素插入到正确的位置上，这样返回中位数的时候就会是一个O(1)的操作，下面列举一张表来说明不同实现的复杂度具体是多少：数据结构 | 插入的时间复杂度 | 得到中位数的时间复杂度:– | :– | :–没有排序的数组 | O(1) | O(n)排序的数组 | O(n) | O(1)排序的链表 | O(n) | O(1)二叉搜索树 | 平均O(logn)，最差O(n) | 平均O(logn)，最差O(n)AVL树 | O(logn) | O(logn)最大堆和最小堆 | O(logn) | O(logn) AVL树是一种很高效的数据结构，但是在大多数的语言中都没有现成的实现，所以考虑用最大堆和最小堆，对于一个已经排好序的数据容器，我们可以从中间分开分成两个部分，其中拿P1指向左半部分最大的元素，拿P2指向有半部分最小的元素，如果能够保证数据容器左边的数据都小于右边的数据，那么即使左、右两边内部的数据没有排序，我们仍然可以根据左边最大的数和右边最大的数得到中位数：如何快速从一个数据容器中找出最大数呢？我们可以使用最大堆来实现这个数据容器，因为堆顶的元素就是最大的元素；同样我们可以使用最小堆来快速找出一个数据容器中最小数。因此按照这个思路我们就可以使用一个最大堆实现左边的数据容器，使用一个最小堆实现右边的数据容器，但是需要注意的是这两个容器的大小差值不能超过1； 347. 前K个高频元素（类似剑指Offer面试题40） 参考答案：（131ms） public List&lt;Integer> topKFrequent(int[] nums, int k) { TreeMap&lt;Integer, Integer> map = new TreeMap&lt;>(); // 保存频率 for (int num : nums) { if (map.containsKey(num)) { map.put(num, map.get(num) + 1); } else { map.put(num, 1); } } PriorityQueue&lt;Integer> pq = new PriorityQueue&lt;>(Comparator.comparingInt(map::get)); for (int key : map.keySet()) { if (pq.size() &lt; k) { pq.add(key); } else if (map.get(key) > map.get(pq.peek())) { pq.remove(); pq.add(key); } } LinkedList&lt;Integer> res = new LinkedList&lt;>(); while (!pq.isEmpty()) { res.add(pq.remove()); } return res; } 692. 前K个高频单词 参考答案：（72ms） public List&lt;String> topKFrequent(String[] words, int k) { Map&lt;String, Integer> count = new HashMap(); for (String word: words) { count.put(word, count.getOrDefault(word, 0) + 1); } List&lt;String> candidates = new ArrayList(count.keySet()); Collections.sort(candidates, (w1, w2) -> count.get(w1).equals(count.get(w2)) ? w1.compareTo(w2) : count.get(w2) - count.get(w1)); return candidates.subList(0, k); } 这道题类似于上面的第347题，但是问题出在返回的顺序上，需要自己来定义一个比较器来排序..然后也学到一个写法，就是上面的第一个for循环里，getOrDefault()方法，get√.. 参考答案2：（91ms） public List&lt;String> topKFrequent(String[] words, int k) { Map&lt;String, Integer> count = new HashMap(); for (String word: words) { count.put(word, count.getOrDefault(word, 0) + 1); } PriorityQueue&lt;String> heap = new PriorityQueue&lt;String>( (w1, w2) -> count.get(w1).equals(count.get(w2)) ? w2.compareTo(w1) : count.get(w1) - count.get(w2) ); for (String word: count.keySet()) { heap.offer(word); if (heap.size() > k) heap.poll(); } List&lt;String> ans = new ArrayList(); while (!heap.isEmpty()) ans.add(heap.poll()); Collections.reverse(ans); return ans; } 这个解法就有点儿类似于上面的347题，其实是大同小异，就是自己不会灵活使用比较器而已，学习到了学习到了√… 简单总结今天算是很有收获的一天，因为这两种数据结构都是自己特别不熟悉的，特别是在刷了一些LeetCode相关题目之后，对这两种数据有了很不一样的认识，特别是堆的应用，这是一种特别适合用来找第k小/大的特殊的数据结构，并且在Java中居然有直接的实现，这可太棒了，而且今天的效率还算挺高的，满足； 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构与算法","slug":"基础知识/数据结构与算法","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"数据结构与算法(3)——树（二叉、二叉搜索树）","slug":"数据结构与算法-3-——树（二叉、二叉搜索树）","date":"2018-07-10T22:51:00.000Z","updated":"2020-12-09T04:59:27.059Z","comments":true,"path":"2018/07/11/shu-ju-jie-gou-yu-suan-fa-3-shu-er-cha-er-cha-sou-suo-shu/","link":"","permalink":"http://www.wmyskxz.com/2018/07/11/shu-ju-jie-gou-yu-suan-fa-3-shu-er-cha-er-cha-sou-suo-shu/","excerpt":"","text":"前言：题图无关，现在开始来学习学习树相关的知识 前序文章： 数据结构与算法(1)——数组与链表（https://www.jianshu.com/p/7b93b3570875） 数据结构与算法(2)——栈和队列(https://www.jianshu.com/p/5087c751cb42) 树什么是树树是一种类似于链表的数据结构，不过链表的结点是以线性方式简单地指向其后继结点，而树的一个结点可以指向许多个结点；数是一种典型的非线性结构；树结构是以表达具有层次特性的图结构的一种方法； 相关术语 根节点：根节点是一个没有双亲结点的结点，一棵树中最多有一个根节点（如上图的结点A就是根节点）； 边：边表示从双亲结点到孩子结点的链接（如上图中所有的链接）； 叶子结点：没有孩子结点的结点叫作叶子结点（如E、J、K、H和I）； 兄弟结点：拥有相同双亲结点的所有孩子结点叫作兄弟结点（B、C、D是A的兄弟结点，E、F是B的兄弟结点）； 祖先结点：如果存在一条从根节点到结点q的路径，其结点p出现在这条路径上，那么就可以吧结点p叫作结点q的祖先结点，结点q也叫做p的子孙结点（例如，A、C和G是K的祖先结点）； 结点的大小：结点的大小是指子孙的个数，包括其自身。（子树C的大小为3）； 树的层：位于相同深度的所有结点的集合叫作树的层（B、C和D具有相同的层，上图的结构有0/1/2/3四个层）； 结点的深度：是指从根节点到该节点的路径长度（G点的深度为2，A—C—G）； 结点的高度：是指从该节点到最深节点的路径长度，树的高度是指从根节点到书中最深结点的路径长度，只含有根节点的树的高度为0。（B的高度为2，B—F—J）； 树的高度：是树中所有结点高度的最大值，树的深度是树中所有结点深度的最大值，对于同一棵树，其深度和高度是相同的，但是对于各个结点，其深度和高度不一定相同； 二叉树如果一棵树中的每个结点有0，1或者2个孩子结点，那么这棵树就称为二叉树；空树也是一颗有效的二叉树，一颗二叉树可以看做是由根节点和两棵不相交的子树（分别称为左子树和右子树）组成，如下图所示。 二叉树的类型严格二叉树：二叉树中的每个节点要么有两个孩子结点，要么没有孩子结点 满二叉树：二叉树中的每个结点恰好有两个孩子结点且所有叶子结点都在同一层 完全二叉树：在定义完全二叉树之前，假定二叉树的高度为h；对于完全二叉树，如果将所有结点从根节点开始从左至右，从上至下，依次编号（假定根节点的编号为1），那么僵得到从1~n（n为结点总数）的完整序列，在遍历过程中对于空指针也赋予编号，如果所有伽椰子结点的深度为h或h-1，且在结点编号序列中没有漏掉任何数字，那么这样的二叉树叫作完全二叉树。 二叉树的应用 编译器中的表达式树； 用于数据压缩算法中的赫夫曼编码树； 支持在集合中查找、插入和删除，其平均时间复杂度为O(lognn)的二叉搜索树（BST）； 优先队列（PQ），它支持以对数时间（最坏情况下）对集合中的最小（或最大）数据元素进行搜索和删除； 二叉树的遍历 访问树中所有结点的过程叫作树的遍历，在遍历过程中，每个结点只能被处理一次，尽管其有可能被访问多次；根据结点处理顺序的不同，。可以定义不同的遍历方法，遍历分类可以根据当前节点被处理的顺序来划分： 前序遍历在前序遍历中，每个结点都是在它的子树遍历之前进行处理，这是最容易理解的便利方法，然而，尽管每个结点在其子树之前进行了处理，但在向下移动的过程仍然需要保留一些信息，以上图为例，首先访问结点1，随后遍历其左子树，最后遍历其右子树，因此当左子树遍历完后，必须要返回到其右子树来继续遍历；为了能够在左子树遍历完成后移动到右子树，必须保留根节点的信息，能够实现该信息存储的抽象数据类型显而易见是栈，由于它是LIFO的结构，所以它可以以逆序来汇过去该信息并返回到右子树； 前序遍历可以如下定义： 访问根节点； 按前序遍历方式遍历左子树； 按前序遍历方式遍历右子树； 利用前序遍历方法上图所示的树的输出序列为：1 2 4 5 3 6 7 void preOrder(BinaryTreeNode root) { if (null != root) { System.out.println(root.getData()); preOrder(root.getLeft()); preOrder(root.getRight()); } } 中序遍历在中序遍历中，根节点的访问在两棵子树的遍历中间完成，中序遍历如下定义： 按中序遍历方式遍历左子树； 访问根节点； 按中序遍历方式遍历右子树； 基于中序遍历，上图所示树的中序遍历输出顺序为：4 2 5 1 6 3 7 void inOrder(BinaryTreeNode root) { if (null != root) { inOrder(root.getLeft()); System.out.println(root.getData()); inOrder(root.getRight()); } } 后序遍历在后续遍历中，根节点的访问是在其两棵子树都遍历完成后进行的，后续遍历如下定义： 按后序遍历左子树； 按后序遍历右子树； 访问根节点； 对上图所示的二叉树，后续遍历产生的输出序列为：4 5 2 6 7 3 1 void postOrder(BinaryTreeNode root) { if (null != root) { postOrder(root.getLeft()); postOrder(root.getRight()); System.out.println(root.getData()); } } 层次遍历层次遍历的定义如下： 访问根节点； 在访问第l层时，将l+1层的节点按顺序保存在队列中； 进入下一层并访问该层的所有结点； 重复上述操作直至所有层都访问完； 对于上图所示的二叉树，层次遍历产生的输出序列为：1 2 3 4 5 6 7 void levelOrder(BinaryTreeNode root) { BinaryTreeNode temp; LoopQueue Q = new LoopQueue(); if (null == root) { return; } Q.enqueue(root); while (!Q.isEmpty()) { temp = Q.dequeue(); // 处理当前节点 System.out.println(temp.getData()); if (temp.getLeft()) { Q.enqueue(temp.getLeft()); } if (temp.getRight()) { Q.enqueue(temp.getRight()); } } // 删除队列中的所有数据 Q.deletequeue(); } 二叉搜索树在二叉搜索树中，所有左子树结点的元素小于根节点的数据，所有右子树结点的元素大于根节点数据，注意，树中的每个结点都应满足这个性质； 实现自己的二叉搜索树其中包含了常用的一些方法，包括几种遍历方法还有查询、删除等，仅供参考： public class BST&lt;E extends Comparable&lt;E>> { private class Node{ public E e; public Node left, right; public Node(E e){ this.e = e; left = null; right = null; } } private Node root; private int size; public BST(){ root = null; size = 0; } public int size(){ return size; } public boolean isEmpty(){ return size == 0; } // 向二分搜索树中添加新的元素e public void add(E e){ root = add(root, e); } // 向以node为根的二分搜索树中插入元素e，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, E e){ if(node == null){ size ++; return new Node(e); } if(e.compareTo(node.e) &lt; 0) node.left = add(node.left, e); else if(e.compareTo(node.e) > 0) node.right = add(node.right, e); return node; } // 看二分搜索树中是否包含元素e public boolean contains(E e){ return contains(root, e); } // 看以node为根的二分搜索树中是否包含元素e, 递归算法 private boolean contains(Node node, E e){ if(node == null) return false; if(e.compareTo(node.e) == 0) return true; else if(e.compareTo(node.e) &lt; 0) return contains(node.left, e); else // e.compareTo(node.e) > 0 return contains(node.right, e); } // 二分搜索树的前序遍历 public void preOrder(){ preOrder(root); } // 前序遍历以node为根的二分搜索树, 递归算法 private void preOrder(Node node){ if(node == null) return; System.out.println(node.e); preOrder(node.left); preOrder(node.right); } // 二分搜索树的非递归前序遍历 public void preOrderNR(){ Stack&lt;Node> stack = new Stack&lt;>(); stack.push(root); while(!stack.isEmpty()){ Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); } } // 二分搜索树的中序遍历 public void inOrder(){ inOrder(root); } // 中序遍历以node为根的二分搜索树, 递归算法 private void inOrder(Node node){ if(node == null) return; inOrder(node.left); System.out.println(node.e); inOrder(node.right); } // 二分搜索树的后序遍历 public void postOrder(){ postOrder(root); } // 后序遍历以node为根的二分搜索树, 递归算法 private void postOrder(Node node){ if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.println(node.e); } // 二分搜索树的层序遍历 public void levelOrder(){ Queue&lt;Node> q = new LinkedList&lt;>(); q.add(root); while(!q.isEmpty()){ Node cur = q.remove(); System.out.println(cur.e); if(cur.left != null) q.add(cur.left); if(cur.right != null) q.add(cur.right); } } // 寻找二分搜索树的最小元素 public E minimum(){ if(size == 0) throw new IllegalArgumentException(\"BST is empty!\"); return minimum(root).e; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 寻找二分搜索树的最大元素 public E maximum(){ if(size == 0) throw new IllegalArgumentException(\"BST is empty\"); return maximum(root).e; } // 返回以node为根的二分搜索树的最大值所在的节点 private Node maximum(Node node){ if(node.right == null) return node; return maximum(node.right); } // 从二分搜索树中删除最小值所在节点, 返回最小值 public E removeMin(){ E ret = minimum(); root = removeMin(root); return ret; } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除最大值所在节点 public E removeMax(){ E ret = maximum(); root = removeMax(root); return ret; } // 删除掉以node为根的二分搜索树中的最大节点 // 返回删除节点后新的二分搜索树的根 private Node removeMax(Node node){ if(node.right == null){ Node leftNode = node.left; node.left = null; size --; return leftNode; } node.right = removeMax(node.right); return node; } // 从二分搜索树中删除元素为e的节点 public void remove(E e){ root = remove(root, e); } // 删除掉以node为根的二分搜索树中值为e的节点, 递归算法 // 返回删除节点后新的二分搜索树的根 private Node remove(Node node, E e){ if( node == null ) return null; if( e.compareTo(node.e) &lt; 0 ){ node.left = remove(node.left , e); return node; } else if(e.compareTo(node.e) > 0 ){ node.right = remove(node.right, e); return node; } else{ // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } // 待删除节点右子树为空的情况 if(node.right == null){ Node leftNode = node.left; node.left = null; size --; return leftNode; } // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; } } @Override public String toString(){ StringBuilder res = new StringBuilder(); generateBSTString(root, 0, res); return res.toString(); } // 生成以node为根节点，深度为depth的描述二叉树的字符串 private void generateBSTString(Node node, int depth, StringBuilder res){ if(node == null){ res.append(generateDepthString(depth) + \"null\\n\"); return; } res.append(generateDepthString(depth) + node.e +\"\\n\"); generateBSTString(node.left, depth + 1, res); generateBSTString(node.right, depth + 1, res); } private String generateDepthString(int depth){ StringBuilder res = new StringBuilder(); for(int i = 0 ; i &lt; depth ; i ++) res.append(\"--\"); return res.toString(); } } LeetCode相关题目整理94.二叉树的中序遍历 我的答案：（1ms） public List&lt;Integer> inorderTraversal(TreeNode root) { List result = new ArrayList(); if (null != root) { result.addAll(inorderTraversal(root.left)); result.add(root.val); result.addAll(inorderTraversal(root.right)); } return result; } 参考答案：（0ms） public List&lt;Integer> inorderTraversal(TreeNode root) { List&lt;Integer> list=new ArrayList&lt;>(); traversal(root, list); return list; } public void traversal(TreeNode root,List&lt;Integer> list) { if(root!=null){ traversal(root.left, list); list.add(root.val); traversal(root.right, list); } } 98. 验证二叉搜索树 我的答案：（53ms） private static int INT_MIN = Integer.MIN_VALUE; private static int INT_MAX = Integer.MAX_VALUE; public boolean isValidBST(TreeNode root) { // 如果节点为空则满足二叉搜索树条件 if (null == root) { return true; } // 如果左孩子结点大于了根节点则返回false if (null != root.left &amp;&amp; findMax(root.left) > root.val) { return false; } // 如果右孩子结点小于了根节点则返回false if (null != root.right &amp;&amp; findMin(root.right) &lt; root.val) { return false; } // 递归判断左子树和右子树，若其中有一颗不是BST树，则返回false if (!isValidBST(root.left) || !isValidBST(root.right)) { return false; } // 通过所有判断则是一颗BST树 return true; } /** * 找到一颗非空树中的最大值 * * @param root * @return */ private int findMax(TreeNode root) { int maxVal = INT_MIN; int leftMaxVal = INT_MIN; int rightMaxVal = INT_MIN; if (null != root) { // 最大值默认等于当前节点值 maxVal = root.val; leftMaxVal = findMax(root.left); rightMaxVal = findMax(root.right); // maxVal等于当前maxVal与leftMaxVal中较大的一个 maxVal = maxVal > leftMaxVal ? maxVal : leftMaxVal; // maxVal等于当前maxVal与rightMaxVal中较大的一个 maxVal = maxVal > rightMaxVal ? maxVal : rightMaxVal; } return maxVal; } /** * 找到一颗非空树的最小值 * * @param root * @return */ private int findMin(TreeNode root) { int minVal = INT_MAX; int leftMinVal = INT_MAX; int rightMinVal = INT_MAX; if (null != root) { // 最小值默认为当前节点值 minVal = root.val; leftMinVal = findMin(root.left); rightMinVal = findMin(root.right); // minVal等于当前minVal与leftMinVal中较小的一个 minVal = minVal &lt; leftMinVal ? minVal : leftMinVal; // minVal等于当前minVal与rightMinVal中较小的一个 minVal = minVal &lt; rightMinVal ? minVal : rightMinVal; } return minVal; } 自己写的时候提交错了很多次..没有掌握到二分搜索树的精髓.. 参考答案：（2ms） public boolean isValidBST(TreeNode root) { if (root == null) return true; return valid(root, Long.MIN_VALUE, Long.MAX_VALUE); } public boolean valid(TreeNode root, long low, long high) { if (root == null) return true; if (root.val &lt;= low || root.val >= high) return false; return valid(root.left, low, root.val) &amp;&amp; valid(root.right, root.val, high); } 这答案写得我服了..真服.. 101. 对称二叉树（剑指Offer面试题28） 参考答案：（12ms） public boolean isSymmetric(TreeNode root) { return isSymmetric(root, root); } public boolean isSymmetric(TreeNode root1, TreeNode root2) { if (null == root1 &amp;&amp; null == root2) { return true; } if (null == root1 || null == root2) { return false; } if (root1.val != root2.val) { return false; } return isSymmetric(root1.left, root2.right) &amp;&amp; isSymmetric(root1.right, root2.left); } 自己做的思路是使用中序遍历来判断（转成数组之后是对称的），但是出了很多问题，就是需要考虑null值，中序遍历中并不能很好地把一棵树保存为一个完整二叉树的样子..所以看了下参考答案..写得服.. 104. 二叉树的最大深度（剑指Offer面试题55） 我的答案：（3ms） public int maxDepth(TreeNode root) { int leftHeight, rightHeight; if (null == root) { return 0; } else { // 计算每个子树的高度 leftHeight = maxDepth(root.left); rightHeight = maxDepth(root.right); return leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1; } } 参考答案：（0ms） public int maxDepth(TreeNode root) { if(root==null) return 0; return Math.max(maxDepth(root.left)+1,maxDepth(root.right)+1); } 105. 从前序与中序遍历序列构造二叉树（剑指Offer面试题7） 参考答案：（2ms） public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder == null || preorder.length == 0) { return null; } return buildTree(preorder, inorder, 0, 0, inorder.length - 1); } private TreeNode buildTree(int[] preorder, int[] inorder, int ps, int is, int ie) { int val = preorder[ps]; TreeNode node = new TreeNode(val); int iRoot = ie; while (iRoot > is) { if (val == inorder[iRoot]) { break; } iRoot--; } if (iRoot > is) { node.left = buildTree(preorder, inorder, ps + 1, is, iRoot - 1); } if (iRoot &lt; ie) { node.right = buildTree(preorder, inorder, ps + 1 + (iRoot - is), iRoot + 1, ie); } return node; } 思路是这样的：在二叉树的前序遍历序列中，第一个数字总是树的根节点的值，但在中序遍历序列中，根节点的值保存在序列的中间，左子树的节点的值位于根节点的值的左边，而右子树则相反，然后既然找到了左右子树我们又可以使用同样的方法在前序和中序中分别构建左右子树，这样我们就能够使用递归的方法完成；（上面算法中的ps、is、ie分别表示前序的开始位置，中序的开始位置和中序的结束位置；） 113. 路径总和 II（剑指Offer面试题34） 参考答案：（3ms） public List&lt;List&lt;Integer>> pathSum(TreeNode root, int sum) { List&lt;Integer> nodeList = new ArrayList&lt;Integer>(); List&lt;List&lt;Integer>> sumList = new ArrayList&lt;List&lt;Integer>>(); if (root == null) { return sumList; } pathSum2(root, sum, sumList, nodeList); return sumList; } public void pathSum2(TreeNode root, int target, List&lt;List&lt;Integer>> sumList, List&lt;Integer> nodeList) { if (root.left == null &amp;&amp; root.right == null) { nodeList.add(root.val); int sum = 0; for (Integer integer : nodeList) { sum += integer; } if (sum == target) { sumList.add(new ArrayList&lt;Integer>(nodeList)); } return; } nodeList.add(root.val); if (root.left != null) { pathSum2(root.left, target, sumList, nodeList); nodeList.remove(nodeList.size() - 1); } if (root.right != null) { pathSum2(root.right, target, sumList, nodeList); nodeList.remove(nodeList.size() - 1); } } 230. 二叉搜索树中第K小的元素（类似剑指Offer面试题54） 我的答案：（23ms） public int kthSmallest(TreeNode root, int k) { // 正确性判断 if (null == root || k &lt; 1) { return -1; } List&lt;Integer> result = preOrder(root); // 从小到大排序 Collections.sort(result); return result.get(k - 1); } /** * 遍历整棵树并返回一个List * * @param root * @return */ private List&lt;Integer> preOrder(TreeNode root) { List result = new ArrayList(); if (null != root) { result.add(root.val); result.addAll(preOrder(root.left)); result.addAll(preOrder(root.right)); } return result; } 贼蠢，完全没有用到二叉搜索树的特性 参考答案：（1ms） public int kthSmallest(TreeNode root, int k) { int count = countNodes(root.left); if (k &lt;= count) { return kthSmallest(root.left, k); } else if (k > count + 1) { return kthSmallest(root.right, k - 1 - count); } return root.val; } public int countNodes(TreeNode n) { if (n == null) return 0; return 1 + countNodes(n.left) + countNodes(n.right); } 449. 序列化二叉搜索树（类似剑指Offer面试题37） 参考答案：（12ms） // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuffer sb = new StringBuffer(); preOrder(root,sb); return sb.toString(); } private static void preOrder(TreeNode root, StringBuffer sb){ if(root==null) return; sb.append(root.val).append('#'); preOrder(root.left,sb); preOrder(root.right,sb); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if(data==null) return null; int val =0; TreeNode root = null; for(int i=0;i&lt;data.length();i++){ if(data.charAt(i)!='#'){ val = val*10+(data.charAt(i)-'0'); }else{ root = insert(root,val); val=0; } } return root; } private static TreeNode insert(TreeNode root,int val){ if(root==null) return new TreeNode(val); if(root.val&lt;val) root.right = insert(root.right,val); else root.left = insert(root.left,val); return root; } 572. 另一个树的子树（类似剑指Offer面试题26） 参考答案：（15ms） public boolean isSubtree(TreeNode s, TreeNode t) { // Write your code here if (s == null) { return t == null; } if (s.val == t.val &amp;&amp; isSametree(s, t)) { return true; } return isSubtree(s.left, t) | isSubtree(s.right, t); } private boolean isSametree(TreeNode s, TreeNode t) { if (s == null) { return t == null; } if (t == null) { return false; } if (s.val != t.val) { return false; } return isSametree(s.left, t.left) &amp; isSametree(s.right, t.right); } 我的第一个反应还是去把两棵树的前序遍历的数组弄出来然后判断是否为子集，但是树这样的天然递归结构这样写很自然… 简单总结还是只是简单复习了一下树的相关知识吧，通过刷LeetCode题目还有参照着剑指Offer对二叉树、二叉搜索树仅仅这两种结构有了一个较深的认识，因为后续还会继续用到，所以这里简单复习一下也无所谓，不过看着题目倒是感觉这样的结构很容易考面试题啊，因为这些结构既重要考点又多… 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构与算法","slug":"基础知识/数据结构与算法","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"数据结构与算法(2)——栈和队列","slug":"数据结构与算法-2-——栈和队列","date":"2018-07-05T22:46:00.000Z","updated":"2020-12-09T04:59:23.954Z","comments":true,"path":"2018/07/06/shu-ju-jie-gou-yu-suan-fa-2-zhan-he-dui-lie/","link":"","permalink":"http://www.wmyskxz.com/2018/07/06/shu-ju-jie-gou-yu-suan-fa-2-zhan-he-dui-lie/","excerpt":"","text":"前言：题图无关，只是好看，接下来就来复习一下栈和队列的相关知识 前序文章： 数据结构与算法(1)——数组与链表（https://www.jianshu.com/p/7b93b3570875） 栈什么是栈栈是一种用于存储数据的简单数据结构（与链表类似）。数据入栈的次序是栈的关键。可以把一桶桶装的薯片看作是一个栈的例子，当薯片做好之后，它们会依次被添加到桶里，每一片都会是当前的最上面一片，而每次我们取的时候也是取的最上面的那一片，规定你不能破坏桶也不能把底部捅穿，所以第一个放入桶的薯片只能最后一个从桶里取出； 定义：栈（Stack）是一个有序线性表，只能在表的一端（称为栈顶，top）执行插入和删除操作。最后插入的元素将第一个被删除，所以栈也称为后进先出（Last In First Out，LIFO）或先进后出（First In Last Out）线性表； 两个改变栈的操作都有专用名称。一个称为入栈（push），表示在栈中插入一个元素；另一个称为出栈（pop），表示从栈中删除一个元素。试图对一个空栈执行栈操作称为下溢（underflow）；试图对一个满栈执行栈操作称为溢出（overflow）。通常，溢出和下溢均认为是异常； 栈的应用 无处不在的Undo操作（撤销）； 程序调用的系统栈； 括号/符号匹配； 等等等等…. 栈抽象数据类型下面给出栈抽象数据类型中的操作，为了简单起见，假设数据类型为整型； 栈的主要操作 void push(int data)：将data（数据）插入栈； int pop()：删除并返回最后一个插入栈的元素； 栈的辅助操作 int top()：返回最后一个插入栈的元素，但不删除； int size()：返回存储在栈中元素的个数； int isEmpty()：判断栈中是否有元素； int isStackFull()：判断栈中是否存满元素； 动态数组简单实现栈结构我们结合之前创建的Array类，我们能够很好的创建属于我们自己的动态数组实现的栈结构，对于用户来说，我们只需要完成我们的相关操作，并且知道我能够不断地往里添加元素而不出错就行了，所以我们先来定义一个通用的栈接口： public interface Stack&lt;E> { int getSize(); boolean isEmepty(); void push(E e); E pop(); E top(); } 然后我们往之前的动态数组中添加两个用户友好的方法： public E getLast() { return get(size - 1); } public E getFirst() { return get(0); } 然后实现自己的动态数组为底层的栈结构就轻松多了： public class ArrayStack&lt;E> implements Stack&lt;E> { Array&lt;E> array; public ArrayStack(int capacity) { array = new Array&lt;>(capacity); } public ArrayStack() { array = new Array&lt;>(); } @Override public int getSize() { return array.getSize(); } @Override public boolean isEmepty() { return array.isEmpty(); } public int getCapacity() { return array.getCapacity(); } @Override public void push(E e) { array.addLast(e); } @Override public E pop() { return array.removeLast(); } @Override public E top() { return array.getLast(); } @Override public String toString() { StringBuilder res = new StringBuilder(); res.append(\"Stack:\"); res.append(\"[\"); for (int i = 0; i &lt; array.getSize(); i++) { res.append(array.get(i)); if (i != array.getSize() - 1) { res.append(\",\"); } } res.append(\"]\"); return res.toString(); } } 简单复杂度分析从代码中可以看出，几乎所有的时间复杂度都为O(1)级别，比较特别的是push()和pop()操作可能涉及到底层数组的扩容或缩容的操作，所以是均摊下来的复杂度； 队列什么是队列队列是一种用于存储数据的数据结构（与链表和栈类似），数据到达的次序是队列的关键；在日常生活中队列是指从序列的开始按照顺序等待服务的一队人或物； 定义：队列是一种只能在一端插入（队尾），在另一端删除（队首）的有序线性表。队列中第一个插入的元素也是第一个被删除的元素，所以队列是一种先进先出（FIFO,First In First Out）或后进后出（LiLO,Last In Last Out）线性表； 与栈类似，两个改变队列的操作各有专用名称；在队列中插入一个元素，称为入队（EnQueue），从队列中删除一个元素，称为出队（DeQueue）；试图对一个空队列执行出队操作称为下溢（underflow），试图对一个满队列执行入队操作称为溢出（overflow）；通常认为溢出和下溢是异常。 队列的一些应用举例 操作系统根据（具有相同优先级的）任务到达的顺序调度任务（例如打印队列）； 模拟现实世界中的队列，如售票柜台前的队伍，或者任何需要先来先服务的场景； 多道程序设计； 异步数据传输（文件输入输出、管道、套接字）； 等等等等… 动态数组简单实现队列结构我们仍然定义一个Queue接口来说明我们队列中常用的一些方法： public interface Queue&lt;E> { int getSize(); boolean isEmpty(); void enqueue(E e); E dequeue(); E getFront(); } 借由我们之前自己实现的动态数组，那么我们的队列就很简单了： public class ArrayQueue&lt;E> implements Queue&lt;E> { private Array&lt;E> array; public ArrayQueue(int capacity){ array = new Array&lt;>(capacity); } public ArrayQueue(){ array = new Array&lt;>(); } @Override public int getSize(){ return array.getSize(); } @Override public boolean isEmpty(){ return array.isEmpty(); } public int getCapacity(){ return array.getCapacity(); } @Override public void enqueue(E e){ array.addLast(e); } @Override public E dequeue(){ return array.removeFirst(); } @Override public E getFront(){ return array.getFirst(); } @Override public String toString(){ StringBuilder res = new StringBuilder(); res.append(\"Queue: \"); res.append(\"front [\"); for(int i = 0 ; i &lt; array.getSize() ; i ++){ res.append(array.get(i)); if(i != array.getSize() - 1) res.append(\", \"); } res.append(\"] tail\"); return res.toString(); } } 简单的复杂度分析 void enquque(E)：O(1)（均摊） E dequeue()：O(n) E front()：O(1) int getSize()：O(1) boolean isEmpty()：O(1) 实现自己的循环队列循环队列的实现其实就是维护了一个front和一个tail分别指向头和尾，然后需要特别注意的呢是判定队满和队空的条件： 队空：front == tail，这没啥好说的； 队满：tail + 1 == front，这里其实是有意浪费了一个空间，不然就判定不了到底是队空还是队满了，因为条件都一样… public class LoopQueue&lt;E> implements Queue&lt;E> { private E[] data; private int front, tail; private int size; public LoopQueue(int capacity){ data = (E[])new Object[capacity + 1]; front = 0; tail = 0; size = 0; } public LoopQueue(){ this(10); } public int getCapacity(){ return data.length - 1; } @Override public boolean isEmpty(){ return front == tail; } @Override public int getSize(){ return size; } @Override public void enqueue(E e){ if((tail + 1) % data.length == front) resize(getCapacity() * 2); data[tail] = e; tail = (tail + 1) % data.length; size ++; } @Override public E dequeue(){ if(isEmpty()) throw new IllegalArgumentException(\"Cannot dequeue from an empty queue.\"); E ret = data[front]; data[front] = null; front = (front + 1) % data.length; size --; if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) resize(getCapacity() / 2); return ret; } @Override public E getFront(){ if(isEmpty()) throw new IllegalArgumentException(\"Queue is empty.\"); return data[front]; } private void resize(int newCapacity){ E[] newData = (E[])new Object[newCapacity + 1]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[(i + front) % data.length]; data = newData; front = 0; tail = size; } @Override public String toString(){ StringBuilder res = new StringBuilder(); res.append(String.format(\"Queue: size = %d , capacity = %d\\n\", size, getCapacity())); res.append(\"front [\"); for(int i = front ; i != tail ; i = (i + 1) % data.length){ res.append(data[i]); if((i + 1) % data.length != tail) res.append(\", \"); } res.append(\"] tail\"); return res.toString(); } } 简单复杂度分析 void enquque(E)：O(1)（均摊） E dequeue()：O(1)（均摊） E front()：O(1) int getSize()：O(1) boolean isEmpty()：O(1) 简单数组队列和循环队列的简单比较我们来简单对比一下两个队列的性能吧，这里直接上代码： // 测试使用q运行opCount个enqueueu和dequeue操作所需要的时间，单位：秒 private static double testQueue(Queue&lt;Integer> q, int opCount){ long startTime = System.nanoTime(); Random random = new Random(); for(int i = 0 ; i &lt; opCount ; i ++) q.enqueue(random.nextInt(Integer.MAX_VALUE)); for(int i = 0 ; i &lt; opCount ; i ++) q.dequeue(); long endTime = System.nanoTime(); return (endTime - startTime) / 1000000000.0; } public static void main(String[] args) { int opCount = 100000; ArrayQueue&lt;Integer> arrayQueue = new ArrayQueue&lt;>(); double time1 = testQueue(arrayQueue, opCount); System.out.println(\"ArrayQueue, time: \" + time1 + \" s\"); LoopQueue&lt;Integer> loopQueue = new LoopQueue&lt;>(); double time2 = testQueue(loopQueue, opCount); System.out.println(\"LoopQueue, time: \" + time2 + \" s\"); } 我这里的测试结果是这样的，大家也就可见一斑啦： 其实ArrayQueue慢主要是因为出栈时每次都需要把整个结构往前挪一下 LeetCode 相关题目整理20.有效的括号 我的答案：（10ms） public boolean isValid(String s) { // 正确性判断 if (null == s || s.length() == 1) { return false; } Stack&lt;Character> stack = new Stack&lt;>(); // 遍历输入的字符 for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // 如果为左括号则push进栈 if (c == '(' || c == '[' || c == '{') { stack.push(c); } else { if (stack.isEmpty()) { return false; } char topChar = stack.pop(); if (c == ')' &amp;&amp; topChar != '(') { return false; } if (c == ']' &amp;&amp; topChar != '[') { return false; } if (c == '}' &amp;&amp; topChar != '{') { return false; } } } // 最后栈为空才能返回true return stack.isEmpty(); } 参考答案：（8ms） public boolean isValid(String s) { // 正确性判断 if (0 == s.length()) { return true; } if (s.length() % 2 == 1) { return false; } Stack&lt;Character> stack = new Stack(); char[] cs = s.toCharArray(); for (int i = 0; i &lt; cs.length; i++) { if (cs[i] == '(' || cs[i] == '[' || cs[i] == '{') { stack.push(cs[i]); } else { if (stack.isEmpty()) { return false; } char c = stack.pop(); if ((cs[i] == ')' &amp;&amp; c == '(') || (cs[i] == '}' &amp;&amp; c == '{') || (cs[i] == ']' &amp;&amp; c == '[')) { } else { return false; } } } return stack.isEmpty(); } 155. 最小栈（剑指Offer面试题30） 参考答案（107ms） class MinStack { // 数据栈，用于存放插入的数据 private Stack&lt;Integer> dataStack; // 最小数位置栈，存放数据栈中最小的数的位置 private Stack&lt;Integer> minStack; /** * initialize your data structure here. */ public MinStack() { this.dataStack = new Stack&lt;>(); this.minStack = new Stack&lt;>(); } /** * 元素入栈 * * @param x 入栈的元素 */ public void push(int x) { dataStack.push(x); // 如果最小栈是空的，只要将元素入栈 if (minStack.isEmpty()) { minStack.push(x); } // 如果最小栈中有数据 else { minStack.push(Math.min(x, minStack.peek())); } } /** * 出栈方法 */ public void pop() { // 如果栈已经为空，则返回（LeetCode不能抛异常...） if (dataStack.isEmpty()) { return; } // 如果有数据，最小数位置栈和数据栈必定是有相同的元素个数， // 两个栈同时出栈 minStack.pop(); dataStack.pop(); } /** * 返回栈顶元素 * * @return 栈顶元素 */ public int top() { return dataStack.peek(); } /** * 获取栈中的最小元素 * * @return 栈中的最小元素 */ public int getMin() { // 如果最小数公位置栈已经为空（数据栈中已经没有数据了），则抛出异常 if (minStack.isEmpty()) { return 0; } // 获取数据占中的最小元素，并且返回结果 return minStack.peek(); } } 改进答案： 上面求解方法的主要问题在于，每次push操作时，minStack也执行了一次push操作（新元素或当前的最小元素），也就是说，重复执行了最小值的入栈操作，所以现在我们来修改算法降低空间复杂度。仍然需要设置一个minStack，但是只有当从dataStack中出栈的元素等于minStack栈顶元素时，才对minStack执行出栈的操作；也只有当dataStack入栈的元素小于或等于当前最小值时，才对minStack执行入栈操作，下面就简单写一下了主要看一下出栈和入栈实现的逻辑就好了： class MinStack { private Stack&lt;Integer> dataStack; private Stack&lt;Integer> minStack; public MinStack() { this.dataStack = new Stack&lt;>(); this.minStack = new Stack&lt;>(); } public void push(int x) { dataStack.push(x); if (minStack.isEmpty() || minStack.peek() >= (Integer) x) { minStack.push(x); } } public void pop() { if (dataStack.isEmpty()) { return; } Integer minTop = minStack.peek(); Integer dataTop = dataStack.peek(); if (minTop.intValue() == dataTop.intValue()) { minStack.pop(); } dataStack.pop(); } public int top() { return dataStack.peek(); } public int getMin() { return minStack.peek(); } } 225. 用队列实现栈 我的答案：（118ms） class MyStack { private Queue&lt;Integer> queue1; private Queue&lt;Integer> queue2; /** * Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList&lt;>(); queue2 = new LinkedList&lt;>(); } /** * Push element x onto stack. */ public void push(int x) { if (queue1.isEmpty()) { queue2.offer(x); } else { queue1.offer(x); } } /** * Removes the element on top of the stack and returns that element. */ public int pop() { int size; if (!queue1.isEmpty()) { size = queue1.size(); for (int i = 0; i &lt; size - 1; i++) { queue2.offer(queue1.poll()); } return queue1.poll(); } else { size = queue2.size(); for (int i = 0; i &lt; size - 1; i++) { queue1.offer(queue2.poll()); } return queue2.poll(); } } /** * Get the top element. */ public int top() { int size; if (!queue1.isEmpty()) { size = queue1.size(); for (int i = 0; i &lt; size - 1; i++) { queue2.offer(queue1.poll()); } int result = queue1.peek(); queue2.offer(queue1.poll()); return result; } else { size = queue2.size(); for (int i = 0; i &lt; size - 1; i++) { queue1.offer(queue2.poll()); } int result = queue2.peek(); queue1.offer(queue2.poll()); return result; } } /** * Returns whether the stack is empty. */ public boolean empty() { return queue1.isEmpty() &amp;&amp; queue2.isEmpty(); } } 参考答案：（121ms） class MyStack { Queue&lt;Integer> q; /** * Initialize your data structure here. */ public MyStack() { this.q = new LinkedList&lt;Integer>(); } /** * Push element x onto stack. */ public void push(int x) { q.add(x); } /** * Removes the element on top of the stack and returns that element. */ public int pop() { int size = q.size(); for (int i = 0; i &lt; size - 1; i++) { q.add(q.remove()); } return q.remove(); } /** * Get the top element. */ public int top() { int size = q.size(); for (int i = 0; i &lt; size - 1; i++) { q.add(q.remove()); } int ret = q.remove(); q.add(ret); return ret; } /** * Returns whether the stack is empty. */ public boolean empty() { return q.isEmpty(); } } 确实写得简洁啊，这样一来我就使用一个队列和两个队列都掌握啦，开心~ 232.用栈实现队列（剑指Offer面试题9） 参考答案：（72ms） class MyQueue { Stack&lt;Integer> pushstack; Stack&lt;Integer> popstack; /** * Initialize your data structure here. */ public MyQueue() { this.pushstack = new Stack(); this.popstack = new Stack(); } /** * Push element x to the back of queue. */ public void push(int x) { pushstack.push(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { if (popstack.isEmpty()) { while (!pushstack.isEmpty()) { popstack.push(pushstack.pop()); } } return popstack.pop(); } /** * Get the front element. */ public int peek() { if (popstack.isEmpty()) { while (!pushstack.isEmpty()) { popstack.push(pushstack.pop()); } } return popstack.peek(); } /** * Returns whether the queue is empty. */ public boolean empty() { return pushstack.isEmpty() &amp;&amp; popstack.isEmpty(); } } 其他题目整理剑指Offer面试题31：栈的压入、弹出序列题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。 参考答案：（原文链接：https://blog.csdn.net/derrantcm/article/details/46691083） public class Test22 { /** * 输入两个整数序列，第一个序列表示栈的压入顺序，请判断二个序列是否为该栈的弹出顺序。 * 假设压入栈的所有数字均不相等。例如序列1 、2、3 、4、5 是某栈压栈序列， * 序列4、5、3、2、1是该压栈序列对应的一个弹出序列， * 但4、3、5、1、2就不可能是该压棋序列的弹出序列。 * 【与书本的的方法不同】 * * @param push 入栈序列 * @param pop 出栈序列 * @return true：出栈序列是入栈序列的一个弹出顺序 */ public static boolean isPopOrder(int[] push, int[] pop) { // 输入校验，参数不能为空，并且两个数组中必须有数字，并且两个数组中的数字个数相同 // 否则返回false if (push == null || pop == null || pop.length == 0 || push.length == 0 || push.length != pop.length) { return false; } // 经过上面的参数校验，两个数组中一定有数据，且数据数目相等 // 用于存放入栈时的数据 Stack&lt;Integer> stack = new Stack&lt;>(); // 用于记录入栈数组元素的处理位置 int pushIndex = 0; // 用于记录出栈数组元素的处理位置 int popIndex = 0; // 如果还有出栈元素要处理 while (popIndex &lt; pop.length) { // 入栈元素还未全部入栈的条件下，如果栈为空，或者栈顶的元素不与当前处理的相等，则一直进行栈操作， // 直到入栈元素全部入栈或者找到了一个与当出栈元素相等的元素 while (pushIndex &lt; push.length &amp;&amp; (stack.isEmpty() || stack.peek() != pop[popIndex])) { // 入栈数组中的元素入栈 stack.push(push[pushIndex]); // 指向下一个要处理的入栈元素 pushIndex++; } // 如果在上一步的入栈过程中找到了与出栈的元素相等的元素 if (stack.peek() == pop[popIndex]) { // 将元素出栈 stack.pop(); // 处理下一个出栈元素 popIndex++; } // 如果没有找到与出栈元素相等的元素，说明这个出栈顺序是不合法的 // 就返回false else { return false; } } // 下面的语句总是成立的 // return stack.isEmpty(); // 为什么可以直接返回true：对上面的外层while进行分析可知道，对每一个入栈的元素， // 在stack栈中，通过一些入栈操作，总可以在栈顶上找到与入栈元素值相同的元素， // 这就说明了这个出栈的顺序是入栈顺序的一个弹出队列，这也可以解释为什么stack.isEmpty() // 总是返回true，所有的入栈元素都可以进栈，并且可以被匹配到，之后就弹出，最后栈中就无元素。 return true; } /** * 输入两个整数序列，第一个序列表示栈的压入顺序，请判断二个序列是否为该栈的弹出顺序。 * 【按书本上的思路进行求解，两者相差不大】 * * @param push 入栈序列 * @param pop 出栈序列 * @return true：出栈序列是入栈序列的一个弹出顺序 */ public static boolean isPopOrder2(int[] push, int[] pop) { // 用于记录判断出栈顺序是不是入栈顺的一个出栈序列，默认false boolean isPossible = false; // 当入栈和出栈数组者都不为空，并且都有数据，并且数据个数都相等 if (push != null &amp;&amp; pop != null &amp;&amp; push.length > 0 &amp;&amp; push.length == pop.length) { // 用于存放入栈时的数据 Stack&lt;Integer> stack = new Stack&lt;>(); // 记录下一个要处理的入栈元素的位置 int nextPush = 0; // 记录下一个要处理的出栈元素的位置 int nextPop = 0; // 如果出栈元素没有处理完就继续进行处理 while (nextPop &lt; pop.length) { // 如果栈为空或者栈顶的元素与当前处理的出栈元素不相同，一直进行操作 while (stack.isEmpty() || stack.peek() != pop[nextPop]) { // 如果入栈的元素已经全部入栈了，就退出内层循环 if (nextPush >= push.length) { break; } // 执行到此处说明还有入栈元素可以入栈 // 即将元素入栈 stack.push(push[nextPush]); // 指向下一个要处理的入栈元素的位置 nextPush++; } // 执行到此处有两种情况： // 第一种：在栈顶上找到了一个与入栈元素相等的元素 // 第二种：在栈顶上没有找到一个与入栈元素相等的元素，而且输入栈的元素已经全部入栈了 // 对于第二种情况就说弹出栈的顺序是不符合要求的，退出外层循环 if (stack.peek() != pop[nextPop]) { break; } // 对应到第一种情况：需要要栈的栈顶元素弹出 stack.pop(); // 指向下一个要处理的出栈元素的位置 nextPop++; } // 执行到此处有两种情况 // 第一种：外层while循环的在第一种情况下退出， // 第二种：所有的出栈元素都被正确匹配 // 对于出现的第一种情况其stack.isEmpty()必不为空，原因为分析如下： // 所有的入栈元素一定会入栈，但是只有匹配的情况下才会出栈， // 匹配的次数最多与入栈元素个数元素相同（两个数组的长度相等），如果有不匹配的元素， // 必然会使出栈的次数比入栈的次数少，这样栈中至少会有一个元素 // 对于第二种情况其stack.isEmpty()一定为空 // 所以书本上的nextPop == pop.length（pNextPop-pPop==nLength）是多余的 if (stack.isEmpty()) { isPossible = true; } } return isPossible; } public static void main(String[] args) { int[] push = {1, 2, 3, 4, 5}; int[] pop1 = {4, 5, 3, 2, 1}; int[] pop2 = {3, 5, 4, 2, 1}; int[] pop3 = {4, 3, 5, 1, 2}; int[] pop4 = {3, 5, 4, 1, 2}; System.out.println(\"true: \" + isPopOrder(push, pop1)); System.out.println(\"true: \" + isPopOrder(push, pop2)); System.out.println(\"false: \" + isPopOrder(push, pop3)); System.out.println(\"false: \" + isPopOrder(push, pop4)); int[] push5 = {1}; int[] pop5 = {2}; System.out.println(\"false: \" + isPopOrder(push5, pop5)); int[] push6 = {1}; int[] pop6 = {1}; System.out.println(\"true: \" + isPopOrder(push6, pop6)); System.out.println(\"false: \" + isPopOrder(null, null)); // 测试方法2 System.out.println(); System.out.println(\"true: \" + isPopOrder2(push, pop1)); System.out.println(\"true: \" + isPopOrder2(push, pop2)); System.out.println(\"false: \" + isPopOrder2(push, pop3)); System.out.println(\"false: \" + isPopOrder2(push, pop4)); System.out.println(\"false: \" + isPopOrder2(push5, pop5)); System.out.println(\"true: \" + isPopOrder2(push6, pop6)); System.out.println(\"false: \" + isPopOrder2(null, null)); } } 简单总结栈和队列的应用远不止上面学习到的那些，实现方式也有很多种，现在也只是暂时学到这里，通过刷LeetCode也加深了我对于这两种数据结构的认识，不过自己还需要去熟悉了解一下计算机系统关于栈的应用这方面的知识，因为栈这种结构本身就很适合用来保存CPU现场之类的工作，还是抓紧时间吧，过两天还考试，这两天就先复习啦… 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构与算法","slug":"基础知识/数据结构与算法","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"数据结构与算法(1)——数组与链表","slug":"数据结构预算法-1-——数组与链表","date":"2018-07-01T22:44:00.000Z","updated":"2020-12-09T04:59:33.957Z","comments":true,"path":"2018/07/02/shu-ju-jie-gou-yu-suan-fa-1-shu-zu-yu-lian-biao/","link":"","permalink":"http://www.wmyskxz.com/2018/07/02/shu-ju-jie-gou-yu-suan-fa-1-shu-zu-yu-lian-biao/","excerpt":"","text":"前言：终于到了疯狂学习数据结构的时候，换个好看的题图，开始吧.. 数组什么是数组？数组简单来说就是将所有的数据排成一排存放在系统分配的一个内存块上，通过使用特定元素的索引作为数组的下标，可以在常数时间内访问数组元素的这么一个结构； 为什么能在常数时间内访问数组元素？为了访问一个数组元素，该元素的内存地址需要计算其距离数组基地址的偏移量。需要用一个乘法计算偏移量，再加上基地址，就可以获得某个元素的内存地址。首先计算元素数据类型的存储大小，然后将它乘以元素在数组中的索引，最后加上基地址，就可以计算出该索引位置元素的地址了；整个过程可以看到需要一次乘法和一次加法就完成了，而这两个运算的执行时间都是常数时间，所以可以认为数组访问操作能在常数时间内完成； 数组的优点 简单且易用； 访问元素快（常数时间）； 数组的缺点 大小固定：数组的大小是静态的（在使用前必须制定数组的大小）； 分配一个连续空间块：数组初始分配空间时，有时候无法分配能存储整个数组的内存空间（当数组规模太大时）； 基于位置的插入操作实现复杂：如果要在数组中的给定位置插入元素，那么可能就会需要移动存储在数组中的其他元素，这样才能腾出指定的位置来放插入的新元素；而如果在数组的开始位置插入元素，那么这样的移动操作开销就会很大。 关于数组的一些问题思考1）在索引没有语义的情况下如何表示没有的元素？ 我们创建的数组的索引可以有语义也可以没有语义，比如我现在只是单纯的想存放100，98，96这三个数字，那么它们保存在索引为0，1，2的这几个地方或者其他地方都可以，无论它们之间的顺序怎样我都不关心，因为它们的索引是没有语义的我只是想把它们存起来而已；但是如果它们变成了学号为1，2，3这几个同学对应的成绩，那么它们的索引就有了语义，索引0对应了学号为1的同学的成绩，索引1对应了学号2的同学，索引2对应了学号3的同学，因为数组的最大的优点是访问元素是在常数时间，所以我们使用数组最好就是在索引有语义的情况下； 好了，那么如果在索引没有语义的情况下，我们如何表示没有的元素呢？例如上图中，对于用户而言，访问索引为3和4的数组元素是违法的，因为它们根本就不存在，我们如何表示没有的元素呢？ 表示为0或者-1？ 2）如何添加元素和删除元素呢？ 我们知道，数组的明显缺点是在创建之前需要提前声明好要使用的空间，那么当我们空间满了该如何处理呢？又该如何删除元素呢？在Java中提供给我们的默认数组是不支持这些功能的，我们需要开发属于自己的数组类才行； 使用泛型封装自己的数组类我们需要自己创建一个Array类，并实现一些增删改查的功能，大体的结构如下： public class Array&lt;E>{ private E[] data; private int size; /* 一些成员方法 */ } 我们需要一个成员变量来保存我们的数据，这里是data，然后需要一个int类型来存放我们的有效元素的个数，在这里我们没有必要再多定义一个表示数组空间的变量，因为这里的空间大小就是data.length； 默认的构造函数我们需要创建一些方法来初始化我们的数组，那肯定是需要传一个capacity来表示数组的容量嘛： // 构造函数，传入数组的容量capacity构造Array public Array(int capacity) { data = (E[]) new Object[capacity]; size = 0; } 当然我们也需要创建一个默认的构造函数来为不知道初始该定义多少的用户一个默认大小的数组： // 无参数的构造函数，默认数组的容量capacity=10 public Array() { this(10); } 这里演示的话给个10差不多了，实际可能会更复杂一些… 成员方法就是增删改查嘛，不过这里需要注意的是，为了实现我们自己的动态数组，在增加和删除中，我们对临界值进行了判断，动态的增加或者缩小数组的大小，而且提供了一些常用友好的方法给用户； // 获取数组的容量 public int getCapacity() { return data.length; } // 获取数组中的元素个数 public int getSize() { return size; } // 返回数组是否为空 public boolean isEmpty() { return size == 0; } // 在index索引的位置插入一个新元素e public void add(int index, E e) { if (index &lt; 0 || index > size) throw new IllegalArgumentException(\"Add failed. Require index >= 0 and index &lt;= size.\"); if (size == data.length) resize(2 * data.length); for (int i = size - 1; i >= index; i--) data[i + 1] = data[i]; data[index] = e; size++; } // 向所有元素后添加一个新元素 public void addLast(E e) { add(size, e); } // 在所有元素前添加一个新元素 public void addFirst(E e) { add(0, e); } // 获取index索引位置的元素 public E get(int index) { if (index &lt; 0 || index >= size) throw new IllegalArgumentException(\"Get failed. Index is illegal.\"); return data[index]; } // 修改index索引位置的元素为e public void set(int index, E e) { if (index &lt; 0 || index >= size) throw new IllegalArgumentException(\"Set failed. Index is illegal.\"); data[index] = e; } // 查找数组中是否有元素e public boolean contains(E e) { for (int i = 0; i &lt; size; i++) { if (data[i].equals(e)) return true; } return false; } // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1 public int find(E e) { for (int i = 0; i &lt; size; i++) { if (data[i].equals(e)) return i; } return -1; } // 从数组中删除index位置的元素, 返回删除的元素 public E remove(int index) { if (index &lt; 0 || index >= size) throw new IllegalArgumentException(\"Remove failed. Index is illegal.\"); E ret = data[index]; for (int i = index + 1; i &lt; size; i++) data[i - 1] = data[i]; size--; data[size] = null; // loitering objects != memory leak if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) resize(data.length / 2); return ret; } // 从数组中删除第一个元素, 返回删除的元素 public E removeFirst() { return remove(0); } // 从数组中删除最后一个元素, 返回删除的元素 public E removeLast() { return remove(size - 1); } // 从数组中删除元素e public void removeElement(E e) { int index = find(e); if (index != -1) remove(index); } @Override public String toString() { StringBuilder res = new StringBuilder(); res.append(String.format(\"Array: size = %d , capacity = %d\\n\", size, data.length)); res.append('['); for (int i = 0; i &lt; size; i++) { res.append(data[i]); if (i != size - 1) res.append(\", \"); } res.append(']'); return res.toString(); } // 将数组空间的容量变成newCapacity大小 private void resize(int newCapacity) { E[] newData = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) newData[i] = data[i]; data = newData; } 注意：为了更好的展示代码而不太浪费空间，所以这里使用//的风格来注释代码； 特别注意：在remove方法中，缩小数组的判断条件为size == data.length / 4 &amp;&amp; data.length / 2 != 0，这是为了防止复杂度抖动和安全性； 简单时间复杂度分析添加操作在添加操作中，我们可以明显看到，addLast()方法是与n无关的，所以为O(1)复杂度；而addFirst()和add()方法都涉及到挪动数组元素，所以都是O(n)复杂度，包括resize()方法；综合起来添加操作的复杂度就是O(n)； 删除操作在删除操作中，与添加操作同理，综合来看删除操作的复杂度就是O(n)； 修改操作在修改操作中，如果我们知道了需要修改元素的索引，那么我们就可以在常数时间内找到元素并进行修改操作，所以很容易的知道这个操作时一个复杂度为O(1)的操作，所以修改操作的复杂度就是O(1)；但另外一种情况是我们不知道元素的索引，那么我们就需要先去查询这个元素，我把这归结到查询操作中去； 查询操作在查询操作中，如果我们已知索引，那么复杂度为O(1)；如果未知索引，我们需要遍历整个数组，那么复杂度为O(n)级别； 总结以上我们简单分析了我们自己创建的数组类的复杂度： 增加：O(n)； 删除：O(n)； 修改：已知索引 O(1)；未知索引 O(n)； 查询：已知索引 O(1)；未知索引 O(n)； 均摊复杂度如果细心的同学应该可以注意到，在增加和删除的复杂度分析中，如果我们都只是对最后一个元素进行相应的操作的话，那么对应的O(n)的复杂度显然是不合理的，我们之所以将他们的复杂度定义为O(n)，就是因为在我们通常的复杂度分析中我们需要考虑最坏的情况，也就是对应的需要使用resize()方法扩容的情况，但是这样的情况并不是每一次都出现，所以我们需要更加合理的来分析我们的复杂度，这里提出的概念就是：均摊复杂度； 假设我们现在的capacity为5，并且每一次的添加操作都使用addLast()方法，那么我们在使用了五次addLast()方法之后就会触发一次resize()方法，在前五次的addLast()方法中我们总共进行了五次基本操作，也就是给数组的末尾添加上一个元素，在进行第六次addLast()方法的时候，触发resize()方法，就需要进行一次元素的转移，共5次操作（转移五个元素嘛），然后再在末尾加上一个元素，也就是总共进行了11次操作； 也就是说：6次addLast()操作，触发resize()方法，总共进行了11次操作，平均下来，每次addLast()操作，进行了2次基本操作（约等于）；那么依照上面的假设我们可以进一步推广为：假设capacity为n，n+1次addLast()操作，触发resize()方法，总共进行了2n+1次基本操作，平均来讲，每次addLast()操作，进行了2次基本操作，这样也就意味着，均摊下来的addLast()方法的复杂度为O(1)，而不是之前分析的O(n)，这样的均摊复杂度显然比最坏复杂度来得更有意义，因为不是每一次的操作都是最坏的情况！ 同理，我们看removeLast()对应的均摊复杂度也为O(1)； 复杂度震荡在我们的remove方法中，我们判断缩小容量的条件为size == data.length / 4 &amp;&amp; data.length / 2 != 0，这样是为了防止复杂度震荡和安全性（因为缩小到一定的时候容量可能为1），这又是怎么一回事呢？我们考虑一下将条件改为size == data.length / 2的时候，出现的如下图这样的情况： 当我们数组已经满元素的情况下，使用一次addLast方法，因为触发resize，数组容量扩容为当前的两倍，所以此时复杂度为O(n)；这时候我们立即使用removeLast，因为此时的容量等于n/2，所以会马上产生缩小容量的操作，此时复杂度为O(n)；我们之前明明通过均摊复杂度分析出我们的两个操作都为O(1)，而此时却产生了震荡，为了避免这样的操作，我们需要懒操作一下，也就是在remove的时候不要立即缩容，而是等到size == capacity / 4的时候再缩小一半，这样就有效的解决了复杂度震荡的问题； Java中的ArrayList的扩容上面我们已经实现了自己的数组类，我们也顺便看看Java中的ArrayList是怎么写的，其他的方法可以自己去看看，这里提出来一个grow()的方法，来看看ArrayList是怎么实现动态扩容的： 从上面的源码我们可以看到ArrayList默认增容是增加当前容量的0.5倍（&gt;&gt; 1即乘以0.5） 链表什么是链表链表是一种用于存储数据集合的数据结构，它是最简单的动态数据结构，我们在上面虽然实现了动态数组，但这仅仅是对于用户而言，其实底层还是维护的一个静态的数组，它之所以是动态的是因为我们在add和remove的时候进行了相应判断动态扩容或缩容而已，而链表则是真正意义上动态的数据结构； 链表的优点 真正的动态，不需要处理固定容量的问题； 能够在常数时间内扩展容量； 对比我们的数组，当创建数组时，我们必须分配能存储一定数量元素的内存，如果向数组中添加更多的元素，那么必须创建一个新的数组，然后把原数组中的元素复制到新数组中去，这将花费大量的时间；当然也可以通过给数组预先设定一个足够大的空间来防止上述时间的发生，但是这个方法可能会因为分配超过用户需要的空间而造成很大的内存浪费；而对于链表，初始时仅需要分配一个元素的存储空间，并且添加新的元素也很容易，不需要做任何内存复制和重新分配的操作； 链表的缺点 丧失了随机访问的能力； 链表中的额外指针引用需要浪费内存； 链表有许多不足。链表的主要缺点在于访问单个元素的时间开销问题；数组是随时存取的，即存取数组中任一元素的时间开销为O(1)，而链表在最差情况下访问一个元素的开销为O(n)；数组在存取时间方面的另一个优点是内存的空间局部性，由于数组定义为连续的内存块，所以任何数组元素与其邻居是物理相邻的，这极大得益于现代CPU的缓存模式； 链表和数组的简单对比 数组最好用于索引有语意的情况，最大的优点：支持快速查询； 链表不适用于索引有语意的情况，最大的优点：动态； 实现自己的链表类public class LinkedList&lt;E> { private class Node { public E e; public Node next; public Node(E e, Node next) { this.e = e; this.next = next; } public Node(E e) { this(e, null); } public Node() { this(null, null); } @Override public String toString() { return e.toString(); } } private Node dummyHead; private int size; public LinkedList() { dummyHead = new Node(); size = 0; } // 获取链表中的元素个数 public int getSize() { return size; } // 返回链表是否为空 public boolean isEmpty() { return size == 0; } // 在链表的index(0-based)位置添加新的元素e // 在链表中不是一个常用的操作，练习用：） public void add(int index, E e) { if (index &lt; 0 || index > size) throw new IllegalArgumentException(\"Add failed. Illegal index.\"); Node prev = dummyHead; for (int i = 0; i &lt; index; i++) prev = prev.next; prev.next = new Node(e, prev.next); size++; } // 在链表头添加新的元素e public void addFirst(E e) { add(0, e); } // 在链表末尾添加新的元素e public void addLast(E e) { add(size, e); } // 获得链表的第index(0-based)个位置的元素 // 在链表中不是一个常用的操作，练习用：） public E get(int index) { if (index &lt; 0 || index >= size) throw new IllegalArgumentException(\"Get failed. Illegal index.\"); Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) cur = cur.next; return cur.e; } // 获得链表的第一个元素 public E getFirst() { return get(0); } // 获得链表的最后一个元素 public E getLast() { return get(size - 1); } // 修改链表的第index(0-based)个位置的元素为e // 在链表中不是一个常用的操作，练习用：） public void set(int index, E e) { if (index &lt; 0 || index >= size) throw new IllegalArgumentException(\"Update failed. Illegal index.\"); Node cur = dummyHead.next; for (int i = 0; i &lt; index; i++) cur = cur.next; cur.e = e; } // 查找链表中是否有元素e public boolean contains(E e) { Node cur = dummyHead.next; while (cur != null) { if (cur.e.equals(e)) return true; cur = cur.next; } return false; } // 从链表中删除index(0-based)位置的元素, 返回删除的元素 // 在链表中不是一个常用的操作，练习用：） public E remove(int index) { if (index &lt; 0 || index >= size) throw new IllegalArgumentException(\"Remove failed. Index is illegal.\"); // E ret = findNode(index).e; // 两次遍历 Node prev = dummyHead; for (int i = 0; i &lt; index; i++) prev = prev.next; Node retNode = prev.next; prev.next = retNode.next; retNode.next = null; size--; return retNode.e; } // 从链表中删除第一个元素, 返回删除的元素 public E removeFirst() { return remove(0); } // 从链表中删除最后一个元素, 返回删除的元素 public E removeLast() { return remove(size - 1); } // 从链表中删除元素e public void removeElement(E e) { Node prev = dummyHead; while (prev.next != null) { if (prev.next.e.equals(e)) break; prev = prev.next; } if (prev.next != null) { Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; } } @Override public String toString() { StringBuilder res = new StringBuilder(); Node cur = dummyHead.next; while (cur != null) { res.append(cur + \"->\"); cur = cur.next; } res.append(\"NULL\"); return res.toString(); } } 链表虚拟头结点的作用 为了屏蔽掉链表头结点的特殊性；因为头结点是没有前序结点的，所以我们不管是删除还是增加操作都要对头结点进行单独的判断，为了我们编写逻辑的方便，引入了一个虚拟头结点的概念； 简单复杂度分析我们从链表的操作中可以很容易的看出，对于增删改查这几个操作的复杂度都是O(n)的，但是如果我们只是对链表头进行增/删/查的操作的话，那么它的复杂度就是O(1)的，这里也可以看出来我们的链表适合干的事情了.. LeetCode相关题目参考1.两数之和 参考答案： class Solution { public int[] twoSum(int[] numbers, int target) { int [] res = new int[2]; if(numbers==null||numbers.length&lt;2) return res; HashMap&lt;Integer,Integer> map = new HashMap&lt;Integer,Integer>(); for(int i = 0; i &lt; numbers.length; i++){ if(!map.containsKey(target-numbers[i])){ map.put(numbers[i],i); }else{ res[0]= map.get(target-numbers[i]); res[1]= i; break; } } return res; } } 2.两数相加 参考答案： public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry > 0) { curr.next = new ListNode(carry); } return dummyHead.next; } 19.删除链表的倒数第N个节点（剑指Offer面试题22） 我的答案：（13ms） public ListNode removeNthFromEnd(ListNode head, int n) { // 正确性判断 if (null == head || null == head.next) { return null; } int num = 0; // 定义一个虚拟头结点方便遍历链表 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode prev = dummyHead; // 一次遍历找到链表的总数 while (null != prev.next) { num++; prev = prev.next; } // 二次遍历删除对应的节点 prev = dummyHead; for (int i = 0; i &lt; num - n; i++) { prev = prev.next; }// end for:找到了删除节点的前序节点 ListNode delNode = prev.next; prev.next = prev.next.next; delNode.next = null; // 返回头结点 return dummyHead.next; } 我的答案2：（16ms） public ListNode removeNthFromEnd(ListNode head, int n) { // 正确性判断 if (null == head || null == head.next) { return null; } HashMap&lt;Integer, ListNode> map = new HashMap&lt;>(); // 定义一个虚拟头结点方便遍历链表 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode prev = dummyHead; map.put(0, dummyHead); // 一次遍历，将序号与ListNode对应存入map中 for (int i = 1; null != prev.next; i++, prev = prev.next) { map.put(i, prev.next); } // 删除对应的节点 int delNodeNum = map.size() - n; ListNode delNode = map.get(delNodeNum); prev = map.get(delNodeNum - 1); prev.next = prev.next.next; delNode.next = null;// help GC // 返回头结点 return dummyHead.next; } 参考答案：（26ms） public ListNode removeNthFromEnd(ListNode head, int n) { // 正确性判断 if (null == head || null == head.next) { return null; } // 定义虚拟头结点方便遍历 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; // 定义快慢两个节点 ListNode fast = dummyHead; ListNode slow = dummyHead; // 让fast先跑到第n个位置 for (int i = 0; i &lt;= n; i++) { fast = fast.next; } // 再让两个一起移动，当fast为尾节点时slow的位置即删除元素的位置 while (null != fast) { fast = fast.next; slow = slow.next; } ListNode delNode = slow.next; slow.next = slow.next.next; delNode.next = null;// help GC. return dummyHead.next; } 21.合并两个有序链表（剑指Offer面试题25） 我的答案：（13ms） public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 正确性判断 if (null == l1) { return l2; } if (null == l2) { return l1; } // 定义一个虚拟头结点方便遍历 ListNode dummyHead = new ListNode(-1); dummyHead.next = l1; ListNode pre = dummyHead; // 遍历l1链表 int len1 = 0; while (null != pre.next) { len1++; pre = pre.next; } int[] nums1 = new int[len1]; // 保存l1链表的数据 pre = dummyHead; for (int i = 0; i &lt; len1; i++) { nums1[i] = pre.next.val; pre = pre.next; } // 遍历l2链表 int len2 = 0; dummyHead.next = l2; pre = dummyHead; while (null != pre.next) { len2++; pre = pre.next; } int[] nums2 = new int[len2]; // 保存l2链表的数据 pre = dummyHead; for (int i = 0; i &lt; len2; i++) { nums2[i] = pre.next.val; pre = pre.next; } int[] nums = new int[len1 + len2]; // 将两个链表的数据整合并排序 System.arraycopy(nums1, 0, nums, 0, len1); System.arraycopy(nums2, 0, nums, len1, len2); Arrays.sort(nums); // 拼接一个链表 ListNode dummy = new ListNode(-1); pre = dummy; for (int i = 0; i &lt; nums.length; i++) { ListNode node = new ListNode(nums[i]); pre.next = node; pre = pre.next; } return dummy.next; } 参考答案：（15ms） public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } if (l2 == null) { return l1; } ListNode head = null; if (l1.val &lt; l2.val) { head = l1; head.next = mergeTwoLists(l1.next, l2); } else { head = l2; head.next = mergeTwoLists(l1, l2.next); } return head; } 74.搜索二维矩阵（剑指Offer面试题4） 参考答案：（8ms） public boolean searchMatrix(int[][] matrix, int target) { // 正确性判断 if (null == matrix || 0 == matrix.length) { return false; } if (null == matrix[0] || 0 == matrix[0].length) { return false; } int row = matrix.length; int col = matrix[0].length; int start = 0, end = row * col - 1; while (start &lt;= end) { int mid = start + (end - start) / 2; int number = matrix[mid / col][mid % col]; if (number == target) { return true; } else if (number > target) { end = mid - 1; } else { start = mid + 1; } } return false; } 141.环形链表 我的答案：（14ms） public boolean hasCycle(ListNode head) { // 正确条件判断 if (null == head || null == head.next) { return false; } // 引入虚拟头结点 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; HashMap&lt;ListNode, Integer> map = new HashMap&lt;>(); ListNode prev = dummyHead; // 遍历链表 while (null != prev.next) { if (map.containsKey(prev.next)) { return true; } else { map.put(prev.next, prev.next.val); prev = prev.next; } } // 如果遍历到了链表尾巴都没找到则返回false return false; } 参考答案：（3ms） public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null){ // move 2 steps fast = fast.next.next; // move 1 step slow = slow.next; if(fast == slow) return true; } return false; } 147.对链表进行插入排序 参考答案：（38ms） public ListNode insertionSortList(ListNode head) { // 正确性判断 if (null == head || null == head.next) { return head; } // 定义一个新的节点，这个节点的作用是一个一个把head开头的链表插入到dummy开头的链表里 ListNode dummy = new ListNode(-1); // 类似于冒泡排序法的遍历整个链表 while (null != head) { ListNode pre = dummy; while (null != pre.next &amp;&amp; pre.next.val &lt; head.val) { pre = pre.next; } ListNode temp = head.next; head.next = pre.next; pre.next = head; head = temp; } return dummy.next; } 148.排序链表 我的答案：（829ms） public ListNode sortList(ListNode head) { // 正确性判断 if (null == head || null == head.next) { return head; } // 引入虚拟头结点方便遍历 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; List&lt;Integer> vals = new ArrayList&lt;>(); ListNode prev = dummyHead; // 遍历一遍数组，将数据存入排好序存入vals集合中 while (null != prev.next) { // 每一次都将val值插入到正确的地方 int index = 0; for (int i = 0; i &lt; vals.size(); i++) { if (prev.next.val >= vals.get(i)) { index = i + 1; } } vals.add(index, prev.next.val); prev = prev.next; } // 连接链表 prev = dummyHead; for (int i = 0; i &lt; vals.size(); i++) { ListNode node = new ListNode(vals.get(i)); prev.next = node; prev = prev.next; } return dummyHead.next; } 参考答案：（4ms） public ListNode sortList(ListNode head) { // 正确性判断 if (null == head || null == head.next) { return head; } // 第一次遍历：找到链表长度 int len = 0; ListNode cur = head; while (null != cur) { len++; cur = cur.next; } // 第二次遍历：保存链表的值 int[] nums = new int[len]; cur = head; for (int i = 0; i &lt; len; i++) { nums[i] = cur.val; cur = cur.next; } // 第三次遍历：改变链表的值 Arrays.sort(nums); cur = head; for (int i = 0; i &lt; len; i++) { cur.val = nums[i]; cur = cur.next; } return head; } 这里想吐槽一下：因为上面的算法遍历了三次链表，我想着使用ArrayList来少一次遍历结果发现运算速度达到了20ms左右..时间好像都花在了ArrayList转数组这个操作上了…这或许就是传说中的负优化吧… 203.删除链表中的节点（剑指Offer面试题18） 参考答案： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // 定义一个虚拟头结点 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode prev = dummyHead; while (prev.next != null) { if (prev.next.val == val) { prev.next = prev.next.next; } else { prev = prev.next; } } return dummyHead.next; } } 206.反转链表（剑指Offer面试题6、面试题24） 我的答案：（7ms） public ListNode reverseList(ListNode head) { // 正确性判断 if (null == head || null == head.next) { return head; } // 定义一个虚拟头结点 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; HashMap&lt;Integer, ListNode> map = new HashMap&lt;>(); ListNode prev = dummyHead; // 存储节点顺序信息 for (int i = 0; null != prev.next; i++) { map.put(i, prev.next); prev = prev.next; } int listSize = map.size(); // 反转链表 for (int i = listSize - 1; i > 0; i--) { map.get(i).next = map.get(i - 1); } map.get(0).next = null; // 返回头结点 return map.get(listSize - 1); } 参考答案：（0ms） public ListNode reverseList(ListNode head) { ListNode pre = null; while (null != head) { ListNode temp = head; head = head.next; temp.next = pre; pre = temp; } return pre; } 442.数组中重复的数据（剑指Offer面试题3） 我的答案：（56ms） public List&lt;Integer> findDuplicates(int[] nums) { List&lt;Integer> result = new ArrayList&lt;>(); // 正确性判断 if (null == nums || 0 == nums.length) { return result; } // 创建一个HashMap，K值存位置，V值存数据 HashMap&lt;Integer, Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt; nums.length; i++) { // 如果存在重复的V值那么则有重复的元素存在 if (map.containsKey(nums[i])) { result.add(nums[i]); } map.put(nums[i], i); } return result; } 参考答案：（14ms） public List&lt;Integer> findDuplicates(int[] nums) { List&lt;Integer> res = new ArrayList&lt;>(); if (nums == null || nums.length == 0) return res; for (int i = 0; i &lt; nums.length; i++) { int index = Math.abs(nums[i]) - 1; if (nums[index] > 0) nums[index] *= -1; else { res.add(index + 1); } } return res; } 上面这个方法我DEBUG了一会儿终于搞懂了，如果有两个重复的数字，那么nums[index]位置的数字一定是一个复数，但是如果这个index值超过了nums.length，就会报错啊..这个只能算一个巧解吧… 简单总结刷题还是挺有成就感的，像这样复习一遍下来感觉自己还是挺有收获的，特别是在算法方面有了一些神奇的体验，然后呢数据结构这方面也通过刷题有了不一样的理解和见解，就希望自己能抓紧点儿时间吧，加油； 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构与算法","slug":"基础知识/数据结构与算法","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"SpringBoot技术栈搭建个人博客【前台开发/项目总结】","slug":"SpringBoot技术栈搭建个人博客【前台开发-项目总结】","date":"2018-06-28T22:42:00.000Z","updated":"2020-12-09T05:13:02.129Z","comments":true,"path":"2018/06/29/springboot-ji-zhu-zhan-da-jian-ge-ren-bo-ke-qian-tai-kai-fa-xiang-mu-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/06/29/springboot-ji-zhu-zhan-da-jian-ge-ren-bo-ke-qian-tai-kai-fa-xiang-mu-zong-jie/","excerpt":"","text":"前言：写前台真的是我不擅长的东西…所以学习和写了很久很久…前台页面大概开发了两天半就开发好了，采用的静态的html和bootstrap来写，写后台的时候纠结住了…怎么说呢，写页面真的是头疼… 前序文章链接：SpringBoot技术栈搭建个人博客【项目准备】：https://www.jianshu.com/p/0293368fe750 前序文章链接：SpringBoot技术栈搭建个人博客【后台开发】：https://www.jianshu.com/p/91c6c9fc67c4 Bootstrap or Vue？先吐槽一句..写页面是真的不擅长，然后限于时间的问题，我开始考虑换用Bootstrap来完成页面的编写，因为时间有限（我得在实习完之前把所有页面开发完），学习Vue对于我来说还是存在一些学习成本的，虽然之前已经通过文档博客之类的学得七七八八（emm..三三四四吧…）的样子，但我还是想尽可能的写好…还是用自己熟悉的Bootstrap来完成吧… 前台页面分析 个人博客的前台页面相对比较简单，大概也就这么五个页面搞定，因为有了原型图，所以实现起来还是挺容易； 页面展示首页 emm…还原度还算蛮高的啦…而且发现这一套模板对于题图的要求蛮高的…如果不好看或者图片本身太小就会变得奇怪以及模糊…目前还没有找到啥好的方法解决这个图片的问题，不过倒是找到一个有趣的css属性叫object-fit: cover;，超级方便的图片居中方法，之前找了很多JS都不是很满意，大家可以试试… 博客分类页 这个页面还有待商榷…因为后面可能会换成没有题图而是只是博文信息的版本… 博文页 Ps：突然很想吐槽一下自己写的文章都有点长..专门找了篇内容没那么多的，不然截图工具截不完页面… 保存在数据库中的是md源码，在前台请求的时候，我直接转成了html源码弄出来，然后CSS样式是自己找的，跟我的公众微信号是一个，大家需要的话存一下吧，感觉还是挺好看的： p{font-size:15px; line-height:28px; color:#595959;font-family:微软雅黑} pre, code{font-size:14px; font-family: Roboto, 'Courier New', Consolas, Inconsolata, Courier, monospace;} code{margin:0 3px; padding:0 6px; white-space: pre-wrap; background-color:#F8F8F8; border-radius:2px; display: inline;} pre{font-size:15px; line-height:20px;} precode{white-space: pre; overflow:auto; border-radius:3px; padding:5px10px; display: block !important;} strong, b{color:#BF360C;} em, i{color:#009688;} big{font-size:22px; color:#009688; font-weight: bold; vertical-align: middle; border-bottom:1px solid #eee;} small{font-size:12px; line-height:22px;} hr{border-bottom:0.05em dotted #eee; margin:10px auto;} p{margin:15px 5px!important;} table, pre, dl, blockquote, q, ul, ol{margin:10px 5px;} ul, ol{padding-left:10px;} li{margin:5px;} lip{margin:5px 0!important;} ulul, ulol, olul, olol{margin:0; padding-left:10px;} olol, ulol{list-style-type: lower-roman;} ululol, ulolol, olulol, ololol{list-style-type: lower-alpha;} dl{padding:0;} dldt{font-size:1em; font-weight: bold; font-style: italic;} dldd{margin:0 0 10px; padding:0 10px;} blockquote, q{border-left:3px solid #009688; padding:0 10px; color:#777; quotes: none;} blockquote::before, blockquote::after, q::before, q::after{content: none;} h1, h2, h3, h4, h5, h6{margin:20px 0 10px; padding:0; font-weight: bold; color:#009688;} h1{font-size:24px;} h2{font-size:22px;} h3{font-size:18px;} h4{font-size:18px;} h5{font-size:16px;} h6{font-size:16px; color:#777;} table{padding:0; border-collapse: collapse; border-spacing:0; font-size:1em; font: inherit; border:0;} tbody{margin:0; padding:0; border:0;} tabletr{border:0; border-top:1px solid #CCC; background-color: white; margin:0; padding:0;} tabletr:nth-child(2n){background-color:#F8F8F8;} tabletrth, tabletrtd{font-size:16px; border:1px solid #CCC; margin:0; padding:5px10px;} tabletrth{font-weight: bold; background-color:#F0F0F0;} img{display:block;text-align:center;margin:0 auto;} 关于/留言页 emmm…一大堆测试用的留言信息请无视… 简历页 这里简历也仅仅是包含了一个头和一个尾巴，其实已经做好了…做成的PDF文件可以网上搜索工具直接转成html代码，但并不是很想粘出来… 后台页面分析 当时分析的时候是大致分成了这几个模块和这么多个页面，但是后来实现的时候，一个模块都整成了一个页面，懒得复制粘贴再改改改，直接一个页面搞定； 页面展示数据统计模块 看过我之前博文的童鞋应该都会觉得眼熟（什么？这不就是之前写天猫找的模板吗？），反正能省事儿就省，而且这一套模板既有满足自适应的要求，又有增强表格的js插件，为啥不用呢？好了，链接在这里：http://www.cssmoban.com/cssthemes/7381.shtml 这一个模块就是一个数据统计，包括有：访问量、日志量、留言数还有一些详细的列表； emmm..自适应后大概像下面这样： 分类管理模块 我把分类相关的功能都写在了一个页面上，这样操作也方便； 博文管理模块 点击编辑会弹出一个模态框，跟新增博文差不太多： 评论管理模块 这个模块我后来改了一下，只是用来显示文章的评论信息，通过监听Select来动态加载数据，删除之后虽然是置数据库isEffective字段为0，但仍然不会在后台显示…（因为我感觉删除的都是不想看到的，就不显示了…） 项目总结上面就是项目的所有页面了，虽然现在看起来还是挺清晰简单的，但写的时候还是头大，头大，头大…不过通过这一次的开发，对写前台还是有了一定的熟悉，特别是对JS的编写以及Bootstrap响应式布局，而且在写前端的时候测出来还是一堆BUG，也犯了一些拼写错误这样的低级错误…而且感觉前端更多的是细节的东西，因为毕竟是直接与用户进行交互的，还是希望自己多写多积累吧，下面对项目中出现的一些问题进行一些总结： HTML公有资源的提取前端会面临着和写后端一样的问题，就是怎样抽取出一些中间件，来让大家共同使用，例如头部、尾部，我采用的是下面这样的方法解决： &lt;script language=\"javascript\" type=\"text/javascript\" src=\"js/head.js\">&lt;/script> 先编写好单独的html文件，然后转成JS动态加载进来就好了，参考文章：https://blog.csdn.net/wabiaozia/article/details/75092623 跨域问题在前后端结合的时候，出现的第一个问题就是跨域，参考文章：https://blog.csdn.net/saytime/article/details/74937204 ，我是使用的Filter方法，下面是代码： /** * 实现跨域 * * @author:wmyskxz * @create:2018-06-21-下午 22:48 */ @Component public class SimpleCORSFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", request.getHeader(\"Origin\")); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS ,PUT, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Connection, User-Agent, Cookie\"); chain.doFilter(req, res); } @Override public void init(FilterConfig filterConfig) {} @Override public void destroy() {} } 但其实这样配置了之后，前端发的请求确实的能提交到服务器上来，服务器也能够做相应的处理，但AJAX中，PUT和POST方法老是进到error方法中而不进入success方法，我也是没辙…而且之前没有给Allow-Headers添加上除X-Requested-with之外的东西，POST的时候它会先提交一个头里面不光有X-Requested-with还有Content-Type的OPTIONS方法…也不知道为啥，最后只能妥协搞成现在这样； 时间显示的BUG从数据库取出来的数据给到前台显示的时候就变成了一串时间戳，解决方法就是在实体类的getCreateBy()这样的取时间的操作前加上一行注解：@JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)，就能成功解决了： font-awesome库显示问题单独编写前台的时候都能够正常的显示字体，但是给弄到服务器文件夹下的时候就加载不出来了，也不是404找不到一类的，但字体就是请求不到，但是我点击控制台的信息又能成功下载到字体不知道是为啥，所以只能妥协给换成了CDN上的CSS： &lt;link href=\"//cdn.bootcss.com/font-awesome/4.4.0/css/font-awesome.min.css\" rel=\"stylesheet\"> 错误页面跳转的问题因为不想让除了我以外的人登录进后台页面，我也是想了各种办法，其中之一就是把login.html页面给“隐藏”起来了，具体的做法就是把它放进一个奇怪的文件夹，然后使用一个奇怪的地址（以后再改）来绑定它： 所以这样就会出现一个问题，因为我写的拦截器的原因，所有不是以/admin开头的地址如果请求错误的话，地址栏不变，会自动跳转到error.html文件中，因为我把这个页面放到了static根目录下，这是SpringBoot默认覆盖的结果，但是如果我在后台拦截器中使用重定向访问error.html的话就会出现404图片请求不到的问题，因为它会默认访问/admin/img/404.png这个地址（此时我后台的页面放在/admin/目录下），所以我不得不把error.html中img标签中的src改成一个网络地址； 项目地址 &amp; 后期计划Github地址：https://github.com/wmyskxz/MyBlog 因为前端（不包括后台页面）没有加任何的响应式的东西，就只是用了百分比来显示，但测试的时候不知道为啥手机端啊，小屏幕啊都还可以，特别是手机端它不会缩放看到的还是页面本身的样子..还是挺好的，又可以骗自己节省了一大部分的工作，hhh 马上面临着暑假，同时也意味着秋招快要开始了，还是准备复习复习基础（数据结构和算法），emmm…冲刺冲刺大厂，自己加油吧… 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"SpringBoot技术栈搭建个人博客【后台开发】","slug":"SpringBoot技术栈搭建个人博客【后台开发】","date":"2018-06-20T22:40:00.000Z","updated":"2020-12-09T05:12:59.573Z","comments":true,"path":"2018/06/21/springboot-ji-zhu-zhan-da-jian-ge-ren-bo-ke-hou-tai-kai-fa/","link":"","permalink":"http://www.wmyskxz.com/2018/06/21/springboot-ji-zhu-zhan-da-jian-ge-ren-bo-ke-hou-tai-kai-fa/","excerpt":"","text":"前言：在之前，我们已经完成了项目的基本准备，那么就可以开始后台开发了，突然又想到一个问题，就是准备的时候只是设计了前台的RESTful APIs，但是后台管理我们同样也是需要API的，那么就在这一篇里面一起实现了吧… 前序文章链接：SpringBoot技术栈搭建个人博客【项目准备】：https://www.jianshu.com/p/0293368fe750 一些设计上的调整在查了一些资料和吸收了一些评论给出良好的建议之后，我觉得有必要对一些设计进行一些调整： 1）数据库：命名应该更加规范，比如表示分类最好用category而不是sort，表示评论最好用comment而不是message； 2）RESful APIs：在准备着手开始写后台的时候就已经发现，本来想的是凡是以/api开头的都是暴露出来给前端用的，凡是以/admin开头的都是给后台使用的地址，但是意外的没有设计后天的API也把一些删除命令暴露给了前端，这就不好了重新设计设计； 3）命名规范的问题：因为使用MyBatis逆向工程自动生成的时候，配置了一个useActualColumnNames使用表真正名称的东西，所以整得来生成POJO类基础字段有下划线，看着着实有点不爽，把它给干掉干掉…； 数据库调整把字段规范了一下，并且删除了分类下是否有效的字段（感觉这种不经常变换的字段留着也没啥用干脆干掉..），所以调整为了下面这个样子（调整字段已标红）： 然后重新使用生成器自动生成对应的文件，注意记得修改generatorConfig.xml文件中对应的数据库名称； 创建和修改时间的字段设置通过查资料发现其实我们可以通过直接设置数据库来自动更新我们的modified_by字段，并且可以像设置初始值那样给create_by和modified_by两个字段以当前时间戳设置默认值，这里具体以tbl_article_info这张表为例： CREATE TABLE `tbl_article_info` ( `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键', `title` varchar(50) NOT NULL DEFAULT '' COMMENT '文章标题', `summary` varchar(300) NOT NULL DEFAULT '' COMMENT '文章简介，默认100个汉字以内', `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '文章是否置顶，0为否，1为是', `traffic` int(10) NOT NULL DEFAULT '0' COMMENT '文章访问量', `create_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `modified_by` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改日期', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 我们通过设置DEFAULT为CURRENT_TIMESTAMP，然后给modified_by字段多添加了一句ON UPDATE CURRENT_TIMESTAMP，这样它就会在更新的时候将该字段的值设置为更新时间，这样我们就不用在后台关心这两个值了，也少写了一些代码（其实是写代码的时候发现可以这样偷懒..hhh…）； RESTful APIs重新设计我们需要把一些不能够暴露给前台的API收回，然后再设计一下后台的API，捣鼓了一下，最后大概是这个样子了： 后台Restful APIs： 前台开放RESful APIs： 这些API只是用来和前端交互的接口，另外一些关于日志啊之类的东西就直接在后台写就行了，OK，这样就爽多了，可以开始着手写代码了； 基本配置随着配置内容的增多，我逐渐的想要放弃.yml的配置文件，主要的一点是这东西不好对内容进行分类（下图是简单配置了一些基本文件后的.yml和.properties文件的对比）.. 最后还是用回.properties文件吧，不分类还是有点难受 编码设置我们首先需要解决的是中文乱码的问题，对应GET请求，我们可以通过修改Tomcat的配置文件【server.xml】来把它默认的编码格式改为UTF-8，而对于POST请求，我们需要统一配置一个拦截器一样的东西把请求的编码统一改成UTF-8： ## ——————————编码设置—————————— spring.http.encoding.charset=UTF-8 spring.http.encoding.force=true spring.http.encoding.enabled=true server.tomcat.uri-encoding=UTF-8 但是这样设置之后，在后面的使用当中还是会发生提交表单时中文乱码的问题，在网上搜索了一下找到了解决方法，新建一个【config】包创建下面这样一个配置类： @Configuration public class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter { @Bean public HttpMessageConverter&lt;String> responseBodyConverter() { StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName(\"UTF-8\")); return converter; } @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) { super.configureMessageConverters(converters); converters.add(responseBodyConverter()); } @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { configurer.favorPathExtension(false); } } 数据库及连接池配置决定这一次试试Druid的监控功能，所以给一下数据库的配置： ## ——————————数据库访问配置—————————— spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driver-class-name = com.mysql.jdbc.Driver spring.datasource.url = jdbc:mysql://127.0.0.1:3306/blog?characterEncoding=UTF-8 spring.datasource.username = root spring.datasource.password = 123456 # 下面为连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 spring.datasource.druid.initial-size=5 spring.datasource.druid.min-idle=5 spring.datasource.druid.max-active=20 # 配置获取连接等待超时的时间 spring.datasource.druid.max-wait=60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 spring.datasource.druid.time-between-eviction-runs-millis=60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 spring.datasource.druid.min-evictable-idle-time-millis=300000 spring.datasource.druid.validation-query=SELECT 1 FROM DUAL spring.datasource.druid.test-while-idle=true spring.datasource.druid.test-on-borrow=false spring.datasource.druid.test-on-return=false # 打开PSCache，并且指定每个连接上PSCache的大小 spring.datasource.druid.pool-prepared-statements=true spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 spring.datasource.druid.filters=stat,wall,log4j 日志配置在SpringBoot中其实已经使用了Logback来作为默认的日志框架，这是log4j作者推出的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J，在SpringBoot中我们无需再添加额外的依赖就能使用，这是因为在spring-boot-starter-web包中已经有了该依赖了，所以我们只需要进行配置使用就好了 第一步：创建logback-spring.xml当项目跑起来的时候，我们不可能还去看控制台的输出信息吧，所以我们需要把日志写到文件里面，在网上找到一个例子（链接：http://tengj.top/2017/04/05/springboot7/） &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\"> &lt;contextName>logback&lt;/contextName> &lt;!--自己定义一个log.path用于说明日志的输出目录--> &lt;property name=\"log.path\" value=\"/log/wmyskxz/\"/> &lt;!--输出到控制台--> &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"> &lt;!-- &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"> &lt;level>ERROR&lt;/level> &lt;/filter>--> &lt;encoder> &lt;pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern> &lt;/encoder> &lt;/appender> &lt;!--输出到文件--> &lt;appender name=\"file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"> &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"> &lt;fileNamePattern>${log.path}/logback.%d{yyyy-MM-dd}.log&lt;/fileNamePattern> &lt;/rollingPolicy> &lt;encoder> &lt;pattern>%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern> &lt;/encoder> &lt;/appender> &lt;root level=\"info\"> &lt;appender-ref ref=\"console\"/> &lt;appender-ref ref=\"file\"/> &lt;/root> &lt;!-- logback为java中的包 --> &lt;logger name=\"cn.wmyskxz.blog.controller\"/> &lt;/configuration> 在Spring Boot中你只要按照规则组织文件名，就能够使得配置文件能够被正确加载，并且官方推荐优先使用带有-spring的文件名作为日志的配置（如上面使用的logback-spring.xml，而不是logback.xml），满足这样的命名规范并且保证文件在src/main/resources下就好了； 第二步：重启项目检查是否成功我们定义的目录位置为/log/wmyskxz/，但是在项目的根目录下并没有发现这样的目录，反而是在当前盘符的根目录..不是很懂这个规则..总之是成功了的.. 打开是密密麻麻一堆跟控制台一样的【info】级别的信息，因为这个系统本身就比较简单，所以就没有必要去搞什么文本切割之类的东西了，ok..日志算是配置完成； 实际测试了一下，上线之后肯定需要调整输出级别的，不然日志文件就会特别大… 拦截器配置我们需要对地址进行拦截，对所有的/admin开头的地址请求进行拦截，因为这是后台管理的默认访问地址开头，这是必须进行验证之后才能访问的地址，正如上面的RESTful APIs，这里包含了一些增加/删除/更改/编辑一类的操作，而统统这些操作都是不能够开放给用户的操作，所以我们需要对这些地址进行拦截： 第一步：创建User实体类做验证还是需要添加session，不然不好弄，所以我们还是得创建一个常规的实体： public class User { private String username; private String password; /* getter and setter */ } 第二步：创建拦截器并继承HandlerInterceptor接口在【interceptor】包下新建一个【BackInterceptor】类并继承HandlerInterceptor接口: public class BackInterceptor implements HandlerInterceptor { private static String username = \"wmyskxz\"; private static String password = \"123456\"; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { boolean flag = true; User user = (User) request.getSession().getAttribute(\"user\"); if (null == user) { flag = false; } else { // 对用户账号进行验证,是否正确 if (user.getUsername().equals(username) &amp;&amp; user.getPassword().equals(password)) { flag = true; } else { flag = false; } } return flag; } } 在拦截器中，我们从session中取出了user，并判断是否符合要求，这里我们直接写死了（并没有更改密码的需求，但需要加密），而且我们并没有做任何的跳转操作，原因很简单，根本就不需要跳转，因为访问后台的用户只有我一个人，所以只需要我知道正确的登录地址就可以了… 第三步：在配置类中复写addInterceptors方法刚才我们在设置编码的时候自己创建了一个继承自WebMvcConfigurerAdapter的设置类，我们需要复写其中的addInterceptors方法来为我们的拦截器添加配置： @Override public void addInterceptors(InterceptorRegistry registry) { // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new BackInterceptor()).addPathPatterns(\"/admin/**\").excludePathPatterns(\"/toLogin\"); super.addInterceptors(registry); } 说明：这个方法也很简单，通过在addPathPatterns中添加拦截规则（这里设置拦截/admin开头的所有地址），并通过excludePathPatterns来排除拦截的地址（这里为/toLogin，即登录地址，到时候我可以弄得复杂隐蔽一点儿） 第四步：配置登录页面以前我们在写Spring MVC的时候，如果需要访问一个页面，必须要在Controller中添加一个方法跳转到相应的页面才可以，但是在SpringBoot中增加了更加方便快捷的方法： /** * 以前要访问一个页面需要先创建个Controller控制类，在写方法跳转到页面 * 在这里配置后就不需要那么麻烦了，直接访问http://localhost:8080/toLogin就跳转到login.html页面了 * * @param registry */ @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/admin/login\").setViewName(\"login.html\"); super.addViewControllers(registry); } 注意：login.html记得要放在【templates】下才会生效哦…（我试过使用login绑定视图名不成功，只能写全了…） 访问日志记录上面我们设置了访问限制的拦截器，对后台访问进行了限制，这是拦截器的好处，我们同样也使用拦截器对于访问数量进行一个统计 第一步：编写前台访问拦截器对照着数据库的设计，我们需要保存的信息都从request对象中去获取，然后保存到数据库中即可，代码也很简单： public class ForeInterceptor implements HandlerInterceptor { @Autowired SysService sysService; private SysLog sysLog = new SysLog(); private SysView sysView = new SysView(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 访问者的IP String ip = request.getRemoteAddr(); // 访问地址 String url = request.getRequestURL().toString(); //得到用户的浏览器名 String userbrowser = BrowserUtil.getOsAndBrowserInfo(request); // 给SysLog增加字段 sysLog.setIp(StringUtils.isEmpty(ip) ? \"0.0.0.0\" : ip); sysLog.setOperateBy(StringUtils.isEmpty(userbrowser) ? \"获取浏览器名失败\" : userbrowser); sysLog.setOperateUrl(StringUtils.isEmpty(url) ? \"获取URL失败\" : url); // 增加访问量 sysView.setIp(StringUtils.isEmpty(ip) ? \"0.0.0.0\" : ip); sysService.addView(sysView); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); // 保存日志信息 sysLog.setRemark(method.getName()); sysService.addLog(sysLog); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 注意：但是需要注意的是测试的时候别把拦截器开了（主要是postHandle方法中中无法强转handler），不然不方便测试… BrowserUtil是找的网上的一段代码，直接黏贴复制放【util】包下就可以了： /** * 用于从Request请求中获取到客户端的获取操作系统,浏览器及浏览器版本信息 * * @author:wmyskxz * @create:2018-06-21-上午 8:40 */ public class BrowserUtil { /** * 获取操作系统,浏览器及浏览器版本信息 * * @param request * @return */ public static String getOsAndBrowserInfo(HttpServletRequest request) { String browserDetails = request.getHeader(\"User-Agent\"); String userAgent = browserDetails; String user = userAgent.toLowerCase(); String os = \"\"; String browser = \"\"; //=================OS Info======================= if (userAgent.toLowerCase().indexOf(\"windows\") >= 0) { os = \"Windows\"; } else if (userAgent.toLowerCase().indexOf(\"mac\") >= 0) { os = \"Mac\"; } else if (userAgent.toLowerCase().indexOf(\"x11\") >= 0) { os = \"Unix\"; } else if (userAgent.toLowerCase().indexOf(\"android\") >= 0) { os = \"Android\"; } else if (userAgent.toLowerCase().indexOf(\"iphone\") >= 0) { os = \"IPhone\"; } else { os = \"UnKnown, More-Info: \" + userAgent; } //===============Browser=========================== if (user.contains(\"edge\")) { browser = (userAgent.substring(userAgent.indexOf(\"Edge\")).split(\" \")[0]).replace(\"/\", \"-\"); } else if (user.contains(\"msie\")) { String substring = userAgent.substring(userAgent.indexOf(\"MSIE\")).split(\";\")[0]; browser = substring.split(\" \")[0].replace(\"MSIE\", \"IE\") + \"-\" + substring.split(\" \")[1]; } else if (user.contains(\"safari\") &amp;&amp; user.contains(\"version\")) { browser = (userAgent.substring(userAgent.indexOf(\"Safari\")).split(\" \")[0]).split(\"/\")[0] + \"-\" + (userAgent.substring(userAgent.indexOf(\"Version\")).split(\" \")[0]).split(\"/\")[1]; } else if (user.contains(\"opr\") || user.contains(\"opera\")) { if (user.contains(\"opera\")) { browser = (userAgent.substring(userAgent.indexOf(\"Opera\")).split(\" \")[0]).split(\"/\")[0] + \"-\" + (userAgent.substring(userAgent.indexOf(\"Version\")).split(\" \")[0]).split(\"/\")[1]; } else if (user.contains(\"opr\")) { browser = ((userAgent.substring(userAgent.indexOf(\"OPR\")).split(\" \")[0]).replace(\"/\", \"-\")) .replace(\"OPR\", \"Opera\"); } } else if (user.contains(\"chrome\")) { browser = (userAgent.substring(userAgent.indexOf(\"Chrome\")).split(\" \")[0]).replace(\"/\", \"-\"); } else if ((user.indexOf(\"mozilla/7.0\") > -1) || (user.indexOf(\"netscape6\") != -1) || (user.indexOf(\"mozilla/4.7\") != -1) || (user.indexOf(\"mozilla/4.78\") != -1) || (user.indexOf(\"mozilla/4.08\") != -1) || (user.indexOf(\"mozilla/3\") != -1)) { browser = \"Netscape-?\"; } else if (user.contains(\"firefox\")) { browser = (userAgent.substring(userAgent.indexOf(\"Firefox\")).split(\" \")[0]).replace(\"/\", \"-\"); } else if (user.contains(\"rv\")) { String IEVersion = (userAgent.substring(userAgent.indexOf(\"rv\")).split(\" \")[0]).replace(\"rv:\", \"-\"); browser = \"IE\" + IEVersion.substring(0, IEVersion.length() - 1); } else { browser = \"UnKnown, More-Info: \" + userAgent; } return os + \"-\" + browser; } } 第二步：设置拦截地址还是在刚才的配置类中，新增这么一条： @Override public void addInterceptors(InterceptorRegistry registry) { // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new BackInterceptor()).addPathPatterns(\"/admin/**\").excludePathPatterns(\"/toLogin\"); registry.addInterceptor(getForeInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/toLogin\",\"/admin/**\"); super.addInterceptors(registry); } 设置默认错误页面在SpringBoot中，默认的错误页面比较丑（如下），所以我们可以自己改得稍微好看一点儿，具体的教程在这里：http://tengj.top/2018/05/16/springboot13/ ，我就搞前台的时候再去弄了… Service 层开发 这是纠结最久应该怎么写的，一开始我还准备老老实实地利用MyBatis逆向工程生成的一堆东西去给每一个实体创建一个Service的，这样其实就只是对Dao层进行了一层不必要的封装而已，然后通过分析其实主要的业务也就分成几个：文章/评论/分类/日志浏览量这四个部分而已，所以创建这四个Service就好了； 比较神奇的事情是在网上找到一种通用Mapper的最佳实践方法，整个人都惊了，“wtf?还可以这样写哦？”，资料如下：http://tengj.top/2017/12/20/springboot11/ emmmm..我们通过MyBatis的逆向工程，已经很大程度上简化了我们的开发，因为在Dao层我们已经免去了自己写SQL语句，自己写实体，自己写XML映射文件的麻烦，但在Service层我们仍然无可避免的要写一些类似功能的代码，有没有什么方法能把这些比较通用的方法给提取出来呢？ 答案就在上面的链接中，oh，简直太酷了…我决定在这里介绍一下… 通用接口开发在Spring4中，由于支持了泛型注解，再结合通用Mapper，我们的想法得到了一个最佳的实践方法，下面我们来讲解一下： 第一步：创建通用接口我们把一些常见的，通用的方法统一使用泛型封装在一个通用接口之中： /** * 通用接口 * * @author: wmyskxz * @create: 2018年6月15日10:27:04 */ public interface IService&lt;T> { T selectByKey(Object key); int save(T entity); int delete(Object key); int updateAll(T entity); int updateNotNull(T entity); List&lt;T> selectByExample(Object example); } 第二步：实现通用接口类/** * 通用Service * * @param &lt;T> */ public abstract class BaseService&lt;T> implements IService&lt;T> { @Autowired protected Mapper&lt;T> mapper; public Mapper&lt;T> getMapper() { return mapper; } /** * 说明：根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 * * @param key * @return */ @Override public T selectByKey(Object key) { return mapper.selectByPrimaryKey(key); } /** * 说明：保存一个实体，null的属性也会保存，不会使用数据库默认值 * * @param entity * @return */ @Override public int save(T entity) { return mapper.insert(entity); } /** * 说明：根据主键字段进行删除，方法参数必须包含完整的主键属性 * * @param key * @return */ @Override public int delete(Object key) { return mapper.deleteByPrimaryKey(key); } /** * 说明：根据主键更新实体全部字段，null值会被更新 * * @param entity * @return */ @Override public int updateAll(T entity) { return mapper.updateByPrimaryKey(entity); } /** * 根据主键更新属性不为null的值 * * @param entity * @return */ @Override public int updateNotNull(T entity) { return mapper.updateByPrimaryKeySelective(entity); } /** * 说明：根据Example条件进行查询 * 重点：这个查询支持通过Example类指定查询列，通过selectProperties方法指定查询列 * * @param example * @return */ @Override public List&lt;T> selectByExample(Object example) { return mapper.selectByExample(example); } } 至此呢，我们的通用接口就开发完成了 第三步：使用通用接口编写好我们的通用接口之后，使用就变得很方便了，只需要继承相应的通用接口或者通用接口实现类，然后进行简单的封装就行了，下面以SortInfo为例： public interface SortInfoService extends IService&lt;SortInfo> { } ========================分割线======================== /** * 分类信息Service * * @author:wmyskxz * @create:2018-06-15-上午 11:14 */ @Service public class SortInfoServiceImpl extends BaseService&lt;SortInfo> implements SortInfoService { } 对应到SortInfo的RESTful API设计，这样简单的继承就能够很好的支持，但是我们还是使用最原始的方式来创建吧… Service接口申明查了一些资料，问了一下实习公司的前辈老师，并且根据我们之前设计好的RESTful APIs，我们很有必要搞一个dto层用于前后端之间的数据交互，这一层主要是对数据库的数据进行一个封装整合，也方便前后端的数据交互，所以我们首先就需要分析在dto层中应该存在哪些数据： DTO层开发对应我们的业务逻辑和RESTful APIs，我大概弄了下面几个Dto： ① ArticleDto： 该Dto封装了文章的详细信息，对应RESTful API中的/api/article/{id}——通过文章ID获取文章信息 /** * 文章信息类 * 说明：关联了tbl_article_info/tbl_article_content/tbl_article_category/tbl_category_info/ * tbl_article_picture五张表的基础字段 * * @author:wmyskxz * @create:2018-06-19-下午 14:13 */ public class ArticleDto { // tbl_article_info基础字段 private Long id; private String title; private String summary; private Boolean isTop; private Integer traffic; // tbl_article_content基础字段 private Long articleContentId; private String content; // tbl_category_info基础字段 private Long categoryId; private String categoryName; private Byte categoryNumber; // tbl_article_category基础字段 private Long articleCategoryId; // tbl_article_picture基础字段 private Long articlePictureId; private String pictureUrl; /* getter and setter */ } ②ArticleCommentDto： 该Dto封装的事文章的评论信息，对应/api/comment/article/{id}——通过文章ID获取某一篇文章的全部评论信息 /** * 文章评论信息 * 说明：关联了tbl_comment和tbl_article_comment两张表的信息 * * @author:wmyskxz * @create:2018-06-19-下午 14:09 */ public class ArticleCommentDto { // tbl_comment基础字段 private Long id; // 评论id private String content; // 评论内容 private String name; // 用户自定义的显示名称 private String email; private String ip; // tbl_article_comment基础字段 private Long articleCommentId; // tbl_article_comment主键 private Long articleId; // 文章ID /* getter and setter */ } ③ArticleCategoryDto： 该Dto是封装了文章的一些分类信息，对应/admin/category/{id}——获取某一篇文章的分类信息 /** * 文章分类传输对象 * 说明：关联了tbl_article_category和tbl_category_info两张表的数据 * * @author:wmyskxz * @create:2018-06-20-上午 8:45 */ public class ArticleCategoryDto { // tbl_article_category表基础字段 private Long id; // tbl_article_category表主键 private Long categoryId; // 分类信息ID private Long articleId; // 文章ID // tbl_category_info表基础字段 private String name; // 分类信息显示名称 private Byte number; // 该分类下对应的文章数量 /* getter and setter */ } ④ArticleWithPictureDto： 该Dto封装了文章用于显示的基本信息，对应所有的获取文章集合的RESful APIs /** * 带题图信息的文章基础信息分装类 * * @author:wmyskxz * @create:2018-06-19-下午 14:53 */ public class ArticleWithPictureDto { // tbl_article_info基础字段 private Long id; private String title; private String summary; private Boolean isTop; private Integer traffic; // tbl_article_picture基础字段 private Long articlePictureId; private String pictureUrl; /* getter and setter */ } Service接口开发Service层其实就是对我们业务的一个封装，所以有了RESTful APIs文档，我们可以很轻易的写出对应的业务模块： 文章Service/** * 文章Service * 说明：ArticleInfo里面封装了picture/content/category等信息 */ public interface ArticleService { void addArticle(ArticleDto articleDto); void deleteArticleById(Long id); void updateArticle(ArticleDto articleDto); void updateArticleCategory(Long articleId, Long categoryId); ArticleDto getOneById(Long id); ArticlePicture getPictureByArticleId(Long id); List&lt;ArticleWithPictureDto> listAll(); List&lt;ArticleWithPictureDto> listByCategoryId(Long id); List&lt;ArticleWithPictureDto> listLastest(); } 分类Service/** * 分类Service */ public interface CategoryService { void addCategory(CategoryInfo categoryInfo); void deleteCategoryById(Long id); void updateCategory(CategoryInfo categoryInfo); void updateArticleCategory(ArticleCategory articleCategory); CategoryInfo getOneById(Long id); List&lt;CategoryInfo> listAllCategory(); ArticleCategoryDto getCategoryByArticleId(Long id); } 留言Service/** * 留言的Service */ public interface CommentService { void addComment(Comment comment); void addArticleComment(ArticleCommentDto articleCommentDto); void deleteCommentById(Long id); void deleteArticleCommentById(Long id); List&lt;Comment> listAllComment(); List&lt;ArticleCommentDto> listAllArticleCommentById(Long id); } 系统Service/** * 日志/访问统计等系统相关Service */ public interface SysService { void addLog(SysLog sysLog); void addView(SysView sysView); int getLogCount(); int getViewCount(); List&lt;SysLog> listAllLog(); List&lt;SysView> listAllView(); } Controller 层开发Controller层简单理解的话，就是用来获取数据的，所以只要Service层开发好了Controller层就很容易，就不多说了，只是我们可以把一些公用的东西放到一个BaseController中，比如引入Service： /** * 基础控制器 * * @author:wmyskxz * @create:2018-06-19-上午 11:25 */ public class BaseController { @Autowired ArticleService articleService; @Autowired CommentService commentService; @Autowired CategoryService categoryService; } 然后前后台的控制器只需要继承该类就行了，这样的方式非常值得借鉴的，只是因为这个系统比较简单，所以这个BaseController，我看过一些源码，可以在里面弄一个通用的用于返回数据的方法，比如分页数据/错误信息之类的； 记录坑1）MyBatis中Text类型的坑按照《阿里手册》（简称）上所规范的那样，我把文章的content单独弄成了一张表并且将这个“可能很长”的字段的类型设置成了text类型，但是MyBatis逆向工程自动生成的时候，却把这个text类型的字段单独给列了出去，即在生成的xml中多出了一个&lt;resultMap&gt;，标识id为ResultMapWithBLOBs，MyBatis这样做可能的原因还是怕这个字段太长影响前面的字段查询吧，但是操作这样的LONGVARCHAR类型的字段MyBatis好像并没有集成很好，所以想要很好的操作还是需要给它弄成VARCHAR类型才行； 在generatorConfig.xml中配置生成字段的时候加上这样一句话就好了： &lt;table domainObjectName=\"ArticleContent\" tableName=\"tbl_article_content\"> &lt;columnOverride column=\"content\" javaType=\"java.lang.String\" jdbcType=\"VARCHAR\" /> &lt;/table> 2）拦截器中Service注入为null的坑在编写前台拦截器的时候，我使用@Autowired注解自动注入了SysService系统服务Service，但是却报nullpointer的错，发现是没有自动注入上，SysService为空..这是为什么呢？排除掉注解没有识别或者没有给Service添加上注解的可能性之后，我发现好像是拦截器拦截的时候Service并没有创建成功造成的，参考这篇文章：https://blog.csdn.net/slgxmh/article/details/51860278，成功解决问题： @Bean public HandlerInterceptor getForeInterceptor() { return new ForeInterceptor(); } @Override public void addInterceptors(InterceptorRegistry registry) { // addPathPatterns 用于添加拦截规则 // excludePathPatterns 用户排除拦截 registry.addInterceptor(new BackInterceptor()).addPathPatterns(\"/admin/**\").excludePathPatterns(\"/toLogin\"); registry.addInterceptor(getForeInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/toLogin\", \"/admin/**\"); super.addInterceptors(registry); } 其实就是添加上@Bean注解让ForeInterceptor提前加载； 3）数据库sys_log表中operate_by字段的坑当时设计表的时候，就只是单纯的想要保存一下用户使用的浏览器是什么，其实当时并不知道应该怎么获取获取到的东西又是什么，只是觉得保存浏览器20个字段够了，但后来发现这是很蠢萌的…所以不得不调整数据库的字段长度，好在只需要单方面调整数据库的字段长度就好了： 4）保存文章的方式的坑因为我想要在数据库中保存的是md源码，而返回前台前端希望的是直接拿到html代码，这样就能很方便的输出了，所以这要怎么做呢？找到一篇参考文章：https://my.oschina.net/u/566591/blog/1535380 我们不要搞那么复杂的封装，只要简单弄一个工具类就可以了，在【util】包下新建一个【Markdown2HtmlUtil】： /** * Markdown转Html工具类 * * @author:wmyskxz * @create:2018-06-21-上午 10:09 */ public class Markdown2HtmlUtil { /** * 将markdown源码转换成html返回 * * @param markdown md源码 * @return html代码 */ public static String markdown2html(String markdown) { MutableDataSet options = new MutableDataSet(); options.setFrom(ParserEmulationProfile.MARKDOWN); options.set(Parser.EXTENSIONS, Arrays.asList(new Extension[]{TablesExtension.create()})); Parser parser = Parser.builder(options).build(); HtmlRenderer renderer = HtmlRenderer.builder(options).build(); Node document = parser.parse(markdown); return renderer.render(document); } } 使用也很简单，只需要在获取一篇文章的时候把ArticleDto里面的md源码转成html代码再返回给前台就好了： /** * 通过文章的ID获取对应的文章信息 * * @param id * @return 自己封装好的文章信息类 */ @ApiOperation(\"通过文章ID获取文章信息\") @GetMapping(\"article/{id}\") public ArticleDto getArticleById(@PathVariable Long id) { ArticleDto articleDto = articleService.getOneById(id); articleDto.setContent(Markdown2HtmlUtil.markdown2html(articleDto.getContent())); return articleDto; } 样式之类的交给前台就好了，搞定… 简单总结关于统计啊日志类的Controller还没有开发，RESful API也没有设计，这里就先发布文章了，因为好像时间有点紧，后台的页面暂时可能开发不完，准备直接开始前台页面显示的开发（主要是自己对前端不熟悉还要学习..），这里对后台进行一个简单的总结： 其实发现当数据库设计好了，RESful APIs设计好了之后，后台的任务变得非常明确，开发起来也就思路很清晰了，只是自己还是缺少一些必要的经验，如对一些通用方法的抽象/层与层之间数据交互的典型设计之类的东西，特别是一些安全方面的东西，网上的资料也比较少一些，也是自己需要学习的地方； 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"SpringBoot技术栈搭建个人博客【项目准备】","slug":"SpringBoot技术栈搭建个人博客【项目准备】","date":"2018-06-13T22:36:00.000Z","updated":"2020-12-09T05:13:04.737Z","comments":true,"path":"2018/06/14/springboot-ji-zhu-zhan-da-jian-ge-ren-bo-ke-xiang-mu-zhun-bei/","link":"","permalink":"http://www.wmyskxz.com/2018/06/14/springboot-ji-zhu-zhan-da-jian-ge-ren-bo-ke-xiang-mu-zhun-bei/","excerpt":"","text":"前言：很早之前就想要写一个自己的博客了，趁着现在学校安排的实习有很多的空档，决定把它给做出来，也顺便完成实习的任务（搞一个项目出来…） 需求分析总体目标：设计一套自适应/简洁/美观/易于文章管理发布的一个属于我个人的博客，最后一页能展示我个人的简历，因为大三快结束了马上就该去找工作了…哦忘了，最重要的还是要支持Markdown才行，因为已经习惯了… 前端需求分析首先，前端的页面要求是： ①简洁/美观——个人很喜欢像Mac那样的简洁风，越简单越好，当然也得好看； ②最好是单页面——单页面的目的一方面是为了简洁，另一方面也是为了实现起来比较简单； ③自适应——至少能适配常见的手机分辨率吧，我可不希望自己的博客存在显示差异性的问题； 然后，思考了一下可能出现的页面： 1）首页： 最新的文章——我可以搞一个轮播之类的东西用来显示最新的几篇博文； 顶部导航——导航栏可以要有，而且可以提出来搞成通用的； 联系方式——首页最好再有能一眼找到我的联系方式，比如简书/博客园/微信公众号之类的； 时间——摁，时间； 2）文章页： 分类栏——左侧应该有文章的分类，记得要有一个全部文章； 文章列表——分类栏的右边就应该是该分类下的所有文章； 分页栏——考虑到现在我的Java Web分栏下的文章已经有那么多了，还是有必要搞个分页； 3）简历页： 这是预留的页面，到时候用来显示个人的简历； 4）关于页： 用来介绍项目的搭建编写过程，还有使用的技术栈啊之类的，然后留下个人的联系方式，Nice； 5）留言页： 因为是个人的博客，所以我并不想要限制看官们留言的权利，我希望他们能自己能定义用于显示的用户名，但是需要填写一个Email，不然搞得我不能回复，那搞个啥…当然也可以不留Email，也就是不希望得到回复呗（那可能有些留言会让我难受死吧..思考…）… 后台需求分析：最初的思考是这样的： 后来一想，文章置顶这个都给忘了…然后发现其实有一个很关键的问题就是Markdown的文章应该怎样保存？一开始还是想要保存为.md文件保存在服务器的硬盘上的，但想想直接保存在数据库里也不错，省的麻烦，而且我很明确一点的是：我并不会直接在博客上写Markdown，因为有许许多多成熟的产品能让我写的舒心的多，我没必要去搞这么麻烦复杂繁琐，而且不一定好，所以我只需要用博客来展示我写的Markdown格式的博文就好了，Nice啊…又成功骗自己少写了好多代码hhhhh（没有啦..需求就这样的嘛…） 顺着这样的思路，我通常写文都是先在简书上写好的，并且简书有一个特点是所有的图片，不管是已经发布的文章还是没有发布的私人文章，都能通过地址取得，可以利用这一点让简书当个图床，诶又少弄了一部分代码，然后分析分析着就把需求搞成下面这样了： 1）博文管理： 这个比较常规，就不说了； 2）网站数据统计： 作为网站的拥有者和设计者，我当然希望能希望知道这些数据了，然后单独作为拥有者来说，最好再分为日访问量/月访问量/总访问量这样子显示出来，再搞搞样式，简直不要太爽； 3）缓存管理： 图片就没缓存了，因为保存文章内容我需要保存md源码，所以可能需要在Redis里缓存最近常访问的文章的md转HTML后渲染好的HTML源码； 4）系统设置： 网站标题可以改呀，然后导航栏的名字也可以弄弄呀，其实这个也可以不用去搞，只是以防有时候心情不好给一整捣鼓可能心情就好了，hhhhh….； 5）留言管理： 有一些流氓留言可以删掉，最近学习到的比较好的方法是让该条数据的状态为置为0，而不是直接删除该条数据，这个设计数据库的时候就需要多设计一个字段，也可以通过用户留下的Email地址进行回复，最好搞一个自动通知，完美； 表结构设计通过需求分析，然后严格按照《阿里巴巴Java开发手册》（下面所说的规范均来自于此）反复分析了很多遍，最终确定了如下的几张表： 然后来具体说一下各个表： 1）日志表（sys_log）： CREATE TABLE `sys_log` ( `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键', `ip` varchar(20) NOT NULL DEFAULT '' COMMENT '操作地址的IP', `create_by` datetime NOT NULL COMMENT '操作时间', `remark` varchar(255) NOT NULL DEFAULT '' COMMENT '操作内容', `operate_url` varchar(50) NOT NULL DEFAULT '' COMMENT '操作的访问地址', `operate_by` varchar(20) DEFAULT '' COMMENT '操作的浏览器', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这张表就是拿来保存日志，用来记录每一个用户访问了哪些地址，使用了什么样的浏览器，操作内容可以作为一个保留字段，如果以后想要监控用户行为，那也是可以的~ 这里首先遵守的规范是（下面雷同则不再重复赘述）： 第五章第一节第2条（强制）——表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑； 第五章第一节第3条（强制）——表名不使用复数名词； 第五章第一节第10条（推荐）——表的命名最好加上“业务名称_表的作用” 想要拿出来跟大家讨论的一则规范是： 第五章第9条（强制）——表必备三个字段：id（unsigned bigint自增），gmt_create（date_time），gmt_modified（date_time） 像如上设计的日志表，它插入进去了就不会再更新了，而且对于我这个系统也很大概率不会有趣操作这个表的可能，那么对于这样不会更新和操作的表，gmt_modified这个字段还有必要存在吗？ emmm..事实上我问了孤尽大大本人，他回答的简洁有力：“要的，以备不时之需；”然而原谅我还是没有听话，hhhhh，另外一点我想说的是，我忘了是在哪里看到的了，但是像gmt_create这样的字段最好设计成create_by这样，字段本身就是很好的注释，摁，就喜欢这样满满的细节… 2）浏览量表（sys_view）： CREATE TABLE `sys_view` ( `id` bigint(40) NOT NULL AUTO_INCREMENT, `ip` varchar(20) NOT NULL COMMENT '访问IP', `create_by` datetime NOT NULL COMMENT '访问时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这张表用于保存每一次访问主页的记录，我想的是每访问主页就记录增加一条数据，简单同时也增加访问量嘛，hhhhh，也是不会更新的一张表，所以没modifield_by字段； 3）留言/评论表（tbl_message） CREATE TABLE `tbl_message` ( `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键', `content` varchar(200) NOT NULL DEFAULT '' COMMENT '留言/评论内容', `create_by` datetime NOT NULL COMMENT '创建日期', `email` varchar(20) NOT NULL DEFAULT '' COMMENT '邮箱，用于回复消息', `name` varchar(20) NOT NULL DEFAULT '' COMMENT '用户自己定义的名称', `ip` varchar(20) NOT NULL DEFAULT '' COMMENT '留言/评论IP', `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1为有效，0为无效', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='因为message分为两种，一种是留言，一种是评论，这里搞成一张表是因为它们几乎是拥有相同的字段，我觉得没必要分成两张表来进行维护'; 这是评论/留言表，因为考虑到留言和评论有几乎相同的字段，所以给弄成了一张表，这张表同样的不需要更新没有modifield_by字段，这里遵守的规范是： 第五章第一节第1条（强制）——表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1表示是，0表示否） 第五章第一节第15条（参考）——设置合适的字段存储长度，不但可以节约数据库表控件和索引存储，更重要的事能够提升检索速度； 4）分类信息表（tbl_sort_info）： CREATE TABLE `tbl_sort_info` ( `id` bigint(40) NOT NULL AUTO_INCREMENT, `name` varchar(20) NOT NULL COMMENT '分类名称', `number` tinyint(10) NOT NULL DEFAULT '0' COMMENT '该分类下的文章数量', `create_by` datetime NOT NULL COMMENT '分类创建时间', `modified_by` datetime NOT NULL COMMENT '分类修改时间', `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，为0无效', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这张表是文章的分类，一开始都忘记设计了…. 5）文章信息表（tbl_article_info）： CREATE TABLE `tbl_article_info` ( `id` bigint(40) NOT NULL AUTO_INCREMENT COMMENT '主键', `title` varchar(50) NOT NULL DEFAULT '' COMMENT '文章标题', `summary` varchar(300) NOT NULL DEFAULT '' COMMENT '文章简介，默认100个汉字以内', `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '文章是否置顶，0为否，1为是', `traffic` int(10) NOT NULL DEFAULT '0' COMMENT '文章访问量', `create_by` datetime NOT NULL COMMENT '创建时间', `modified_by` datetime NOT NULL COMMENT '修改日期', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这是文章信息表，都是一些基础常用的字段就不再多做解释了 6）文章内容表（tbl_article_content）： CREATE TABLE `tbl_article_content` ( `id` bigint(40) NOT NULL AUTO_INCREMENT, `content` text NOT NULL, `article_id` bigint(40) NOT NULL COMMENT '对应文章ID', `create_by` datetime NOT NULL COMMENT '创建时间', `modifield_by` datetime NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这是文章内容表，我们并没有直接把内容字段设计在文章信息表里，而是单独建了一个表用来保存文章的内容，然后使用主键来关联，我们这里遵守的规范是： 第五章第一节第8条（强制）——varchar是可变长字符串，不预先分配存储空间，长度不要超过5000个字符。如果存储长度大于此值，则应定义字段类型为text，独立出来一张表，用主键来对应，避免影响其他字段的索引效率； 第五章第三节第6条（强制）——不得使用外键与级联，一切外键概念必须在应用层解决； 我试过我现在最长的一篇文章长度大概能存储8W长度的varchar，所以我就给单独建一个表分离出来了，使用text类型来保存文章的md源码 7）文章评论表（tbl_article_message）： CREATE TABLE `tbl_article_message` ( `id` bigint(40) NOT NULL AUTO_INCREMENT, `article_id` bigint(40) NOT NULL COMMENT '文章ID', `message_id` bigint(40) NOT NULL COMMENT '对应的留言ID', `create_by` datetime NOT NULL COMMENT '创建时间', `is_effective` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，默认为1有效，置0无效', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这其实是一个关联表，关联了文章和tbl_message表，用于专门存储某个文章下的评论信息 8）文章分类表（tbl_article_sort）： CREATE TABLE `tbl_article_sort` ( `id` bigint(40) NOT NULL AUTO_INCREMENT, `sort_id` bigint(40) NOT NULL COMMENT '分类id', `article_id` bigint(40) NOT NULL COMMENT '文章id', `create_by` datetime NOT NULL COMMENT '创建时间', `modified_by` datetime NOT NULL COMMENT '更新时间', `is_effective` tinyint(1) DEFAULT '1' COMMENT '表示当前数据是否有效，默认为1有效，0则无效', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 同样是一张关联表，连接了文章和分类，并且同一篇文章能属于多个分类； 9）文章题图表（tbl_article_picture）： CREATE TABLE `tbl_article_picture` ( `id` bigint(40) NOT NULL AUTO_INCREMENT, `article_id` bigint(40) NOT NULL COMMENT '对应文章id', `picture_url` varchar(100) NOT NULL DEFAULT '' COMMENT '图片url', `create_by` datetime NOT NULL COMMENT '创建时间', `modified_by` datetime NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='这张表用来保存题图url，每一篇文章都应该有题图'; 这个是保存每一篇文章的题图，每一篇文章都因该有题图； 原型设计事实上，我是直接先去找的原型，去参考了一下大概我需要做成什么样子… 前端原型参考在这里先给大家推荐一个设计网站吧，找素材啊之类的还挺方便的： 站酷：http://www.zcool.com.cn/ 所以我在里面找到了我想要的前端原型，大概就像这个样子： 1）首页： 2）博客页： 3）博文详情页： 4）博文列表页： 不能再酷了.. 后端原型参考 emmmm…大概就像这样了吧，具体的样式可以到时候再调… 总体是酷的就行！ 项目搭建先来介绍一下这次想要使用的一些技术： SpringBoot / Spring 来编写后台 Vue 来写页面，准备抛弃一下JSP，虽然现在Vue还啥都不懂，学呗 MyBatis 用于ORM，喜欢这玩意儿的逆向工程 RESTful API / JSON 交互 Redis 可能还会使用这个来缓存一下md转换之后的html源码 SpringBoot 工程搭建SpringBoot 项目搭建过程就不再赘述了，不熟悉的童鞋戳这边：https://www.jianshu.com/p/70963ab49f8c，这里就简单给一下配置信息： 后台肯定是需要加安全验证的，要简单点我可以搞一个拦截器来简单弄弄，也可以用现有的安全框架，这里暂时就不加入这方面的东西了，把基本的弄进来就OK，然后它默认加入的东西不能够支持我们的业务，所以还需要手动添加进一些包： 4.0.0 cn.wmyskxz blog 0.0.1-SNAPSHOT jar blog Demo project for Spring Boot org.springframework.boot spring-boot-starter-parent 2.0.2.RELEASE UTF-8 UTF-8 1.8 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.2 org.mybatis.generator mybatis-generator-core 1.3.6 org.springframework.boot spring-boot-starter-test test mysql mysql-connector-java runtime org.springframework.boot spring-boot-devtools true org.springframework.boot spring-boot-maven-plugin 热部署还是要的呀，然后再在【resrouces】下新建一个【banner.txt】文件，修改一下SpringBoot启动的提示信息： __ __ __ /\\ \\ __/\\ \\ /\\ \\ \\ \\ \\/\\ \\ \\ \\ ___ ___ __ __ ____\\ \\ \\/&#39;\\ __ _ ____ \\ \\ \\ \\ \\ \\ \\ /&#39; __` __`\\ /\\ \\/\\ \\ /&#39;,__\\\\ \\ , &lt; /\\ \\/&#39;\\/\\_ ,`\\ \\ \\ \\_/ \\_\\ \\/\\ \\/\\ \\/\\ \\\\ \\ \\_\\ \\ /\\__, `\\\\ \\ \\\\`\\ \\/&gt; &lt;/\\/_/ /_ \\ `\\___x___/\\ \\_\\ \\_\\ \\_\\\\/`____ \\\\/\\____/ \\ \\_\\ \\_\\/\\_/\\_\\ /\\____\\ &#39;\\/__//__/ \\/_/\\/_/\\/_/ `/___/&gt; \\\\/___/ \\/_/\\/_/\\//\\/_/ \\/____/ /\\___/ \\/__/ 弄弄结构，最后整个项目的目录看起来大概是这个样子： 下面对这些目录进行一些简要的说明： controller：控制器 dao：实际上这个包可以改名叫mapper，因为里面放的应该是MyBatis逆向工程自动生成之后的mapper类，还是叫dao吧，传统… entity：实体类，还会有一些MyBatis生成的example generator：MyBatis逆向工程生成类 interceptor：SpringBoot 拦截器 service：Service层，里面还有一层impl目录 util：一些工具类可以放在里面 mapper：用于存放MyBatis逆向工程生成的.xml映射文件 static：这个目录存放一些静态文件，简单了解了一下Vue的前后端分离，前台文件以后也需要放在这个目录下面 然后我使用application.yml文件代替了application.properties，这个东西结构清晰一点儿，反正用哪个都无所谓，配置好就OK了： spring: datasource: url: jdbc:mysql://127.0.0.1:3306/blog?characterEncoding=UTF-8 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver #Druid连接池配置相关 druid: # 初始大小，最大，最小 initial-size: 5 min-idle: 5 max-active: 20 # 配置获取连接等待超时的时间 max-wait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 不需要检测数据库，不要整这么复杂，不过倒是需要给数据库密码加个密，明文的配置实在不安全，但是现在先不搞了； MyBatis 逆向工程使用过MyBatis逆向工程的朋友都应该知道，这东西有个BUG，就是重复生成的时候它并不会覆盖掉原来的内容（特指xml映射文件），而是会在后面重新生成一遍，这有点儿头疼，所以首先需要解决这个问题： 首先在【util】包下新建一个【OverIsMergeablePlugin】工具类： package cn.wmyskxz.blog.util; import org.mybatis.generator.api.GeneratedXmlFile; import org.mybatis.generator.api.IntrospectedTable; import org.mybatis.generator.api.PluginAdapter; import java.lang.reflect.Field; import java.util.List; /** * 避免MyBatiis重复生成的工具类 * * @author:wmyskxz * @create:2018-06-14-上午 9:50 */ public class OverIsMergeablePlugin extends PluginAdapter { @Override public boolean validate(List&lt;String> warnings) { return true; } @Override public boolean sqlMapGenerated(GeneratedXmlFile sqlMap, IntrospectedTable introspectedTable) { try { Field field = sqlMap.getClass().getDeclaredField(\"isMergeable\"); field.setAccessible(true); field.setBoolean(sqlMap, false); } catch (Exception e) { e.printStackTrace(); } return true; } } 然后在【generatorConfig.xml】中配置上该工具类： &lt;plugin type=\"cn.wmyskxz.blog.util.OverIsMergeablePlugin\"/> 好的这样就搞定了，我们就正式开始我们的逆向工程： 1）编写generatorConfig.xml逆向工程配置文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"> &lt;generatorConfiguration> &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"> &lt;!--避免生成重复代码的插件--> &lt;plugin type=\"cn.wmyskxz.blog.util.OverIsMergeablePlugin\"/> &lt;!--是否在代码中显示注释--> &lt;commentGenerator> &lt;property name=\"suppressDate\" value=\"true\"/> &lt;property name=\"suppressAllComments\" value=\"true\"/> &lt;/commentGenerator> &lt;!--数据库链接地址账号密码--> &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1:3306/blog?characterEncoding=UTF-8\" userId=\"root\" password=\"123456\"> &lt;/jdbcConnection> &lt;!--生成pojo类存放位置--> &lt;javaModelGenerator targetPackage=\"cn.wmyskxz.blog.entity\" targetProject=\"src/main/java\"> &lt;property name=\"enableSubPackages\" value=\"true\"/> &lt;property name=\"trimStrings\" value=\"true\"/> &lt;/javaModelGenerator> &lt;!--生成xml映射文件存放位置--> &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"> &lt;property name=\"enableSubPackages\" value=\"true\"/> &lt;/sqlMapGenerator> &lt;!--生成mapper类存放位置--> &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.wmyskxz.blog.dao\" targetProject=\"src/main/java\"> &lt;property name=\"enableSubPackages\" value=\"true\"/> &lt;/javaClientGenerator> &lt;!--生成对应表及类名--> &lt;table tableName=\"sys_log\" domainObjectName=\"SysLog\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;!--使用自增长键--> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;!--使用数据库中实际的字段名作为生成的实体类的属性--> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"sys_view\" domainObjectName=\"SysView\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"tbl_article_content\" domainObjectName=\"ArticleContent\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"tbl_article_info\" domainObjectName=\"ArticleInfo\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"tbl_article_message\" domainObjectName=\"ArticleMessage\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"tbl_message\" domainObjectName=\"Message\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"tbl_sort_info\" domainObjectName=\"SortInfo\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;table tableName=\"tbl_article_sort\" domainObjectName=\"ArticleSort\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"> &lt;property name=\"my.isgen.usekeys\" value=\"true\"/> &lt;property name=\"useActualColumnNames\" value=\"true\"/> &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/> &lt;/table> &lt;/context> &lt;/generatorConfiguration> 注意表名/生成目标目录之类的有没有写错，表名最好就直接去复制数据库中的名称； 2）编写逆向工程生成类： package cn.wmyskxz.blog.generator; import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.exception.XMLParserException; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.IOException; import java.io.InputStream; import java.sql.SQLException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; /** * MyBatis逆向工程生成类 * * @author:wmyskxz * @create:2018-06-14-上午 10:10 */ public class MybatisGenerator { public static void main(String[] args) throws Exception { String today = \"2018-6-14\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date now = sdf.parse(today); Date d = new Date(); if (d.getTime() > now.getTime() + 1000 * 60 * 60 * 24) { System.err.println(\"——————未成成功运行——————\"); System.err.println(\"——————未成成功运行——————\"); System.err.println(\"本程序具有破坏作用，应该只运行一次，如果必须要再运行，需要修改today变量为今天，如:\" + sdf.format(new Date())); return; } if (false) return; List&lt;String> warnings = new ArrayList&lt;String>(); boolean overwrite = true; InputStream is = MybatisGenerator.class.getClassLoader().getResource(\"generatorConfig.xml\").openStream(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(is); is.close(); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); System.out.println(\"生成代码成功，只能执行一次，以后执行会覆盖掉mapper,pojo,xml 等文件上做的修改\"); } } 这个是参考自how2j.cn的逆向工程，这个可以说是很成熟的模块了，写的很棒，考虑了安全方面的一些东西，链接在这里：http://how2j.cn/k/tmall_ssm/tmall_ssm-1547/1547.html 3）点击运行： 控制台看到成功的信息之后，就能看到项目中自动多了一堆文件了： RESTful API 设计为了实现前后端分离，好的RESTful API是离不开的，正好前一段时间学习了这方面的知识，所以决定先来设计一套RESTful API，之前学习的文章链接在这里：https://www.jianshu.com/p/91600da4df95 1）引入Swagger2来构造RESTful API： 既然想弄一下前后端分离，那就彻底一点儿，写后台完全不管前台，前后台的交互靠一套RESTful API和JSON数据来弄，所以需要一个文档来瞅瞅，首先在pox.xml添加相关依赖： &lt;!--Swagger2支持--> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>2.2.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>2.2.2&lt;/version> &lt;/dependency> 2）创建Swagger2配置类： 在SpringBoot启动类的同级目录下创建Swagger2的配置类【Swagger2】： /** * Swagger2 配置类 * * @author:wmyskxz * @create:2018-06-14-上午 10:40 */ @Configuration @EnableSwagger2 public class Swagger2 { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"cn.wmyskxz.blog\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"Wmyskxz个人博客RESTful APIs\") .description(\"原文地址链接：http://blog.didispace.com/springbootswagger2/\") .termsOfServiceUrl(\"http://blog.didispace.com/\") .contact(\"@我没有三颗心脏\") .version(\"1.0\") .build(); } } 这样，就可以在我们启动项目之后，访问http://localhost:8080/swagger-ui.html地址来查看当前项目中的RESTful风格的API： 3）设计RESTful API： 好的，捣鼓了半天，终于有了一些雏形： 但是这也只是设计了API，具体都还没有实现，这些就在写后台的时候来完善了，具体的这些内容怎么显示出来的，我给一个【SortController】的参考类： /** * 分类信息控制器 * * @author:wmyskxz * @create:2018-06-14-下午 13:25 */ @RestController @RequestMapping(\"/api/sort\") public class SortController { /** * 获取所有分类信息 * * @return */ @ApiOperation(\"获取所有分类信息\") @GetMapping(\"/list\") public List&lt;SortInfo> listAllSortInfo() { return null; } /** * 通过id获取一条分类信息 * * @param id * @return */ @ApiOperation(\"获取某一条分类信息\") @ApiImplicitParam(name = \"id\", value = \"分类ID\", required = true, dataType = \"Long\") @GetMapping(\"/{id}\") public SortInfo getSortInfoById(@PathVariable Long id) { return null; } /** * 增加一条分类信息数据 * * @return */ @ApiOperation(\"增加分类信息\") @ApiImplicitParam(name = \"name\", value = \"分类名称\", required = true, dataType = \"String\") @PostMapping(\"\") public String addSortInfo() { return null; } /** * 更新/编辑一条数据 * * @param id * @return */ @ApiOperation(\"更新/编辑分类信息\") @ApiImplicitParam(name = \"id\", value = \"分类ID\", required = true, dataType = \"Long\") @PutMapping(\"/{id}\") public String updateSortInfo(@PathVariable Long id) { return null; } /** * 根据ID删除分类信息 * * @param id * @return */ @ApiOperation(\"删除分类信息\") @ApiImplicitParam(name = \"id\", value = \"分类ID\", required = true, dataType = \"Long\") @DeleteMapping(\"/{id}\") public String deleteSortInfo(@PathVariable Long id) { return null; } } 简单介绍一下这些Swagger2的注解吧： @ApiOperation：用于给API设置提示信息，就上图中右边显示的那些，默认不写的情况下是value属性，还可以多写一个notes属性，用于详细的描述API，这里就不需要了，都还比较简单； @ApiImplicaitParam：用于说明API的参数信息，加了s的注解同理，写了这个之后呢，我们就可以利用Swagger2给我们的信息页面进行测试了，当然这里没有具体实现，也可以来看一下（下图）； 这里没有具体实现所以就不足以完成测试，等到后台编写的时候再进行测试吧… 总结至此呢，我们项目所需要的准备就差不多完成了，想要去做一个东西必须要清楚的知道要的是一个什么东西，这样才能更加好的完成我们的产品，这也是我喜欢和坚信的事情：方向永远比努力重要！（强行有联系..hhhh） 另外一个问题： 我在想文章信息和内容分成了两个表的问题，这样的设计我觉得是没有问题的，但是作为前端并不关心这些数据库的设计，他只要能拿到对象就可以了，在设计 API 的时候，就发现获得一篇文章，需要从三个表（文章信息/文章内容/评论）去获取信息并封装返回前端，这就需要自己在后台另外写一个实体类去封装这些信息，这无疑增加了我们的代码工作量，有没有什么好的方法解决呢？ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"大三小白初次接触封闭式开发总结","slug":"大三小白初次接触封闭式开发总结","date":"2018-06-10T22:34:00.000Z","updated":"2020-12-09T04:49:18.902Z","comments":true,"path":"2018/06/11/da-san-xiao-bai-chu-ci-jie-hong-feng-bi-shi-kai-fa-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/06/11/da-san-xiao-bai-chu-ci-jie-hong-feng-bi-shi-kai-fa-zong-jie/","excerpt":"前言：一晃眼都差不多11天没有更新了，差一点都以为自己松懈没有努力了，hhh…这几天去跟着一个项目组在酒店封闭式开发，经过了四天，今天算是回归学校实习的队伍中（时间冲突找了个人先替我去了学校安排的实习单位..），时间虽短，但是学习到了很多东西这里做一下简短的总结","text":"前言：一晃眼都差不多11天没有更新了，差一点都以为自己松懈没有努力了，hhh…这几天去跟着一个项目组在酒店封闭式开发，经过了四天，今天算是回归学校实习的队伍中（时间冲突找了个人先替我去了学校安排的实习单位..），时间虽短，但是学习到了很多东西这里做一下简短的总结 背景学院大三的期末似乎总是这样，会在6月初的时候不是自己出去找到实习，不然就会要求你去到学校安排的实习中去（自己选择实习的方向），所以在我选择了Java Web方向，第二天就准备去实习的时候，突然接触到了一个急需上线的项目（很急），他们是从北京来的公司在这儿的酒店封闭式开发，需要我们工作室的人去跟进，我觉得机会难得； 实习 &amp; 封闭式开发一方面是学校安排的实习，一方面是从未接触过的封闭式开发，我毫不犹豫的选择了后者，因为在我看来，学校安排的实习无非是学校花钱请的培训老师，学一些在学校的学习中不会接触但是自己已经学习过的框架方面的知识，而后者则会让我学习到一些更加实际更加真实的经验和经历，面对这样的选择，我似乎没有怎么犹豫； 跟着住进酒店当我背着我的电脑包住进酒店，连上团队的SVN下载好源码的那一刻，说实话让我兴奋得不行，虽然用的是我自己没有接触和学习过的 Hibernate 框架那一套，存图片用的同样是我不熟悉的 Mango ，但我看着源码，心里有一种说不出来的开心； 技术自信一开始让我感受最深的东西，或者说感受最深的词，就是 “技术自信”，我发现从我小白的立场去融入一个陌生的团队，实在是有些不容易，虽然一开始并没有让我去写一些什么东西，只是让我从最简单的帮忙调一下前端样式开始，但是跟陌生人打交道，跟陌生团队交流这些无一不是自己陌生的东西，感觉就我一个人就被扔那儿了… 最开始我都不敢去改不敢去写一些东西，因为怕错！，和我自己独立开发时的状态完全不同，最开始我没有一丁点的自信，一方面是面对陌生的团队，一方面是框架的不熟悉，所以我找项目负责人决定要些代码写写，可是一开始得到的回答大概都是：“这个业务逻辑太复杂了你不会”、“那个太繁琐了不敢给你写”，我的任务一开始就是打辅助，我很明确这一点，所以我就开始一边默默滑水一边尽量不给他们找麻烦的给整个系统灌数据测BUG，我变成了测试人员…测试我还不怎么会… 帮忙搞的东西今天算是回到学校实习大队伍，但是回来的第一天老师就请假，负责老师就开始叫组长出去商量搞什么活动玩儿什么…我也是一脸懵；虽然一直都是打辅助，搞一些简单的东西，但还是搞过一些东西的，这里总结一下： 帮忙调整了一下后台页面表中列的宽度，使它更加友善（之前一些诸如序号啊编码啊之类的字段占很长，就把后面的列给挤了） 给数据库搞了17W左右的数据，帮忙测试了一下导入的速度，检索的速度，系统是直接使用 Hibernate 操作数据库的，我查到这玩意儿瓶颈挺大，想给自己优化优化的，后来没成…. 有一些代码注释没对齐之类的我给搞好看了，有一些 For 循环里新建冗余类的我给搞出来了… 前端方面修复了一下关闭按钮没关联上不起作用的问题，修复了分页中可选每页显示数据不起作用的问题，给导入数据的每一个页面增加了一个 loading 等待提示（之前导入稍微多一点儿还以为系统卡了，没任何提示） 从 Excel 导入的时候增加了对空格的处理，让导入的数据更加规范化（因为不能控制用户的行为…） 重构了一下数据库，因为之前的数据库有一类库全是用的编码做主键，存在不同账户添加相同编码覆盖的问题（原来他们也会犯这样的错…莫名喜闻乐见..hhhh），我给把这一类的代码和页面都微调了一下，隐藏了一个id属性做主键； 总结emmm..回去瞄了一眼儿这些天搞得东西，确实好low，但这个项目过去的时候其实就只差一个模块没有写了，摁摁，我是这样安慰自己的…hhhh….虽然这些天很短暂，但还是学到了好多东西，很感恩那个项目负责人晚上还把我拉住说了我一顿，虽然明面上是给我建议，但其实就是在讲我是一个辣鸡，hhh….还是做一下简单的总结吧： 不要总是“我以为….”，很多不清楚不明确的地方就该去问，比如我在调整表格宽度的时候以为某个字段不会很长所以调得差不多不长不短，后来提交代码上去就被叫过去给说一顿； 笨点就笨点，但一定不要出错！就比如他们分页栏右边给搞了一个可以设置每页显示多少数据的这么一个东西，我测试了几下没有用，发现代码上是在基类上写死了每页显示20行数据，我要去把这个改掉，第一反应就是找个快捷键把所有的相同语句给改掉，但是前辈说最好别这样，你最好把设置在基类的值给注释掉看哪儿报错再去改，笨点就笨点，但一定要保证正确性； 思路很重要，想好再开始写代码，这也是我一直坚信的道理，任何事方向比努力一定更重要； 思维一定不能局限，a方法可能行不通，但是还有bcde…z等其他方法可以选择嘛； 不要问一些低级的问题，先尝试自己解决！； 最后很重要的一点是：原来企业级的代码没有和我想象中的差距那么大嘛！不过逻辑和工程量上确实天差地别，好的东西体现出来的不仅仅是技术，更多的是细节！ 还有很长的路要走能看到源码并且共同维护代码是我最开心的事，发现原来线上代码和自己写的代码也没有想象之中那样的天差地别，甚至觉得自己写得代码要规范一些（悄悄讲..他们所有字段全是中文拼音的缩写…虽然看多了源码还挺容易理解和方便的）..😂😂 总之还有很多需要学习的地方，还有很长的路要走，要积累足够的经验，要形成自己独有的技术自信才能走得更远..加油呗！ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Redis【入门】就这一篇!","slug":"Redis【入门】就这一篇","date":"2018-05-30T23:22:00.000Z","updated":"2020-12-09T05:10:20.769Z","comments":true,"path":"2018/05/31/redis-ru-men-jiu-zhe-yi-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/","excerpt":"","text":"Redis 概述在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。 NoSQL 技术为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。 Redis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。 Redis 在 Java Web 中的应用Redis 在 Java Web 主要有两个应用场景： 存储 缓存 用的数据； 需要高速读/写的场合使用它快速读/写； 缓存在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 1:9 到 3:7，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会去磁盘把对应的数据索引取回来，这是一个相对较慢的过程。 如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们只是使用 Redis 存储一些常用和主要的数据，比如用户登录的信息等。 一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑： 业务数据常用吗？命中率如何？如果命中率很低，就没有必要写入缓存； 该业务数据是读操作多，还是写操作多？如果写操作多，频繁需要写入数据库，也没有必要使用缓存； 业务数据大小如何？如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要； 在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！使用 Redis 作为缓存的读取逻辑如下图所示： 从上图我们可以知道以下两点： 当第一次读取数据的时候，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中； 当第二次以及以后需要读取数据时，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。 从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。 分析了读操作的逻辑，下面我们来看看写操作的流程： 从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。 关于使用内存存储数据，我知道谷歌好像就是把所有互联网的数据都存储在内存条的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌… 高速读/写的场合在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有成千上万的请求到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机，而这样的场合都是不允许的！ 所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看一次请求操作的流程图： 我们来进一步阐述这个过程： 当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足高速响应的需求； 但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去判断该高速读/写的业务是否结束，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式一次性写入数据库，从而完成持久化的工作。 Redis 的安装访问地址：https://github.com/ServiceStack/redis-windows/tree/master/downloads 把 Redis 下载下来后找到一个合适的地方解压，就能得到如下图所示的目录（这里空格被替换成了%20…）： 为了方便启动，我们在该目录下新建一个 startup.cmd 的文件，然后将以下内容写入文件： redis-server redis.windows.conf这个命令其实就是在调用 redis-server.exe 命令来读取 redis.window.conf 的内容，我们双击刚才创建好的 startup.cmd 文件，就能成功的看到 Redis 启动： 上图的提示信息告诉了我们：① Redis 当前的版本为 3.0.503；② Redis 运行在 6379 端口；③ Redis 进程的 PID 为 14748；④ 64 位。 我们可以打开同一个文件夹下的 redis-cli.exe 文件，这是 Redis 自带的一个客户端工具，它可以用来连接到我们当前的 Redis 服务器，我们做以下测试： 如此，我们便在 Windows 的环境下安装好了 Redis。 在 Java 中使用 Redis第一步：添加 Jedis 依赖想要在 Java 中使用 Redis 缓存，需要添加相关的Jar包依赖，打开Maven仓库的网站：https://mvnrepository.com/ ，搜索Jedis： 把它导入工程中去就可以啦，下面我们来对Redis的写入性能做一下测试： @Test public void redisTester() { Jedis jedis = new Jedis(\"localhost\", 6379, 100000); int i = 0; try { long start = System.currentTimeMillis();// 开始毫秒数 while (true) { long end = System.currentTimeMillis(); if (end - start >= 1000) {// 当大于等于1000毫秒（相当于1秒）时，结束操作 break; } i++; jedis.set(\"test\" + i, i + \"\"); } } finally {// 关闭连接 jedis.close(); } // 打印1秒内对Redis的操作次数 System.out.println(\"redis每秒操作：\" + i + \"次\"); } -----------测试结果----------- redis每秒操作：10734次 据说 Redis 的性能能达到十万级别，我不敢相信我的台式机电脑只有十分之一不到的性能，虽然说这里不是流水线的操作，会造成一定的影响，但我还是不信邪，我查到了官方的性能测试方法： 首先在Redis根目录下召唤Cmd：具体方法是按住【Shift】点击右键 然后输入命令：【redis-benchmark -n 100000 -q】：来同时执行10万个请求测试性能 好吧，我同时在我的笔记本上测试了一下，结果更加惨淡…low啊low… 第二步：使用 Redis 连接池跟数据库连接池相同，Java Redis也同样提供了类redis.clients.jedis.JedisPool来管理我们的Reids连接池对象，并且我们可以使用redis.clients.jedis.JedisPoolConfig来对连接池进行配置，代码如下： JedisPoolConfig poolConfig = new JedisPoolConfig(); // 最大空闲数 poolConfig.setMaxIdle(50); // 最大连接数 poolConfig.setMaxTotal(100); // 最大等待毫秒数 poolConfig.setMaxWaitMillis(20000); // 使用配置创建连接池 JedisPool pool = new JedisPool(poolConfig, \"localhost\"); // 从连接池中获取单个连接 Jedis jedis = pool.getResource(); // 如果需要密码 //jedis.auth(\"password\"); Redis 只能支持六种数据类型（string/hash/list/set/zset/hyperloglog）的操作，但在 Java 中我们却通常以类对象为主，所以在需要 Redis 存储的五中数据类型与 Java 对象之间进行转换，如果自己编写一些工具类，比如一个角色对象的转换，还是比较容易的，但是涉及到许多对象的时候，这其中无论工作量还是工作难度都是很大的，所以总体来说，就操作对象而言，使用 Redis 还是挺难的，好在 Spring 对这些进行了封装和支持。 第三步：在 Spring 中使用 Redis上面说到了 Redis 无法操作对象的问题，无法在那些基础类型和 Java 对象之间方便的转换，但是在 Spring 中，这些问题都可以通过使用RedisTemplate得到解决！ 想要达到这样的效果，除了 Jedis 包以外还需要在 Spring 引入 spring-data-redis 包：https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis 这里把2.0.7最新版本标红的意思是：别老想着使用最新的Jar包，特别是涉及到框架的一些东西，笔者用实际的操作体验告诉你们，引入该版本的包是会导致Jar包冲突的（也就是莫名其妙的错误），我乖乖换回了1.7.2的版本，代码就通了…我们来看看怎么做吧： （1）第一步：使用Spring配置JedisPoolConfig对象 大部分的情况下，我们还是会用到连接池的，于是先用 Spring 配置一个 JedisPoolConfig 对象： &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"> &lt;!--最大空闲数--> &lt;property name=\"maxIdle\" value=\"50\"/> &lt;!--最大连接数--> &lt;property name=\"maxTotal\" value=\"100\"/> &lt;!--最大等待时间--> &lt;property name=\"maxWaitMillis\" value=\"20000\"/> &lt;/bean> （2）第二步：为连接池配置工厂模型 好了，我们现在配置好了连接池的相关属性，那么具体使用哪种工厂实现呢？在Spring Data Redis中有四种可供我们选择的工厂模型，它们分别是： JredisConnectionFactory JedisConnectionFactory LettuceConnectionFactory SrpConnectionFactory 我们这里就简单配置成JedisConnectionFactory： &lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"> &lt;!--Redis服务地址--> &lt;property name=\"hostName\" value=\"localhost\"/> &lt;!--端口号--> &lt;property name=\"port\" value=\"6379\"/> &lt;!--如果有密码则需要配置密码--> &lt;!--&lt;property name=\"password\" value=\"password\"/>--> &lt;!--连接池配置--> &lt;property name=\"poolConfig\" ref=\"poolConfig\"/> &lt;/bean> （3）第三步：配置RedisTemplate 普通的连接根本没有办法直接将对象直接存入 Redis 内存中，我们需要替代的方案：将对象序列化（可以简单的理解为继承Serializable接口）。我们可以把对象序列化之后存入Redis缓存中，然后在取出的时候又通过转换器，将序列化之后的对象反序列化回对象，这样就完成了我们的要求： RedisTemplate可以帮助我们完成这份工作，它会找到对应的序列化器去转换Redis的键值： &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\" p:connection-factory-ref=\"connectionFactory\"/> 笔者从《JavaEE互联网轻量级框架整合开发》中了解到，这一步需要配置单独的序列化器去支撑这一步的工作，但是自己在测试当中，发现只要我们的POJO类实现了Serializable接口，就不会出现问题…所以我直接省略掉了配置序列化器这一步… （4）第四步：编写测试 首先编写好支持我们测试的POJO类： /** * @author: @我没有三颗心脏 * @create: 2018-05-30-下午 22:31 */ public class Student implements Serializable{ private String name; private int age; /** * 给该类一个服务类用于测试 */ public void service() { System.out.println(\"学生名字为：\" + name); System.out.println(\"学生年龄为：\" + age); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 然后编写测试类： @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); RedisTemplate redisTemplate = context.getBean(RedisTemplate.class); Student student = new Student(); student.setName(\"我没有三颗心脏\"); student.setAge(21); redisTemplate.opsForValue().set(\"student_1\", student); Student student1 = (Student) redisTemplate.opsForValue().get(\"student_1\"); student1.service(); } 运行可以成功看到结果： 第四步：在 SpringBoot 中使用 Redis（1）在SpringBoot中添加Redis依赖： org.springframework.boot spring-boot-starter-data-redis （2）添加配置文件： 在SpringBoot中使用.properties或者.yml都可以，这里给出.properties的例子，因为自己的.yml文件看上去感觉乱糟糟的： # REDIS (RedisProperties) # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器地址 spring.redis.host=localhost # Redis服务器连接端口 spring.redis.port=6379 # Redis服务器连接密码（默认为空） spring.redis.password= # 连接池最大连接数（使用负值表示没有限制） spring.redis.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.pool.max-wait=-1 # 连接池中的最大空闲连接 spring.redis.pool.max-idle=8 # 连接池中的最小空闲连接 spring.redis.pool.min-idle=0 # 连接超时时间（毫秒） spring.redis.timeout=0 （3）测试访问： @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest() public class ApplicationTests { @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void test() throws Exception { // 保存字符串 stringRedisTemplate.opsForValue().set(\"aaa\", \"111\"); Assert.assertEquals(\"111\", stringRedisTemplate.opsForValue().get(\"aaa\")); } } 通过上面这段极为简单的测试案例演示了如何通过自动配置的StringRedisTemplate对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。原本是RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。 运行测试，如果一切成功则不会报错，如果我们没有拿到或者拿到的数不是我们想要的 “111” ，那么则会报错，这是使用Assert的好处（下面是我改成112之后运行报错的结果）： （4）存储对象： 这一步跟上面使用Spring一样，只需要将POJO类实现Serializable接口就可以了，我这里就贴一下测试代码： @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest() public class ApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test public void test() throws Exception { User user = new User(); user.setName(\"我没有三颗心脏\"); user.setAge(21); redisTemplate.opsForValue().set(\"user_1\", user); User user1 = (User) redisTemplate.opsForValue().get(\"user_1\"); System.out.println(user1.getName()); } } 仍然没有任何问题： 参考文章：1.https://www.cnblogs.com/ityouknow/p/5748830.html2.http://blog.didispace.com/springbootredis/ 在Redis中操作集合 引用文章：https://www.jianshu.com/p/29aaac3172b5 直接黏上两段简单的示例代码： 在Redis中操作List// list数据类型适合于消息队列的场景:比如12306并发量太高，而同一时间段内只能处理指定数量的数据！必须满足先进先出的原则，其余数据处于等待 @Test public void listPushResitTest() { // leftPush依次由右边添加 stringRedisTemplate.opsForList().rightPush(\"myList\", \"1\"); stringRedisTemplate.opsForList().rightPush(\"myList\", \"2\"); stringRedisTemplate.opsForList().rightPush(\"myList\", \"A\"); stringRedisTemplate.opsForList().rightPush(\"myList\", \"B\"); // leftPush依次由左边添加 stringRedisTemplate.opsForList().leftPush(\"myList\", \"0\"); } @Test public void listGetListResitTest() { // 查询类别所有元素 List&lt;String> listAll = stringRedisTemplate.opsForList().range(\"myList\", 0, -1); logger.info(\"list all {}\", listAll); // 查询前3个元素 List&lt;String> list = stringRedisTemplate.opsForList().range(\"myList\", 0, 3); logger.info(\"list limit {}\", list); } @Test public void listRemoveOneResitTest() { // 删除先进入的B元素 stringRedisTemplate.opsForList().remove(\"myList\", 1, \"B\"); } @Test public void listRemoveAllResitTest() { // 删除所有A元素 stringRedisTemplate.opsForList().remove(\"myList\", 0, \"A\"); } 在Redis中操作Hash@Test public void hashPutResitTest() { // map的key值相同，后添加的覆盖原有的 stringRedisTemplate.opsForHash().put(\"banks:12600000\", \"a\", \"b\"); } @Test public void hashGetEntiresResitTest() { // 获取map对象 Map&lt;Object, Object> map = stringRedisTemplate.opsForHash().entries(\"banks:12600000\"); logger.info(\"objects:{}\", map); } @Test public void hashGeDeleteResitTest() { // 根据map的key删除这个元素 stringRedisTemplate.opsForHash().delete(\"banks:12600000\", \"c\"); } @Test public void hashGetKeysResitTest() { // 获得map的key集合 Set&lt;Object> objects = stringRedisTemplate.opsForHash().keys(\"banks:12600000\"); logger.info(\"objects:{}\", objects); } @Test public void hashGetValueListResitTest() { // 获得map的value列表 List&lt;Object> objects = stringRedisTemplate.opsForHash().values(\"banks:12600000\"); logger.info(\"objects:{}\", objects); } @Test public void hashSize() { // 获取map对象大小 long size = stringRedisTemplate.opsForHash().size(\"banks:12600000\"); logger.info(\"size:{}\", size); } 总结在网上看到了关于MySQL的性能测试，读写操作大概就每秒1000以下的样子，而且这还和引擎相关，所以可以看出Redis确实能在性能方面帮助许多 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"}],"author":"我没有三颗心脏"},{"title":"使用RESTful风格开发Java Web","slug":"使用RESTful风格开发Java-Web","date":"2018-05-28T23:19:00.000Z","updated":"2020-12-09T04:58:47.009Z","comments":true,"path":"2018/05/29/shi-yong-restful-feng-ge-kai-fa-java-web/","link":"","permalink":"http://www.wmyskxz.com/2018/05/29/shi-yong-restful-feng-ge-kai-fa-java-web/","excerpt":"","text":"什么是RESTful风格？REST是REpresentational State Transfer的缩写（一般中文翻译为表述性状态转移），REST 是一种体系结构，而 HTTP 是一种包含了 REST 架构属性的协议，为了便于理解，我们把它的首字母拆分成不同的几个部分： 表述性（REpresentational）： REST 资源实际上可以用各种形式来进行表述，包括 XML、JSON 甚至 HTML——最适合资源使用者的任意形式； 状态（State）： 当使用 REST 的时候，我们更关注资源的状态而不是对资源采取的行为； 转义（Transfer）： REST 涉及到转移资源数据，它以某种表述性形式从一个应用转移到另一个应用。 简单地说，REST 就是将资源的状态以适合客户端或服务端的形式从服务端转移到客户端（或者反过来）。在 REST 中，资源通过 URL 进行识别和定位，然后通过行为(即 HTTP 方法)来定义 REST 来完成怎样的功能。 实例说明:在平时的 Web 开发中，method 常用的值是 GET 和 POST，但是实际上，HTTP 方法还有 PATCH、DELETE、PUT 等其他值，这些方法又通常会匹配为如下的 CRUD 动作: CRUD 动作 HTTP 方法 Create POST Read GET Update PUT 或 PATCH Delete DELETE 尽管通常来讲，HTTP 方法会映射为 CRUD 动作，但这并不是严格的限制，有时候 PUT 也可以用来创建新的资源，POST 也可以用来更新资源。实际上，POST 请求非幂等的特性(即同一个 URL 可以得到不同的结果)使其成一个非常灵活地方法，对于无法适应其他 HTTP 方法语义的操作，它都能够胜任。 在使用 RESTful 风格之前，我们如果想要增加一条商品数据通常是这样的: /addCategory?name=xxx 但是使用了 RESTful 风格之后就会变成: /category 这就变成了使用同一个 URL ，通过约定不同的 HTTP 方法来实施不同的业务，这就是 RESTful 风格所做的事情了，为了有一个更加直观的理解，引用一下来自how2j.cn的图: SpringBoot 中使用 RESTful 下面我使用 SpringBoot 结合文章：http://blog.didispace.com/springbootrestfulapi/ 来实例演示如何在 SpringBoot 中使用 RESTful 风格的编程并如何做单元测试 RESTful API 具体设计如下： User实体定义： public class User { private Long id; private String name; private Integer age; // 省略setter和getter } 实现对User对象的操作接口 @RestController @RequestMapping(value=\"/users\") // 通过这里配置使下面的映射都在/users下 public class UserController { // 创建线程安全的Map static Map&lt;Long, User> users = Collections.synchronizedMap(new HashMap&lt;Long, User>()); @RequestMapping(value=\"/\", method=RequestMethod.GET) public List&lt;User> getUserList() { // 处理\"/users/\"的GET请求，用来获取用户列表 // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 List&lt;User> r = new ArrayList&lt;User>(users.values()); return r; } @RequestMapping(value=\"/\", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) { // 处理\"/users/\"的POST请求，用来创建User // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 users.put(user.getId(), user); return \"success\"; } @RequestMapping(value=\"/{id}\", method=RequestMethod.GET) public User getUser(@PathVariable Long id) { // 处理\"/users/{id}\"的GET请求，用来获取url中id值的User信息 // url中的id可通过@PathVariable绑定到函数的参数中 return users.get(id); } @RequestMapping(value=\"/{id}\", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @ModelAttribute User user) { // 处理\"/users/{id}\"的PUT请求，用来更新User信息 User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return \"success\"; } @RequestMapping(value=\"/{id}\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) { // 处理\"/users/{id}\"的DELETE请求，用来删除User users.remove(id); return \"success\"; } } 编写测试单元 参考文章：http://tengj.top/2017/12/28/springboot12/#Controller单元测试看过这几篇文章之后觉得好棒，还有这么方便的测试方法，这些以前都没有接触过… 下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证，因为涉及一些包的导入，这里给出全部代码： package cn.wmyskxz.springboot; import cn.wmyskxz.springboot.controller.UserController; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.mock.web.MockServletContext; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import org.springframework.test.context.web.WebAppConfiguration; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.RequestBuilder; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import static org.hamcrest.Matchers.equalTo; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; /** * @author: @我没有三颗心脏 * @create: 2018-05-29-上午 8:39 */ @RunWith(SpringJUnit4ClassRunner.class) @SpringBootTest(classes = MockServletContext.class) @WebAppConfiguration public class ApplicationTests { private MockMvc mvc; @Before public void setUp() throws Exception { mvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); } @Test public void testUserController() throws Exception { // 测试UserController RequestBuilder request = null; // 1、get查一下user列表，应该为空 request = get(\"/users/\"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[]\"))); // 2、post提交一个user request = post(\"/users/\") .param(\"id\", \"1\") .param(\"name\", \"测试大师\") .param(\"age\", \"20\"); mvc.perform(request) .andExpect(content().string(equalTo(\"success\"))); // 3、get获取user列表，应该有刚才插入的数据 request = get(\"/users/\"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[{\\\"id\\\":1,\\\"name\\\":\\\"测试大师\\\",\\\"age\\\":20}]\"))); // 4、put修改id为1的user request = put(\"/users/1\") .param(\"name\", \"测试终极大师\") .param(\"age\", \"30\"); mvc.perform(request) .andExpect(content().string(equalTo(\"success\"))); // 5、get一个id为1的user request = get(\"/users/1\"); mvc.perform(request) .andExpect(content().string(equalTo(\"{\\\"id\\\":1,\\\"name\\\":\\\"测试终极大师\\\",\\\"age\\\":30}\"))); // 6、del删除id为1的user request = delete(\"/users/1\"); mvc.perform(request) .andExpect(content().string(equalTo(\"success\"))); // 7、get查一下user列表，应该为空 request = get(\"/users/\"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[]\"))); } } MockMvc实现了对HTTP请求的模拟，从示例的代码就能够看出MockMvc的简单用法，它能够直接使用网络的形式，转换到Controller的调用，这样使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。 需要注意的就是在MockMvc使用之前需要先用MockMvcBuilders构建MockMvc对象，如果对单元测试感兴趣的童鞋请戳上面的链接哦，这里就不细说了 测试信息运行测试类，控制台返回的信息如下： __ __ __ /\\ \\ __/\\ \\ /\\ \\ \\ \\ \\/\\ \\ \\ \\ ___ ___ __ __ ____\\ \\ \\/&#39;\\ __ _ ____ \\ \\ \\ \\ \\ \\ \\ /&#39; __` __`\\/\\ \\/\\ \\ /&#39;,__\\\\ \\ , &lt; /\\ \\/&#39;\\/\\_ ,`\\ \\ \\ \\_/ \\_\\ \\/\\ \\/\\ \\/\\ \\ \\ \\_\\ \\/\\__, `\\\\ \\ \\ \\`\\\\/&gt; &lt;/\\/_/ /_ \\ `\\___x___/\\ \\_\\ \\_\\ \\_\\/`____ \\/\\____/ \\ \\_\\ \\_\\/\\_/\\_\\ /\\____\\ &#39;\\/__//__/ \\/_/\\/_/\\/_/`/___/&gt; \\/___/ \\/_/\\/_/\\//\\/_/ \\/____/ /\\___/ \\/__/ 2018-05-29 09:28:18.730 INFO 5884 --- [ main] cn.wmyskxz.springboot.ApplicationTests : Starting ApplicationTests on SC-201803262103 with PID 5884 (started by Administrator in E:\\Java Projects\\springboot) 2018-05-29 09:28:18.735 INFO 5884 --- [ main] cn.wmyskxz.springboot.ApplicationTests : No active profile set, falling back to default profiles: default 2018-05-29 09:28:18.831 INFO 5884 --- [ main] o.s.w.c.s.GenericWebApplicationContext : Refreshing org.springframework.web.context.support.GenericWebApplicationContext@7c37508a: startup date [Tue May 29 09:28:18 CST 2018]; root of context hierarchy 2018-05-29 09:28:19.200 INFO 5884 --- [ main] cn.wmyskxz.springboot.ApplicationTests : Started ApplicationTests in 1.184 seconds (JVM running for 2.413) 2018-05-29 09:28:19.798 INFO 5884 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[PUT]}&quot; onto public java.lang.String cn.wmyskxz.springboot.controller.UserController.putUser(java.lang.Long,cn.wmyskxz.springboot.pojo.User) 2018-05-29 09:28:19.800 INFO 5884 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/users/],methods=[GET]}&quot; onto public java.util.List&lt;cn.wmyskxz.springboot.pojo.User&gt; cn.wmyskxz.springboot.controller.UserController.getUserList() 2018-05-29 09:28:19.800 INFO 5884 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/users/],methods=[POST]}&quot; onto public java.lang.String cn.wmyskxz.springboot.controller.UserController.postUser(cn.wmyskxz.springboot.pojo.User) 2018-05-29 09:28:19.801 INFO 5884 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[DELETE]}&quot; onto public java.lang.String cn.wmyskxz.springboot.controller.UserController.deleteUser(java.lang.Long) 2018-05-29 09:28:19.801 INFO 5884 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/users/{id}],methods=[GET]}&quot; onto public cn.wmyskxz.springboot.pojo.User cn.wmyskxz.springboot.controller.UserController.getUser(java.lang.Long) 2018-05-29 09:28:19.850 INFO 5884 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.test.web.servlet.setup.StubWebApplicationContext@42f8285e 2018-05-29 09:28:19.924 INFO 5884 --- [ main] o.s.mock.web.MockServletContext : Initializing Spring FrameworkServlet &#39;&#39; 2018-05-29 09:28:19.925 INFO 5884 --- [ main] o.s.t.web.servlet.TestDispatcherServlet : FrameworkServlet &#39;&#39;: initialization started 2018-05-29 09:28:19.926 INFO 5884 --- [ main] o.s.t.web.servlet.TestDispatcherServlet : FrameworkServlet &#39;&#39;: initialization completed in 1 ms通过控制台信息，我们得知通过 RESTful 风格能成功调用到正确的方法并且能获取到或者返回正确的参数，没有任何错误，则说明成功！ 如果你想要看到更多的细节信息，可以在每次调用 perform() 方法后再跟上一句 .andDo(MockMvcResultHandlers.print()) ，例如： // 1、get查一下user列表，应该为空 request = get(\"/users/\"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo(\"[]\"))) .andDo(MockMvcResultHandlers.print()); 就能看到详细的信息，就像下面这样： MockHttpServletRequest: HTTP Method = GET Request URI = /users/ Parameters = {} Headers = {} Body = &lt;no character encoding set&gt; Session Attrs = {} Handler: Type = cn.wmyskxz.springboot.controller.UserController Method = public java.util.List&lt;cn.wmyskxz.springboot.pojo.User&gt; cn.wmyskxz.springboot.controller.UserController.getUserList() Async: Async started = false Async result = null Resolved Exception: Type = null ModelAndView: View name = null View = null Model = null FlashMap: Attributes = null MockHttpServletResponse: Status = 200 Error message = null Headers = {Content-Type=[application/json;charset=UTF-8]} Content type = application/json;charset=UTF-8 Body = [] Forwarded URL = null Redirected URL = null Cookies = []总结我们仍然使用 @RequestMapping 注解，但不同的是，我们指定 method 属性来处理不同的 HTTP 方法，并且通过 @PathVariable 注解来将 HTTP 请求中的属性绑定到我们指定的形参上。 事实上，Spring 4.3 之后，为了更好的支持 RESTful 风格，增加了几个注解：@PutMapping、@GetMapping、@DeleteMapping、@PostMapping，从名字也能大概的看出，其实也就是将 method 属性的值与 @RequestMapping 进行了绑定而已，例如，我们对UserController中的deleteUser方法进行改造： -----------改造前----------- @RequestMapping(value=\"/{id}\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) { // 处理\"/users/{id}\"的DELETE请求，用来删除User users.remove(id); return \"success\"; } -----------改造后----------- @DeleteMapping(\"/{id}\") public String deleteUser(@PathVariable Long id) { // 处理\"/users/{id}\"的DELETE请求，用来删除User users.remove(id); return \"success\"; } 使用Swagger2构造RESTful API文档 参考文章：http://blog.didispace.com/springbootswagger2/ RESTful 风格为后台与前台的交互提供了简洁的接口API，并且有利于减少与其他团队的沟通成本，通常情况下，我们会创建一份RESTful API文档来记录所有的接口细节，但是这样做有以下的几个问题： 由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 Swagger2的出现就是为了解决上述的这些问题，并且能够轻松的整合到我们的SpringBoot中去，它既可以减少我们创建文档的工作量，同时说明内容又可以整合到代码之中去，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明，这太酷了，另外Swagger2页提供了强大的页面测试功能来调试每个RESTful API，具体效果如下： 让我们赶紧来看看吧： 第一步：添加Swagger2依赖：在 pom.xml 中加入Swagger2的依赖： &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>2.2.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>2.2.2&lt;/version> &lt;/dependency> 第二步：创建Swagger2配置类在SpringBoot启动类的同级目录下创建Swagger2的配置类 Swagger2： @Configuration @EnableSwagger2 public class Swagger2 { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"cn.wmyskxz.springboot\")) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"Spring Boot中使用Swagger2构建RESTful APIs\") .description(\"原文地址链接：http://blog.didispace.com/springbootswagger2/\") .termsOfServiceUrl(\"http://blog.didispace.com/\") .contact(\"@我没有三颗心脏\") .version(\"1.0\") .build(); } } 如上面的代码所示，通过 @Configuration 注解让Spring来加载该配置类，再通过 @EnableSwagger2 注解来启动Swagger2； 再通过 createRestApi 函数创建 Docket 的Bean之后，apiInfo() 用来创建该API的基本信息（这些基本信息会展现在文档页面中），select() 函数返回一个 ApiSelectorBuilder 实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有的Controller定义的API，并产生文档内容（除了被 @ApiIgnore 指定的请求） 第三步：添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。 @RestController @RequestMapping(value=\"/users\") // 通过这里配置使下面的映射都在/users下，可去除 public class UserController { static Map&lt;Long, User> users = Collections.synchronizedMap(new HashMap&lt;Long, User>()); @ApiOperation(value=\"获取用户列表\", notes=\"\") @RequestMapping(value={\"\"}, method=RequestMethod.GET) public List&lt;User> getUserList() { List&lt;User> r = new ArrayList&lt;User>(users.values()); return r; } @ApiOperation(value=\"创建用户\", notes=\"根据User对象创建用户\") @ApiImplicitParam(name = \"user\", value = \"用户详细实体user\", required = true, dataType = \"User\") @RequestMapping(value=\"\", method=RequestMethod.POST) public String postUser(@RequestBody User user) { users.put(user.getId(), user); return \"success\"; } @ApiOperation(value=\"获取用户详细信息\", notes=\"根据url的id来获取用户详细信息\") @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\") @RequestMapping(value=\"/{id}\", method=RequestMethod.GET) public User getUser(@PathVariable Long id) { return users.get(id); } @ApiOperation(value=\"更新用户详细信息\", notes=\"根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息\") @ApiImplicitParams({ @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\"), @ApiImplicitParam(name = \"user\", value = \"用户详细实体user\", required = true, dataType = \"User\") }) @RequestMapping(value=\"/{id}\", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) { User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return \"success\"; } @ApiOperation(value=\"删除用户\", notes=\"根据url的id来指定删除对象\") @ApiImplicitParam(name = \"id\", value = \"用户ID\", required = true, dataType = \"Long\") @RequestMapping(value=\"/{id}\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) { users.remove(id); return \"success\"; } } 完成上述代码添加之后，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html，就能看到前文展示的RESTful API的页面，我们可以点开具体的API请求，POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示： API文档访问与调试在上图请求的页面中，我们可以看到一个Value的输入框，并且在右边的Model Schema中有示例的User对象模板，我们点击右边黄色的区域Value框中就会自动填好示例的模板数据，我们可以稍微修改修改，然后点击下方的 “Try it out!” 按钮，即可完成一次请求调用，这太酷了。 总结对比之前用文档来记录RESTful API的方式，我们通过增加少量的配置内容，在原有代码的基础上侵入了忍受范围内的代码，就可以达到如此方便、直观的效果，可以说是使用Swagger2来对API文档进行管理，是个很不错的选择！ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"JavaWeb中使用JSON","slug":"JavaWeb中使用JSON","date":"2018-05-27T23:16:00.000Z","updated":"2020-12-09T05:07:16.679Z","comments":true,"path":"2018/05/28/javaweb-zhong-shi-yong-json/","link":"","permalink":"http://www.wmyskxz.com/2018/05/28/javaweb-zhong-shi-yong-json/","excerpt":"","text":"前言： 最近也是期末了，有好多好多文档和实验报告要交，所以都没啥时间写文，这段时间清闲了，来补一下之前学习时遗漏的一些知识树，话说就没人吐槽这个JSON图标好丑吗？ 什么是JSON JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 这里有意思的是，JSON本来是用来表示 JavaScript 对象的一种数据文本格式，但由于它轻量级、易于解析/操作（JavaScript原生支持）的一些特点，渐渐的被很多语言支持也就成了一种标准 为什么使用JSON在JSON之前，我们通常在网络传输中使用的格式是XML，在我们的印象之中，XML具有很好的可读性，并且格式统一，解析起来也相对比较简单，为什么摒弃掉XML而逐渐的使用起JSON呢？ 主要原因在于：JSON比XML更小、更快、更易解析。 JavaScript原生支持JSON，解析速度相较XML会更快； XML解析成DOM对象的时候，浏览器之间会产生差异【例如IE和FireFox】； JSON有很多强大的库能够帮助我们更快更简单的完成工作 XML与JSON实例比较接下来我们通过一个实例的比较来真实的说明一下XML与JSON的区别： 使用XML表示中国部分省市的数据如下： &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?> &lt;country> &lt;name>中国&lt;/name> &lt;province> &lt;name>黑龙江&lt;/name> &lt;citys> &lt;city>哈尔滨&lt;/city> &lt;city>大庆&lt;/city> &lt;/citys> &lt;/province> &lt;province> &lt;name>广东&lt;/name> &lt;citys> &lt;city>广州&lt;/city> &lt;city>深圳&lt;/city> &lt;city>珠海&lt;/city> &lt;/citys> &lt;/province> &lt;province> &lt;name>台湾&lt;/name> &lt;citys> &lt;city>台北&lt;/city> &lt;city>高雄&lt;/city> &lt;/citys> &lt;/province> &lt;province> &lt;name>新疆&lt;/name> &lt;citys> &lt;city>乌鲁木齐&lt;/city> &lt;/citys> &lt;/province> &lt;/country> 使用JSON中国部分省市数据如下： var country = { name: \"中国\", provinces: [ { name: \"黑龙江\", citys: { city: [\"哈尔滨\", \"大庆\"]} }, { name: \"广东\", citys: { city: [\"广州\", \"深圳\", \"珠海\"]} }, { name: \"台湾\", citys: { city: [\"台北\", \"高雄\"]} }, { name: \"新疆\", citys: { city: [\"乌鲁木齐\"]} } ] } 从编码的可读性来说，XML有明显的优势，毕竟人类的语言更贴近这样的说明结构。而JSON读起来更像是一个数据块，读起来比较费解，不过我们读起来费解的语言，恰恰是适合机器于都的，所以通过JSON是的索引contry.provinces[0].name就可以读取到“黑龙江”这个值 从编码的手写难度来说，XML还是更简单一些，好读也就意味着好写；不过JSON写出来的字符明显就少很多；去掉空白制表以及换行的话，JSON就是密密麻麻的有用数据，而XML却包含很多重复的标记字符。 JSON相比XML的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 对于AJAX应用程序员来说，JSON比XML更快更易使用：使用XML： 读取XML文档 使用XML DOM来循环遍历文档 读取值并存储在变量中 使用JSON： 读取JSON字符串 用 eval() 处理JSON字符串 JSON语法客户端与服务器交换的数据无非就是两种： 数组或者是对象，JSON所表示的数据也就是这两种了 JSON语法是JavaScript语法的子集，在JavaScript中用[]中括号来表示数组，用{}大括号来表示对象，JSON也是这样 JSON数组：[]中括号里面的内容有些像ArrayList，是一个列表一样的东西 var employees = [ { \"firstName\":\"Bill\" , \"lastName\":\"Gates\" }, { \"firstName\":\"George\" , \"lastName\":\"Bush\" }, { \"firstName\":\"Thomas\" , \"lastName\": \"Carter\" } ]; JSON对象：{}大括号里面的东西有些像Map，是一对一对的键值对 var obj = { age:20, str:\"wmyskxz\", method:function() { alert(\"我爱学习\"); } }; 注意：[]中括号和{}大括号之间是可以相互嵌套的 解析JSON在解析JSON对象之前，我们需要首先地来创造一个JSON对象： var JASONObject = {\"name\": \"我没有三颗心脏\", \"age\": 21}; 使用HTML解析在HTML中我们可以直接使用.点号来直接访问JSON对象的属性： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>JSON学习&lt;/title> &lt;/head> &lt;body> &lt;p> Name:&lt;span id=\"name\">&lt;/span>&lt;br> Age:&lt;span id=\"age\">&lt;/span>&lt;br> &lt;/p> &lt;script> var JASONObject = {\"name\": \"我没有三颗心脏\", \"age\": 21}; document.getElementById(\"name\").innerHTML = JASONObject.name; document.getElementById(\"age\").innerHTML = JASONObject.age; &lt;/script> &lt;/body> &lt;/html> 打开网页我们能正确看到如下效果： 但通常情况中，我们拿到和上传的并不是一个真正的JSON对象，而是一串由JSON转换得来的字符串，我们同样在HTML中模拟解析一下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>JSON学习&lt;/title> &lt;/head> &lt;body> &lt;p> Name:&lt;span id=\"name\">&lt;/span>&lt;br> Age:&lt;span id=\"age\">&lt;/span>&lt;br> &lt;/p> &lt;script> var txt = '{\"students\":[' + '{\"name\":\"我没有三颗心脏0\",\"age\":21},' + '{\"name\":\"我没有三颗心脏1\",\"age\":21 }]}'; var obj = eval(\"(\" + txt + \")\"); document.getElementById(\"name\").innerHTML = obj.students[1].name; document.getElementById(\"age\").innerHTML = obj.students[1].age; &lt;/script> &lt;/body> &lt;/html> 打开网页即可看到如下正确效果： 从前端发送JSON数据到后台我们这里演示使用AJAX请求的方式来提交JSON数据到后台： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>JSON学习&lt;/title> &lt;!-- 因为不想手动引感觉挺麻烦，引了个菜鸟教程的 --> &lt;script src=\"http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js\">&lt;/script> &lt;/head> &lt;body> &lt;form> id：&lt;input type=\"text\" id=\"id\" value=\"123\"/>&lt;br/> 名称：&lt;input type=\"text\" id=\"name\" value=\"category xxx\"/>&lt;br/> &lt;input type=\"button\" value=\"提交\" id=\"sender\"> &lt;/form> &lt;div id=\"messageDiv\">&lt;/div> &lt;script> $('#sender').click(function () { var id = document.getElementById('id').value; var name = document.getElementById('name').value; var category = {\"name\": name, \"id\": id}; var jsonData = JSON.stringify(category); var page = \"category\"; $.ajax({ type: \"put\", url: page, data: jsonData, dataType: \"json\", contentType: \"application/json;charset=UTF-8\", success: function (result) { } }); alert(\"提交成功，请在springboot控制台查看服务端接收到的数据\"); }); &lt;/script> &lt;/body> &lt;/html> 注意： 在上面的例子中，我们使用了 JSON.stringify() 来将一个JSON对象转换成了一串字符串，并且在AJAX中，我们设置了 dataType 和 contentType 来告知后台我们传输的是一个JSON数据 简单写一个Controller来验证一下吧： @PutMapping(\"/category\") public void addCategory(@RequestBody Category category) throws Exception { System.out.println(\"springboot接受到浏览器以JSON格式提交的数据：\" + category.getId() + category.getName()); } -----------控制台打印信息：---------- springboot接受到浏览器以JSON格式提交的数据：123 category xxx @RequestBody 注解后面讲到，这里只做简单演示 JSON库介绍 引用自：几种常用JSON库性能比较 在后台有许多支持解析JSON的库，目前对于Java开源的JSON类库有许多，下面我们介绍三种比较常用的JSON库，并进行比对说明，它们分别是： Gson（项目地址：https://github.com/google/gson) Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。 FastJson（项目地址：https://github.com/alibaba/fastjson） Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 Jackson（项目地址：https://github.com/FasterXML/jackson） 相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式。 到底使用哪一个JSON库呢？我看了一些资料，比较印象深刻的是：FastJson在复杂类型的Bean转换Json上会出现一些问题，但是在解析JSON时却是最快的（具体参考：知乎：fastjson这么快老外为啥还是热衷 jackson?） 总结如下： FastJson的API设计的最简单，最方便使用，直接使用JSON的两个静态方法即可完成四种操作；而Gson和Jackson都需要new一个对象； 数据量大时，使用Jackson; 如果有性能要求可以使用Gson/Jackson将bean转换json确保数据的正确性，使用FastJson将Json转换成Bean 三种JSON库简要使用说明 为了导库简单，我在这里都使用Maven搭建的SpringBoot项目来演示，Maven库的地址在这里：https://mvnrepository.com/ 在使用之前，我们先来建设一些基础类，用于支持JSON库的使用： public class Person { private String name; private Integer age; /* getter and setter */ @Override public String toString() { return \"名字为\" + name + \",年龄\" + age; } } Gson库使用简要说明（1）Maven依赖： com.google.code.gson gson 2.8.5 （2）使用示例： @Test public void tester() { Gson gson = new Gson(); /* —————————————————— 准备测试数据 —————————————————— */ Person person1 = new Person(); person1.setName(\"我没有三颗心脏1\"); person1.setAge(21); Person person2 = new Person(); person2.setName(\"我没有三颗心脏2\"); person2.setAge(21); Person person3 = new Person(); person3.setName(\"我没有三颗心脏3\"); person3.setAge(21); List&lt;Person> list = new ArrayList&lt;>(); list.add(person1); list.add(person2); list.add(person3); /* —————————————————— 简单的Bean转为JSON —————————————————— */ String jsonString = gson.toJson(person1); System.out.println(\"简单的Bean转为JSON：\" + jsonString); /* —————————————————— JSON转为简单Bean —————————————————— */ Person personFromJson = gson.fromJson(jsonString, Person.class); System.out.println(\"JSON转为简单Bean：\" + personFromJson.toString()); /* —————————————————— 带泛型的List转JSON —————————————————— */ String jsonStringFromList = gson.toJson(list); System.out.println(\"带泛型的List转JSON：\" + jsonStringFromList); /* —————————————————— JSONz转为带泛型的List —————————————————— */ List&lt;Person> retList = gson.fromJson(jsonStringFromList, new TypeToken&lt;List&lt;Person>>() { }.getType()); for (Person tempPerson : retList) { System.out.println(tempPerson.toString()); } } ------------------结果如下------------------ 简单的Bean转为JSON：{\"name\":\"我没有三颗心脏1\",\"age\":21} JSON转为简单Bean：名字为我没有三颗心脏1,年龄21 带泛型的List转JSON：[{\"name\":\"我没有三颗心脏1\",\"age\":21},{\"name\":\"我没有三颗心脏2\",\"age\":21},{\"name\":\"我没有三颗心脏3\",\"age\":21}] 名字为我没有三颗心脏1,年龄21 名字为我没有三颗心脏2,年龄21 名字为我没有三颗心脏3,年龄21 好文推荐及扩展阅读：你真的会用Gson吗?Gson使用指南（一） FastJson库简要使用说明（1）Maven依赖： com.alibaba fastjson 1.2.47 （2）使用示例： @Test public void tester() { /* —————————————————— 准备测试数据 —————————————————— */ Person person1 = new Person(); person1.setName(\"我没有三颗心脏1\"); person1.setAge(21); Person person2 = new Person(); person2.setName(\"我没有三颗心脏2\"); person2.setAge(21); Person person3 = new Person(); person3.setName(\"我没有三颗心脏3\"); person3.setAge(21); List&lt;Person> list = new ArrayList&lt;>(); list.add(person1); list.add(person2); list.add(person3); /* —————————————————— 简单的Bean转为JSON —————————————————— */ String jsonString = JSON.toJSONString(person1); System.out.println(\"简单的Bean转为JSON：\" + jsonString); /* —————————————————— JSON转为简单Bean —————————————————— */ Person personFromJson = JSON.parseObject(jsonString, Person.class); System.out.println(\"JSON转为简单Bean：\" + personFromJson.toString()); /* —————————————————— 带泛型的List转JSON —————————————————— */ String jsonStringFromList = JSON.toJSONString(list); System.out.println(\"带泛型的List转JSON：\" + jsonStringFromList); /* —————————————————— JSONz转为带泛型的List —————————————————— */ List&lt;Person> retList = JSON.parseObject(jsonStringFromList, new TypeReference&lt;List&lt;Person>>() { }); for (Person tempPerson : retList) { System.out.println(tempPerson.toString()); } } ------------------结果如下------------------ 简单的Bean转为JSON：{\"age\":21,\"name\":\"我没有三颗心脏1\"} JSON转为简单Bean：名字为我没有三颗心脏1,年龄21 带泛型的List转JSON：[{\"age\":21,\"name\":\"我没有三颗心脏1\"},{\"age\":21,\"name\":\"我没有三颗心脏2\"},{\"age\":21,\"name\":\"我没有三颗心脏3\"}] 名字为我没有三颗心脏1,年龄21 名字为我没有三颗心脏2,年龄21 名字为我没有三颗心脏3,年龄21 官方文档：戳这里，据官方说法，FastJson比Gson要快上6倍哦！ Jackson库使用简要说明（1）Maven依赖： 稍微麻烦一点的是Jackson需要依赖三个包 com.fasterxml.jackson.core jackson-databind 2.9.5 com.fasterxml.jackson.core jackson-core 2.9.5 com.fasterxml.jackson.core jackson-annotations 2.9.5 （2）使用示例： @Test public void tester() throws IOException { /* —————————————————— 准备测试数据 —————————————————— */ Person person1 = new Person(); person1.setName(\"我没有三颗心脏1\"); person1.setAge(21); Person person2 = new Person(); person2.setName(\"我没有三颗心脏2\"); person2.setAge(21); Person person3 = new Person(); person3.setName(\"我没有三颗心脏3\"); person3.setAge(21); List&lt;Person> list = new ArrayList&lt;>(); list.add(person1); list.add(person2); list.add(person3); /* ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现的 */ ObjectMapper mapper = new ObjectMapper(); /* —————————————————— 简单的Bean转为JSON —————————————————— */ String jsonString = mapper.writeValueAsString(person1); System.out.println(\"简单的Bean转为JSON：\" + jsonString); /* —————————————————— JSON转为简单Bean —————————————————— */ Person personFromJson = mapper.readValue(jsonString, Person.class); System.out.println(\"JSON转为简单Bean：\" + personFromJson.toString()); /* —————————————————— 带泛型的List转JSON —————————————————— */ String jsonStringFromList = mapper.writeValueAsString(list); System.out.println(\"带泛型的List转JSON：\" + jsonStringFromList); /* —————————————————— JSONz转为带泛型的List —————————————————— */ // List&lt;LinkedHashMap&lt;String, Person>> retList = mapper.readValue(jsonStringFromList, List.class); // for (int i = 0; i &lt; retList.size(); i++) { // Map&lt;String, Person> map = retList.get(i); // Set&lt;String> set = map.keySet(); // for (Iterator&lt;String> it = set.iterator(); it.hasNext();) { // String key = it.next(); // System.out.println(key + \":\" + map.get(key)); // } // } /* —————————————————— JSONz转为Array数组 —————————————————— */ Person[] retList = mapper.readValue(jsonStringFromList, Person[].class); for (int i = 0; i &lt; retList.length; i++) { System.out.println(retList[i].toString()); } } ------------------结果如下------------------ 简单的Bean转为JSON：{\"name\":\"我没有三颗心脏1\",\"age\":21} JSON转为简单Bean：名字为我没有三颗心脏1,年龄21 带泛型的List转JSON：[{\"name\":\"我没有三颗心脏1\",\"age\":21},{\"name\":\"我没有三颗心脏2\",\"age\":21},{\"name\":\"我没有三颗心脏3\",\"age\":21}] 名字为我没有三颗心脏1,年龄21 名字为我没有三颗心脏2,年龄21 名字为我没有三颗心脏3,年龄21 几点注意： 1.由于Jackson底层代码抛出了IOEception，所以我们在调用的时候也需要抛出；2.Jackson所有的操作都是基于ObjectMapper 在框架中使用JSONSpingMVC和SpringBoot一样，都能通过注解的方式获取并返回一串JSON格式的数据，我们使用SpringBoot的一段实例程序来实际说明一下： @RequestMapping(\"/jsonCategory\") @ResponseBody // 该注解表示我们的请求不再交给springmvc处理，而是结合JSON包，将对象解析成JSON字符串 public Category jsonCategory() { return new Category(123, \"我没有三颗心脏\"); } 我们在浏览器中访问地址：localhost:8080/jsonCategory，会得到以下JSON数据： 我们也可以使用 @RequestBody 来获取一串JSON数据： @PutMapping(\"/category\") public void addCategory(@RequestBody Category category) { System.out.println(\"springboot接受到浏览器以JSON格式提交的数据：\" + category.getId() + category.getName()); } 我们在前台使用的是上面用过的用于提交JSON数据的页面，运行能够成功得到结果： 注意： Spring4 之后新加入了 @RestController 注解，是@ResponseBody和@Controller的组合注解，用于返回JSON数据。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(七)——Web篇","slug":"Java面试知识点解析-七-——Web篇","date":"2018-05-21T23:13:00.000Z","updated":"2020-12-09T05:05:47.953Z","comments":true,"path":"2018/05/22/java-mian-shi-zhi-shi-dian-jie-xi-qi-web-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/22/java-mian-shi-zhi-shi-dian-jie-xi-qi-web-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 前序文章链接： Java 面试知识点解析(一)——基础知识篇 Java 面试知识点解析(二)——高并发编程篇 Java 面试知识点解析(三)——JVM篇 Java 面试知识点解析(四)——版本特性篇 Java 面试知识点解析(五)——网络协议篇 Java 面试知识点解析(六)——数据库篇 （一）J2EE 相关知识点 不涉及任何框架，对 J2EE 相关知识点的解析 1）Servlet 的生命周期？在 Web 容器中，Servlet 主要经历 4 个阶段，如下图： 1. 加载 Servlet：当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例。 2. 初始化 Servlet：当 Servlet 被实例化之后，Tomcat 会调用 init() 方法来初始化这个对象。 3. 处理服务：当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求。 4. 销毁：当 Tomcat 关闭或者检测到 Servlet 要从 Tomcat 删除的时候，会自动调用 destroy() 方法，让该实例所占用的资源释放掉。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁。 简单总结：只要访问 Servlet ，就会调用其对应的 service() 方法，init() 方法只会在第一次访问 Serlvet 的时候才会被调用。 2）Servlet 的请求流程？ 浏览器发出请求： http://localhost:80/xxx1/xxx2 （80端口可以默认不写，因为这是http协议默认的端口，平时我们访问https://www.baidu.com/ 时其实访问的是https://www.baidu.com:80/） 服务器解析请求信息： http:协议名称 localhost:访问的是互联网中的哪一台计算机 80:从主机当中找到对应 80 端口的程序 **（这里即为 Tomcat 服务器**） /xxx1:当前项目的上下文路径 （即在 server.xml 中配置主机时配置的 path属性） /xxx2:当前请求的资源名 解析 Tomcat 服务器根目录下的 /config/server.xml 文件：&lt;Context docBase=&quot;D:\\javaPros\\test\\webapp&quot; path=&quot;xxx1&quot; /&gt;判断哪一个&lt;Context /&gt;元素的 path属性 属性为 xxx1 若找不到，则返回 404错误 若找到了，则解析该&lt;Context /&gt;元素，得到docBase属性，获取当前访问 Web 项目的跟的绝对路径：D:\\javaPros\\test\\webapp 从D:\\javaPros\\test\\webapp下的 WEB-INF 下找到 web.xml 文件判断 web.xml 文件中是否有 &lt;url-pattern&gt; 的文本内容为 /xxx2 若找不到，则返回 404错误 若找到了，则继续获取该资源对应 Servlet 类的全限名称： xxx.xxx 判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象 Map&lt;String,Servlet> cache = ......(Tomcat提供的); key:存Servlet类的全限定名称 value:该Servlet类的对象. Servlet obj = cache.get(\"xxx.xxx\"); if(obj==null){ //Servlet实例缓存中没有该类的对象,第一次. GOTO 6: }else{ //有对象,非第一次. GOTO 8: } } 使用反射调用构造器，创建对应的对象obj = Class.forName(&quot;xxx.xxx&quot;).newInstance();把当前创建的 Servlet 对象，存放在缓存之中，供给下一次的使用.cache.put(&quot;xxx.xxx&quot;,obj); 创建 ServletConfig 对象，并调用 init() 方法obj.init(config); 创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法obj.service(req,resp); 在 service() 方法中对浏览器作出响应操作。 3）Servlet 是单例的吗？为什么？Servlet 是单例的，浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。 4）GET 和 POST 的区别要知道，GET 和 POST 都是请求方式 1. GET：浏览器器地址栏：http://localhost/test.html?name=wmyskxz&amp;sex=male 这里提交了两个参数，一个是name属性值为wmyskxz，另一个是sex属性值为male，这是一种直接的请求方式，在请求资源后面跟上 ? 符号与参数连接，其他的参数使用 &amp; 符号连接。 缺点： 1.暴露请求信息，不安全2.请求信息不能超过1kb，可传输的信息有限，不能上传图片 2. POST：浏览器地址栏：http://localhost/test.html# 优点： 1.隐藏了请求信息，较安全（但仍可以通过相关工具访问到数据）2.POST 方式没有限制请求的数据大小，可以做图片的上传 5）Tomcat 中如何解决中文乱码问题？在 Tomcat 服务器中，接受请求的时候，默认的编码方式为 ISO-8859-1，而该编码方式只占一个字节，不支持中文（两个字节），所以当我们做请求的时候，会出现乱码的问题 解决方案： 1.对乱码使用 ISO-8859-1 解码，转换成byte数组，恢复为二进制byte[] data = name.getBytes(&quot;ISO-8859-1&quot;); 2.对byte数组重新进行 UTF-8 编码：name = new String(data,&quot;UTF-8&quot;);但是这样会出现一个问题，那就是当表单数据太多的时候，这样反复解码-编码，会很繁琐。 终极解决方案： 1.对于 POST 请求：设置请求的编码方式：request.setCharacterEncoding(&quot;UTF-8&quot;);注意：必须在获取第一个参数之前设置，并且该方式只对 POST 方式有效。 2.对于 GET 请求：重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:Tomcat根目录/conf/server.xml(修改端口的那一行) 6）forward 与 redirect 的区别1.请求转发（forward）又叫做直接转发方式，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。 比如：从 AServlet 请求转发到 BServlet 语法： request.getRequestDispatcher(path).forward(request, response); 参数： path，要跳转到的资源路径：上下文路径 / 资源路径 特点： 1.地址栏中的地址【不会】改变，通常看作是服务端的跳转 2.只有一个请求 3.资源是共享的 也就是说在两个 Servlet 中可以共享请求的资源，可以通过request.setAttribute(String var1,Object var2)设置要共享的数据资源，并通过request.getAttribute(String var1);来获取传递的资源 4.【可以】访问 WEB-INF 中的资源 WEB-INF 文件夹是 Java Web 应用的默认安全目录，即客户端无法直接访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 注意：在实际的开发中，可以把不希望用户直接访问到（通过浏览器输入地址栏）的网页放在文件夹中通过此方式访问。 5.请求转发【不能】跨域访问 所谓的同域，是指域名，协议，端口均相同 2.URl 重定向（redirect）又叫做间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 比如:从AServlet重定向到BServlet 语法： response.sendRedirect(String location); 参数：location，转发到的资源路径 特点： 1.地址栏中的地址【会】发生改变，通常看作是客户端跳转 2.有两个请求 3.在两个 Servlet 中不可以共享请求中的数据 4.最终的响应由 BServlet 来决定，和 AServlet 没有关系 5.【不可以】访问 WEB-INF 中的资源 6.请求转发【能】跨域访问 就像是在网页中点开了新的链接一样 总结：URL 重定向相当于是将重定向的资源路径，重新复制到浏览器地址栏中按下回车一样，重新发送一次新的请求。 7）JSP 的执行原理？当访问一个 JSP 页面时，该页面请求将会讲给服务器中的 JSP 引擎去处理，它负责解释和执行 JSP 页面，每个 JSP 页面在第一次被访问时，JSP 引擎就会将它翻译成一个继承自 org.apache.jasper.runtime.HttpJspBase类的 Servlet 源程序，接着再编译成 class 类文件，再由 Web 容器像调用普通 Servlet 程序一样的方式来装载和解释执行这个由 JSP 页面翻译成的 Servlet 程序。 8）request.getAttribute() 和 request.getParameter() 有何区别？ request.getParameter() 通常用来接收接收表单的get或者post提交过来的参数；而request.getAttribute()一般和setAttribute()搭配使用，只有先set之后才能通过get方法获取到Object类型的数据 getAttribute 返回的是对象，而getParameter 返回的是字符串 getAttribute 和 setAttribute 只是在 web 容器内流转，仅仅是请求处理阶段；而 getParameter 取到的数据是通过容器来获取的。 9）JSP 与 Servlet 的区别？ JSP 实质上就是一个 Servlet。可以理解为，JSP 是编译后的 “Servlet 类”； JSP 由 HTML 代码和 JSP 标签组成，更擅长页面显示；而 Servlet 更擅长流程控制； JSP 感觉像是 HTML 中嵌入 Java 代码，而 Servlet 有些像 Java 中嵌入 HTML 代码的意思。 10）JSP 静态包含和动态包含的区别？（1）静态包含：编译指令包含&lt;%@include file=&quot;被包含的页面的路径&quot;%&gt; 包含的时机：在 JSP 文件被翻译的时候合并在一起，最终翻译得到一个 class文件 （2）动态包含：动作指令包含&lt;jsp:include page=&quot;被包含页面的路径&quot;&gt;&lt;/jsp:include&gt; 包含的时机：在运行阶段合并代码，最终得到两个 class 文件 （3）动态包含和静态包含的选择: 如果被包含的页面如果是静态页面,那么使用静态包含； 如果被包含的如果是动态页面,那么使用动态包含。 11）JSP 有哪些内置对象？作用分别是什么？JSP 共有以下 9 个内置的对象： request：用户端请求，此请求会包含来自 GET/POST 请求的参数； response：表示一次响应对象； pageContext：表示当前的 JSP 对象； session：表示一次会话对象； application：表示当前应用对象； out：表示一个输出流对象； config：表示当前 JSP 的配置对象； page：表示当前页面； exception：表示异常对象。 12）JSTL 是什么？优点有哪些？JSTL（JSP StandardTagLibrary，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，由四个定制标记库（core、format、xml和sql）和一对通用标记库验证器（ScriptFreeTLV和PermittedTaglibsTLV）组成。优点有： 在应用程序服务器之间提供了一致的接口，最大程序地提高了WEB应用在各应用服务器之间的移植。 简化了JSP和WEB应用程序的开发。 以一种统一的方式减少了JSP中的scriptlet代码数量，可以达到没有任何scriptlet代码的程序。在我们公司的项目中是不允许有任何的scriptlet代码出现在JSP中。 允许JSP设计工具与WEB应用程序开发的进一步集成。相信不久就会有支持JSTL的IDE开发工具出现。 13）什么是 Cookie？Session 和 Cookie 有什么区别？Cookie 技术Cookie 是一种会话技术，用于将用户的信息保存在客户端上。Cookie 英文直接翻译过来就是小甜品，Cookie 的作用呢，通俗的说就是当一个用户通过 HTTP 访问一个服务器时，这个服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据又被完整地带回给服务器。 这个作用就像是你去超市购物时，第一次给你办了一张购物卡，在这个购物卡里存放了一些你的个人信息，下次你再来这个超市的时候，你就只需要带上你的购物卡，直接购物就好了。 Session 技术Session：会话，从浏览器打开开始，直到浏览器关闭结束，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。Session 也可以称为会话 Cookie 特点：服务端技术，将数据保存在服务器 Cookie 与 Session 的区别 Cookie 的数据是存放在客户的浏览器上，Session 数据放在服务器上； Cookie 不是很安全，别人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗，如果考虑安全问题则应当使用 Session； Session 会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的资源，所以如果考虑性能问题，则应当使用 Cookie； 单个 Cookie 在客户端的限制是 3k ，就是说一个站点在客户端存放的 Cookie 不能超过 3k。 总结： 将登录信息等重要信息存放为 Session；其他信息如果需要保留，可以存放在 Cookie 中。 14）什么是过滤器？过滤器就是 Servlet 的高级特性之一，就是一个具有拦截/过滤功能的一个东西，在生活中过滤器可以是香烟滤嘴，滤纸，净水器，空气净化器等，在 Web 中仅仅是一个实现了 Filter 接口的 Java 类而已。 特点：双向，拦截请求，拦截响应 作用：过滤器可以对所有的请求或者响应做拦截操作 15）为什么在 Web 开发中需要用到过滤器？ 问题：为什么非得使用过滤器，我直接在 Servlet 中作判断不行吗？ 开发遵循的原则：1.DRY原则（Don’t Reeat Yourself，不要重复你自己）：重复，意味着维护的成本很高。2.责任分离原则：谁擅长什么功能就做什么功能，Servlet 擅长的是逻辑而不是处理请求 举一个实际的例子：（处理 POST 请求中文编码的问题） Web 中过滤器的作用：1.可以在请求资源之前设置请求的编码2.可以进行登录校验3.可以进行请求参数的内容的过滤4.数据压缩 / 数据加密 / 数据格式的转换5.可以设置浏览器相关的数据 16）MVC 模式？MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： Controller——负责转发请求，对请求进行处理 View——负责界面显示 Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示： 1.Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发）2.Controller(Servlet)调用核心业务逻辑——Model部分，获得结果3.Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容4.动态生成的HTML内容返回到浏览器显示 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。 参考：知乎@David （二）框架相关知识 由于我没有接触和学习过 Hibernate 和 Struts 这两个框架，所以细节方面的东西请读者自行收集… 1）什么是框架？框架是指完成一定功能的半成品。 框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 2）什么是 Spring ？ Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。 Spring 提倡以 “最少侵入” 的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring 适用范围：任何 Java 应用 Spring 的根本使命：简化 Java 开发 3）什么是非侵入式设计？从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 4）Spring 有什么优势？ 低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring 的框架结构 Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 5）Spring IoC 和 DI 分别是什么？Spring IoCIoC：Inverse of Control（控制反转），读作 “反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 正控：若要使用某个对象，需要自己去负责对象的创建 反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架 好莱坞法则：Don’t call me ,I’ll call you 为了便于理解我们这里举一个鲜明的例子： 在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。 然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。 请注意你并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。 总结： 这就是一种控制反转的理念，上述的例子已经很好的说明了问题，我们再来描述一下控制反转的概念：控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。 好处： ① 降低对象之间的耦合；② 我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿） DI：Dependency Injection（依赖注入）指 Spring 创建对象的过程中，将对象依赖属性（简单值，集合，对象）通过配置设值给该对象 两者的区别IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，明确描述了 “被注入对象依赖 IoC 容器配置依赖对象”。 你也可以简单的理解为：IoC 是目的，是一种思想，而 DI 是手段，是一种设计模式。 6）BeanFactory 和 ApplicationContext 的区别1.BeanFactory： 是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。在应用中，一般不使用 BeanFactory，而推荐使ApplicationContext（应用上下文），原因如下。 2.ApplicationContext： ⑴. 继承了 BeanFactory，拥有了基本的 IoC 功能；⑵. 除此之外，ApplicationContext 还提供了以下功能：① 支持国际化；② 支持消息机制；③ 支持统一的资源加载；④ 支持AOP功能； 注意： ApplicationContext 和 BeanFactory 相比，最主要的区别在于 BeanFactory 是延迟加载，举个例子：如果 Bean 没有完全注入，BeanFactory 加载后，会在你第一次调用 getBean 方法才会抛出异常；而 ApplicationContext 会在初始化的时候就加载并且检查，这样的好处是可以及时检查依赖是否完全注入；所以通常我们会选择 ApplicationContext。 7）IoC 是如何实现的最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎： 读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名 使用反射的API，基于类名实例化对应的对象实例 将对象实例，通过构造函数或者 setter，传递给 JuiceMaker 我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！ 引用地址：这里 8）Spring 配置 Bean 有几种方式？在 Spring 中提供了 3 种方法进行配置： 在 XML 文件中显式配置 在 Java 的接口和类中实现配置 隐式 Bean 的发现机制和自动装配原则 方式选择的原则在现实的工作中，这 3 种方式都会被用到，并且在学习和工作之中常常混合使用，所以这里给出一些关于这 3 种优先级的建议： 1.最优先：通过隐式 Bean 的发现机制和自动装配的原则。基于约定由于配置的原则，这种方式应该是最优先的 好处：减少程序开发者的决定权，简单又不失灵活。 2.其次：Java 接口和类中配置实现配置在没有办法使用自动装配原则的情况下应该优先考虑此类方法 好处：避免 XML 配置的泛滥，也更为容易。 典型场景：一个父类有多个子类，比如学生类有两个子类，一个男学生类和女学生类，通过 IoC 容器初始化一个学生类，容器将无法知道使用哪个子类去初始化，这个时候可以使用 Java 的注解配置去指定。 3.最后：XML 方式配置在上述方法都无法使用的情况下，那么也只能选择 XML 配置的方式。 好处：简单易懂（当然，特别是对于初学者） 典型场景：当使用第三方类的时候，有些类并不是我们开发的，我们无法修改里面的代码，这个时候就通过 XML 的方式配置使用了。 9）介绍一下 Spring AOPAOP 即 Aspect Oriented Program 面向切面编程 首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫 AOP 还是来举一个鲜明的例子： 在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 AOP 的一个思想：让关注点代码与业务代码分离！ 10）Spring 中 Bean 的作用域在默认的情况下，Spring IoC 容器只会对一个 Bean 创建一个实例，但有时候，我们希望能够通过 Spring IoC 容器获取多个实例，我们可以通过 @Scope 注解或者 &lt;bean&gt; 元素中的 scope 属性来设置，例如： // XML 中设置作用域 &lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;prototype&quot; /&gt; // 使用注解设置作用域 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)Spring 提供了 5 种作用域，它会根据情况来决定是否生成新的对象： 作用域类别 描述 singleton(单例) 在Spring IoC容器中仅存在一个Bean实例 （默认的scope） prototype(多例) 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean()：不会在容器启动时创建对象 request(请求) 用于web开发，将Bean放入request范围 ，request.setAttribute(“xxx”) ， 在同一个request 获得同一个Bean session(会话) 用于web开发，将Bean 放入Session范围，在同一个Session 获得同一个Bean globalSession(全局会话) 一般用于 Porlet 应用环境 , 分布式系统存在全局 session 概念（单点登录），如果不是 porlet 环境，globalSession 等同于 Session 在开发中主要使用 scope=&quot;singleton&quot;、scope=&quot;prototype&quot;，对于MVC中的Action使用prototype类型，其他使用singleton，Spring容器会管理 Action 对象的创建,此时把 Action 的作用域设置为 prototype. 扩展阅读：@Profile 注解 、 条件化装配 Bean 11）Spring 面试问答 Top 25 更多戳这里：Spring面试问答Top 25 12）Spring MVC 的请求流程每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程： 第一站：DispatcherServlet从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。 &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!-- 拦截所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。 第二站：处理器映射（HandlerMapping） 问题：典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？ 所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理： &lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt; &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;第三站：控制器一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息： public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { // 处理逻辑 .... } 第四站：返回 DispatcherServlet当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP。 控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。 public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { // 处理逻辑 .... // 返回给 DispatcherServlet return mav; } 第五站：视图解析器这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。 DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP 上面的例子是直接绑定到了 index.jsp 视图 第六站：视图既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。 它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; &lt;h1&gt;${message}&lt;/h1&gt; 更多 Spring-MVC 内容：Spring MVC【入门】就这一篇 13）什么是 ORM？对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术； 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。 14）为什么要使用 MyBatis ？在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 15）MyBatis 中占位符 # 和 $ 的区别区别如下： #符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号 $符号将传入的数据直接显示生成SQL中。 #符号存在预编译的过程，，对问号赋值，防止SQL注入。 $符号是直译的方式，一般用在orderby {列名} 语句中。 能用#号就不要用$符号 16）MyBatis 缓存结构 在 Web 系统中，最重要的操作就是查询数据库中的数据。但是有些时候查询数据的频率非常高，这是很耗费数据库资源的，往往会导致数据库查询效率极低，影响客户的操作体验。于是我们可以将一些变动不大且访问频率高的数据，放置在一个缓存容器中，用户下一次查询时就从缓存容器中获取结果。 MyBatis 拥有自己的缓存结构，可以用来缓解数据库压力，加快查询速度。 MyBatis 一级缓存是一个 SqlSession 级别，同一个 SqlSession 只能访问自己的一级缓存的数据 二级缓存是跨sqlSession，是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession是可以共享的。 更多深入MyBatis的内容戳这里：MyBatis(2)——MyBatis 深入学习 17）MyBatis 与 Spring 整合 戳这里：MyBatis 与 Spring 整合 18）IDEA 整合 SSM 框架学习 戳这里IDEA 整合 SSM 框架学习 19）MVC 三种模式在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1： 出现的弊端： JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 代码难以复用 正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。 M 代表 模型（Model）模型是什么呢？ 模型就是数据，就是 dao,bean V 代表 视图（View）视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller)控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 扩展阅读：Web开发模式 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点：结构松散，几乎可以在 Spring MVC 中使用各类视图松耦合，各个模块分离与 Spring 无缝集成 20）分页？ 戳这里：Java Web -【分页功能】详解 21）什么是 Spring Boot ？ 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：springboot(一)：入门篇——纯洁的微笑） 22）使用 Spring Boot 有什么好处？回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： 1）配置 web.xml，加载 spring 和 spring mvc 2）配置数据库连接、配置日志文件 3）配置家在配置文件的读取，开启注解 4）配置mapper文件 ….. 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 Spring Boot 由于笔者还没有深入学习..所以细节部分请读者自行收集… 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(六)——数据库篇","slug":"Java面试知识点解析-六-——数据库篇","date":"2018-05-20T23:10:00.000Z","updated":"2020-12-09T05:05:44.006Z","comments":true,"path":"2018/05/21/java-mian-shi-zhi-shi-dian-jie-xi-liu-shu-ju-ku-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/21/java-mian-shi-zhi-shi-dian-jie-xi-liu-shu-ju-ku-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 前序文章链接： Java 面试知识点解析(一)——基础知识篇 Java 面试知识点解析(二)——高并发编程篇 Java 面试知识点解析(三)——JVM篇 Java 面试知识点解析(四)——版本特性篇 Java 面试知识点解析(五)——网络协议篇 前排引用说明及好文推荐：面试/笔试第三弹 —— 数据库面试问题集锦、数据库常见面试题(开发者篇) 1）什么是存储过程？有哪些优缺点？存储过程就像是编程语言中的函数一样，封装了我们的代码（PLSQL，T-SQL） 例如： -------------创建名为GetUserAccount的存储过程---------------- create Procedure GetUserAccount as select * from UserAccount go -------------执行上面的存储过程---------------- exec GetUserAccount 存储过程的优点： 能够将代码封装起来 保存在数据库之中 让编程语言进行调用 存储过程是一个预编译的代码块，执行效率比较高 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率 存储过程的缺点： 每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用） 业务逻辑放在数据库上，难以迭代 2）三大范式 思考这样的一个例子： 我们现在需要建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号（Sno）、所在系（Sdept）、系主任姓名（Mname）、课程号（Cno）和成绩（Grade），假设我们使用单一的关系模式 Student 来表示，那么根据现实世界已知的信息，会描述成以下这个样子： 但是，这个关系模式存在以下问题： （1） 数据冗余比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，这将浪费大量的存储空间。（2）更新异常（update anomalies）由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。比如，某系更换系主任后，必须修改与该系学生有关的每一个元组。（3）插入异常（insertion anomalies）如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。（4）删除异常（deletion anomalies）如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢失了。 总结： 所以，我们在设计数据库的时候，就需要满足一定的规范要求，而满足不同程度要求的就是不同的范式。 第一范式： 列不可分 1NF（第一范式）是对属性具有原子性的要求，不可再分，例如： 如果认为最后一列还可以再分成出生年，出生月，出生日，则它就不满足第一范式的要求。 第二范式： 消除非主属性对码的部分函数依赖 2NF（第二范式）是对记录有唯一性的要求，即实体的唯一性，不存在部分依赖，每一列与主键都相关，例如： 该表明显说明了两个事物：学生信息和课程信息；正常的依赖应该是：学分依赖课程号，姓名依赖学号，但这里存在非主键字段对码的部分依赖，即与主键不相关，不满足第二范式的要求。 可能存在的问题： 数据冗余：每条记录都含有相同信息； 删除异常：删除所有学生成绩，就把课程信息全删除了； 插入异常：学生未选课，无法记录进数据库； 更新异常：调整课程学分，所有行都调整。 正确的做法： 第三范式： 消除非主属性对码的传递函数依赖 3NF（第三范式）对字段有冗余性的要求，任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在依赖传递，例如： 很明显，学院电话是一个冗余字段，因为存在依赖传递：（学号）→（学生）→（学院）→（学院电话） 可能会存在的问题： 数据冗余：有重复值； 更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。 正确的做法： 3）数据库索引 什么是索引？ 索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。 你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 底层数据结构是什么，为什么使用这种数据结构？ （1）底层数据结构是B+树：在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。 （2）使用B+树的原因：查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（此时，你应该在白纸上画出什么是B+树） 索引的分类？ 唯一索引：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个 非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 索引的优缺点？ （1）优点： 大大加快数据的检索速度，这也是创建索引的最主要的原因； 加速表和表之间的连接； 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间； 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性； （2）缺点： 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度； 空间方面：索引需要占物理空间。 什么样的字段适合创建索引？ 经常作查询选择的字段 经常作表连接的字段 经常出现在order by, group by, distinct 后面的字段 创建索引时需要注意什么？ 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 4）听说过事务吗？（必考）事务简单来说：一个 Session 中所进行所有的操作，要么同时成功，要么同时失败；作为单个逻辑工作单元执行的一系列操作，满足四大特性： 原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行 一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存 实例说明： /* * 我们来模拟A向B账号转账的场景 * A和B账户都有1000块，现在我让A账户向B账号转500块钱 * **/ //JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题 //A账户减去500块 String sql = \"UPDATE a SET money=money-500 \"; preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); //B账户多了500块 String sql2 = \"UPDATE b SET money=money+500\"; preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); 从上面看，我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下 // A账户减去500块 String sql = \"UPDATE a SET money=money-500 \"; preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); // 这里模拟出现问题 int a = 3 / 0; String sql2 = \"UPDATE b SET money=money+500\"; preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); 显然，上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。 我们可以通过事务来解决上面出现的问题： // 开启事务,对数据的操作就不会立即生效。 connection.setAutoCommit(false); // A账户减去500块 String sql = \"UPDATE a SET money=money-500 \"; preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); // 在转账过程中出现问题 int a = 3 / 0; // B账户多500块 String sql2 = \"UPDATE b SET money=money+500\"; preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); // 如果程序能执行到这里，没有抛出异常，我们就提交数据 connection.commit(); // 关闭事务【自动提交】 connection.setAutoCommit(true); } catch(SQLException e) { try { // 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】 connection.rollback(); // 关闭事务【自动提交】 connection.setAutoCommit(true); } catch (SQLException e1) { e1.printStackTrace(); } } 上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。 注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。 5）事务的并发问题有哪几种？ 丢失更新：一个事务的更新覆盖了另一个事务的更新； 脏读：一个事务读取了另一个事务未提交的数据； 不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改； 幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。 6）事务的隔离级别有哪几种？隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是： 读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题； 读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题； 可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。 序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。 MySQL默认的隔离级别是可重复读（REPEATABLE READ） MySql 的事务支持 MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关： MyISAM：不支持事务，用于只读程序提高性能； InnoDB：支持ACID事务、行级锁、并发； Berkeley DB：支持事务。 7）什么是视图？以及视图的使用场景有哪些？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 如下两种场景一般会使用到视图： 不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。 注意：这个视图是在数据库中创建的 而不是用代码创建的。 8）drop,delete与truncate的区别？drop 直接删除表；truncate 删除表中数据，再插入时自增长id又从1开始 ；delete 删除表中数据，可以加where字句。 drop table： 属于DDL（Data Definition Language，数据库定义语言） 不可回滚 不可带 where 表内容和结构删除 删除速度快 truncate table： 属于DDL（Data Definition Language，数据库定义语言） 不可回滚 不可带 where 表内容删除 删除速度快 delete from： 属于DML 可回滚 可带where 表结构在，表内容要看where执行的情况 删除速度慢,需要逐行删除 使用简要说明： 不再需要一张表的时候，用drop 想删除部分数据行时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate 9）触发器的作用？触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。 10）数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 悲观锁是一种利用数据库内部机制提供的锁的方式，也就是对更新的数据加锁，这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了，这就是悲观锁的实现方式。 MySQL InnoDB中使用悲观锁： 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0; //0.开始事务 begin;/begin work;/start transaction; (三者选一就可以) //1.查询出商品信息 select status from t_goods where id=1 for update; //2.根据商品信息生成订单 insert into t_orders (id,goods_id) values (null,1); //3.修改商品status为2 update t_goods set status=2; //4.提交事务 commit;/commit work; 上面的查询语句中，我们使用了 select…for update 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 上面我们提到，使用 select…for update 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足： 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁是一种不会阻塞其他线程并发的控制，它不会使用数据库的锁进行实现，它的设计里面由于不阻塞其他线程，所以并不会引起线程频繁挂起和恢复，这样便能够提高并发能力，所以也有人把它称为非阻塞锁。一般的实现乐观锁的方式就是记录数据版本。 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。 实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。 使用版本号实现乐观锁： 使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 1.查询出商品信息 select (status,status,version) from t_goods where id=#{id} 2.根据商品信息生成订单 3.修改商品status为2 update t_goods set status=2,version=version+1 where id=#{id} and version=#{version}; 优点与不足： 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。 参考文章：深入理解乐观锁与悲观锁 11）超键、候选键、主键、外键分别是什么？ 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键（候选码）：是最小超键，即没有冗余元素的超键。 主键（主码）：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 候选码和主码： 例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人） 它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码} 如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键) 12）SQL 约束有哪几种？ NOT NULL: 用于控制字段的内容一定不能为空（NULL）。 UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。 PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。 FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CHECK: 用于控制字段的值范围。 13）MySQL存储引擎中的MyISAM和InnoDB区别详解在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，其由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然MyISAM性能极佳，但却有一个显著的缺点： 不支持事务处理。不过，MySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。 InnoDB是MySQL的数据库引擎之一，其由Innobase oy公司所开发，2006年五月由甲骨文公司并购。与传统的ISAM、MyISAM相比，InnoDB的最大特色就是支持ACID兼容的事务功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。具体地，MyISAM与InnoDB作为MySQL的两大存储引擎的差异主要包括： 存储结构：每个MyISAM在磁盘上存储成三个文件：第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。 存储空间：MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 可移植性、备份及恢复：MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。 事务支持：MyISAM强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。 AUTO_INCREMENT：在MyISAM中，可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引，并且引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。 表锁差异：MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。 全文索引：MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。 表主键：MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。 表的具体行数：MyISAM保存表的总行数，select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 CURD操作：在MyISAM中，如果执行大量的SELECT，MyISAM是更好的选择。对于InnoDB，如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。 外键：MyISAM不支持外键，而InnoDB支持外键。 通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁、外键等等。尤其在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，必须需要注意的是，任何一种表都不是万能的，合适的才是最好的，才能最大的发挥MySQL的性能优势。如果是不复杂的、非关键的Web应用，还是可以继续考虑MyISAM的，这个具体情况具体考虑。 14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？答案:都是B+树! MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。 Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。 15）varchar和char的区别char是一种固定长度的类型，varchar是一种可变长度的类型，例如： 定义一个char[10]和varchar[10]，如果存进去的是 ‘test’，那么char所占的长度依然为10，除了字符 ‘test’ 外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的 char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储于查找 char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。 varchar是以空间效率为首位。 char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。 varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。两者的存储数据都非unicode的字符数据。 16）主键、自增主键、主键索引与唯一索引概念区别 主键：指字段 唯一、不为空值 的列； 主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引； 自增主键：字段类型为数字、自增、并且是主键； 唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。 17）主键就是聚集索引吗？主键和索引有什么区别？主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。 18）实践中如何优化MySQL实践中，MySQL的优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面，如下图所示： ⑴ SQL语句优化：SQL语句的优化主要包括三个问题，即如何发现有问题的SQL、如何分析SQL的执行计划以及如何优化SQL，下面将逐一解释。 ① 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控） MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示： 通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。 ② 通过explain查询和分析SQL的执行计划： 使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。 ③ SQL语句的优化： ⒈优化insert语句：一次插入多值； ⒉应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描； ⒊应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描； ⒋优化嵌套查询：子查询可以被更有效率的连接(Join)替代； ⒌很多时候用 exists 代替 in 是一个好的选择。 ⒍选择最有效率的表名顺序：数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理 在FROM子句中包含多个表的情况下： 如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推 也就是说：选择记录条数最少的表放在最后 如果有3个以上的表连接查询： 如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。 也就是说：被其他表所引用的表放在最后 ⒎用IN代替OR： select * from emp where sal = 1500 or sal = 3000 or sal = 800; select * from emp where sal in (1500,3000,800); ⒏SELECT子句中避免使用*号： 我们最开始接触 SQL 的时候，“*” 号是可以获取表中全部的字段数据的，但是它要通过查询数据字典完成，这意味着将消耗更多的时间，而且使用 “*” 号写出来的 SQL 语句也不够直观。 ⑵ 索引优化：建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在 order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形： 以 “%(表示任意0个或多个字符)” 开头的 LIKE 语句，模糊匹配； OR语句前后没有同时使用索引； 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）； 对于多列索引，必须满足最左匹配原则(eg,多列索引col1、col2和col3，则 索引生效的情形包括col1或col1，col2或col1，col2，col3)。 ⑶ 数据库表结构的优化：① 选择合适数据类型： 使用较小的数据类型解决问题； 使用简单的数据类型(mysql处理int要比varchar容易)； 尽可能的使用not null 定义字段； 尽量避免使用text类型，非用不可时最好考虑分表； ② 表的范式的优化： 一般情况下，表的设计应该遵循三大范式。 ③ 表的垂直拆分： 把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段： 把不常用的字段单独放在同一个表中； 把大字段独立放入一个表中； 把经常使用的字段放在一起； 这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单 ④ 表的水平拆分： 表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种： 对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值； 针对不同的hashID将数据存入不同的表中； 表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处： 表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度； 表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。 需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)。 ⑷ 系统配置的优化： 操作系统配置的优化：增加TCP支持的队列数 mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances） ⑸ 硬件的优化： CPU：核心数多并且主频高的 内存：增大内存 磁盘配置和选择：磁盘性能 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(五)——网络协议篇","slug":"Java面试知识点解析-五-——网络写一篇","date":"2018-05-17T23:05:00.000Z","updated":"2020-12-09T05:05:56.719Z","comments":true,"path":"2018/05/18/java-mian-shi-zhi-shi-dian-jie-xi-wu-wang-luo-xie-yi-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/18/java-mian-shi-zhi-shi-dian-jie-xi-wu-wang-luo-xie-yi-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 前序文章链接： Java 面试知识点解析(一)——基础知识篇 Java 面试知识点解析(二)——高并发编程篇 Java 面试知识点解析(三)——JVM篇 Java 面试知识点解析(四)——版本特性篇 前排引用说明及好文推荐：面试/笔试第一弹 —— 计算机网络面试问题集锦——书呆子Rico （一）网络基础知识1）Http和Https的区别？答：Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443； 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源； 开销：Https通信需要证书，而证书一般需要向认证机构购买； Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 2）对称加密与非对称加密答： 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 3）三次握手与四次挥手答： (1). 三次握手（我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功） 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 (2). 四次挥手（我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）： 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 (3). 通俗一点的理解就是： 4）为什么 TCP 链接需要三次握手，两次不可以么？答：“三次握手” 的目的是为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。 正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。 现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 5）为什么要四次挥手？答：TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。 所以想要愉快的结束这次对话就需要四次挥手。 6）TCP 协议如何来保证传输的可靠性答：TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。 对于可靠性，TCP通过以下方式进行保证： 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据； 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？答：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认 (1). DDos 攻击： 客户端向服务端发送请求链接数据包 服务端向客户端发送确认数据包 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 (2). DDos 预防：（没有彻底根治的办法，除非不使用TCP） 限制同时打开SYN半链接的数目 缩短SYN半链接的Time out 时间 关闭不必要的服务 8）GET 与 POST 的区别？答：GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面： (1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源； (2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变； (3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。 (4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。 (5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。 为什么在GET请求中会对URL进行编码？ 我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 避免歧义。看下面的例子， 针对 “name1=value1&amp;name2=value2” 的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为： 6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532 6E616D6531：name1 3D：= 76616C756531：value1 26：&amp; 6E616D6532：name2 3D：= 76616C756532：value2 服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。 现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。 那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。 9）TCP与UDP的区别答：TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括： TCP是面向连接的，UDP是无连接的； TCP是可靠的，UDP是不可靠的； TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式； TCP是面向字节流的，UDP是面向报文的； TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信； TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大； 10）TCP和UDP分别对应的常见应用层协议答： (1). TCP 对应的应用层协议： FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。 SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 HTTP：从Web服务器传输超文本到本地浏览器的传送协议。 (2). UDP 对应的应用层协议： DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务 (3). 图示： 11）TCP 的拥塞避免机制答： 拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。 拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。 拥塞控制的方法： (1). 慢启动 + 拥塞避免： 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小; 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。 (2). 快重传 + 快恢复： 快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 12）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。解析：经典的网络协议问题。 答： 由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。 建立TCP/IP连接（三次握手具体过程） 由浏览器发送一个HTTP请求 经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器 服务器处理该HTTP请求，返回一个HTML文件 浏览器解析该HTML文件，并且显示在浏览器端 这里需要注意： HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接 可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。 13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?答：HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。 HTTP 的这种特性有优点也有缺点： 优点：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用 缺点：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享 解决方案： 使用参数传递机制：将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：/param/list?username=wmyskxz 问题：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb2. 使用 Cookie 技术3. 使用 Session 技术 14）Session、Cookie 与 Application答：Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 (1). Cookie 及其相关 API ： Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。 (2). Session 及其相关 API： 同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 URL重写机制 将sessionid传回服务器。 (3). Session 与 Cookie 的对比： 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID； 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关； 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全； 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 (4). Application： Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。 15）滑动窗口机制答：由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。这就实现了流量的控制。 16）常用的HTTP方法有哪些？答： GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 17）常见HTTP状态码答： 1xx（临时响应） 2xx（成功） 3xx（重定向）：表示要完成请求需要进一步操作 4xx（错误）：表示请求可能出错，妨碍了服务器的处理 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误 常见状态码： 200（成功） 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容 401（未授权）：请求要求身份验证 403（禁止）：服务器拒绝请求 404（未找到）：服务器找不到请求的网页 18）SQL 注入答：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 (1).SQL注入攻击的总体思路： 寻找到SQL注入的位置 判断服务器类型和后台数据库类型 针对不通的服务器和数据库特点进行SQL注入攻击 (2). SQL注入攻击实例： 比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录： 用户名： ‘or 1 = 1 -- 密 码：用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句： String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; 因此，当输入了上面的用户名和密码，上面的SQL语句变成： SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’ 分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。 (3). 应对方法： 1.参数绑定： 使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和$来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。 2.使用正则表达式过滤传入的参数 19）XSS 攻击答：XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 (1). XSS攻击的危害： 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 (2). 原因解析： 主要原因：过于信任客户端提交的数据！ 解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。 进一步分析细节：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！ (3). XSS 攻击分类： 反射性 XSS 攻击（非持久性 XSS 攻击）： 漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息： http://www.test.com/message.php?send=Hello,World！接收者将会接收信息并显示Hello,World；但是，非正常发送消息： http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！接收者接收消息显示的时候将会弹出警告窗口！ 持久性XSS攻击 (留言板场景)： XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。 例如，留言板表单中的表单域： &lt;input type=“text” name=“content” value=“这里是用户填写的数据”&gt;正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写: &lt;script&gt;alert(‘foolish!’)；&lt;/script&gt; &lt;!--或者html其他标签（破坏样式）、一段攻击型代码--&gt;并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。 (4). 修复漏洞方针： 漏洞产生的根本原因是 太相信用户提交的数据，对用户所提交的数据过滤不足所导致的，因此解决方案也应该从这个方面入手，具体方案包括： 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）； 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。 对数据进行Html Encode 处理 过滤或移除特殊的Html标签，例如: , , < for for>, &quot for 过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。 需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！ 20）OSI 网络体系结构与 TCP/IP 协议模型答：OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对 OSI 七层模型的各层进行简要的介绍： 1). 物理层 参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。 2). 数据链路层（data link layer） 接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。 3). 网络层 将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。 4). 传输层（transport layer） 在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。 实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。 5). 会话层（Session Layer） 会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。 6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密 表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。 7). 应用层（Application layer）：为用户的应用进程提供网络通信服务 21）网络层的 ARP 协议工作原理？答：地址解析协议(ARP) 是通过解析网路层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。 网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 22）IP地址的分类答：整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位标识符，它是一个逻辑地址，用以屏蔽掉物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。 每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下： A类地址：以0开头，第一个字节范围：0~127； B类地址：以10开头，第一个字节范围：128~191； C类地址：以110开头，第一个字节范围：192~223； D类地址：以1110开头，第一个字节范围为224~239； E类地址：以1111开头，保留地址 1). A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0” 一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。 A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。 2). B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10” 一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。 B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。 3). C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110” 一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。 C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。 4). D类地址:多播地址，用于1对多通信，最高位必须是“1110” D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。 5). E类地址:为保留地址，最高位必须是“1111” 23）IP地址与物理地址答：物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。 24）影响网络传输的因素有哪些？答：将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。 网络带宽：所谓带宽就是一条物理链路在 1s 内能够传输的最大比特数，注意这里是比特（bit）而不是字节数，也就是 b/s 。网络带宽肯定是影响数据传输的一个关键环节，因为在当前的网络环境中，平均网络带宽只有 1.7 MB/s 左右。 传输距离：也就是数据在光纤中要走的距离，虽然光的传播速度很快，但也是有时间的，由于数据在光纤中的移动并不是走直线的，会有一个折射率，所以大概是光的 2/3，这个时间也就是我们通常所说的传输延时。传输延时是一个无法避免的问题，例如，你要给在杭州和青岛的两个机房的一个数据库进行同步数据操作，那么必定会存在约 30ms 的一个延时。 TCP 拥塞控制：我们知道 TCP 传输是一个 “停-等-停-等” 的协议，传输方和接受方的步调要一致，要达到步调一致就要通过拥塞控制来调节。TCP 在传输时会设定一个 “窗口”，这个窗口的大小是由带宽和 RTT（Round-Trip Time，数据在两端的来回时间，也就是响应时间）决定的。计算的公式是带宽（b/s）xRTT（s）。通过这个值就可以得出理论上最优的 TCP 缓冲区的大小。Linux 2.4 已经可以自动地调整发送端的缓冲区的大小，而到 Linux 2.6.7 时接收端也可以自动调整了。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(四)——版本特性篇","slug":"Java面试知识点解析-四-——版本特性篇","date":"2018-05-16T23:02:00.000Z","updated":"2020-12-09T05:05:52.884Z","comments":true,"path":"2018/05/17/java-mian-shi-zhi-shi-dian-jie-xi-si-ban-ben-te-xing-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/17/java-mian-shi-zhi-shi-dian-jie-xi-si-ban-ben-te-xing-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 前序文章链接： Java 面试知识点解析(一)——基础知识篇 Java 面试知识点解析(二)——高并发编程篇 Java 面试知识点解析(三)——JVM篇 对于 Java 各个版本的特性，特别是 Java 8 的新知识点，我们都应该有所了解。前排申明和好文推荐：闪烁之狐 » Java5新特性及使用 » Java6新特性及使用 » Java7新特性及使用 » Java8新特性及使用(一) » Java8新特性及使用(二) （一）Java 5 相关知识点 参考文章：jdk 1.5新特性 1）增强型 for 循环：答：增强 for 循环：foreach 语句，foreach 简化了迭代器。 格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器 for( 元素类型 变量名 : Collection集合 &amp; 数组 ) { … } 语法：for ( type 变量名：集合变量名 ) { … } 注意事项： 迭代变量必须在( )中定义！ 集合变量可以是数组或实现了Iterable接口的集合类。 高级for循环和传统for循环的区别： 高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。 如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。比起普通的for循环，高级for循环还有性能优势，因为它对数组索引的边界值只计算一次（摘自《Effective Java》第46条）。 高级for循环可以遍历map集合吗？ 答：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。 for(Object obj : map.entrySet()) { Map.Entry entry = (Entry) obj; // obj 依次表示Entry System.out.println(entry.getKey() + \"=\" + entry.getValue()); } 总之，for-each 循环在简洁性和预防 Bug 方面有着传统 for 循环无法比拟的优势，并且没有性能损失。应该尽可能地使用 for-each 循环。遗憾的是，有三种常见的情况是无法使用 for-each 循环的： 过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式地迭代器，以便可以调用它的 remove 方法。 转换——如果需要遍历列表或者数组，并取代它部分或者全部的元素值（增删、或对元素进行赋值），就需要列表迭代器或者数组索引，以便设定元素的值 平行迭代——如果需要并行地遍历多个集合，就需要显式地控制迭代器或者所因变量以便所有迭代器或者索引变量都可以得到同步前移 2）可变参数：解析：什么意思呢？举个例子：在 JDK 1.5 之前，当我们要为一个传递多个类型相同的参数时，我们有两种方法解决，1.直接传递一个数组过去，2.有多少个参数就传递多少个参数。 例如： public void printColor(String red,String green,String yellow){ } // 或者 public void printColor(String[] colors){ } 这样编写方法参数虽然能够实现我们想要的效果，但是，这样是不是有点麻烦呢？再者，如果参数个数不确定，我们怎么办呢？Java JDK1.5为我们提供的可变参数就能够完美的解决这个问题 答： 可变参数（…）：用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。 和以前接收数组不一样的是： 以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。 如果在参数列表中使用了可变参数，可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。 如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。 可变参数的特点： ① 只能出现在参数列表的最后； ② “…” 位于变量类型和变量名之间，前后有无空格都可以; ③ 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。 Public int add(int x, int... args){//也可以直接（int..args）就是说传不传都可以 Int sum = x; For(int i = 0; i&lt;=args.lengrth;i++){ Sum+=args[i]; } return sum; } 实例： public class VariableParameter { public static void main(String[] args) { System. out.println(add(1, 2)); System. out.println(add(1, 2, 3)); } public static int add(int x, int... args){ int sum = x; for(int i = 0; i &lt; args.length; i++){ sum += args[i]; } return sum; } } 3）枚举解析：关键字 enum 答： 问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个； 解决办法： 1）在 setGrade 方法中做判断，不符合格式要求就抛出异常；2）直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个 Grade 类，私有构造函数，对外提供 5 个静态的常量表示类的实例；3）jdk5 中新定义了枚举类型，专门用于解决此类问题；4）枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类； 为什么要有枚举？ 问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。 枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。 用普通类如何实现枚举功能，定义一个Weekday的类来模拟枚举功能。 1、私有的构造方法。2、每个元素分别用一个公有的静态成员变量表示。 可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句转移成了一个个独立的类 示例：定义一个Weekday的类来模拟枚举功能。 public class WeekDay { private WeekDay(){} public static final WeekDay SUN = new WeekDay(); public static final WeekDay MON = new WeekDay(); public WeekDay nextDay(){ if(this == SUN){ return MON ; } else{ return SUN ; } } public String toString(){ return this == SUN? \"SUN\":\"MON\" ; } } public class EnumTest { public static void main(String[] args) { WeekDay day = WeekDay.MON; System. out.println(day.nextDay()); //结果：SUN } } 使用枚举类实现 public class EnumTest { public static void main(String[] args) { WeekDay day = WeekDay.FRI; System.out.println(day); //结果：FRI System.out.println(day.name()); //结果：FRI System.out.println(day.ordinal()); //结果：5 System.out.println(WeekDay. valueOf(\"SUN\")); //结果：SUN System.out.println(WeekDay. values().length); //结果：7 } public enum WeekDay{ SUN,MON ,TUE,WED, THI,FRI ,SAT; } } 总结： 枚举是一种特殊的类，其中的每个元素都是该类的一个实例对象，例如可以调用WeekDay.SUN.getClass().getName 和 WeekDay.class.getName()。 注意： 最后一个枚举元素后面可以加分号，也可以不加分号。 实现带有构造方法的枚举 枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。 枚举元素必须位于枚举体中的最开始部分，枚举元素列表的最后要有分号与其他成员分隔。把枚举中的成员方法或变量等放在枚举元素的前面，编译器会报告错误。 带构造方法的枚举：构造方法必须定义成私有的如果有多个构造方法，将根据枚举元素创建时所带的参数决定选择哪个构造方法创建对象。枚举元素 MON 和 MON() 的效果一样，都是调用默认的构造方法。 示例： public class EnumTest { public static void main(String[] args) { WeekDay day = WeekDay.FRI; } public enum WeekDay{ SUN(1),MON (),TUE, WED,THI ,FRI,SAT; private WeekDay(){ System. out.println(\"first\" ); } private WeekDay(int value){ System. out.println(\"second\" ); } //结果： //second //first //first //first //first //first //first } } 实现带有抽象方法的枚举 定义枚举TrafficLamp，实现抽象的nextTrafficLamp方法：每个元素分别是由枚举类的子类来生成的实例对象，这些子类采用类似内部类的方式进行定义。增加上表示时间的构造方法。 public class EnumTest { public static void main(String[] args) { TrafficLamp lamp = TrafficLamp.RED; System.out.println(lamp.nextLamp()); //结果：GREEN } public enum TrafficLamp { RED(30) { public TrafficLamp nextLamp() { return GREEN; } }, GREEN(45) { public TrafficLamp nextLamp() { return YELLOW; } }, YELLOW(5) { public TrafficLamp nextLamp() { return RED; } }; private int time; private TrafficLamp(int time) { this.time = time; } public abstract TrafficLamp nextLamp(); } } 注意：1、枚举只有一个成员时，就可以作为一种单例的实现方式。2、查看生成的class文件，可以看到内部类对应的class文件。 4）自动拆装箱答：在 Java 中数据类型分为两种：基本数据类型、引用数据类型(对象) 自动装箱：把基本类型变成包装器类型，本质是调用包装器类型的valueOf（）方法 注意：基本数据类型的数组与包装器类型数组不能互换 在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下： int → Integerbyte → Byteshort → Shortlong → Longchar → Characterdouble → Doublefloat → Floatboolean → Boolean 在 jdk 1.5 以前基本数据类型和包装类之间需要相互转换： 基本—引用 Integer x = new Integer(x);引用—基本 int num = x.intValue(); 1）Integer x = 1; x = x + 1; 经历了什么过程？装箱→拆箱→装箱2）为了优化，虚拟机为包装类提供了缓冲池，Integer池的大小为 -128~127 一个字节的大小。String池：Java 为了优化字符串操作也提供了一个缓冲池； → 享元模式（Flyweight Pattern）：享元模式的特点是，复用我们内存中已经存在的对象，降低系统创建对象实例。 自动装箱： Integer num1 = 12; 自动拆箱： System.out.println(num1 + 12); 基本数据类型的对象缓存： Integer num1 = 12; Integer num2 = 12; System.out.println(num1 == num2);//ture Integer num3 = 129; Integer num4 = 129; System.out.println(num3 == num4);//false Integer num5 = Integer.valueOf(12); Integer num6 = Integer.valueOf(12); System.out.println(num5 == num6);//true 示例： public class AutoBox { public static void main(String[] args) { //装箱 Integer iObj = 3; //拆箱 System. out.println(iObj + 12); //结果：15 Integer i1 = 13; Integer i2 = 13; System. out.println(i1 == i2); //结果：true i1 = 137; i2 = 137; System. out.println(i1 == i2); //结果：false } } 注意：如果有很多很小的对象，并且他们有相同的东西，那就可以把他们作为一个对象。如果还有很多不同的东西，那就可以作为外部的东西，作为参数传入。这就是享元设计模式（flyweight）。 例如示例中的Integer对象，在-128~127范围内的Integer对象，用的频率比较高，就会作为同一个对象，因此结果为true。超出这个范围的就不是同一个对象，因此结果为false。 5）泛型 Generics答：引用泛型之后，允许指定集合里元素的类型，免去了强制类型转换，并且能在编译时刻进行类型检查的好处。Parameterized Type作为参数和返回值，Generic是vararg、annotation、enumeration、collection的基石。 泛型可以带来如下的好处总结如下： 类型安全：抛弃List、Map，使用List、Map给它们添加元素或者使用Iterator遍历时，编译期就可以给你检查出类型错误 方法参数和返回值加上了Type: 抛弃List、Map，使用List、Map 不需要类型转换：List list = new ArrayList(); 类型通配符“?”： 假设一个打印List中元素的方法printList,我们希望任何类型T的List都可以被打印 6）静态导入答：静态导入：导入了类中的所有静态成员，简化静态成员的书写。import语句可以导入一个类或某个包中的所有类import static语句导入一个类中的某个静态方法或所有静态方法 import static java.util.Collections.*; //导入了Collections类中的所有静态成员 静态导入可以导入静态方法，这样就不必写类名而可以直接调用静态方法了。 例子： 原来的： public class Demo12 { public static void main(String[] args) { System.out.println(Math.max(12, 15)); System. out.println(Math.abs(3-6)); } } 使用静态导入的： import static java.lang.Math.max ; import static java.lang.Math.abs ; public class Demo12 { public static void main(String[] args) { System.out.println(max(12, 15)); System. out.println(abs(3-6)); } } 注意： 1、也可以通过import static java.lang.Math.*;导入Math类下所有的静态方法。2、如果将javac设置为了Java5以下，那么静态导入等jdk1.5的特性都会报告错误。 7）新的线程模型和并发库Thread Framework(重要)答： 最主要的就是引入了 java.util.concurrent 包，这个都是需要重点掌握的。 HashMap 的替代者 ConcurrentHashMap 和 ArrayList 的替代者 CopyOnWriteArrayList 在大并发量读取时采用 java.util.concurrent 包里的一些类会让大家满意 BlockingQueue、Callable、Executor、Semaphore 8）内省（Introspector）答：是 Java 语言对 Bean 类属性、事件的一种缺省处理方法。例如类 A 中有属性 name , 那我们通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问name属性，这就是默认的规则。Java 中提供了一套 API 用来访问某个属性的 getter /setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中。 一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来 调用这些方法。 扩展阅读：java Introspector(内省) 的介绍 9）注解（Annotations）答： 注解(Annotation)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从Java5开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。 比如，下面这段代码： @Override public String toString() { return \"This is String.\"; } 上面的代码中，我重写了toString()方法并使用了@Override注解。但是，即使我们不使用@Override注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将toString()写成了toStrring(){double r}，而且我也没有使用@Override注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。 为什么要引入注解？ 使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。 假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。 另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。 目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。 参考文章（更多注解戳这里）:Java注解的理解和应用 10）新增 ProcessBuilder 类答： ProcessBuilder 类是 Java5 在 java.lang 包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由 Process 类处来实现进程的控制管理。每个 ProcessBuilder 实例管理一个进程属性集。它的 start() 方法利用这些属性创建一个新的 Process 实例。start() 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。 ProcessBuilder 是一个 final 类，有两个带参数的构造方法，你可以通过构造方法来直接创建 ProcessBuilder 的对象。而 Process 是一个抽象类，一般都通过 Runtime.exec() 和 ProcessBuilder.start() 来间接创建其实例。ProcessBuilder 为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而 Process 类的功能相对来说简单的多。ProcessBuilder 类不是同步的。如果多个线程同时访问一个 ProcessBuilder，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。 若要使用 ProcessBuilder 创建一个进程，只需要创建 ProcessBuilder 的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的 start() 即可。下面是一个执行打开 Windows 记事本的例子。注意它将要编辑的文件名指定为一个参数。 class PBDemo { public static void main(String args[]) { try { ProcessBuilder proc = new ProcessBuilder(\"notepad.exe\", \"testfile\"); proc.start(); } catch (Exception e) { System.out.println(\"Error executing notepad.\"); } } } 参考文章：Java5新特性及使用 11）新增Formatter格式化器(Formatter)Formatter 类是Java5中新增的 printf-style 格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的 Java 类型，如 byte，java.math.BigDecimal 和 java.util.Calendar 都支持。 通过 java.util.Formattable 接口提供了针对任意用户类型的有限格式定制。 更详细的介绍见这里。主要使用方法的代码示例如下： import java.io.BufferedReader; import java.io.FileReader; import java.text.MessageFormat; import java.text.SimpleDateFormat; import java.util.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * 格式化测试使用的示例类. * * @author blinkfox on 2017-11-28. */ public class FormatTester { private static final Logger log = LoggerFactory.getLogger(FormatTester.class); /** * 格式化. */ private static void formatter() { StringBuilder sb = new StringBuilder(); Formatter formatter = new Formatter(sb, Locale.US); // 可重新排序输出. formatter.format(\"%n%4$2s %3$2s %2$2s %1$2s %n\", \"a\", \"b\", \"c\", \"d\"); // -> \" d c b a\" formatter.format(Locale.FRANCE, \"e = %+10.4f\", Math.E); // -> \"e = +2,7183\" formatter.format(\"%nAmount gained or lost since last statement: $ %(,.2f\", 6217.58); // -> \"Amount gained or lost since last statement: $ 6,217.58\" log.info(\"打印出格式化后的字符串:{}\", formatter); formatter.close(); } /** * printf打印. */ private static void printf() { String filename = \"testfile\"; try (FileReader fileReader = new FileReader(filename)) { BufferedReader reader = new BufferedReader(fileReader); String line; int i = 1; while ((line = reader.readLine()) != null) { System.out.printf(\"Line %d: %s%n\", i++, line); } } catch (Exception e) { System.err.printf(\"Unable to open file named '%s': %s\", filename, e.getMessage()); } } /** * stringFormat使用. */ private static void stringFormat() { // 格式化日期. Calendar c = new GregorianCalendar(1995, Calendar.MAY, 23); String s = String.format(\"Duke's Birthday: %1$tm %1$te,%1$tY\", c); // -> s == \"Duke's Birthday: May 23, 1995\" log.info(s); } /** * 格式化消息. */ private static void messageFormat() { String msg = \"欢迎光临，当前（{0}）等待的业务受理的顾客有{1}位，请排号办理业务！\"; MessageFormat mf = new MessageFormat(msg); String fmsg = mf.format(new Object[]{new Date(), 35}); log.info(fmsg); } /** * 格式化日期. */ private static void dateFormat() { String str = \"2010-1-10 17:39:21\"; SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMddHHmmss\"); try { log.info(\"格式化后的日期:{}\", format.format(format.parse(str))); } catch (Exception e) { log.error(\"日期格式化出错！\", e); } } public static void main(String[] args) { formatter(); stringFormat(); messageFormat(); dateFormat(); printf(); } } 参考文章：Java5新特性及使用 12）新增 Scanner 类（Scanner）java.util.Scanner 是 Java5 的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。 (1).Scanner概述 可以从字符串(Readable)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。 Scanner 默认使用空格作为分割符来分隔文本，但允许你使用 useDelimiter(Pattern pattern) 或 useDelimiter(String pattern) 方法来指定新的分隔符。 主要API如下： delimiter(): 返回此 Scanner 当前正在用于匹配分隔符的 Pattern。 hasNext(): 判断扫描器中当前扫描位置后是否还存在下一段。 hasNextLine(): 如果在此扫描器的输入中存在另一行，则返回true。 next(): 查找并返回来自此扫描器的下一个完整标记。 nextLine(): 此扫描器执行当前行，并返回跳过的输入信息。 (2).扫描控制台输入 当通过 new Scanner(System.in) 创建了一个 Scanner 实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给 Scanner，作为扫描对象。如果要获取输入的内容，则只需要调用 Scanner 的 nextLine() 方法即可。 /** * 扫描控制台输入. * * @author blinkfox 2017-11-28 */ public class ScannerTest { public static void main(String[] args) { Scanner s = new Scanner(System.in); System.out.println(\"请输入字符串：\"); while (true) { String line = s.nextLine(); if (line.equals(\"exit\")) break; System.out.println(\">>>\" + line); } } } (3).其它示例 该示例中会从 myNumbers 文件中读取长整型 long 的数据。 Scanner sc = new Scanner(new File(\"myNumbers\")); while (sc.hasNextLong()) { long aLong = sc.nextLong(); } 以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目： String input = \"1 fish 2 fish red fish blue fish\"; Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\"); System.out.println(s.nextInt()); System.out.println(s.nextInt()); System.out.println(s.next()); System.out.println(s.next()); s.close(); 将输出： 1 2 red blue 参考文章：Java5新特性及使用 13）StringBuilderStringBuilder 也是 Java5 中新增的类，主要用来代替 + 号和 StringBuffer 来更加高效的拼接字符串。StringBuffer 与 StringBuilder 都是继承于 AbstractStringBuilder，主要的区别就是 StringBuffer 的函数上都有 synchronized 关键字，保证线程安全。 关于 StringBuilder 的使用这里就不再详细介绍了，网上文章也有很多。总之，对于动态字符串的拼接推荐使用 StringBuilder。静态字符串的拼接直接使用 + 号或者字符串的 concat(String str) 方法，甚至也使用 StringBuilder 亦可。 参考文章：Java5新特性及使用 （二）Java 6 相关知识点 关于 JDK 1.6 的新特性，了解一下就可以了…如果有兴趣深入研究的童鞋，右转这里：Java6新特性及使用 1）Desktop 类和 SystemTray 类：答： 在JDK6中 ,AWT新增加了两个类:Desktop 和 SystemTray 。 前者可以用来打开系统默认浏览器浏览指定的 URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档; 后者可以用来在系统托盘区创建一个托盘程序. 2）使用 JAXB2 来实现对象与 XML 之间的映射答： JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。 我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。 JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。 实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。 3）理解StAX答： StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。 StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML). 由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本). JDK6里面JAXP的版本就是1.4. 。 StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件，然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 4）使用Compiler API答： 现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。 5）轻量级Http Server API答： JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法. 6）插入式注解处理API(Pluggable Annotation Processing API)答： 插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175) 实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境. JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列. JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。 7）用Console开发控制台程序JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. 8）对脚本语言的支持如: ruby, groovy, javascript. 9）Common annotationsCommon annotations 原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。 10）Java DB(Derby)从 JDK6 开始，JDK 目录中新增了一个名为 db 的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目 Derby。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性 JDBC 4.0 规范(JSR 221)。 11）JDBC 4.0在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。 自动加载 java.sql.Driver，而不需要再调用 class.forName； 添加了 java.sql.RowId 数据类型用来可以访问 sql rowid ； 添加了 National Character Set 的支持； 增强了 BLOB 和 CLOB 的支持功能； SQL/XML 和 XML 支持； Wrapper Pattern； SQLException 增强； Connection 和 Statement 接口增强； New Scalar Funtions； JDBC API changes。 （三）JAVA 7 相关知识点 之前已经写过一篇详细介绍 Java 7 特性的文章了，这里就直接黏了：Java 7新特性 1）Diamond Operator类型判断是一个人特殊的烦恼，入下面的代码： Map&lt;String,List&lt;String>> anagrams = new HashMap&lt;String,List&lt;String>>(); 通过类型推断后变成： Map&lt;String,List&lt;String>> anagrams = new HashMap&lt;>(); 注：这个&lt;&gt;被叫做diamond(钻石)运算符，Java 7后这个运算符从引用的声明中推断类型。 2）在switch语句中使用字符串switch语句可以使用原始类型或枚举类型。Java引入了另一种类型，我们可以在switch语句中使用：字符串类型。 说我们有一个根据其地位来处理贸易的要求。直到现在，我们使用if-其他语句来完成这个任务。 private voidprocessTrade(Trade t){ String status = t.getStatus(); if(status.equalsIgnoreCase(NEW)) { newTrade(t); } else if(status.equalsIgnoreCase(EXECUTE)) { executeTrade(t); } else if(status.equalsIgnoreCase(PENDING)) { pendingTrade(t); } } 这种处理字符串的方法是粗糙的。在Java中，我们可以使用增强的switch语句来改进程序，该语句以String类型作为参数。 public voidprocessTrade(Trade t) { String status = t.getStatus(); switch(status) { caseNEW: newTrade(t); break; caseEXECUTE: executeTrade(t); break; casePENDING: pendingTrade(t); break; default: break; } } 在上面的程序中，状态字段总是通过使用 String.equals() 与案例标签来进行比较。 3）自动资源管理Java中有一些资源需要手动关闭，例如Connections，Files，Input/OutStreams等。通常我们使用 try-finally 来关闭资源： public voidoldTry() { try{ fos= newFileOutputStream(\"movies.txt\"); dos= newDataOutputStream(fos); dos.writeUTF(\"Java 7 Block Buster\"); } catch(IOException e) { e.printStackTrace(); } finally{ try{ fos.close(); dos.close(); } catch(IOException e) { // log the exception } } } 然而，在Java 7中引入了另一个很酷的特性，可以自动管理资源。它的操作也很简单，我们所要做的就是在 try 块中申明资源如下： try(resources_to_be_cleant){ // your code } 以上方法与旧的 try-finally 能最终写成下面的代码： public voidnewTry() { try(FileOutputStream fos = newFileOutputStream(\"movies.txt\"); DataOutputStream dos = newDataOutputStream(fos)) { dos.writeUTF(\"Java 7 Block Buster\"); } catch(IOException e) { // log the exception } } 上面的代码也代表了这个特性的另一个方面：处理多个资源。FileOutputStream 和 DataOutputStream 在try语句中一个接一个地含在语句中，每一个都用分号(;)分隔符分隔开。我们不必手动取消或关闭流，因为当空间存在try块时，它们将自动关闭。 在后台，应该自动关闭的资源必须试验 java.lang.AutoCloseable 接口。 任何实现 AutoCloseable 接口的资源都可以作为自动资源管理的候选。AutoCloseable 是 java.io.Closeable 接口的父类，JVM会在程序退出try块后调用一个方法 close()。 4）带下划线的数字文本数字文字绝对是对眼睛的一种考验。我相信，如果你给了一个数字，比如说，十个零，你就会像我一样数零。如果不计算从右到左的位置，识别一个文字的话，就很容易出错，而且很麻烦。Not anymore。Java在识别位置时引入了下划线。例如，您可以声明1000，如下所示： int thousand = 1_000; 或1000000(一百万)如下: int million = 1_000_000 请注意，这个版本中也引入了二进制文字-例如“0b1”-因此开发人员不必再将它们转换为十六进制。 5）改进的异常处理在异常处理区域有几处改进。Java引入了多个catch功能，以使用单个抓到块捕获多个异常类型。 假设您有一个方法，它抛出三个异常。在当前状态下，您将分别处理它们，如下所示： public voidoldMultiCatch() { try{ methodThatThrowsThreeExceptions(); } catch(ExceptionOne e) { // log and deal with ExceptionOne } catch(ExceptionTwo e) { // log and deal with ExceptionTwo } catch(ExceptionThree e) { // log and deal with ExceptionThree } } 在一个catch块中逐个捕获一个连续的异常，看起来很混乱。我还看到了捕获十几个异常的代码。这是非常低效和容易出错的。Java为解决这只丑小鸭带来了新的语言变化。请参阅下面的方法oldMultiCatch方法的改进版本： public voidnewMultiCatch() { try{ methodThatThrowsThreeExceptions(); } catch(ExceptionOne | ExceptionTwo | ExceptionThree e) { // log and deal with all Exceptions } } 多个异常通过使用 “|” 操作符在一个catch块中捕获。这样，您不必编写数十个异常捕获。但是，如果您有许多属于不同类型的异常，那么您也可以使用“多个catch块”块。下面的代码片段说明了这一点： public voidnewMultiMultiCatch() { try{ methodThatThrowsThreeExceptions(); } catch(ExceptionOne e) { // log and deal with ExceptionOne } catch(ExceptionTwo | ExceptionThree e) { // log and deal with ExceptionTwo and ExceptionThree } } 在上面的例子中，在和ExceptionThree属于不同的层次结构，因此您希望以不同的方式处理它们，但使用一个抓到块。 6）New file system API(NIO 2.0)那些使用Java的人可能还记得框架引起的头痛。在操作系统或多文件系统之间无缝地工作从来都不是一件容易的事情.。有些方法，例如删除或重命名，在大多数情况下都是出乎意料的。使用符号链接是另一个问题。实质上API需要大修。 为了解决上述问题，Java引入了一个新的API，并在许多情况下引入了新的api。 在NIO2.0提出了许多增强功能。在处理多个文件系统时，它还引入了新的类来简化开发人员的生活。 Working With Path（使用路径）： 新的 java.nio.file 由包和接口组成例如：Path,Paths,FileSystem,FileSystems等等。 路径只是对文件路径的简单引用。它与java.io.File等价(并具有更多的特性)。下面的代码段显示了如何获取对“临时”文件夹的路径引用： public voidpathInfo() { Path path= Paths.get(\"c:\\Temp\\temp\"); System.out.println(\"Number of Nodes:\"+ path.getNameCount()); System.out.println(\"File Name:\"+ path.getFileName()); System.out.println(\"File Root:\"+ path.getRoot()); System.out.println(\"File Parent:\"+ path.getParent()); } 最终控制台的输出将是: Number of Nodes:2 File Name:temp.txt File Root:c: File Parent:c:Temp 删除文件或目录就像在文件中调用delete方法(注意复数)一样简单。在类公开两个删除方法，一个抛出NoSuchFileException，另一个不抛。 下面的delete方法调用抛出NoSuchFileException，因此您必须处理它： Files.delete(path); Where as Files.deleteIfExists(path) does not throw exception (as expected) if the file/directory does not exist. 使用 Files.deteleIfExists(path) 则不会抛出异常。 您可以使用其他实用程序方法，例如Files.copy(.)和Files.move(.)来有效地对文件系统执行操作。类似地，使用 createSymbolicLink(..) 方法使用代码创建符号链接。 文件更改通知： JDK 7中最好的改善算是File change notifications（文件更改通知）了。这是一个长期等待的特性，它最终被刻在NIO 2.0中。WatchService API 允许您在对主题(目录或文件)进行更改时接收通知事件。 具体的创建步骤就不给了，总之它的功能就跟它的名字一般，当文件发生更改的时候，能及时作出反馈。 7）Fork and Join（Fork/Join框架）在一个 Java 程序中有效地使用并行内核一直是一个挑战。很少有国内开发的框架将工作分配到多个核心，然后加入它们来返回结果集。Java已经将这个特性作为Fork/Join框架结合了起来。 基本上，在把手头的任务变成了小任务，直到小任务简单到可以不进一步分手的情况下解决。这就像一个分而治之的算法.。在这个框架中需要注意的一个重要概念是，理想情况下，没有工作线程是空闲的。他们实现了一个 work-stealing 算法，在空闲的工人“偷”工作从那些工人谁是忙。 支持Fork-Join机制的核心类是 ForkJoinPool和ForkJoinTask。 什么是Fork/Join框架： Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 Fork/Join的运行流程图如下： 工作窃取算法： 工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下： 工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。 Fork/Join框架使用示例： 让我们通过一个简单的需求来使用下 Fork／Join 框架，需求是：计算1 + 2 + 3 + 4的结果。 使用 Fork/Join 框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以 Fork/Join 框架会把这个任务 fork 成两个子任务，子任务一负责计算1 + 2，子任务二负责计算3 + 4，然后再 join 两个子任务的结果。 因为是有结果的任务，所以必须继承 RecursiveTask ，实现代码如下： import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.Future; import java.util.concurrent.RecursiveTask; /** * CountTask. * * @author blinkfox on 2018-01-03. */ public class CountTask extends RecursiveTask&lt;Integer> { /** 阈值. */ public static final int THRESHOLD = 2; /** 计算的开始值. */ private int start; /** 计算的结束值. */ private int end; /** * 构造方法. * * @param start 计算的开始值 * @param end 计算的结束值 */ public CountTask(int start, int end) { this.start = start; this.end = end; } /** * 执行计算的方法. * * @return int型结果 */ @Override protected Integer compute() { int sum = 0; // 如果任务足够小就计算任务. if ((end - start) &lt;= THRESHOLD) { for (int i = start; i &lt;= end; i++) { sum += i; } } else { // 如果任务大于阈值，就分裂成两个子任务来计算. int middle = (start + end) / 2; CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle + 1, end); // 等待子任务执行完，并得到结果，再合并执行结果. leftTask.fork(); rightTask.fork(); sum = leftTask.join() + rightTask.join(); } return sum; } /** * main方法. * * @param args 数组参数 */ public static void main(String[] args) throws ExecutionException, InterruptedException { ForkJoinPool fkPool = new ForkJoinPool(); CountTask task = new CountTask(1, 4); Future&lt;Integer> result = fkPool.submit(task); System.out.println(\"result:\" + result.get()); } } 参考文章：Java7新特性及使用这里是Java 7的新特性一览表：http://www.oschina.net/news/20119/new-features-of-java-7 （四）Java 8 相关知识点 关于 Java 8 中新知识点，面试官会让你说说 Java 8 你了解多少，下面分享一下我收集的 Java 8 新增的知识点的内容，前排申明引用自：Java8新特性及使用 1）接口默认方法和静态方法Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。 1.接口默认方法 默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子： private interface Defaulable { // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() { return \"Default implementation\"; } } private static class DefaultableImpl implements Defaulable { } private static class OverridableImpl implements Defaulable { @Override public String notRequired() { return \"Overridden implementation\"; } } Defaulable 接口用关键字 default 声明了一个默认方法 notRequired()，Defaulable 接口的实现者之一 DefaultableImpl 实现了这个接口，并且让默认方法保持原样。Defaulable 接口的另一个实现者 OverridableImpl 用自己的方法覆盖了默认方法。 1.1 多重继承的冲突说明： 由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下： 一个声明在类里面的方法优先于任何默认方法 优先选取最具体的实现 public interface A { default void hello() { System.out.println(\"Hello A\"); } } public interface B extends A { default void hello() { System.out.println(\"Hello B\"); } } public class C implements A, B { public static void main(String[] args) { new C().hello(); // 输出 Hello B } } 1.2 优缺点： 优点: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。 缺点: 使得接口作为协议，类作为具体实现的界限开始变得有点模糊。 1.3 接口默认方法不能重载Object类的任何方法： 接口不能提供对Object类的任何方法的默认实现。简单地讲，每一个java类都是Object的子类，也都继承了它类中的 equals()/hashCode()/toString() 方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。 在 JVM 中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到 java.util.Collection 接口中去：stream()，parallelStream()，forEach()，removeIf() 等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。 2.接口静态方法 Java 8 带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用 static 关键字，例如： public interface StaticInterface { static void method() { System.out.println(\"这是Java8接口中的静态方法!\"); } } 下面的一小段代码是上面静态方法的使用。 public class Main { public static void main(String[] args) { StaticInterface.method(); // 输出 这是Java8接口中的静态方法! } } Java 支持一个实现类可以实现多个接口，如果多个接口中存在同样的 static 方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。 2）Lambda 表达式Lambda 表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：行为参数化，函数作为参数传递进方法中）。 一个 Lambda 可以由用逗号分隔的参数列表、–&gt; 符号与函数体三部分表示。 首先看看在老版本的Java中是如何排列字符串的： List&lt;String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\"); Collections.sort(names, new Comparator&lt;String>() { @Override public int compare(String a, String b) { return b.compareTo(a); } }); 只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： Collections.sort(names, (String a, String b) -> { return b.compareTo(a); }); 看到了吧，代码变得更短且更具有可读性，但是实际上还可以写得更短： Collections.sort(names, (String a, String b) -> b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： Collections.sort(names, (a, b) -> b.compareTo(a)); Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。 更多 Lambda 表达式的示例在这里：Java8 lambda表达式10个示例 3）函数式接口Lambda 表达式是如何在 Java 的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而函数式接口是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。 示例如下： @FunctionalInterface interface Converter&lt;F, T> { T convert(F from); } Converter&lt;String, Integer> converter = (from) -> Integer.valueOf(from); Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 注意： 如果 @FunctionalInterface 如果没有指定，上面的代码也是对的。更多参考： Java 8——Lambda表达式、Java8新特性及使用 4）方法引用1.概述： 在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下： Arrays.sort(strArray, (s1, s2) -> s1.compareToIgnoreCase(s2)); 在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。 Arrays.sort(strArray, String::compareToIgnoreCase); 这种特性就叫做方法引用(Method Reference)。 方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。 注意: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。 2.分类： 方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号） 有以下四种形式的方法引用： 引用静态方法: ContainingClass::staticMethodName 引用某个对象的实例方法: containingObject::instanceMethodName 引用某个类型的任意对象的实例方法:ContainingType::methodName 引用构造方法: ClassName::new 3.示例： 使用示例如下： public class Person { String name; LocalDate birthday; public Person(String name, LocalDate birthday) { this.name = name; this.birthday = birthday; } public LocalDate getBirthday() { return birthday; } public static int compareByAge(Person a, Person b) { return a.birthday.compareTo(b.birthday); } @Override public String toString() { return this.name; } } public class MethodReferenceTest { @Test public static void main() { Person[] pArr = new Person[] { new Person(\"003\", LocalDate.of(2016,9,1)), new Person(\"001\", LocalDate.of(2016,2,1)), new Person(\"002\", LocalDate.of(2016,3,1)), new Person(\"004\", LocalDate.of(2016,12,1)) }; // 使用匿名类 Arrays.sort(pArr, new Comparator&lt;Person>() { @Override public int compare(Person a, Person b) { return a.getBirthday().compareTo(b.getBirthday()); } }); //使用lambda表达式 Arrays.sort(pArr, (Person a, Person b) -> { return a.getBirthday().compareTo(b.getBirthday()); }); //使用方法引用，引用的是类的静态方法 Arrays.sort(pArr, Person::compareByAge); } } 5）Steam Java8添加的 Stream API(java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为 Stream API 可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。使用 Steam 写出来的代码真的能让人兴奋，这里链出之前的一篇文章：Java 8——函数式数据处理（流） 流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括filter、map、flatMap、peel、distinct、sorted、limit 和 substream。终止操作包括 forEach、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst 和 findAny。 java.util.stream.Collectors 是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。 1.一些重要方法说明： stream: 返回数据流，集合作为其源 parallelStream: 返回并行数据流， 集合作为其源 filter: 方法用于过滤出满足条件的元素 map: 方法用于映射每个元素对应的结果 forEach: 方法遍历该流中的每个元素 limit: 方法用于减少流的大小 sorted: 方法用来对流中的元素进行排序 anyMatch: 是否存在任意一个元素满足条件（返回布尔值） allMatch: 是否所有元素都满足条件（返回布尔值） noneMatch: 是否所有元素都不满足条件（返回布尔值） collect: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束 2.一些使用示例： 2.1 Filter 过滤： stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);2.2 Sort 排序： stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);2.3 Map 映射： stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);2.4 Match 匹配： boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;)); System.out.println(anyStartsWithA); // true boolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(&quot;a&quot;)); System.out.println(allStartsWithA); // false boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;)); System.out.println(noneStartsWithZ); // true 2.5 Count 计数： long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;b&quot;)) .count(); System.out.println(startsWithB); // 3 2.6 Reduce 规约： Optional&lt;String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -> s1 + \"#\" + s2); reduced.ifPresent(System.out::println); 6）Optional到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。 Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。 Optional&lt;String> fullName = Optional.ofNullable(null); System.out.println(\"Full Name is set? \" + fullName.isPresent()); System.out.println(\"Full Name: \" + fullName.orElseGet(() -> \"[none]\")); System.out.println(fullName.map(s -> \"Hey \" + s + \"!\").orElse(\"Hey Stranger!\")); 如果Optional类的实例为非空值的话，isPresent()返回true，否从返回false。为了防止Optional为空值，orElseGet()方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出： Full Name is set? false Full Name: [none] Hey Stranger! 让我们来看看另一个例子： Optional&lt;String> firstName = Optional.of(\"Tom\"); System.out.println(\"First Name is set? \" + firstName.isPresent()); System.out.println(\"First Name: \" + firstName.orElseGet(() -> \"[none]\")); System.out.println(firstName.map(s -> \"Hey \" + s + \"!\").orElse(\"Hey Stranger!\")); System.out.println(); 下面是程序的输出： First Name is set? true First Name: Tom Hey Tom! 7）Date/Time APIJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： 1.Clock 时钟： Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis()来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。代码如下: Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date 2.Timezones 时区： 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下: System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(\"Europe/Berlin\"); ZoneId zone2 = ZoneId.of(\"Brazil/East\"); System.out.println(zone1.getRules()); System.out.println(zone2.getRules()); // ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00] 3.LocalTime 本地时间： LocalTime定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下: LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下: LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter); System.out.println(leetTime); // 13:37 4.LocalDate 本地日期： LocalDate表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下: LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek(); System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下: DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN); LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter); System.out.println(xmas); // 2014-12-24 5.LocalDateTime 本地日期时间： LocalDateTime同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。代码如下: LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。代码如下: Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下: DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\"); LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 关于Java8中日期API更多的使用示例可以参考Java 8中关于日期和时间API的20个使用示例。 8）重复注解自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。 重复注解机制本身必须用@Repeatable注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子： import java.lang.annotation.ElementType; import java.lang.annotation.Repeatable; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class RepeatingAnnotations { @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Filters { Filter[] value(); } @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Filters.class) public @interface Filter { String value(); }; @Filter(\"filter1\") @Filter(\"filter2\") public interface Filterable { } public static void main(String[] args) { for(Filter filter: Filterable.class.getAnnotationsByType(Filter.class)) { System.out.println(filter.value()); } } } 正如我们看到的，这里有个使用@Repeatable(Filters.class)注解的注解类Filter，Filters仅仅是Filter注解的数组，但Java编译器并不想让程序员意识到Filters的存在。这样，接口Filterable就拥有了两次Filter（并没有提到Filter）注解。 同时，反射相关的API提供了新的函数getAnnotationsByType()来返回重复注解的类型（请注意Filterable.class.getAnnotation(Filters.class)经编译器处理后将会返回Filters的实例）。 9）扩展注解的支持Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子： import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.util.ArrayList; import java.util.Collection; public class Annotations { @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.TYPE_USE, ElementType.TYPE_PARAMETER }) public @interface NonEmpty { } public static class Holder&lt;@NonEmpty T> extends @NonEmpty Object { public void method() throws @NonEmpty Exception { } } @SuppressWarnings(\"unused\") public static void main(String[] args) { final Holder&lt;String> holder = new @NonEmpty Holder&lt;String>(); @NonEmpty Collection&lt;@NonEmpty String> strings = new ArrayList&lt;>(); } } 10）Base 64在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子： import java.nio.charset.StandardCharsets; import java.util.Base64; public class Base64s { public static void main(String[] args) { final String text = \"Base64 finally in Java 8!\"; final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8)); System.out.println(encoded); final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8); System.out.println(decoded); } } 程序在控制台上输出了编码后的字符与解码后的字符： QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ== Base64 finally in Java 8! Base64类同时还提供了对URL、MIME友好的编码器与解码器（Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()）。 11）JavaFXJavaFX是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考JavaFX中文文档。 12）HashMap的底层实现有变化Java8中，HashMap内部实现又引入了红黑树（数组+链表+红黑树），使得HashMap的总体性能相较于Java7有比较明显的提升。 13）JVM内存管理方面，由元空间代替了永久代。区别： 元空间并不在虚拟机中，而是使用本地内存 默认情况下，元空间的大小仅受本地内存限制 也可以通过-XX：MetaspaceSize指定元空间大小 （五）Java 9 相关知识点 引用自文章：Java 9 中的 9 个新特性、Java 9 新特性概述——IBM、【译】使用示例带你提前了解 Java 9 中的新特性 1）Java 9 PEPK（JShell）Oracle 公司（Java Library 开发者）新引进一个代表 Java Shell 的称之为 “jshell” 或者 REPL（Read Evaluate Print Loop）的新工具。该工具可以被用来执行和测试任何 Java 中的结构，如 class，interface，enum，object，statements 等。使用非常简单。 JDK 9 EA（Early Access）下载地址：https://jdk9.java.net/download/ G:\\&gt;jshell | Welcome to JShell -- Version 9-ea | For an introduction type: /help intro jshell&gt; int a = 10 a ==&gt; 10 jshell&gt; System.out.println(&quot;a value = &quot; + a ) a value = 102）集合工厂方法通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法： Set&lt;Integer> ints = Set.of(1, 2, 3); List&lt;String> strings = List.of(\"first\", \"second\"); 除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。 3）接口中的私有方法在 Java 8 中，我们可以在接口中使用默认或者静态方法提供一些实现方式，但是不能创建私有方法。 为了避免冗余代码和提高重用性，Oracle 公司准备在 Java SE 9 接口中引入私有方法。也就是说从 Java SE 9 开始，我们也能够在接口类中使用 ‘private’ 关键字写私有化方法和私有化静态方法。 接口中的私有方法与 class 类中的私有方法在写法上并无差异，如： public interface Card{ private Long createCardID(){ // Method implementation goes here. } private static void displayCardDetails(){ // Method implementation goes here. } } 4）Java 平台级模块系统 这里只给出解决的问题，仅限了解…. Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。 5）进程 APIJava SE 9 迎来一些 Process API 的改进，通过添加一些新的类和方法来优化系统级进程的管控。 Process API 中的两个新接口： java.lang.ProcessHandle java.lang.ProcessHandle.Info Process API 示例 ProcessHandle currentProcess = ProcessHandle.current(); System.out.println(\"Current Process Id: = \" + currentProcess.getPid()); 6）Try With Resources Improvement我们知道，Java SE 7 引入了一个新的异常处理结构：Try-With-Resources，来自动管理资源。这个新的声明结构主要目的是实现“Automatic Better Resource Management”（“自动资源管理”）。 Java SE 9 将对这个声明作出一些改进来避免一些冗长写法，同时提高可读性。 Java SE 7 示例 void testARM_Before_Java9() throws IOException { BufferedReader reader1 = new BufferedReader(new FileReader(\"journaldev.txt\")); try (BufferedReader reader2 = reader1) { System.out.println(reader2.readLine()); } } Java SE 9 示例 void testARM_Java9() throws IOException { BufferedReader reader1 = new BufferedReader(new FileReader(\"journaldev.txt\")); try (reader1) { System.out.println(reader1.readLine()); } } 7）CompletableFuture API Improvements在 Java SE 9 中，Oracle 公司将改进 CompletableFuture API 来解决一些 Java SE 8 中出现的问题。这些被添加的 API 将用来支持一些延时和超时操作，实用方法和更好的子类化。 Executor exe = CompletableFuture.delayedExecutor(50L, TimeUnit.SECONDS); 这里的 delayedExecutor() 是静态实用方法，用来返回一个在指定延时时间提交任务到默认执行器的新 Executor 对象。 8）反应式流 （ Reactive Streams ） 反应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的反应式 库 RxJava 和 R eactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。 Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 F low.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。 9）改进的 Stream API长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代： IntStream.iterate(1, i -> i &lt; 100, i -> i + 1).forEach(System.out::println); 第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。 除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 stram 将一个 Optional 对象转换为一个(可能是空的) Stream 对象： Stream&lt;Integer> s = Optional.of(1).stream(); 在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。 10）HTTP/2Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 HttpURLConnection API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API： HttpClient client = HttpClient.newHttpClient(); HttpRequest req = HttpRequest.newBuilder(URI.create(\"http://www.google.com\")) .header(\"User-Agent\",\"Java\") .GET() .build(); HttpResponse&lt;String> resp = client.send(req, HttpResponse.BodyHandler.asString()); HttpResponse&lt;String&gt; resp = client.send(req, HttpResponse.BodyHandler.asString()); 除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。 11）Optional Class Improvements在 Java SE 9 中，Oracle 公司添加了一些新的实用方法到 java.util.Optional 类里面。这里我将使用一些简单的示例来描述其中的一个：stream 方法。 如果一个值出现在给定 Optional 对象中，stream() 方法可以返回包含该值的一个顺序 Stream 对象。否则，将返回一个空 Stream。 stream() 方法已经被添加，并用来在 Optional 对象中使用，如： Stream&lt;Optional> emp = getEmployee(id) Stream empStream = emp.flatMap(Optional::stream) 这里的 Optional.stream() 方法被用来转化 Employee 可选流对象 到 Employee 流中，如此我们便可以在后续代码中使用这个结果。 12）多版本兼容 JAR我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本： multirelease.jar ├── META-INF │ └── versions │ └── 9 │ └── multirelease │ └── Helper.class ├── multirelease ├── Helper.class └── Main.class 在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(三)——JVM篇","slug":"Java面试知识点解析-三-——JVM篇","date":"2018-05-15T23:01:00.000Z","updated":"2020-12-09T05:05:50.270Z","comments":true,"path":"2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 前序文章链接： Java 面试知识点解析(一)——基础知识篇 Java 面试知识点解析(二)——高并发编程篇 （一）JVM 基础知识 问题和答案都是自行整理的，所以仅供参考！欢迎指正！ 1）Java 是如何实现跨平台的？注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM 答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。 而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。 2）什么是 JVM ？解析：不仅仅是基本概念，还有 JVM 的作用。 答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。 3）JVM 由哪些部分组成？解析：这是对 JVM 体系结构的考察 答：JVM 的结构基本上由 4 部分组成： 类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中 执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU 内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等 本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果 4）类加载器是有了解吗？解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。 答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。 类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 面试官：Java 虚拟机是如何判定两个 Java 类是相同的？ 答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。 5）类加载器是如何加载 class 文件的？答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤： 第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中 第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接 第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等 面试官：能详细讲讲吗？ 答： 1.加载 查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 2.连接 验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： ① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 ② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value = 3; 那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的public static指令是在程序编译后，存放于类构造器 &lt;clinit&gt;（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 ③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。 假设上面的类变量 value 被定义为： public static final int value = 3; 编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 3.初始化 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ① 声明类变量是指定初始值 ② 使用静态代码块为类变量指定初始值 JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 结束生命周期 在如下几种情况下，Java虚拟机将结束生命周期 执行了 System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 参考文章：jvm系列(一):java类的加载机制 - 纯洁的微笑 7）双亲委派模型（Parent Delegation Model）？解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性 答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示： 该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类） 面试官：双亲委派模型的工作过程？ 答： 1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。 每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。 2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。 面试官：为什么这样设计呢？ 解析：这是对于使用这种模型来组织累加器的好处 答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException. 参考文章： JVM 的 工作原理，层次结构 以及 GC工作原理 （二）JVM 内存管理1）JVM 内存划分： 答： 方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。 堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。 程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程； 本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务 2）对象分配规则？答： 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 3）Java 的内存模型：答： Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。 面试官：两个线程之间是如何通信的呢？ 答：在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。 例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤： 1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去 2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。 5）内存屏障？解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：Java内存访问重排序的研究 答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。 面试官：内存屏障为何重要？ 答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。 5）类似-Xms、-Xmn这些参数的含义：答： 堆内存分配： JVM初始分配的内存由-Xms指定，默认是物理内存的1/64 JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4 默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。 因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。 非堆内存分配： JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64； 由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 -Xmn2G：设置年轻代大小为2G。 -XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。 6）内存泄漏和内存溢出答： 概念： 内存溢出指的是内存不够用了。 内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收 内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。 内存泄漏的原因分析： 长生命周期的对象引用短生命周期的对象 没有将无用对象置为null 小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。 7）简述一下 Java 中创建一个对象的过程？解析：回答这个问题首先就要清楚类的生命周期 答：下图展示的是类的生命周期流向： Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。 大致过程如下： 1.检测类是否被加载： 当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。 2.为对象分配内存： 类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。 具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。 对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。 对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。 分配内存的时候也需要考虑线程安全问题，有两种解决方案： 第一种是采用同步的办法，使用CAS来保证操作的原子性。 另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。 3.为分配的内存空间初始化零值： 对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。 4.对对象进行其他设置： 分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。 5.执行 init 方法： 执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。 到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下： 参考文章：Java创建对象的过程简介 面试官：对象的内存布局是怎样的？ 答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。 对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。 实例数据：就是数据啦 对齐填充：不是必然的存在，就是为了对齐的嘛 面试官：对象是如何定位访问的？ 答：对象的访问定位有两种：句柄定位和直接指针 句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。 参考文章：JAVA对象创建的过程 （三）GC 相关1）如何判断一个对象是否已经死去？答： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。 2）垃圾回收算法有哪些？答： 引用计数：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。 标记-清除：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。 复制算法：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。 标记-整理：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。 分代收集算法： 分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。 在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。 参考文章：jvm系列(三):GC算法 垃圾收集器——纯洁的微笑 3）GC什么时候开始？答：GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。 对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快； Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝； 发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。 4）引用的分类？答： 强引用：通过new出来的引用，只要强引用还存在，则不会回收。 软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。 弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。 虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。 扩展阅读：重新认识java（一） —- 万物皆对象 ，文章中有对这四个引用有详细的描述，还有一些典型的应用，这里就不摘过来啦… 5）垃圾收集器？解析：如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现 答： 1. Serial 收集器 串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会 Stop The World（服务暂停） 参数控制： -XX:+UseSerialGC 串行收集器 2.ParNew 收集器 ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 参数控制： -XX:+UseParNewGC ParNew收集器-XX:ParallelGCThreads 限制线程数量 3.Parallel Scavenge收集器 Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩 参数控制： -XX:+UseParallelGC 使用Parallel收集器+ 老年代串行 4.Parallel Old 收集器 Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在 JDK 1.6 中才开始提供 参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 5.CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点: 并发收集、低停顿缺点: 产生大量空间碎片、并发阶段会降低吞吐量 参数控制： -XX:+UseConcMarkSweepGC 使用CMS收集器-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理-XX:ParallelCMSThreads 设定CMS的线程数量（一般情况约等于可用CPU数量） 6.G1收集器 G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。 G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。 收集步骤： 1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark) 2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 参考文章：jvm系列(三):GC算法 垃圾收集器——纯洁的微笑 （四）其他 JVM 相关面试题整理1）64 位 JVM 中，int 的长度是多数？答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。 2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？答：Sun有一个Java System属性来确定JVM的位数：32或64： sun.arch.data.model=32 // 32 bit JVM sun.arch.data.model=64 // 64 bit JVM 我可以使用以下语句来确定 JVM 是 32 位还是 64 位： System.getProperty(\"sun.arch.data.model\") 3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。 4）你能保证 GC 执行吗？答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。 5）怎么获取 Java 程序使用的内存？堆使用的百分比？答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。 6）Java 中堆和栈有什么区别？答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 小结：JVM 是自己之前没有去了解过得知识，所以这次写这篇文章写了很久，也学到了很多东西；在考虑要不要开微信公众号来着… 参考资料： 《深入理解 Java 虚拟机》 《深入分析 Java Web技术内幕》 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(二)——高并发编程篇","slug":"Java面试知识点解析-二-——高并发编程篇","date":"2018-05-09T22:58:00.000Z","updated":"2020-12-09T05:05:39.432Z","comments":true,"path":"2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 前序文章链接： Java 面试知识点解析(一)——基础知识篇 （一）高并发编程基础知识 这里涉及到一些基础的概念，我重新捧起了一下《实战 Java 高并发程序设计》这一本书，感觉到心潮澎湃，这或许就是笔者叙述功底扎实的魅力吧，喜欢。对于并发的基础可以参照一下我之前写过的一篇博文：Java学习笔记（4）——并发基础 1）多线程和单线程的区别和联系？答： 在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。 结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。 面试官：那使用多线程有什么优势？ 解析：尽管面临很多挑战，多线程有一些优点仍然使得它一直被使用，而这些优点我们应该了解。 答： （1）资源利用率更好 想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要： 1| 5秒读取文件A 2| 2秒处理文件A 3| 5秒读取文件B 4| 2秒处理文件B 5| --------------------- 6| 总共需要14秒从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序： 1| 5秒读取文件A 2| 5秒读取文件B + 2秒处理文件A 3| 2秒处理文件B 4| --------------------- 5| 总共需要12秒CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。 总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。 （2）程序设计在某些情况下更简单 在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 （3）程序响应更快 有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单赶快找、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？ 在上面的场景中，可以使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。 多线程还有一些优势也显而易见：① 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。② 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.③ Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程. 2）多线程一定快吗？答：不一定。 比如，我们尝试使用并行和串行来分别执行累加的操作观察是否并行执行一定比串行执行更快： 以下是我测试的结果，可以看出，当不超过1百万的时候，并行是明显比串行要慢的，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。 3）什么是同步？什么又是异步？解析：这是对多线程基础知识的考察 答：同步和异步通常用来形容一次方法调用。 同步方法调用一旦开始，调用者必须等到方法返回后，才能继续后续的行为。这就好像是我们去商城买一台空调，你看中了一台空调，于是就跟售货员下了单，然后售货员就去仓库帮你调配物品，这天你热的实在不行，就催着商家赶紧发货，于是你就在商店里等着，知道商家把你和空调都送回家，一次愉快的购物才结束，这就是同步调用。 而异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。回到刚才买空调的例子，我们可以坐在里打开电脑，在网上订购一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。这就是异步调用。 面试官：那并发（Concurrency）和并行（Parallelism）的区别呢？ 解析：并行性和并发性是既相似又有区别的两个概念。 答：并行性是指两个或多个事件在同一时刻发生。而并发性是指连个或多个事件在同一时间间隔内发生。 在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机环境下（一个处理器），每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。例如，在1秒钟时间内，0-15ms程序A运行；15-30ms程序B运行；30-45ms程序C运行；45-60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。 如果在计算机系统中有多个处理机，这些可以并发执行的程序就可以被分配到多个处理机上，实现并发执行，即利用每个处理机处理一个可并发执行的程序。这样，多个程序便可以同时执行。以此就能提高系统中的资源利用率，增加系统的吞吐量。 4）线程和进程的区别：（必考）答： 进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位； 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）； 线程上下文的切换比进程上下文切换要快很多。 （1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。 （2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。 面试官：进程间如何通讯？线程间如何通讯？ 答：进程间通讯依靠 IPC 资源，例如管道（pipes）、套接字（sockets）等； 线程间通讯依靠 JVM 提供的 API，例如 wait()、notify()、notifyAll() 等方法，线程间还可以通过共享的主内存来进行值的传递。 关于线程和进程有一篇写得非常不错的文章，不过是英文的，我进行了翻译，相信阅读之后会对进程和线程有不一样的理解：线程和进程基础——翻译文 5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？答：阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个而资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。 非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。 面试官：临界区是什么？ 答：临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。 比如，在一个办公室里有一台打印机，打印机一次只能执行一个任务。如果小王和小明同时需要打印文件，很显然，如果小王先下发了打印任务，打印机就开始打印小王的文件了，小明的任务就只能等待小王打印结束后才能打印，这里的打印机就是一个临界区的例子。 在并行程序中，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务，那么最可能的结果就是打印出来的文件就会是损坏的文件，它既不是小王想要的，也不是小明想要的。 6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？答：死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。 死锁应该是最糟糕的一种情况了，它表示两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：1）它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。在自然界中，母鸡喂食雏鸟时，很容易出现这种情况，由于雏鸟很多，食物有限，雏鸟之间的食物竞争可能非常厉害，小雏鸟因为经常抢不到食物，有可能会被饿死。线程的饥饿也非常类似这种情况。2）另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行） 活锁是一种非常有趣的情况。不知道大家是不是有遇到过这样一种情况，当你要坐电梯下楼，电梯到了，门开了，这时你正准备出去，但不巧的是，门外一个人挡着你的去路，他想进来。于是你很绅士的靠左走，避让对方，但同时对方也很绅士，但他靠右走希望避让你。结果，你们又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右走，他也立即向左走，结果又撞上了！不过介于人类的只能，我相信这个动作重复 2、 3 次后，你应该可以顺利解决这个问题，因为这个时候，大家都会本能的对视，进行交流，保证这种情况不再发生。但如果这种情况发生在两个线程间可能就不会那么幸运了，如果线程的智力不够，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有的资源而正常执行。这种情况就是活锁。 7）多线程产生死锁的 4 个必要条件？答： 互斥条件：一个资源每次只能被一个线程使用； 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺； 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 面试官：如何避免死锁？（经常接着问这个问题哦~） 答：指定获取锁的顺序，举例如下： 比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？ 获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！ 8）如何指定多个线程的执行顺序？解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现） 答： 设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。 在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。 9）Java 中线程有几种状态？答：六种（查看 Java 源码也可以看到是 6 种），并且某个时刻 Java 线程只能处于其中的一个状态。 新建（NEW）状态：表示新创建了一个线程对象，而此时线程并没有开始执行。 可运行（RUNNABLE）状态：线程对象创建后，其它线程（比如 main 线程）调用了该对象的 start() 方法，才表示线程开始执行。当线程执行时，处于 RUNNBALE 状态，表示线程所需的一切资源都已经准备好了。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。 阻塞（BLOCKED）状态：如果线程在执行过程终于到了 synchronized 同步块，就会进入 BLOCKED 阻塞状态，这时线程就会暂停执行，直到获得请求的锁。 等待（WAITING）状态：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况； 计时等待（TIMED_WAITING）状态：Object.wait、Thread.join、Lock.tryLock和Condition.await 等方法有超时参数，还有 Thread.sleep 方法、LockSupport.parkNanos 方法和 LockSupport.parkUntil 方法，这些方法会导致线程进入计时等待状态，如果超时或者出现通知，都会切换会可运行状态； 终止（TERMINATED）状态：当线程执行完毕，则进入该状态，表示结束。 注意：从 NEW 状态出发后，线程不能再回到 NEW 状态，同理，处于 TERMINATED 状态的线程也不能再回到 RUNNABLE 状态。 （二）高并发编程-JUC 包 在 Java 5.0 提供了 java.util.concurrent（简称 JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。 1）sleep( ) 和 wait( n)、wait( ) 的区别：答： sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）； wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。 2）synchronized 关键字：答：底层实现： 进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1； 当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。 含义：（monitor 机制） Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。 该关键字是一个几种锁的封装。 3）volatile 关键字：答：该关键字可以保证可见性不保证原子性。 功能： 主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性； 禁止 JVM 进行的指令重排序。 解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。 4）volatile 能使得一个非原子操作变成原子操作吗？答：能。 一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。 面试官：volatile 修饰符的有过什么实践？ 答： 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。 volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 5）ThreadLocal（线程局部变量）关键字：答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。 ThreadLocal 内部实现机制： 每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程； Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系； Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。 6）线程池有了解吗？（必考）答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态： 当前线程池大小 ：表示线程池中实际工作者线程的数量； 最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限； 核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队； 如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程； 如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。 面试官：我们为什么要使用线程池？ 答： 减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机） 面试官：核心线程池内部实现了解吗？ 答：对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。 为何 ThreadPoolExecutor 有如此强大的功能呢？我们可以来看一下 ThreadPoolExecutor 最重要的构造函数： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)函数的参数含义如下： corePoolSize：指定了线程池中的线程数量 maximumPoolSize：指定了线程池中的最大线程数量 keepAliveTime：当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过了 corePoolSize 的空闲线程，在多长时间内，会被销毁。 unit: keepAliveTime 的单位。 workQueue：任务队列，被提交但尚未被执行的任务。 threadFactory：线程工厂，用于创建线程，一般用默认的即可。 handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。 7）Atomic关键字：答：可以使基本数据类型以原子的方式实现自增自减等操作。参考博客：concurrent.atomic包下的类AtomicInteger的使用 8）创建线程有哪几种方式？答：有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象;二是直接继承Thread类。 面试官：两种方式有什么区别呢？ 继承方式: （1）Java中类是单继承的,如果继承了Thread了,该类就不能再有其他的直接父类了. （2）从操作上分析,继承方式更简单,获取线程名字也简单.(操作上,更简单) （3）从多线程共享同一个资源上分析,继承方式不能做到. 实现方式: （1）Java中类可以多实现接口,此时该类还可以继承其他类,并且还可以实现其他接口(设计上,更优雅). （2）从操作上分析,实现方式稍微复杂点,获取线程名字也比较复杂,得使用Thread.currentThread()来获取当前线程的引用. （3）从多线程共享同一个资源上分析,实现方式可以做到(是否共享同一个资源). 9）run() 方法和 start() 方法有什么区别？答：start() 方法会新建一个线程并让这个线程执行 run() 方法；而直接调用 run() 方法知识作为一个普通的方法调用而已，它只会在当前线程中，串行执行 run() 中的代码。 10）你怎么理解线程优先级？答：Java 中的线程可以有自己的优先级。优先极高的线程在竞争资源时会更有优势，更可能抢占资源，当然，这只是一个概率问题。如果运行不好，高优先级线程可能也会抢占失败。 由于线程的优先级调度和底层操作系统有密切的关系，在各个平台上表现不一，并且这种优先级产生的后果也可能不容易预测，无法精准控制，比如一个低优先级的线程可能一直抢占不到资源，从而始终无法运行，而产生饥饿（虽然优先级低，但是也不能饿死它啊）。因此，在要求严格的场合，还是需要自己在应用层解决线程调度的问题。 在 Java 中，使用 1 到 10 表示线程优先级，一般可以使用内置的三个静态标量表示： public final static int MIN_PRIORITY = 1; public final static int NORM_PRIORITY = 5; public final static int MAX_PRIORITY = 10;数字越大则优先级越高，但有效范围在 1 到 10 之间，默认的优先级为 5 。 11）在 Java 中如何停止一个线程？答：Java 提供了很丰富的 API 但没有为停止线程提供 API 。 JDK 1.0 本来有一些像 stop()，suspend() 和 resume() 的控制方法但是由于潜在的死锁威胁因此在后续的 JDK 版本中他们被弃用了，之后 Java API 的设计者就没有提供一个兼容且线程安全的方法来停止任何一个线程。 当 run() 或者 call() 方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run() 方法的循环或者是取消任务来中断线程。 12）多线程中的忙循环是什么？答：忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(),sleep() 或yield() 它们都放弃了 CPU 控制权，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。 在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存，为了避免重建缓存和减少等待重建的时间就可以使用它了。 13）10 个线程和 2 个线程的同步代码，哪个更容易写？答：从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。 14）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？答：wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码： // The standard idiom for using the wait method synchronized (obj) { while (condition does not hold) obj.wait(); // (Releases lock, and reacquires on wakeup) ... // Perform action appropriate to condition }参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。 15）什么是多线程环境下的伪共享（false sharing）？答：伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示： 伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。 16）用 wait-notify 写一段代码来解决生产者-消费者问题？解析：这是常考的基础类型的题，只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。 答： import java.util.Vector; import java.util.logging.Level; import java.util.logging.Logger; /** * Java program to solve Producer Consumer problem using wait and notify * method in Java. Producer Consumer is also a popular concurrency design pattern. * * @author Javin Paul */ public class ProducerConsumerSolution { public static void main(String args[]) { Vector sharedQueue = new Vector(); int size = 4; Thread prodThread = new Thread(new Producer(sharedQueue, size), &quot;Producer&quot;); Thread consThread = new Thread(new Consumer(sharedQueue, size), &quot;Consumer&quot;); prodThread.start(); consThread.start(); } } class Producer implements Runnable { private final Vector sharedQueue; private final int SIZE; public Producer(Vector sharedQueue, int size) { this.sharedQueue = sharedQueue; this.SIZE = size; } @Override public void run() { for (int i = 0; i &lt; 7; i++) { System.out.println(&quot;Produced: &quot; + i); try { produce(i); } catch (InterruptedException ex) { Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex); } } } private void produce(int i) throws InterruptedException { // wait if queue is full while (sharedQueue.size() == SIZE) { synchronized (sharedQueue) { System.out.println(&quot;Queue is full &quot; + Thread.currentThread().getName() + &quot; is waiting , size: &quot; + sharedQueue.size()); sharedQueue.wait(); } } // producing element and notify consumers synchronized (sharedQueue) { sharedQueue.add(i); sharedQueue.notifyAll(); } } } class Consumer implements Runnable { private final Vector sharedQueue; private final int SIZE; public Consumer(Vector sharedQueue, int size) { this.sharedQueue = sharedQueue; this.SIZE = size; } @Override public void run() { while (true) { try { System.out.println(&quot;Consumed: &quot; + consume()); Thread.sleep(50); } catch (InterruptedException ex) { Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex); } } } private int consume() throws InterruptedException { // wait if queue is empty while (sharedQueue.isEmpty()) { synchronized (sharedQueue) { System.out.println(&quot;Queue is empty &quot; + Thread.currentThread().getName() + &quot; is waiting , size: &quot; + sharedQueue.size()); sharedQueue.wait(); } } // Otherwise consume element and notify waiting producer synchronized (sharedQueue) { sharedQueue.notifyAll(); return (Integer) sharedQueue.remove(0); } } } Output: Produced: 0 Queue is empty Consumer is waiting , size: 0 Produced: 1 Consumed: 0 Produced: 2 Produced: 3 Produced: 4 Produced: 5 Queue is full Producer is waiting , size: 4 Consumed: 1 Produced: 6 Queue is full Producer is waiting , size: 4 Consumed: 2 Consumed: 3 Consumed: 4 Consumed: 5 Consumed: 6 Queue is empty Consumer is waiting , size: 017）用 Java 写一个线程安全的单例模式（Singleton）？解析：有多种方法，但重点掌握的是双重校验锁。 答： 1.饿汉式单例 饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码： public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }2.加入 synchronized 的懒汉式单例 所谓懒汉式单例模式就是在调用的时候才去创建这个实例，我们在对外的创建实例方法上加如 synchronized 关键字保证其在多线程中很好的工作： public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3.使用静态内部类的方式创建单例 这种方式利用了 classloder 的机制来保证初始化 instance 时只有一个线程，它跟饿汉式的区别是：饿汉式只要 Singleton 类被加载了，那么 instance 就会被实例化（没有达到 lazy loading 的效果），而这种方式是 Singleton 类被加载了，instance 不一定被初始化。只有显式通过调用 getInstance() 方法时才会显式装载 SingletonHoder 类，从而实例化 singleton public class Singleton { private Singleton() { } private static class SingletonHolder {// 静态内部类 private static Singleton singleton = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.singleton; } }4.双重校验锁 为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下： public class Singleton { private volatile static Singleton singleton; private Singleton() { } public static Singleton getInstance(){ if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 这种是用双重判断来创建一个单例的方法，那么我们为什么要使用两个if判断这个对象当前是不是空的呢 ？因为当有多个线程同时要创建对象的时候，多个线程有可能都停止在第一个if判断的地方，等待锁的释放，然后多个线程就都创建了对象，这样就不是单例模式了，所以我们要用两个if来进行这个对象是否存在的判断。 5.使用 static 代码块实现单例 静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。 public class Singleton{ private static Singleton instance = null; private Singleton(){} static{ instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 6.使用枚举数据类型实现单例模式 枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例： public class ClassFactory{ private enum MyEnumSingleton{ singletonFactory; private MySingleton instance; private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化 instance = new MySingleton(); } public MySingleton getInstance(){ return instance; } } public static MySingleton getInstance(){ return MyEnumSingleton.singletonFactory.getInstance(); } } 小结：关于 Java 中多线程编程，线程安全等知识一直都是面试中的重点和难点，还需要熟练掌握。 参考资料：① 知名互联网公司校招 Java 开发岗面试知识点解析② 最近5年133个Java面试问题列表③ 《实战 Java 高并发程序设计 —— 葛一鸣 郭超 编著》 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Java面试知识点解析(一)——基础知识篇","slug":"Java面试知识点解析-一-基础知识篇","date":"2018-05-08T22:57:00.000Z","updated":"2020-12-09T05:06:00.264Z","comments":true,"path":"2018/05/09/java-mian-shi-zhi-shi-dian-jie-xi-yi-ji-chu-zhi-shi-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/05/09/java-mian-shi-zhi-shi-dian-jie-xi-yi-ji-chu-zhi-shi-pian/","excerpt":"","text":"前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 （一）Java 基础知识点1）面向对象的特性有哪些？答：封装、继承和多态（应要多算一个那就是抽象） 封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。但封装不仅仅是 private + getter/setter ，使用封装可以对 setter 进行更深层次的定制，例如你可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。使用封装不仅仅安全，更可以简化操作。（封装扩展阅读：oc面向对象三大特性之一 &lt;封装&gt;） 继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。继承的缺点：1）继承是一种强耦合关系，父类变子类也必须变；2）继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。 多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。 多态的条件：1）继承；2）重写；3）向上转型。多态的好处：当把不同的子类对象都当作父类类型来看，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。（多态扩展阅读：重新认识java（五） —- 面向对象之多态（向上转型与向下转型）） 抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。 2）面向对象和面向过程的区别？答：面向过程是一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程，即先干啥，后干啥。 面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。 面向过程的缺陷：向过程的设计,是采用置顶而下的设计方式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。 问题：1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。 面向对象是一种基于面向过程的新的编程思想，是一种站在对象的角度思考问题的思想，我们把多个功能合理的放到不同对象里，强调的是具备某些功能的对象。 面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。 注意： 不要粗浅的认为面向对象一定就优于面向过程的设计 看到知乎上有一句有意思的话： 你的程序要完成一个任务，相当于讲一个故事。 面向过程：编年体；面向对象：纪传体。 而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。 扩展阅读：面向过程 VS 面向对象 3）JDK 和 JRE 的区别是什么？解析：这是考察一些基本的概念 答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。 还有其他的一些名词也可以再看一下： 4）Java 中覆盖和重载是什么意思？解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。 答：覆盖（Override）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。 重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。 面试官： 那么构成重载的条件有哪些？ 答：参数类型不同、参数个数不同、参数顺序不同。 面试官： 函数的返回值不同可以构成重载吗？为什么？ 答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下： 如下两个方法： void f(){} int f(){ return 1; } 只要编译器可以根据语境明确判断出语义，比如在 int x = f(); 中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用” ），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用： f(); 此时 Java 如何才能判断调用的是哪一个 f() 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。 5）抽象类和接口的区别有哪些？答： 抽象类中可以没有抽象方法；接口中的方法必须是抽象方法； 抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。 抽象类只能单继承，接口可以继承多个父接口； Java 8 中接口中会有 default 方法，即方法可以被实现。 面试官：抽象类和接口如何选择？ 答： 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。 如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。 6）Java 和 C++ 的区别：解析：虽然我们不太懂C++，但是就是会这么问，尤其是三面（总监级别）面试中。 答： 都是面向对象的语言，都支持封装、继承和多态 指针：Java不提供指针来直接访问内存，程序更加安全 继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承 内存： Java有自动内存管理机制，不需要程序员手动释放无用内存 7）“static” 关键字是什么意思？答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？ 答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。 扩展阅读：重新认识java（六） —- java中的另类：static关键字（附代码块知识） 8）Java 是值传递还是引用传递？解析：这类题目，面试官会手写一个例子，让你说出函数执行结果。 答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为，Java 内的传递都是值传递.，Java 中实例对象的传递是引用传递，Java 是值传递的！ 我们先来看一个例子： 这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？ 这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。 再来看一个例子： 我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？ 你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！ 9）JDK 中常用的包有哪些？答：java.lang、java.util、java.io、java.net、java.sql。 10）JDK，JRE 和 JVM 的联系和区别？答：JDK 是 Java 开发工具包，是 Java 开发环境的核心组件，并提供编译、调试和运行一个 Java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。 JRE 是 Java 运行时环境，是 JVM 的实施实现，提供了运行 Java 程序的平台。JRE 包含了 JVM，但是不包含 Java 编译器 / 调试器之类的开发工具。 JVM 是 Java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。 这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因。 区别： &emsp;&emsp;1. JDK 用于开发，JRE 用于运行 Java 程序；&emsp;&emsp;2. JDK 和 JRE 中都包含 JVM；&emsp;&emsp;3. JVM 是 Java 编程语言的核心并且具有平台独立性。 11）Integer 的缓存机制解析：考察的是对源码的熟悉程度 看一个例子： 第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。 第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。 第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。 我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。 跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的，了解就行了，不必去深究。） 12）下述两种方法分别创建了几个 Sring 对象？// 第一种：直接赋一个字面量 String str1 = \"ABCD\"; // 第二种：通过构造器创建 String str2 = new String(\"ABCD\"); 解析：考察的是对 String 对象和 JVM 内存划分的知识。 答：String str1 = &quot;ABCD&quot;;最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用. String str2 = new String(&quot;ABCD&quot;);最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。 我们来看图理解一下： 当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD 当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。 String 对象是一个特殊的存在，需要注意的知识点也比较多，这里给一个之前写的 String 详解的文章链接：传送门 其中包含的问题大概有：1）“+” 怎么连接字符串；2）字符串的比较；3）StringBuilder/StringBuffer/String 的区别； 13）i++ 与 ++i 到底有什么不同？解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，前置++和后置++一样，在参与运算之前都会将变量的值加 1 答：实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。 14）交换变量的三种方式答： 第一种：通过第三个变量 public class Test{ public static void main(String[] args) { int x = 5; int y = 10; swap(x,y); System.out.println(x); System.out.println(y); Value v = new Value(5,10); swap(v); System.out.println(v.x); System.out.println(v.y); } // 无效的交换：形参的改变无法反作用于实参 public static void swap(int x,int y) { int temp = x; x = y; y = temp; } // 有效的交换：通过引用（变量指向一个对象）来修改成员变量 public static void swap(Value value) { int temp = value.x; value.x = value.y; value.y = temp; } } class Value{ int x; int y; public Value(int x,int y) { this.x = x; this.y = y; } } 输出的结果：510105 这有点类似于C/C++语言中的指针，不过相对来说更加安全。 事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。 第二种：通过通过相加的方式（相同的 Value 类不再重复展示） public class Test{ public static void main(String[] args) { Value v1 = new Value(5,10); swap(v1); System.out.println(\"v1交换之后的结果为：\"); System.out.println(v1.x); System.out.println(v1.y); } public static void swap(Value v) { v.x = v.x + v.y; v.y = v.x - v.y; v.x = v.x - v.y; } } 输出的结果：v1的交换结果：105 核心的算法就是swap方法: v.x = v.x + v.y; // 把v.x与v.y的和存储在v.x中 v.y = v.x - v.y; // v.x减掉v.y本来的值即为v.x v.x = v.x - v.y; // v.x减掉v.y的值也就是以前x.y的值 这样就可以不通过临时变量，来达到交换两个变量的目的，如果觉得上面的方法不太容易理解，我们也可以用另一个参数z来表示上述过程： int z = v.x + v.y; // 把v.x与v.y的和存储在z中 v.y = z - v.y; // z减掉以前的v.y就等于v.x v.x = z - v.y; // z减掉现在的v.y即以前的v.x，即为v.y 但并不推荐这种做法，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。 第三种：通过异或的方式： 位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：（x ^ y ^ y） == x这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值： public class Test{ public static void main(String[] args) { Value v1 = new Value(5,10); swap(v1); System.out.println(\"v1交换之后的结果为：\"); System.out.println(v1.x); System.out.println(v1.y); } public static void swap(Value v) { v.x = v.x ^ v.y; v.y = v.x ^ v.y; v.x = v.x ^ v.y; } } 输出的结果：v1交换之后的结果为：105 跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。异或的方法比相加更加可取的地方在于，异或不存在数据溢出。 15）Java 对象初始化顺序？答：不考虑静态成员的初始化，调用一个对象的构造函数时，程序先调用父类的构造函数（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；最后调用自身构造函数。 我们可以写一段程序来对初始化顺序进行一个简单的验证： public class Derive extends Base { private Member m1 = new Member(\"Member 1\"); { System.out.println(\"Initial Block()\"); } public Derive() { System.out.println(\"Derive()\"); } private Member m2 = new Member(\"Member 2\"); private int i = getInt(); private int getInt() { System.out.println(\"getInt()\"); return 2; } public static void main(String[] args) { new Derive(); } } class Base { public Base() { System.out.println(\"Base()\"); } } class Member { public Member(String m) { System.out.println(\"Member() \"+m); } } 程序的输出结果是：Base()Member() Member 1Initial Block()Member() Member 2getInt()Derive() 16）true、false 与 null 是关键字吗？答：不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。 面试官：那 goto 与 const 呢？ 答：是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。 17）exception 和 error 有什么区别？答：exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。 exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 18）throw 和 throws 有什么区别？答：throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 小结：本节主要阐述了 Java 基础知识，并没有涉及到一些高级的特性，这些问题一般难度不大，适当复习下，应该没问题。 （二）Java 中常见集合集合这方面的考察相当多，这部分是面试中必考的知识点。 1）说说常见的集合有哪些吧？答：Map接口和Collection接口是所有集合框架的父接口： Collection接口的子接口包括：Set接口和List接口 Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等 Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等 List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等 2）HashMap和Hashtable的区别有哪些？（必问）答： HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的； 前者允许null作为Key；后者不允许null作为Key 3）HashMap的底层实现你知道吗？答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析： 4）ConcurrentHashMap 和 Hashtable 的区别？（必问） 答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶。 面试官：ConcurrentHashMap的具体实现知道吗？ 答： 1. 该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色； 2. Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。 5）HashMap 的长度为什么是2的幂次方？答： 1. 通过将 Key 的 hash 值与 length - 1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率 2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 6）List和Set的区别是啥？答：List元素是有序的，可以重复；Set元素是无序的，不可以重复。 7）List、Set和Map的初始容量和加载因子：答： 1. List ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。 Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。 2. Set HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32 3. Map HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32 8）Comparable接口和Comparator接口有什么区别？答： 1. 前者简单，但是如果需要重新定义比较类型时，需要修改源代码。 2. 后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 具体解析参考博客：Java集合框架—Set 9）Java集合的快速失败机制 “fail-fast”答： 是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。 例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 1. 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。 2. 使用CopyOnWriteArrayList来替换ArrayList 10）ArrayList 和 Vector 的区别答： 这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。 ArrayList 与 Vector 的区别主要包括两个方面： 同步性：Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 数据增长：ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。 面试官：那 ArrayList 和 LinkedList 的区别呢？ 答： LinkedList 实现了 List 和 Deque 接口，一般称为双向链表； LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高； LinkedList 比 ArrayList 需要更多的内存； 面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？ 答：它们的区别是： Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 Array 大小是固定的，ArrayList 的大小是动态变化的。 ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 11）如何去掉一个 Vector 集合中重复的元素？答： Vector newVector = new Vector(); for (int i = 0; i &lt; vector.size(); i++) { Object obj = vector.get(i); if (!newVector.contains(obj)) { newVector.add(obj); } } 还有一种简单的方式，利用了 Set 不允许重复元素的特性： HashSet set = new HashSet(vector); 小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。 12）如何权衡是使用无序的数组还是有序的数组？答：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 总结oh…..复习下来还真是酸爽….前路漫漫啊…. 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料 前言： 在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：知名互联网公司校招 Java 开发岗面试知识点解析 ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。 （一）Java 基础知识点1）面向对象的特性有哪些？答：封装、继承和多态（应要多算一个那就是抽象） 封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。但封装不仅仅是 private + getter/setter ，使用封装可以对 setter 进行更深层次的定制，例如你可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。使用封装不仅仅安全，更可以简化操作。（封装扩展阅读：oc面向对象三大特性之一 &lt;封装&gt;） 继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。继承的缺点：1）继承是一种强耦合关系，父类变子类也必须变；2）继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。 多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。 多态的条件：1）继承；2）重写；3）向上转型。多态的好处：当把不同的子类对象都当作父类类型来看，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。（多态扩展阅读：重新认识java（五） —- 面向对象之多态（向上转型与向下转型）） 抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。 2）面向对象和面向过程的区别？答：面向过程是一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程，即先干啥，后干啥。 面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。 面向过程的缺陷：向过程的设计,是采用置顶而下的设计方式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。 问题：1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。 面向对象是一种基于面向过程的新的编程思想，是一种站在对象的角度思考问题的思想，我们把多个功能合理的放到不同对象里，强调的是具备某些功能的对象。 面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。 注意： 不要粗浅的认为面向对象一定就优于面向过程的设计 看到知乎上有一句有意思的话： 你的程序要完成一个任务，相当于讲一个故事。 面向过程：编年体；面向对象：纪传体。 而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。 扩展阅读：面向过程 VS 面向对象 3）JDK 和 JRE 的区别是什么？解析：这是考察一些基本的概念 答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。 还有其他的一些名词也可以再看一下： 4）Java 中覆盖和重载是什么意思？解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。 答：覆盖（Override）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。 重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。 面试官： 那么构成重载的条件有哪些？ 答：参数类型不同、参数个数不同、参数顺序不同。 面试官： 函数的返回值不同可以构成重载吗？为什么？ 答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下： 如下两个方法： void f(){} int f(){ return 1; } 只要编译器可以根据语境明确判断出语义，比如在 int x = f(); 中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用” ），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用： f(); 此时 Java 如何才能判断调用的是哪一个 f() 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。 5）抽象类和接口的区别有哪些？答： 抽象类中可以没有抽象方法；接口中的方法必须是抽象方法； 抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。 抽象类只能单继承，接口可以继承多个父接口； Java 8 中接口中会有 default 方法，即方法可以被实现。 面试官：抽象类和接口如何选择？ 答： 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。 如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。 6）Java 和 C++ 的区别：解析：虽然我们不太懂C++，但是就是会这么问，尤其是三面（总监级别）面试中。 答： 都是面向对象的语言，都支持封装、继承和多态 指针：Java不提供指针来直接访问内存，程序更加安全 继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承 内存： Java有自动内存管理机制，不需要程序员手动释放无用内存 7）“static” 关键字是什么意思？答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？ 答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。 扩展阅读：重新认识java（六） —- java中的另类：static关键字（附代码块知识） 8）Java 是值传递还是引用传递？解析：这类题目，面试官会手写一个例子，让你说出函数执行结果。 答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 一般认为，Java 内的传递都是值传递.，Java 中实例对象的传递是引用传递，Java 是值传递的！ 我们先来看一个例子： 这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？ 这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。 再来看一个例子： 我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？ 你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！ 9）JDK 中常用的包有哪些？答：java.lang、java.util、java.io、java.net、java.sql。 10）JDK，JRE 和 JVM 的联系和区别？答：JDK 是 Java 开发工具包，是 Java 开发环境的核心组件，并提供编译、调试和运行一个 Java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。 JRE 是 Java 运行时环境，是 JVM 的实施实现，提供了运行 Java 程序的平台。JRE 包含了 JVM，但是不包含 Java 编译器 / 调试器之类的开发工具。 JVM 是 Java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。 这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因。 区别： &emsp;&emsp;1. JDK 用于开发，JRE 用于运行 Java 程序；&emsp;&emsp;2. JDK 和 JRE 中都包含 JVM；&emsp;&emsp;3. JVM 是 Java 编程语言的核心并且具有平台独立性。 11）Integer 的缓存机制解析：考察的是对源码的熟悉程度 看一个例子： 第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。 第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。 第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。 我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。 跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的，了解就行了，不必去深究。） 12）下述两种方法分别创建了几个 Sring 对象？// 第一种：直接赋一个字面量 String str1 = \"ABCD\"; // 第二种：通过构造器创建 String str2 = new String(\"ABCD\"); 解析：考察的是对 String 对象和 JVM 内存划分的知识。 答：String str1 = &quot;ABCD&quot;;最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用. String str2 = new String(&quot;ABCD&quot;);最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。 我们来看图理解一下： 当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD 当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。 String 对象是一个特殊的存在，需要注意的知识点也比较多，这里给一个之前写的 String 详解的文章链接：传送门 其中包含的问题大概有：1）“+” 怎么连接字符串；2）字符串的比较；3）StringBuilder/StringBuffer/String 的区别； 13）i++ 与 ++i 到底有什么不同？解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，前置++和后置++一样，在参与运算之前都会将变量的值加 1 答：实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。 14）交换变量的三种方式答： 第一种：通过第三个变量 public class Test{ public static void main(String[] args) { int x = 5; int y = 10; swap(x,y); System.out.println(x); System.out.println(y); Value v = new Value(5,10); swap(v); System.out.println(v.x); System.out.println(v.y); } // 无效的交换：形参的改变无法反作用于实参 public static void swap(int x,int y) { int temp = x; x = y; y = temp; } // 有效的交换：通过引用（变量指向一个对象）来修改成员变量 public static void swap(Value value) { int temp = value.x; value.x = value.y; value.y = temp; } } class Value{ int x; int y; public Value(int x,int y) { this.x = x; this.y = y; } } 输出的结果：510105 这有点类似于C/C++语言中的指针，不过相对来说更加安全。 事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。 第二种：通过通过相加的方式（相同的 Value 类不再重复展示） public class Test{ public static void main(String[] args) { Value v1 = new Value(5,10); swap(v1); System.out.println(\"v1交换之后的结果为：\"); System.out.println(v1.x); System.out.println(v1.y); } public static void swap(Value v) { v.x = v.x + v.y; v.y = v.x - v.y; v.x = v.x - v.y; } } 输出的结果：v1的交换结果：105 核心的算法就是swap方法: v.x = v.x + v.y; // 把v.x与v.y的和存储在v.x中 v.y = v.x - v.y; // v.x减掉v.y本来的值即为v.x v.x = v.x - v.y; // v.x减掉v.y的值也就是以前x.y的值 这样就可以不通过临时变量，来达到交换两个变量的目的，如果觉得上面的方法不太容易理解，我们也可以用另一个参数z来表示上述过程： int z = v.x + v.y; // 把v.x与v.y的和存储在z中 v.y = z - v.y; // z减掉以前的v.y就等于v.x v.x = z - v.y; // z减掉现在的v.y即以前的v.x，即为v.y 但并不推荐这种做法，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。 第三种：通过异或的方式： 位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：（x ^ y ^ y） == x这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值： public class Test{ public static void main(String[] args) { Value v1 = new Value(5,10); swap(v1); System.out.println(\"v1交换之后的结果为：\"); System.out.println(v1.x); System.out.println(v1.y); } public static void swap(Value v) { v.x = v.x ^ v.y; v.y = v.x ^ v.y; v.x = v.x ^ v.y; } } 输出的结果：v1交换之后的结果为：105 跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。异或的方法比相加更加可取的地方在于，异或不存在数据溢出。 15）Java 对象初始化顺序？答：不考虑静态成员的初始化，调用一个对象的构造函数时，程序先调用父类的构造函数（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；最后调用自身构造函数。 我们可以写一段程序来对初始化顺序进行一个简单的验证： public class Derive extends Base { private Member m1 = new Member(\"Member 1\"); { System.out.println(\"Initial Block()\"); } public Derive() { System.out.println(\"Derive()\"); } private Member m2 = new Member(\"Member 2\"); private int i = getInt(); private int getInt() { System.out.println(\"getInt()\"); return 2; } public static void main(String[] args) { new Derive(); } } class Base { public Base() { System.out.println(\"Base()\"); } } class Member { public Member(String m) { System.out.println(\"Member() \"+m); } } 程序的输出结果是：Base()Member() Member 1Initial Block()Member() Member 2getInt()Derive() 16）true、false 与 null 是关键字吗？答：不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。 面试官：那 goto 与 const 呢？ 答：是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。 17）exception 和 error 有什么区别？答：exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。 exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 18）throw 和 throws 有什么区别？答：throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 小结：本节主要阐述了 Java 基础知识，并没有涉及到一些高级的特性，这些问题一般难度不大，适当复习下，应该没问题。 （二）Java 中常见集合集合这方面的考察相当多，这部分是面试中必考的知识点。 1）说说常见的集合有哪些吧？答：Map接口和Collection接口是所有集合框架的父接口： Collection接口的子接口包括：Set接口和List接口 Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等 Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等 List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等 2）HashMap和Hashtable的区别有哪些？（必问）答： HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的； 前者允许null作为Key；后者不允许null作为Key 3）HashMap的底层实现你知道吗？答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析： 4）ConcurrentHashMap 和 Hashtable 的区别？（必问） 答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶。 面试官：ConcurrentHashMap的具体实现知道吗？ 答： 1. 该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色； 2. Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。 5）HashMap 的长度为什么是2的幂次方？答： 1. 通过将 Key 的 hash 值与 length - 1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率 2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 6）List和Set的区别是啥？答：List元素是有序的，可以重复；Set元素是无序的，不可以重复。 7）List、Set和Map的初始容量和加载因子：答： 1. List ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。 Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。 2. Set HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32 3. Map HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32 8）Comparable接口和Comparator接口有什么区别？答： 1. 前者简单，但是如果需要重新定义比较类型时，需要修改源代码。 2. 后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 具体解析参考博客：Java集合框架—Set 9）Java集合的快速失败机制 “fail-fast”答： 是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。 例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 1. 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。 2. 使用CopyOnWriteArrayList来替换ArrayList 10）ArrayList 和 Vector 的区别答： 这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。 ArrayList 与 Vector 的区别主要包括两个方面： 同步性：Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 数据增长：ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。 面试官：那 ArrayList 和 LinkedList 的区别呢？ 答： LinkedList 实现了 List 和 Deque 接口，一般称为双向链表； LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高； LinkedList 比 ArrayList 需要更多的内存； 面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？ 答：它们的区别是： Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 Array 大小是固定的，ArrayList 的大小是动态变化的。 ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 11）如何去掉一个 Vector 集合中重复的元素？答： Vector newVector = new Vector(); for (int i = 0; i &lt; vector.size(); i++) { Object obj = vector.get(i); if (!newVector.contains(obj)) { newVector.add(obj); } } 还有一种简单的方式，利用了 Set 不允许重复元素的特性： HashSet set = new HashSet(vector); 小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。 12）如何权衡是使用无序的数组还是有序的数组？答：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 总结oh…..复习下来还真是酸爽….前路漫漫啊…. 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Spring Boot【快速入门】","slug":"Spring-Boot【快速入门】","date":"2018-05-07T22:54:00.000Z","updated":"2020-12-09T05:10:59.778Z","comments":true,"path":"2018/05/08/spring-boot-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2018/05/08/spring-boot-kuai-su-ru-men/","excerpt":"","text":"Spring Boot 概述 Build Anything with Spring Boot： Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. 上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。 什么是 Spring Boot 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：springboot(一)：入门篇——纯洁的微笑） 使用 Spring Boot 有什么好处回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： 1）配置 web.xml，加载 spring 和 spring mvc 2）配置数据库连接、配置日志文件 3）配置家在配置文件的读取，开启注解 4）配置mapper文件 ….. 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 Spring Boot 快速搭建第一步：新建项目选择 Spring Initializr ，然后选择默认的 url 点击【Next】： 然后修改一下项目的信息： 勾选上 Web 模板： 选择好项目的位置，点击【Finish】： 如果是第一次配置 Spring Boot 的话可能需要等待一会儿 IDEA 下载相应的 依赖包，默认创建好的项目结构如下： 项目结构还是看上去挺清爽的，少了很多配置文件，我们来了解一下默认生成的有什么： SpringbootApplication： 一个带有 main() 方法的类，用于启动应用程序 SpringbootApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文 application.properties：一个空的 properties 文件，可以根据需要添加配置属性 pom.xml： Maven 构建说明文件 第二步：HelloController在【cn.wmyskxz.springboot】包下新建一个【HelloController】： package cn.wmyskxz.springboot; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * 测试控制器 * * @author: @我没有三颗心脏 * @create: 2018-05-08-下午 16:46 */ @RestController public class HelloController { @RequestMapping(&quot;/hello&quot;) public String hello() { return &quot;Hello Spring Boot!&quot;; } } @RestController 注解： 该注解是 @Controller 和 @ResponseBody 注解的合体版 第三步：利用 IDEA 启动 Spring Boot我们回到 SpringbootApplication 这个类中，然后右键点击运行： 注意：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat 等待一会儿就会看到下方的成功运行的提示信息： 可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “/hello” 地址试一下： 可以看到页面成功显示出我们返回的信息。 解析 Spring Boot 项目 这一部分参考自：Spring Boot干货系列（一）优雅的入门篇 ——嘟嘟独立博客 解析 pom.xml 文件让我们来看看默认生成的 pom.xml 文件中到底有一些什么特别： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;我们可以看到一个比较陌生一些的标签 &lt;parent&gt; ，这个标签是在配置 Spring Boot 的父级依赖： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的 Maven 默认依赖，使用它之后，常用的包依赖就可以省去 version 标签。 关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\\repository\\org\\springframework\\boot\\spring-boot-dependencies\\2.0.1.RELEASE\\spring-boot-dependencies-2.0.1.RELEASE.pom 文件来查看，挺长的… 应用入口类Spring Boot 项目通常有一个名为 Application 的入口类，入口类里有一个 main 方法， *这个 main 方法其实就是一个标准的 Javay 应用的入口方法。** @SpringBootApplication 是 Spring Boot 的核心注解，它是一个组合注解，该注解组合了：@Configuration、@EnableAutoConfiguration、@ComponentScan； 若不是用 @SpringBootApplication 注解也可以使用这三个注解代替。 其中，@EnableAutoConfiguration 让 Spring Boot 根据类路径中的 jar 包依赖为当前项目进行自动配置，例如，添加了 spring-boot-starter-web 依赖，会自动添加 Tomcat 和 Spring MVC 的依赖，那么 Spring Boot 会对 Tomcat 和 Spring MVC 进行自动配置。 Spring Boot 还会自动扫描 @SpringBootApplication 所在类的同级包以及下级包里的 Bean ，所以入口类建议就配置在 grounpID + arctifactID 组合的包名下（这里为 cn.wmyskxz.springboot 包） Spring Boot 的配置文件Spring Boot 使用一个全局的配置文件 application.properties 或 application.yml，放置在【src/main/resources】目录或者类路径的 /config 下。 Spring Boot 不仅支持常规的 properties 配置文件，还支持 yaml 语言的配置文件。yaml 是以数据为中心的语言，在配置数据的时候具有面向对象的特征。 Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。 简单实例一下 我们同样的将 Tomcat 默认端口设置为 8080 ，并将默认的访问路径从 “/” 修改为 “/hello” 时，使用 properties 文件和 yml 文件的区别如上图。 注意： yml 需要在 “:” 后加一个空格，幸好 IDEA 很好地支持了 yml 文件的格式有良好的代码提示； 我们可以自己配置多个属性 我们直接把 .properties 后缀的文件删掉，使用 .yml 文件来进行简单的配置，然后使用 @Value 来获取配置属性： 重启 Spring Boot ，输入地址：localhost:8080/hello 能看到正确的结果： 注意： 我们并没有在 yml 文件中注明属性的类型，而是在使用的时候定义的。 你也可以在配置文件中使用当前配置： 仍然可以得到正确的结果： 问题： 这样写配置文件繁琐而且可能会造成类的臃肿，因为有许许多多的 @Value 注解。 封装配置信息 我们可以把配置信息封装成一个类，首先在我们的 name 和 age 前加一个 student 前缀，然后新建一个 StudentProperties 的类用来封装这些信息，并用上两个注解： @Component：表明当前类是一个 Java Bean @ConfigurationProperties(prefix = “student”)：表示获取前缀为 sutdent 的配置信息 这样我们就可以在控制器中使用，重启得到正确信息： Spring Boot 热部署在目前的 Spring Boot 项目中，当发生了任何修改之后我们都需要重新启动才能够正确的得到效果，这样会略显麻烦，Spring Boot 提供了热部署的方式，当发现任何类发生了改变，就会通过 JVM 类加载的方式，加载最新的类到虚拟机中，这样就不需要重新启动也能看到修改后的效果了。 做法也很简单，修改 pom.xml 即可！ 我们往 pom.xml 中添加一个依赖就可以了： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt; &lt;/dependency&gt;重新启动 Spring Boot ，然后修改任意代码，就能观察到控制台的自动重启现象： 关于如何在 IDEA 中配置热部署：传送门 Spring Boot 使用上面已经完成了 Spring Boot 项目的简单搭建，我们仅仅需要进行一些简单的设置，写一个 HelloController 就能够直接运行了，不要太简单…接下来我们再深入了解一下 Spring Boot 的使用。 Spring Boot 支持 JSPSpring Boot 的默认视图支持是 Thymeleaf 模板引擎，但是这个我们不熟悉啊，我们还是想要使用 JSP 怎么办呢？ 第一步：修改 pom.xml 增加对 JSP 文件的支持 &lt;!-- servlet依赖. --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tomcat的支持.--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 第二步：配置试图重定向 JSP 文件的位置 修改 application.yml 文件，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下： 第三步：修改 HelloController 修改 @RestController 注解为 @Controller ，然后将 hello 方法修改为： 第四步：新建 hello.jsp 文件 在【src/main】目录下依次创建 webapp、WEB-INF、views 目录，并创建一个 hello.jsp 文件： 第五步：刷新网页 因为我们部署了热部署功能，所以只需要等待控制台重启信息完成之后再刷新网页就可以看到正确效果了： 关于 404，使用 spring-boot:run 运行项目可以解决： 集成 MyBatis 第一步：修改 pom.xml 增加对 MySql和 MyBatis 的支持 &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; 第二步：新增数据库链接参数 这里我们就直接使用之前创建好的 student 表了吧： 第三步：创建 Student 实体类和 StudentMapper 映射类 在【cn.wmyskxz.springboot】下新建一个【pojo】包，然后在其下创建一个 Student 类： public class Student { private Integer id; private Integer student_id; private String name; private Integer age; private String sex; private Date birthday; /* getter and setter */ }在【cn.wmyskxz.springboot】下新建一个【mapper】包，然后在其下创建一个 StudentMapper 映射类： package cn.wmyskxz.springboot.mapper; import cn.wmyskxz.springboot.pojo.Student; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; import java.util.List; @Mapper public interface StudentMapper { @Select(&quot;SELECT * FROM student&quot;) List&lt;Student&gt; findAll(); } 第四步：编写 StudentController 在【cn.wmyskxz.springboot】下新建一个【controller】包，然后在其下创建一个 StudentController ： package cn.wmyskxz.springboot.controller; import cn.wmyskxz.springboot.mapper.StudentMapper; import cn.wmyskxz.springboot.pojo.Student; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; /** * Student 控制器 * * @author: @我没有三颗心脏 * @create: 2018-05-08-下午 20:25 */ @Controller public class StudentController { @Autowired StudentMapper studentMapper; @RequestMapping(&quot;/listStudent&quot;) public String listStudent(Model model) { List&lt;Student&gt; students = studentMapper.findAll(); model.addAttribute(&quot;students&quot;, students); return &quot;listStudent&quot;; } } 第五步：编写 listStudent.jsp 文件 我们简化一下 JSP 的文件，仅显示两个字段的数据： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;table align=&#39;center&#39; border=&#39;1&#39; cellspacing=&#39;0&#39;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${students}&quot; var=&quot;s&quot; varStatus=&quot;st&quot;&gt; &lt;tr&gt; &lt;td&gt;${s.id}&lt;/td&gt; &lt;td&gt;${s.name}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; 第六步：重启服务器运行 因为往 pom.xml 中新增加了依赖的包，所以自动重启服务器没有作用，我们需要手动重启一次，然后在地址输入：localhost:8080/listStudent 查看效果： 以上。 参考资料：how2j.cn-Spring Boot 系列教程 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"模仿天猫实战【SSM】——总结","slug":"模仿天猫实战【SSM】——总结","date":"2018-05-07T01:04:00.000Z","updated":"2020-12-09T04:55:26.157Z","comments":true,"path":"2018/05/07/mo-fang-tian-mao-shi-zhan-ssm-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/05/07/mo-fang-tian-mao-shi-zhan-ssm-zong-jie/","excerpt":"第一篇文章链接：模仿天猫实战【SSM版】——项目起步第二篇文章链接：模仿天猫实战【SSM版】——后台开发 总结：项目从4-27号开始写，到今天5-7号才算真正的完工，有许多粗糙的地方，但总算完成了，比想象中的开发周期要久的多，并且大部分的时间都花在了前端页面的编写上…仅以此文来总结一下","text":"第一篇文章链接：模仿天猫实战【SSM版】——项目起步第二篇文章链接：模仿天猫实战【SSM版】——后台开发 总结：项目从4-27号开始写，到今天5-7号才算真正的完工，有许多粗糙的地方，但总算完成了，比想象中的开发周期要久的多，并且大部分的时间都花在了前端页面的编写上…仅以此文来总结一下 项目总结功能一览表 大致理了一下功能列表，应该是齐全的，其中推荐链接暂时不支持修改。 项目页面一览表 后端页面： 后台所需要用到的页面，从名字很好区分功能，其中 index.jsp 只有一行代码用于跳转 公共页面： 都是前端页面，从对天猫页面的分析提取出一些复用比较高的页面用于动态的包含在其他前端页面中。 前台页面：前台相较于后台页面 CSS 更加复杂，交互也更多，我把每一个页面的需要用到的 css 和 js 代码均保留在了当前 JSP 页面中，方便浏览学习。 项目主要逻辑类 控制器（Controller）： 用于控制页面的逻辑， 提取出一个 PageController 来专门控制页面的跳转，ForeController 用于前台所有的逻辑操作 拦截器（Interceptor）： LoginInteceptor 用于对登录进行判断，因为有一些页面需要登录之后才能访问的，例如：购物车；OtherInterceptor 用于向页面中添加一些其他的数据，例如：购物车数量。 业务层（Service层）： 业务处理层，其中封装了 Dao 层，用于完成主要的逻辑处理。 不需要登录就能访问的页面（以下为拦截器中的代码片段）： 其中包括：主页、搜索结果页、产品展示页、登录页、注册页。 还包括一些其他的路径用于处理逻辑，test 为开发过程中用于测试的页面 前台总结前台花费了大部分的时间，不仅仅是繁杂的样式和页面需要自己去编写，业务逻辑也比后台要复杂一些，因为是模仿，所以大部分的 CSS 我都是参照着天猫官网写的（利用FireFox来查看元素和元素样式）： 另外一部分是参照了how2j.cn上模仿的前端教程：戳这里 首页 简要的首页大概就是这样，请别在意轮播下面的【女装/内衣】中的产品，因为在4月份的时候，第一个分类的名字还叫【女装 /男装 /内衣】（好像是这个），后来项目写着写着突然改了… 观察大部分的页面，其实都是包含了其中的三个部分： 即顶部导航栏、一个搜索框、还有底部，我们可以单独把他们写成一个 jsp ，并动态的包含在我们的页面中 首页分类栏 因为一开始，我以为分类栏中保存的是一些直接的产品，但是分析前端的时候发现它们只是一些 hot-word 热词，所以为了和天猫的首页保持一致，我直接把分类栏写死了写成了一个单独的 JSP 文件并包含进了主页： 我还自己写了一个小程序，用来将这些 hor-word 转换成对应的 html 代码，不然这手写 2000 行可能真的够呛… 产品搜索页 并且支持按照【综合（销量*评价）】、【人气（评论量）】、【销量】、【价格】来排序产品，使用 Java 8 的新特性来完成该功能： 产品展示页 所有的产品展示图片均是来自how2j.com上的一张图，前面有链接，表示有参照这个教程来做。 购买页 在产品页中点击立即购买，或者在购物车点击结算都会跳转到该页面，创建订单。 付款页面 无耻的黏了一张自己的收款二维码… 付款成功页 当点击确认支付按钮之后，就会跳转到该页面来。 购物车页 该页面支持删除订单和对订单项进行相关的操作，点击结算页面跳转到购买页。 我的订单页 该页面用于对订单的管理，可以查看和操作订单。 评价页 当完成购买，即经过购买→支付→发货→确认收货的流程之后，即可对产品进行评论，评论完成后能看到其他用户的评价信息： 注册页 用户注册页，在前端判断两次密码是否相同，并提交给后台判断用户名是否唯一。 登录页 因为分辨率的问题有一点 BUG，不过不影响体验，登录之后顶部导航栏出现用户信息： 后台总结前台因为有现成的原型可以参照和模仿，后台需要自己去设计和实现界面，所以我直接找了一个模板代码，很方便也很快的完成了开发，在我的第二篇文章：模仿天猫实战【SSM版】——后台开发 有介绍。 分类管理 其中的分页和搜索功能是我找来的模板中用 js 代码来实现的，分类管理中不仅提供了更改分类名称的功能，还能管理分类下的产品和属性。 产品管理页 产品图片管理页 产品的图片是默认放置在 img/product/产品的id号/ 目录下的，并且默认的五张图片分别为：1.jpg、2.jpg…..5.jpg，用于默认显示的图片均为 1.jpg 属性值管理页 产品属性值管理页，能增加的属性值只能为当前分类下拥有的属性。 用户管理 提供一个修改密码的功能，给申诉修改密码的用户留一条后路。 订单管理页 等待发货的订单有一个发货按钮，用于发货。 上面有一些产品管理的按钮乱入了..直接拷贝的之前的图片，左侧栏中的产品管理按钮是删除了的… 推荐链接管理 暂时不提供修改功能。 项目中遇到的一些问题轮播失效 Bootstrap 的引入要在 JQuery 之后，不然不能正常使用… 为什么不在 PropertyValue 表中增加 property_name 字段？在产品详情页明显感觉到显示产品的属性的时候，特别不方便。 PropertyValue新增一个 Property 属性，来完成产品页的传递 后台属性值管理逻辑有点问题之前的代码： &lt;c:forEach items=&quot;${propertyValues}&quot; var=&quot;pv&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;c:forEach items=&quot;${properties}&quot; var=&quot;p&quot;&gt; &lt;c:if test=&quot;${p.id==pv.property_id}&quot;&gt;${p.name}&lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/td&gt; &lt;td&gt;${pv.value}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;editPropertyValue?id=${pv.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-edit&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;deletePropertyValue?id=${pv.id}&amp;category_id=${product.category_id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;非常糟糕，逻辑就是错的。 利用上面为 PropertyValue 添加的 Property 来完成功能： 下面的 select 标签也是错的 生成出来的代码是这样的： 我想要绑定一个隐藏的 input ，看来这样写是不行的，搜索了一下，可以通过为 &lt;select&gt; 标签写 onchange 属性来完成： 使用 Java 8 的新特性来排序使用了 Java 8 的 Lambda 表达式来完成前端的排序工作： 注册页天猫的注册搞得很高大上的样子，淘宝也弄成了一样的，不是很好模仿出效果： 所以照着改了一改，弄成了这个样子： 在前端通过 JS 来判断完成确认密码的功能，然后这是注册成功的页面： 发现 OrderItem 少设计了一个字段这是最初设计的数据库表与表之间的关系： 当我按照流程一步一步完成着项目，在完成立即购买这个功能时，我需要按照user_id来返回订单项时，不容易实现，我们需要为 OrderItem 增加一个字段（user_id）： CREATE TABLE `order_item` ( `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, `product_id` INT(11) NOT NULL COMMENT &#39;对应产品id&#39;, `order_id` INT(11) NOT NULL COMMENT &#39;对应订单id&#39;, `user_id` INT(11) NOT NULL COMMENT &#39;对应用户id&#39;, `number` INT(11) NULL DEFAULT NULL COMMENT &#39;对应产品购买的数量&#39;, INDEX `fk_order_item_product` (`product_id`), INDEX `fk_order_item_order` (`order_id`), INDEX `fk_order_item_user` (`user_id`), PRIMARY KEY (`id`), CONSTRAINT `fk_order_item_order` FOREIGN KEY (`order_id`) REFERENCES `order_` (`id`), CONSTRAINT `fk_order_item_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`), CONSTRAINT `fk_order_item_product` FOREIGN KEY (`product_id`) REFERENCES `product` (`id`) )COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB;然后运行 TestMybatisGenerator 来重新生成相关的文件. 更改 OrderItem 表中的 order_id 字段默认为空order_id 是用于判断当前的 OrderItem 是否存在于购物车中的依据，最开始我们将这个字段设计为不能为空，那么就只能在购物车中存在，当我们不需要经过购物车而要直接购买的时候，就不能得到满足… 修复购物车逻辑问题之前给 cart.jsp 页面的 List 仅仅是通过 listByUserId 方法来获取，但其实真正的购物车是那些 order_id 为空的，所以我在 OrderItemService 中新增了一个方法：listForCart 来返回那些真正属于购物车的订单项： @Override public List&lt;OrderItem&gt; listForCart(Integer user_id) { OrderItemExample example = new OrderItemExample(); example.or().andUser_idEqualTo(user_id).andOrder_idIsNull(); List&lt;OrderItem&gt; result = orderItemMapper.selectByExample(example); setProduct(result); return result; } Github完成之后的项目直接上传 Github，代码可能有些乱，可读性不是很高，但结构还是清晰的，还是值得参考：传送门 后期再对代码进行维护吧…菜鸟学习代码，勿喷…. 关于 sql 语句这里给一个连接提供建表语句以及一些数据：传送门 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"模仿天猫实战【SSM版】——后台开发","slug":"模仿天猫实战【SSM版】——后台开发","date":"2018-04-28T01:01:00.000Z","updated":"2020-12-09T04:55:32.818Z","comments":true,"path":"2018/04/28/mo-fang-tian-mao-shi-zhan-ssm-ban-hou-tai-kai-fa/","link":"","permalink":"http://www.wmyskxz.com/2018/04/28/mo-fang-tian-mao-shi-zhan-ssm-ban-hou-tai-kai-fa/","excerpt":"上一篇文章链接：模仿天猫实战【SSM版】——项目起步","text":"上一篇文章链接：模仿天猫实战【SSM版】——项目起步 后台需求分析在开始码代码之前，还是需要先清楚自己要做什么事情，后台具体需要实现哪些功能： 注意： 订单、用户、订单、推荐链接均不提供增删的功能。 后台界面设计不像前端那样有原型直接照搬就可以了，后台的设计还真的有难到我…毕竟我是一个对美有一定要求的人，一方面想尽量的简洁、简单，另一方面又不想要太难看，那怎么办呢？ 那当然是找模板了，找到一个顺眼的下载下来就开始改， 这个模板的原地址在这里：戳这里 顺便安利一下 FireFox ，真是开发神器，配合着修改，棒棒哒： 经过一番折腾… 摁，就这风格了，而且我还发现右上角的【Search】框是下载的模板用 js 实现的…对于管理来说更加方便了….而且居然还实现了分页…. 一个邪恶的想法又诞生了… 一些规定 为了降低项目的难度，我们做了很多的精简，现在我们作出如下的规定： 全站没有商家，只有一家 Tmall ，后台没有验证，可以直接进入 前台的路径就是默认路径，后台的路径需要加上 “/admin” 后缀，如访问后台则为：localhost/admin （默认为分类管理页） 管理路径统一为：admin/listXxxxx，如分类管理路径为：admin/listCategory，用户管理路径为：admin/listUser，诸如此类 编辑路径统一为：admin/editXxxxx，如编辑分类路径为：admin/editCategory，产品编辑页为：admin/editProduct，诸如此类 删除路径统一为：admin/deleteXxxxx 更新路径统一为：admin/updateXxxxx 关于页面路径的一些规定： 前端页面统一在【WEB-INF/views】下，后端页面统一在【WEB-INF/views/admin】下 分类管理正式开始编写我们的代码，以 Category 为例。 编写 Service 层我们需要在这一层上考虑需要完成的功能，对应我们上面画的后台功能图，分类管理也就是完成分类的查询还有修改的工作： package cn.wmyskxz.service; import cn.wmyskxz.pojo.Category; import java.util.List; public interface CategoryService { /** * 返回分类列表 * @return */ List&lt;Category&gt; list(); /** * 通过id获取对应的数据 * @param id * @return */ Category get(Integer id); /** * 更新分类 * @param category * @return */ void update(Category category); } 编写 CategoryServiceImpl ：在同一包下编写实现类 package cn.wmyskxz.service; import cn.wmyskxz.mapper.CategoryMapper; import cn.wmyskxz.pojo.Category; import cn.wmyskxz.pojo.CategoryExample; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; /** * CategoryService 的实现类 * * @author: @我没有三颗心脏 * @create: 2018-04-27-下午 16:35 */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryMapper categoryMapper; public List&lt;Category&gt; list() { CategoryExample example = new CategoryExample(); List&lt;Category&gt; categories = categoryMapper.selectByExample(example); return categories; } public Category get(Integer id) { return categoryMapper.selectByPrimaryKey(id); } public void update(Category category) { categoryMapper.updateByPrimaryKey(category); } }编写 CategoryController根据业务需求可以很容易的编写出来： package cn.wmyskxz.controller; import cn.wmyskxz.pojo.Category; import cn.wmyskxz.service.CategoryService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; /** * Category 的控制类 * * @author: @我没有三颗心脏 * @create: 2018-04-27-下午 16:37 */ @Controller @RequestMapping(&quot;/admin&quot;) public class CategoryController { @Autowired CategoryService categoryService; @RequestMapping(&quot;/listCategory&quot;) public String list(Model model) { List&lt;Category&gt; categories = categoryService.list(); model.addAttribute(&quot;categories&quot;, categories); return &quot;admin/listCategory&quot;; } @RequestMapping(&quot;/editCategory&quot;) public String edit(Category category,Model model) { model.addAttribute(&quot;category&quot;, category); return &quot;admin/editCategory&quot;; } @RequestMapping(&quot;/updateCategory&quot;) public String update(Category category) { categoryService.update(category); return &quot;redirect:listCategory&quot;; } }JSP 相关文件编写自己研究了一会儿这个模板，感觉还是挺好改的，然后就给改成了大概以下这个样子（自己在数据库中加入了 16 条数据）： 分类管理页 分类编辑页 模板下载下来之后文件目录是这样的： 我们直接整个拷贝【assets】文件夹放在【webapp】目录下，然后根据模板里面的代码就可以开始修改了，修改下来的两个文件源码如下： listCategory.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;模仿天猫-后台&lt;/title&gt; &lt;!-- Bootstrap Styles--&gt; &lt;link href=&quot;../assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- FontAwesome Styles--&gt; &lt;link href=&quot;../assets/css/font-awesome.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- Morris Chart Styles--&gt; &lt;!-- Custom Styles--&gt; &lt;link href=&quot;../assets/css/custom-styles.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;!-- Google Fonts--&gt; &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39; /&gt; &lt;!-- TABLE STYLES--&gt; &lt;link href=&quot;../assets/js/dataTables/dataTables.bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;nav class=&quot;navbar navbar-default top-navbar&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.sidebar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;listCategory&quot;&gt;Tmall&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!--/. NAV TOP --&gt; &lt;nav class=&quot;navbar-default navbar-side&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;sidebar-collapse&quot;&gt; &lt;ul class=&quot;nav&quot; id=&quot;main-menu&quot;&gt; &lt;li&gt; &lt;a class=&quot;active-menu&quot; href=&quot;listCategory&quot;&gt;&lt;i class=&quot;fa fa-bars&quot;&gt;&lt;/i&gt; 分类管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listUser&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 用户管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listOrder&quot;&gt;&lt;i class=&quot;fa fa-list-alt&quot;&gt;&lt;/i&gt; 订单管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listProduct&quot;&gt;&lt;i class=&quot;fa fa-th-list&quot;&gt;&lt;/i&gt; 产品管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listLink&quot;&gt;&lt;i class=&quot;fa fa-link&quot;&gt;&lt;/i&gt; 推荐链接管理&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- /. NAV SIDE --&gt; &lt;div id=&quot;page-wrapper&quot;&gt; &lt;div id=&quot;page-inner&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h1 class=&quot;page-header&quot;&gt; 分类管理 &lt;small&gt;&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;!-- Advanced Tables --&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; 分类管理表 &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover&quot; id=&quot;dataTables-example&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;分类id&lt;/th&gt; &lt;th&gt;分类名称&lt;/th&gt; &lt;th&gt;编辑分类&lt;/th&gt; &lt;th&gt;产品管理&lt;/th&gt; &lt;th&gt;属性管理&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;${categories}&quot; var=&quot;c&quot;&gt; &lt;tr&gt; &lt;td&gt;${c.id}&lt;/td&gt; &lt;td&gt;${c.name}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;editCategory?id=${c.id}&amp;name=${c.name}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-th-list&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;listProduct?category_id=${c.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-shopping-cart&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;listProperty?category_id=${c.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-edit&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--End Advanced Tables --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /. PAGE WRAPPER --&gt; &lt;/div&gt; &lt;!-- /. WRAPPER --&gt; &lt;!-- JS Scripts--&gt; &lt;!-- jQuery Js --&gt; &lt;script src=&quot;../assets/js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt; &lt;!-- Bootstrap Js --&gt; &lt;script src=&quot;../assets/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Metis Menu Js --&gt; &lt;script src=&quot;../assets/js/jquery.metisMenu.js&quot;&gt;&lt;/script&gt; &lt;!-- DATA TABLE SCRIPTS --&gt; &lt;script src=&quot;../assets/js/dataTables/jquery.dataTables.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../assets/js/dataTables/dataTables.bootstrap.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function () { $(&#39;#dataTables-example&#39;).dataTable(); }); &lt;/script&gt; &lt;!-- Custom Js --&gt; &lt;script src=&quot;../assets/js/custom-scripts.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; editCategory.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;/&gt; &lt;title&gt;模仿天猫-后台&lt;/title&gt; &lt;!-- Bootstrap Styles--&gt; &lt;link href=&quot;../assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;!-- FontAwesome Styles--&gt; &lt;link href=&quot;../assets/css/font-awesome.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;!-- Morris Chart Styles--&gt; &lt;!-- Custom Styles--&gt; &lt;link href=&quot;../assets/css/custom-styles.css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;!-- Google Fonts--&gt; &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;nav class=&quot;navbar navbar-default top-navbar&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.sidebar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;listCategory&quot;&gt;Tmall&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!--/. NAV TOP --&gt; &lt;nav class=&quot;navbar-default navbar-side&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;sidebar-collapse&quot;&gt; &lt;ul class=&quot;nav&quot; id=&quot;main-menu&quot;&gt; &lt;li&gt; &lt;a class=&quot;active-menu&quot; href=&quot;listCategory&quot;&gt;&lt;i class=&quot;fa fa-bars&quot;&gt;&lt;/i&gt; 分类管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listUser&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 用户管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listOrder&quot;&gt;&lt;i class=&quot;fa fa-list-alt&quot;&gt;&lt;/i&gt; 订单管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listProduct&quot;&gt;&lt;i class=&quot;fa fa-th-list&quot;&gt;&lt;/i&gt; 产品管理&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;listLink&quot;&gt;&lt;i class=&quot;fa fa-link&quot;&gt;&lt;/i&gt; 推荐链接管理&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- /. NAV SIDE --&gt; &lt;div id=&quot;page-wrapper&quot;&gt; &lt;div id=&quot;page-inner&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h1 class=&quot;page-header&quot;&gt; 分类管理 &lt;small&gt; - id:${category.id} &lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;!-- Advanced Tables --&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; 编辑分类 &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;row col-lg-12&quot;&gt; &lt;form action=&quot;updateCategory&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%-- 隐藏id属性，一并提交 --%&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${category.id}&quot;&gt; &lt;label&gt;分类名称：&lt;/label&gt; &lt;input name=&quot;name&quot; class=&quot;form-control&quot; value=&quot;${category.name}&quot;&gt; &lt;br/&gt; &lt;div class=&quot;pull-right&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--End Advanced Tables --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /. PAGE WRAPPER --&gt; &lt;/div&gt; &lt;!-- /. WRAPPER --&gt; &lt;!-- JS Scripts--&gt; &lt;!-- jQuery Js --&gt; &lt;script src=&quot;../assets/js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt; &lt;!-- Bootstrap Js --&gt; &lt;script src=&quot;../assets/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;这样就完成了 Category 的后台管理模块其他模块的思路跟 Category 如出一辙，就比较偏向于体力劳动了… 注意： 所有本类的 id 属性均为 id ，所有外键的 id 都是 属性名_id 这样的格式，保持统一！ Example 条件查询MyBatis 逆向工程自动生成文件的时候自动生成了 Example 条件查询类，我们到底应该怎么使用它呢，这里简要的说明一下。 不得不说这个东西还挺神奇，也很方便，比如我们需要查询 category_id 对应下的属性表，我们可以这样写： public List&lt;Property&gt; list(Integer category_id) { PropertyExample example = new PropertyExample(); example.or().andCategory_idEqualTo(category_id); List&lt;Property&gt; properties = propertyMapper.selectByExample(example); return properties; }通过方法名其实也很容易看懂这些是什么意思，我们首先创建了一个 PropertyExample 实例对象，然后通过 .or() 方法开启条件查询，.andCategory_idEqualTo() 匹配对应的 category_id ，自动生成的 sql 语句就像这样： 更多详情戳这里 - 引用其他博客的详细说明 IDEA 快速重构当我编写好了 PropertyService 、PropertyServiceImpl、 PropertyController 之后再想要去编写 Product 的这一系列文件的时候，发现其实很多代码都是重复的，只是很少一部分的代码需要改动，暂时不考虑设计模式的话，我们可以使用 IDEA 来完成快速重构： 直接复制 PropertyController 的代码到 ProductController 中，然后【Ctrl + F】搜索 Property ： 我们可以发现所有的 Property 都高亮了，然后我们怎么批量修改呢？ 然后继续疯狂码代码… 开发过程中遇到的一些问题PropertyValue 遇到的麻烦 PropertyValue 属性值表，这个表关联了两个外键，一个指向 Product ，另一个指向 Property ，当我按照之前的设计把 listProduct.jsp 设计成下面这个样子的时候，点击【编辑属性】，Property 的信息应该怎么传递？ 也就是说，如何处理从 listProduct 跳转到 listPropertyValue 页面时凭空跳出来的 Property 的相关信息？ 解决方案： 在 PropertyValueServiceImpl 中增加： @Autowired PropertyService propertyService;我们现在有 category_id 和 product_id ，我们可以利用 Property 和 Category 之间的联系，通过 category_id 查询出所有对应的 Property ，然后再筛选出同时匹配 property_id 和 product_id 的 PropertyValue： public List&lt;PropertyValue&gt; list(Integer product_id, Integer category_id) { PropertyValueExample example = new PropertyValueExample(); List&lt;PropertyValue&gt; propertyValues = new ArrayList&lt;PropertyValue&gt;(); List&lt;Property&gt; properties = propertyService.list(category_id); for (Property property : properties) { // 筛选出同时匹配 property_id 和 product_id 的值 example.or().andProperti_idEqualTo(property.getId()).andProduct_idEqualTo(product_id); propertyValues.addAll(propertyValueMapper.selectByExample(example)); } return propertyValues; }emmm…这样的思路出来之后，对应的 Controller 就清晰了： @RequestMapping(\"/listPropertyValue\") public String list(Model model, Integer product_id, Integer category_id) { List&lt;PropertyValue> propertyValues = propertyValueService.list(product_id, category_id); model.addAttribute(\"propertyValues\", propertyValues); Product product = productService.get(product_id); model.addAttribute(\"product\", product); return \"admin/listPropertyValue\"; } 加入一条数据测试： bingo！ 另一个问题是添加属性值： 添加的属性值必须是当前 Category 下有的属性值，所以我们可以在 Controller 上自动注入一个 PropertyService 通过 category_id 查询到当前分类下所有的 Property 然后传递给 listPropertyValue ： @Autowired PropertyService propertyService; @RequestMapping(\"/listPropertyValue\") public String list(Model model, Integer product_id, Integer category_id) { List&lt;PropertyValue> propertyValues = propertyValueService.list(product_id, category_id); model.addAttribute(\"propertyValues\", propertyValues); Product product = productService.get(product_id); model.addAttribute(\"product\", product); List&lt;Property> properties = propertyService.list(category_id); model.addAttribute(\"properties\", properties); return \"admin/listPropertyValue\"; } 期间发现一个 BUG，PropertyValue 表里的 property_id 居然写成了 properti_id，吓得我赶紧检查了一下所有表的字段，其他的没问题，重新生成一下逆向工程 然后获取属性名称： 完善之后大概是这样： 产品图片管理产品图片的管理需要涉及到文件的上传操作，我们需要先提供必要的 jar 包依赖： commons-fileupload commons-io 同样的搜索 maven 库添加依赖到 pom.xml中： &lt;!-- 上传文件fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt;产品图片如何管理？ 规定一：所有的产品图片均保存在【img/product/】对应的 product_id 目录下，并且默认的文件名为 1，2，3，4，5 ，例如 product_id 为 1 的产品的产品图片 1 保存于：【img/product/1/1.jpg】 规定二：每一个产品对应五张图片，文件名分别为 1.jpg ，2.jpg 以此类推，不能少也不能多，删除也只是将对应目录下的图片删除，id 并不改变 规定三：默认产品打开的大图即为该产品图片目录中的 1.jpg 界面大概设计成了这样： 莫名其妙一个 BUG： 我把表单设计成了这样，隐藏了两个属性，一个 product_id，一个 id： 为了方便操作，我想要直接申明两个参数用来接收上面的两个属性，大概是这样： 但是上面两种方法都不行，我还查了一些资料在 @RequestParam 注解里设置了 required 属性，仍然获取不到，但是我改成用 ProductImage 来接收就好了..Why? 后来写着写着，又必须要使用上面两种方法了…. 根据我们的规定来完成代码 ProductImageService 层还是跟之前的没有多大的区别，但是值得注意的是，根据我们的规定，我们的删除需要做一些改动（根据 product_id 批量删除）： package cn.wmyskxz.service; import cn.wmyskxz.mapper.PropertyValueMapper; import cn.wmyskxz.pojo.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.ArrayList; import java.util.List; /** * cn.wmyskxz.pojo.PropertyValueValueService 实现类 * * @author: @我没有三颗心脏 * @create: 2018-04-28-上午 7:47 */ @Service public class PropertyValueServiceImpl implements PropertyValueService { @Autowired PropertyValueMapper propertyValueMapper; @Autowired PropertyService propertyService; @Autowired ProductService productService; public void add(PropertyValue propertyValue) { propertyValueMapper.insert(propertyValue); } public void delete(Integer id) { propertyValueMapper.deleteByPrimaryKey(id); } public void deleteByProductId(Integer product_id) { // 按条件查询出需要删除的列表 PropertyValueExample example = new PropertyValueExample(); example.or().andProduct_idEqualTo(product_id); Integer category_id = productService.get(product_id).getCategory_id(); List&lt;PropertyValue> propertyValues = list(product_id, category_id); // 循环删除 for (int i = 0; i &lt; propertyValues.size(); i++) { propertyValueMapper.deleteByPrimaryKey(propertyValues.get(i).getId()); } } public void update(PropertyValue propertyValue) { propertyValueMapper.updateByPrimaryKey(propertyValue); } public List&lt;PropertyValue> list(Integer product_id, Integer category_id) { PropertyValueExample example = new PropertyValueExample(); List&lt;PropertyValue> propertyValues = new ArrayList&lt;PropertyValue>(); List&lt;Property> properties = propertyService.list(category_id); for (Property property : properties) { // 筛选出同时匹配 property_id 和 product_id 的值 example.or().andProperty_idEqualTo(property.getId()).andProduct_idEqualTo(product_id); propertyValues.addAll(propertyValueMapper.selectByExample(example)); } return propertyValues; } public PropertyValue get(Integer id) { return propertyValueMapper.selectByPrimaryKey(id); } } 首先在 ProductController 中 add 和 delete 方法中增加以下代码： @Autowired ProductImageService productImageService; @RequestMapping(\"/addProduct\") public String add(Product product) { productService.add(product); // 创建新的 Product 时默认创建 5 个对应的 ProductImage 数据 ProductImage productImage = new ProductImage(); productImage.setProduct_id(product.getId()); for (int i = 1; i &lt;= 5; i++) { productImage.setId(i); productImageService.add(productImage); } return \"redirect:listProduct?category_id=\" + product.getCategory_id(); } @RequestMapping(\"/deleteProduct\") public String delete(Integer id, HttpServletRequest request) { // 在删除产品的时候将对应的 5 个 ProductImage 数据也删除了 productImageService.deleteByProductId(id); // 同时删除目录下的相关文件 String path = request.getSession().getServletContext().getRealPath(\"\" + id); deleteDir(new File(path)); // 删除外键对应的数据 propertyValueService.deleteByProductId(id); int category_id = productService.get(id).getCategory_id(); productService.delete(id); return \"redirect:listProduct?category_id=\" + category_id; } /** * 递归删除目录下的所有文件及子目录下所有文件 * * @param dir 将要删除的文件目录 * @return boolean Returns \"true\" if all deletions were successful. * If a deletion fails, the method stops attempting to * delete and returns \"false\". */ private static boolean deleteDir(File dir) { if (dir.isDirectory()) { String[] children = dir.list(); //递归删除目录中的子目录下 for (int i = 0; i &lt; children.length; i++) { boolean success = deleteDir(new File(dir, children[i])); if (!success) { return false; } } } // 目录此时为空，可以删除 return dir.delete(); } 然后编写我们的 ProductImageController ： package cn.wmyskxz.controller; import cn.wmyskxz.pojo.Product; import cn.wmyskxz.pojo.ProductImage; import cn.wmyskxz.service.ProductImageService; import cn.wmyskxz.service.ProductService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.util.List; /** * ProductImage 的控制器 * * @author: @我没有三颗心脏 * @create: 2018-04-28-下午 14:10 */ @Controller @RequestMapping(&quot;/admin&quot;) public class ProductImageController { @Autowired ProductImageService productImageService; @Autowired ProductService productService; @RequestMapping(&quot;/editProductImage&quot;) public String edit(Model model, Integer product_id) { List&lt;ProductImage&gt; productImages = productImageService.list(product_id); model.addAttribute(&quot;productImages&quot;, productImages); Product product = productService.get(product_id); model.addAttribute(&quot;product&quot;, product); return &quot;admin/editProductImage&quot;; } @RequestMapping(value = &quot;/updateProductImage&quot;, method = RequestMethod.POST) public String update(HttpServletRequest request, // @RequestParam(&quot;productImage&quot;) ProductImage productImage, Integer product_id, Integer id, @RequestParam(&quot;picture&quot;) MultipartFile picture) { // 上传文件到指定位置 String filePath = request.getSession().getServletContext() .getRealPath(&quot;img/product/&quot; + product_id); // 因为 id 是自增长键，所以需要 % 5 来作为文件名 String fileName = (id % 5 == 0 ? 5 : id % 5) + &quot;.jpg&quot;; File uploadPicture = new File(filePath, fileName); if (!uploadPicture.exists()) { uploadPicture.mkdirs(); } // 保存 try { picture.transferTo(uploadPicture); } catch (Exception e) { e.printStackTrace(); } return &quot;redirect:editProductImage?product_id=&quot; + product_id; } @RequestMapping(&quot;/deleteProductImage&quot;) public String delete(Integer id, Integer product_id, HttpServletRequest request) { // 不删除表中的数据（在 ProductController 中统一删除），删除对应文件 String filePath = request.getSession().getServletContext() .getRealPath(&quot;img/product/&quot; + product_id); String fileName = id + &quot;.jpg&quot;; new File(filePath, fileName).delete(); return &quot;redirect:editProductImage?product_id=&quot; + product_id; } } 再优化一下界面的东西，增加没有图片显示的 error 图片，大概就是这个样子： 这里就只贴一下 table 的代码吧： &lt;c:forEach items=&quot;${productImages}&quot; var=&quot;pi&quot;&gt; &lt;tr&gt; &lt;td&gt;${pi.product_id}&lt;/td&gt; &lt;td&gt;${pi.id}&lt;/td&gt; &lt;td&gt;&lt;img class=&quot;col-md-8&quot; src=&quot;../img/product/${pi.product_id}/${pi.id%5==0?5:pi.id%5}.jpg&quot; onerror=&quot;this.src=&#39;../img/product/error.png&#39;&quot;&gt;&lt;/td&gt; &lt;td class=&quot;col-md-5&quot;&gt; &lt;form action=&quot;updateProductImage&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${pi.id}&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;product_id&quot; value=&quot;${pi.product_id}&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;picture&quot; class=&quot;pull-left&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; value=&quot;上传&quot;&gt; &lt;/form&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;deleteProductImage?product_id=${pi.product_id}&amp;id=${pi.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;在写图片管理的时候又遇到一个坑在删除顶层数据库数据的时候，要注意删除其下的有外键关联的数据，特别是 product_id 这个东西，是很多表的外键，删除 product 之前需要先清空有关联的其他表的数据…. 总之坑是很多啦..不过项目在进展总归是好事…耐心耐心… 接着码代码….还剩下一些体力活的东西，就先结博文啦…（心累.jpg） 有一些催更的朋友，希望能别催啦…每天都在码啦，而且本身也是很low的东西，写完之后我会上传 github 的。 总结 当我给自己埋了一个大坑说要模仿天猫，并且陷进去的时候，一方面痛苦着一方面也察觉了自己很多不足的地方，就觉得还是很值得，现在来做一下简短的总结。 进度比想象中慢了很多，虽然一步一步按照之前的分析图来编写代码总体是顺畅的，但是有那种写着写着突然发现之前的设计有问题的感觉，中途也改了几次，发现自己分析问题不够全面。 项目中有许多类似的代码，并且在 Controller 和 Impl 中不断有其他的东西加入，总觉得是糟糕的代码，但是又不知道应该进一步如何改进。 方向永远比努力重要，在行动之前思考清楚，我一直觉得是很重要的一点，我觉得通过对项目的分析，对我项目的进展有一个整体的构思，各个模块该有什么功能都比较清晰，特别在编写 JSP 文件的时候能明显感觉不会很迷茫，这是比较好的一点 发现自己阅读代码量很少，这种感觉体现在很多地方，一是写代码时感觉到自己思想的局限性，二是觉得自己写的代码有很多的相似性，虽然这个项目是自己突发奇想的想要去做的，但是有很多细节的地方，是自己没有去注意到的，比如类型要求、边界判断、事务处理等等等… 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"模仿天猫实战【SSM版】——项目起步","slug":"模仿天猫实战【SSM版】——项目起步","date":"2018-04-27T00:57:00.000Z","updated":"2020-12-09T04:55:35.924Z","comments":true,"path":"2018/04/27/mo-fang-tian-mao-shi-zhan-ssm-ban-xiang-mu-qi-bu/","link":"","permalink":"http://www.wmyskxz.com/2018/04/27/mo-fang-tian-mao-shi-zhan-ssm-ban-xiang-mu-qi-bu/","excerpt":"前言：现在自己的学习似乎遇到了瓶颈，感觉学习了 SSM 之后有一些迷茫，不知道接下来该往哪里去努力了，我觉得这是个很不好的状态，为了度过这段时期，我准备把天猫模仿下来（给自己找点事做）之后开始去巩固 Java 的基础知识，也准备好暑假去找实习。","text":"前言：现在自己的学习似乎遇到了瓶颈，感觉学习了 SSM 之后有一些迷茫，不知道接下来该往哪里去努力了，我觉得这是个很不好的状态，为了度过这段时期，我准备把天猫模仿下来（给自己找点事做）之后开始去巩固 Java 的基础知识，也准备好暑假去找实习。 第一步：需求分析首先要确定要实现哪些功能，需要对需求进行完整的分析，才能在编写项目的时候有条不紊，我们的目的很明确：就是模仿天猫前端 + 自己实现后端。并且尽最大努力去降低这个项目的复杂度（毕竟高深的东西不懂）。 前端需求分析规定：全天猫没有店铺，就只有唯一一家叫做 Tmall 的商家，卖所有的东西。 1.数据的显示： 首页数据显示分析： 首先是搜索栏下方的九个商品，需要从数据库中取出销量最高的几个产品，关于标红的关键字，是要满足一定条件的，比如：这一个星期内销量超过多少… 接着是分类导航栏，首先是商品分类右边固定的两个链接【天猫超市】和【天猫国际】，还有紧跟着的八个超链，这个可以设计为一个单表，存储它显示的文字和链接过去的地址，然后是具体的 16 个分类以及轮播： 下面的具体产品展示比较复杂，我们可以自己做一下简化，比如就展示几个产品比较多的固定的几个分类就好了，其他的就直接舍弃： 总结： 总之就是需要显示各种数据库中的数据 2.登录/注册页 需要有一个登录/注册页，能够完成用户的登录和注册功能，并能提供基础的例如判断空值等功能。 3.产品搜索页 左上角的图标我们可以统一简化成 Tmall 的图片，商品图片，我们可以整个大分类使用一张图，主要就是实现排序功能还有搜索功能 4.产品展示页 天猫原生的产品展示页有些复杂，我们可以自己简化一下，就不要选这么多东西，都是一口价， 另外下方规格参数和评价都不能省略： 5.购物车/购买页面 第二步：表结构设计根据对于前端的分析，数据库有了一些眉目，为了简化项目的难度，所以我们需要自己想点办法，先来构思一下大概需要一些什么样的表： 我大概就想出来需要用到这些表，我们一个一个来创建它们： 表一：分类表首先我们需要一个表来存储我们的分类信息，也就是【女装/内衣】、【男装/运动户外】在内的 16 个分类，为了高度一致，这 16 个分类不能多也不能少。 为了简化任务，可以观察出，【热门手机】、【特色手机】分栏下的东西都是【手机/数码/电脑办公】类别里的东西，所以我们直接砍掉，右边的一些图片超链也给直接砍掉，我们规定每一行显示的产品数目就可以了，这样就简单多了。 CREATE TABLE category ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) NOT NULL COMMENT &#39;分类的名字&#39;, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;表二：商品分类右边的超链表即在【天猫国际】右边的 8 个超链，我们单独新建一个表来存储超链显示的文字和链接的地址，这样就可以任意的修改其内容： 百度翻译【推荐链接】翻译为【Referral links】，那我们也这么给我们的表命名好了： CREATE TABLE referal_link ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, text varchar(255) NOT NULL COMMENT &#39;超链显示的文字&#39;, link varchar(255) NOT NULL COMMENT &#39;超链的地址&#39;, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;表三：产品表每个分类下都要一定的产品，这些产品还有自己的一些属性，所以另外需要属性表，这个表另外创建，我们先来观察一下一个产品表需要一些什么东西： 用于展示的 5 张图片 产品名称 小标题（即名称下面一排标红的小字） 价格（就一口价，没别的） 销量（别月销量了，能简化就简化一下） 累计评价（还需要设计一个评价表） 库存 属性（需要关联另外的属性表） CREATE TABLE product ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) NOT NULL COMMENT &#39;产品的名称&#39;, sub_title varchar(255) DEFAULT NULL COMMENT &#39;小标题&#39;, price float DEFAULT NULL COMMENT &#39;价格&#39;, sale int(11) DEFAULT NULL COMMENT &#39;销量&#39;, stock int(11) DEFAULT NULL COMMENT &#39;库存&#39;, category_id int(11) DEFAULT NULL COMMENT &#39;对应的分类id&#39;, PRIMARY KEY (id), CONSTRAINT fk_product_category FOREIGN KEY (category_id) REFERENCES category (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 注意： 其中产品图片，累计评价，属性都作为单独的表存在并让当前表的 id 作为外键 表四：属性表 去掉详细的规格参数划分，其实属性也就是一个名字而已（简化简化简化）。 CREATE TABLE property ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) DEFAULT NULL COMMENT &#39;属性名称&#39;, product_id int(11) NOT NULL COMMENT &#39;对应的产品id&#39;, PRIMARY KEY (id), CONSTRAINT fk_property_product FOREIGN KEY (product_id) REFERENCES product(id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 突然想到的问题：每一个产品的属性其实是很多的，如果每一个产品都对应很多属性的话，对于天猫这样的数据量来说，应该会让数据库爆炸的吧… 改进方法：将属性表关联到 category 表上，因为其实每一个分类下的产品的属性差不多！ 修改数据库根据以上问题，修改一下数据库表之间的关系 并将属性表的外键修改为 category 的主键： CREATE TABLE property ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) DEFAULT NULL COMMENT &#39;属性名称&#39;, category_id int(11) NOT NULL COMMENT &#39;对应的分类id&#39;, PRIMARY KEY (id), CONSTRAINT fk_property_category FOREIGN KEY (category_id) REFERENCES category(id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;表五：属性值表其中就是保存了对应属性的值，并且应该有两个外键，一个指向 Property 表，而另一个则指向 Product 表 CREATE TABLE property_value ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;, properti_id int(11) NOT NULL COMMENT &#39;对应属性id&#39;, value varchar(255) DEFAULT NULL COMMENT &#39;具体的属性值&#39;, PRIMARY KEY (id), CONSTRAINT fk_property_value_property FOREIGN KEY (properti_id) REFERENCES property (id), CONSTRAINT fk_property_value_product FOREIGN KEY (product_id) REFERENCES product (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;表六：产品图片表这个表名义上是保存了产品的图片，其实只是保存了产品图片的位置即图片名称，我们可以规定所有的产品图片都放在一个统一的文件夹下面，然后通过 id 来获取对应名称的图片： CREATE TABLE product_image ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, product_id int(11) DEFAULT NULL COMMENT &#39;对应的产品id&#39;, PRIMARY KEY (id), CONSTRAINT fk_product_image_product FOREIGN KEY (product_id) REFERENCES product (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 注意： 我们通过把产品图片的文件命名为 id.jpg ，然后通过相对路径来获取到产品图片 表七：用户表用户表很简单，也没有权限之类的东西： CREATE TABLE user ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) NOT NULL COMMENT &#39;用户名称&#39;, password varchar(255) NOT NULL COMMENT &#39;用户密码&#39;, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 我们或许会在之后把密码弄成 “*****” 这种形式的，但是现在一切为了简单！ 表八：评价表 评价表对应了用户和产品两个表，也比较简单，我们为了简单，把上面红色的部分全部砍掉，因为没有商家，所以也不需要回复用户的评价，都砍掉砍掉！ CREATE TABLE review ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, content varchar(4000) DEFAULT NULL COMMENT &#39;评价内容&#39;, user_id int(11) NOT NULL COMMENT &#39;对应的用户id&#39;, product_id int(11) NOT NULL COMMENT &#39;对应的产品id&#39;, createDate datetime DEFAULT NULL COMMENT &#39;评价时间&#39;, PRIMARY KEY (id), CONSTRAINT fk_review_product FOREIGN KEY (product_id) REFERENCES product (id), CONSTRAINT fk_review_user FOREIGN KEY (user_id) REFERENCES user (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;表九：订单表由于 Order 是 MySql 的一个关键字，所以我们在订单表的最后添加一个下划线： CREATE TABLE order_ ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, order_code varchar(255) NOT NULL COMMENT &#39;订单号&#39;, address varchar(255) NOT NULL COMMENT &#39;收货地址&#39;, post varchar(255) NOT NULL COMMENT &#39;邮编&#39;, receiver varchar(255) NOT NULL COMMENT &#39;收货人姓名&#39;, mobile varchar(255) NOT NULL COMMENT &#39;手机号码&#39;, user_message varchar(255) NOT NULL COMMENT &#39;用户备注的信息&#39;, create_date datetime NOT NULL COMMENT &#39;订单创建时间&#39;, pay_date datetime DEFAULT NULL COMMENT &#39;订单支付时间&#39;, delivery_date datetime DEFAULT NULL COMMENT &#39;发货日期&#39;, confirm_date datetime DEFAULT NULL COMMENT &#39;确认收货日期&#39;, user_id int(11) DEFAULT NULL COMMENT &#39;对应的用户id&#39;, status varchar(255) NOT NULL COMMENT &#39;订单状态&#39;, PRIMARY KEY (id), CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES user (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;表十：订单项表一个订单里面可能有多个订单项，一个产品也可能对应多个订单项，所以这个表应该有两个外键： CREATE TABLE order_item ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;, order_id int(11) NOT NULL COMMENT &#39;对应订单id&#39;, number int(11) DEFAULT NULL COMMENT &#39;对应产品购买的数量&#39;, PRIMARY KEY (id) COMMENT &#39;邮编&#39;, CONSTRAINT fk_order_item_product FOREIGN KEY (product_id) REFERENCES product (id), CONSTRAINT fk_order_item_order FOREIGN KEY (order_id) REFERENCES order_ (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;汇总：我们在创建表之前，应该创建一个新的数据库，并命名为【tmall_ssm】 DROP DATABASE IF EXISTS tmall_ssm; CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8;将这十个表汇个总就是： DROP DATABASE IF EXISTS tmall_ssm; CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8; use tmall_ssm; CREATE TABLE category ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) NOT NULL COMMENT &#39;分类的名字&#39;, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE referal_link ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, text varchar(255) NOT NULL COMMENT &#39;超链显示的文字&#39;, link varchar(255) NOT NULL COMMENT &#39;超链的地址&#39;, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE product ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) NOT NULL COMMENT &#39;产品的名称&#39;, sub_title varchar(255) DEFAULT NULL COMMENT &#39;小标题&#39;, price float DEFAULT NULL COMMENT &#39;价格&#39;, sale int(11) DEFAULT NULL COMMENT &#39;销量&#39;, stock int(11) DEFAULT NULL COMMENT &#39;库存&#39;, category_id int(11) DEFAULT NULL COMMENT &#39;对应的分类id&#39;, PRIMARY KEY (id), CONSTRAINT fk_product_category FOREIGN KEY (category_id) REFERENCES category (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE property ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) DEFAULT NULL COMMENT &#39;属性名称&#39;, category_id int(11) NOT NULL COMMENT &#39;对应的分类id&#39;, PRIMARY KEY (id), CONSTRAINT fk_property_category FOREIGN KEY (category_id) REFERENCES category(id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE property_value ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;, properti_id int(11) NOT NULL COMMENT &#39;对应属性id&#39;, value varchar(255) DEFAULT NULL COMMENT &#39;具体的属性值&#39;, PRIMARY KEY (id), CONSTRAINT fk_property_value_property FOREIGN KEY (properti_id) REFERENCES property (id), CONSTRAINT fk_property_value_product FOREIGN KEY (product_id) REFERENCES product (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE product_image ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, product_id int(11) DEFAULT NULL COMMENT &#39;对应的产品id&#39;, PRIMARY KEY (id), CONSTRAINT fk_product_image_product FOREIGN KEY (product_id) REFERENCES product (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE user ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, name varchar(255) NOT NULL COMMENT &#39;用户名称&#39;, password varchar(255) NOT NULL COMMENT &#39;用户密码&#39;, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE review ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, content varchar(4000) DEFAULT NULL COMMENT &#39;评价内容&#39;, user_id int(11) NOT NULL COMMENT &#39;对应的用户id&#39;, product_id int(11) NOT NULL COMMENT &#39;对应的产品id&#39;, createDate datetime DEFAULT NULL COMMENT &#39;评价时间&#39;, PRIMARY KEY (id), CONSTRAINT fk_review_product FOREIGN KEY (product_id) REFERENCES product (id), CONSTRAINT fk_review_user FOREIGN KEY (user_id) REFERENCES user (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE order_ ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, order_code varchar(255) NOT NULL COMMENT &#39;订单号&#39;, address varchar(255) NOT NULL COMMENT &#39;收货地址&#39;, post varchar(255) NOT NULL COMMENT &#39;邮编&#39;, receiver varchar(255) NOT NULL COMMENT &#39;收货人姓名&#39;, mobile varchar(255) NOT NULL COMMENT &#39;手机号码&#39;, user_message varchar(255) NOT NULL COMMENT &#39;用户备注的信息&#39;, create_date datetime NOT NULL COMMENT &#39;订单创建时间&#39;, pay_date datetime DEFAULT NULL COMMENT &#39;订单支付时间&#39;, delivery_date datetime DEFAULT NULL COMMENT &#39;发货日期&#39;, confirm_date datetime DEFAULT NULL COMMENT &#39;确认收货日期&#39;, user_id int(11) DEFAULT NULL COMMENT &#39;对应的用户id&#39;, status varchar(255) NOT NULL COMMENT &#39;订单状态&#39;, PRIMARY KEY (id), CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES user (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE order_item ( id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;, product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;, order_id int(11) NOT NULL COMMENT &#39;对应订单id&#39;, number int(11) DEFAULT NULL COMMENT &#39;对应产品购买的数量&#39;, PRIMARY KEY (id) COMMENT &#39;邮编&#39;, CONSTRAINT fk_order_item_product FOREIGN KEY (product_id) REFERENCES product (id), CONSTRAINT fk_order_item_order FOREIGN KEY (order_id) REFERENCES order_ (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;直接复制进 MySql 中执行，就能看到我们创建好的十个数据库： 第三步：创建 SSM 开发环境根据之前我写过的博文：IDEA 整合 SSM 搭建好 SSM 开发环境，这里给出完整的项目结构和 pom.xml 文件： 完整的项目结构： pom.xml 文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;wmyskxz&lt;/name&gt; &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt; &lt;artifactId&gt;wmyskxz&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version} &lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- pageHelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2-beta&lt;/version&gt; &lt;/dependency&gt; &lt;!--jsqlparser--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; MyBatis 逆向工程按照正常的流程，我们应该去创建数据库对应的 POJO 和 DAO 类还有对应的 mapper 映射文件，按照上面的分析我们一共有十张表，想象一下为这十张表做这些无技术含量的机械化的繁杂的工作是多么头疼的一件事，我们希望的是：有人帮我自动创建好这些！ MyBatis 官方提供了一种名为 “逆向工程” 的机制，其可以针对数据库中的单表自动生成 MyBatis 执行所需要的代码 包括： Java 实体类、Mapper映射配置、Mapper代理接口 第一步：添加必要的 jar 包我们使用逆向工程，需要先导入 Mybatis Generator 的官方包，由于我们使用的是 Maven 搭建的 SSM 项目，所有我们可以去 Maven 的官网去查询需要的相关包：http://mvnrepository.com/ 戳进去点击最新的包： 就可以在下方找到 Maven 依赖添加的语句： 直接粘进 pom.xml 就可以了，这里就不演示了。 第二步：generatorConfig.xml在【resources】下创建 generatorConfig.xml 配置文件，该配置文件说明了一些逆向工程的细节： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 是否去除自动生成的代码中的注释 true：是 false：否--&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库连接信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/tmall_ssm&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认 false，把 JDBC DECIMAL 和 NUMERIC 类型解析为 Integer 为 true 时解析为 java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject：生成 POJO 类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;cn.wmyskxz.pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;!-- trimStrings：从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject：生成xml映射文件存放位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetProject：生成mapper类存放位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.wmyskxz.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名 tableName:要生成的表名 domainObjectName:生成后的实例名 enableCountByExample:Count语句中加入where条件查询，默认为true开启 enableUpdateByExample:Update语句中加入where条件查询，默认为true开启 enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启 enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启 selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启 --&gt; &lt;table tableName=&quot;category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;!-- 使用数据库中实际的字段名作为生成的实体类的属性 --&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;!-- 使用自增长键 --&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;property&quot; domainObjectName=&quot;Property&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;product_image&quot; domainObjectName=&quot;ProductImage&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;order_&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;property_value&quot; domainObjectName=&quot;PropertyValue&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;review&quot; domainObjectName=&quot;Review&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;order_item&quot; domainObjectName=&quot;OrderItem&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;table tableName=&quot;referal_link&quot; domainObjectName=&quot;ReferalLink&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;这样配置文件也就编写好了 第三步：逆向数据文件生成类在编写完配置文件只有，就需要加载该配置文件，利用逆向工程的机制来对数据库的各个表进行一系列文件的生成，我们在【test/java】包下创建【TestMyBatisGenerator】类： import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.api.ShellCallback; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.File; import java.util.ArrayList; import java.util.List; /** * 逆向工程测试类 * * @author: @我没有三颗心脏 * @create: 2018-04-27-上午 8:26 */ public class TestMybatisGenerator { public static void main(String[] args) throws Exception { // warnings 为用于放置生成过程中警告信息的集合对象 List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); // 指定是否覆盖重名文件 boolean overwrite = true; // 加载配置文件 File configFile = new File(MyBatisGenerator.class.getClassLoader().getResource(&quot;generatorConfig.xml&quot;).toURI()); // 配置解析类 ConfigurationParser cp = new ConfigurationParser(warnings); // 配置解析类解析配置文件并生成 Configuration 配置对象 Configuration config = cp.parseConfiguration(configFile); // ShellCallback 负责如何处理重复文件 ShellCallback callback = new DefaultShellCallback(overwrite); // 逆向工程对象 MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); // 执行逆向文件生成操作 myBatisGenerator.generate(null); // 打印提示信息 System.out.println(&quot;MyBatis 逆向工程执行成功，刷新项目查看文件！&quot;); } }执行该测试类，就能看见自动生成的文件： Oh！这真的是太爽了！突然开心(*^▽^*) 看一下自动生成的文件以 Category 为例，我们来看一下自动生成的文件： Category 实体类： package cn.wmyskxz.pojo; public class Category { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name == null ? null : name.trim(); } } CategoryMapper 映射类： package cn.wmyskxz.mapper; import cn.wmyskxz.pojo.Category; import cn.wmyskxz.pojo.CategoryExample; import java.util.List; public interface CategoryMapper { int deleteByPrimaryKey(Integer id); int insert(Category record); int insertSelective(Category record); List&lt;Category> selectByExample(CategoryExample example); Category selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Category record); int updateByPrimaryKey(Category record); } CategoryMapper.xml 映射文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;cn.wmyskxz.mapper.CategoryMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;cn.wmyskxz.pojo.Category&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Example_Where_Clause&quot;&gt; &lt;where&gt; &lt;foreach collection=&quot;oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot;&gt; &lt;if test=&quot;criteria.valid&quot;&gt; &lt;trim prefix=&quot;(&quot; prefixOverrides=&quot;and&quot; suffix=&quot;)&quot;&gt; &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot;&gt; &lt;choose&gt; &lt;when test=&quot;criterion.noValue&quot;&gt; and ${criterion.condition} &lt;/when&gt; &lt;when test=&quot;criterion.singleValue&quot;&gt; and ${criterion.condition} #{criterion.value} &lt;/when&gt; &lt;when test=&quot;criterion.betweenValue&quot;&gt; and ${criterion.condition} #{criterion.value} and #{criterion.secondValue} &lt;/when&gt; &lt;when test=&quot;criterion.listValue&quot;&gt; and ${criterion.condition} &lt;foreach close=&quot;)&quot; collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt; #{listItem} &lt;/foreach&gt; &lt;/when&gt; &lt;/choose&gt; &lt;/foreach&gt; &lt;/trim&gt; &lt;/if&gt; &lt;/foreach&gt; &lt;/where&gt; &lt;/sql&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; id, name &lt;/sql&gt; &lt;select id=&quot;selectByExample&quot; parameterType=&quot;cn.wmyskxz.pojo.CategoryExample&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;if test=&quot;distinct&quot;&gt; distinct &lt;/if&gt; &#39;false&#39; as QUERYID, &lt;include refid=&quot;Base_Column_List&quot;/&gt; from category &lt;if test=&quot;_parameter != null&quot;&gt; &lt;include refid=&quot;Example_Where_Clause&quot;/&gt; &lt;/if&gt; &lt;if test=&quot;orderByClause != null&quot;&gt; order by ${orderByClause} &lt;/if&gt; &lt;/select&gt; &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from category where id = #{id,jdbcType=INTEGER} &lt;/select&gt; &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from category where id = #{id,jdbcType=INTEGER} &lt;/delete&gt; &lt;insert id=&quot;insert&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into category (name) values (#{name,jdbcType=VARCHAR}) &lt;/insert&gt; &lt;insert id=&quot;insertSelective&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into category &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; #{name,jdbcType=VARCHAR}, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot;&gt; update category &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #{name,jdbcType=VARCHAR}, &lt;/if&gt; &lt;/set&gt; where id = #{id,jdbcType=INTEGER} &lt;/update&gt; &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot;&gt; update category set name = #{name,jdbcType=VARCHAR} where id = #{id,jdbcType=INTEGER} &lt;/update&gt; &lt;/mapper&gt;其中就只有映射文件稍微有些复杂，但细看下来其实跟我们自己写的差不多，甚至自动生成的完成得更好。 xxxExample MybatisGenerator会生成一个类叫做XXXXExample的。，它的作用是进行排序，条件查询的时候使用。 这里有详细的说明，了解一下就好了：戳这里 第四步：测试我们这里仅仅就用 CategoryMapper 映射类来进行简单测试了： @Autowired CategoryMapper categoryMapper; @Test public void test() { Category category = new Category(); category.setName(&quot;分类1&quot;); categoryMapper.insert(category); }由于我们使用了自增长键 id ，所以仅仅只需要提供 name 属性就可以了，执行，可以看到数据库中有正确的数据： 总结根据以上的 “折腾” 算是完成了项目的起步工作了吧，我是一边写项目一边写博客的，所以可能有时候想着想着写着写着思绪会有点飘，写得凌乱，这也是没有办法的事，不管写得好还是差我都希望能记录下来，这些都是属于我自己的思路和学习路程。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"Java Web—【分页功能】详解","slug":"Java-Web—【分页功能】详解","date":"2018-04-25T00:53:00.000Z","updated":"2020-12-09T05:04:24.633Z","comments":true,"path":"2018/04/25/java-web-fen-ye-gong-neng-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/25/java-web-fen-ye-gong-neng-xiang-jie/","excerpt":"","text":"分页简介分页功能在网页中是非常常见的一个功能，其作用也就是将数据分割成多个页面来进行显示。 使用场景： 当取到的数据量达到一定的时候，就需要使用分页来进行数据分割。 当我们不使用分页功能的时候，会面临许多的问题： 客户端的问题： 如果数据量太多，都显示在同一个页面的话，会因为页面太长严重影响到用户的体验，也不便于操作，也会出现加载太慢的问题。 服务端的问题： 如果数据量太多，可能会造成内存溢出，而且一次请求携带的数据太多，对服务器的性能也是一个考验。 分页的分类分页的实现分为真分页和假分页两种，也就是物理分页和逻辑分页。 1.真分页（物理分页）： 实现原理： SELECT * FROM xxx [WHERE...] LIMIT #{param1}, #{param2}第一个参数是开始数据的索引位置第二个参数是要查询多少条数据 优点： 不会造成内存溢出 缺点： 翻页的速度比较慢 2.假分页（逻辑分页）： 实现原理： 一次性将所有的数据查询出来放在内存之中，每次需要查询的时候就直接从内存之中去取出相应索引区间的数据 优点： 分页的速度比较快 缺点： 可能造成内存溢出 传统的分页方式对于假分页的实现方式很简单，只需要准备一个集合保存从数据库中取出的所有数据，然后根据当前页面的码数，取出对应范围的数据显示就好了，我们这里基于物理分页来实现。 分页的原理 页面中的数据有：结果集：通过 SQL 语句查询得来的——List 分页条中的数据有：当前页：用户传递到后台——currentPage总页数：计算的来——totalPage上一页：计算的来——prePage下一页：计算的来——nextPage尾页：计算的来（总页数）——lastPage页面大小（即每一页显示的条数）：用户传递到后台——count总条数：通过 SQL 语句查询得来的——totalCount 可以发现页面功能中需要用到的数据有两个是需要通过 SQL 语句查询得来的：一个是页面中显示的数据 List ，另一个是数据的总条数 totalCount，分别对应以下两条 SQL 语句： SELECT * FROM student LIMIT #{param1}, #{param2} SELECT COUNT(*) FROM student 通过计算得到的数据有： 总页数：totalPage总页数 = 总条数 % 页面大小 == 0 ? 总条数 / 页面大小 : 总条数 / 页面大小 + 1 上一页：prePage上一页 = 当前页 - 1 &gt; = 1 ? 当前页 - 1 : 1 下一页：nextPage下一页 = 当前页 + 1 &lt;= totalPage ? 当前页 + 1 : totalPage 尾页：lastPage尾页 = 总条数 % 页面大小 == 0 ？ 总条数 - 页面大小 : 总条数 - 总条数 % 页面大小 用户传递的数据： 当前页：currentPage 页面大小：count 所有我们可以创建一个 Page 工具类备用： public class Page { int start; // 开始数据的索引 int count; // 每一页的数量 int total; // 总共的数据量 /** * 提供一个构造方法 * @param start * @param count */ public Page(int start, int count) { super(); this.start = start; this.count = count; } /** * 判断是否有上一页 * @return */ public boolean isHasPreviouse(){ if(start==0) return false; return true; } /** * 判断是否有下一页 * @return */ public boolean isHasNext(){ if(start==getLast()) return false; return true; } /** * 计算得到总页数 * @return */ public int getTotalPage(){ int totalPage; // 假设总数是50，是能够被5整除的，那么就有10页 if (0 == total % count) totalPage = total /count; // 假设总数是51，不能够被5整除的，那么就有11页 else totalPage = total / count + 1; if(0==totalPage) totalPage = 1; return totalPage; } /** * 计算得到尾页 * @return */ public int getLast(){ int last; // 假设总数是50，是能够被5整除的，那么最后一页的开始就是45 if (0 == total % count) last = total - count; // 假设总数是51，不能够被5整除的，那么最后一页的开始就是50 else last = total - total % count; last = last&lt;0?0:last; return last; } /* getter and setter */ } 前台实现分页设计首先我们在前台需要完成我们分页条的设计，这里可以直接引入 Bootstrap 来完成： 上面是使用 Bootstrap 实现一个分页条的简单例子，如果不熟悉的童鞋可以去菜鸟教程中查看：点这里 简单版本的分页条为了便于理解，我们先来实现一个简单版本的分页条吧： 首页超链：指向了 start 为 0 的首页 &lt;li&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; 上一页超链： &lt;li &gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; 下一页超链： &lt;li &gt; &lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt; &lt;span&gt;›&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; 最后一页超链：指向了最后一页 &lt;li &gt; &lt;a href=&quot;?page.start=${page.last}&quot;&gt; &lt;span&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; 中间页： &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;li&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; class=&quot;current&quot;&gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:forEach&gt; 所以写完看起来会是这样子的： &lt;nav&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;li&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; class=&quot;current&quot;&gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:forEach&gt; &lt;li &gt; &lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt; &lt;span&gt;›&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &gt; &lt;a href=&quot;?page.start=${page.last}&quot;&gt; &lt;span&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 存在的问题：① 没有边界判断，即在首页仍然可以点击前一页，不符合逻辑也影响用户体验② 会显示完所有的分页，即如果 totalPage 有50页，那么分页栏将会显得特别长，影响体验 改良版本的分页条1.写好头和尾 &lt;nav class=&quot;pageDIV&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; ..... &lt;/ul&gt; &lt;/nav&gt;2.写好« ‹这两个功能按钮使用 &lt;c:if&gt;标签来增加边界判断，如果没有前面的页码了则设置为disable状态 &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;再通过 JavaScrip 代码来完成禁用功能： &lt;script&gt; $(function () { $(&quot;ul.pagination li.disabled a&quot;).click(function () { return false; }); }); &lt;/script&gt;3.完成中间页码的编写 &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt; &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt; &gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt;从 0 循环到 page.totalPage - 1 ，varStatus 相当于是循环变量 status.count 是从1开始遍历 status.index 是从0开始遍历 要求：显示当前页码的前两个和后两个就可，例如当前页码为3的时候，就显示 1 2 3(当前页) 4 5 的页码 理解测试条件： 10 &lt;= 当前页*每一页显示的数目 - 当前页开始的数据编号 &lt;= 30 只要理解了这个判断条件，其他的就都好理解了 注意： 测试条件是需要根据项目的需求动态改变的，不是万能的！ 后台中的分页首页在项目中引入上面提到的 Page 工具类，然后我们在 DAO 类中使用 LIMIT 关键字来查询数据库中的信息： public List&lt;Student&gt; list() { return list(0, Short.MAX_VALUE); } public List&lt;Student&gt; list(int start, int count) { List&lt;Student&gt; students = new ArrayList&lt;&gt;(); String sql = &quot;SELECT * FROM student ORDER BY student_id desc limit ?,?&quot;; try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) { ps.setInt(1, start); ps.setInt(2, count); // 获取结果集... } catch (SQLException e) { e.printStackTrace(); } return students; }在 Servlet 中获取分页参数并使首页显示的 StudentList 用 page 的参数来获取： // 获取分页参数 int start = 0; int count = 10; try { start = Integer.parseInt(req.getParameter(&quot;page.start&quot;)); count = Integer.parseInt(req.getParameter(&quot;page.count&quot;)); } catch (Exception e) { } Page page = new Page(start, count); List&lt;Student&gt; students = studentDAO.list(page.getStart(), page.getCount()); .... // 共享数据 req.setAttribute(&quot;page&quot;, page); req.setAttribute(&quot;students&quot;, students);以上即可完成分页功能，但这是基于 Servlet 的版本，在之前写过的项目（学生管理系统(简易版)）中实际的使用了这种方法，感兴趣的可以去看一下。 SSM 中的分页在 SSM 项目中，我们可以使用 MyBatis 的一款分页插件： PageHelper 来帮助我们更加简单的完成分页的需求，官网在这里： PageHelper 在这里，我们演示一下如何使用上面的工具重构我们之前写过的 SSM 项目 —— 学生管理系统-SSM 版 第一步：添加相关 jar 依赖包PageHelper 需要依赖两个 jar 包，我们直接在 pom.xml 中增加两个 jar 包依赖： &lt;!-- pageHelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2-beta&lt;/version&gt; &lt;/dependency&gt; &lt;!--jsqlparser--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt;第二步：配置相关环境在 MyBatis 的 SessionFactory 配置中新增加一个属性名 plugins 的配置： &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.wmyskxz.entity&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;!-- 让MyBatis支持PageHelper插件 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;第三步：重构项目首先我们把 LIMIT 关键字从映射文件中干掉： &lt;!-- 查询从start位置开始的count条数据--&gt; &lt;select id=&quot;list&quot; resultMap=&quot;student&quot;&gt; SELECT * FROM student ORDER BY student_id desc &lt;/select&gt;然后注释掉查询数据总条数的 SQL 语句： &lt;!--&amp;lt;!&amp;ndash; 查询数据条目 &amp;ndash;&amp;gt;--&gt; &lt;!--&lt;select id=&quot;getTotal&quot; resultType=&quot;int&quot;&gt;--&gt; &lt;!--SELECT COUNT(*) FROM student--&gt; &lt;!--&lt;/select&gt;--&gt;在 Dao 类和 Service 类中修改相应的地方： 然后修改掉 StudentController 中的方法： @RequestMapping(&quot;/listStudent&quot;) public String listStudent(HttpServletRequest request, HttpServletResponse response) { // 获取分页参数 int start = 0; int count = 10; try { start = Integer.parseInt(request.getParameter(&quot;page.start&quot;)); count = Integer.parseInt(request.getParameter(&quot;page.count&quot;)); } catch (Exception e) { } Page page = new Page(start, count); // 使用 PageHelper 来设置分页 PageHelper.offsetPage(page.getStart(),page.getCount()); List&lt;Student&gt; students = studentService.list(); // 使用 PageHelper 来获取总数 int total = (int) new PageInfo&lt;&gt;(students).getTotal(); page.setTotal(total); request.setAttribute(&quot;students&quot;, students); request.setAttribute(&quot;page&quot;, page); return &quot;listStudent&quot;; }重启服务器，能看到也能够正确的使用分页功能。 总结其实我自己对于这个工具比较无感..因为只是弱化了少一部分的功能，并没有我想象中的那样 “智能” ，也没有看到什么好的博文能够点通我的认知，希望了解的大大们能无私分享一下，谢谢！ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"学生管理系统（SSM简易版）总结","slug":"学生管理系统（SSM简易版）总结","date":"2018-04-24T00:50:00.000Z","updated":"2020-12-09T05:01:02.324Z","comments":true,"path":"2018/04/24/xue-sheng-guan-li-xi-tong-ssm-jian-yi-ban-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/24/xue-sheng-guan-li-xi-tong-ssm-jian-yi-ban-zong-jie/","excerpt":"之前用 Servlet + JSP 实现了一个简易版的学生管理系统，在学习了 SSM 框架之后，我们来对之前写过的项目重构一下！","text":"之前用 Servlet + JSP 实现了一个简易版的学生管理系统，在学习了 SSM 框架之后，我们来对之前写过的项目重构一下！ 技术准备为了完成这个项目，需要掌握如下技术： Java基础知识 前端：HTML, CSS, JAVASCRIPT, JQUERY J2EE：Tomcat, Servlet, JSP, Filter 框架：Spring, Spring MVC, MyBatis, Spring 与 MyBatis 整合, SSM 整合 数据库：MySQL 开发工具：IDEA, Maven 开发流程之前虽然已经使用 Servlet + JSP 完成了简单的开发，这次使用 SSM 仅仅是重构工作，但我们仍然按照商业项目的开发步骤来一步一步完成，进一步熟悉这个过程，重复的部分我就直接复制了。 ① 需求分析首先要确定要做哪些功能 使用数据库来保存数据 能增删改查学生的信息（学号，名称，年龄，性别，出生日期） ② 表结构设计根据需求，那么只需要一个 student 表就能够完成功能了。 创建数据库：student将数据库编码格式设置为 UTF-8 ，便于存取中文数据 DROP DATABASE IF EXISTS student; CREATE DATABASE student DEFAULT CHARACTER SET utf8; 创建学生表：student不用学生学号(studentID)作为主键的原因是：不方便操作，例如在更新数据的时候，同时也要更改学号，那这样的操作怎么办呢？所以我们加了一个 id 用来唯一表示当前数据。 CREATE TABLE student( id int(11) NOT NULL AUTO_INCREMENT, student_id int(11) NOT NULL UNIQUE, name varchar(255) NOT NULL, age int(11) NOT NULL, sex varchar(255) NOT NULL, birthday date DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; MySQL 在 Windows 下不区分大小写，但在 Linux 下默认区分大小写，因此，数据库名、表明、字段名都不允许出现任何大写字母，避免节外生枝。 ③ 原型设计就是设计界面，在商业项目中，这是很重要的一步，我们可以解除界面原型，低成本、高效率的与客户达成需求的一致性。 这个项目一共就分为两个页面： 主页面： 学生编辑页面： ④ SSM 环境搭建在真正开始编写代码之前，我们首先需要先来搭建好我们的 SSM 环境。 第一步：创建 Maven webapp 项目首先新建工程，选择 Maven 标签，然后勾选上【Create from archetype】选择 webapp： 点击下一步，填写上【GroupId】和【ArtifactId】： GroupId：项目组织唯一的标识符，实际对应 JAVA 的包的结构，也就是 main 目录下 java 的目录结构（包） AritifactId：项目的唯一标识符，实际对应项目的名称，就是项目根目录的名称 实际上你可以乱填上试试，我就不乱填了 然后是确认项目路径，这一步你可以看到 Maven 配置中的参数，不需要做改动，直接下一步就可以（图中的路径是我配置的本地 Maven 仓库的地址）： 确认项目名称和路径，点击【Finish】即可： 等待一会儿，控制台就会有创建成功的提示信息，我们把【Enable Auto-Import】点上，这个提示会在每次 pom.xml 有改动时出现，自动导入，省掉麻烦： 第二步：搭建项目目录结构下面就是 Maven 风格的 webapp 的默认目录结构： 注意： webapp 是默认没有 java 源文件也没有 test 目录的。 遵循 Maven 的统一项目结构，我们搭建出项目的完整目录结构如下图： 我们并没有使用 Log4j 来输出日志，而是使用 logback 提示：我们可以在 IDEA 中右键目录然后选择【Make Directory as】，让 IDEA 识别不同的目录作用 这里的目录建好之后还需要设置一下，让 IDEA 识别目录作用，选择【File】&gt;【Project Structure】： 设置好之后点击 OK，即完成了项目目录的搭建。 第三步：配置文件内容在【pom.xml】文件中声明依赖的 jar 包 ： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;StudentManagerSSM&lt;/name&gt; &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt; &lt;artifactId&gt;StudentManagerSSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version} &lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- jstl标签 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; &lt;build&gt; 标签是默认生成的 我们在 &lt;properties&gt; 中声明了编码格式以及使用的 spring 和 mybatis 的版本号，然后在 &lt;dependencies&gt; 中声明了具体的 jar 包 在【web.xml】中声明编码过滤器并配置 DispatcherServlet ： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;在【spring-mybatis.xml】中完成 spring 和 mybatis 的配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=&quot;cn.wmyskxz.service&quot;/&gt; &lt;!-- 配置数据库相关参数properties的属性：${url} --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${c3p0.maxPoolSize}&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${c3p0.minPoolSize}&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;${c3p0.autoCommitOnClose}&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;${c3p0.checkoutTimeout}&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;${c3p0.acquireRetryAttempts}&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.wmyskxz.entity&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.wmyskxz.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt;在【spring-mvc.xml】中完成 Spring MVC 的相关配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;cn.wmyskxz.controller&quot;/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt;在【jdbc.properties】中配置 c3p0 数据库连接池： jdbc.driver=com.mysql.jdbc.Driver #数据库地址 jdbc.url=jdbc:mysql://localhost:3306/student?useUnicode=true&amp;characterEncoding=utf8 #用户名 jdbc.username=root #密码 jdbc.password=root #最大连接数 c3p0.maxPoolSize=30 #最小连接数 c3p0.minPoolSize=10 #关闭连接后不自动commit c3p0.autoCommitOnClose=false #获取连接超时时间 c3p0.checkoutTimeout=10000 #当获取连接失败重试次数 c3p0.acquireRetryAttempts=2在【logback.xml】中完成日志输出的相关配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration debug=&quot;true&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt;以上就完成了 SSM 框架的基本配置： 添加进了 SSM 项目所需要的 jar 包 配置好了 spring/mybatis/spring MVC 的相关配置信息（自动扫描 cn.wmyskxz 包下的带有注解的类） 通过 xml 配置的方式配置好了日志和数据库 ⑤ 实体类设计实体类仅仅是对数据库中表的一一映射（表中字段名应该和实体类中的名称一一对应），同时可能还需要兼顾对业务能力的支持。 在 Packge【cn.wmyskxz.entity】下创建 Student 类：package cn.wmyskxz.entity; import java.util.Date; /** Student 实体类 @author: @我没有三颗心脏 @create: 2018-04-23-下午 13:34 /public class Student { private int id; private int student_id; private String name; private int age; private String sex; private Date birthday; /* getter and setter */} ⑤ DAO 类的设计DAO，即 Date Access Object，数据库访问对象，就是对数据库相关操作的封装，让其他地方看不到 JDBC 的代码。 在【cn.wmyskxz.dao】包下创建【StudentDao】接口： package cn.wmyskxz.dao; import cn.wmyskxz.entity.Student; import java.util.List; public interface StudentDao { int getTotal(); void addStudent(Student student); void deleteStudent(int id); void updateStudent(Student student); Student getStudent(int id); List&lt;Student&gt; list(int start, int count); }然后在【resources/mapper】下创建好对应的映射文件【StudengDao.xml】： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 将namespace的值设置为DAO类对应的路径 --&gt; &lt;mapper namespace=&quot;cn.wmyskxz.dao.StudentDao&quot;&gt; &lt;!-- 查询数据条目 --&gt; &lt;select id=&quot;getTotal&quot; resultType=&quot;int&quot;&gt; SELECT COUNT(*) FROM student &lt;/select&gt; &lt;!-- 增加一条数据 --&gt; &lt;insert id=&quot;addStudent&quot; parameterType=&quot;Student&quot;&gt; INSERT INTO student VALUES(NULL, #{student_id}, #{name}, #{age}, #{sex}, #{birthday}) &lt;/insert&gt; &lt;!-- 删除一条数据 --&gt; &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;int&quot;&gt; DELETE FROM student WHERE id = #{id} &lt;/delete&gt; &lt;!-- 更新一条数据 --&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;Student&quot;&gt; UPDATE student SET student_id = #{student_id}, name = #{name}, age = #{age}, sex = #{sex}, birthday = #{birthday} WHERE id = #{id} &lt;/update&gt; &lt;!-- 查询一条数据 --&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;student&quot; parameterType=&quot;int&quot;&gt; SELECT * FROM student WHERE id = #{id} &lt;/select&gt; &lt;resultMap id=&quot;student&quot; type=&quot;student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;student_id&quot; property=&quot;student_id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 查询从start位置开始的count条数据--&gt; &lt;select id=&quot;list&quot; resultMap=&quot;student&quot;&gt; SELECT * FROM student ORDER BY student_id desc limit #{param1}, #{param2} &lt;/select&gt; &lt;/mapper&gt;编写好了 Dao 类是需要测试的，这里测试类就不给出了。 ⑦ 业务类设计 问题： 为什么不直接使用 Dao 类而是还要在上面封装一层 Service 层呢？ 回答：基于责任分离的原则，Dao 层就应该专注于对数据库的操作，而在 Service 层我们可以增加一些非 CRUD 的方法去更好的完成本身抽离出来的 service 服务（业务处理）。 在【cn.wmyskxz.service】包下创建【StudentService】接口： package cn.wmyskxz.service; import cn.wmyskxz.entity.Student; import java.util.List; public interface StudentService { /** * 获取到 Student 的总数 * @return */ int getTotal(); /** * 增加一条数据 * @param student */ void addStudent(Student student); /** * 删除一条数据 * @param id */ void deleteStudent(int id); /** * 更新一条数据 * @param student */ void updateStudent(Student student); /** * 找到一条数据 * @param id * @return */ Student getStudent(int id); /** * 列举出从 start 位置开始的 count 条数据 * @param start * @param count * @return */ List&lt;Student&gt; list(int start, int count); }并在相同包名下创建实现类【StudentServiceImpl】： package cn.wmyskxz.service; import cn.wmyskxz.dao.StudentDao; import cn.wmyskxz.entity.Student; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; /** * StudentService 的实现类 * * @author: @我没有三颗心脏 * @create: 2018-04-23-下午 13:51 */ @Service public class StudentServiceImpl implements StudentService { @Autowired StudentDao studentDao; public int getTotal() { return studentDao.getTotal(); } public void addStudent(Student student) { studentDao.addStudent(student); } public void deleteStudent(int id) { studentDao.deleteStudent(id); } public void updateStudent(Student student) { studentDao.updateStudent(student); } public Student getStudent(int id) { return studentDao.getStudent(id); } public List&lt;Student&gt; list(int start, int count) { return studentDao.list(start, count); } }⑧ 功能开发在【cn.wmyskxz.controller】包下创建【StudentController】控制器，代码基本上都是复制黏贴之前在 Servlet 中的代码： package cn.wmyskxz.controller; import cn.wmyskxz.entity.Student; import cn.wmyskxz.service.StudentService; import cn.wmyskxz.util.Page; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; /** * Student 控制器 * * @author: @我没有三颗心脏 * @create: 2018-04-23-下午 13:27 */ @Controller @RequestMapping(&quot;&quot;) public class StudentController { @Autowired private StudentService studentService; @RequestMapping(&quot;/addStudent&quot;) public String addStudent(HttpServletRequest request, HttpServletResponse response) { Student student = new Student(); int studentID = Integer.parseInt(request.getParameter(&quot;student_id&quot;)); String name = request.getParameter(&quot;name&quot;); int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); String sex = request.getParameter(&quot;sex&quot;); Date birthday = null; // String 类型按照 yyyy-MM-dd 的格式转换为 java.util.Date 类 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try { birthday = simpleDateFormat.parse(request.getParameter(&quot;birthday&quot;)); } catch (ParseException e) { e.printStackTrace(); } student.setStudent_id(studentID); student.setName(name); student.setAge(age); student.setSex(sex); student.setBirthday(birthday); studentService.addStudent(student); return &quot;redirect:listStudent&quot;; } @RequestMapping(&quot;/listStudent&quot;) public String listStudent(HttpServletRequest request, HttpServletResponse response) { // 获取分页参数 int start = 0; int count = 10; try { start = Integer.parseInt(request.getParameter(&quot;page.start&quot;)); count = Integer.parseInt(request.getParameter(&quot;page.count&quot;)); } catch (Exception e) { } Page page = new Page(start, count); List&lt;Student&gt; students = studentService.list(page.getStart(), page.getCount()); int total = studentService.getTotal(); page.setTotal(total); request.setAttribute(&quot;students&quot;, students); request.setAttribute(&quot;page&quot;, page); return &quot;listStudent&quot;; } @RequestMapping(&quot;/deleteStudent&quot;) public String deleteStudent(int id) { studentService.deleteStudent(id); return &quot;redirect:listStudent&quot;; } @RequestMapping(&quot;/editStudent&quot;) public ModelAndView editStudent(int id) { ModelAndView mav = new ModelAndView(&quot;editStudent&quot;); Student student = studentService.getStudent(id); mav.addObject(&quot;student&quot;, student); return mav; } @RequestMapping(&quot;/updateStudent&quot;) public String updateStudent(HttpServletRequest request, HttpServletResponse response) { Student student = new Student(); int id = Integer.parseInt(request.getParameter(&quot;id&quot;)); int student_id = Integer.parseInt(request.getParameter(&quot;student_id&quot;)); String name = request.getParameter(&quot;name&quot;); int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); String sex = request.getParameter(&quot;sex&quot;); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date birthday = null; try { birthday = simpleDateFormat.parse(request.getParameter(&quot;birthday&quot;)); } catch (ParseException e) { e.printStackTrace(); } student.setId(id); student.setStudent_id(student_id); student.setName(name); student.setAge(age); student.setSex(sex); student.setBirthday(birthday); studentService.updateStudent(student); return &quot;redirect:listStudent&quot;; } } 注意： 所有的学号都用 student_id 表示，为了契合在数据库中的字段名（包括下面的 JSP 文件） JSP 文件也直接黏之前的就好了，不过需要注意所有的 name 属性： 【listStudent.jsp】： &lt;!DOCTYPE html&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;%-- 引入JQ和Bootstrap --%&gt; &lt;script src=&quot;js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;学生管理页面 - 首页&lt;/title&gt; &lt;script&gt; $(function () { $(&quot;ul.pagination li.disabled a&quot;).click(function () { return false; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;listDIV&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover table-condensed&quot;&gt; &lt;caption&gt;学生列表 - 共${page.total}人&lt;/caption&gt; &lt;thead&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;出生日期&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;${students}&quot; var=&quot;s&quot; varStatus=&quot;status&quot;&gt; &lt;tr&gt; &lt;td&gt;${s.student_id}&lt;/td&gt; &lt;td&gt;${s.name}&lt;/td&gt; &lt;td&gt;${s.age}&lt;/td&gt; &lt;td&gt;${s.sex}&lt;/td&gt; &lt;td&gt;${s.birthday}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/editStudent?id=${s.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-edit&quot;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/deleteStudent?id=${s.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;nav class=&quot;pageDIV&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt; &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt; &gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li &lt;c:if test=&quot;${!page.hasNext}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt; &lt;span&gt;›&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasNext}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.last}&quot;&gt; &lt;span&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;addDIV&quot;&gt; &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;增加学生&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;/addStudent&quot; role=&quot;form&quot;&gt; &lt;table class=&quot;addTable&quot;&gt; &lt;tr&gt; &lt;td&gt;学号：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;student_id&quot; id=&quot;student_id&quot; placeholder=&quot;请在这里输入学号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请在这里输入名字&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; placeholder=&quot;请在这里输入年龄&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请在这里输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;submitTR&quot;&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;提 交&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 【editStudent.jsp】： &lt;!DOCTYPE html&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;%-- 引入JQ和Bootstrap --%&gt; &lt;script src=&quot;js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;学生管理页面 - 编辑页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;editDIV&quot;&gt; &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;编辑学生&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;/updateStudent&quot; role=&quot;form&quot;&gt; &lt;table class=&quot;editTable&quot;&gt; &lt;tr&gt; &lt;td&gt;学号：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;student_id&quot; id=&quot;student_id&quot; value=&quot;${student.student_id}&quot; placeholder=&quot;请在这里输入学号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; value=&quot;${student.name}&quot; placeholder=&quot;请在这里输入名字&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; value=&quot;${student.age}&quot; placeholder=&quot;请在这里输入年龄&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; value=&quot;${student.birthday}&quot; placeholder=&quot;请在这里输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;submitTR&quot;&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${student.id}&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;提 交&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; style.css 文件： body { padding-top: 60px; } div.listDIV { width: 600px; margin: 0 auto; } div.editDIV { width: 400px; margin: 0 auto; } nav.pageDIV { text-align: center; } div.addDIV { width: 300px; margin: 0 auto; } table.addTable { width: 100%; padding: 5px; } table.addTable td { padding: 5px; } table.editTable { width: 100%; padding: 5px; } table.editTable td { padding: 5px; }项目的整体结构 分页功能 首先在 Packge【util】包下创建一个 Page 工具类： package cn.wmyskxz.util; public class Page { int start; // 开始数据 int count; // 每一页的数量 int total; // 总共的数据量 public Page(int start, int count) { super(); this.start = start; this.count = count; } public boolean isHasPreviouse(){ if(start==0) return false; return true; } public boolean isHasNext(){ if(start==getLast()) return false; return true; } public int getTotalPage(){ int totalPage; // 假设总数是50，是能够被5整除的，那么就有10页 if (0 == total % count) totalPage = total /count; // 假设总数是51，不能够被5整除的，那么就有11页 else totalPage = total / count + 1; if(0==totalPage) totalPage = 1; return totalPage; } public int getLast(){ int last; // 假设总数是50，是能够被5整除的，那么最后一页的开始就是40 if (0 == total % count) last = total - count; // 假设总数是51，不能够被5整除的，那么最后一页的开始就是50 else last = total - total % count; last = last&lt;0?0:last; return last; } // 各种 setter 和 getter } totalPage 是计算得来的数，用来表示页码一共的数量 在首页显示的 StudentList 用 page 的参数来获取： List&lt;Student&gt; students = studentService.list(page.getStart(), page.getCount());并且在映射文件中用 LIMIT 关键字： &lt;!-- 查询从start位置开始的count条数据--&gt; &lt;select id=&quot;list&quot; resultMap=&quot;student&quot;&gt; SELECT * FROM student ORDER BY student_id desc limit #{param1}, #{param2} &lt;/select&gt; 第一个参数为 start，第二个参数为 count这样就能根据分页的信息来获取到响应的数据 编写分页栏： 1.写好头和尾 &lt;nav class=&quot;pageDIV&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; ..... &lt;/ul&gt; &lt;/nav&gt;2.写好« ‹这两个功能按钮使用 &lt;c:if&gt;标签来增加边界判断，如果没有前面的页码了则设置为disable状态 &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;再通过 JavaScrip 代码来完成禁用功能： &lt;script&gt; $(function () { $(&quot;ul.pagination li.disabled a&quot;).click(function () { return false; }); }); &lt;/script&gt;3.完成中间页码的编写从 0 循环到 page.totalPage - 1 ，varStatus 相当于是循环变量 status.count 是从1开始遍历 status.index 是从0开始遍历 要求：显示当前页码的前两个和后两个就可，例如当前页码为3的时候，就显示 1 2 3(当前页) 4 5 的页码 理解测试条件： 10 &lt;= 当前页*每一页显示的数目 - 当前页开始的数据编号 &lt;= 30 只要理解了这个判断条件，其他的就都好理解了 &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt; &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt; &gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt;4.在控制器中获取参数 // 获取分页参数 int start = 0; int count = 10; try { start = Integer.parseInt(request.getParameter(&quot;page.start&quot;)); count = Integer.parseInt(request.getParameter(&quot;page.count&quot;)); } catch (Exception e) { } .... // 共享 page 数据 request.setAttribute(&quot;page&quot;, page);Date 转换的问题最开始的时候，我们看到页面上显示的日期是这样的格式： 这显然是我们不希望看到的 解决方案：在映射文件中设置日期显示的类型。 重新部署文件，然后刷新页面，就能看到我们希望的效果啦： 项目总结 由于之前的项目代码都有，所以在重构的时候，基本上没有花什么时间就完成了项目的搭建，能够体会到代码分离的重要性，这在很大程度上保证了我们的代码复用。 相较于之前用 Servlet + JSP 来完成，很明显的感觉是DAO层的编写方便了很多，仅仅需要编写一个 xml 映射文件和一个 Dao 层接口就可以完成功能，而不用自己再去重复的去在每一个 CRUD 方法中去处理结果集，重复而且繁琐。 注解真的很方便，这不仅仅提升了我们自身开发的效率，写起来也很带劲儿。 开发效率快，而且低耦合，我们基于 xml 配置了大部分的工作，在基于 SSM 框架开发时，我们可以把专注点集中在逻辑处理上。 在 SSM 框架中能方便的对项目进行修改，这不仅仅得益于框架的约定，使得代码分离并且可复用，也得益于 Maven 工具对于项目的管理。 我们能够通过一个 Controller 来完成五个 Servlet 的功能，并且通过注解来完成配置。 项目改进项目很简单，仅仅也只是在数据库增删改查的基础上增加了一个界面，我们来动手改一改。 改进一：增加删除提示第一个想到的就是删除提示，没有删除提示是很要命的一件事情，如果手滑了一下那可能就悲剧了…. 首先我们在顶部的 &lt;head&gt; 标签中的 &lt;script&gt; 中增加一段代码： function del() { var msg = &quot;您真的确定要删除吗？\\n\\n请确认！&quot;; if (confirm(msg) == true) { return true; } else { return false; } }然后在删除 a 标签页中增加 onclick 属性： onclick=&quot;javascript:return del();&quot; ....就像下面这样.... td&gt;&lt;a href=&quot;/deleteStudent?id=${s.id}&quot; onclick=&quot;javascript:return del();&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/td&gt;当我们刷新页面后，点击删除就会弹出提示信息： 改进二：编辑页面自动勾选上性别在当前的项目中，如果点击编辑按钮进入到编辑页面后，性别这个选项是空选的状态，这就很low： 这个也很简单，在 editStudent 页面增加一些判断就好了： 用 &lt;c:if&gt; 标签来判断 sex 的值，然后根据对应的属性增加 checked 属性，这样就可以自动勾选上所对应的属性： 改进三：空值判断我们允许设置为 null 的值仅仅为出生日期，其他的值均不允许出现空值，所以我们需要加入空值判断： function checkEmpty(id, name) { var value = $(&quot;#&quot; + id).val(); if (value.length == 0) { alert(name + &quot;不能为空&quot;); $(&quot;#&quot; + id).focus(); return false; } return true; }然后再为 form 创建一个 id 属性值为 “addForm” 并添加进判断空值的方法： 注意： 这里需要写在 $(function(){}) 里面，等待文档加载完毕才能生效。 这里并没有为 sex 属性判断空值，我们采用一个简单的为 sex 添加一个默认勾选项来省略空值的判断。 同样的，我们也在编辑页面，采用同样的方法进行空值判断： 当进入编辑页面的时候已经有默认的勾选项了，所以 sex 值仍然不需要判空 最后给出项目地址：https://github.com/wmyskxz/StudentManager-SSM 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"tags":[{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"}],"author":"我没有三颗心脏"},{"title":"IDEA整合SSM框架学习","slug":"IDEA整合SSM框架学习","date":"2018-04-23T00:47:00.000Z","updated":"2020-12-09T05:03:30.535Z","comments":true,"path":"2018/04/23/idea-zheng-he-ssm-kuang-jia-xue-xi/","link":"","permalink":"http://www.wmyskxz.com/2018/04/23/idea-zheng-he-ssm-kuang-jia-xue-xi/","excerpt":"","text":"认识 Spring 框架 更多详情请点击这里：这里 Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 IoC (Inversion of Control，控制反转) 和 AOP(Aspect Oriented Programming，面向切面编程)。 什么是 Spring： Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。 Spring 提倡以“最少侵入”的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring 适用范围：任何 Java 应用 Spring 的根本使命：简化 Java 开发 尽管 J2EE 能够赶上 Spring 的步伐，但 Spring 并没有停止前进， Spring 继续在其他领域发展，而 J2EE 则刚刚开始涉及这些领域，或者还没有完全开始在这些领域的创新。移动开发、社交 API 集成、NoSQL 数据库、云计算以及大数据都是 Spring 正在涉足和创新的领域。Spring 的前景依然会很美好。 Spring 的优势 低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring 能帮我们做什么①.Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。②.Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。③.Spring 能非常简单的帮我们管理数据库事务。④.Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。⑤.Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。⑥.Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring 的框架结构 Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 Spring IoC 概述 更多详情请点击这里：这里 IoC：Inverse of Control（控制反转） 读作“反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 正控：若要使用某个对象，需要自己去负责对象的创建 反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架 好莱坞法则：Don’t call me ,I’ll call you 一个例子控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。 在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。 然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。 请注意你并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。 Spring IoC 阐述这就是一种控制反转的理念，上述的例子已经很好的说明了问题，我们再来描述一下控制反转的概念：控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。 好处：降低对象之间的耦合我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿） 主动创建的模式中，责任归于开发者，而在被动的模式下，责任归于 IoC 容器，基于这样的被动形式，我们就说对象被控制反转了。（也可以说是反转了控制） Spring AOP 简介 更多详情请点击这里：这里 如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。 AOP 即 Aspect Oriented Program 面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP AOP 的目的AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 一个例子为了更好的说明 AOP 的概念，我们来举一个实际中的例子来说明： 在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 AOP 的一个思想：让关注点代码与业务代码分离！ 认识 MyBatis 框架 更多详情请点击这里：这里 MyBatis 简介MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点：可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 灵活，几乎可以代替 JDBC，同时提供了接口编程。 缺点：慢（相对于内存而言） 为什么使用 MyBatis在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 认识 Spring MVC 框架 更多详情请点击这里：这里 MVC 设计概述在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1： 出现的弊端： JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 代码难以复用 正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。 M 代表 模型（Model）模型是什么呢？ 模型就是数据，就是 dao,bean V 代表 视图（View）视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller)控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 扩展阅读：Web开发模式 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点：结构松散，几乎可以在 Spring MVC 中使用各类视图松耦合，各个模块分离与 Spring 无缝集成 Spring + Spring MVC + MyBatis 整合开发认识 MavenMaven 的翻译为 “专家”、“行家” ，是一个跨平台的项目管理工具。 主要用于：基于 Java 平台的项目（Maven 本身也是 Java 编写的）的构建、依赖包管理和项目信息管理。 Maven 主要用处一：相同的项目结构Maven 提供了一种标准的项目目录结构，测试命名规则等项目的最佳实践方案，统一了不同项目的学习成本（约定大于配置）： 在 IDEA 下创建一个默认的 Maven 项目，有着上面这样相同的结构： 有一个 pom.xml 用于维护当前项目所依赖的 jar 包 所有的 Java 代码都放在 src/main/java 目录下 所有的测试代码都放在 src/test/java 目录下 Maven 主要用处二：统一维护 jar 包Maven能提供一种项目的依赖配置，配置好的项目，Maven 能自动的从 Maven 的中央仓库中帮我们下载并管理项目依赖的 jar 包，并且还能自动的管理这些 jar 包依赖的其他 jar 包 比如说有 3 个 Java 项目，这些项目都不是 maven 风格。那么这3个项目，就会各自维护一套jar包。 而其中有些jar包是相同的。 而 maven 风格的项目，首先把所有的 jar 包都放在”仓库“ 里，然后哪个项目需要用到这个 jar 包，只需要给出 jar 包的名称和版本号就行了。 这样 jar 包就实现了共享 如图所示，在 pom.xml 里，表示用到了 mysql 的jar包，版本号是 5.1.30。 引自：how2j.cn-Maven教程 使用 Maven 构建 SSM 项目如果对于 Maven 不熟悉的童鞋可以去上面的链接学习一下 Maven 的使用，下面是我配置好了 Maven 的 IDEA 环境下的构建过程。 第一步：创建 Maven webapp 项目首先新建工程，选择 Maven 标签，然后勾选上【Create from archetype】选择 webapp： 点击下一步，填写上【GroupId】和【ArtifactId】： GroupId：项目组织唯一的标识符，实际对应 JAVA 的包的结构，也就是 main 目录下 java 的目录结构（包） AritifactId：项目的唯一标识符，实际对应项目的名称，就是项目根目录的名称 实际上你可以乱填上试试，我就不乱填了 确认项目路径，这一步你可以看到 Maven 配置中的参数，不需要做改动，直接下一步就可以（图中的路径是我配置的本地 Maven 仓库的地址）： 确认项目名称，点击【Finish】即可： 等待一会儿，控制台就会有创建成功的提示信息，我们把【Enable Auto-Import】点上，这个提示会在每次 pom.xml 有改动时出现，自动导入，省掉麻烦： 第二步：搭建项目目录结构下面就是 Maven 风格的 webapp 的默认目录结构： 注意： webapp 是默认没有 java 源文件也没有 test 目录的。 遵循 Maven 的统一项目结构，我们搭建出项目的完整目录结构如下图： 我们并没有使用 Log4j 来输出日志，而是使用 logback 提示：我们可以在 IDEA 中右键目录然后选择【Make Directory as】，让 IDEA 识别不同的目录作用 这里的目录建好之后还需要设置一下，让 IDEA 识别目录作用，选择【File】&gt;【Project Structure】： 设置好之后点击 OK，即完成了项目目录的搭建。 第三步：配置文件内容在【pom.xml】文件中声明依赖的 jar 包 ： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SSM&lt;/name&gt; &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt; &lt;artifactId&gt;SSM&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version} &lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt;在【web.xml】中声明编码过滤器并配置 DispatcherServlet ： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;在【spring-mybatis.xml】中完成 spring 和 mybatis 的配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=&quot;cn.wmyskxz.service&quot;/&gt; &lt;!-- 配置数据库相关参数properties的属性：${url} --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${c3p0.maxPoolSize}&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${c3p0.minPoolSize}&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;${c3p0.autoCommitOnClose}&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;${c3p0.checkoutTimeout}&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;${c3p0.acquireRetryAttempts}&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.wmyskxz.entity&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.wmyskxz.dao&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt;在【spring-mvc.xml】中完成 Spring MVC 的相关配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;cn.wmyskxz.controller&quot;/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置jsp 显示ViewResolver --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt;在【jdbc.properties】中配置 c3p0 数据库连接池： jdbc.driver=com.mysql.jdbc.Driver #数据库地址 jdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8 #用户名 jdbc.username=root #密码 jdbc.password=root #最大连接数 c3p0.maxPoolSize=30 #最小连接数 c3p0.minPoolSize=10 #关闭连接后不自动commit c3p0.autoCommitOnClose=false #获取连接超时时间 c3p0.checkoutTimeout=10000 #当获取连接失败重试次数 c3p0.acquireRetryAttempts=2在【logback.xml】中完成日志输出的相关配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration debug=&quot;true&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/root&gt; &lt;/configuration&gt;以上就完成了基本的相关配置： 添加进了 SSM 项目所需要的 jar 包 配置好了 spring/mybatis/spring MVC 的相关配置信息（自动扫描 cn.wmyskxz 包下的带有注解的类） 通过 xml 配置的方式配置好了日志和数据库 第四步：测试 SSM 框架准备好用来测试的数据库： DROP DATABASE IF EXISTS ssm; CREATE DATABASE ssmDEFAULT CHARACTER SET utf8; use ssm; CREATE TABLE user( id int(11) NOT NULL AUTO_INCREMENT, username varchar(50) NOT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO user VALUES(1,&#39;我没有三颗心脏&#39;);接下来在【cn.wmyskxz.entity】包下创建好对应的实体类 User ： package cn.wmyskxz.entity; /** * User 实体类 * * @author: @我没有三颗心脏 * @create: 2018-04-23-上午 9:23 */ public class User { private int id; private String username; /* getter and setter */ } 在【cn.wmyskxz.dao】包下创建好 Dao 接口： package cn.wmyskxz.dao; import cn.wmyskxz.entity.User; public interface UserDao { // 根据 id 寻找对应的 User User findUserById(int id); }在【resources/mapper】下编写 UserDao.xml 映射文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 设置为IUserDao接口方法提供sql语句配置 --&gt; &lt;mapper namespace=&quot;cn.wmyskxz.dao.UserDao&quot;&gt; &lt;select id=&quot;findUserById&quot; resultType=&quot;cn.wmyskxz.entity.User&quot; parameterType=&quot;int&quot;&gt; SELECT * FROM user WHERE id = #{id} &lt;/select&gt; &lt;/mapper&gt;在编写好每一个 Dao 的时候，我们都需要对它进行测试，在【test/java】下创建一个【UserDaoTest】的测试类： import cn.wmyskxz.dao.UserDao; import cn.wmyskxz.entity.User; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; /** * UserDao 的测试类 * * @author: @我没有三颗心脏 * @create: 2018-04-23-上午 9:54 */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration({\"classpath:spring-mybatis.xml\"}) public class UserDaoTest { @Autowired private UserDao userDao; @Test public void testFindUserById() { int id = 1; User user = userDao.findUserById(id); System.out.println(user.getId() + \":\" + user.getUsername()); } } 运行测试代码，能够获取到正确的信息： 接着在【cn.wmyskxz.service】包下编写好对应的 UserService 接口： package cn.wmyskxz.service; import cn.wmyskxz.entity.User; public interface UserService { // 根据 id 寻找对应的 User public User findUserById(int id); }和对应的实现类： package cn.wmyskxz.service; import cn.wmyskxz.dao.UserDao; import cn.wmyskxz.entity.User; import org.springframework.stereotype.Service; import javax.annotation.Resource; /** * UserService 对应的实现类 * * @author: @我没有三颗心脏 * @create: 2018-04-23-上午 9:31 */ @Service(&quot;userService&quot;) public class UserServiceImpl implements UserService { @Resource private UserDao userDao; public User findUserById(int id) { return userDao.findUserById(id); } }在【cn.wmyskxz.controller】下创建【UserController】控制类： package cn.wmyskxz.controller; import cn.wmyskxz.entity.User; import cn.wmyskxz.service.UserService; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import javax.annotation.Resource; /** * User 的控制类 * * @author: @我没有三颗心脏 * @create: 2018-04-23-上午 9:58 */ @Controller @RequestMapping(&quot;&quot;) public class UserController { @Resource private UserService userService; @RequestMapping(&quot;/findUser&quot;) public String findUser(Model model) { int id = 1; User user = this.userService.findUserById(id); model.addAttribute(&quot;user&quot;, user); return &quot;index&quot;; } }最后在【WEB-INF/views】下创建 index.jsp 用于接收并显示数据： &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;SSM 框架整合&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${user.id}：${user.username} &lt;/body&gt; &lt;/html&gt;配置好 Tomcat 服务器，运行并在浏览器中输入：localhost/findUser 即完成了 SSM 的整合！ 参考资料：使用idea2017搭建SSM框架最开始想要手动添加 jar 包依赖创建，但是调了 1 天的 bug 也不通，换了很多 jar 包…有点崩溃，后来直接使用 Maven 创建就成功了…参考了上面链接的文章。 SSM 框架架构图为了更加能理解 SSM 处理用户请求的整个过程，下面给出一张 SSM 系统架构图： 通常我们还会在 Controller 和 Service 层中引入工厂模式，这里仅仅是创建了一个简单的 SSM 项目，用以测试而已，并且没有配置 MyBatis 的相关信息，如果需要配置在 resource 目录下创建一个 SqlMapConfig.xml 文件并且完成 &lt;settings&gt; 的相关配置即可。 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Spring MVC + MyBatis开发从入门到项目实战》 全能的百度和万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SSM","slug":"后端/Java/SSM","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SSM/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"MyBatis与Spring整合","slug":"MyBatis与Spring整合","date":"2018-04-18T00:44:00.000Z","updated":"2020-12-09T05:08:39.364Z","comments":true,"path":"2018/04/18/mybatis-yu-spring-zheng-he/","link":"","permalink":"http://www.wmyskxz.com/2018/04/18/mybatis-yu-spring-zheng-he/","excerpt":"","text":"MyBatis—Spring 项目目前大部分的 Java 互联网项目，都是用 Spring MVC + Spring + MyBatis 搭建平台的。 使用 Spring IoC 可以有效的管理各类的 Java 资源，达到即插即拔的功能；通过 Spring AOP 框架，数据库事务可以委托给 Spring 管理，消除很大一部分的事务代码，配合 MyBatis 的高灵活、可配置、可优化 SQL 等特性，完全可以构建高性能的大型网站。 毫无疑问，MyBatis 和 Spring 两大框架已经成了 Java 互联网技术主流框架组合，它们经受住了大数据量和大批量请求的考验，在互联网系统中得到了广泛的应用。使用 MyBatis-Spring 使得业务层和模型层得到了更好的分离，与此同时，在 Spring 环境中使用 MyBatis 也更加简单，节省了不少代码，甚至可以不用 SqlSessionFactory、 SqlSession 等对象，因为 MyBatis-Spring 为我们封装了它们。 摘自：《Java EE 互联网轻量级框架整合开发》 第一步：创建测试工程第一步，首先在 IDEA 中新建一个名为【MybatisAndSpring】的 WebProject 工程： 然后在【src】中创建 4 个空包： cn.wmyskxz.dao（放置 DAO 数据交互层处理类） cn.wmyskxz.mapper（放置 Mapper 代理接口） cn.wmyskxz.pojo（放置 Java 实体类） cn.wmyskxz.test（放置测试类） 接着新建源文件夹【config】，用于放置各种资源配置文件： 在【config / mybatis】下创建一个空的名为 “SqlMapConfig.xml” 的 MyBatis 全局配置文件 在【config / spring】下创建一个空的名为 “applicationContext.xml” 的 Spring 资源配置文件 在【config / sqlmap】下创建一个空的名为 “UserMapper.xml” 的 Mapper 映射文件。 在【config】下创建两个 properties 属性文件，分别为 “db.properties” 和 “log4j.properties”，用于数据库连接和日志系统参数设置。 再在【web】文件夹下新建一个【WEB-INF】默认安全文件夹，并在其下创建一个【classes】和【lib】，并将项目的输出位置，改在【classes】下： 工程的完整初始结构如下： 第二步：引入依赖 jar 包第二步，就是要准备项目的依赖 jar 包： MyBatis 的包（MyBatis 3.4.6） Spring 的 jar 包（Spring 4.3.15） MyBatis 与 Spring 的整合 jar 包（mybatis-spring 1.3.2） mysql-connector-java-5.1.21.jar junit-4.12.jar 在【WEB-INF】文件夹下的【lib】文件夹中放置上面列举的 jar 包，然后添加依赖。 第三步：编写 Spring 配置文件第三步，编写 Spring 的配置文件： 加载数据库连接文件 “db.properties” 中的数据，建立数据源 配置 sqlSessionFactory 会话工厂对象 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 加载 MyBatis 的配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;/&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 头部的信息就是声明 xml 文档配置标签的规则的限制与规范。 “context:property-placeholder” 配置是用于读取工程中的静态属性文件，然后在其他配置中使用时，就可以采用 “${属性名}” 的方式获取该属性文件中的配置参数值。 配置了一个名为 “dataSrouce” 的 bean 的信息，实际上是连接数据库的数据源。 设置 sqlSessionFactory 的 bean 实现类为 MyBatis 与 Spring 整合 jar 包中的 SqlSessionFactoryBean 类，在其中只需要注入两个参数：一个是 MyBatis 的全局配置文件，一个是上面配置的数据源 bean 第四步：编写 MyBatis 配置文件第四步，在【mybatis】包下编写 MyBatis 的全局配置文件 SqlMapConfig.xml ： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- settings --&gt; &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将积极加载改为消极加载（即按需加载） --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!-- 打开全局缓存开关（二级缓存）默认值就是 true --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!-- 别名定义 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.wmyskxz.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;!-- 通过 resource 方法一次加载一个映射文件 --&gt; &lt;mapper resource=&quot;sqlmap/UserMapper.xml&quot;/&gt; &lt;!-- 批量加载mapper --&gt; &lt;package name=&quot;cn.wmyskxz.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt;在该配置文件中： 通过 settings 配置了一些延迟加载和缓存的开关信息 在 typeAliases 中设置了一个 package 的别名扫描路径，在该路径下的 Java 实体类都可以拥有一个别名（即首字母小写的类名） 在 mappers 配置中，使用 mapper 标签配置了即将要加载的 Mapper 映射文件的资源路径，当然也可以使用 package 标签，配置 mapper 代理接口所在的包名，以批量加载 mapper 代理对象。 注意： 有了 Spring 托管数据源，在 MyBatis 配置文件中仅仅需要关注性能化配置。 第五步：编写 Mapper 以及其他配置文件第五步，编写 Mapper 映射文件，这里依然定义 Mapper 映射文件的名字为 “UserMapper.xml” （与 SqlMapConfig.xml 中配置一致），为了测试效果，只配置了一个查询类 SQL 映射： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;_int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;/select&gt; &lt;/mapper&gt;在该配置中，输出参数的映射为 “user” ，这是因为之前在 SqlMapConfig.xml 中配置了 “cn.wmyskxz.pojo” 包下的实体类使用别名（即首字母小写的类名），所以这里只需在 “cn.wmyskxz.pojo” 包下，创建 “finduserById” 对应的 Java 实体类 User： package cn.wmyskxz.pojo; import java.io.Serializable; public class User implements Serializable { private int id; private String username; /* getter and setter */ } 实现 Serializable 接口是为之后使用 Mapper 动态代理做准备，这里没有使用动态代理。 在数据库资源 “db.properties” 中配置了数据库的连接信息，以 “key=value” 的形式配置，String 正是使用 “${}” 获取其中 key 对应的 value 配置的： jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8 jdbc.username=root jdbc.password=root另外日志配置和之前的配置一样，我就直接黏贴了： # Global logging configuration # 在开发环境下日志级别要设置成 DEBUG ，生产环境设为 INFO 或 ERROR log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n第六步：编写 DAO 层第六步，进行数据库交互（Data Access Object）层的编写。 由于该项目只对 User 用户查询，所以 DAO 层就只有一个类，在 “cn.wmyskxz” 包下创建 DAO 层的 interface 接口，其中定义了 findUserById 方法，参数为用户的 id 值（int 类型）： package cn.wmyskxz.dao; import cn.wmyskxz.pojo.User; public interface UserDAO { // 根据 id 查询用户信息 public User findUserById(int id) throws Exception; }然后在同一个包下创建 UserDAO 接口的实现类 UserDAOImpl: package cn.wmyskxz.dao; import cn.wmyskxz.pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; public class UserDAOImpl extends SqlSessionDaoSupport implements UserDAO { @Override public User findUserById(int id) throws Exception { // 继承 SqlSessionDaoSupport 类，通过 this.getSqlSession() 得到 sqlSession SqlSession sqlSession = this.getSqlSession(); User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id); return user; } } 有几点解释： UserDAOImpl 不仅实现了 UserDAO 接口，而且继承了 SqlSessionDaoSupport 类。 SqlSessionDaoSupport 类是 MyBatis 与 Spring 整合的 jar 包中提供的，在该类中已经包含了 sqlSessionFactory 对象作为其成员变量，而且对外提供 get 和 set 方法，方便 Spring 从外部注入 sqlSessionFactory 对象。 UserDAOImpl 类要成功获取 sqlSessionFactory 对象，还需要在 Spring 配置文件 applicationContext.xml 中添加 userDAO 的 bean 配置，将其中定义的 sqlSessionFactory 对象当做参数注入进去，这样 UserDAOImpl 继承 SqlSessionDaoSupport 类才会起到作用： &lt;!-- 原始 DAO 接口 --&gt; &lt;bean id=&quot;userDAO&quot; class=&quot;cn.wmyskxz.dao.UserDAOImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 注意： DAO 实现类继承了 SqlSessionDaoSupport 父类后，就无须自己定义获取 SqlSession 会话实例类方法了，该父类会默认加载数据源信息并提供获取 SqlSession 类的方法。 第七步：编写 Service 测试类在 “cn.wmyskxz.test” 包下创建【UserServiceTest】测试类： package cn.wmyskxz.test; import cn.wmyskxz.dao.UserDAO; import cn.wmyskxz.pojo.User; import org.junit.Before; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserServiceTest { private ApplicationContext applicationContext; // 在执行测试方法之前首先获取 Spring 配置文件对象 // 注解@Before在执行本类所有测试方法之前先调用这个方法 @Before public void setup() throws Exception { applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;); } @Test public void testFindUserById() throws Exception { // 通过配置资源对象获取 userDAO 对象 UserDAO userDAO = (UserDAO) applicationContext.getBean(&quot;userDAO&quot;); // 调用 UserDAO 的方法 User user = userDAO.findUserById(1); // 输出用户信息 System.out.println(user.getId() + &quot;:&quot; + user.getUsername()); } }运行测试方法，输出结果如下： 动态代理 + 注解实现上面的实例程序并没有使用 Mapper 动态代理和注解来完成，下面我们就来试试如何用动态代理和注解： 第一步：编写 UserQueryMapper在【mapper】下新建一个【UserQueryMapper】代理接口，并使用注解： package cn.wmyskxz.mapper; import cn.wmyskxz.pojo.User; import org.apache.ibatis.annotations.Select; public interface UserQueryMapper { @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;) public User findUserById(int id) throws Exception; } 注意： 在默认情况下，该 bean 的名字为 userQueryMapper（即首字母小写） 现在有了代理类，我们需要通知 Spring 在这里来扫描到该类，Mapper 扫描配置对象需要用专门的扫描器： &lt;!-- Mapper 扫描器 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 扫描 cn.wmyskxz.mapper 包下的组件 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.wmyskxz.mapper&quot;/&gt; &lt;/bean&gt;第二步：编写测试类这一次我们获取的不再是 userDAO 对象，而是定义的 Mapper 代理对象 userQueryMapper： package cn.wmyskxz.test; import cn.wmyskxz.mapper.UserQueryMapper; import cn.wmyskxz.pojo.User; import org.junit.Before; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserServiceTest { private ApplicationContext applicationContext; // 在执行测试方法之前首先获取 Spring 配置文件对象 // 注解@Before在执行本类所有测试方法之前先调用这个方法 @Before public void setup() throws Exception { applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;); } @Test public void testFindUserById() throws Exception { // 通过配置资源对象获取 userDAO 对象 UserQueryMapper userQueryMapper = (UserQueryMapper) applicationContext.getBean(&quot;userQueryMapper&quot;); // 调用 UserDAO 的方法 User user = userQueryMapper.findUserById(1); // 输出用户信息 System.out.println(user.getId() + &quot;:&quot; + user.getUsername()); } }运行测试方法，得到正确结果： 可以看到，查询结果和之前非 Mapper 代理的查询结果一样。 原理： 在 applicationContext.xml 配置文件中配置的 mapper 批量扫描器类，会从 mapper 包中扫描出 Mapper 接口，自动创建代理对象并且在 Spring 容器中注入。自动扫描出来的 Mapper 的 bean 的 id 为 mapper 类名（首字母小写），所以这里获取的就是名为 “userQueryMapper” 的 mapper 代理对象。 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Spring MVC + MyBatis开发从入门到项目实战》 全能的百度和万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"MyBatis","slug":"后端/Java/MyBatis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/MyBatis/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"《阿里巴巴Java开发手册》读书笔记","slug":"《阿里巴巴Java开发手册》读书笔记","date":"2018-04-18T00:39:00.000Z","updated":"2020-12-09T03:18:21.390Z","comments":true,"path":"2018/04/18/a-li-ba-ba-java-kai-fa-shou-ce-du-shu-bi-ji/","link":"","permalink":"http://www.wmyskxz.com/2018/04/18/a-li-ba-ba-java-kai-fa-shou-ce-du-shu-bi-ji/","excerpt":"","text":"偶然看到阿里巴巴居然出书了？？？趁着满减活动（节约节约….）我赶紧买来准备看看，刚拿到的时候掂量了好多下，总觉得商家给我少发了一本书，结果打开才知道..原来这本书这么小…. 编码规范的重要性别人都说我们是搬砖的码农，但我们知道自己是追求个性的艺术家。也许我们不会过多在意自己的外表和穿着，但在我们不羁的外表下，骨子里追求着代码的美、系统的美、设计的美，代码规范其实就是一个对程序美的定义。—— 引自 序 如果有一天在我们的项目中看到了这样的代码： 或者是这样的代码： 这样美不美呢？或许看着是还挺美的，但是如果需要修改，是不是人傻啦？ 那这样的代码呢？ 作为一个对自己有一定要求的程序猿，是不是第一反应就是： 重写！ 原作者是谁？锤他！ 规范不一，就会像下图中的小鸭和小鸡对话一样，语言不通，一脸囧相。鸡同鸭讲也恰恰形容了人与人之间沟通的痛点，自说自话，无法达成一致意见。再举一个生活中的例子，交通规则靠左行驶还是靠右行驶，两者孰好孰坏并不重要，重要的是必须要在统一的方向上通行，表面上限制了自由，但实际上是保障了公众的人身安全。试想，如果没有规定靠右行驶，那样的路况肯定拥堵不堪，险象环生。同样，过分自由随意、天马行空的代码会严重的伤害系统的健康，影响到可扩展性以及可维护性。 总结：代码规范很重要！ 关于编码规范的三大圣战众所周知，互联网公司的优势在于效率，它是企业核心竞争力。体现在产品开发领域，就是够沟通效率和研发效率。对于沟通效率的重要性，可以从程序猿三大 “编码理念之争” 说起： 缩进采用空格键，还是 Tab 键 if 单行语句需要大括号还是不需要大括号 左大括号不换行，还是单独另起一行 在美剧《硅谷》中，有这样的一个经典镜头： 程序媛：Kid? 我们似乎很久没有一起睡了。 程序猿：现在？不可能！我永远不会和使用空格来缩进的人睡在一起！ 程序媛：（疯狂敲 space 气走了程序猿） 程序猿：（甩了一句）一个 Tab 可以代替 8个 空格！之后程序猿就因为视图一步跨下八个阶梯而摔了…. Tab 键和空格键的争议确实存在，并且在知乎上讨论得火热：写代码时，缩进使用 tab 还是空格？ 总结：使用 4 个空格好，在《阿里巴巴 Java 开发手册》中也明确支持了这样的做法。下面也引用一张图来调侃一下。 if 单语句是否需要换行，也是争论不休的话题。相对来说，写过格式缩进类编程语言的开发者， 更加习惯于不加大括号。《手册》中明确 if/for 单行语句必须加大括号，因为单行语句的写法，容易在添加逻辑时引起视觉上的错误判断。此外，if 不加大括号还会有局部变量作用域的问题。 左大括号是否单独另起一行？因为 Go 语言的强制不换行，在这点上，“编程理念之争” 的硝烟味似乎没有那么浓。如果一定要给一个理由，那么换行的代码可以增加一行，对于按代码行数考核工作量的公司员工，肯定倾向于左大括号前换行。《手册》明确左大括号不换行！ 总结： 其实，很多编程方式客观上没有对错之分，一致性很重要，可读性很重要，团队沟通效率很重要。 第1章：编程规约这一章是对传统意义上的代码规范，包括变量命名、代码风格、控制语句、代码注释等基本的变成习惯，以及从高并发场景中提炼出来的集合处理技巧与并发多线程的注意事项。 1.1 命名风格第一条：【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例：_name / $name / name_ / name$ 尽管 $ 可以作为标识符使用，然而我们应该尽量避免对其使用。 原因： $ 通常在编译器生成的标识符名称中使用，如果我们也使用这个符号，可能会有一些意想不到的错误发生…. 意想不到的错误示例： package test; public class User$VIP { public static void main(String[] args) { User user = new User(); User.VIP vip = user.new VIP(); vip.print(); } } class User{ class VIP{ void print(){ System.out.println(\"成员类\"); } } } 仔细阅读以下，似乎并没有什么问题，代码也比较简单，但正在我们编译的时候，IDEA提示我们： 定义了重复的代码？归根到底，都是 $ 惹的祸！因为 $ 被编译器所使用，在源文件（.java 文件）编译成字节码（.class 文件）后，会称为顶层类型与嵌套类型之间的连接符。例如，如果存在一个顶层类 A，在其内声明了一个成员类 B，那么编译之后就会产生两个 class 文件，分别为 A.class 与 A$B.class。 就本程序来说，会生成 3 个 class 文件（如果可以编译的话），分别是 User$VIP.class（顶层类）、User.class 与 User$VIP.class（User 类的成员类，也就是类 VIP）。由于试图存在两个 User$VIP.class 所以才会报错！ 第三至第六条：【强制】 类名使用 UpperCamelCase 风格，方法名、参数名、成员变量、局部变量都同意使用 lowerCamelCase 风格，必须遵从驼峰形式。 变量命名全部大写，单词兼用下划线隔开，力求予以表达完整清楚，不要嫌名字太长。 正例：MAX_STOCK_COUNT / PRIZE_NUMBER_EVERYDAY反例：MAX_COUNT / PRIZE_NUMBER 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类名开始，以 Test 结尾。 第八条：【强制】 POJO 类中布尔类型的变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型 Boolen isDeleted; 的属性，它的方法名称也是 isDeleted() ，RPC 框架在反向解析的时候，“误以为” 对应的属性名称是 deleted ，导致属性获取不到抛出异常。 第十二条：【推荐】 如果模块、类、方法使用了设计模式，应在命名时体现出具体模式 说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver; 第十三条：【推荐】 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的间接性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，必须是与接口方法相关的，并且是整个应用的基础变量。 正例：接口方法签名： void commit();接口基础变量： String COMPANY = &quot;alibaba&quot;;反例：接口定义方法： public abstract void commit(); 说明： 如果 JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 第十四条：接口和实现类的命名规则 1）：【强制】 对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 后缀与接口区别。 正例： CacheServiceImpl 实现 CacheServcie 接口 2）：【推荐】 如果是形容能力的接口名称，取对应的形容词为接口名（通常是 -able 的形式）。 正例： AbstractTranslator 实现 Translatable。 1.2 常量定义第二条：【强制】 long 或者 Long 初始赋值时，使用大写的 L，不能是小写的 l。小写的 l 容易跟数字 1 混淆，造成误解。 说明： Long a = 2l; 写得是数字的 21 还是 Long 型的 2？ 第三条：【推荐】 不要使用一个常量类维护所有变量，要按常量功能进行归类，分开维护。 说明： 大而全的变量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在 ConfigConsts 下。 1.3 代码格式public static void main(String[] args){ // 注释的双斜线与注释内容之间有且仅有一个空格 // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有 1 个空格 int flag = 0; // 关键字 if 与括号之间必须有 1 个空格，括号内的 f与左括号、 // 0 与右括号之间不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) { System.out.println(\"world\"); // 右大括号前换行，右大括号后有 else，不用换行 } else { System.out.println(\"ok\"); // 在右大括号后直接结束，则必须换行 } } 第八条：【强制】 方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例：下例中实参的“one”，后边必须要有一个空格。method(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;); 1.4 OOP 规约第二条：【强制】 所有的复写方法，必须加 @Override 注解。 说明： getObject() 与 get0bject() 的问题。一个是字母 O,一个是数字 0，加 @Override 注解可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 第七条：【强制】 所有相同类型的包装类对象之间值得比较，全部使用 equals 方法 说明： 对于 Intergre var = ? 在 -128~127 范围内的赋值， Integer 对象是在 IntegerCache.cache 中产生的，会复用已有的对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象。这是一个大坑，推荐使用 equals 方法进行判断。 第十二条：【强制】 POJO 类必须写 toString 方法。在使用 IDE 中的工具 source&gt;generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。 说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString() 方法打印其属性值，便于排查问题。 1.5 集合处理第七条：【强制】 不要在 foreach 循环里进行元素的 remove / add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。// 正例 Iterator&lt;String> iterator = list.iterator(); while (iterator.hasNext()) { String item = iterator.next(); if (删除元素的条件) { iterator.remove(); } } // 反例 List&lt;String> list = new ArrayList&lt;>(); list.add(\"1\"); list.add(\"2\"); for (String item : list) { // 如果把 1 改为 2 再试一下看看是否相同 if (\"1\".equals(item)) { list.remove(item); } } 第十一条：【推荐】 高度注意 Map 类集合 K/V 能不能存储 null 值得情况 1.6 并发处理第三条：【强制】 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明： 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源，解决资源不足的问题。如果不适用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过渡切换” 的问题。 1.7 控制语句第二条：【强制】 在 if / else / for / while / do 语句中，必须使用大括号。即使只有一行代码，也应该避免采用单行的编码方式：if (condition) statements;第三条：【强制】 在高并发场景中，避免使用 “等于” 判断作为终端或退出的条件 说明： 如果并发控制没有处理好，容易产生等值判断被 “击穿” 的情况，应使用大于或小于的区间判断条件来代替。 反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。 第四条：【推荐】 在表达异常的分支时，尽量少用 if-else 方式 说明： 如果不得不使用 if()…else if()…else… 方式表达逻辑，【强制】 避免后续代码维护困难，请勿超过 3 层。 // 正例：超过 3 层的 if-else 逻辑判断代码可以使用卫语句、策略模式 // 状态模式等来实现，其中卫语句实例如下： public void today() { if (isBusy()) { System.out.println(\"change time,\"); return; } if (isFree()) { System.out.println(\"go to travel.\"); return; } System.out.println(\"stay at home to learn Java\"); return; } 1.8 注释规约第一条：【强制】 类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /**内容*/ 格式，不得使用 //xxx 方式 第二条：【强制】 所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释，除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明： 对子类的实现要求，或者调用注意事项，请一并说明。 第三条：【强制】 所有的类都必须添加创建者和创建日期。 1.9 其他第三条：【强制】 后台输送给网页的变量必须加$!{var}——中间是感叹号 说明： 如果 var=null 或者不存在，那么 ${var} 会直接显示在页面上。 第四条：【强制】 注意 Math.random() 这个方法返回的是 double 类型，取值的范围 0≤x＜1（能够取到零值，注意除零异常），如果向获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。第六条：【推荐】 不要在视图模板中加入任何复杂的逻辑。 说明： 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的工作。 第4章：安全规约“安全生产，责任重于泰山。” 这句话同样适用于软件生产，本章主要说明编程中需要注意的比较基础的安全准则。 第一条：【强制】 隶属于用户个人的页面或者功能必须进行权限控制校验 说明： 放置皆有做水平权限校验就可以随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 第二条：【强制】 用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 说明： 个人手机号码会显示为 158****9119，隐藏中间 4 位，防止个人隐私泄露。 第三条：【强制】 用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 第四条：【强制】 用户请求传入的任何参数必须做有效性验证 说明： 忽略参数校验可能导致如下情况。1）page size 过大导致内存溢出2）恶意 order by 导致数据库慢查询3）任意重定向4）SQL 注入5）反序列化注入6）正则输入源串拒绝服务 ReDoSJava 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，则有可能导致死循环。 第五条：【强制】 禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。第六条：【强制】 表单、AJAX 提交必须执行 CSRF 安全过滤 第七条：【强制】 在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 第5章：MySQL 数据库5.1 建表规约第二条：【强制】 表名、字段名必须使用小写字母或数字 ， 禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明： MySQL 在 Windows 下不区分大小写，但在 Linux 下默认区分大小写。因此，数据库名、表明、字段名都不允许出现任何大写字母，避免节外生枝。 正例： getter _ admin ， task _ config ， level 3_ name反例： GetterAdmin ， taskConfig ， level 3 name 第四条：【强制】禁用保留字，如 desc 、 range 、 match 、 delayed 等，请参考 MySQL 官方保留字。第五条： 【强制】主键索引名为 pk_ 字段名；唯一索引名为 uk _字段名 ； 普通索引名则为 idx _字段名。 说明： pk_ 即 primary key；uk _ 即 unique key；idx _ 即 index 的简称。 第六条：【强制】小数类型为 decimal ，禁止使用 float 和 double 。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 第八条：【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text ，独立出来一张表，用主键来对应，避免影响其它字段索引效率。第九条：【强制】表必备三字段： id , gmt _ create , gmt _ modified 说明：其中 id 必为主键，类型为 unsigned bigint 、单表时自增、步长为 1。 gmt _ create ,gmt _ modified 的类型均为 date _ time 类型。 第十条： 【推荐】表的命名最好是加上“业务名称_表的作用”。 正例： tiger _ task / tiger _ reader / mpp _ config 第十五条：【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 对象 年龄区间 类型 表示范围 人 150 岁之内 unsigned tinyint 无符号值：0 到 255 龟 数百岁 unsigned smallint 无符号值：0 到 65535 恐龙化石 数千万年 unsigned int 无符号值：0 到约 42.9 亿 太阳 约 50 亿年 unsigned bigint 无符号值：0 到约 10 的 19 次方 5.2 索引规约第五条： 【推荐】如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file _ sort 的情况，影响查询性能。 正例： where a =? and b =? order by c; 索引： a _ b _ c反例：索引中有范围查找，那么索引有序性无法利用，如： WHERE a &gt;10 ORDER BY b; 索引 a _ b 无法排序。 第九条： 【推荐】建组合索引的时候，区分度最高的在最左边。正例：如果 where a =? and b =? ， a 列的几乎接近于唯一值，那么只需要单建 idx _ a 索引即可。 说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如： where a &gt;? and b = ? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 5.3 SQL 语句第一条：【强制】不要使用 count( 列名 ) 或 count( 常量 ) 来替代 count( * ) ， count( * ) 是 SQL 92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明： count( * ) 会统计值为 NULL 的行，而 count( 列名 ) 不会统计此列为 NULL 值的行。 第六条： 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明： （ 概念解释 ） 学生表中的 student _ id 是主键，那么成绩表中的 student _ id 则为外键。如果更新学生表中的 student _ id ，同时触发成绩表中的 student _ id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群 ； 级联更新是强阻塞，存在数据库更新风暴的风险 ； 外键影响数据库的插入速度。 第八条： 【强制】数据订正时，删除和修改记录时，要先 select ，避免出现误删除，确认无误才能执行更新语句。 5.4 ORM 映射 整个规约对自己来说都挺有用的，因为正好涉及到这方面，幸好感觉脸不怎么疼。 第一条：【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明： 1 ） 增加查询分析器解析成本。2 ） 增减字段容易与 resultMap 配置不一致。 第二条：【强制】 POJO 类的 布尔 属性不能加 is ，而数据库字段必须加 is _，要求在 resultMap 中进行字段与属性之间的映射。 说明： 参见定义 POJO 类以及数据库字段定义规定，在 中 增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。 第三条：【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义 ； 反过来，每一个表也必然有一个与之对应。 说明： 配置映射关系，使字段与 DO 类解耦，方便维护。 第七条：【强制】更新数据表记录时，必须同时更新记录对应的 gmt _ modified 字段值为当前时间。第九条：【参考】@ Transactional 事务不要滥用。事务会影响数据库的 QPS ，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 总结浏览了一遍，还是学习到了很多东西吧，上面也仅仅只是总结了对我自己比较收益，现阶段我能吸收能实际感受得到的规约，如果想要 PDF 版的可以在这里下载：戳这里 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"MyBatis(2)——深入学习","slug":"MyBatis-2-——深入学习","date":"2018-04-16T00:34:00.000Z","updated":"2020-12-09T05:08:30.319Z","comments":true,"path":"2018/04/16/mybatis-2-shen-ru-xue-xi/","link":"","permalink":"http://www.wmyskxz.com/2018/04/16/mybatis-2-shen-ru-xue-xi/","excerpt":"","text":"编写日志输出环境配置文件在开发过程中，最重要的就是在控制台查看程序输出的日志信息，在这里我们选择使用 log4j 工具来输出： 准备工作： 将【MyBatis】文件夹下【lib】中的 log4j 开头的 jar 包都导入工程并添加依赖。在【src】下新建一个文件 log4j.properties 资源: # Global logging configuration # 在开发环境下日志级别要设置成 DEBUG ，生产环境设为 INFO 或 ERROR log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n其中，第一条配置语句 “log4j.rootLogger=DEBUG, stdout” 指的是日志输出级别，一共有 7 个级别（OFF、 FATAL、 ERROR、 WARN、 INFO、 DEBUG、 ALL）。 一般常用的日志输出级别分别为 DEBUG、 INFO、 ERROR 以及 WARN，分别表示 “调试级别”、 “标准信息级别”、 “错误级别”、 “异常级别”。如果需要查看程序运行的详细步骤信息，一般选择 “DEBUG” 级别，因为该级别在程序运行期间，会在控制台才打印出底层的运行信息，以及在程序中使用 Log 对象打印出调试信息。 如果是日常的运行，选择 “INFO” 级别，该级别会在控制台打印出程序运行的主要步骤信息。“ERROR” 和 “WARN” 级别分别代表 “不影响程序运行的错误事件” 和 “潜在的错误情形”。 文件中 “stdout” 这段配置的意思就是将 DEBUG 的日志信息输出到 stdout 参数所指定的输出载体中。 第二条配置语句 “log4j.appender.stdout=org.apache.log4j.ConsoleAppender” 的含义是，设置名为 stdout 的输出端载体是哪种类型。 目前输出载体有ConsoleAppender（控制台）FileAppender（文件）DailyRollingFileAppender（每天产生一个日志文件）RollingFileAppender（文件大小到达指定大小时产生一个新的文件）WriterAppender（将日志信息以流格式发送到任意指定的地方） 这里要将日志打印到 IDEA 的控制台，所以选择 ConsoleAppender 第三条配置语句 “log4j.appender.stdout.layout=org.apache.log4j.PatternLayout” 的含义是，名为 stdout 的输出载体的 layout（即界面布局）是哪种类型。 目前输出端的界面类型分为HTMLLayout（以 HTML 表格形式布局）PatternLayout（可以灵活地指定布局模式）SimpleLayout（包含日志信息的级别和信息字符串）TTCCLayout（包含日志产生的时间、线程、类别等信息） 这里选择灵活指定其布局类型，即自己去配置布局。 第四条配置语句 “log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n” 的含义是，如果 layout 界面布局选择了 PatternLayout 灵活布局类型，要指定的打印信息的具体格式。 格式信息配置元素大致如下：%m 输出代码中的指定的信息%p 输出优先级，即 DEBUG、 INFO、 WARN、 ERROR 和 FATAL%r 输出自应用启动到输出该 log 信息耗费的毫秒数%c 输出所属的类目，通常就是所在类的全名%t 输出产生该日志事件的线程名%n 输出一个回车换行符，Windows 平台为 “rn”，UNIX 平台为 “n”%d 输出日志时的时间或日期，默认个事为 ISO8601，也可以在其后指定格式，比如 %d{yyy MMM dd HH:mm:ss}，输出类似：2018 年 4 月18 日 10:32:00%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数 MyBatis 高级映射在上一篇文章中，我们讲解了一个 MyBatis 的入门程序的开发，了解了 MyBatis 开发的基本内容。今天我们先来了解一下 MyBatis 是如何处理多张数据库表之间的关联关系，其中包括： 一对一的查询 一对多查询 多对多查询 延迟加载 一对一查询 首先我们先来建立一个数据模型（删掉之前创建的 student 表）： use mybatis; CREATE TABLE student ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(255) DEFAULT NULL, card_id int(11) NOT NULL, PRIMARY KEY (id) )AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE TABLE card ( id int(11) NOT NULL AUTO_INCREMENT, number int(11) NOT NULL, PRIMARY KEY (id) )AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; INSERT INTO student VALUES (1,&#39;student1&#39;,1); INSERT INTO student VALUES (2,&#39;student2&#39;,2); INSERT INTO card VALUES (1,1111); INSERT INTO card VALUES (2,2222); 注意： 这里并没有在数据库中设置外键，而是让 MyBatis 去处理多表之间的关系。事实上，外键只是用来保证数据一致性，在某些特殊的情况下（例如高并发秒杀系统中），会专门设置不适用外键，因为存在一定的性能损耗。 然后我们要来确认我们查询的 SQL 语句，我们或许可以简单的写成下面这样： SELECT student.*, card.* FROM student,card WHERE student.card_id = card.id AND card.number = #{value} 提示： 在日常开发中，总是先确定业务的具体 SQL ，再将此 SQL 配置在 Mapper 文件中 确定了主要的查询 SQL 后，接下来我们分别使用 resultType 和 resultMap 来实现这个一对一查询的实例。 1. 使用 resultType 实现首先创建学生 student 表所对应的 Java 实体类 Student，其中封装的属性信息为响应数据库中的字段： package pojo; public class Student { int id; String name; int card_id; /* getter and setter */ } 最终我们执行查询（上述的 SQL 语句）的结果如下： 由于最终的查询的结果是由 resultType 指定的，也就是只能映射一个确定的 Java 包装类，上面的 Stuent 类只包含了学生的基本信息，并没有包含 Card 的信息，所以我们要创建一个最终映射类，以 Student 类为父类，然后追加 Card 的信息： package pojo; public class StudentAndCard extends Student { private int number; /* getter and setter /* } 然后在 Student.xml 映射文件中定义 &lt;select&gt; 类型的查询语句 SQL 配置，将之前设计好的 SQL 语句配置进去，然后指定输出参数属性为 resultType，类型为 StudentAndCard 这个 Java 包装类： &lt;select id=&quot;findStudentByCard&quot; parameterType=&quot;_int&quot; resultType=&quot;Student&quot;&gt; SELECT student.*, card.* FROM student,card WHERE student.card_id = card.id AND card.number = #{value} &lt;/select&gt;然后在测试类中编写测试方法： @Test public void test() throws IOException { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 找到身份证身份证号码为 1111 的学生 StudentAndCard student = session.selectOne(\"findStudentByCard\",1111); // 获得其姓名并输出 System.out.println(student.getName()); } 获得正确结果： 2. 使用 resultMap 实现使用 resultMap 可以将数据字段映射到名称不一样的响应实体类属性上，重要的是，可以映射实体类中包裹的其他实体类。 首先我们来创建一个封装了 Card 号码和 Student 实体类的 StudentWithCard 类： package pojo; public class StudentWithCard { Student student; int number; int id; /* getter and setter */ } SQL 语句依然没有变化，但是使用的输出映射属性改为了 resultMap ，其中的映射类型是 id 为 StudentInfoMap 的 resultMap 配置： &lt;select id=&quot;findStudentByCard&quot; parameterType=&quot;_int&quot; resultMap=&quot;StudentInfoMap&quot;&gt; SELECT student.*, card.* FROM student,card WHERE student.card_id = card.id AND card.number = #{value} &lt;/select&gt; &lt;resultMap id=&quot;StudentInfoMap&quot; type=&quot;pojo.StudentWithCard&quot;&gt; &lt;!-- id 标签表示对应的主键 column 对应查询结果的列值 property 对应封装类中的属性名称 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt; &lt;!-- association 表示关联的嵌套结果， 可以简单理解就是为封装类指定的标签 --&gt; &lt;association property=&quot;student&quot; javaType=&quot;pojo.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;card_id&quot; property=&quot;card_id&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt;稍微修改一下测试类，测试使用 resultMap 实现的一对一查询映射： @Test public void test() throws IOException { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 找到身份证身份证号码为 1111 的学生 StudentWithCard student = session.selectOne(&quot;findStudentByCard&quot;, 1111); // 获得其姓名并输出 System.out.println(student.getStudent().getName()); }测试仍然能得到正确的结果： 一对多查询 还是先来建立数据模型，删掉之前的： use mybatis; CREATE TABLE student ( student_id int(11) NOT NULL AUTO_INCREMENT, name varchar(255) DEFAULT NULL, PRIMARY KEY (student_id) )AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE TABLE class ( class_id int(11) NOT NULL AUTO_INCREMENT, name varchar(255) NOT NULL, student_id int(11) NOT NULL, PRIMARY KEY (class_id) )AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; INSERT INTO student VALUES (1,&#39;student1&#39;); INSERT INTO student VALUES (2,&#39;student2&#39;); INSERT INTO class VALUES (1,&#39;Java课&#39;,1); INSERT INTO class VALUES (2,&#39;Java课&#39;,2); 其中 class 的 name 字段表示课程的名称。 然后我们来编写我们的 SQL 语句： SELECT student.* FROM student, class WHERE student.student_id = class.student_id AND class.class_id = #{value} 我们执行的结果如下： 我们再来创建对应的实体类： public class Student { private int id; private String name; /* getter and setter */ } public class Class { private int id; private String name; private List&lt;Student> students; /* getter and setter */ } 在 Package【pojo】下新建一个【class.xml】文件完成配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;class&quot;&gt; &lt;resultMap id=&quot;Students&quot; type=&quot;pojo.Student&quot;&gt; &lt;id column=&quot;student_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;listStudentByClassName&quot; parameterType=&quot;String&quot; resultMap=&quot;Students&quot;&gt; SELECT student.* FROM student, class WHERE student.student_id = class.student_id AND class.name= #{value} &lt;/select&gt; &lt;/mapper&gt;编写测试类： @Test public void test() throws IOException { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 查询上Java课的全部学生 List&lt;Student> students = session.selectList(\"listStudentByClassName\", \"Java课\"); for (Student student : students) { System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); } } 运行测试结果，成功： 多对多查询 建立数据模型： use mybatis; CREATE TABLE students ( student_id int(11) NOT NULL AUTO_INCREMENT, student_name varchar(255) DEFAULT NULL, PRIMARY KEY (student_id) )AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE TABLE courses ( course_id int(11) NOT NULL AUTO_INCREMENT, course_name varchar(255) NOT NULL, PRIMARY KEY (course_id) )AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE TABLE student_select_course( s_id int(11) NOT NULL, c_id int(11) NOT NULL, PRIMARY KEY(s_id,c_id) ) DEFAULT CHARSET=utf8; INSERT INTO students VALUES (1,&#39;student1&#39;); INSERT INTO students VALUES (2,&#39;student2&#39;); INSERT INTO courses VALUES (1,&#39;Java课&#39;); INSERT INTO courses VALUES (2,&#39;Java Web课&#39;); INSERT INTO student_select_course VALUES(1,1); INSERT INTO student_select_course VALUES(1,2); INSERT INTO student_select_course VALUES(2,1); INSERT INTO student_select_course VALUES(2,2);根据要求我们来设计一下 SQL 语言： SELECT s.student_id,s.student_name FROM students s,student_select_course ssc,courses c WHERE s.student_id = ssc.s_id AND ssc.c_id = c.course_id AND c.course_name = #{value} 执行 SQL 结果如下： 实体类雷同，就不再赘述，我们直接来配置映射文件【Student.xml】： &lt;resultMap id=&quot;Students&quot; type=&quot;pojo.Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;student_id&quot;/&gt; &lt;result column=&quot;student_name&quot; property=&quot;name&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findStudentsByCourseName&quot; parameterType=&quot;String&quot; resultMap=&quot;Students&quot;&gt; SELECT s.student_id,s.student_name FROM students s,student_select_course ssc,courses c WHERE s.student_id = ssc.s_id AND ssc.c_id = c.course_id AND c.course_name = #{value} &lt;/select&gt;测试类也雷同，只需要修改一下调用的 id （改为findStudentsByCourseName）就好了，直接上测试结果： 相反也是一样的，重要的是 SQL 语句和映射。 总结： 自己写的 SQL 语句看着虽然没有很恶心（至少思路清晰），但感觉很烂！ 结合 SQL 语言和映射文件，能够很方便的操作数据库 数据库还是建立外键得好….（啪啪打脸，根据《阿里Java开发手册》里提到，最好不要建外键，而让程序的Service层去做判断） 延迟加载什么是延迟加载？从字面上理解，就是对某一类信息的加载之前需要延迟一会儿。在 MyBatis 中，通常会进行多表联合查询，但是有的时候不会立即用到所有的联合查询结果，这时候就可以采用延迟加载的功能。 功能： 延迟加载可以做到，先从单表查询，需要时再从关联表关联查询，这样就大大提高了数据库的性能，因为查询单表要比关联查询多张表速度快。 实例： 如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。 关联查询： SELECT orders.*, user.username FROM orders, user WHERE orders.user_id = user.id 延迟加载相当于： SELECT orders.*, (SELECT username FROM USER WHERE orders.user_id = user.id) username FROM orders所以这就比较直观了，也就是说，我把关联查询分两次来做，而不是一次性查出所有的。第一步只查询单表orders，必然会查出orders中的一个user_id字段，然后我再根据这个user_id查user表，也是单表查询。 参考文章： 【MyBatis学习11】MyBatis中的延迟加载 Mapper 映射配置编写首先在 Mapper 映射文件中定义只查询所有订单信息的 SQL : &lt;select id=&quot;findOrdersUserLazyLoading&quot; resultMap=&quot;OrdersUserLazyLoadingResultMap&quot;&gt; SELECT * FROM orders &lt;/select&gt;上面的 SQL 语句查询所有的订单信息，而每个订单信息中会关联查询用户，但由于希望延迟加载用户信息，所以会在 id 为 “OrdersUserLazyLoadingResultMap“ 的 resultMap 对应的结果集配置中进行配置： 最后配置延迟加载要执行的获取用户信息的 SQL： &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #{id} &lt;/select&gt;上面的配置会被用来延迟加载的 resultMap 中的 association 调用，输入参数就是 association 中 column 中定义的字段信息。 在编写测试方法之前，首先需要开启延迟加载功能（这在 MyBatis 中默认是禁用掉的）。这需要在 MyBatis 的全局配置文件 mybatis-config.xml 中配置 setting 属性，将延迟加载（lazyLoadingEnable）的开关设置成 “ture” ，并且由于是按需加载，所以还需要将积极加载改为消极加载： &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; 注意： 在 configuration 中配置是有一定顺序的，具体可以按住【Ctrl】不放点击 configuration 属性，能看到如下信息（即定义的顺序）： &lt;!ELEMENT configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&gt; Mapper 动态代理什么是 Mapper 动态代理？一般创建 Web 工程时，从数据库取数据的逻辑会放置在 DAO 层（Date Access Object，数据访问对象）。使用 MyBatis 开发 Web 工程时，通过 Mapper 动态代理机制，可以只编写数据交互的接口及方法定义，和对应的 Mapper 映射文件，具体的交互方法实现由 MyBatis 来完成。这样大大节省了开发 DAO 层的时间。 实现 Mapper 代理的方法并不难，只需要遵循一定的开发规范即可。 Mapper 代理实例编写我们编写一个使用 Mapper 代理查询学生信息的示例，首先还是在【pojo】下新建一个名为 StudentMapper.xml 的 Mapper 配置文件，其中包含了对 Student 的增删改查的 SQL 配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;mapper.StudentMapper&quot;&gt; &lt;!-- 查询学生 --&gt; &lt;select id=&quot;findStudentById&quot; parameterType=&quot;_int&quot; resultType=&quot;pojo.Student&quot;&gt; SELECT * FROM student WHERE student_id = #{id} &lt;/select&gt; &lt;!-- 增加用户 --&gt; &lt;insert id=&quot;insertStudent&quot; parameterType=&quot;pojo.Student&quot;&gt; INSERT INTO student(student_id, name) VALUES(#{id}, #{name}) &lt;/insert&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;_int&quot;&gt; DELETE FROM student WHERE student_id = #{id} &lt;/delete&gt; &lt;!-- 修改用户 --&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;pojo.Student&quot;&gt; UPDATE student SET name = #{name} WHERE student_id = #{id} &lt;/update&gt; &lt;/mapper&gt;如果需要使用 StudentMapper.xml 的 Mapper 代理，首先需要定义一个接口，名为 StudentMapper。然后在里面新建四个方法定义，分别对应 StudentMapper.xml 中的 Student 的增删改查的 SQL 配置，然后将 StudentMapper 中的 namespace 改为 StudentMapper 接口定义的地方（也就是 mapper 包下的 StudentMapper），这样就可以在业务类中使用 Mapper 代理了，接口代码如下： package mapper; import pojo.Student; public interface StudentMapper { // 根据 id 查询学生信息 public Student findStudentById(int id) throws Exception; // 添加学生信息 public void insertStudent(Student student) throws Exception; // 删除学生信息 public void deleteStudent(int id) throws Exception; // 修改学生信息 public void updateStudent(Student student) throws Exception; } 注意： 别忘了在 mybatis-config.xml 中配置一下 Mapper 映射文件 测试动态代理在测试方法中，使用 SqlSession 类的 getMapper 方法，并将要加载的 Mapper 代理的接口类传递进去，就可以获得相关的 Mapper 代理对象，使用 Mapper 代理对象去对学生信息进行增删改查： @Test public void test() throws Exception { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 获取 Mapper 代理 StudentMapper studentMapper = session.getMapper(StudentMapper.class); // 执行 Mapper 代理独享的查询方法 Student student = studentMapper.findStudentById(1); System.out.println(&quot;学生的姓名为：&quot; + student.getName()); session.close(); }运行测试方法，看到正确的结果： 使用 Mapper 代理可以让开发更加简洁，使查询结构更加清晰，工程结构更加规范。 使用注解开发 MyBatis在上面的例子中，我们已经有了方便的 Mapper 代理对象，我们可以进一步省掉 XML 的配置信息，进而使用方便的注解来开发 MyBatis ，让我们实际来操练一下： 第一步：为 Mapper 增加注解我们把 StudentMapper.xml 下配置的 SQL 语句通过注解的方式原封不动的配置在 StudentMapper 接口中： public interface StudentMapper { // 根据 id 查询学生信息 @Select(&quot;SELECT * FROM student WHERE student_id = #{id}&quot;) public Student findStudentById(int id) throws Exception; // 添加学生信息 @Insert(&quot;INSERT INTO student(student_id, name) VALUES(#{id}, #{name})&quot;) public void insertStudent(Student student) throws Exception; // 删除学生信息 @Delete(&quot;DELETE FROM student WHERE student_id = #{id}&quot;) public void deleteStudent(int id) throws Exception; // 修改学生信息 @Update(&quot;UPDATE student SET name = #{name} WHERE student_id = #{id}&quot;) public void updateStudent(Student student) throws Exception; }第二步：修改 mybatis-config.xml将之前配置的映射注释掉，新建一条： &lt;!-- 映射文件 --&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource=&quot;pojo/StudentMapper.xml&quot;/&gt;--&gt; &lt;mapper class=&quot;mapper.StudentMapper&quot;/&gt; &lt;/mappers&gt; 注意： 这次映射的并不是文件（使用 resource 属性），而是类（使用 class 属性） 第三步：运行测试代码上面的测试代码不用修改，直接运行，也能得到正确结果： 更多的注解：戳这里 MyBatis 缓存结构 在 Web 系统中，最重要的操作就是查询数据库中的数据。但是有些时候查询数据的频率非常高，这是很耗费数据库资源的，往往会导致数据库查询效率极低，影响客户的操作体验。于是我们可以将一些变动不大且访问频率高的数据，放置在一个缓存容器中，用户下一次查询时就从缓存容器中获取结果。 MyBatis 拥有自己的缓存结构，可以用来缓解数据库压力，加快查询速度。 mybatis一级缓存是一个SqlSession级别，sqlsession只能访问自己的一级缓存的数据 二级缓存是跨sqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的sqlsession是可以共享的。 一级查询缓存一级查询存在于每一个 SqlSession 类的实例对象中，当第一次查询某一个数据时，SqlSession 类的实例对象会将该数据存入一级缓存区域，在没有收到改变该数据的请求之前，用户再次查询该数据，都会从缓存中获取该数据，而不是再次连接数据库进行查询。 MyBatis 的一级缓存原理： 第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map key：hashcode+sql+sql输入参数+输出参数（sql的唯一标识） value：用户信息 同一个 sqlsession 再次发出相同的 sql，就从缓存中取不走数据库。如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。 一级缓存示例 我们在同一个 session 中查询两次 id = 1 的 Category 对象试一试： public static void main(String[] args) throws IOException { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session1 = sqlSessionFactory.openSession(); Category c1 = session1.selectOne(&quot;getCategory&quot;, 1); System.out.println(c1); Category c2 = session1.selectOne(&quot;getCategory&quot;, 1); System.out.println(c2); session1.commit(); session1.close(); }运行，可以看到第一次会去数据库中取数据，但是第二次就不会访问数据库了，而是直接从session中取出来： 我们再来测试一下在不同 session 里查询相同的 id 数据 public static void main(String[] args) throws IOException { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session1 = sqlSessionFactory.openSession(); Category c1 = session1.selectOne(&quot;getCategory&quot;, 1); System.out.println(c1); Category c2 = session1.selectOne(&quot;getCategory&quot;, 1); System.out.println(c2); session1.commit(); session1.close(); SqlSession session2 = sqlSessionFactory.openSession(); Category c3 = session2.selectOne(&quot;getCategory&quot;, 1); System.out.println(c3); session2.commit(); session2.close(); }这一次，另外打开一个 session , 取同样 id 的数据，就会发现需要执行 sql 语句，证实了一级缓存是在 session 里的： MyBatis 一级缓存值得注意的地方： MyBatis 默认就是支持一级缓存的，并不需要我们配置. MyBatis 和 spring 整合后进行 mapper 代理开发，不支持一级缓存，mybatis和 spring 整合，spring 按照 mapper 的模板去生成 mapper 代理对象，模板中在最后统一关闭 sqlsession。 二级查询缓存 问题： 有些时候，在 Web 工程中会将执行查询操作的方法封装在某个 Service 方法中，当查询完一次后，Service 方法结束，此时 SqlSession 类的实例对象就会关闭，一级缓存就会被清空。 二级缓存原理： 二级缓存的范围是 mapper 级别（mapper即同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是 map。 要开启二级缓存，需要进行两步操作。 第一步：在 MyBatis 的全局配置文件 mybatis-config.xml 中配置 setting 属性，设置名为 “cacheEnable” 的属性值为 “true” 即可： &lt;settings&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 注意： settings 配置的位置一定是在 properties 后面，typeAliases前面！ 第二步：然后由于二级缓存是 Mapper 级别的，还要在需要开启二级缓存的具体 mapper.xml 文件中开启二级缓存，只需要在相应的 mapper.xml 中添加一个 cache 标签即可： &lt;!-- 开启本 Mapper 的 namespace 下的二级缓存 --&gt; &lt;cache /&gt;开启二级缓存之后，我们需要为查询结果映射的 POJO 类实现 java.io.serializable 接口，二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。 二级缓存示例我们在同一个 SessionFactory 下查询 id = 1 的数据，只有第一次需要执行 SQL 语句，从后都是从缓存中取出来的： 参考资料：how2j.cn-MyBatis教程、Java3y-Mybatis【缓存、代理、逆向工程】 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Spring MVC + MyBatis开发从入门到项目实战》 How2j-MyBatis 系列教程 全能的百度和万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"MyBatis","slug":"后端/Java/MyBatis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/MyBatis/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"MyBatis(1)——快速入门","slug":"MyBatis-1-——快速入门","date":"2018-04-15T00:31:00.000Z","updated":"2020-12-09T05:08:27.200Z","comments":true,"path":"2018/04/15/mybatis-1-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2018/04/15/mybatis-1-kuai-su-ru-men/","excerpt":"","text":"MyBatis 简介MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 缺点：慢（相对于内存而言） 为什么使用 MyBatis在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 搭建 MyBatis 环境首先，我们需要先下载和搭建 MyBatis 的开发环境。 下载 MyBatis 工程包打开链接 http://github.com/mybatis/mybatis-3/releases 下载 MyBatis 所需要的包和源码，当前最新版本为 3.4.6，官方还提供了文档： 戳这里，虽然感觉写得一般，但还是有一些参考价值…唉，别当教程看，当字典看！ 下载好 MyBatis 的包解压后，可以得到以下的文件目录： 其中 mybatis-3.4.6.jar 包就是 MyBatis 的项目工程包，【lib】文件夹下就是 MyBatis 项目需要依赖的第三方包，pdf 文件是它英文版的说明，不要英文也可以戳上面的链接。 为 IDEA 配置 MyBatis 环境IDEA 默认是不支持 MyBatis 开发的，需要自己下载第三方插件来支持，可惜的是功能强大的【MyBatis Plugin】是收费的，需要我们自己破解！ 第一步：在 IDEA 中下载 MyBatis Plugin在【File】菜单下找到【Settings】，然后再【Plugins】下点击【Browse repositories..】： 在搜索栏中输入【MyBatis Plugin】，然后点击【Install】（我这里是安装好了所以没有这个按钮）： 第二步：破解有幸找到最新的破解方法，最新支持破解的版本号为：v3.58 crack，下载链接：戳这里 把它下载到 【D:\\Download\\】目录下，打开 idea.vmoptions （【Help】-&gt; 【Eidt Custom VM Options…】）：在下方插入 -javaagent:D:/Download/ideaagent-1.2.jar 重启 IDEA，首次启动需要信任本地服务器 ssl 证书，点击接受后如未激活，再次重启即可： 至此，我们就为 IDEA 配置好了 MyBatis 的开发环境，可以检验一下是否安装成功： 第一个 MyBatis 程序我们来实际开发一个 MyBatis 程序，感受一下。 第一步：准备数据库首先我们创建一个数据库【mybatis】，编码方式设置为 UTF-8，然后再创建一个名为【student】的表，插入几行数据： DROP DATABASE IF EXISTS mybatis; CREATE DATABASE mybatis DEFAULT CHARACTER SET utf8; use mybatis; CREATE TABLE student( id int(11) NOT NULL AUTO_INCREMENT, studentID int(11) NOT NULL UNIQUE, name varchar(255) NOT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO student VALUES(1,1,&#39;我没有三颗心脏&#39;); INSERT INTO student VALUES(2,2,&#39;我没有三颗心脏&#39;); INSERT INTO student VALUES(3,3,&#39;我没有三颗心脏&#39;);第二步：创建工程在 IDEA 中新建一个 Java 工程，并命名为【HelloMybatis】，然后导入必要的 jar 包： mybatis-3.4.6.jar mysql-connector-java-5.1.21-bin.jar 第三步：创建实体类在 Package【pojo】下新建实体类【Student】，用于映射表 student： package pojo; public class Student { int id; int studentID; String name; /* getter and setter */ } 第四步：配置文件 mybatis-config.xml在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等，我们在后面说明： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 数据库环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;pojo/Student.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt;第五步：配置文件 Student.xml在 Package【pojo】下新建一个【Student.xml】文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;pojo&quot;&gt; &lt;select id=&quot;listStudent&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;/select&gt; &lt;/mapper&gt; 由于上面配置了 &lt;typeAliases&gt; 别名，所以在这里的 resultType 可以直接写 Student，而不用写类的全限定名 pojo.Student namespace 属性其实就是对 SQL 进行分类管理，实现不同业务的 SQL 隔离 SQL 语句的增删改查对应的标签有： 第六步：编写测试类在 Package【test】小创建测试类【TestMyBatis】： package test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import pojo.Student; import java.io.IOException; import java.io.InputStream; import java.util.List; public class TestMyBatis { public static void main(String[] args) throws IOException { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent List&lt;Student> listStudent = session.selectList(\"listStudent\"); for (Student student : listStudent) { System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); } } } 运行测试类： 基本原理 应用程序找 MyBatis 要数据 MyBatis 从数据库中找来数据 1.通过 mybatis-config.xml 定位哪个数据库2.通过 Student.xml 执行对应的 sql 语句3.基于 Student.xml 把返回的数据库封装在 Student 对象中4.把多个 Student 对象装载一个 Student 集合中 返回一个 Student 集合 参考资料：How2j.cn-MyBatis 相关教程 CRUD 操作我们来看看常规的一套增删改查应该怎么实现： 第一步：配置 Student.xml首先，我们在 SQL 映射文件中新增语句，用来支撑 CRUD 的系列操作 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;pojo&quot;&gt; &lt;select id=&quot;listStudent&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;/select&gt; &lt;insert id=&quot;addStudent&quot; parameterType=&quot;Student&quot;&gt; insert into student (id, studentID, name) values (#{id},#{studentID},#{name}) &lt;/insert&gt; &lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;Student&quot;&gt; delete from student where id = #{id} &lt;/delete&gt; &lt;select id=&quot;getStudent&quot; parameterType=&quot;_int&quot; resultType=&quot;Student&quot;&gt; select * from student where id= #{id} &lt;/select&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;Student&quot;&gt; update student set name=#{name} where id=#{id} &lt;/update&gt; &lt;/mapper&gt; parameterType：要求输入参数的类型 resultType：输出的类型 第二步：实现增删改查package test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import pojo.Student; import java.io.IOException; import java.io.InputStream; import java.util.List; public class TestMyBatis { public static void main(String[] args) throws IOException { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 增加学生 Student student1 = new Student(); student1.setId(4); student1.setStudentID(4); student1.setName(\"新增加的学生\"); session.insert(\"addStudent\", student1); // 删除学生 Student student2 = new Student(); student2.setId(1); session.delete(\"deleteStudent\", student2); // 获取学生 Student student3 = session.selectOne(\"getStudent\", 2); // 修改学生 student3.setName(\"修改的学生\"); session.update(\"updateStudent\", student3); // 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent List&lt;Student> listStudent = session.selectList(\"listStudent\"); for (Student student : listStudent) { System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); } // 提交修改 session.commit(); // 关闭 session session.close(); } } 上述的程序中： 通过 session.insert(&quot;addStudent&quot;, student1); 增加了一个 ID 和 studentID 都为 4，名字为“新增加的学生” 的学生 通过 session.delete(&quot;deleteStudent&quot;, student2); 删除了 ID = 1 的学生 通过 Student student3 = session.selectOne(&quot;getStudent&quot;, 2); 获取了 ID = 2的学生 通过 session.update(&quot;updateStudent&quot;, student3); 将 ID = 2 的学生的名字修改为 “修改的学生” 通过 session.commit() 来提交事务，也可以简单理解为更新到数据库 运行获得正确结果： 模糊查询如果要对数据库中的 student 表进行模糊查询，需要通过匹配名字中的某个字来查询该用户。 我们首先在 Student.xml 配置文件中配置 SQL 映射： &lt;select id=&quot;findStudentByName&quot; parameterMap=&quot;java.lang.String&quot; resultType=&quot;Student&quot;&gt; SELECT * FROM student WHERE name LIKE &#39;%${value}%&#39; &lt;/select&gt; 注意： &lt;select&gt; 标签对中 SQL 语句的 “${}” 符号，表示拼接 SQL 串，将接受的参数内容不加任何修饰地拼接在 SQL 中，在 “${}” 中只能使用 value 来代表其中的参数。 因为是模糊查询，所以得到的查询结果可能不止一个，所以我们使用 SqlSession 的 selectList() 方法，写一个测试方法： @Test public void test() throws IOException { // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 模糊查询 List&lt;Student> students = session.selectList(\"findStudentByName\", \"三颗心脏\"); for (Student student : students) { System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); } } 测试结果： 总结一下 关于 parameterType： 就是用来在 SQL 映射文件中指定输入参数类型的，可以指定为基本数据类型（如 int、float 等）、包装数据类型（如 String、Interger 等）以及用户自己编写的 JavaBean 封装类 关于 resultType： 在加载 SQL 配置，并绑定指定输入参数和运行 SQL 之后，会得到数据库返回的响应结果，此时使用 resultType 就是用来指定数据库返回的信息对应的 Java 的数据类型。 关于 “#{}” ： 在传统的 JDBC 的编程中，占位符用 “?” 来表示，然后再加载 SQL 之前按照 “?” 的位置设置参数。而 “#{}” 在 MyBatis 中也代表一种占位符，该符号接受输入参数，在大括号中编写参数名称来接受对应参数。当 “#{}” 接受简单类型时可以用 value 或者其他任意名称来获取。 关于 “${}” ： 在 SQL 配置中，有时候需要拼接 SQL 语句（例如模糊查询时），用 “#{}” 是无法达到目的的。在 MyBatis 中，“${}” 代表一个 “拼接符号” ，可以在原有 SQL 语句上拼接新的符合 SQL 语法的语句。使用 “${}” 拼接符号拼接 SQL ，会引起 SQL 注入，所以一般不建议使用 “${}”。 MyBatis 使用场景： 通过上面的入门程序，不难看出在进行 MyBatis 开发时，我们的大部分精力都放在了 SQL 映射文件上。 MyBatis 的特点就是以 SQL 语句为核心的不完全的 ORM（关系型映射）框架。与 Hibernate 相比，Hibernate 的学习成本比较高，而 SQL 语句并不需要开发人员完成，只需要调用相关 API 即可。这对于开发效率是一个优势，但是缺点是没办法对 SQL 语句进行优化和修改。而 MyBatis 虽然需要开发人员自己配置 SQL 语句，MyBatis 来实现映射关系，但是这样的项目可以适应经常变化的项目需求。所以使用 MyBatis 的场景是：对 SQL 优化要求比较高，或是项目需求或业务经常变动。 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Spring MVC + MyBatis开发从入门到项目实战》 How2j-MyBatis 系列教程 全能的百度和万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"MyBatis","slug":"后端/Java/MyBatis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/MyBatis/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Spring MVC【入门】就这一篇！","slug":"Spring-MVC【入门】就这一篇！","date":"2018-04-14T00:29:00.000Z","updated":"2020-12-09T05:12:11.229Z","comments":true,"path":"2018/04/14/spring-mvc-ru-men-jiu-zhe-yi-pian/","link":"","permalink":"http://www.wmyskxz.com/2018/04/14/spring-mvc-ru-men-jiu-zhe-yi-pian/","excerpt":"","text":"MVC 设计概述在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1： 出现的弊端： JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 代码难以复用 正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。 M 代表 模型（Model）模型是什么呢？ 模型就是数据，就是 dao,bean V 代表 视图（View）视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller)控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 扩展阅读：Web开发模式 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点：结构松散，几乎可以在 Spring MVC 中使用各类视图松耦合，各个模块分离与 Spring 无缝集成 Hello Spring MVC让我们来写一下我们的第一个 Spring MVC 程序： 第一步：在 IDEA 中新建 Spring MVC 项目 并且取名为 【HelloSpringMVC】，点击【Finish】： IDEA 会自动帮我们下载好必要的 jar 包，并且为我们创建好一些默认的目录和文件，创建好以后项目结构如下： 第二步：修改 web.xml我们打开 web.xml ，按照下图完成修改： 把&lt;url-pattern&gt;元素的值改为 / ，表示要拦截所有的请求，并交由Spring MVC的后台控制器来处理，改完之后： &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;第三步：编辑 dispatcher-servlet.xml这个文件名的开头 dispatcher 与上面 web.xml 中的 &lt;servlet-name&gt; 元素配置的 dispatcher 对应，这是 Spring MVC 的映射配置文件（xxx-servlet.xml），我们编辑如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt; &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt; &lt;/beans&gt;第四步：编写 HelloController在 Package【controller】下创建 【HelloController】类，并实现 org.springframework.web.servlet.mvc.Controller 接口： package controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; public class HelloController implements Controller{ @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { return null; } } 出现了问题： javax.servlet 包找不到 解决： 将本地 Tomcat 服务器的目录下【lib】文件夹下的 servlet-api.jar 包拷贝到工程【lib】文件夹下，添加依赖 Spring MVC 通过 ModelAndView 对象把模型和视图结合在一起 ModelAndView mav = new ModelAndView(\"index.jsp\"); mav.addObject(\"message\", \"Hello Spring MVC\"); 这里表示视图的是index.jsp模型数据的是 message，内容是 “Hello Spring MVC” package controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; public class HelloController implements Controller { public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\"index.jsp\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav; } } 第五步：准备 index.jsp将 index.jsp 的内容修改为： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; &lt;h1&gt;${message}&lt;/h1&gt;内容很简单，用El表达式显示 message 的内容。 第六步：部署 Tomcat 及相关环境在【Run】菜单项下找到【Edit Configurations】 配置 Tomcat 环境： 选择好本地的 Tomcat 服务器，并改好名字： 在 Deployment 标签页下完成如下操作： 点击 OK 就好了，我们点击右上角的三角形将 Tomcat 服务器运行起来。 出现的问题： Tomcat 服务器无法正常启动 原因： Tomcat 服务器找不到相关的 jar 包 解决方法： 将【lib】文件夹整个剪贴到【WEB-INF】下，并重新建立依赖： 第七步：重启服务器重启服务器，输入地址：localhost/hello 参考资料：Spring MVC 教程(how2j.cn) 跟踪 Spring MVC 的请求每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程： 第一站：DispatcherServlet从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。 &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!-- 拦截所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。 第二站：处理器映射（HandlerMapping） 问题： 典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？ 所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理： &lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt; &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;第三站：控制器一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息： public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { // 处理逻辑 .... } 第四站：返回 DispatcherServlet当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP。 控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。 public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { // 处理逻辑 .... // 返回给 DispatcherServlet return mav; } 第五站：视图解析器这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。 DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP 上面的例子是直接绑定到了 index.jsp 视图 第六站：视图既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。 它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; &lt;h1&gt;${message}&lt;/h1&gt; 使用注解配置 Spring MVC上面我们已经对 Spring MVC 有了一定的了解，并且通过 XML 配置的方式创建了第一个 Spring MVC 程序，我们来看看基于注解应该怎么完成上述程序的配置： 第一步：为 HelloController 添加注解package controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller public class HelloController{ @RequestMapping(\"/hello\") public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\"index.jsp\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav; } } 把实现的接口也给去掉。 简单解释一下： @Controller 注解：很明显，这个注解是用来声明控制器的，但实际上这个注解对 Spring MVC 本身的影响并不大。（Spring 实战说它仅仅是辅助实现组件扫描，可以用 @Component 注解代替，但我自己尝试了一下并不行，因为上述例子没有配置 JSP 视图解析器我还自己配了一个仍没有成功…） @RequestMapping 注解：很显然，这就表示路径 /hello 会映射到该方法上 第二步：取消之前的 XML 注释在 dispatcher-servlet.xml 文件中，注释掉之前的配置，然后增加一句组件扫描： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--&lt;bean id=&quot;simpleUrlHandlerMapping&quot;--&gt; &lt;!--class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;--&gt; &lt;!--&lt;property name=&quot;mappings&quot;&gt;--&gt; &lt;!--&lt;props&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt;--&gt; &lt;!--&lt;/props&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;--&gt; &lt;!-- 扫描controller下的组件 --&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;/beans&gt;第三步：重启服务器当配置完成，重新启动服务器，输入 localhost/hello 地址仍然能看到效果： @RequestMapping 注解细节如果 @RequestMapping 作用在类上，那么就相当于是给该类所有配置的映射地址前加上了一个地址，例如： @Controller @RequestMapping(\"/wmyskxz\") public class HelloController { @RequestMapping(\"/hello\") public ModelAndView handleRequest(....) throws Exception { .... } } 则访问地址： localhost/wmyskxz/hello 配置视图解析器还记得我们 Spring MVC 的请求流程吗，视图解析器负责定位视图，它接受一个由 DispaterServlet 传递过来的逻辑视图名来匹配一个特定的视图。 需求： 有一些页面我们不希望用户用户直接访问到，例如有重要数据的页面，例如有模型数据支撑的页面。 造成的问题：我们可以在【web】根目录下放置一个【test.jsp】模拟一个重要数据的页面，我们什么都不用做，重新启动服务器，网页中输入 localhost/test.jsp 就能够直接访问到了，这会造成数据泄露…另外我们可以直接输入 localhost/index.jsp 试试，根据我们上面的程序，这会是一个空白的页面，因为并没有获取到 ${message} 参数就直接访问了，这会影响用户体验 解决方案我们将我们的 JSP 文件配置在【WEB-INF】文件夹中的【page】文件夹下，【WEB-INF】是 Java Web 中默认的安全目录，是不允许用户直接访问的（也就是你说你通过 localhost/WEB-INF/ 这样的方式是永远访问不到的） 但是我们需要将这告诉给视图解析器，我们在 dispatcher-servlet.xml 文件中做如下配置： &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;这里配置了一个 Spring MVC 内置的一个视图解析器，该解析器是遵循着一种约定：会在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径的。让我们实际来看看效果： 第一步：修改 HelloController我们将代码修改一下： 第二步：配置视图解析器：按照上述的配置，完成： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--&lt;bean id=&quot;simpleUrlHandlerMapping&quot;--&gt; &lt;!--class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;--&gt; &lt;!--&lt;property name=&quot;mappings&quot;&gt;--&gt; &lt;!--&lt;props&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt;--&gt; &lt;!--&lt;/props&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;--&gt; &lt;!-- 扫描controller下的组件 --&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt;第三步：剪贴 index.jsp 文件在【WEB-INF】文件夹下新建一个【page】文件夹，并将【index.jsp】文件剪贴到里面： 第四步：更新资源重启服务器访问 localhost/hello 路径，看到正确效果： 原理： 我们传入的逻辑视图名为 index ，再加上 “/WEB-INF/page/” 前缀和 “.jsp” 后缀，就能确定物理视图的路径了，这样我们以后就可以将所有的视图放入【page】文件夹下了！ 注意：此时的配置仅是 dispatcher-servlet.xml 下的 控制器接收请求数据使用控制器接收参数往往是 Spring MVC 开发业务逻辑的第一步，为探索 Spring MVC 的传参方式，为此我们先来创建一个简单的表单用于提交数据： &lt;!DOCTYPE html&gt; &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot; isELIgnored=&quot;false&quot;%&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Spring MVC 传参方式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/param&quot; role=&quot;form&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提 交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;丑就丑点儿吧，我们就是来测试一下： 使用 Servlet 原生 API 实现：我们很容易知道，表单会提交到 /param 这个目录，我们先来使用 Servlet 原生的 API 来看看能不能获取到数据： @RequestMapping(&quot;/param&quot;) public ModelAndView getParam(HttpServletRequest request, HttpServletResponse response) { String userName = request.getParameter(&quot;userName&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(userName); System.out.println(password); return null; }测试成功： 使用同名匹配规则我们可以把方法定义的形参名字设置成和前台传入参数名一样的方法，来获取到数据（同名匹配规则）： @RequestMapping(\"/param\") public ModelAndView getParam(String userName, String password) { System.out.println(userName); System.out.println(password); return null; } 测试成功： 问题： 这样又会和前台产生很强的耦合，这是我们不希望的 解决： 使用 @RequestParam(&quot;前台参数名&quot;) 来注入： @RequestParam 注解细节：该注解有三个变量：value、required、defaultvalue value ：指定 name 属性的名称是什么，value 属性都可以默认不写 required ：是否必须要有该参数，可以设置为【true】或者【false】 defaultvalue ：设置默认值 使用模型传参 要求： 前台参数名字必须和模型中的字段名一样 让我们先来为我们的表单创建一个 User 模型： package pojo; public class User { String userName; String password; /* getter and setter */ } 然后测试仍然成功： 中文乱码问题 注意： 跟 Servlet 中的一样，该方法只对 POST 方法有效（因为是直接处理的 request） 我们可以通过配置 Spring MVC 字符编码过滤器来完成，在 web.xml 中添加： &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;!-- 设置编码格式 --&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 控制器回显数据通过上面，我们知道了怎么接受请求数据，并能解决 POST 乱码的问题，那么我们怎么回显数据呢？为此我们在【page】下创建一个【test2.jsp】： &lt;!DOCTYPE html&gt; &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot; isELIgnored=&quot;false&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Spring MVC 数据回显&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;回显数据：${message}&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;使用 Servlet 原生 API 来实现我们先来测试一下 Servlet 原生的 API 是否能完成这个任务： @RequestMapping(\"/value\") public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) { request.setAttribute(\"message\",\"成功！\"); return new ModelAndView(\"test1\"); } 在浏览器地址栏中输入：localhost/value 测试 使用 Spring MVC 所提供的 ModelAndView 对象 使用 Model 对象在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据， 使用 @ModelAttribute 注解： @ModelAttribute public void model(Model model) { model.addAttribute(&quot;message&quot;, &quot;注解成功&quot;); } @RequestMapping(&quot;/value&quot;) public String handleRequest() { return &quot;test1&quot;; }这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 message 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。 客户端跳转前面不管是地址 /hello 跳转到 index.jsp 还是 /test 跳转到 test.jsp，这些都是服务端的跳转，也就是 request.getRequestDispatcher(&quot;地址&quot;).forward(request, response); 那我们如何进行客户端跳转呢？我们继续在 HelloController 中编写： @RequestMapping(\"/hello\") public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\"index\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav; } @RequestMapping(\"/jump\") public ModelAndView jump() { ModelAndView mav = new ModelAndView(\"redirect:/hello\"); return mav; } 我们使用 redirect:/hello 就表示我们要跳转到 /hello 这个路径，我们重启服务器，在地址栏中输入：localhost/jump ，会自动跳转到 /hello 路径下： 也可以这样用： @RequestMapping(\"/jump\") public String jump() { return \"redirect: ./hello\"; } 文件上传我们先来回顾一下传统的文件上传和下载：这里 我们再来看一下在 Spring MVC 中如何实现文件的上传和下载 注意： 需要先导入 commons-io-1.3.2.jar 和 commons-fileupload-1.2.1.jar 两个包 第一步：配置上传解析器在 dispatcher-servlet.xml 中新增一句： &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;/&gt;开启对上传功能的支持 第二步：编写 JSP文件名为 upload.jsp，仍创建在【page】下： &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;测试文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;picture&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上 传&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;第三步：编写控制器在 Package【controller】下新建【UploadController】类： package controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import org.springframework.web.servlet.ModelAndView; @Controller public class UploadController { @RequestMapping(\"/upload\") public void upload(@RequestParam(\"picture\") MultipartFile picture) throws Exception { System.out.println(picture.getOriginalFilename()); } @RequestMapping(\"/test2\") public ModelAndView upload() { return new ModelAndView(\"upload\"); } } 第四步：测试在浏览器地址栏中输入：localhost/test2 ，选择文件点击上传，测试成功： 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Spring 实战》 How2j Spring MVC 系列教程 全能的百度和万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"SpringMVC","slug":"后端/Java/SpringMVC","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringMVC/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"Spring学习(5)——Spring和数据库编程","slug":"Spring学习-5-——Spring和数据库编程","date":"2018-04-12T01:38:00.000Z","updated":"2020-12-09T05:12:47.402Z","comments":true,"path":"2018/04/12/spring-xue-xi-5-spring-he-shu-ju-ku-bian-cheng/","link":"","permalink":"http://www.wmyskxz.com/2018/04/12/spring-xue-xi-5-spring-he-shu-ju-ku-bian-cheng/","excerpt":"","text":"传统 JDBC 回顾JDBC 我们一定不陌生，刚开始学习的时候，我们写过很多很多重复的模板代码： public Student getOne(int id) { String sql = \"SELECT id,name FROM student WHERE id = ?\"; Student student = null; // 声明 JDBC 变量 Connection con = null; PreparedStatement ps = null; ResultSet rs = null; try { // 注册驱动程序 Class.forName(\"com.myql.jdbc.Driver\"); // 获取连接 con = DriverManager.getConnection(\"jdbc://mysql://localhost:\" + \"3306/student\", \"root\", \"root\"); // 预编译SQL ps = con.prepareStatement(sql); // 设置参数 ps.setInt(1, id); // 执行SQL rs = ps.executeQuery(); // 组装结果集返回 POJO if (rs.next()) { student = new Student(); student.setId(rs.getInt(1)); student.setName(rs.getString(1)); } } catch (ClassNotFoundException | SQLException e) { e.printStackTrace(); } finally { // 关闭数据库连接资源 try { if (rs != null &amp;&amp; !rs.isClosed()) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (ps != null &amp;&amp; !ps.isClosed()) { ps.close(); } } catch (SQLException e) { e.printStackTrace(); } try { if (con != null &amp;&amp; con.isClosed()) { con.close(); } } catch (SQLException e) { e.printStackTrace(); } } return student; } 现在光是看着就头大，并且我还把它完整的写了出来..真恶心！ 这还仅仅是一个 JDBC 的方法，并且最主要的代码只有ps = con.prepareStatement(sql);这么一句，而且有很多模板化的代码，包括建立连接以及关闭连接..我们必须想办法解决一下！ 优化传统的 JDBC第一步：创建 DBUtil 类我想第一步我们可以把重复的模板代码提出来创建一个【DBUtil】数据库工具类： package util; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class DBUtil { static String ip = \"127.0.0.1\"; static int port = 3306; static String database = \"student\"; static String encoding = \"UTF-8\"; static String loginName = \"root\"; static String password = \"root\"; static { try { Class.forName(\"com.mysql.jdbc.Driver\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static Connection getConnection() throws SQLException { String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); } } 这样我们就可以把上面的恶心的代码变成这样： public Student getOne(int id) { String sql = \"SELECT id,name FROM student WHERE id = ?\"; Student student = null; // 声明 JDBC 变量 Connection con = null; PreparedStatement ps = null; ResultSet rs = null; try { // 获取连接 con = DBUtil.getConnection(); // 预编译SQL ps = con.prepareStatement(sql); // 设置参数 ps.setInt(1, id); // 执行SQL rs = ps.executeQuery(); // 组装结果集返回 POJO .... } catch (SQLException e) { e.printStackTrace(); } finally { // 关闭数据库连接资源 .... } return student; } 也只是少写了一句注册驱动程序少处理了一个异常而已，并没有什么大的变化，必须再优化一下 第二步：使用 try-catch 语句自动关闭资源自动资源关闭是 JDK 7 中新引入的特性，不了解的同学可以去看一下我之前写的文章：JDK 7 新特性 于是代码可以进一步优化成这样： public Student getOne(int id) { String sql = \"SELECT id,name FROM student WHERE id = ?\"; Student student = null; // 将 JDBC 声明变量包含在 try(..) 里将自动关闭资源 try (Connection con = DBUtil.getConnection(); PreparedStatement ps = con.prepareStatement(sql)) { // 设置参数 ps.setInt(1, id); // 执行SQL ResultSet rs = ps.executeQuery(); // 组装结果集返回 POJO if (rs.next()) { student = new Student(); student.setId(rs.getInt(1)); student.setName(rs.getString(1)); } } catch (SQLException e) { e.printStackTrace(); } return student; } 这样看着好太多了，但仍然不太满意，因为我们最核心的代码也就只是执行 SQL 语句并拿到返回集，再来再来 再进一步改进 DBUtil 类：在 DBUtil 类中新增一个方法，用来直接返回结果集： public static ResultSet getResultSet(String sql, Object[] objects) throws SQLException { ResultSet rs = null; try (Connection con = getConnection(); PreparedStatement ps = con.prepareStatement(sql)) { // 根据传递进来的参数，设置 SQL 占位符的值 for (int i = 0; i &lt; objects.length; i++) { ps.setObject(i + 1, objects[i]); } // 执行 SQL 语句并接受结果集 rs = ps.executeQuery(); } // 返回结果集 return rs; } 这样我们就可以把我们最开始的代码优化成这样了： public Student getOne(int id) { String sql = \"SELECT id,name FROM student WHERE id = ?\"; Object[] objects = {id}; Student student = null; try (ResultSet rs = DBUtil.getResultSet(sql, objects);) { student.setId(rs.getInt(1)); student.setName(rs.getString(1)); } catch (SQLException e) { // 处理异常 e.printStackTrace(); } return student; } wooh!看着爽多了，但美中不足的就是没有把 try-catch 语句去掉，我们也可以不进行异常处理直接把 SQLException 抛出去： public Student getOne(int id) throws SQLException { String sql = \"SELECT id,name FROM student WHERE id = ?\"; Object[] objects = {id}; Student student = null; try (ResultSet rs = DBUtil.getResultSet(sql, objects);) { student.setId(rs.getInt(1)); student.setName(rs.getString(1)); } return student; } 其实上面的版本已经够好了，这样做只是有些强迫症。 我们自己定义的 DBUtil 工具已经很实用了，因为是从模板化的代码中抽离出来的，所以我们可以一直使用 Spring 中的 JDBC要想使用 Spring 中的 JDBC 模块，就必须引入相应的 jar 文件： 需要引入的 jar 包： spring-jdbc-4.3.16.RELEASE.jar spring-tx-4.3.16.RELEASE.jar 好在 IDEA 在创建 Spring 项目的时候已经为我们自动部署好了，接下来我们来实际在 Spring 中使用一下 JDBC： 配置数据库资源就像我们创建 DBUtil 类，将其中连接的信息封装在里面一样，我们需要将这些数据库资源配置起来 配置方式： 使用简单数据库配置 使用第三方数据库连接池 我们可以使用 Spring 内置的类来配置，但大部分时候我们都会使用第三方数据库连接池来进行配置，由于使用第三方的类，一般采用 XML 文件配置的方式，我们这里也使用 XML 文件配置的形式： 使用简单数据库配置首先我们来试试 Spring 的内置类 org.springframework.jdbc.datasource.SimpleDriverDataSource： &lt;bean id=\"dateSource\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\"> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc://mysql://locolhost:3306/student\"/> &lt;/bean> 我们来测试一下，先把我们的 JDBC 操作类写成这个样子： package jdbc; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import pojo.Student; import javax.sql.DataSource; import java.sql.*; @Component(\"jdbc\") public class JDBCtest { @Autowired private DataSource dataSource; public Student getOne(int stuID) throws SQLException { String sql = \"SELECT id, name FROM student WHERE id = \" + stuID; Student student = new Student(); Connection con = dataSource.getConnection(); Statement st = con.createStatement(); ResultSet rs = st.executeQuery(sql); if (rs.next()) { student.setId(rs.getInt(\"id\")); student.setName(rs.getString(\"name\")); } return student; } } 然后编写测试类： ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); JDBCtest jdbc = (JDBCtest) context.getBean(\"jdbc\"); Student student = jdbc.getOne(123456789); System.out.println(student.getId()); System.out.println(student.getName()); 成功取出数据库中的数据： 使用第三方数据库连接池上面配置的这个简单的数据源一般用于测试，因为它不是一个数据库连接池，知识一个很简单的数据库连接的应用。在更多的时候，我们需要使用第三方的数据库连接，比如使用 C3P0数据库连接池： &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"> &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\">&lt;/property> &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///hib_demo\">&lt;/property> &lt;property name=\"user\" value=\"root\">&lt;/property> &lt;property name=\"password\" value=\"root\">&lt;/property> &lt;property name=\"initialPoolSize\" value=\"3\">&lt;/property> &lt;property name=\"maxPoolSize\" value=\"10\">&lt;/property> &lt;property name=\"maxStatements\" value=\"100\">&lt;/property> &lt;property name=\"acquireIncrement\" value=\"2\">&lt;/property> &lt;/bean> 跟上面的测试差不多，不同的是需要引入相关支持 C3P0 数据库连接池的 jar 包而已。 Jdbc TemplateSpring 中提供了一个 Jdbc Template 类，它自己已经封装了一个 DataSource 类型的变量，我们可以直接使用： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;bean id=\"dataSrouce\" class=\"org.springframework.jdbc.datasource.SimpleDriverDataSource\"> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/student\"/> &lt;/bean> &lt;context:component-scan base-package=\"jdbc\" /> &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"> &lt;property name=\"dataSource\" ref=\"dataSrouce\"/> &lt;/bean> &lt;/beans> 我们来改写一下 JDBC 操作的类： package jdbc; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import org.springframework.stereotype.Component; import pojo.Student; import java.sql.*; @Component(\"jdbc\") public class JDBCtest { @Autowired private JdbcTemplate jdbcTemplate; public Student getOne(int stuID) throws SQLException { String sql = \"SELECT id, name FROM student WHERE id = ?\"; Student student = jdbcTemplate.queryForObject(sql, new RowMapper&lt;Student>() { @Override public Student mapRow(ResultSet resultSet, int i) throws SQLException { Student stu = new Student(); stu.setId(resultSet.getInt(\"id\")); stu.setName(resultSet.getString(\"name\")); return stu; } }, 123456789); return student; } } 测试类不变，运行可以获得正确的结果： 但是好像并没有简单多少的样子，那我们来看看其他 CRUD 的例子： /** * 增加一条数据 * * @param student */ public void add(Student student) { this.jdbcTemplate.update(\"INSERT INTO student(id,name) VALUES(?,?)\", student.getId(), student.getName()); } /** * 更新一条数据 * * @param student */ public void update(Student student) { this.jdbcTemplate.update(\"UPDATE student SET name = ? WHERE id = ?\", student.getName(), student.getId()); } /** * 删除一条数据 * * @param id */ public void delete(int id) { this.jdbcTemplate.update(\"DELETE FROM student WHERE id = ?\", id); } 现在应该简单多了吧，返回集合的话只需要稍微改写一下上面的 getOne() 方法就可以了 扩展阅读：官方文档 、 Spring 中 JdbcTemplate 实现增删改查 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Spring 实战》 全能的百度和万能的大脑 扩展阅读：① 彻底理解数据库事务、② Spring事务管理详解、③ Spring 事务管理（详解+实例）、④ 全面分析 Spring 的编程式事务管理及声明式事务管理 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"Spring","slug":"后端/Java/Spring","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Spring学习(4)——面向切面编程(AOP模块)","slug":"Spring学习-4-——面向切面编程-AOP模块","date":"2018-04-12T01:36:00.000Z","updated":"2020-12-09T05:12:43.927Z","comments":true,"path":"2018/04/12/spring-xue-xi-4-mian-xiang-qie-mian-bian-cheng-aop-mo-kuai/","link":"","permalink":"http://www.wmyskxz.com/2018/04/12/spring-xue-xi-4-mian-xiang-qie-mian-bian-cheng-aop-mo-kuai/","excerpt":"","text":"Spring AOP 简介如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。 AOP 即 Aspect Oriented Program 面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP AOP 的目的AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 AOP 当中的概念： 切入点（Pointcut）在哪些类，哪些方法上切入（where） 通知（Advice）在方法执行的什么实际（when:方法前/方法后/方法前后）做什么（what:增强的功能） 切面（Aspect）切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！ 织入（Weaving）把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成） 一个例子为了更好的说明 AOP 的概念，我们来举一个实际中的例子来说明： 在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 AOP 的一个思想：让关注点代码与业务代码分离！ 实际的代码我们来实际的用代码感受一下 1.在 Package【pojo】下新建一个【Landlord】类（我百度翻译的包租婆的英文）： package pojo; import org.springframework.stereotype.Component; @Component(\"landlord\") public class Landlord { public void service() { // 仅仅只是实现了核心的业务功能 System.out.println(\"签合同\"); System.out.println(\"收房租\"); } } 2.在 Package【aspect】下新建一个中介商【Broker】类（我还是用的翻译…）： package aspect; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Component @Aspect class Broker { @Before(\"execution(* pojo.Landlord.service())\") public void before(){ System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); } @After(\"execution(* pojo.Landlord.service())\") public void after(){ System.out.println(\"交钥匙\"); } } 3.在 applicationContext.xml 中配置自动注入，并告诉 Spring IoC 容器去哪里扫描这两个 Bean： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"> &lt;context:component-scan base-package=\"aspect\" /> &lt;context:component-scan base-package=\"pojo\" /> &lt;aop:aspectj-autoproxy/> &lt;/beans> 4.在 Package【test】下编写测试代码： package test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Landlord; public class TestSpring { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Landlord landlord = (Landlord) context.getBean(\"landlord\", Landlord.class); landlord.service(); } } 5.执行看到效果： 这个例子使用了一些注解，现在看不懂没有关系，但我们可以从上面可以看到，我们在 Landlord 的 service() 方法中仅仅实现了核心的业务代码，其余的关注点功能是根据我们设置的切面自动补全的。 使用注解来开发 Spring AOP使用注解的方式已经逐渐成为了主流，所以我们利用上面的例子来说明如何用注解来开发 Spring AOP 第一步：选择连接点Spring 是方法级别的 AOP 框架，我们主要也是以某个类额某个方法作为连接点，另一种说法就是：选择哪一个类的哪一方法用以增强功能。 .... public void service() { // 仅仅只是实现了核心的业务功能 System.out.println(\"签合同\"); System.out.println(\"收房租\"); } .... 我们在这里就选择上述 Landlord 类中的 service() 方法作为连接点。 第二步：创建切面选择好了连接点就可以创建切面了，我们可以把切面理解为一个拦截器，当程序运行到连接点的时候，被拦截下来，在开头加入了初始化的方法，在结尾也加入了销毁的方法而已，在 Spring 中只要使用 @Aspect 注解一个类，那么 Spring IoC 容器就会认为这是一个切面了： package aspect; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Component @Aspect class Broker { @Before(\"execution(* pojo.Landlord.service())\") public void before(){ System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); } @After(\"execution(* pojo.Landlord.service())\") public void after(){ System.out.println(\"交钥匙\"); } } 注意： 被定义为切面的类仍然是一个 Bean ，需要 @Component 注解标注 代码部分中在方法上面的注解看名字也能猜出个大概，下面来列举一下 Spring 中的 AspectJ 注解： 注解 说明 @Before 前置通知，在连接点方法前调用 @Around 环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法，后面会讲 @After 后置通知，在连接点方法后调用 @AfterReturning 返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常 @AfterThrowing 异常通知，当连接点方法异常时调用 有了上表，我们就知道 before() 方法是连接点方法调用前调用的方法，而 after() 方法则相反，这些注解中间使用了定义切点的正则式，也就是告诉 Spring AOP 需要拦截什么对象的什么方法，下面讲到。 第三步：定义切点在上面的注解中定义了 execution 的正则表达式，Spring 通过这个正则表达式判断具体要拦截的是哪一个类的哪一个方法： execution(* pojo.Landlord.service()) 依次对这个表达式作出分析： execution：代表执行方法的时候会触发 * ：代表任意返回类型的方法 pojo.Landlord：代表类的全限定名 service()：被拦截的方法名称 通过上面的表达式，Spring 就会知道应该拦截 pojo.Lnadlord 类下的 service() 方法。上面的演示类还好，如果多出都需要写这样的表达式难免会有些复杂，我们可以通过使用 @Pointcut 注解来定义一个切点来避免这样的麻烦： package aspect; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Component @Aspect class Broker { @Pointcut(\"execution(* pojo.Landlord.service())\") public void lService() { } @Before(\"lService()\") public void before() { System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); } @After(\"lService()\") public void after() { System.out.println(\"交钥匙\"); } } 第四步：测试 AOP编写测试代码，但是我这里因为 JDK 版本不兼容出现了 BUG….（尴尬…） 这就告诉我们：环境配置很重要…不然莫名其妙的 BUG 让你崩溃… 环绕通知我们来探讨一下环绕通知，这是 Spring AOP 中最强大的通知，因为它集成了前置通知和后置通知，它保留了连接点原有的方法的功能，所以它及强大又灵活，让我们来看看： package aspect; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; @Component @Aspect class Broker { // 注释掉之前的 @Before 和 @After 注解以及对应的方法 // @Before(\"execution(* pojo.Landlord.service())\") // public void before() { // System.out.println(\"带租客看房\"); // System.out.println(\"谈价格\"); // } // // @After(\"execution(* pojo.Landlord.service())\") // public void after() { // System.out.println(\"交钥匙\"); // } // 使用 @Around 注解来同时完成前置和后置通知 @Around(\"execution(* pojo.Landlord.service())\") public void around(ProceedingJoinPoint joinPoint) { System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); try { joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } System.out.println(\"交钥匙\"); } } 运行测试代码，结果仍然正确： 使用 XML 配置开发 Spring AOP注解是很强大的东西，但基于 XML 的开发我们仍然需要了解，我们先来了解一下 AOP 中可以配置的元素： AOP 配置元素 用途 备注 aop:advisor 定义 AOP 的通知其 一种很古老的方式，很少使用 aop:aspect 定义一个切面 —— aop:before 定义前置通知 —— aop:after 定义后置通知 —— aop:around 定义环绕通知 —— aop:after-returning 定义返回通知 —— aop:after-throwing 定义异常通知 —— aop:config 顶层的 AOP 配置元素 AOP 的配置是以它为开始的 aop:declare-parents 给通知引入新的额外接口，增强功能 —— aop:pointcut 定义切点 —— 有了之前通过注解来编写的经验，并且有了上面的表，我们将上面的例子改写成 XML 配置很容易（去掉所有的注解）： &lt;!-- 装配 Bean--> &lt;bean name=\"landlord\" class=\"pojo.Landlord\"/> &lt;bean id=\"broker\" class=\"aspect.Broker\"/> &lt;!-- 配置AOP --> &lt;aop:config> &lt;!-- where：在哪些地方（包.类.方法）做增加 --> &lt;aop:pointcut id=\"landlordPoint\" expression=\"execution(* pojo.Landlord.service())\"/> &lt;!-- what:做什么增强 --> &lt;aop:aspect id=\"logAspect\" ref=\"broker\"> &lt;!-- when:在什么时机（方法前/后/前后） --> &lt;aop:around pointcut-ref=\"landlordPoint\" method=\"around\"/> &lt;/aop:aspect> &lt;/aop:config> 运行测试程序，看到正确结果： 扩展阅读：Spring【AOP模块】就这么简单 、 关于 Spring AOP(AspectJ)你该知晓的一切（慎独读，有些深度…） 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Java 实战（第四版）》 万能的百度 and 万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"Spring","slug":"后端/Java/Spring","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Spring学习(3)——装配Spring Bean详解","slug":"Spring学习-3-——装配Spring-Bean详解","date":"2018-04-12T01:34:00.000Z","updated":"2020-12-09T05:12:40.758Z","comments":true,"path":"2018/04/12/spring-xue-xi-3-zhuang-pei-spring-bean-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/12/spring-xue-xi-3-zhuang-pei-spring-bean-xiang-jie/","excerpt":"","text":"装配 Bean 的概述前面已经介绍了 Spring IoC 的理念和设计，这一篇文章将介绍的是如何将自己开发的 Bean 装配到 Spring IoC 容器中。 大部分场景下，我们都会使用 ApplicationContext 的具体实现类，因为对应的 Spring IoC 容器功能相对强大。 而在 Spring 中提供了 3 种方法进行配置： 在 XML 文件中显式配置 在 Java 的接口和类中实现配置 隐式 Bean 的发现机制和自动装配原则 方式选择的原则在现实的工作中，这 3 种方式都会被用到，并且在学习和工作之中常常混合使用，所以这里给出一些关于这 3 种优先级的建议： 1.最优先：通过隐式 Bean 的发现机制和自动装配的原则。基于约定由于配置的原则，这种方式应该是最优先的 好处： 减少程序开发者的决定权，简单又不失灵活。 2.其次：Java 接口和类中配置实现配置在没有办法使用自动装配原则的情况下应该优先考虑此类方法 好处： 避免 XML 配置的泛滥，也更为容易。 典型场景： 一个父类有多个子类，比如学生类有两个子类，一个男学生类和女学生类，通过 IoC 容器初始化一个学生类，容器将无法知道使用哪个子类去初始化，这个时候可以使用 Java 的注解配置去指定。 3.最后：XML 方式配置在上述方法都无法使用的情况下，那么也只能选择 XML 配置的方式。 好处： 简单易懂（当然，特别是对于初学者） 典型场景： 当使用第三方类的时候，有些类并不是我们开发的，我们无法修改里面的代码，这个时候就通过 XML 的方式配置使用了。 通过 XML 配置装配 Bean使用 XML 装配 Bean 需要定义对应的 XML，这里需要引入对应的 XML 模式（XSD）文件，这些文件会定义配置 Spring Bean 的一些元素，当我们在 IDEA 中创建 XML 文件时，会有友好的提示： 一个简单的 XML 配置文件如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;/beans> 这就只是一个格式文件，引入了一个 beans 的定义，引入了 xsd 文件，它是一个根元素，这样它所定义的元素将可以定义对应的 Spring Bean 装配简易值先来一个最简单的装配： &lt;bean id=\"c\" class=\"pojo.Category\"> &lt;property name=\"name\" value=\"测试\" /> &lt;/bean> 简单解释一下： id 属性是 Spring 能找到当前 Bean 的一个依赖的编号，遵守 XML 语法的 ID 唯一性约束。必须以字母开头，可以使用字母、数字、连字符、下划线、句号、冒号，不能以 / 开头。不过 id 属性不是一个必需的属性，name 属性也可以定义 bean 元素的名称，能以逗号或空格隔开起多个别名，并且可以使用很多的特殊字符，比如在 Spring 和 Spring MVC 的整合中，就得使用 name 属性来定义 bean 的名称，并且使用 / 开头。 注意： 从 Spring 3.1 开始，id 属性也可以是 String 类型了，也就是说 id 属性也可以使用 / 开头，而 bean 元素的 id 的唯一性由容器负责检查。如果 id 和 name 属性都没有声明的话，那么 Spring 将会采用 “全限定名#{number}” 的格式生成编号。 例如这里，如果没有声明 “id=&quot;c&quot;” 的话，那么 Spring 为其生成的编号就是 “pojo.Category#0”，当它第二次声明没有 id 属性的 Bean 时，编号就是 “pojo.Category#1”，以此类推。 class 属性显然就是一个类的全限定名 property 元素是定义类的属性，其中的 name 属性定义的是属性的名称，而 value 是它的值。 这样的定义很简单，但是有时候需要注入一些自定义的类，比如之前饮品店的例子，JuickMaker 需要用户提供原料信息才能完成 juice 的制作： &lt;!-- 配置 srouce 原料 --> &lt;bean name=\"source\" class=\"pojo.Source\"> &lt;property name=\"fruit\" value=\"橙子\"/> &lt;property name=\"sugar\" value=\"多糖\"/> &lt;property name=\"size\" value=\"超大杯\"/> &lt;/bean> &lt;bean name=\"juickMaker\" class=\"pojo.JuiceMaker\"> &lt;!-- 注入上面配置的id为srouce的Srouce对象 --> &lt;property name=\"source\" ref=\"source\"/> &lt;/bean> 这里先定义了一个 name 为 source 的 Bean，然后再制造器中通过 ref 属性去引用对应的 Bean，而 source 正是之前定义的 Bean 的 name ，这样就可以相互引用了。 注入对象：使用 ref 属性 装配集合有些时候我们需要装配一些复杂的东西，比如 Set、Map、List、Array 和 Properties 等，为此我们在 Packge【pojo】下新建一个 ComplexAssembly 类： package pojo; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; public class ComplexAssembly { private Long id; private List&lt;String> list; private Map&lt;String, String> map; private Properties properties; private Set&lt;String> set; private String[] array; /* setter and getter */ } 这个 Bean 没有任何的实际意义，知识为了介绍如何装配这些常用的集合类： &lt;bean id=\"complexAssembly\" class=\"pojo.ComplexAssembly\"> &lt;!-- 装配Long类型的id --> &lt;property name=\"id\" value=\"1\"/> &lt;!-- 装配List类型的list --> &lt;property name=\"list\"> &lt;list> &lt;value>value-list-1&lt;/value> &lt;value>value-list-2&lt;/value> &lt;value>value-list-3&lt;/value> &lt;/list> &lt;/property> &lt;!-- 装配Map类型的map --> &lt;property name=\"map\"> &lt;map> &lt;entry key=\"key1\" value=\"value-key-1\"/> &lt;entry key=\"key2\" value=\"value-key-2\"/> &lt;entry key=\"key3\" value=\"value-key-2\"/> &lt;/map> &lt;/property> &lt;!-- 装配Properties类型的properties --> &lt;property name=\"properties\"> &lt;props> &lt;prop key=\"prop1\">value-prop-1&lt;/prop> &lt;prop key=\"prop2\">value-prop-2&lt;/prop> &lt;prop key=\"prop3\">value-prop-3&lt;/prop> &lt;/props> &lt;/property> &lt;!-- 装配Set类型的set --> &lt;property name=\"set\"> &lt;set> &lt;value>value-set-1&lt;/value> &lt;value>value-set-2&lt;/value> &lt;value>value-set-3&lt;/value> &lt;/set> &lt;/property> &lt;!-- 装配String[]类型的array --> &lt;property name=\"array\"> &lt;array> &lt;value>value-array-1&lt;/value> &lt;value>value-array-2&lt;/value> &lt;value>value-array-3&lt;/value> &lt;/array> &lt;/property> &lt;/bean> 总结： List 属性为对应的 &lt;list&gt; 元素进行装配，然后通过多个 &lt;value&gt; 元素设值 Map 属性为对应的 &lt;map&gt; 元素进行装配，然后通过多个 &lt;entry&gt; 元素设值，只是 entry 包含一个键值对(key-value)的设置 Properties 属性为对应的 &lt;properties&gt; 元素进行装配，通过多个 &lt;property&gt; 元素设值，只是 properties 元素有一个必填属性 key ，然后可以设置值 Set 属性为对应的 &lt;set&gt; 元素进行装配，然后通过多个 &lt;value&gt; 元素设值 对于数组而言，可以使用 &lt;array&gt; 设置值，然后通过多个 &lt;value&gt; 元素设值。 上面看到了对简单 String 类型的各个集合的装载，但是有些时候可能需要更为复杂的装载，比如一个 List 可以是一个系列类的对象，为此需要定义注入的相关信息，其实跟上面的配置没什么两样，只不过加入了 ref 这一个属性而已： 集合注入总结： List 属性使用 &lt;list&gt; 元素定义注入，使用多个 &lt;ref&gt; 元素的 Bean 属性去引用之前定义好的 Bean &lt;property name=\"list\"> &lt;list> &lt;ref bean=\"bean1\"/> &lt;ref bean=\"bean2\"/> &lt;/list> &lt;/property> Map 属性使用 &lt;map&gt; 元素定义注入，使用多个 &lt;entry&gt; 元素的 key-ref 属性去引用之前定义好的 Bean 作为键，而用 value-ref 属性引用之前定义好的 Bean 作为值 &lt;property name=\"map\"> &lt;map> &lt;entry key-ref=\"keyBean\" value-ref=\"valueBean\"/> &lt;/map> &lt;/property> Set 属性使用 &lt;set&gt; 元素定义注入，使用多个 &lt;ref&gt; 元素的 bean 去引用之前定义好的 Bean &lt;property name=\"set\"> &lt;set> &lt;ref bean=\"bean\"/> &lt;/set> &lt;/property> 命名空间装配除了上述的配置之外， Spring 还提供了对应的命名空间的定义，只是在使用命名空间的时候要先引入对应的命名空间和 XML 模式（XSD）文件。 ——【① c-命名空间】——c-命名空间是在 Spring 3.0 中引入的，它是在 XML 中更为简洁地描述构造器参数的方式，要使用它的话，必须要在 XML 的顶部声明其模式： 注意：是通过构造器参数的方式 现在假设我们现在有这么一个类： package pojo; public class Student { int id; String name; public Student(int id, String name) { this.id = id; this.name = name; } // setter and getter } 在 c-命名空间和模式声明之后，我们就可以使用它来声明构造器参数了： &lt;!-- 引入 c-命名空间之前 --> &lt;bean name=\"student1\" class=\"pojo.Student\"> &lt;constructor-arg name=\"id\" value=\"1\" /> &lt;constructor-arg name=\"name\" value=\"学生1\"/> &lt;/bean> &lt;!-- 引入 c-命名空间之后 --> &lt;bean name=\"student2\" class=\"pojo.Student\" c:id=\"2\" c:name=\"学生2\"/> c-命名空间属性名以 “c:” 开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后如果需要注入对象的话则要跟上 -ref（如c:card-ref=&quot;idCard1&quot;，则对 card 这个构造器参数注入之前配置的名为 idCard1 的 bean） 很显然，使用 c-命名空间属性要比使用 &lt;constructor-arg&gt; 元素精简，并且会直接引用构造器之中参数的名称，这有利于我们使用的安全性。 我们有另外一种替代方式： &lt;bean name=\"student2\" class=\"pojo.Student\" c:_0=\"3\" c:_1=\"学生3\"/> 我们将参数的名称替换成了 “0” 和 “1” ，也就是参数的索引。因为在 XML 中不允许数字作为属性的第一个字符，因此必须要添加一个下划线来作为前缀。 ——【② p-命名空间】——c-命名空间通过构造器注入的方式来配置 bean，p-命名空间则是用setter的注入方式来配置 bean ，同样的，我们需要引入声明： 然后我们就可以通过 p-命名空间来设置属性： &lt;!-- 引入p-命名空间之前 --> &lt;bean name=\"student1\" class=\"pojo.Student\"> &lt;property name=\"id\" value=\"1\" /> &lt;property name=\"name\" value=\"学生1\"/> &lt;/bean> &lt;!-- 引入p-命名空间之后 --> &lt;bean name=\"student2\" class=\"pojo.Student\" p:id=\"2\" p:name=\"学生2\"/> 我们需要先删掉 Student 类中的构造函数，不然 XML 约束会提示我们配置 &lt;constructor-arg&gt; 元素。 同样的，如果属性需要注入其他 Bean 的话也可以在后面跟上 -ref： &lt;bean name=\"student2\" class=\"pojo.Student\" p:id=\"2\" p:name=\"学生2\" p:cdCard-ref=\"cdCard1\"/> ——【③ util-命名空间】——工具类的命名空间，可以简化集合类元素的配置，同样的我们需要引入其声明（无需担心怎么声明的问题，IDEA会有很友好的提示）： 我们来看看引入前后的变化： &lt;!-- 引入util-命名空间之前 --> &lt;property name=\"list\"> &lt;list> &lt;ref bean=\"bean1\"/> &lt;ref bean=\"bean2\"/> &lt;/list> &lt;/property> &lt;!-- 引入util-命名空间之后 --> &lt;util:list id=\"list\"> &lt;ref bean=\"bean1\"/> &lt;ref bean=\"bean2\"/> &lt;/util:list> &lt;util:list&gt; 只是 util-命名空间中的多个元素之一，下表提供了 util-命名空间提供的所有元素： 元素 描述 &lt;util:constant&gt; 引用某个类型的 public static 域，并将其暴露为 bean &lt;util:list&gt; 创建一个 java.util.List 类型的 bean，其中包含值或引用 &lt;util:map&gt; 创建一个 java.util.map 类型的 bean，其中包含值或引用 &lt;util:properties&gt; 创建一个 java.util.Properties 类型的 bean &lt;util:property-path&gt; 引用一个 bean 的属性（或内嵌属性），并将其暴露为 bean &lt;util:set&gt; 创建一个 java.util.Set 类型的 bean，其中包含值或引用 引入其他配置文件在实际开发中，随着应用程序规模的增加，系统中 &lt;bean&gt; 元素配置的数量也会大大增加，导致 applicationContext.xml 配置文件变得非常臃肿难以维护。 解决方案：让 applicationContext.xml 文件包含其他配置文件即可使用 &lt;import&gt; 元素引入其他配置文件 1.在【src】文件下新建一个 bean.xml 文件，写好基础的约束，把 applicationContext.xml 文件中配置的 &lt;bean&gt; 元素复制进去 2.在 applicationContext.xml 文件中写入： &lt;import resource=\"bean.xml\" /> 3.运行测试代码，仍然能正确获取到 bean: 通过注解装配 Bean上面，我们已经了解了如何使用 XML 的方式去装配 Bean，但是更多的时候已经不再推荐使用 XML 的方式去装配 Bean，更多的时候回考虑使用注解（annotation） 的方式去装配 Bean。 优势： 1.可以减少 XML 的配置，当配置项多的时候，臃肿难以维护2.功能更加强大，既能实现 XML 的功能，也提供了自动装配的功能，采用了自动装配后，程序猿所需要做的决断就少了，更加有利于对程序的开发，这就是“约定由于配置”的开发原则 在 Spring 中，它提供了两种方式来让 Spring IoC 容器发现 bean： 组件扫描：通过定义资源的方式，让 Spring IoC 容器扫描对应的包，从而把 bean 装配进来。 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。 使用@Compoent 装配 Bean我们把之前创建的 Student 类改一下： package pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component(value = \"student1\") public class Student { @Value(\"1\") int id; @Value(\"student_name_1\") String name; // getter and setter } 解释一下： @Component注解：表示 Spring IoC 会把这个类扫描成一个 bean 实例，而其中的 value 属性代表这个类在 Spring 中的 id，这就相当于在 XML 中定义的 Bean 的 id：&lt;bean id=&quot;student1&quot; class=&quot;pojo.Student&quot; /&gt;，也可以简写成 @Component(&quot;student1&quot;)，甚至直接写成 @Component ，对于不写的，Spring IoC 容器就默认以类名来命名作为 id，只不过首字母小写，配置到容器中。 @Value注解：表示值的注入，跟在 XML 中写 value 属性是一样的。 这样我们就声明好了我们要创建的一个 Bean，就像在 XML 中写下了这样一句话： &lt;bean name=\"student1\" class=\"pojo.Student\"> &lt;property name=\"id\" value=\"1\" /> &lt;property name=\"name\" value=\"student_name_1\"/> &lt;/bean> 但是现在我们声明了这个类，并不能进行任何的测试，因为 Spring IoC 并不知道这个 Bean 的存在，这个时候我们可以使用一个 StudentConfig 类去告诉 Spring IoC ： package pojo; import org.springframework.context.annotation.ComponentScan; @ComponentScan public class StudentConfig { } 这个类十分简单，没有任何逻辑，但是需要说明两点： 该类和 Student 类位于同一包名下 @ComponentScan注解：代表进行扫描，默认是扫描当前包的路径，扫描所有带有 @Component 注解的 POJO。 这样一来，我们就可以通过 Spring 定义好的 Spring IoC 容器的实现类——AnnotationConfigApplicationContext 去生成 IoC 容器了： ApplicationContext context = new AnnotationConfigApplicationContext(StudentConfig.class); Student student = (Student) context.getBean(\"student1\", Student.class); student.printInformation(); 这里可以看到使用了 AnnotationConfigApplicationContext 类去初始化 Spring IoC 容器，它的配置项是 StudentConfig 类，这样 Spring IoC 就会根据注解的配置去解析对应的资源，来生成 IoC 容器了。 明显的弊端： 对于 @ComponentScan 注解，它只是扫描所在包的 Java 类，但是更多的时候我们希望的是可以扫描我们指定的类 上面的例子只是注入了一些简单的值，测试发现，通过 @Value 注解并不能注入对象 @Component 注解存在着两个配置项： basePackages：它是由 base 和 package 两个单词组成的，而 package 还是用了复数，意味着它可以配置一个 Java 包的数组，Spring 会根据它的配置扫描对应的包和子包，将配置好的 Bean 装配进来 basePackageClasses：它由 base、package 和 class 三个单词组成，采用复数，意味着它可以配置多个类， Spring 会根据配置的类所在的包，为包和子包进行扫描装配对应配置的 Bean 我们来试着重构之前写的 StudentConfig 类来验证上面两个配置项： package pojo; import org.springframework.context.annotation.ComponentScan; @ComponentScan(basePackages = \"pojo\") public class StudentConfig { } // —————————————————— 【 宇宙超级无敌分割线】—————————————————— package pojo; import org.springframework.context.annotation.ComponentScan; @ComponentScan(basePackageClasses = pojo.Student.class) public class StudentConfig { } 验证都能通过，bingo！ 对于 【basePackages】 和 【basePackageClasses】 的选择问题：【basePackages】 的可读性会更好一些，所以在项目中会优先选择使用它，但是在需要大量重构的工程中，尽量不要使用【basePackages】，因为很多时候重构修改包名需要反复地配置，而 IDE 不会给你任何的提示，而采用【basePackageClasses】会有错误提示。 自动装配——@Autowired上面提到的两个弊端之一就是没有办法注入对象，通过自动装配我们将解决这个问题。 所谓自动装配技术是一种由 Spring 自己发现对应的 Bean，自动完成装配工作的方式，它会应用到一个十分常用的注解 @Autowired 上，这个时候 Spring 会根据类型去寻找定义的 Bean 然后将其注入，听起来很神奇，让我们实际来看一看： 1.先在 Package【service】下创建一个 StudentService 接口： package service; public interface StudentService { public void printStudentInfo(); } 使用接口是 Spring 推荐的方式，这样可以更为灵活，可以将定义和实现分离 2.为上面的接口创建一个 StudentServiceImp 实现类： package service; import org.springframework.beans.factory.annotation.Autowired; import pojo.Student; @Component(\"studentService\") public class StudentServiceImp implements StudentService { @Autowired private Student student = null; // getter and setter public void printStudentInfo() { System.out.println(\"学生的 id 为：\" + student.getName()); System.out.println(\"学生的 name 为：\" + student.getName()); } } 该实现类实现了接口的 printStudentInfo() 方法，打印出成员对象 student 的相关信息，这里的 @Autowired 注解，表示在 Spring IoC 定位所有的 Bean 后，这个字段需要按类型注入，这样 IoC 容器就会寻找资源，然后将其注入。 3.编写测试类： // 第一步：修改 StudentConfig 类，告诉 Spring IoC 在哪里去扫描它： package pojo; import org.springframework.context.annotation.ComponentScan; @ComponentScan(basePackages = {\"pojo\", \"service\"}) public class StudentConfig { } // 或者也可以在 XML 文件中声明去哪里做扫描 &lt;context:component-scan base-package=\"pojo\" /> &lt;context:component-scan base-package=\"service\" /> // 第二步：编写测试类： package test; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import pojo.StudentConfig; import service.StudentService; import service.StudentServiceImp; public class TestSpring { public static void main(String[] args) { // 通过注解的方式初始化 Spring IoC 容器 ApplicationContext context = new AnnotationConfigApplicationContext(StudentConfig.class); StudentService studentService = context.getBean(\"studentService\", StudentServiceImp.class); studentService.printStudentInfo(); } } 运行代码： 再次理解： @Autowired 注解表示在 Spring IoC 定位所有的 Bean 后，再根据类型寻找资源，然后将其注入。 过程： 定义 Bean ——》 初始化 Bean（扫描） ——》 根据属性需要从 Spring IoC 容器中搜寻满足要求的 Bean ——》 满足要求则注入 问题： IoC 容器可能会寻找失败，此时会抛出异常（默认情况下，Spring IoC 容器会认为一定要找到对应的 Bean 来注入到这个字段，但有些时候并不是一定需要，比如日志） 解决： 通过配置项 required 来改变，比如 @Autowired(required = false) @Autowired 注解不仅仅能配置在属性之上，还允许方法配置，常见的 Bean 的 setter 方法也可以使用它来完成注入，总之一切需要 Spring IoC 去寻找 Bean 资源的地方都可以用到，例如： /* 包名和import */ public class JuiceMaker { ...... @Autowired public void setSource(Source source) { this.source = source; } } 在大部分的配置中都推荐使用这样的自动注入来完成，这是 Spring IoC 帮助我们自动装配完成的，这样使得配置大幅度减少，满足约定优于配置的原则，增强程序的健壮性。 自动装配的歧义性（@Primary和@Qualifier）在上面的例子中我们使用 @Autowired 注解来自动注入一个 Source 类型的 Bean 资源，但如果我们现在有两个 Srouce 类型的资源，Spring IoC 就会不知所措，不知道究竟该引入哪一个 Bean： &lt;bean name=\"source1\" class=\"pojo.Source\"> &lt;property name=\"fruit\" value=\"橙子\"/> &lt;property name=\"sugar\" value=\"多糖\"/> &lt;property name=\"size\" value=\"超大杯\"/> &lt;/bean> &lt;bean name=\"source2\" class=\"pojo.Source\"> &lt;property name=\"fruit\" value=\"橙子\"/> &lt;property name=\"sugar\" value=\"少糖\"/> &lt;property name=\"size\" value=\"小杯\"/> &lt;/bean> 我们可以会想到 Spring IoC 最底层的容器接口——BeanFactory 的定义，它存在一个按照类型获取 Bean 的方法，显然通过 Source.class 作为参数无法判断使用哪个类实例进行返回，这就是自动装配的歧义性。 为了消除歧义性，Spring 提供了两个注解： @Primary 注解：代表首要的，当 Spring IoC 检测到有多个相同类型的 Bean 资源的时候，会优先注入使用该注解的类。 问题：该注解只是解决了首要的问题，但是并没有选择性的问题 @Qualifier 注解：上面所谈及的歧义性，一个重要的原因是 Spring 在寻找依赖注入的时候是按照类型注入引起的。除了按类型查找 Bean，Spring IoC 容器最底层的接口 BeanFactory 还提供了按名字查找的方法，如果按照名字来查找和注入不就能消除歧义性了吗？ 使用方法： 指定注入名称为 “source1” 的 Bean 资源 /* 包名和import */ public class JuiceMaker { ...... @Autowired @Qualifier(\"source1\") public void setSource(Source source) { this.source = source; } } 使用@Bean 装配 Bean 问题： 以上都是通过 @Component 注解来装配 Bean ，并且只能注解在类上，当你需要引用第三方包的（jar 文件），而且往往并没有这些包的源码，这时候将无法为这些包的类加入 @Component 注解，让它们变成开发环境中的 Bean 资源。 解决方案： 1.自己创建一个新的类来扩展包里的类，然后再新类上使用 @Component 注解，但这样很 low2.使用 @Bean 注解，注解到方法之上，使其成为 Spring 中返回对象为 Spring 的 Bean 资源。 我们在 Package【pojo】 下新建一个用来测试 @Bean 注解的类： package pojo; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class BeanTester { @Bean(name = \"testBean\") public String test() { String str = \"测试@Bean注解\"; return str; } } 注意： @Configuration 注解相当于 XML 文件的根元素，必须要，有了才能解析其中的 @Bean 注解 然后我们在测试类中编写代码，从 Spring IoC 容器中获取到这个 Bean ： // 在 pojo 包下扫描 ApplicationContext context = new AnnotationConfigApplicationContext(\"pojo\"); // 因为这里获取到的 Bean 就是 String 类型所以直接输出 System.out.println(context.getBean(\"testBean\")); @Bean 的配置项中包含 4 个配置项： name： 是一个字符串数组，允许配置多个 BeanName autowire： 标志是否是一个引用的 Bean 对象，默认值是 Autowire.NO initMethod： 自定义初始化方法 destroyMethod： 自定义销毁方法 使用 @Bean 注解的好处就是能够动态获取一个 Bean 对象，能够根据环境不同得到不同的 Bean 对象。或者说将 Spring 和其他组件分离（其他组件不依赖 Spring，但是又想 Spring 管理生成的 Bean） Bean 的作用域在默认的情况下，Spring IoC 容器只会对一个 Bean 创建一个实例，但有时候，我们希望能够通过 Spring IoC 容器获取多个实例，我们可以通过 @Scope 注解或者 &lt;bean&gt; 元素中的 scope 属性来设置，例如： // XML 中设置作用域 &lt;bean id=\"\" class=\"\" scope=\"prototype\" /> // 使用注解设置作用域 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) Spring 提供了 5 种作用域，它会根据情况来决定是否生成新的对象： 作用域类别 描述 singleton(单例) 在Spring IoC容器中仅存在一个Bean实例 （默认的scope） prototype(多例) 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean()：不会在容器启动时创建对象 request(请求) 用于web开发，将Bean放入request范围 ，request.setAttribute(“xxx”) ， 在同一个request 获得同一个Bean session(会话) 用于web开发，将Bean 放入Session范围，在同一个Session 获得同一个Bean globalSession(全局会话) 一般用于 Porlet 应用环境 , 分布式系统存在全局 session 概念（单点登录），如果不是 porlet 环境，globalSession 等同于 Session 在开发中主要使用 scope=&quot;singleton&quot;、scope=&quot;prototype&quot;，对于MVC中的Action使用prototype类型，其他使用singleton，Spring容器会管理 Action 对象的创建,此时把 Action 的作用域设置为 prototype. 扩展阅读：@Profile 注解 、 条件化装配 Bean Spring 表达式语言简要说明Spring 还提供了更灵活的注入方式，那就是 Spring 表达式，实际上 Spring EL 远比以上注入方式都要强大，它拥有很多功能： 使用 Bean 的 id 来引用 Bean 调用指定对象的方法和访问对象的属性 进行运算 提供正则表达式进行匹配 集合配置 我们来看一个简单的使用 Spring 表达式的例子： package pojo; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component(\"elBean\") public class ElBean { // 通过 beanName 获取 bean，然后注入 @Value(\"#{role}\") private Role role; // 获取 bean 的属性 id @Value(\"#{role.id}\") private Long id; // 调用 bean 的 getNote 方法 @Value(\"#{role.getNote().toString()}\") private String note; /* getter and setter */ } 与属性文件中读取使用的 “$” 不同，在 Spring EL 中则使用 “#” 扩展阅读： Spring 表达式语言 参考资料： 《Java EE 互联网轻量级框架整合开发》 《Java 实战（第四版）》 万能的百度 and 万能的大脑 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"Spring","slug":"后端/Java/Spring","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Spring学习(2)——Spring IoC详解","slug":"Spring学习-2-——Spring-IoC详解","date":"2018-04-11T01:32:00.000Z","updated":"2020-12-09T05:12:35.731Z","comments":true,"path":"2018/04/11/spring-xue-xi-2-spring-ioc-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/11/spring-xue-xi-2-spring-ioc-xiang-jie/","excerpt":"","text":"Spring IoC 概述IoC：Inverse of Control（控制反转） 读作 “反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 正控：若要使用某个对象，需要自己去负责对象的创建 反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架 好莱坞法则： Don’t call me ,I’ll call you 一个例子控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。 在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。 然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。 请注意你并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。 Spring IoC 阐述这就是一种控制反转的理念，上述的例子已经很好的说明了问题，我们再来描述一下控制反转的概念：控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。 好处：降低对象之间的耦合我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿） 主动创建的模式中，责任归于开发者，而在被动的模式下，责任归于 IoC 容器，基于这样的被动形式，我们就说对象被控制反转了。（也可以说是反转了控制） Spring IoC 容器Spring 会提供 IoC 容器来管理和容纳我们所开发的各种各样的 Bean，并且我们可以从中获取各种发布在 Spring IoC 容器里的 Bean，并且通过描述可以得到它。 Spring IoC 容器的设计Spring IoC 容器的设计主要是基于以下两个接口： BeanFactory ApplicationContext 其中 ApplicationContext 是 BeanFactory 的子接口之一，换句话说：BeanFactory 是 Spring IoC 容器所定义的最底层接口，而 ApplicationContext 是其最高级接口之一，并对 BeanFactory 功能做了许多的扩展，所以在绝大部分的工作场景下，都会使用 ApplicationContext 作为 Spring IoC 容器。 BeanFactory从上图中我们可以几乎看到， BeanFactory 位于设计的最底层，它提供了 Spring IoC 最底层的设计，为此，我们先来看看该类中提供了哪些方法： 由于这个接口的重要性，所以有必要在这里作一下简短的说明： 【getBean】 对应了多个方法来获取配置给 Spring IoC 容器的 Bean。① 按照类型拿 bean：bean = (Bean) factory.getBean(Bean.class); 注意： 要求在 Spring 中只配置了一个这种类型的实例，否则报错。（如果有多个那 Spring 就懵了，不知道该获取哪一个）② 按照 bean 的名字拿 bean:bean = (Bean) factory.getBean(&quot;beanName&quot;);注意： 这种方法不太安全，IDE 不会检查其安全性（关联性）③ 按照名字和类型拿 bean：（推荐）bean = (Bean) factory.getBean(&quot;beanName&quot;, Bean.class); 【isSingleton】 用于判断是否单例，如果判断为真，其意思是该 Bean 在容器中是作为一个唯一单例存在的。而【isPrototype】则相反，如果判断为真，意思是当你从容器中获取 Bean，容器就为你生成一个新的实例。 注意： 在默认情况下，【isSingleton】为 ture，而【isPrototype】为 false 关于 type 的匹配，这是一个按 Java 类型匹配的方式 【getAliases】方法是获取别名的方法 这就是 Spring IoC 最底层的设计，所有关于 Spring IoC 的容器将会遵守它所定义的方法。 ApplicationContext根据 ApplicationContext 的类继承关系图，可以看到 ApplicationContext 接口扩展了许许多多的接口，因此它的功能十分强大，所以在实际应用中常常会使用到的是 ApplicationContext 接口，因为 BeanFactory 的方法和功能较少，而 ApplicationContext 的方法和功能较多。 通过上一篇 IoC 的例子，我们来认识一个 ApplicationContext 的子类——ClassPathXmlApplicationContext。 先在【src】目录下创建一个 【bean.xml】 文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;!-- 通过 xml 方式装配 bean --> &lt;bean name=\"source\" class=\"pojo.Source\"> &lt;property name=\"fruit\" value=\"橙子\"/> &lt;property name=\"sugar\" value=\"多糖\"/> &lt;property name=\"size\" value=\"超大杯\"/> &lt;/bean> &lt;/beans> 这里定义了一个 bean ，这样 Spring IoC 容器在初始化的时候就能找到它们，然后使用 ClassPathXmlApplicationContext 容器就可以将其初始化： ApplicationContext context = new ClassPathXmlApplicationContext(\"bean.xml\"); Source source = (Source) context.getBean(\"source\", Source.class); System.out.println(source.getFruit()); System.out.println(source.getSugar()); System.out.println(source.getSize()); 这样就会使用 Application 的实现类 ClassPathXmlApplicationContext 去初始化 Spring IoC 容器，然后开发者就可以通过 IoC 容器来获取资源了啦！ 关于 Spring Bean 的装配以及一些细节，会在下一篇文章中讲到 ApplicationContext 常见实现类：1.ClassPathXmlApplicationContext：读取classpath中的资源 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 2:FileSystemXmlApplicationContext:-读取指定路径的资源 ApplicationContext ac = new FileSystemXmlApplicationContext(\"c:/applicationContext.xml\"); 3.XmlWebApplicationContext:需要在Web的环境下才可以运行 XmlWebApplicationContext ac = new XmlWebApplicationContext(); // 这时并没有初始化容器 ac.setServletContext(servletContext); // 需要指定ServletContext对象 ac.setConfigLocation(\"/WEB-INF/applicationContext.xml\"); // 指定配置文件路径，开头的斜线表示Web应用的根目录 ac.refresh(); // 初始化容器 BeanFactory 和 ApplicationContext 的区别： BeanFactory： 是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。在应用中，一般不使用 BeanFactory，而推荐使用ApplicationContext（应用上下文），原因如下。 ApplicationContext： 1.继承了 BeanFactory，拥有了基本的 IoC 功能；2.除此之外，ApplicationContext 还提供了以下功能：① 支持国际化；② 支持消息机制；③ 支持统一的资源加载；④ 支持AOP功能； Spring IoC 的容器的初始化和依赖注入虽然 Spring IoC 容器的生成十分的复杂，但是大体了解一下 Spring IoC 初始化的过程还是必要的。这对于理解 Spring 的一系列行为是很有帮助的。 注意： Bean 的定义和初始化在 Spring IoC 容器是两大步骤，它是先定义，然后初始化和依赖注入的。 Bean 的定义分为 3 步： 1.Resource 定位Spring IoC 容器先根据开发者的配置，进行资源的定位，在 Spring 的开发中，通过 XML 或者注解都是十分常见的方式，定位的内容是由开发者提供的。2.BeanDefinition 的载入这个时候只是将 Resource 定位到的信息，保存到 Bean 定义（BeanDefinition）中，此时并不会创建 Bean 的实例3.BeanDefinition 的注册这个过程就是将 BeanDefinition 的信息发布到 Spring IoC 容器中注意：此时仍然没有对应的 Bean 的实例。 做完了以上 3 步，Bean 就在 Spring IoC 容器中被定义了，而没有被初始化，更没有完成依赖注入，也就是没有注入其配置的资源给 Bean，那么它还不能完全使用。 对于初始化和依赖注入，Spring Bean 还有一个配置选项——【lazy-init】，其含义就是是否初始化 Spring Bean。在没有任何配置的情况下，它的默认值为 default，实际值为 false，也就是 Spring IoC 默认会自动初始化 Bean。如果将其设置为 true，那么只有当我们使用 Spring IoC 容器的 getBean 方法获取它时，它才会进行 Bean 的初始化，完成依赖注入。 IoC 是如何实现的最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎： 读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名 使用反射的API，基于类名实例化对应的对象实例 将对象实例，通过构造函数或者 setter，传递给 JuiceMaker 我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！ 引用地址：这里【参考资料】:《Java EE 互联网轻量级框架整合开发》、《Spring 实战（第四版）》【好文推荐】：①Spring 的本质系列(1) – 依赖注入、 ②Spring的IoC原理 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"Spring","slug":"后端/Java/Spring","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"Spring学习(1)——快速入门","slug":"Spring学习-1-——快速入门","date":"2018-04-10T01:29:00.000Z","updated":"2020-12-09T05:12:19.625Z","comments":true,"path":"2018/04/10/spring-xue-xi-1-kuai-su-ru-men/","link":"","permalink":"http://www.wmyskxz.com/2018/04/10/spring-xue-xi-1-kuai-su-ru-men/","excerpt":"","text":"认识 Spring 框架Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 IoC (Inversion of Control，控制反转) 和 AOP(Aspect Oriented Programming，面向切面编程)。 什么是 Spring： Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作 《Expert one on one J2EE design and development》 中阐述的部分理念和原型衍生而来。 Spring 提倡以 “最少侵入” 的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring 适用范围：任何 Java 应用 Spring 的根本使命：简化 Java 开发 尽管 J2EE 能够赶上 Spring 的步伐，但 Spring 并没有停止前进， Spring 继续在其他领域发展，而 J2EE 则刚刚开始涉及这些领域，或者还没有完全开始在这些领域的创新。移动开发、社交 API 集成、NoSQL 数据库、云计算以及大数据都是 Spring 正在涉足和创新的领域。Spring 的前景依然会很美好。 Spring 中常用术语： 框架：是能完成一定功能的半成品。框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 非侵入式设计：从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 轻量级和重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 JavaBean：即符合 JavaBean 规范的 Java 类 POJO：即 Plain Old Java Objects，简单老式 Java 对象它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。 容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 Spring 的优势 低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring 能帮我们做什么①.Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。②.Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。③.Spring 能非常简单的帮我们管理数据库事务。④.Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。⑤.Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。⑥.Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring 的框架结构 Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)： 包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 Spring IoC 和 DI 简介IoC：Inverse of Control（控制反转） 读作 “反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 正控：若要使用某个对象，需要自己去负责对象的创建 反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架 好莱坞法则： Don’t call me ,I’ll call you 一个例子控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。 在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。 然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。请注意你并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。 编写第一个 Spring 程序 新建一个空的 Java 项目，命名为【spring】 新建一个名为【lib】的目录，并添加进必要的 jar 包，导入项目 在 Packge【pojo】下新建一个【Source】类： package pojo; public class Source { private String fruit; // 类型 private String sugar; // 糖分描述 private String size; // 大小杯 /* setter and getter */ } 在 【src】 目录下新建一个 【applicationContext.xml】 文件，通过 xml 文件配置的方式装配我们的 bean 在 Packge【test】下新建一个【TestSpring】类： package test; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Source; public class TestSpring { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext( new String[]{\"applicationContext.xml\"} ); Source source = (Source) context.getBean(\"source\"); System.out.println(source.getFruit()); System.out.println(source.getSugar()); System.out.println(source.getSize()); } } 运行测试代码，可以正常拿到 xml 配置的 bean 总结： 传统的方式：通过new 关键字主动创建一个对象 IOC方式：对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 参考地址：这里 DI：Dependency Injection（依赖注入） 指 Spring 创建对象的过程中，将对象依赖属性（简单值，集合，对象）通过配置设值给该对象 继续上面的例子 在 Packge【pojo】下新建一个【JuiceMaker】类： package pojo; public class JuiceMaker { // 唯一关联了一个 Source 对象 private Source source = null; /* setter and getter */ public String makeJuice(){ String juice = \"xxx用户点了一杯\" + source.getFruit() + source.getSugar() + source.getSize(); return juice; } } 在 xml 文件中配置 JuiceMaker 对象： 注意：这里要使用 ref 来注入另一个对象 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean name=\"source\" class=\"pojo.Source\"> &lt;property name=\"fruit\" value=\"橙子\"/> &lt;property name=\"sugar\" value=\"多糖\"/> &lt;property name=\"size\" value=\"超大杯\"/> &lt;/bean> &lt;bean name=\"juickMaker\" class=\"pojo.JuiceMaker\"> &lt;property name=\"source\" ref=\"source\" /> &lt;/bean> &lt;/beans> 在 【TestSpring】 中添加如下代码： package test; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.JuiceMaker; import pojo.Source; public class TestSpring { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext( new String[]{\"applicationContext.xml\"} ); Source source = (Source) context.getBean(\"source\"); System.out.println(source.getFruit()); System.out.println(source.getSugar()); System.out.println(source.getSize()); JuiceMaker juiceMaker = (JuiceMaker) context.getBean(\"juickMaker\"); System.out.println(juiceMaker.makeJuice()); } } 运行测试代码： 总结： IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，明确描述了“被注入对象依赖 IoC 容器配置依赖对象” IoC 如何实现的最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎： 读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名 使用反射的API，基于类名实例化对应的对象实例 将对象实例，通过构造函数或者 setter，传递给 JuiceMaker 我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！ 引用地址：这里 Spring AOP 简介如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。 AOP 即 Aspect Oriented Program 面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP AOP 的目的AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 AOP 当中的概念： 切入点（Pointcut）在哪些类，哪些方法上切入（where） 通知（Advice）在方法执行的什么实际（when:方法前/方法后/方法前后）做什么（what:增强的功能） 切面（Aspect）切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！ 织入（Weaving）把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成） AOP 编程 在 Packge【service】下创建 【ProductService】类： package service; public class ProductService { public void doSomeService(){ System.out.println(\"doSomeService\"); } } 在 xml 文件中装配该 bean： &lt;bean name=\"productService\" class=\"service.ProductService\" /> 在【TestSpring】中编写测试代码，运行： 在 Packge【aspect】下准备日志切面 【LoggerAspect】类： package aspect; import org.aspectj.lang.ProceedingJoinPoint; public class LoggerAspect { public Object log(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"start log:\" + joinPoint.getSignature().getName()); Object object = joinPoint.proceed(); System.out.println(\"end log:\" + joinPoint.getSignature().getName()); return object; } } 在 xml 文件中声明业务对象和日志切面： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"> &lt;bean name=\"productService\" class=\"service.ProductService\" /> &lt;bean id=\"loggerAspect\" class=\"aspect.LoggerAspect\"/> &lt;!-- 配置AOP --> &lt;aop:config> &lt;!-- where：在哪些地方（包.类.方法）做增加 --> &lt;aop:pointcut id=\"loggerCutpoint\" expression=\"execution(* service.ProductService.*(..)) \"/> &lt;!-- what:做什么增强 --> &lt;aop:aspect id=\"logAspect\" ref=\"loggerAspect\"> &lt;!-- when:在什么时机（方法前/后/前后） --> &lt;aop:around pointcut-ref=\"loggerCutpoint\" method=\"log\"/> &lt;/aop:aspect> &lt;/aop:config> &lt;/beans> 再次运行 TestSpring 中的测试代码，代码并没有改变，但是在业务方法运行之前和运行之后，都分别输出了日志信息： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"Spring","slug":"后端/Java/Spring","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"}],"tags":[{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(9)——学生管理系统(简易版)总结","slug":"初学Java-Web-9-——学生管理系统-简易版-总结","date":"2018-04-09T01:12:00.000Z","updated":"2020-12-09T04:49:09.293Z","comments":true,"path":"2018/04/09/chu-xue-java-web-9-xue-sheng-guan-li-xi-tong-jian-yi-ban-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/09/chu-xue-java-web-9-xue-sheng-guan-li-xi-tong-jian-yi-ban-zong-jie/","excerpt":"项目开始时间：2018年4月8日14:37:47项目完成时间：2018年4月9日10:03:30","text":"项目开始时间：2018年4月8日14:37:47项目完成时间：2018年4月9日10:03:30 技术准备 这个项目是自己用于巩固 J2EE 相关知识的练手项目，非常简单，但是相关的功能却非常实用，所以在这里分享一下 为了完成这个项目，需要掌握如下技术： Java基础知识 前端：HTML, CSS, JAVASCRIPT, JQUERY J2EE：Tomcat, Servlet, JSP, Filter 数据库：MySQL 开发流程项目虽然很简单，很小，但是为了开发的有条不紊，还是按照商业项目的开发来完成。 ① 需求分析首先要确定要做哪些功能 使用数据库来保存数据 能增删改查学生的信息（学号，名称，年龄，性别，出生日期） ② 表结构设计根据需求，那么只需要一个 student 表就能够完成功能了。 创建数据库：student将数据库编码格式设置为 UTF-8 ，便于存取中文数据 DROP DATABASE IF EXISTS student; CREATE DATABASE student DEFAULT CHARACTER SET utf8; 创建学生表：student不用学生学号(studentID)作为主键的原因是：不方便操作，例如在更新数据的时候，同时也要更改学号，那这样的操作怎么办呢？所以我们加了一个 id 用来唯一表示当前数据。 CREATE TABLE student( id int(11) NOT NULL AUTO_INCREMENT, studentID int(11) NOT NULL UNIQUE, name varchar(255) NOT NULL, age int(11) NOT NULL, sex varchar(255) NOT NULL, birthday date DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ③ 原型设计就是设计界面，在商业项目中，这是很重要的一步，我们可以解除界面原型，低成本、高效率的与客户达成需求的一致性。 这个项目一共就分为两个页面： 主页面： 学生编辑页面： ④ 实体类的设计实体类仅仅是对数据库中表的一一映射，同时可能还需要兼顾对业务能力的支持。 在 Packge[bean]下创建 Student 类：package bean; import java.util.Date; public class Student { private int id; // 在数据库中的ID private int studentID; // 学号，跟ID区分开为了方便数据库操作 private String name; // 姓名 private int age; // 年龄 private String sex; // 性别 private Date birthday; // 出生日期 // setter 和 getter (为节约篇幅没列出来)} #### ⑤ DAO 类的设计 DAO，即 Date Access Object，数据库访问对象，就是对数据库相关操作的封装，让其他地方看不到 JDBC 的代码。 首先我们先创建一个数据库操作的工具类： - 在 Packge[util]下创建 DBUtil 类： ```java /** * 数据库工具类，这个类的作用是初始化驱动，并且提供一个getConnection用于获取连接。 */ package util; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class DBUtil { static String ip = &quot;127.0.0.1&quot;; static int port = 3306; static String database = &quot;student&quot;; static String encoding = &quot;UTF-8&quot;; static String loginName = &quot;root&quot;; static String password = &quot;root&quot;; static { try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static Connection getConnection() throws SQLException { String url = String.format(&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;, ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); } public static void main(String[] args) throws SQLException { System.out.println(getConnection()); } } 写工具类的好处： 便于统一维护，降低维护成本 然后是 DAO 类，除了进行典型的 ORM 支持功能之外，也需要提供各种业务方法。 在 Packge[dao]下创建 StudentDAO 类：package dao; import bean.Student;import util.DBUtil; import java.sql.*;import java.util.ArrayList;import java.util.List; public class StudentDAO { public int getTotal() { int total = 0; String sql = &quot;SELECT COUNT(*) FROM student&quot;; try (Connection c = DBUtil.getConnection(); Statement st = c.createStatement()) { ResultSet rs = st.executeQuery(sql); while (rs.next()) { total = rs.getInt(1); } } catch (SQLException e) { e.printStackTrace(); } return total; } public void add(Student student) { String sql = &quot;INSERT INTO student VALUES(NULL,?,?,?,?,?)&quot;; try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) { ps.setInt(1, student.getStudentID()); ps.setString(2, student.getName()); ps.setInt(3, student.getAge()); ps.setString(4, student.getSex()); ps.setDate(5, new java.sql.Date(student.getBirthday().getTime())); ps.execute(); } catch (SQLException e) { e.printStackTrace(); } } public void delete(int id) { String sql = &quot;DELETE FROM student WHERE ID = ?&quot;; try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) { ps.setInt(1, id); ps.execute(); } catch (SQLException e) { e.printStackTrace(); } } public void update(Student student) { String sql = &quot;update student set student_id = ?, name = ?, age = ?, sex = ?, birthday = ? where id = ? &quot;; try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) { ps.setInt(1, student.getStudentID()); ps.setString(2, student.getName()); ps.setInt(3, student.getAge()); ps.setString(4, student.getSex()); ps.setDate(5, new java.sql.Date(student.getBirthday().getTime())); ps.setInt(6, student.getId()); ps.execute(); } catch (SQLException e) { e.printStackTrace(); } } public Student get(int id) { Student student = new Student(); String sql = &quot;SELECT * FROM student WHERE ID = &quot; + id; try (Connection c = DBUtil.getConnection(); Statement st = c.createStatement()) { ResultSet rs = st.executeQuery(sql); if (rs.next()) { int student_id = rs.getInt(&quot;student_id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); String sex = rs.getString(&quot;sex&quot;); Date birthday = rs.getDate(&quot;birthday&quot;); student.setStudentID(student_id); student.setName(name); student.setAge(age); student.setSex(sex); student.setBirthday(birthday); student.setId(id); } } catch (SQLException e) { e.printStackTrace(); } return student; } public List&lt;Student&gt; list() { return list(0, Short.MAX_VALUE); } public List&lt;Student&gt; list(int start, int count) { List&lt;Student&gt; students = new ArrayList&lt;&gt;(); String sql = &quot;SELECT * FROM student ORDER BY student_id desc limit ?,?&quot;; try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) { ps.setInt(1, start); ps.setInt(2, count); ResultSet rs = ps.executeQuery(); while (rs.next()) { Student student = new Student(); int id = rs.getInt(&quot;id&quot;); int studentID = rs.getInt(&quot;student_id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); String sex = rs.getString(&quot;sex&quot;); Date birthday = rs.getDate(&quot;birthday&quot;); student.setId(id); student.setStudentID(studentID); student.setName(name); student.setAge(age); student.setSex(sex); student.setBirthday(birthday); students.add(student); } rs.close(); } catch (SQLException e) { e.printStackTrace(); } return students; }} - 该类中，既提供了**增删改查**这些基本的 **CRUD** 操作 1.增加：`public void add(Student student)` 2.删除：`public void delete(int id)` 3.修改：`public void update(Student student)` 4.查询所有：`public List&lt;Student&gt; list()` - 又提供了一些非 **CRUD** 方法 1.获取总数：`public int getTotal()` 2.根据 id 获取：`public Student get(int id)` #### ⑥ 业务类介绍 作为 J2EE Web 应用，一般都会按照如图所示的设计流程进行： Servlet -&gt; Service（业务类） -&gt; DAO -&gt; database 当浏览器提交请求到 Tomcat Web 服务器的时候，对应的 Servlet 的doGet/doPost 方法会被调用，接着在 Servlet 中调用 Service类，然后在 Service 类中调用DAO类，最后在 DAO 中访问数据库获取相应的数据。 ![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/初学Java-Web(9)——学生管理系统（简易版）总结/7896890-7e224d06d164441a.png) 单本项目没有使用 Service 这一层，原因是在对 DAO 类进行开发中，已经提供了很好的支持业务的方法，没有必要再包括上一层 Service 业务类。 &gt; 参考链接：[这里](http://how2j.cn/k/tmall-j2ee/tmall-j2ee-995/995.html) #### ⑦ 功能开发 需要按照模块之间的依赖关系，顺序开发。 - 首先为项目添加[必要的 jar 包](https://pan.baidu.com/s/19EXWcsi1DUMdUrCXgPeqVg)： jstl.jar mysql-connector-java-5.0.8-bin.jar servlet-api.jar standard.jar 这也是 Web 开发中最基本的 4 个包 #### ——【1.编写 Filter】—— 由于项目中设计表单 POST 方式的提交，所以我们先来编写好相关编码的过滤器，好支持中文的存取 - 在 Packge[filter] 下编写 EncodingFilter 类： ```java package filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebFilter(&quot;/*&quot;) public class EncodingFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; // 设置编码格式为 UTF-8 request.setCharacterEncoding(&quot;UTF-8&quot;); chain.doFilter(request, response); } public void init(FilterConfig config) throws ServletException { } }——【2. 编写 Servlet 】——按照传统的方式，我们项目的业务为增删改查，所以对应四个路径，也就是需要编写四个 Servlet 才可以 AddServlet：package servlet; import bean.Student;import dao.StudentDAO; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; @WebServlet(“/addStudent”)public class AddServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Student student = new Student(); // 直接从表单中获取数据 int studentID = Integer.parseInt(req.getParameter(&quot;studentID&quot;)); String name = req.getParameter(&quot;name&quot;); int age = Integer.parseInt(req.getParameter(&quot;age&quot;)); String sex = req.getParameter(&quot;radio&quot;); Date birthday = null; // String 类型按照 yyyy-MM-dd 的格式转换为 java.util.Date 类 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try { birthday = simpleDateFormat.parse(req.getParameter(&quot;birthday&quot;)); } catch (ParseException e) { e.printStackTrace(); } student.setStudentID(studentID); student.setName(name); student.setAge(age); student.setSex(sex); student.setBirthday(birthday); new StudentDAO().add(student); resp.sendRedirect(&quot;/listStudent&quot;); // 这里可以理解为刷新，重新请求 }} - **DeleteServlet：**package servlet; import dao.StudentDAO; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException; @WebServlet(“/deleteStudent”)public class DeleteServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { int id = Integer.parseInt(req.getParameter(&quot;id&quot;)); new StudentDAO().delete(id); resp.sendRedirect(&quot;/listStudent&quot;); }} - **EditServlet：** ```java package servlet; import bean.Student; import dao.StudentDAO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/editStudent&quot;) public class EditServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { int id = Integer.parseInt(req.getParameter(&quot;id&quot;)); Student student = new StudentDAO().get(id); req.setAttribute(&quot;student&quot;, student); req.getRequestDispatcher(&quot;/editStudent.jsp&quot;).forward(req, resp); } } ListServlet：package servlet; import bean.Student;import dao.StudentDAO;import util.Page; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List; @WebServlet(“/listStudent”)public class ListServlet extends HttpServlet { private StudentDAO studentDAO = new StudentDAO(); protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取分页参数 int start = 0; int count = 10; try { start = Integer.parseInt(req.getParameter(&quot;page.start&quot;)); count = Integer.parseInt(req.getParameter(&quot;page.count&quot;)); } catch (Exception e) { } Page page = new Page(start, count); List&lt;Student&gt; students = studentDAO.list(page.getStart(), page.getCount()); int total = studentDAO.getTotal(); page.setTotal(total); req.setAttribute(&quot;students&quot;, students); req.setAttribute(&quot;page&quot;, page); req.getRequestDispatcher(&quot;/listStudent.jsp&quot;).forward(req, resp); }} - **UpdateServlet：** ```java package servlet; import bean.Student; import dao.StudentDAO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; @WebServlet(&quot;/updateStudent&quot;) public class UpdateServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Student student = new Student(); int id = Integer.parseInt(req.getParameter(&quot;id&quot;)); int studentID = Integer.parseInt(req.getParameter(&quot;studentID&quot;)); String name = req.getParameter(&quot;name&quot;); int age = Integer.parseInt(req.getParameter(&quot;age&quot;)); String sex = req.getParameter(&quot;radio&quot;); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date birthday = null; try { birthday = simpleDateFormat.parse(req.getParameter(&quot;birthday&quot;)); } catch (ParseException e) { e.printStackTrace(); } student.setId(id); student.setStudentID(studentID); student.setName(name); student.setAge(age); student.setSex(sex); student.setBirthday(birthday); new StudentDAO().update(student); resp.sendRedirect(&quot;/listStudent&quot;); } }——【3. JSP 的编写】——我们把默认的 index.jsp 修改成如下代码： 引入 JQ 和 Bootstrap为了简化操作，引入了 JQuery 和 Bootstrap 编写 listStudent.jsp其实主要还是利用 Bootstrap 编写好整个页面，我写的时候也是对照这里写的 &lt;!DOCTYPE html&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;%-- 引入JQ和Bootstrap --%&gt; &lt;script src=&quot;js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;学生管理页面 - 首页&lt;/title&gt; &lt;script&gt; $(function () { $(&quot;ul.pagination li.disabled a&quot;).click(function () { return false; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;listDIV&quot;&gt; &lt;table class=&quot;table table-striped table-bordered table-hover table-condensed&quot;&gt; &lt;caption&gt;学生列表 - 共${page.total}人&lt;/caption&gt; &lt;thead&gt; &lt;tr class=&quot;success&quot;&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;出生日期&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=&quot;${students}&quot; var=&quot;s&quot; varStatus=&quot;status&quot;&gt; &lt;tr&gt; &lt;td&gt;${s.studentID}&lt;/td&gt; &lt;td&gt;${s.name}&lt;/td&gt; &lt;td&gt;${s.age}&lt;/td&gt; &lt;td&gt;${s.sex}&lt;/td&gt; &lt;td&gt;${s.birthday}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/editStudent?id=${s.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-edit&quot;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/deleteStudent?id=${s.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;nav class=&quot;pageDIV&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt; &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt; &gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;li &lt;c:if test=&quot;${!page.hasNext}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt; &lt;span&gt;›&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasNext}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.last}&quot;&gt; &lt;span&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;addDIV&quot;&gt; &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;增加学生&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;/addStudent&quot; role=&quot;form&quot;&gt; &lt;table class=&quot;addTable&quot;&gt; &lt;tr&gt; &lt;td&gt;学号：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;studentID&quot; id=&quot;studentID&quot; placeholder=&quot;请在这里输入学号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请在这里输入名字&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; placeholder=&quot;请在这里输入年龄&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;radio&quot; value=&quot;男&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;radio&quot; value=&quot;女&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请在这里输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;submitTR&quot;&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;提 交&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; eidtStudent.jsp编辑表单对照着首页的增加表单稍微改一改参数就好了&lt;!DOCTYPE html&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; %&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%-- 引入JQ和Bootstrap --%&gt; &lt;script src=&quot;js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;学生管理页面 - 编辑页面&lt;/title&gt; &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;编辑学生&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;/updateStudent&quot; role=&quot;form&quot;&gt; &lt;table class=&quot;editTable&quot;&gt; &lt;tr&gt; &lt;td&gt;学号：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;studentID&quot; id=&quot;studentID&quot; value=&quot;${student.studentID}&quot; placeholder=&quot;请在这里输入学号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;姓名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; value=&quot;${student.name}&quot; placeholder=&quot;请在这里输入名字&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot; value=&quot;${student.age}&quot; placeholder=&quot;请在这里输入年龄&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;radio&quot; value=&quot;男&quot;&gt; 男 &lt;input type=&quot;radio&quot; class=&quot;radio radio-inline&quot; name=&quot;radio&quot; value=&quot;女&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; value=&quot;${student.birthday}&quot; placeholder=&quot;请在这里输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;submitTR&quot;&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${student.id}&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success&quot;&gt;提 交&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; ``` style.css 文件：body { padding-top: 60px; } div.listDIV { width: 600px; margin: 0 auto;} div.editDIV { width: 400px; margin: 0 auto;} nav.pageDIV { text-align: center;} div.addDIV { width: 300px; margin: 0 auto;} table.addTable { width: 100%; padding: 5px;} table.addTable td { padding: 5px;} table.editTable { width: 100%; padding: 5px;} table.editTable td { padding: 5px;} #### ——【4. 项目细节】—— - 项目的整理结构： ![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/初学Java-Web(9)——学生管理系统（简易版）总结/7896890-e95ffeefc9bfbeca.png) #### 分页功能 - 首页在 Packge[util] 下创建一个 Page 工具类： ```java package util; public class Page { int start; // 开始数据 int count; // 每一页的数量 int total; // 总共的数据量 public Page(int start, int count) { super(); this.start = start; this.count = count; } public boolean isHasPreviouse(){ if(start==0) return false; return true; } public boolean isHasNext(){ if(start==getLast()) return false; return true; } public int getTotalPage(){ int totalPage; // 假设总数是50，是能够被5整除的，那么就有10页 if (0 == total % count) totalPage = total /count; // 假设总数是51，不能够被5整除的，那么就有11页 else totalPage = total / count + 1; if(0==totalPage) totalPage = 1; return totalPage; } public int getLast(){ int last; // 假设总数是50，是能够被5整除的，那么最后一页的开始就是40 if (0 == total % count) last = total - count; // 假设总数是51，不能够被5整除的，那么最后一页的开始就是50 else last = total - total % count; last = last&lt;0?0:last; return last; } // 各种 setter 和 getter } totalPage 是计算得来的数，用来表示页码一共的数量 在首页显示的 StudentList 用 page 的参数来获取： List&lt;Student&gt; students = studentDAO.list(page.getStart(), page.getCount());并且在 DAO 类中用 LIMIT 关键字： String sql = &quot;SELECT * FROM student ORDER BY student_id desc limit ?,?&quot;; 第一个参数为 start，第二个参数为 count这样就能根据分页的信息来获取到响应的数据 编写分页栏： 1.写好头和尾 &lt;nav class=&quot;pageDIV&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; ..... &lt;/ul&gt; &lt;/nav&gt;2.写好« ‹这两个功能按钮使用 &lt;c:if&gt;标签来增加边界判断，如果没有前面的页码了则设置为disable状态 &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=0&quot;&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;再通过 JavaScrip 代码来完成禁用功能： &lt;script&gt; $(function () { $(&quot;ul.pagination li.disabled a&quot;).click(function () { return false; }); }); &lt;/script&gt;3.完成中间页码的编写从 0 循环到 page.totalPage - 1 ，varStatus 相当于是循环变量 status.count 是从1开始遍历 status.index 是从0开始遍历 要求：显示当前页码的前两个和后两个就可，例如当前页码为3的时候，就显示 1 2 3(当前页) 4 5 的页码 理解测试条件： 10 &lt;= 当前页*每一页显示的数目 - 当前页开始的数据编号 &lt;= 30 只要理解了这个判断条件，其他的就都好理解了 &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt; &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt; &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt; &lt;a href=&quot;?page.start=${status.index*page.count}&quot; &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt; &gt;${status.count}&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; 4.在 Servlet 中获取参数 // 获取分页参数 int start = 0; int count = 10; try { start = Integer.parseInt(req.getParameter(&quot;page.start&quot;)); count = Integer.parseInt(req.getParameter(&quot;page.count&quot;)); } catch (Exception e) { } .... // 共享 page 数据 req.setAttribute(&quot;page&quot;, page);Date 转换的问题 /** * Date类型转为指定格式的String类型 * * @param source * @param pattern * @return */ public static String DateToString(Date source, String pattern) { simpleDateFormat = new SimpleDateFormat(pattern); return simpleDateFormat.format(source); } /** * * 字符串转换为对应日期 * * @param source * @param pattern * @return */ public static Date stringToDate(String source, String pattern) { simpleDateFormat = new SimpleDateFormat(pattern); Date date = null; try { date = simpleDateFormat.parse(source); } catch (Exception e) { } return date; } 项目总结这一个项目实在有些太简单了，可能最需要理解的一个功能就属于【分页功能】了吧 不过还是借助这个项目，进一步巩固了 J2EE 开发的相关知识，也对开发的流程愈发熟悉，整个项目编写时间不超过 8 个小时，对于我自己来说，不算快，但还算比较顺畅的 需要改进的地方： 登录验证本项目没有增加登录验证，可以增加一个登录页面并结合 session 来完成验证 代码重构本项目仅仅完成的是一个学生表的增删改查，却有以下的五个 Servlet ： 如果项目大起来，那可想而知，Servlet 有多臃肿，维护成本有多高 改进方法：用一个 StudentServlet 代替 具体做法：使用 Filter + Servlet 完成 ① 首先编写一个过滤所有地址的 Filter，并解析地址栏的地址，提取出其中的方法传递给 StudentServlet （这个时候需要统一的地址，如：student_list、student_edit、student_delete、student_update） request.setAttribute(&quot;method&quot;, method); ② 在 Servlet 中获取 method 方法，并调用 // 获取到对应的方法 String method = (String) request.getAttribute(&quot;method&quot;); // 对 method 作判断，调用对应的方法 没有对输入的数据的正确性进行验证这显然会导致许多问题，可以通过 js 代码来完成验证 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(8)——过滤器和监听器","slug":"初学Java-Web-8-——过滤器和监听器","date":"2018-04-08T01:11:00.000Z","updated":"2020-12-09T04:49:06.515Z","comments":true,"path":"2018/04/08/chu-xue-java-web-8-guo-lu-qi-he-jian-ting-qi/","link":"","permalink":"http://www.wmyskxz.com/2018/04/08/chu-xue-java-web-8-guo-lu-qi-he-jian-ting-qi/","excerpt":"","text":"什么是过滤器过滤器就是 Servlet 的高级特性之一，就是一个具有拦截/过滤功能的一个东西，在生活中过滤器可以是香烟滤嘴，滤纸，净水器，空气净化器等，在 Web 中仅仅是一个实现了 Filter 接口的 Java 类而已。 特点：双向，拦截请求，拦截响应 作用：过滤器可以对所有的请求或者响应做拦截操作 为什么在 Web 开发中需要用到过滤器？ 问题：为什么非得使用过滤器，我直接在 Servlet 中作判断不行吗？ 开发遵循的原则： 1.DRY原则（Don’t Reeat Yourself，不要重复你自己）：重复，意味着维护的成本很高。2.责任分离原则：谁擅长什么功能就做什么功能，Servlet 擅长的是逻辑而不是处理请求 举一个实际的例子：（处理 POST 请求中文编码的问题） Web 中过滤器的作用： 1.可以在请求资源之前设置请求的编码2.可以进行登录校验3.可以进行请求参数的内容的过滤4.数据压缩 / 数据加密 / 数据格式的转换5.可以设置浏览器相关的数据 Filter 的开发和使用对应于 Servlet 的开发步骤： 定义一个类，实现 Filter 接口 在 doFilter() 方法中对请求和响应进行过滤 在 web.xml 文件中进行 Filter 的配置（告诉服务器来管理当前的 Filter）&lt;!-- web.xml --&gt; &lt;filter&gt; &lt;filter-name&gt;filter的名称&lt;/filter-name&gt; &lt;filter-class&gt;filter类的全限定名&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;指定对哪一个filter做的映射&lt;/filter-name&gt; &lt;url-pattern&gt;指定对哪些资源进行过滤&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 注意：此时 &lt;url-pattern&gt; 表示对哪些资源做过滤/拦截。例如： /hello.jsp当前 Filter 就仅仅只对 hello.jsp 资源做拦截. /index当前 Filter 就仅仅只对 /index 资源做拦截. /*当前 Filter 就对所有资源做拦截.访问任意的资源,都会先进入该过滤器器. /system/*当前 Filter 就对以 /system/ 打头的资源做拦截.如/system , /system/a, /system/a/b/c, /systema Filter 映射细节 在启动服务器的时候，就创建了 Filter 对象并执行了初始化方法 init()。Filter 先于 Servlet 存在于服务端 在应用中允许存在多个 Filter ，到底哪一个 Filter 先执行哪一个后执行，这取决于在 web.xml 中定义的先后次序 （如果使用注解配置，则 Filter 的执行顺序由 Filter 的类名的字母的顺序来决定，如 AFilter 和 BFilter，则先执行 AFilter） 一个 Filter 可以配置多个 &lt;url-pattern&gt; 也可以对指定的 Servlet 做过滤（注解通过 servletNames 指定，配置由 &lt;servlet-name&gt; 指定） 默认情况下，Filter 只对新的请求做拦截，如果是请求转发，则不会过滤。 &lt;dispatcher&gt;配置项指定了 Filter 的过滤时间： REQUEST：只对请求做过滤，默认选项，如果有该配置项则必须显式写明 FORWARD：只对请求转发(forword)方式做过滤 ERROR：只对跳转到全局的错误页面做过滤 INCLUDE：只对请求包含(include)方式做过滤 对应的注解属性为:dispatcherTypes 过滤器实例 戳这里 监听器 作用： 1.监听 web 应用的创建和销毁2.attribute发生的变化。 web 应用：即ServletContext对象(jsp的隐式对象application) 除了对web应用的监听外，还能监听session和request的生命周期，以及他们的attribute发生的变化。 了解详情戳这里 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(7)——文件的上传和下载","slug":"初学Java-Web-7-——文件的上传和下载","date":"2018-04-08T01:08:00.000Z","updated":"2020-12-09T04:49:03.309Z","comments":true,"path":"2018/04/08/chu-xue-java-web-7-wen-jian-de-shang-chuan-he-xia-zai/","link":"","permalink":"http://www.wmyskxz.com/2018/04/08/chu-xue-java-web-7-wen-jian-de-shang-chuan-he-xia-zai/","excerpt":"","text":"文件上传文件上传前的准备 在表单中必须有一个上传的控件&lt;input type=&quot;file&quot; name=&quot;testImg&quot;/&gt; 因为 GET 方式有请求大小的限制，所以表单的提交方式必须是 POST&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt; 表单默认的编码方式为 application/x-www-form-urlencoded ，应该修改为 multipart/form-data ，以二进制的形式进行数据的传输&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 注意：此时 Servlet 中就不能再使用 request对象.getParameter(String name) 来获取请求参数 上传组件要实现文件的上传，需要基于以下两种组件的一种： Apache FileUpload 组件【操作比较复杂】 SmartUpload 组件【操作比较简单，但存在一些问题】 基于 FileUpload 组件使用基于Apache FileUpload上传组件实现文件的上传，步骤： 将必要的 jar 包导入到项目中commons-fileupload-1.2.2.jarcommons-io-1.4.jar 简单写好 upload.jsp 上传页面： &lt;!DOCTYPE html> &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*\" %> &lt;html> &lt;head> &lt;title>文件的上传和下载&lt;/title> &lt;/head> &lt;body> 文件上传： &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"> &lt;input type=\"file\" name=\"testImg\"/> &lt;br> &lt;input type=\"submit\"/> &lt;/form> &lt;/body> &lt;/html> 编写 UploadServlet 处理相关请求： package servlet; import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileItemFactory; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.IOException; import java.util.List; @WebServlet(\"/upload\") public class UploadServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头 boolean isMultipart = ServletFileUpload.isMultipartContent(req); // 如果不满足要求就立即结束对该请求的处理 if (!isMultipart) { return; } try { // FileItem 是表单中的每一个元素的封装 // 创建一个 FileItem 的工厂类 FileItemFactory factory = new DiskFileItemFactory(); // 创建一个文件上传处理器（装饰设计模式） ServletFileUpload upload = new ServletFileUpload(factory); // 解析请求 List&lt;FileItem> items = upload.parseRequest(req); for (FileItem fileItem : items) { // 判断空间是否是普通控件 if (fileItem.isFormField()) { // 普通控件 } else { // 上传控件 // 将上传的文件保存到服务器 fileItem.write(new File(\"C:/\", \"testImg.jpg\")); } } } catch (Exception e) { e.printStackTrace(); } } } 文件上传的细节上面已经能实现简单的文件上传功能了，但文件上传有很多需要注意的地方。 缓存大小和临时目录在上传文件的时候,如果文件过大,而且是将文件放在缓存中,就可能造成内存溢出默认的缓存大小为 10 kb，临时目录的默认值为 tomcat/temp 解决方案：将操作缓存大小的文件放在服务器的磁盘(临时目录)中,在文件的大小超过设定的缓存大小的时候就会使用到临时目录// 设置缓存大小 500kb factory.setSizeThreshold(1024*500); // 设置临时目录 factory.setRepository(new File(\"C:/\")); 通常不需要设置 另一个问题是：如果用户 A 上传了一个文件名叫xxx，用户 B 也上传了一个文件名叫 xxx，那么此时用户 B 的文件会把用户 A 的文件给覆盖掉。 文件名称的处理相同文件名称的文件，后面的文件会把前面的文件覆盖掉 解决方案：使用UUID来生成一个随机的而且不重复字符串作为文件的名称，获取真实文件的后缀名需要用到 FilenameUtils 这个工具类 语法： String fileName = UUID.randomUUID().toString()+\".\"+FilenameUtils.getExtension(fileItem.getName()); 文件类型的约束上传文件的类型应该需要做一些约束的，比如在上传头像的时候就只允许上传图片，其他类型的文件都不应该允许上传，并且如果类型不正确的时候，应该给用户一个错误的提示。 jsp 文件增加显示错误提示信息： 我们给我们的 jsp 开头增加一个 &lt;span&gt; 来显示错误信息 &lt;!DOCTYPE html> &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*\" %> &lt;html> &lt;head> &lt;title>文件的上传和下载&lt;/title> &lt;/head> &lt;body> 文件上传：&lt;span>${errorMsg}&lt;/span> &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"> &lt;input type=\"file\" name=\"testImg\"/> &lt;br> &lt;input type=\"submit\"/> &lt;/form> &lt;/body> &lt;/html> 判断上传文件类型：限制文件类型那么就需要对文件类型进行判断 语法：String contentType = fileItem.getContentType(); Servlet 源码：package servlet; import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileItemFactory;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.apache.commons.io.FilenameUtils; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.List;import java.util.UUID; @WebServlet(“/upload”)public class UploadServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 验证请求是否满足要求（post 请求 / enctype 是否以multipart打头 boolean isMultipart = ServletFileUpload.isMultipartContent(req); // 如果不满足要求就立即结束对该请求的处理 if (!isMultipart) { return; } try { // FileItem 是表单中的每一个元素的封装 // 创建一个 FileItem 的工厂类 FileItemFactory factory = new DiskFileItemFactory(); // 创建一个文件上传处理器（装饰设计模式） ServletFileUpload upload = new ServletFileUpload(factory); // 解析请求 List&lt;FileItem&gt; items = upload.parseRequest(req); for (FileItem fileItem : items) { // 判断空间是否是普通控件 if (fileItem.isFormField()) { // 普通控件 } else { // 上传控件 String contentType = fileItem.getContentType(); if (!contentType.startsWith(&quot;image/&quot;)) { // 实现简单的错误提示 req.setAttribute(&quot;errorMsg&quot;, &quot;亲，您上传的文件格式不正确，请重新上传！&quot;); req.getRequestDispatcher(&quot;upload.jsp&quot;).forward(req, resp); return; // 如果不是图片类型则不再对请求进行处理 } // 随机命名文件名 String fileName = UUID.randomUUID().toString() + &quot;.&quot; + FilenameUtils.getExtension(fileItem.getName()); // 将上传的文件保存到服务器 fileItem.write(new File(&quot;C:/&quot;, fileName)); } } } catch (Exception e) { e.printStackTrace(); } }} #### 解决中文乱码问题 - 解决中文文件名乱码（事实上我在本地测试并没有出现乱码），得到解析器以后，就**直接设置解析器的编码为UTF-8就行了** fileUpload.setHeaderEncoding(“UTF-8”); - 解决表单数据乱码，在获取表单值的时候，按照UTF-8编码来获取String value = fileItem.getString(“UTF-8”); #### 文件大小约束 - 单个文件数据的大小约束 即整个表单之中只有一个上传控件 - 语法：`upload.setFileSizeMax(1024 * 500); // 单个文件不能超过500 kb` - 一次请求数据的大小约束 限制整个请求之中的数据大小 - 语法：`upload.setSizeMax(1024 * 750); // 整个请求文件大小不能超过 750 kb` #### 使用 Map 封装请求信息 上面提到，我们已经无法用 request对象正常获取到参数，那么我们究竟应该怎么办呢？ &gt; - 使用 Map 封装一下就好了，等到要用的时候再从 Map 中取出 ![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/初学Java-Web(7)——文件的上传和下载/7896890-4e09be236b365217.png) --- ## SmartUpload 上面已经基于 FileUpload 实现了文件的上传，事实上也没有想象中那么复杂，让我们来看看 SmartUpload 要使用SmartUpload组件，就需要导入smartupload.jar开发包 #### 快速入门 ``` java //实例化组件 SmartUpload smartUpload = new SmartUpload(); //初始化上传操作 smartUpload.initialize(this.getServletConfig(), request, response); try { //上传准备 smartUpload.upload(); //对于普通数据，单纯到request对象是无法获取得到提交参数的。也是需要依赖smartUpload String password = smartUpload.getRequest().getParameter(&quot;password&quot;); System.out.println(password); //上传到uploadFile文件夹中 smartUpload.save(&quot;uploadFile&quot;); } catch (SmartUploadException e) { e.printStackTrace(); } 摘自：这里 上面链接提到 SmartUpload 组件在解决中文乱码中有一些小问题，我没有测试过，但我觉得自己写一个 FileUpload 工具类已经足够使用了 文件下载 写一个简单的 jsp 页面： 在 WEB-INF 下创建 download 文件夹，里面放入一个 test.zip 编写 Servlet 处理相关请求 package servlet; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.IOException; import java.net.URLEncoder; import java.nio.file.Files; import java.nio.file.Paths; @WebServlet(\"/download\") public class DownloadServlet extends HttpServlet { protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 设置响应数据的 MIME 类型 resp.setContentType(\"application/x-msdownload\"); // 获取文件名称 String fileName = req.getParameter(\"fileName\"); // 判断浏览器是否是 IE String userAgent = req.getHeader(\"User-Agent\"); if (userAgent.contains(\"MSIE\")) { // IE // 设置文件的名称 resp.setHeader(\"Content-Disposition\", \"attachment; fileName=\" + URLEncoder.encode(fileName, \"UTF-8\")); } else { // 非IE resp.setHeader(\"Content-Disposition\", \"attachment; fileName=\" + new String(fileName.getBytes(\"UTF-8\"), \"ISO-8859-1\")); } // 获取文件所在的路径 String path = req.getServletContext().getRealPath(\"/WEB-INF/download\"); // 获取指定的文件对象 File f = new File(path, fileName); ServletOutputStream out = resp.getOutputStream(); // 将文件复制到输出流中，响应给浏览器 Files.copy(Paths.get(f.getAbsolutePath()), out); } } 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(6)——JSP学习总结","slug":"初学Java-Web-6-——JSP学习总结","date":"2018-04-07T01:03:00.000Z","updated":"2020-12-09T04:49:00.101Z","comments":true,"path":"2018/04/07/chu-xue-java-web-6-jsp-xue-xi-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/07/chu-xue-java-web-6-jsp-xue-xi-zong-jie/","excerpt":"","text":"为什么要学习 JSPServlet 的短板：Servlet 的出现，是为了解决动态输出网页的问题。 虽然这样做目的能达到，但是存在一些缺陷： 在 Servlet 输出网页片段非常恶心（可读性差，维护起来也很麻烦） 没有体现责任分离的原则（做自己擅长做的事） 责任分离 Servlet 能够很好地组织业务逻辑代码，但是在 Java 源文件中通过字符串拼接的方式生成动态 HTML 内容会导致代码维护困难、可读性差 JSP 虽然规避了 Servlet 在生成 HTML 内容方面的劣势，但是在 HTML 中混入大量、复杂的业务逻辑同样也是不可取的 参考：知乎@David 注意：JSP实质上就是一个Servlet MVC 模式既然 Servlet 和 JSP 都有各自的优势和短板，那么为什么不结合起来扬长避短呢？答案是肯定的——MVC(Model-View-Controller)模式非常适合解决这一问题。 MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： Controller——负责转发请求，对请求进行处理 View——负责界面显示 Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示： 1.Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发）2.Controller(Servlet)调用核心业务逻辑——Model部分，获得结果3.Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容4.动态生成的HTML内容返回到浏览器显示 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。 参考：知乎@David JSP 的执行原理 总结：当访问一个 JSP 页面时，该页面请求将会讲给服务器中的 JSP 引擎去处理，它负责解释和执行 JSP 页面，每个 JSP 页面在第一次被访问时，JSP 引擎就会将它翻译成一个继承自 org.apache.jasper.runtime.HttpJspBase类的 Servlet 源程序，接着再编译成 class 类文件，再由 Web 容器像调用普通 Servlet 程序一样的方式来装载和解释执行这个由 JSP 页面翻译成的 Servlet 程序。 详细资料在这里，感兴趣的戳我 JSP 的语法像这样冗杂繁复的知识点，直接给两个好一点的链接记下就好了：1.W3Cschool2.菜鸟教程 JSP 三大指令 特点：并不向客户端产生任何输出，指令在 JSP 整个文件范围内有效，并且为翻译阶段提供了全局信息 指令的语法格式： &lt;%@ 指令名称 属性名=属性值 属性名=属性值%&gt; ——【page指令】—— 作用：定义 JSP 页面的各种属性 属性： 1.language：指示JSP页面中使用脚本语言。默认值java，目前只支持java。2.extends：指示 JSP 对应的 Servlet 类的父类。不要修改。3.*import：导入JSP中的Java脚本使用到的类或包。（如同Java中的import语句）JSP 引擎自动导入以下包中的类：javax.servlet.*javax.servlet.http.*javax.servlet.jsp.*注意：一个import属性可以导入多个包，用逗号分隔。4.*sessioin：指示JSP页面是否创建 HttpSession 对象。默认值是true，创建5.*buffer：指示 JSP 用的输出流的缓存大小.默认值是8Kb。6.autoFlush：自动刷新输出流的缓存。7.isThreadSafe：指示页面是否是线程安全的（过时的）。默认是true。true：不安全的。false：安全的。指示 JSP 对应的 Servlet 实现 SingleThreadModel 接口。8.*errorPage:指示当前页面出错后转向（转发）的页面。 &gt; 配置全局错误提示页面： &gt; web.xml 文件中添加： &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt; &lt;/error-page&gt;9.*isErrorPage:指示当前页面是否产生 Exception 对象。10.*contentType：指定当前页面的 MIME 类型。作用与 Servlet 中的response.setContentType() 作用完全一致11.*pageEncoding：通知引擎读取 JSP 时采用的编码（因为要翻译）12.*isELIgnored：是否忽略EL表达式。${1+1}。默认值是false。 page 指令最简单的使用方式：&lt;%@ page pageEncoding=&quot;UTF-8&quot;%&gt; ——【include】—— 作用：包含其他的组件 语法：&lt;%@include file=&quot;&quot;%&gt;file 指定要包含的目标组件。路径如果以 “/“（当前应用）就是绝对路径。 原理：把目标组件的内容加到源组件中，输出结果。 静态包含和动态包含的区别： 静态包含：&lt;%@include file=&quot;被包含的页面的路径&quot;%&gt; 包含的时机：在 JSP 文件被翻译的时候合并在一起最终会被翻译成一个 class 文件 动态包含：&lt;jsp:include page=&quot;被包含页面的路径&quot;&gt;&lt;/jsp:include&gt; 包含的时机：在运行阶段合并代码最终将得到两个 class 文件 总结：在实际开发中，能用静的就别用动的 ——【taglib】—— 作用：引入外部的标签 语法：&lt;%@taglib uri=&quot;标签名称空间&quot; prefix=&quot;前缀&quot;%&gt;例如：&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; JSP 九大内置对象内置对象：JSP 中事先创建好的对象，可以直接拿来使用 名称 类型 描述 pageContext PageContext 表示当前的JSP对象 request HttpServletRequest 表示一次请求对象 session HttpSession 表示一次会话对象,session=”true” application ServletContext 表示当前应用对象 response HttpServletResponse 表示一次响应对象 exception Throwable 表示异常对象,isErrorPage=”true” config ServletConfig 表示当前JSP的配置对象 out JspWriter 表示一个输出流对象 page Object 表示当前页面 JSP 四大作用域 名称 类型 描述 pageContext PageContext 表示当前的JSP对象 request HttpServletRequest 表示一次请求对象 session HttpSession 表示一次会话对象,session=”true” application ServletContext 表示当前应用对象 EL（表达式语言） 需求：从作用域中获取共享数据,如果没有对应的数据,返回空字符串在PageContext中提供了下面的方法:abstract Object findAttribute(String name)来获取共享数据，从page，request，session，application作用域中按顺序搜索,如果找到立即返回,反之,返回null 所以我们可以这样来完成要求：&lt;%=pageContext.findAttribute(&quot;msg&quot;)==null?&quot;&quot;:pageContext.findAttribute(&quot;msg&quot;) %&gt;这样的代码虽然能够完成需求，但是总的来说：太麻烦！ 如果我们使用 EL 表达式，该如何实现呢？${msg}等价于&lt;%=pageContext.findAttribute(&quot;msg&quot;)==null?&quot;&quot;:pageContext.findAttribute(&quot;msg&quot;) %&gt;这样看起来就简单多了！ EL的特点： 1.从作用域中获取共享数据2.从page,request,session,application作用域中按顺序搜索3.如果共享数据为null,就输出空字符串（这是EL最重要的特点） 使用EL表达式从指定的作用域中获取共享数据: 使用EL表达式访问对象的属性的两种方式： 1.${对象.属性名} :通常使用这种方式,属性名比较规范2.${对象[“属性名”]} :当属性名不规范的时候使用这种方式,比如:name-age 使用El表达式获取应用的上下文路径：在EL表达式中有一个隐含的对象pageContext而在pageContext中有一个request属性,在request对象中有一个contextPath属性,那么获取contextPage的方法:${pageContext.request.contextPath}在 Tomcat 7 以后,EL表达式不仅支持属性的访问,而且还支持访问方法${pageContext.getRequest().getContextPath()} empty 运算符：empty 运算符主要用来判断值是否为空（NULL,空字符串，空集合），返回 true / false JSTL 作用：消除 JSP 中的 Java 代码 在 JSP 中使用 JSTL 的步骤： 1.引入入jar包：在 Tomcat 中的实例项目 examples 中找到对应的两个jar包standard-1.1.2.jar ，jstl-1.1.2.jar2.在对应的 JSP 页面中引入要使用的标签库,比如引入核心标签库&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; 下面列出 JSTL 主要提供的 5 大类标签库（搬自菜鸟教程），先对这些标签初步有一个印象，然后下面给一些常用的标签的一些用法。 JSTL 核心标签 核心标签是最常用的JSTL标签。引用核心标签库的语法如下： &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 标签 描述 &lt;c:out&gt; 用于在JSP中显示数据，就像&lt;%= … &gt; &lt;c:set&gt; 用于保存数据 &lt;c:remove&gt; 用于删除数据 &lt;c:catch&gt; 用来处理产生错误的异常状况，并且将错误信息储存起来 &lt;c:if&gt; 与我们在一般程序中用的if一样 &lt;c:choose&gt; 本身只当做&lt;c:when&gt;和&lt;c:otherwise&gt;的父标签 &lt;c:when&gt; &lt;c:choose&gt;的子标签，用来判断条件是否成立 &lt;c:otherwise&gt; &lt;c:choose&gt;的子标签，接在&lt;c:when&gt;标签后，当&lt;c:when&gt;标签判断为false时被执行 &lt;c:import&gt; 检索一个绝对或相对 URL，然后将其内容暴露给页面 &lt;c:forEach&gt; 基础迭代标签，接受多种集合类型 &lt;c:forTokens&gt; 根据指定的分隔符来分隔内容并迭代输出 &lt;c:param&gt; 用来给包含或重定向的页面传递参数 &lt;c:redirect&gt; 重定向至一个新的URL. &lt;c:url&gt; 使用可选的查询参数来创造一个URL #### 格式化标签 JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下： ``` &lt;%@ taglib prefix=”fmt” uri=”http://java.sun.com/jsp/jstl/fmt&quot; %&gt; ``` 标签 描述 :- :- fmt:formatNumber 使用指定的格式或精度格式化数字 fmt:parseNumber 解析一个代表着数字，货币或百分比的字符串 fmt:formatDate 使用指定的风格或模式格式化日期和时间 fmt:parseDate 解析一个代表着日期或时间的字符串 fmt:bundle 绑定资源 fmt:setLocale 指定地区 fmt:setBundle 绑定资源 fmt:timeZone 指定时区 fmt:setTimeZone 指定时区 fmt:message 显示资源配置文件信息 fmt:requestEncoding 设置request的字符编码 SQL标签JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下： &lt;%@ taglib prefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt; 标签 描述 sql:setDataSource 指定数据源 sql:query 运行SQL查询语句 sql:update 运行SQL更新语句 sql:param 将SQL语句中的参数设为指定值 sql:dateParam 将SQL语句中的日期参数设为指定的java.util.Date 对象值 sql:transaction 在共享数据库连接中提供嵌套的数据库行为元素，将所有语句以一个事务的形式来运行 XML 标签JSTL XML标签库提供了创建和操作XML文档的标签。引用XML标签库的语法如下： &lt;%@ taglib prefix=&quot;x&quot; uri=&quot;http://java.sun.com/jsp/jstl/xml&quot; %&gt;在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的&lt;Tomcat 安装目录&gt;\\lib下: XercesImpl.jar 下载地址： http://www.apache.org/dist/xerces/j/ xalan.jar 下载地址： http://xml.apache.org/xalan-j/index.html 标签 描述 &lt;x:out&gt; 与&lt;%= … &gt;,类似，不过只用于XPath表达式 &lt;x:parse&gt; 解析 XML 数据 &lt;x:set&gt; 设置XPath表达式 &lt;x:if&gt; 判断XPath表达式，若为真，则执行本体中的内容，否则跳过本体 &lt;x:forEach&gt; 迭代XML文档中的节点 &lt;x:choose&gt; &lt;x:when&gt;和&lt;x:otherwise&gt;的父标签 &lt;x:when&gt; &lt;x:choose&gt;的子标签，用来进行条件判断 &lt;x:otherwise&gt; &lt;x:choose&gt;的子标签，当&lt;x:when&gt;判断为false时被执行 &lt;x:transform&gt; 将XSL转换应用在XML文档中 &lt;x:param&gt; 与&lt;x:transform&gt;共同使用，用于设置XSL样式表 JSTL函数JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下： &lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; 函数 描述 fn:contains() 测试输入的字符串是否包含指定的子串 fn:containsIgnoreCase() 测试输入的字符串是否包含指定的子串，大小写不敏感 fn:endsWith() 测试输入的字符串是否以指定的后缀结尾 fn:escapeXml() 跳过可以作为XML标记的字符 fn:indexOf() 返回指定字符串在输入字符串中出现的位置 fn:join() 将数组中的元素合成一个字符串然后输出 fn:length() 返回字符串长度 fn:replace() 将输入字符串中指定的位置替换为指定的字符串然后返回 fn:split() 将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回 fn:startsWith() 测试输入字符串是否以指定的前缀开始 fn:substring() 返回字符串的子集 fn:substringAfter() 返回字符串在指定子串之后的子集 fn:substringBefore() 返回字符串在指定子串之前的子集 fn:toLowerCase() 将字符串中的字符转为小写 fn:toUpperCase() 将字符串中的字符转为大写 fn:trim() 移除首位的空白符 JSTL 中常用的标签1.逻辑判断标签(if,choose-when-otherwise) &lt;c:if&gt; 标签 语法格式&lt;c:if test=&quot;&lt;boolean&gt;&quot; var=&quot;&lt;string&gt;&quot; scope=&quot;&lt;string&gt;&quot;&gt; ... &lt;/c:if&gt; 属性&lt;c:if&gt;标签有如下属性： 属性 描述 是否必要 默认值 test 条件 是 无 var 用于存储条件结果的变量 否 无 scope var属性的作用域 否 page - 演示实例： ``` &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8”%&gt; &lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core&quot; prefix=”c” %&gt; c:if 标签实例 &lt;c:set var=”salary” scope=”session” value=”${2000*2}”/&gt; &lt;c:if test=”${salary &gt; 2000}”&gt; 我的工资为: &lt;c:out value=”${salary}”/&gt; ``` 运行结果如下： ``` 我的工资为: 4000 ``` &lt;c:choose&gt;, &lt;c:when&gt;, &lt;c:otherwise&gt; 标签&lt;c:choose&gt;标签与 Java switch 语句的功能一样，用于在众多选项中做出选择。switch 语句中有 case ，而&lt;c:choose&gt;标签中对应有 &lt;c:when&gt;，switch语句中有 default，而&lt;c:choose&gt;标签中有&lt;c:otherwise&gt;。 语法格式&lt;c:choose&gt; &lt;c:when test=&quot;&lt;boolean&gt;&quot;&gt; ... &lt;/c:when&gt; &lt;c:when test=&quot;&lt;boolean&gt;&quot;&gt; ... &lt;/c:when&gt; ... ... &lt;c:otherwise&gt; ... &lt;/c:otherwise&gt; &lt;/c:choose&gt; 属性&lt;c:choose&gt;标签没有属性。&lt;c:when&gt;标签只有一个属性，在下表中有给出。&lt;c:otherwise&gt;标签没有属性。&lt;c:when&gt;标签的属性如下： 属性 描述 是否必要 默认值 test 条件 是 无 实例演示&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;c:choose 标签实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;c:set var=&quot;salary&quot; scope=&quot;session&quot; value=&quot;${2000*2}&quot;/&gt; &lt;p&gt;你的工资为 : &lt;c:out value=&quot;${salary}&quot;/&gt;&lt;/p&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${salary &lt;= 0}&quot;&gt; 太惨了。 &lt;/c:when&gt; &lt;c:when test=&quot;${salary &gt; 1000}&quot;&gt; 不错的薪水，还能生活。 &lt;/c:when&gt; &lt;c:otherwise&gt; 什么都没有。 &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt; &lt;/html&gt;运行结果如下：你的工资为 : 4000 不错的薪水，还能生活。 **2.循环遍历标签(foreach)** - **&lt;c:forEach&gt;标签** - 语法格式&lt;c:forEach items=”“ begin=”“ end=”“ step=”“ var=”“ varStatus=”“&gt; ...- 属性 `&lt;c:forEach&gt;`标签有如下属性： 属性 | 描述 | 是否必要| 默认值 :- | :- | :- | :- | items | 要被循环的信息 | 否 | 无 begin | 开始的元素（0=第一个元素，1=第二个元素）| 否 | 0 end | 最后一个元素（0=第一个元素，1=第二个元素）| 否 | Last element step | 每一次迭代的步长| 否 | 1 var | 代表当前条目的变量名称 | 否 | 无 varStatus | 代表循环状态的变量名称 | 否 | 无 - 实例演示&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8”%&gt;&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core&quot; prefix=”c” %&gt; c:forEach 标签实例 Item ``` 运行结果如下： ``` Item 1 Item 2 Item 3 Item 4 Item 5 ``` 3.在 JSP 中实现日期的格式化: fmt:formatDate 标签 语法格式&lt;fmt:formatDate value=&quot;&lt;string&gt;&quot; type=&quot;&lt;string&gt;&quot; dateStyle=&quot;&lt;string&gt;&quot; timeStyle=&quot;&lt;string&gt;&quot; pattern=&quot;&lt;string&gt;&quot; timeZone=&quot;&lt;string&gt;&quot; var=&quot;&lt;string&gt;&quot; scope=&quot;&lt;string&gt;&quot;/&gt; 属性&lt;fmt:formatDate&gt;标签有如下属性： 属性 描述 是否必要 默认值 value 要显示的日期 是 无 type DATE, TIME, 或 BOTH 否 date dateStyle FULL, LONG, MEDIUM, SHORT, 或 DEFAULT 否 default timeStyle FULL, LONG, MEDIUM, SHORT, 或 DEFAULT 否 default pattern 自定义格式模式 否 无 timeZone 显示日期的时区 否 默认时区 var 存储格式化日期的变量名 否 显示在页面 scope 存储格式化日志变量的范围 否 页面 实例演示&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; JSTL fmt:dateNumber 标签 日期格式化: 日期格式化 (1): 日期格式化 (2): 日期格式化 (3): 日期格式化 (4): 日期格式化 (5): 日期格式化 (6): 日期格式化 (7): ``` 以上实例运行结果： ``` 日期格式化: 日期格式化 (1): 11:19:43 日期格式化 (2): 2016-6-26 日期格式化 (3): 2016-6-26 11:19:43 日期格式化 (4): 16-6-26 上午11:19 日期格式化 (5): 2016-6-26 11:19:43 日期格式化 (6): 2016年6月26日 上午11时19分43秒 日期格式化 (7): 2016-06-26 --- &gt; 欢迎转载，转载请注明出处！ &gt; 简书ID：[@我没有三颗心脏](https://www.jianshu.com/u/a40d61a49221) &gt; github：[wmyskxz](https://github.com/wmyskxz/) &gt; 欢迎关注公众微信号：wmyskxz &gt; 分享自己的学习 &amp; 学习资料 &amp; 生活 &gt; 想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(5)——Cookie-Session学习","slug":"初学Java-Web-5-——Cookie-Session学习","date":"2018-04-07T01:01:00.000Z","updated":"2020-12-09T04:48:56.700Z","comments":true,"path":"2018/04/07/chu-xue-java-web-5-cookie-session-xue-xi/","link":"","permalink":"http://www.wmyskxz.com/2018/04/07/chu-xue-java-web-5-cookie-session-xue-xi/","excerpt":"","text":"HTTP 协议Web 浏览器与 Web 服务器之间的一问一答的交互过程必须遵守一定的规则，这样的规则就是 HTTP 协议。 HTTP 是 hypertext transfer protocol（超文本传输协议）的简写，它是 TCP/IP 协议之上的一个应用层的协议，用于定义 Web 浏览器与 Web 服务器之间交互数据的过程以及数据本身的格式。 特点：无状态，默认端口 80 HTTP 协议到底约束了什么？ 约束了浏览器以何种格式向服务端发送数据 约束了服务器应该以何种格式来接收客户端发送的数据 约束了服务器应该以何种格式来反馈数据给浏览器 约束了浏览器应该以何种格式来接收服务器的反馈数据 总结：浏览器给服务器发送数据:一次请求服务器给浏览器反馈数据:一次响应 HTTP 无状态协议HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。 HTTP 的这种特性有优点也有缺点： 优点：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用。 缺点：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享。 主要问题：请求之间无法实现数据的共享 解决方案： 1.使用参数传递机制：将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：/param/list?username=wmyskxz问题：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb2.使用Cookie技术3.使用Session技术 Cookie 技术 特点：客户端的技术，将共享数据保存在客户端（浏览器）中 英文直接翻译过来就是小甜品，Cookie 的作用呢，通俗的说就是当一个用户通过 HTTP 访问一个服务器时，这个服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据又被完整地带回给服务器。 这个作用就像是你去超市购物时，第一次给你办了一张购物卡，在这个购物卡里存放了一些你的个人信息，下次你再来这个超市的时候，你就只需要带上你的购物卡，直接购物就好了。 Cookie 操作 创建 Cookie 对象，设置共享数据Cookie c = new Cookie(String name,String value); // 相当于办卡 注意：一个Cookie只能存储一个字符串类型的数据,不能存储其他类型的数据 将 Cookie 响应给浏览器response对象.addCookie(cookie对象) // 相当于把卡交给用户 获取请求中的 Cookie 信息Cookie[] cs = request对象.getCookies(); for(Cookie c : cs){ if(“username”.equals(c.getName())){ String value = c.getValue(); } } 修改 Cookie 中的共享数据 重新创建一个新的 Cookie，名称要和要修改的数据一致 现获取到要修改的 Cookie 对象，再调用 setValue(String newValue) 重新设置 注意：修改 Cookie 中的数据，需要再次发送给浏览器（第2点） 操作 Cookie 的生命周期 默认：在关闭浏览器的时候销毁 Cookie 对象 语法：void setMaxAge(int expiry)expiry &gt; 0：设置 Cookie 对象能够存活 expiry 秒，即使关闭浏览器，也不影响 Cookie 中的共享数据，比如设置一个月：setMaxAge(60*60*24*30);expiry = 0：立即删除当前的 Cookie 信息expiry &lt; 0：关闭浏览器时销毁 删除 Cookie 中的共享数据通过setMaxAge(0)来实现 Cookie 中的 key 和 value 不支持中文设置 Cookie 时需要对中文字符串进行编码： Cookie c = new Cookie(\"username\", URLEncoder.encode(username,\"UTF-8\")); 在获取 Cookie 数据的时候再进行解码： username = URLDecoder.decode(value, \"UTF-8\"); Cookie 的路径和域范围 Cookie 的路径Cookie 在创建的时候，会根据当前的Servlet的相对路径来设置自己的路径，比如 Servlet 的url-pattern为 /cookie/login，相对路径则为：/cookie/ 出现的问题：只有在访问路径为 /cookie/ 下面的资源的时候，才会将该 Cookie 发送到服务器 解决方案：设置 Cookie 的路径：void setPath(String uri)Cookie对象.setPath(&quot;/&quot;); 表示当前应用中的所有的资源都能够共享该Cookie信息 域范围：（了解）在多个应用之间实现数据的共享，那么就需要设置域范围，比如：www.baidu.com / news.baidu.com / map.baidu.com 语法：Cookie对象.setDomain(&quot;baidu.com&quot;); Cookie 的缺陷Cookie 的作用其实就是一种会话跟踪技术，但存在一些缺陷： 获取 Cookie 信息比较麻烦 Cookie 不支持中文 一个 Cookie 只能存储一个字符串类型的数据 Cookie 在浏览器中有大小和数量上的限制（不同浏览器存在不同的限制，例如FireFox一个站点最多存储50个 Cookie ，浏览器最多存储 4097个字大小的 Cookie） 共享数据时保存在浏览器中，容易造成数据的泄露，不安全 最好的解决方案：将数据保存在服务端（session） Session 技术Session：会话，从浏览器打开开始，直到浏览器关闭结束，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。Session 也可以称为会话 Cookie 特点：服务端技术，将数据保存在服务器 理解 Session前面已经介绍了 Cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些 Cookie，如果 Cookie 很多，则无形增加了客户端与服务端的数据传输量，而 Session 的出现正是为了解决这个问题。 同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 就是客户端第一次访问服务器生成的，而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NAME 为 JSESIONID 的一个 Cookie。 Session 基本操作 获取 Session 对象request对象.getSession()和参数为true的一样request对象.getSession(true)获取Session对象,如果没有Session对象,直接创建一个新的返回,缺省值request对象.getSession(false)获取Session对象,如果没有返回null 设置共享数据Session对象.setAttribute(String name, Object value) 注意：Session 可以存储任何类型的数据,比如登陆用户的信息,可以封装到User对象中 修改共享数据重新设置一个同名的共享数据 获取共享数据 Object value = Session对象.getAttribute(String name); 删除 Session 中的共享数据 Session对象.removeAttribute(String name); 销毁 Session void invalidate() Session 的超时管理 超时：在访问当前的资源的过程中,不和网页进行任何的交互,超过设定的时间就是超时在 Tomcat 服务器中有默认的配置为30分钟，一般不需要去修改 语法：void setMaxInactiveInterval(int interval) Session 扩展 Seesion 中的共享数据的属性名的命名规范：通常为：XXX_IN_SESSION，例如：Session对象.setAttribute(“USER_IN_SESSION”,user) 序列化与反序列化：Session 中存储的对象通常需要实现序列化接口，因为在网络之间传输的数据格式为二进制数据： 序列化：将对象转换成二进制数据 反序列化:将二进制数据转换成对象 URL 重写 出现的问题：当浏览器禁用Cookie之后,那么我们的jsessionid就不能在浏览器中保存,那么后面的请求中就不会将 jsessionid 发送到服务器,服务器这面就找不到数据解决方案：1.在url后手动的拼接上 jsessionid传递格式如 /path/Servlet;jsessionid=sessionid2.使用响应对象中的encodeURL(String path)实现 jsessionid 的自动拼接String path = resp.encodeURL(&quot;path/Servlet&quot;); 推荐方式：② 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(4)——Servlet学习总结","slug":"初学Java-Web-4-——Servlet学习总结","date":"2018-04-06T01:00:00.000Z","updated":"2020-12-09T04:48:53.806Z","comments":true,"path":"2018/04/06/chu-xue-java-web-4-servlet-xue-xi-zong-jie/","link":"","permalink":"http://www.wmyskxz.com/2018/04/06/chu-xue-java-web-4-servlet-xue-xi-zong-jie/","excerpt":"经过一段时间的学习，对于Servlet有了新的不一样的见解，在这里做一下总结，将近来学习到的知识总结一下。","text":"经过一段时间的学习，对于Servlet有了新的不一样的见解，在这里做一下总结，将近来学习到的知识总结一下。 Servlet 的请求流程 浏览器发出请求：http://localhost:80/xxx1/xxx2 （80端口可以默认不写，因为这是http协议默认的端口，平时我们访问https://www.baidu.com/ 时其实访问的是https://www.baidu.com:80/） 服务器解析请求信息： http:协议名称 localhost:访问的是互联网中的哪一台计算机 80:从主机当中找到对应 80 端口的程序 **（这里即为 Tomcat 服务器**） /xxx1:当前项目的上下文路径 （即在 server.xml 中配置主机时配置的 path属性） /xxx2:当前请求的资源名 解析 Tomcat 服务器根目录下的 /config/server.xml 文件：&lt;Context docBase=&quot;D:\\javaPros\\test\\webapp&quot; path=&quot;xxx1&quot; /&gt;判断哪一个&lt;Context /&gt;```元素的 **path属性** 属性为 ```xxx1 若找不到，则返回 404错误 若找到了，则解析该&lt;Context /&gt;元素，得到docBase属性，获取当前访问 Web 项目的跟的绝对路径：D:\\javaPros\\test\\webapp 从D:\\javaPros\\test\\webapp下的 WEB-INF 下找到 web.xml 文件判断 web.xml 文件中是否有 &lt;url-pattern&gt; 的文本内容为 /xxx2 若找不到，则返回 404错误 若找到了，则继续获取该资源对应 Servlet 类的全限名称： xxx.xxx 判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象 Map&lt;String,Servlet> cache = ......(Tomcat提供的); key:存Servlet类的全限定名称 value:该Servlet类的对象. Servlet obj = cache.get(\"xxx.xxx\"); if(obj==null){ //Servlet实例缓存中没有该类的对象,第一次. GOTO 6: }else{ //有对象,非第一次. GOTO 8: } } 使用反射调用构造器，创建对应的对象 obj = Class.forName(&quot;xxx.xxx&quot;).newInstance(); 把当前创建的 Servlet 对象，存放在缓存之中，供给下一次的使用. cache.put(&quot;xxx.xxx&quot;,obj); 创建 ServletConfig 对象，并调用 init() 方法 obj.init(config); 创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法 obj.service(req,resp); 在 service() 方法中对浏览器作出响应操作。 Servlet 生命周期在 Web 容器中，Servlet 主要经历 4 个阶段，如下图： 加载 Servlet：当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例。 初始化 Servlet：当 Servlet 被实例化之后，Tomcat 会调用 init() 方法来初始化这个对象。 处理服务：当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求。 销毁：当 Tomcat 关闭或者检测到 Servlet 要从 Tomcat 删除的时候，会自动调用 destroy() 方法，让该实例所占用的资源释放掉。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁。 简单总结：只要访问 Servlet ，就会调用其对应的 service() 方法，init() 方法只会在第一次访问 Serlvet 的时候才会被调用。 这一部分参考文章：这里是链接 Servlet 提供处理请求的方法前面的文章里面提到过，广义上，Servlet 即实现了 Servlet 接口 的类，当我们创建一个自定义类，实现 Servlet 接口 的时候，会发现有 5 个方法需要重写，有init【初始化】，destroy【销毁】,service【服务】,ServletConfig【Servlet配置】,getServletInfo【Serlvet信息】。 这样做的话，我们每次都需要实现 5 个方法，太麻烦了！ 我们可以直接继承 HttpServlet 类，该类已经默认实现了 Servlet 接口中的所有方法，在编写 Servlet 的时候，你只需要重写你需要的方法就好了，并且该类还在原有 Servlet 接口上添加了一些与 HTTP 协议处理相关的方法，比 Servlet 接口的功能更强大。 Servlet 处理请求的方法一共有三种：① 实现 service() 方法。② 重写 doGet() 和 doPost() 方法，并在 doGet() 中添加一句this.doPost(req, resp);（因为无论是get或post请求提交的数据，处理方式都基本相同，下同）③ 重写 doGet() 和 doPost() 方法，并在 doPost() 中添加一句this.doGet()(req, resp); 推荐方式①。 Servlet 是单例的为什么Servlet是单例的浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。 每次访问请求对象和响应对象都是新的对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 线程安全问题当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。 原则： 1. 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制synchronized (对象){} 2. 如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题 这一部分参考文章：这里是链接 HttpServletRequest 和 HttpServletResponse 对象对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，即 request 和 response 对象。 既然 request 对象代表 http 请求，那么我们获取浏览器提交过来的数据，就找 request 对象 即可。response 对象代表 http 响应，那么我们向浏览器输出数据，找 response 对象即可。 HttpServletRequest 常用方法 String getContextPath():获取上下文路径,&lt;Context path=”上下文” ../&gt; String getHeader(String headName):根据指定的请求头获取对应的请求头的值. String getRequestURI():返回当期请求的资源名称. 上下文路径/资源名 StringBuffer getRequestURL():返回浏览器地址栏的内容 String getRemoteAddr():返回请求服务器的客户端的IP 获取请求参数的方法： String getParameter(String name):根据参数名称,获取对应参数的值. String[] getParameterValues(String name):根据参数名称,获取该参数的多个值. Enumeration getParameterNames():获取所有请求参数的名字 Map&lt;String,String[]&gt; getParameterMap():返回请求参数组成的Map集合. key:参数名称value:参数值,封装在String数组中. HttpServletResponse 常用方法 OutputStream getOutputStream():获取字节输出流:文件下载 Writer getWriter():获取字符输出流:输出内容设置文件输出的编码格式和内容类型：resp.setContentType(&quot;text/html;charset=utf-8&quot;); GET 和 POST 的区别要知道，GET 和 POST 都是请求方式 GET：浏览器器地址栏：http://localhost/test.html?name=wmyskxz&amp;sex=male这里提交了两个参数，一个是name属性值为wmyskxz，另一个是sex属性值为male，这是一种直接的请求方式，在请求资源后面跟上 ? 符号与参数连接，其他的参数使用 &amp; 符号连接。 缺点： 1.暴露请求信息，不安全2.请求信息不能超过1kb，可传输的信息有限，不能上传图片 POST：浏览器地址栏：http://localhost/test.html# 优点： 1.隐藏了请求信息，较安全（但仍可以通过相关工具访问到数据）2.POST 方式没有限制请求的数据大小，可以做图片的上传 但并不是所有的数据都需要使用 POST 请求来完成，事实上，GET 请求方式会比 POST 请求更快，当数据小并且安全性要求不是那么高的时候，GET 仍然是很好的选择.(并且 GET 相较 POST 简单) 请求中文乱码的处理在 Tomcat 服务器中，接受请求的时候，默认的编码方式为 ISO-8859-1，而该编码方式只占一个字节，不支持中文（两个字节），所以当我们做请求的时候，会出现乱码的问题 解决方案： 1.对乱码使用 ISO-8859-1 解码，转换成byte数组，恢复为二进制byte[] data = name.getBytes(&quot;ISO-8859-1&quot;);2.对byte数组重新进行 UTF-8 编码：name = new String(data,&quot;UTF-8&quot;);但是这样会出现一个问题，那就是当表单数据太多的时候，这样反复解码-编码，会很繁琐。 终极解决方案： 1.对于 POST 请求：设置请求的编码方式：request.setCharacterEncoding(&quot;UTF-8&quot;);注意：必须在获取第一个参数之前设置，并且该方式只对 POST 方式有效。2.对于 GET 请求：重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:Tomcat根目录/conf/server.xml(修改端口的那一行) Servlet 细节 1.一个 Servlet 可以有多个 &lt;url-pattern&gt; ，可以使用多个资源名称找到当前的 Servlet 2.配置 Servlet 可以使用通配符（）*表示任意字符/*：可以使用任意的字符访问当前的 Servlet`.xxx`：如 wmyskxz.wudi 3.自定义的 Servlet 的 &lt;servlet-name&gt; 不能够为 default ，使用它会造成项目下面的静态资源找不到，在 Tomcat/conf/web.xml 文件中配置一个名字为default的Servlet,该Servlet在负责访问项目下的静态资源 4.关于 Servlet 的初始化操作，如果初始化操作非常的耗时，那么第一个请求的用户的用户体验就非常差 解决思路：将初始化操作向前移,在服务器启动的时候执行 Servlet 的初始化 通过注解配置 Servlet这是 Servlet 3.0 提出的新特性，支持注解配置，这大大简化了我们的工作。 在之前的开发工作中，我们总是去 web.xml 文件中进行配置，至少会出现8行： 而当一个项目中存在很多 Servlet **，那么配置文件就会变得非常臃肿，不便于后期的维护，在 Servlet 3.0 推出之后，我们可以使用注解来配置 Servlet，**上面 8 行的配置可以简化为下面的简单的注解： 或者也可以使用属性 value 定义访问的 URL，只有 URL 这个属性是必要的，name 是可以缺省的值，而默认的 value 也可以省略不写，所以可以简写成： @WebServlet(\"/foreServlet\") Web 组件之间的跳转方式1.请求转发（forward）又叫做直接转发方式，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。 比如：从 AServlet 请求转发到 BServlet 语法： request.getRequestDispatcher(path).forward(request, response); 参数：path，要跳转到的资源路径：上下文路径 / 资源路径 特点： 1.地址栏中的地址【不会】改变通常看作是服务端的跳转2.只有一个请求3.资源是共享的，也就是说在两个 Servlet 中可以共享请求的资源可以通过request.setAttribute(String var1,Object var2)设置要共享的数据资源，并通过request.getAttribute(String var1);来获取传递的资源4.【可以】访问 WEB-INF 中的资源WEB-INF 文件夹是 Java Web 应用的默认安全目录，即客户端无法直接访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。注意：在实际的开发中，可以把不希望用户直接访问到（通过浏览器输入地址栏）的网页放在文件夹中通过此方式访问。5.请求转发【不能】跨域访问所谓的同域，是指域名，协议，端口均相同 2.URl 重定向（redirect）又叫做间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 比如:从AServlet重定向到BServlet 语法： response.sendRedirect(String location); 参数：location，转发到的资源路径 特点： 1.地址栏中的地址【会】发生改变通常看作是客户端跳转2.有两个请求3.在两个 Servlet 中不可以共享请求中的数据4.最终的响应由 BServlet 来决定，和 AServlet 没有关系5.【不可以】访问 WEB-INF 中的资源6.请求转发【能】跨域访问就像是在网页中点开了新的链接一样 总结：URL 重定向相当于是将重定向的资源路径，重新复制到浏览器地址栏中按下回车一样，重新发送一次新的请求。 3.请求包含（include） MVC 模式MVC 是一种分层的设计模式 。 M 代表 模型（Model）模型是什么呢？ 模型就是数据，就是dao,bean V 代表 视图（View）视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 C 代表 控制器（controller)控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上。 这部分可以参考一下这里 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(3)——第一个Servlet","slug":"初学Java-Web-3-——第一个Servlet","date":"2018-03-21T00:59:00.000Z","updated":"2020-12-09T04:48:50.678Z","comments":true,"path":"2018/03/21/chu-xue-java-web-3-di-yi-ge-servlet/","link":"","permalink":"http://www.wmyskxz.com/2018/03/21/chu-xue-java-web-3-di-yi-ge-servlet/","excerpt":"","text":"这学期 Java Web 课程的第一节课就简短复习了一下 Java 的一些基础知识，所以觉得 Java 的基础知识还是很重要的，但当我想要去写一篇 Java 回顾的文章的时候发现很难，因为坑实在太多了（一个头，两个大），只能另外找一些时间去写顺便巩固巩固自己的基础。 ——【1. 什么是 Servlet 】——学习一个东西就要先去了解它是什么东西。 Servlet 取自两个单词：Server、Applet （很符合 sun 公司的命名特点）， Java Servlet 的简称，其实质就是运行在 Web 应用服务器上的 Java 程序，与普通 Java 程序不同，它是位于 Web 服务器内部的服务器端的 Java 应用程序，可以对 Web 浏览器或其他 HTTP 客户端程序发送的请求进行处理。 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 实际上，Servlet 就像是一个规范，想象一下我们的 USB 接口，它不仅约束了U盘的大小和形状，同样也约束了电脑的插槽，Servlet 也是如此，它不仅约束了服务器端如何实现规范，也约束着 Java Web 项目的结构，为什么这样说，我们下面再来讲，编写一个 Servlet 其实就是按照 Servlet 规范编写一个 Java 类。 ——【2. Servlet 与 Servlet 容器 】——Servlet 对象与普通的 Java 对象不同，它可以处理 Web 浏览器或其他 HTTP 客户端程序发送的 HTTP 请求，但前提是把 Servlet 对象布置到 Servlet 容器中，也就是说，其运行需要 Servlet 容器的支持。 Servlet 容器也叫做 Servlet 引擎，是 Web 服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于 MIME 的请求，格式化基于 MIME 的响应。Servlet 没有 main 方法，不能独立运行，它必须被部署到 Servlet 容器中，由容器来实例化和调用 Servlet 的方法（如 doGet() 和 doPost() 方法），Servlet 容器在 Servlet 的生命周期内包容和管理 Servlet 。在 JSP 技术 推出后，管理和运行 Servlet / JSP 的容器也称为 Web 容器。 有了 Servlet 之后，用户通过单击某个链接或者直接在浏览器的地址栏中输入 URL 来访问 Servlet ，Web 服务器接收到该请求后，并不是将请求直接交给 Servlet ，而是交给 Servlet 容器。Servlet 容器实例化 Servlet ，调用 Servlet 的一个特定方法对请求进行处理， 并产生一个响应。这个响应由 Servlet 容器返回给 Web 服务器，Web 服务器包装这个响应，以 HTTP 响应的形式发送给 Web 浏览器。 Servlet 容器能提供什么？上面我们知道了需要由 Servlet 容器来管理和运行 Servlet ，但是为什么要这样做呢？使用 Servlet 容器的原因有： 通信支持：利用容器提供的方法，你能轻松的让 Servlet 与 web 服务器对话，而不用自己建立 serversocket 、监听某个端口、创建流等。容器知道自己与 web 服务器之间的协议，所以你的 Servlet 不用担心 web 服务器（如Apache）和你自己的 web 代码之间的 API ，只需要考虑如何在 Servlet 中实现业务逻辑（如处理一个订单）。 生命周期管理： Servlet 容器控制着 Servlet 的生与死，它负责加载类、实例化和初始化 Servlet ，调用 Servlet 方法，以及使 Servlet 实例被垃圾回收，有了 Servlet 容器，你不需要太多的考虑资源管理。 多线程支持：容器会自动为它所接收的每个 Servlet 请求创建一个新的 java 线程。针对用户的请求，如果 Servlet 已经运行完相应的http服务方法，这个线程就会结束。这并不是说你不需要考虑线程安全性，其实你还会遇到同步问题，不过这样能使你少做很多工作。 声明方式实现安全：利用 Servlet 容器，你可以使用 xml 部署描述文件来配置和修改安全性，而不必将其硬编码写到 Servlet 类代码中。 JSP支持： Servlet容器负责将 jsp 代码翻译为真正的 java 代码。 Servlet 生命周期通常情况下，Servlet 容器也就是指 Web 容器，如 Tomcat、Jboss、Resin、Weblogic 等，它们对 Servlet 进行控制。当一个客户端发送 HTTP 请求时，由容器加载 Servlet 对其进行处理并做出响应。在 Web 容器中，Servlet 主要经历 4 个阶段，如下图： Servlet 与 Web 容器的关系是非常密切的，在 Web 容器中 Servlet 主要经历了 4 个阶段，这 4 个阶段实质是 Servlet 的生命周期，由容器进行管理。 （1）在 Web 容器启动或者客户机第一次请求服务时，容器将加载 Servlet 类并将其放入到 Servlet 实例池。 （2）当 Servlet 实例化后，容器将调用 Servlet 对象的 init() 方法完成 Servlet 的初始化操作，主要是为了让 Servlet 在处理请求之前做一些初始化工作。 （3）容器通过 Servlet 的 service() 方法处理客户端请求。在 Service() 方法中，Servlet 实例根据不同的 HTTP 请求类型作出不同处理，并在处理之后作出相应的响应。 （4）在 Web 容器关闭时，容器调用 Servlet 对象的 destroy() 方法对资源进行释放。在调用此方法后，Servlet 对象将被垃圾回收器回收。 ——【3. 第一个 Servlet 】——① 搭建 Java Web 项目 创建 一个 Java 项目，并命名为 HelloServlet； （注意：这是普通的 Java 项目而不是动态 Web 项目） 在项目的根目录下创建一个文件夹 webapp，表示 Web 项目的根； 在 webapp 中创建 WEB-INF 文件夹； 在 WEB-INF 文件夹中创建文件夹：classes,lib； 在 WEB-INF 文件中添加 Tomcat 根目录下 conf 文件夹中的 web.xml 文件；（只保留根元素，就像下面这样） &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;/web-app&gt; 把当前项目的 classpath 路径改成 webapp/WEB-INF 下的 classes 中。 ② 编写 Servlet 为该项目增加Servlet的支持. 1.1. 把Tomcat根/lib中servlet-api.jar文件拷贝到项目下WEB-INF下的lib中 1.2. 在项目中选择servlet-api.jar,鼠标右键,build path–&gt;add to build path 开发Servlet程序: 2.1:定义一个类HelloServlet,并让该类去实现javax.servlet.Servlet接口; 2.2:实现Servlet接口中的init,service,destory等方法. import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloServlet implements Servlet{ @Override public void init(ServletConfig config) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(&quot;测试一下！&quot;); // 先在这里写下测试代码 } @Override public String getServletInfo() { return null; } @Override public void destroy() { } }注意:若生成方法中的参数是 arg0 或则 arg1 等格式的,原因是还没有关联源代码的问题: 关联上 tomcat src 文件即可 ③ 配置 Servlet上面编写好的 HelloServlet 类仅仅是一个普通的实现类而已，而现在我想要它运行在我自己的 Tomcat 服务器中，所以应该通知 Tomcat 服务器来管理我的 HelloServlet 类，具体的做法如下： 找到项目根下的WEB-INF下的web.xml文件: 在根元素web-app中创建一个新的元素节点:servlet 在根元素web-app中创建一个新的元素节点:servlet-mapping（Servlet 的映射） &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;lt.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; ``` &gt; web.xml 提供路径和servlet映射关系，这意思是把/hello这个路径，映射到 HelloServlet 这个类上，需要注意的是：**&lt; servlet&gt; 标签下的 &lt; servlet-name&gt;与 &lt; servlet-mapping&gt; 标签下的 &lt; servlet-name&gt; 必须一样**（因为标签被编辑器识别故&lt;后加了一个空格） 配置 Tomcat 服务器： 4.1. 修改默认端口为 80 端口： 首先进入到 Tomcat 服务器的根路径下找到 conf 文件夹下的 server.xml 文件，默认是在第 70 行，找到 Connector 元素的 port 属性，修改为 80 ，重启 Tomcat 即可。 ![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/初学Java-Web（3）——第一个Servlet/7896890-7812541ce51b78e5.png) Tomcat 的默认端口为8080，而 HTTP 协议的默认端口是 80，配置 80 端口的好处在于，我们平时输入的类似于 http://baidu.com 其实是默认省略了写 80端口的，它其实等价于：http://baidu.com:80/ ，所以以后我们就不用再写冒号直接输入 locahost 就能进入到 Tomcat 的配置页面了。 4.2 部署 Java 项目（告诉 Tomcat 服务器来管理我们的项目）： 这里直接引用 how2j.cn 的教程啦： ![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/初学Java-Web（3）——第一个Servlet/7896890-9b8a876c38379a5a.png) 所以加上&lt;Context path=&quot;&quot; docBase=&quot;F:\\\\Projects\\\\JavaProject\\\\HelloServlet\\\\webapp&quot; /&gt;这一句重启 Tomcat 服务器 在浏览器中输入 localhost/hello，回车，即可在 Tomcat 服务器上看到相关信息，至此第一个 Servlet 就编写成功了 ——【4. Servlet 请求过程】——学习 Servlet 技术，就需要有一个 Servlet 运行环境，也就是需要有一个 Servlet 容器，如这里使用的【Tomcat】。 Tomcat 服务器接受客户请求并做出响应的过程如下（以上面搭建的项目为例）： ① 打开浏览器发起请求：http://localhost:80/hello/index.html （假设有一个 index.html 文件） ② 服务器接收到请求后处理请求： htpp：所使用的协议localhost：ip地址，确定访问的主机80：端口号hello：上下文路径，确定访问项目的根路径index.html：确定访问项目中的具体哪一个资源 ③ 根据 hello 去 tomcat/conf/server.xml 文件中找到相关配置文件，根据上下文路径找到项目的根路径：&lt;Context path=&quot;&quot; docBase=&quot;F:\\\\Projects\\\\JavaProject\\\\HelloServlet\\\\webapp&quot; /&gt;如果找不到根路径（因为这里默认上下文路径为空），返回 404 ④ 根据资源名称去项目中的 web.xml 文件中找到相关的配置，找到配置中的&lt;url-pattern&gt; 如果找不到 hello 的资源名称，则返回 404 ⑤ 根据资源名称找到 Servlet 的全限定名，如果找不到则在启动服务器的时候报错java.lang.IllegalArgumentException: Servlet mapping specifies an unknown servlet name HelloServlet ⑥ 根据找到的全限定名创建对象，在创建对象之前需要判断是否是第一次请求，使用 Tomcat 中使用 Servlet 实例缓存池来实现，若是第一次则调用对象的 init 方法。 ⑦ 创建 req,resp 对象，执行 service 方法； ⑧ 使用 resp 对象给浏览器响应信息。 发现一边学一边写起来太麻烦了，一方面是因为自己的水平，另一方面是觉得这样太费时间了，也要开始找实习了，所以时间有些宝贵，可能这不会作为一个连续的系列，反而是一些学习的分享和感悟，emmm….事实上，Servlet也还有好多东西，包括最新支持注解方式配置等….参考资料：《Java Web程序设计 慕课版——明日科技》how2j.cn理解Servlet和Servlet容器、Web服务器等概念 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(2)——搭建Java Web开发环境","slug":"初学Java-Web-2-——搭建Java-Web开发环境","date":"2018-03-14T00:57:00.000Z","updated":"2020-12-09T04:48:47.364Z","comments":true,"path":"2018/03/14/chu-xue-java-web-2-da-jian-java-web-kai-fa-huan-jing/","link":"","permalink":"http://www.wmyskxz.com/2018/03/14/chu-xue-java-web-2-da-jian-java-web-kai-fa-huan-jing/","excerpt":"虽然说 html 和 css 等前端技术，是对于 Web 来说不可或缺的技术，但是毕竟更为简单一些，所以就不详细介绍了，没有基础的同学可以去菜鸟教程或者W3school进行自主学习，最好的方式还是做一做简单的项目，相信你很快就可以上手啦。(有空把我仿的天猫给大家拿出来..)","text":"虽然说 html 和 css 等前端技术，是对于 Web 来说不可或缺的技术，但是毕竟更为简单一些，所以就不详细介绍了，没有基础的同学可以去菜鸟教程或者W3school进行自主学习，最好的方式还是做一做简单的项目，相信你很快就可以上手啦。(有空把我仿的天猫给大家拿出来..) ——【1. JDK 的安装】——在搭建环境之前呢，还是给搬一下一些名词的介绍和解释： 术语名 缩写 解释 Java Development Kit JDK 编写Java程序的从程序员使用的软件 Java Runtime Environment JRE 运行Java程序的用户使用的软件 Standard Edition SE 用于桌面或简单的服务器应用的Java平台 Enterprise Edition EE 用于复杂的服务器应用的Java平台 Micro Edition ME 用于手机和其他小型设备的Java平台 Java 2 J2 一个过时的术语，用于描述1998年~2006年之间的Java版本 Software Development Kit SDK 一个过时的术语，用于描述1998年~2006年之间的JDK 再来引用一张图片来说明 Java SE 和 Jave EE 的区别： JDK 的下载JDK的官方下载地址在这：http://www.oracle.com/technetwork/java/javase/downloads/index.html最新的JDK已经升级到了9.0，而且据说10.0都快出来了，可能对于一些新学 Java 的同学来说，8的特性还没熟悉，9不知道是啥，10.0 眼看着都要出来了…没关系，我也是差不多这样的感受… JDK 的安装上图就是一个JDK的下载过程，安装很简单，我就直接粘网上的图了（重要的是记住JDK安装的路径用于配置环境变量）： JDK 环境变量的配置Java环境变量涉及到三个名词：JAVA_HOME、path、classpath。 JAVA_HOME代表JDK安装主目录，path代表JDK下可执行文件目录，classpath代表运行java程序时需要查找class文件的目录。 依据上面的安装步骤： JAVA_HOME应该设置为：D:\\DevelopTools\\JAVA\\JDK path应该设置为：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;（注意其中的分号） classpath应该设置为：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;（注意最前面的点代表当前路径，JDK1.5之后这项不用设置了） 设置方式如下： 到此就已经成功配置好了 JDK 所需要的环境变量，我们下面来验证一下。 验证 JDK 是否安装成功打开命令提示符，WINDOWS 下的快捷键为【Win + R】，然后输入 cmd ，输入【java -version】查看是否输出正确地版本信息，如果成功，则 JRE 配置成功。（我直接贴的老图啦，所以….） 输入【javac】看是否输出编译信息，若有，则 JDK 配置成功： 至此，JDK 就彻底安装成功了。 ——【2.安装和配置 Tomcat 服务器】——正如上一篇说到的，Tomcat 是使用 Java 语言编写的一个服务器（程序），所以要运行 Tomcat ，必须配置好相关的 JDK 或 JRE。Tomcat 的官方网站是：http://tomcat.apache.org/ 你可以去官网下载最新的版本，也可以下载我提供的绿色版本（v8.5.5）：https://pan.baidu.com/s/1gROPZCovNrsMxkWLFbZ9IQ（密码:142q） 以我提供的绿色版本为例，安装步骤如下： ① 解压提供的 Tomcat 到 D 盘并记录下其路径，如 D:\\apache-tomcat-8.5.5. ② 配置 CATALINA_HOME 环境变量到上面记下的路径： ③ 启动 Tomcat 服务器找到 D:\\apache-tomcat-8.5.5 路径下的 bin 目录中的 startup.bat 文件，双击运行，如果输出启动信息，并未输出任何异常，则 Tomcat 安装正确（注意，弹出的命令提示符窗口不能关闭，否则服务器将停止运行！） ④ 打开浏览器验证 Tomcat打开浏览器，在地址栏输入地址：http://localhost:8080/ 或者 http://127.0.0.1:8080/ ，如果能够打开 Tomcat 配置页面，则说明 Tomcat 配置成功： 关闭 Tomcat 服务器在 Tomcat 开启的命令提示符界面按下【Ctrl + C】键，将关闭 Tomcat 服务器。再次尝试访问 Tomcat 配置页面，若出现网页不能访问提示，则说明 Tomcat 关闭成功： 在 Tomcat 中新建 Web 工程步骤如下：（下载文件-密码klhk）① 找到 Tomcat 目录下的 webapps 目录。② 在 webapps 目录下新建一个目录： first_webapp。（注意 first 和 webapp 中间为下划线）③ 在 first_webapp 中建立一个目录： WEB-INF。（注意大小写，WEB 和 INF 之间为横线）④ 将上面的下载文件下载下来以后，将提供的 web.xml 文件复制到 WEB-INF 目录中。⑤ 将提供的 index.html 文件复制到 first_webapp 目录下。⑥ 启动 Tomcat。⑦ 在浏览器中输入网址：http://localhose:8080/first_webapp ，查看是否能够正确访问，如果可以正确显示页面，则表示 Tomcat 中创建新项目成功。 ——【3.安装配置 MySql 服务器】——不管怎样，服务器端总是要有数据库的，这里就给出两个绿色版本的工具，来建立一个 Web 开发所需要的 MySql 服务器：链接：https://pan.baidu.com/s/1i-H4SUMcn2y5_arluK923A 密码：1n04 xampp 是一套 Web 开发套件，里面包含了 mysql、apache、tomcat 等常用组件。这里我们主要利用其中的 mysql 组件来完成数据库的开发。 heidiSQL 是一款绿色版的 SQL 管理软件，能实现数据库的一些常用功能。 步骤如下：① 将提供的 xampp 工具解压到 D 盘根目录下。（注意 xampp 一定要解压到根目录下才有效。所谓根目录是指D:\\xampp\\目录下不能再嵌套 xampp 目录，而是直接在 D:\\xampp\\目录下能够找到 mysql 目录。切记！！）② 双击 xampp 目录下的 xampp-control.exe 文件运行，并显示如下界面： ③ 为了避免和本机上已经安装的 MySql 服务器冲突，我们需要更改 xampp 的服务名称：单机界面上的 Config 按钮，显示如下界面： ④ 点击“Service and Port Settings”按钮，将出现如下界面： ⑤ 点击 MySQL 标签页，配置 MySql，将 MySql 的 Service Name 从 mysql 更改为 mysql-xampp，然后保存： ⑥ 关闭 xampp。（ 注意 如果闭 关闭 xampp 后，xampp 。 任然在后台运行，必须从右下角系统托盘处完全关闭。）然后重新打开 xampp-control.exe 文件： ⑦ 点击 MySql 对应的 Start 按钮。如果 MySql 服务启动成功，则显示如下： 其中，MySql 字符的背景色变为绿色表示启动成功，PID 表示 MySql 在操作系统中的进程号，Port 表示 MySql 进程所监听的端口号。 ⑧ 打开提供的 heidiSQL 工具（绿色软件），将显示如下界面： ⑨ 点击 New 按钮，新建 MySql 连接： ⑩ 在 hostname/IP 处填写：127.0.0.1 或者 localhost。在 User 处填写：root（这是 MySql 的登录用户名）。在 Password 处填写：root（这是 MySql 的登录密码。 注意：如果是自己下载的 xampp 工具，则密码为空。使用的我提供的 xampp 工具，则 MySql 登录密码被我改成 root ）在 Port 处填写：3306（这是 MySql 默认的监听端口），随后点击【Open】按钮，将显示如下界面： 左边列出了目前 MySql 中的所有数据库，右边是当前数据库的内容。（请勿更改和删除默认数据库的内容） 在 Tomcat 中连接数据库将提供的 MySql 的 JDBC 驱动文件 mysql-connector-java-xxxx-bin.jar 文件复制到 Tomcat 目录下的 lib 目录中 至此，就成功搭建好了 MySql 服务器。 ——【4.安装 Eclipse-JEE】——① 下载 Eclipse - Jee进入官网 http://www.eclipse.org/downloads/eclipse-packages 选择Eclipse IDE for Java EE Developers，根据自己电脑情况选择32位或者64位： 下好以后直接解压到相应位置，并找到 eclipse.exe，右键 –&gt; 发送到 –&gt; 桌面快捷方式就行了。 ② 首次打开设置工作空间由于我们已经配置好了 JDK 的相关信息，所以这里的 Eclipse 可以直接打开： 工作空间大家设置成自己喜欢。熟悉的路径即可，以后建立的工程文件都在设置的工作空间里面。 ③ 进行简单配置 配置 Tomcat 服务器：1.进入 Eclipse 后首先将 Tomcat 服务器位置通知 Eclipse。选择菜单项“Window”→“Preferences”2.打开“Preferences”对话框，在左边找到“Server”选项，并展开，选中其中“Runtime Environments”项目： 3.点击右边界面中“Add”按钮，在弹出的界面中找到“Apache Tomcat 8.5”项目并选中： 4.点击下一步，并在 Name 处输入：Apache Tomcat v8.5。然后将目标目录选定为刚刚安装的 Tomcat 目录 5.最后点击“Finish”按钮完成服务器的配置 配置默认的格式：1.选择菜单项“Window”→“Preferences”，找到下方的“Web”，将其中红色框标记的选项里的【Encoding（编码格式）】均改为 UTF-8，是为防止使用中文乱码的问题。 2.点击“Apply and Close”完成配置。 ④ 创建一个动态网页项目测试 1.选中 Eclipse 菜单项“New”→“Dynamic Web Project”，新建一个动态网页项目 2.在新建项目界面中 project name 处输入工程名称 second_webapp（注意 second 和 webapp 中间为下划线）。并记住此名字。在 Runtime 中选择刚刚配置的 Tomat。 3.点击“Next”按钮，并对配置不做修改，再次点击“Next”按钮，在下一个界面中，选中“Generate web.xml”选项。最后点击“Finish”按钮创建工程。 4.在 second_webapp 上点击右键，并选中“Properties”菜单项，若看到工程默认编码为 GBK，则在对话框中将工程的编码方式改为 UTF-8，目的是避免以后中文出现乱码： 5.展开 second_webapp 工程，并在“WebContent”项目上点击鼠标右键，并选中菜单项目“New”→“HTMLFile”，然后输入网页的名字 index.html，并点击“Finish”按钮： 6.此时将显示 HTML 文件内容（默认为 HTML 5 格式），编辑 index.html 文件，成如下内容：&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>我的第二个网页&lt;/title> &lt;/head> &lt;body> Java EE 环境部署成功！ &lt;/body> &lt;/html> - 7.编辑完成后，点击 Eclipse 菜单：“Run”→“Run As”→“Run on Server”**（注意：此时在 Eclipse 外面不能启动Tomcat 服务器，即 Tomcat 的命令提示窗口不能已经打开）**，在弹出的对话框中选择，刚刚配置的 Tomcat 环境，边点击“Finish”按钮启动 Tomcat 服务器： ![](https://cdn.jsdelivr.net/gh/wmyskxz/img/img/初学Java-Web（2）——搭建Java-Web开发环境/7896890-1e386be820188f6e.png) - 8.等待服务器启动完成。然后在浏览器中输入网址：http://localhost:8080/second_webapp/index.html，查看网页。如果能正确显示页面，则 Eclipse 新建项目成功。 ---- 至此，Java Web 的开发环境就已经全部搭建好了，关于为什么选择 Eclipse 而不选择 IDEA ，是因为这学期开的 Java Web 课程中使用的也是 Eclipse ，为了避免麻烦，所以还是用 Eclipse 吧。 #### 参考资料： &gt; [1.迷路的国王博客](http://www.cnblogs.com/kangjianwei101/p/5621750.html) &gt; 2.本学校的实验说明 --- &gt; 欢迎转载，转载请注明出处！ &gt; 简书ID：[@我没有三颗心脏](https://www.jianshu.com/u/a40d61a49221) &gt; github：[wmyskxz](https://github.com/wmyskxz/) &gt; 欢迎关注公众微信号：wmyskxz &gt; 分享自己的学习 &amp; 学习资料 &amp; 生活 &gt; 想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"初学Java Web(1)——Web概述","slug":"初学Java-Web-1-——Web概述","date":"2018-03-14T00:55:00.000Z","updated":"2020-12-09T04:48:44.310Z","comments":true,"path":"2018/03/14/chu-xue-java-web-1-web-gai-shu/","link":"","permalink":"http://www.wmyskxz.com/2018/03/14/chu-xue-java-web-1-web-gai-shu/","excerpt":"已经很久没有更新博客了，过年忙着吃喝玩乐，就怠惰了一小下下？幸好这学期新开的课程都比较有趣——Java Web和Android。至少对于我自己来说，既充满挑战，又富有趣味。","text":"已经很久没有更新博客了，过年忙着吃喝玩乐，就怠惰了一小下下？幸好这学期新开的课程都比较有趣——Java Web和Android。至少对于我自己来说，既充满挑战，又富有趣味。 ——【1.Web概述】——什么是Web?Web在计算机网页开发设计中就是网页的意思。网页是网站中的一个页面，我们平常浏览网站时，看到的都是一个一个的页面，通常它们都是HTML格式的。网页可以展示文字、图片、媒体等内容，而这些都是需要通过浏览器来阅读。 Web应用程序的工作原理？Web应用程序大体上可以分为两种，静态网站和动态网站。 早期的Web应用主要是静态页面的浏览，即静态网站。这些网站使用HTML描写，通常来说随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。这些代码放在Web服务器上，用户使用浏览器通过HTTP协议请求服务器上的Web页面，服务器上的Web服务器接受到用户的请求处理后，再发送给客户端浏览器，显示给用户。整个过程就像下图： 而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。这些网站通常使用HTML和动态脚本语言（入JSP、ASP或者是PHP等）编写，并将编写后的程序部署到Web服务器上，由Web服务器堆动态脚本代码进行处理，并转化成浏览器可以解析的HTML代码，返回给客户端浏览器，显示给用户。 值得一提的是：动态网页并非是那些带有动画效果的网页，而是指具有交互性、内容可以自动更新，并且内容会根据访问的时间和访问者而改变的网页。这里所说的交互性是指网页可以根据用户的要求动态改变或响应。由此可见，静态网页就像是老式的手机，只能使用系统自带的铃声和功能，而动态网页就像是现代的手机，可以自行添加/删除或者说更改铃声和其他一些设置。 ——【2.Web的发展历程】——自从1989年由 Tim Berners-Lee(蒂姆·伯纳斯·李) 发明了 World Wide Web 以来，Web 主要精力了3个阶段，分别是静态文档阶段（指代 Web 1.0）、动态网页阶段（指代 Web 1.5）和 Web 2.0 阶段。 ① 静态文档阶段处理静态文档阶段的 Web ，主要是用于静态 Web 页面的浏览。用户通过客户端的 Web 浏览器可以访问 Internet 上各个 Web 站点。在每个 Web 站点上，保存着提前编写好的 HTML 格式的 Web 页，以及各 Web 页之间可以实现跳转的超文本链接。通常情况下，这些 Web 页都是通过 HTML 语言编写的。由于受低版本 HTML 语言和旧式浏览器的制约，Web 页面只能包括单纯的文本内容，浏览器页只能显示呆板的文字信息，不过这已经基本满足了建立 Web 站点的初衷，实现了信息资源共享。 随着互联网技术的不断发展以及网上信息呈几何倍数的增长，人们逐渐发现手工编写包含所有信息和内容的页面，对人力和物理都是一种极大的浪费，而且几乎变得难以实现。另外，这样的页面也无法实现各种动态的交互功能。这就促使了 Web 技术进入了发展的第二阶段——动态网页阶段。 ② 动态网页阶段为了克服静态页面的不足，人们将传统单机环境下的编程技术与 Web 技术相结合，从而形成新的网络编程技术。网络编程技术通过在传统的静态网页中加入各种程序和逻辑控制，从而实现动态和个性化的交流与互动。我们将这种使用网络编程技术创建的页面称为动态页面。动态页面的后缀通常是.jsp、.php、和.asp等，而静态页面的后缀通常是.htm、.html和.shtml等。 ③ Web 2.0 阶段随着互联网技术的不断发展，又提出了一种新的互联网模式——Web 2.0。这种模式更加以用户为中心，通过网络应用（ Web Applications ）促进网络上人与人间的信息交换和协同合作。 Web 2.0 技术主要包括：博客（ BLOG ）、微博（ Twitter ）、维基百科全书（ Wiki ）、即时信息（ IM ）等。 ——【3.网络程序开发的体系结构】——随着 Web 2.0 时代的到来，互联网的网络架构已经从传统的 C/S 架构转变为更加方便、快捷的 B/S 架构，B/S 架构大大简化了用户使用网络应用的难度，这种人人都能上网、人人都能使用网络上提供的服务的方法也进一步推动了互联网的繁荣。 理解 C/S 和 B/S 可以通过一些实际的例子。C/S 就像是桌面 QQ 等一些运行在桌面的程序，，在服务端主要就是一个数据库，把所有业务逻辑以及界面的渲染操作交给客户端去完成。而 B/S 就是我们的浏览器，把业务逻辑交给服务端完成，客户端仅仅只做界面渲染和数据交换。 B/S 架构带来了以下两个方面的好处： 客户端使用同一的浏览器（ Browser ）。由于浏览器具有统一性，它不需要特殊的配置和网络连接，有效的屏蔽了不同服务提供商提供给用户使用服务的差异性。另外，最重要的一点，浏览器的交互特性使得用户使用它非常简便，而且用户行为的可继承性非常强，也就是用户只要学会了上网，不管使用的是哪一个应用，一旦学会了，在使用其他互联网服务时同样具有了使用经验，因为它们都是基于同样的浏览器操作界面。 服务端（ Server ）基于统一的 HTTP 。和传统的 C/S 架构使用自定义的应用层协议不同，B/S 价格使用的都是统一的 HTTP。使用同一的 HTTP 也为服务提供商简化了开发模式，使得服务器开发者可以采用相对规范的开发模式，这样可以大大节省开发成本。由于使用统一的 HTTP，所以基于 HTTP 的服务器就有很多，如 IIS、Tomcat 等，这些服务器可以直接拿来使用，不需要服务开发者单独来开发。不仅如此，连开发服务的通用框架都不需要单独开发，服务开发者只需要关注提供服务的应用逻辑，其他一切平台和框架都可以直接拿来使用，所以 B/S 架构同样简化了服务器提供者的开发，从而出现了越来越多的互联网服务。 B/S 网络架构概述B/S 网络架构从前端到后端都得到了简化，基于统一的应用层协议 HTTP 来交互数据，与大多数传统 C/S 互联网应用程序采用的长连接的交互模式不同，HTTP 采用无状态的短连接的通信方式，通常情况下，一次请求就完成了一次数据交互，通常也对应一个业务逻辑，然后这次通信连接就断开了。采用这种方式是为了能够同时服务更多的用户，因为当前互联网应用每天都会处理上亿的用户请求，不可能每个用户访问一次后就一直保持这个连接。 基于 HTTP 本身的特点，目前的 B/S 网络架构大多采用 CDN 的架构设计（如上图），既要满足海量用户的访问请求，又要保持用户请求的快速响应，所以现在的网络架构也越来越复杂。 当一个用户在浏览器里输入 www.taobao.com 这个 URL 时，将会发生很多操作。首先它会请求 DNS 吧这个域名解析成对应的 IP 地址，然后根据这个 IP 地址在互联网上找到相对应的服务器，向这个服务器发起一个 get 请求，由这个服务器决定返回默认的数据资源给访问的用户。在服务器端实际上还有很复杂的业务逻辑：服务器可能有很多台，到底指定哪一台服务器来处理请求，这需要一个负载均衡设备来平均分配所有用户的请求；还有请求的数据是存储在分布式缓存里还是一个静态文件中，或是在数据库里；当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（ 如 CSS 、JS 或者图片 ）时又会发起另外的 HTTP 请求，而这些请求很可能会在 CDN 上，那么 CDN 服务器又会处理这个用户的请求，大体上一个用户请求会设计这么多的操作。每一个细节都会影响这个请求最终是否会成功。 不管网络架构如何变化，时钟有一些固定不变的原则需要遵守。 互联网上所有资源都要用一个 URL 来表示。URL 就是同意资源定位符，如果你要发布一个服务或者一个资源到互联网上，让别人能够访问到，那么你首先必须要有一个在世界上独一无二的 URL 。不要小看这个 URL ，它几乎包含了整个互联网的架构精髓。 必须基于 HTTP 与服务端交互。不管你要访问的事国内的还是国外的数据，是文本数据还是流媒体，都必须按照套路出牌，也就是都得采用统一打招呼的方式，这样人家才会明白你要的是什么。 数据展示必须在浏览器中进行。当你获取到数据资源后，必须在浏览器上才能恢复它的容貌。 只要满足上面的几点，一个互联网应用基本上就能正确地运行起来了，当然这里面还有很多细节。 参考资料：①《Java Web 程序设计 慕课版——明日科技·出品》②《深入分析Java Web技术内幕——许令波 著》 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}],"author":"我没有三颗心脏"},{"title":"Java 8——函数式数据处理（流）","slug":"Java-8——函数式数据处理（流）","date":"2018-01-01T15:54:00.000Z","updated":"2020-12-09T05:03:55.761Z","comments":true,"path":"2018/01/01/java-8-han-shu-shi-shu-ju-chu-li-liu/","link":"","permalink":"http://www.wmyskxz.com/2018/01/01/java-8-han-shu-shi-shu-ju-chu-li-liu/","excerpt":"本篇内容大部分来自《Java 8实战》","text":"本篇内容大部分来自《Java 8实战》 流是什么？流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时写一个实现）。 就现在来说，你可以把它们看成遍历数据集合的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码！ 下面两段代码都是用来返回低热量的菜肴名称的，并按照卡路里排序，一个使用java 7写的，另一个是用java 8的流写的，比较一下，不用太关心java 8的语法： 现在，你可以看出，从软件工程师的角度来看，新的方法有几个显而易见的好处。 代码是以声明性方式写的：说明想要完成什么（筛选热量低的菜肴）而不是说明如何实现一个操作（利用循环和if条件等控制流语句）。这种方法加上行为参数化让你可以轻松应对变化的需求：你很容易创建一个代码版本，利用Lambda表达式来筛选高卡路里的菜肴，而用不着去复制粘贴代码。 你可以把几个基础操作链接起来，来表达复杂的数据处理流水线（在filter后面接上sorted、map和collect操作），同时保持代码清晰可读。 因为filter、sorted、map和coleect等操作是与具体线程模型无关的高层次构件，所以它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构！在实践中，这意味着你用不着为了让某些数据处理任务并行而去操心线程和锁了，Steam API都替你做好了！ 并且新的Steam APi表达能力非常强，能写出例如下面这样的代码： Map&lt;Dish.Type, List&lt;Dish>> dishesByType = menu.steam().collect(groupingBy(Dish::getType)); 流简介要讨论流，就要先来讨论集合，这是最容易上手的方式了。Java 8中的集合支持一个新的stream方法，它会返回一个流（接口定义在java.util,steam.Steam里）。 那么，流到底是什么呢？简短的定义就是“从支持数据处理操作的源，生成的元素序列”。Oh，听上去就让人头大。让我们一步步来剖析这个定义： 让我们来看一段能够体现所有这些概念的代码： 在本例中，我们先是对menu调用steam方法，由菜单得到一个流。数据源是菜肴列表（菜单），它给流提供一个元素序列。接下来，对流应用一系列数据处理操作：filter、map、limit和collect。 除了collect之外，所有这些操作都会返回另一个流，这样它们就可以竭诚一条流水线，于是就可以看作对源的一个查询。最后，collect操作开始处理流水线，并返回结果。下图展示了该流操作的每个操作的简介： 感觉像不像变魔术呢？不过至少看起来，是挺酷的。 集合与流 上图很好的说明了在Java 8中的集合与流的关系，集合就像是DVD一样，保存了完整的数据结构和所有的值，而流则像是现在视频网站中的视频那样，不必提前下好完整的视频，只需要提前下载好用户播放位置的那几帧就好了。 请注意：流和迭代器一样，都只能遍历一次。 流操作java.util.steam.Steam中的Steam接口定义了许多操作。它们可以分为两大类，一类是中间操作，另一类是终端操作。 为了方便，下面总结了一些Steam API提供的操作： 流的使用一般包括三件事： 一个数据源（如集合）来执行一个查询； 一个中间操作链，形成一条流的流水线； 一个终端操作，执行流水线，并能生成结果 流的流水线背后的理念有点类似于构建器模式。 至此，流的基本操作就已经阐述完全了，相信你已经同我一样对Java 8的新特性感到兴奋了吧，不可避免，因为这实在是太酷啦！ 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java 8——Lambda表达式","slug":"Java-8——Lambda表达式","date":"2017-12-27T15:53:00.000Z","updated":"2020-12-09T05:04:04.538Z","comments":true,"path":"2017/12/27/java-8-lambda-biao-da-shi/","link":"","permalink":"http://www.wmyskxz.com/2017/12/27/java-8-lambda-biao-da-shi/","excerpt":"本文内容大部分来自《Java 8实战》一书 前言在上一篇文章中，我们了解了利用行为参数化来传递代码有助于应对不断变化的需求，它允许你定义一个代码块来表示一个行为，然后传递它。一般来说，利用这个概念，你就可以编写更为灵活且可重复使用的代码了。 但是你同时也看到，使用匿名类来表示不同的行为并不令人满意：代码十分啰嗦，这会影响程序员在时间中使用行为参数化的积极性。Lambda表达式很好的解决了这个问题，它可以让你很简洁地表示一个行为或传递代码。现在你可以把Lambda表达式看作匿名功能，它基本上就是没有声明名称的方法，但和匿名类一样，它也可以作为参数传递给一个方法。","text":"本文内容大部分来自《Java 8实战》一书 前言在上一篇文章中，我们了解了利用行为参数化来传递代码有助于应对不断变化的需求，它允许你定义一个代码块来表示一个行为，然后传递它。一般来说，利用这个概念，你就可以编写更为灵活且可重复使用的代码了。 但是你同时也看到，使用匿名类来表示不同的行为并不令人满意：代码十分啰嗦，这会影响程序员在时间中使用行为参数化的积极性。Lambda表达式很好的解决了这个问题，它可以让你很简洁地表示一个行为或传递代码。现在你可以把Lambda表达式看作匿名功能，它基本上就是没有声明名称的方法，但和匿名类一样，它也可以作为参数传递给一个方法。 Lambda管中窥豹可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它由参数列表、函数主体、返回类型，可能还有一个抛出的异常列表。 Lambda表达式鼓励你采用上一篇文章中提到的行为参数化风格，最终结果就是你的额代码变得更加清晰、更加灵活。比如，利用Lambda表达式，你可以更为简洁地自定义一个Comparator对象： 不得不承认，代码看起来更清晰了。要是现在觉得Lambda表达式看起来一头雾水的话也没关系，很快就会一点点的解释清楚的。现在，请注意你基本上只传递了比较两个苹果重量所需要的代码。看起来就像只传递了compare方法的主体。你很快就会学到，你甚至还可以进一步简化代码。 为了进一步说明，下面给出了Java 8五个有效的Lambda表达式的例子： Java语言设计者选择这样的语法，是因为C#和Scala等语言中的类似功能广受欢迎。Lambda的基本语法是： (parameters) -> expression 或（请注意语句的花括号） (parameters) -> { statements; } 你可以看到，Lambda表达式的语法很简单，我们下来来测试一下你对这个模式的了解程度： 在哪里以及如何使用Lambda现在你可能在想，在哪里可以使用Lambda表达式。直接公布答案：你可以在函数式接口上使用Lambda表达式。 函数式接口还记得上一篇文章中，为了参数化filter方法的行为而创建的Predicate接口吗？它就是一个函数式接口！为什么呢？因为Predicate仅仅定义了一个抽象方法： public interface Predicate&lt;T>{ boolean test(T t); } 一言以蔽之，函数式接口就是之定义一个抽象方法的接口。你已经知道了Java API中的一些其他函数式接口，如Comparator和Runnable public interface Comparator&lt;T>{ int compare(T o1, T o2); } public interface Runnable{ void run(); } 接口现在还可以拥有默认方法（即在类没有对方法进行是现实时，其主体为方法提供默认实现的方法，如List的sort方法）。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。 为了检测是否掌握了函数式接口的概念，我们来看一个小测试： 用函数式接口可以干什么呢？Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。这听上去可能有些绕口，但是联想到上一篇文章中的Lambda表达式改造的语句，或许就会清晰许多，它不同于使用匿名内部类来完成时的笨拙，而是更加清晰直接： 你可能会想：“为什么只有在需要函数式接口的时候才可以传递Lambda呢？”语言的设计者也考虑过其他方法，例如给Java添加函数类型，但最终他们选择了现在这种方式，因为这种方式自然且能避免语言变得更加复杂。此外，大多数Java程序员都已经熟悉了具有一个抽象方法的接口的理念（例如事件处理）。 把Lambda付诸实践：环绕执行模式让我们通过一个例子，看看在实践中如何利用Lambda和行为参数化来让代码更为灵活，更为简洁。资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。这个设置和清理阶段总是很相似，并且会围绕着执行处理的那些重要代码。这就是所谓的环绕执行（execute around）模式： 第一步：记得行为参数化现在这段代码时有局限的。你只能读文件的第一行。如果你想要返回头两行，甚至返回使用最频繁的词，该怎么办呢？在理想的情况下，你要重用执行设置和清理的代码，并告诉processFile方法对文件执行不同的操作。这听起来是不是很耳熟？是的，你需要把processFile的行为参数化。你需要一种方法把行为传递给processFile，以便它可以利用BufferedReader执行不同的行为。 传递行为正是Lambda的拿手好戏。那要是想一次读两行，这个新的processFile方法看起来又该是什么样的呢？基本上，你需要一个接受BufferedReader并返回String的Lambda。例如，下面就是从BufferedReader中打印两行的写法： String result = processFile((BufferedReader br) -> br.readLine() + br.readLine()); 第二步：使用函数式接口来传递行为前面已经解释过了，Lambda仅可用于上下文是函数式接口的情况。你需要创建一个能匹配BufferedReader -&gt; String，还可以抛出IOException异常的接口。让我们把这一接口叫做BufferedReaderProcessor吧。 @FunctionalInterface public interface BufferedReaderProcessor{ String process(BufferedReader b) throws IOException; } @FunctionalInterface 标注表示该接口会设计成一个函数式接口。如果你用此标注定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。 现在你就可以把这个接口作为新的processFile方法的参数了： public static String processFile(BufferedReaderProcessor p) throws IOException{ ... } 第三步：执行一个行为任何BufferedRader -&gt; String形式的Lambda都可以作为参数来传递，因为它们符合BufferedReaderProcessor接口中定义的process方法的签名。现在你只需要一种方法在processFile主体内执行Lambda所代表的代码。请记住，Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。因此，你可以在processFile主体内，对得到的BufferedReaderProcessor对象调用process方法执行处理： public static String processFile(BufferedReaderProcesssor p) throws IOException{ try(BufferedReader br = new BufferedReader(new FileReader(\"data.txt\"))){ return p.process(br); } } 第四步：传递Lambda现在你就可以通过传递不同的Lambda重用processFile方法，并以不同的方式处理文件了： 下面的图片总结了所采取的使processFile方法更加灵活的四个步骤： 使用函数式接口如你所见的，函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名。Java 8的库设计师帮你在java.util.function包中引入了几个新的函数式接口。 Predicatejava.util.function.Predicate接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。在你需要一个涉及类型T的布尔表达式时，就可以使用这个接口： Consumerjava.util.function.Consumer定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用这个接口： Functionjava.util.function.Function&lt;T,R&gt;接口定义了一个叫做apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果你需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）： 还有更为丰富的一些函数式接口，这里列举了三个比较有代表性的。 方法引用方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。在一些情况下，比起使用Lambda表达式，它们似乎更易读，感觉也更自然。下面就是借助Java 8API，用方法引用写的一个排序的例子： 是不是更酷了？念起来就是“给库存排序，比较苹果的重量”，这样的代码读起来简直就像是在描述问题本身，太酷了。 为什么要关心方法引用呢？方法引用可以被看作调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的知识“直接调用这个方法”，拿最好还是用名称来调用它，而不是去描述如何调用它。 事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式，但是，显式地指明方法的名称，你的代码可读性会更好。 它是如何工作的呢？当你需要使用方法引用时，目标引用放在分隔符** :: **前，方法的名称放在后面。例如，Apple::getWeight就是引用了Apple类中定义的方法getWeight。请记住，不需要括号，因为你没有实际调用这个方法，方法引用就是Lambda表达式(Apple a) -&gt; a.getWeight()的快捷写法。 下面给出一些在Java 8中方法引用的例子来让你更加了解： 你可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖，因为你表达同样的事情时写的代码更少了。 Lambda 和方法引用实战我们继续来研究开始的那个问题——用不同的排序策略给一个Apple列表排序，并展示如何把一个原始粗暴的解决方案转变得更为简明：inventory.sort(comparing(Apple::getWeight)); 第一步：传递代码很幸运，Java 8的API已经为你提供了一个List可用的sort方法，你不用自己去实现它。那么最困难的部分已经搞定了！但是，如何把排序的策略传递给sort方法呢？你看，sort方法的签名是这样的： void sort(Comparator&lt;? super E&gt; c) 它需要一个Comparator对象来比较两个Apple！这就是在Java中传递策略的方式：它们必须包裹在一个对象里。我们说sort的行为被参数化了：传递给它的排序策略不同，其行为也会不同。 你的第一个解决方案看上去是这样的： public class AppleComparator implements Comparator&lt;Apple>{ public int compare(Apple a1, Apple a2){ return a1.getWeigh().compareTo(a2.getWeight()); } } inventory.sort(new AppleComparator()); 第二步：使用匿名类你可以使用匿名类来改进解决方案，而不是实现一个Comparator却只实例化一次： inventory.sort(new Comparator&lt;Apple>(){ public int compare(Apple a1, Apple a2){ return a1.getWeight().compareTo(a2.getWeight()); } }); 第三步：使用Lambda表达式但你的解决方案仍然挺啰嗦的。使用Java 8引入的Lambda改进后的代码如下： inventory.sort((a1, a2) -> a1.getWeight().compareTo(a2.getWeight())); 你的代码还能变得更易读一点吗？Comparator具有一个叫做comparing的静态辅助方法，它可以接受一个Function来提取Comparable键值，并生成一个Comparator对象。它可以像下面这样用： Comparator&lt;Apple&gt; c = Comparator.comparing((Apple a1) -&gt; a.getWeight()); 现在你可以把代码再改得紧凑一点了： import static java.util.Comparator.comparing; inventory.sort(comparing((a) -> a.getWeight())); 第四步：使用方法引用前面解释过，方法引用就是替代那些转发参数的Lambda表达式的语法糖。你可以用方法引用让你的代码更加简洁（假设你已经静态导入了java.util.Comparator.comparing）： inventory.sort(comparing(Apple::getWeight)); 恭喜你，这就是你的最终解决方案！这笔Java 8之前的代码好在哪儿呢？它比较短；它的意思也很明显，并且代码读起来和问题描述差不多：“对库存进行排序，比较苹果的重量。” 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java 8——行为参数化","slug":"Java-8——行为参数化","date":"2017-12-26T15:52:00.000Z","updated":"2020-12-09T05:03:58.579Z","comments":true,"path":"2017/12/26/java-8-xing-wei-can-shu-hua/","link":"","permalink":"http://www.wmyskxz.com/2017/12/26/java-8-xing-wei-can-shu-hua/","excerpt":"前言《Java8实战》不得不说是一本好书，捧起来看起来就兴奋得不想放下，其中介绍的函数式编程实在是太令人兴奋了，不仅仅大大提高了代码的可读性，而且提高了代码的重用性，并且语法简单。 Java 8中新增的功能是自Java 1.0发布以来18年以来，发生变化最大的一次。我本身没有太大的体会，但新增的这些功能，每一个都让我兴奋，这里就书中的内容简单的介绍一下Java 8的这些新特性，我相信很快，你也会有跟我一样的感受。","text":"前言《Java8实战》不得不说是一本好书，捧起来看起来就兴奋得不想放下，其中介绍的函数式编程实在是太令人兴奋了，不仅仅大大提高了代码的可读性，而且提高了代码的重用性，并且语法简单。 Java 8中新增的功能是自Java 1.0发布以来18年以来，发生变化最大的一次。我本身没有太大的体会，但新增的这些功能，每一个都让我兴奋，这里就书中的内容简单的介绍一下Java 8的这些新特性，我相信很快，你也会有跟我一样的感受。 （1）用行为参数化把代码传递给方法Java 8中增加了通过API来传递代码的能力，但这实在听起来太绕了，这到底在说什么！打个比方或许要容易理解一些，你想要写两个只有几行代码不同的方法，那现在你只需要把不同的那部分代码作为参数传递进去就可以了。 在Java 8中，这样做起来（不止于匿名类）远远比你想象的要来得更加清晰、简洁。行为参数化 我们现在来考虑这样一个例子：有个应用程序是帮助农民了解自己的库存的，这位农民可能想有一个查找库存中所有绿色苹果的功能。但到了第二天，他可能会告诉你：“其实我还想找出所有重量超过150克的苹果”。又过了两天，他可能会继续补充道：“要是我可以找出所有既是绿色，重量也超过150克的苹果，那就太棒了。” 想一下你应该如何应对这样不断变化的需求呢？理想的状态下，你应该把你的工作量降到最小，此外类似的新功能实现起来还应该很简单，而且易于长期维护。 第一次尝试：筛选绿苹果第一个解决方案可能是下面这样的: public static List&lt;Apple> filterGreenApples(List&lt;Apple> inventory){ List&lt;Apple> result = new ArrayList&lt;>(); for(Apple apple: inventory){ if( “green”.equals(apple.getColor()) { result.add(apple); } } // end for return result; } 这样的代码看起来似乎也没什么问题，也很容易看懂，但是现在农民改主意了，他还想要筛选红苹果，又该怎么做呢？简单的方法就是复制这个方法，然后把函数名称和if判断的条件来分别匹配到红苹果上就可以了。然而，要是农民想要筛选出多种颜色：浅绿色，暗红色、黄色等，这种方法就应付不了了。一个良好的原则是在编写类似的代码之后，尝试将其抽象化。 第二次尝试：把颜色作为参数一种做法是给方法加一个参数，把颜色变成参数，这样就灵活地适应了变化： public static List&lt;Apple> filterApplesByColor(List&lt;Apple> inventory,String color){ List&lt;Apple> result = new ArrayList&lt;>(); for(Apple apple: inventory){ if(apple.getColor().equals(color)){ result.add(apple); } } // end for return result; } 现在，只要像下面这样调用方法，农民朋友就会满意了： List&lt;Apple&gt; greenApples = filterApplesByColor(inventory,&quot;green&quot;); List&lt;Apple&gt; greenApples = filterApplesByColor(inventory,&quot;red&quot;); ....太简单了对吧？让我们把案例变得复杂一点。这位农民又跑回来和你说：“要是能区分轻的苹果和重的苹果就太好了。重的苹果一般大于150克。” 作为软件工程师，你早就想好了农民可能会要改变重量，于是你写了下面的方法，用另一个参数来应对不同的重量： public static List&lt;Apple> filterApplesByColor(List&lt;Apple> inventory,int weight){ List&lt;Apple> result = new ArrayList&lt;>(); for(Apple apple: inventory){ if(apple.getWeight() > weight){ result.add(apple); } } // end for return result; } 解决方案不错，但是请注意，你赋值了大部分的代码来实现遍历库存，并对每个苹果应用筛选条件。这有点儿令人失望，因为它打破了DRY（Don’t Repeat Yourself,不要重复你自己）的软件工程原则。 如果你想要改变筛选遍历方式来提升性能呢？那就得修改所有方法的实现，而不是只改变一个。从工程工作量的角度来看，这代价太大了。 你可以将颜色和重量结合为一个方法，称为filter。不过就算这样，你还是需要一种方式来区分想要筛选哪个属性。你可以加上一个标志位来区分对颜色和重量的查询（但绝不要这样做！很快你就会明白为什么）。 第三次尝试：对你想到的每个属性做筛选一种把所有属性结合起来的笨拙尝试如下： public static List&lt;Apple> filterApples(List&lt;Apple> inventory, String color, int weight, boolean flag){ List&lt;Apple> result = new ArrayList&lt;>(); for(Apple apple: inventory){ if((flag &amp;&amp; apple.getColor.equals(color)) || (!flag &amp;&amp; apple.getWeight() > weight)){ result.add(apple); } } // end for return result; } 你可以这么用（但真的很笨拙）: List&lt;Apple> greenApples = filterApples(inventory, \"green\", 0, ture); List&lt;Apple> heavyApples = filterApples(inventory, \"\", 150, false); 这样的解决方案再差不过了。 首先，客户端代码看上去糟糕透了，ture和false是什么意思？此外，这个解决方案还是不能很好的应对变化的需求。如果这位农要求你对苹果的不同属性做筛选，比如大小、形状、产地等，又怎么办？而且，如果农民要求你组合属性，做更复杂的查询，比如绿色的种苹果，又改怎么办？你会有好多个重复的filter方法，或者一个巨大的非常复杂的方法。 到目前为止，你已经给filterApples方法加上了值（如String、Integer或boolean）的参数。这对于某些确定性问题可能还不错，但如今这种情况下，你需要一种更好的方式，来把苹果的选择标准告诉你的filterApples方法。 这就是需要行为参数化登场发挥作用的地方了。让我们后退一步来看看更高层次的抽象。一种可能的解决方案是对你的选择标准建模：你考虑的是苹果，需要根据Apple的某些属性（比如它是绿色的吗？重量超过150克吗？）来返回一个boolean值，我们把它称为谓词（即一个返回boolean值得函数）。 第四次尝试：根据抽象条件筛选让我们先来定义一个接口对选择标准建模： public interface ApplePredicate{ boolean test (Apple apple); } 现在你可以使用ApplePredicate的多个实现代表 不同的选择标准了，比如： 你可以把这些标准看作filter方法的不同行为。你刚做的这些和“策略设计模式”相关，它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。在这里算法簇就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。 但是，该怎么利用ApplePredicate的不同实现呢？你需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：让方法接受多种行为（或战略）作为参数，并在内部使用，完成不同的行为。 利用ApplePredicate改过之后，filter方法看起来就是这样的： public static List&lt;Apple> filterApples(List&lt;Apple> inventory, ApplePredicate p){ List&lt;Apple> result = new ArrayList&lt;>(); for(Apple apple:inventory){ if(p.test(apple)){ result.add(apple); } // end if } // end for return result; } 这里值得暂停下来小小地庆祝一下。这段代码比我们第一次尝试的时候灵活多了，读起来、用起来也更容易！现在你可以创建不同的ApplePredicate对象，并将它们传递给filterApples方法。免费的灵活性！比如，如果农民让你找出所有重量超过150克的红苹果，你只需要创建一个类来实现ApplePredicacte对象就可以了，你的代码现在足够灵活，可以应对任何涉及苹果属性的需求变更了。 你已经做成了一件很酷的事：filterApples方法的行为取决于你通过ApplePredicate对象传递的代码，换句话说，你把filterApples方法的行为参数化了！ 第五次尝试：使用匿名类这样做起来已经很棒了，还有什么问题呢？ 我们都知道，人们都不愿意用那些很麻烦的功能或者概念，目前，当要把新的行为传递给filterApples方法的时候，你不得不声明好几个实现ApplePredicate接口的类，然后实例化好几个只会提到一次的ApplePredicate对象。下面这段程序总结了你目前看到的一切，这真的很啰嗦而且费时间： 费这么大劲儿，真的没什么必要。能不能做得更好呢？Java有一个机制称为匿名类，它可以让你同时声明和实例化一个类，它可以帮助你进一步改善代码，让它变得更简洁： List&lt;Apple> redApples = filterApples(inventory, new Applepredicate(){ public boolean test(Apple apple){ return \"red\".equals(apple.getColor()); } }); GUI应用程序中经常使用匿名类来创建事件处理器对象（下面的例子使用的是JavaFX API,一种现代的Java UI平台）： button.setOnAction(new EventHandler&lt;ActionEvent>(){ public void handle(ActionEvent event){ System.out.println(\"Woooo a click!\"); } }); 但是匿名类仍然不够好。 第一，它往往很笨重，因为它占用了很多空间，还拿前面的例子来说： 第二，很多程序员觉得它用起来很让人费解，比如这里有一道经典的Java谜题，它让大多数程序员都措手不及，来试试看： 答案是5，因为this指的是包含它的Runnable，而不是外面的类MeaningOfThis。 整体来说，啰嗦就不好。它让人不愿意使用语言的某种功能，因为编写和维护啰嗦的代码需要很长时间，而且代码也不易读。好的代码应该一目了然。 即使匿名类处理在某种程度上改善了为一个接口声明好几个实体类的啰嗦问题，但它仍然不能让人满意。在只需要传递一段简单的代码时（例如表示选择标准的boolean表达式），你还是要创建一个对象，明确地实现一个方法来定义一个新的行为（例如Predicate中的test方法或者是EventHandler中的handler方法）。 在理想的情况下，我们想鼓励程序员使用行为参数化模式，因为正如你在前面看到的，它让代码更能适应需求的变化，但也同样的，啰嗦不可避免。这也正是Java 8的语言设计者引入Lambda表达式的原因——他让传递代码的方式变得更加简洁、干净。 第六次尝试：使用Lambda表达式上面的代码在Java 8里可以用Lambda表达式重写为下面的样子： List&lt;Apple> result = filterApples(inventory, (Apple apple) -> \"red\".equals(apple.getColor())); 不得不承认这代码看上去比先前干净很多，这很好，因为它看起来更像问题陈述本身了。我们现在已经解决了啰嗦的问题，下图总结了到目前为止的工作： 第七次尝试：将List类型抽象化在通往抽象的道路上，我们还可以更近一步。目前filterApples方法还只适用于Apple。你还可以将List类型抽象画，从而超越你眼前要处理的问题： public interface Predicate&lt;T>{ boolean test(T t); } public static &lt;T> List&lt;T> filter(List&lt;T> list, Predicate&lt;T> p){ List&lt;T> result = new ArrayList&lt;>(); for(T e:list){ if(p.test(e)){ result.add(e); } // end if } // end for return result; } 现在你可以把filter方法用在香蕉、桔子、Integer或者是String的列表上了。这里有一些使用Lambda表达式的例子： List&lt;Apple> redApples = filter(inventory, (Apple apple) -> \"red\".equals(apple.getColor())); List&lt;Integer> evenNumbers = filter(numbers, (Integer i) -> i % 2 == 0); 酷不酷？你现在在灵活性和简洁性之间找到了最佳平衡点，这在Java 8之前是不可能做到的！ 应用行为参数化的典型例子 一个是用Runnable执行代码块，用Lambda表达式的话，看起来就是这个样子的： Thread t = new Thread(() -> System.out.println(\"Hello world\")); 另一个就是GUI事件处理： button.setOnAction((ActionEvent event) -> label.setText(\"Sent!!\")); 看起来酷极了吧？不过想要熟练地运用，就要足够了解Lambda表达式，这将在下一节中再来说。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"Java 7的新特性","slug":"Java-7的新特性","date":"2017-11-20T15:51:00.000Z","updated":"2020-12-09T05:03:47.510Z","comments":true,"path":"2017/11/20/java-7-de-xin-te-xing/","link":"","permalink":"http://www.wmyskxz.com/2017/11/20/java-7-de-xin-te-xing/","excerpt":"前言 看大佬推荐的书单买了一本《Java 8实战》，总觉得在了解Java 8之前，是不是也应该去了解了解一下Java 7的一些特性？所以就自己百度了一些资料来学习。","text":"前言 看大佬推荐的书单买了一本《Java 8实战》，总觉得在了解Java 8之前，是不是也应该去了解了解一下Java 7的一些特性？所以就自己百度了一些资料来学习。 当然还是要先看看官方文档啦 这里是详细介绍（缺点是全英文的，貌似还不是官方的，不过很详细）：https://www.oreilly.com/learning/java7-features下面大部分内容均来自这一篇文章，翻译一下而已。 戳进去看看，大概还是能看懂的，看到有博客说Java 7大部分的特性都是语法糖。 1.Diamond Operator类型判断是一个人特殊的烦恼，入下面的代码： Map&lt;String,List&lt;String>> anagrams = new HashMap&lt;String,List&lt;String>>(); 通过类型推断后变成： Map&lt;String,List&lt;String>> anagrams = new HashMap&lt;>(); 注：这个&lt;&gt;被叫做diamond(钻石)运算符，Java 7后这个运算符从引用的声明中推断类型。 2.在switch语句中使用字符串switch语句可以使用原始类型或枚举类型。Java引入了另一种类型，我们可以在switch语句中使用：字符串类型。 说我们有一个根据其地位来处理贸易的要求。直到现在，我们使用if-其他语句来完成这个任务。 private voidprocessTrade(Trade t){ String status = t.getStatus(); if(status.equalsIgnoreCase(NEW)) { newTrade(t); } else if(status.equalsIgnoreCase(EXECUTE)) { executeTrade(t); } else if(status.equalsIgnoreCase(PENDING)) { pendingTrade(t); } } 这种处理字符串的方法是粗糙的。在Java中，我们可以使用增强的switch语句来改进程序，该语句以String类型作为参数。 public voidprocessTrade(Trade t) { String status = t.getStatus(); switch(status) { caseNEW: newTrade(t); break; caseEXECUTE: executeTrade(t); break; casePENDING: pendingTrade(t); break; default: break; } } 在上面的程序中，状态字段总是通过使用 String.equals() 与案例标签来进行比较。 3.自动资源管理Java中有一些资源需要手动关闭，例如Connections，Files，Input/OutStreams等。通常我们使用 try-finally 来关闭资源： public voidoldTry() { try{ fos= newFileOutputStream(\"movies.txt\"); dos= newDataOutputStream(fos); dos.writeUTF(\"Java 7 Block Buster\"); } catch(IOException e) { e.printStackTrace(); } finally{ try{ fos.close(); dos.close(); } catch(IOException e) { // log the exception } } } 然而，在Java 7中引入了另一个很酷的特性，可以自动管理资源。它的操作也很简单，我们所要做的就是在 try 块中申明资源如下： try(resources_to_be_cleant){ // your code } 以上方法与旧的 try-finally 能最终写成下面的代码： public voidnewTry() { try(FileOutputStream fos = newFileOutputStream(\"movies.txt\"); DataOutputStream dos = newDataOutputStream(fos)) { dos.writeUTF(\"Java 7 Block Buster\"); } catch(IOException e) { // log the exception } } 上面的代码也代表了这个特性的另一个方面：处理多个资源。FileOutputStream 和 DataOutputStream 在try语句中一个接一个地含在语句中，每一个都用分号(;)分隔符分隔开。我们不必手动取消或关闭流，因为当空间存在try块时，它们将自动关闭。 在后台，应该自动关闭的资源必须试验 java.lang.AutoCloseable 接口。 任何实现 AutoCloseable 接口的资源都可以作为自动资源管理的候选。AutoCloseable 是 java.io.Closeable 接口的父类，JVM会在程序退出try块后调用一个方法 close()。 4.带下划线的数字文本数字文字绝对是对眼睛的一种考验。我相信，如果你给了一个数字，比如说，十个零，你就会像我一样数零。如果不计算从右到左的位置，识别一个文字的话，就很容易出错，而且很麻烦。Not anymore。Java在识别位置时引入了下划线。例如，您可以声明1000，如下所示： int thousand = 1_000; 或1000000(一百万)如下: int million = 1_000_000 请注意，这个版本中也引入了二进制文字-例如“0b1”-因此开发人员不必再将它们转换为十六进制。 5.改进的异常处理在异常处理区域有几处改进。Java引入了多个catch功能，以使用单个抓到块捕获多个异常类型。 假设您有一个方法，它抛出三个异常。在当前状态下，您将分别处理它们，如下所示： public voidoldMultiCatch() { try{ methodThatThrowsThreeExceptions(); } catch(ExceptionOne e) { // log and deal with ExceptionOne } catch(ExceptionTwo e) { // log and deal with ExceptionTwo } catch(ExceptionThree e) { // log and deal with ExceptionThree } } 在一个catch块中逐个捕获一个连续的异常，看起来很混乱。我还看到了捕获十几个异常的代码。这是非常低效和容易出错的。Java为解决这只丑小鸭带来了新的语言变化。请参阅下面的方法oldMultiCatch方法的改进版本： public voidnewMultiCatch() { try{ methodThatThrowsThreeExceptions(); } catch(ExceptionOne | ExceptionTwo | ExceptionThree e) { // log and deal with all Exceptions } } 多个异常通过使用 “|”操作符在一个catch块中捕获。这样，您不必编写数十个异常捕获。但是，如果您有许多属于不同类型的异常，那么您也可以使用“多个catch块”块。下面的代码片段说明了这一点： public voidnewMultiMultiCatch() { try{ methodThatThrowsThreeExceptions(); } catch(ExceptionOne e) { // log and deal with ExceptionOne } catch(ExceptionTwo | ExceptionThree e) { // log and deal with ExceptionTwo and ExceptionThree } } 在上面的例子中，在和ExceptionThree属于不同的层次结构，因此您希望以不同的方式处理它们，但使用一个抓到块。 6.New file system API(NIO 2.0)那些使用Java的人可能还记得框架引起的头痛。在操作系统或多文件系统之间无缝地工作从来都不是一件容易的事情.。有些方法，例如删除或重命名，在大多数情况下都是出乎意料的。使用符号链接是另一个问题。实质上API需要大修。 为了解决上述问题，Java引入了一个新的API，并在许多情况下引入了新的api。 在NIO2.0提出了许多增强功能。在处理多个文件系统时，它还引入了新的类来简化开发人员的生活。 Working With Path（使用路径）新的 java.nio.file 由包和接口组成例如：Path,Paths,FileSystem,FileSystems等等。 路径只是对文件路径的简单引用。它与java.io.File等价(并具有更多的特性)。下面的代码段显示了如何获取对“临时”文件夹的路径引用： public voidpathInfo() { Path path= Paths.get(\"c:\\Temp\\temp\"); System.out.println(\"Number of Nodes:\"+ path.getNameCount()); System.out.println(\"File Name:\"+ path.getFileName()); System.out.println(\"File Root:\"+ path.getRoot()); System.out.println(\"File Parent:\"+ path.getParent()); } 最终控制台的输出将是: Number of Nodes:2 File Name:temp.txt File Root:c: File Parent:c:Temp 删除文件或目录就像在文件中调用delete方法(注意复数)一样简单。在类公开两个删除方法，一个抛出NoSuchFileException，另一个不抛。 下面的delete方法调用抛出NoSuchFileException，因此您必须处理它： Files.delete(path); Where as Files.deleteIfExists(path) does not throw exception (as expected) if the file/directory does not exist. 使用 Files.deteleIfExists(path) 则不会抛出异常。 您可以使用其他实用程序方法，例如Files.copy(.)和Files.move(.)来有效地对文件系统执行操作。类似地，使用 createSymbolicLink(..) 方法使用代码创建符号链接。 文件更改通知JDK 7中最好的改善算是File change notifications（文件更改通知）了。这是一个长期等待的特性，它最终被刻在NIO 2.0中。WatchService API 允许您在对主题(目录或文件)进行更改时接收通知事件。 具体的创建步骤就不给了，总之它的功能就跟它的名字一般，当文件发生更改的时候，能及时作出反馈。 7.Fork and Join（Fork/Join框架）在一个java程序中有效地使用并行内核一直是一个挑战。很少有国内开发的框架将工作分配到多个核心，然后加入它们来返回结果集。Java已经将这个特性作为Fork/Join框架结合了起来。 基本上，在把手头的任务变成了小任务，直到小任务简单到可以不进一步分手的情况下解决。这就像一个分而治之的算法.。在这个框架中需要注意的一个重要概念是，理想情况下，没有工作线程是空闲的。他们实现了一个 work-stealing 算法，在空闲的工人“偷”工作从那些工人谁是忙。 支持Fork-Join机制的核心类是ForkJoinPool和ForkJoinTask。 这里是Java 7的新特性一览表：http://www.oschina.net/news/20119/new-features-of-java-7 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"}],"author":"我没有三颗心脏"},{"title":"《编写高质量代码》学习笔记(3)","slug":"《编写高质量代码》学习笔记-3","date":"2017-11-19T15:49:00.000Z","updated":"2020-12-09T03:20:47.634Z","comments":true,"path":"2017/11/19/bian-xie-gao-zhi-liang-dai-ma-xue-xi-bi-ji-3/","link":"","permalink":"http://www.wmyskxz.com/2017/11/19/bian-xie-gao-zhi-liang-dai-ma-xue-xi-bi-ji-3/","excerpt":"","text":"建议125：优先选择线程池在Java1.5之前，实现多线程比较麻烦，需要自己启动线程，并关注同步资源，防止出现线程死锁等问题，在1.5版本之后引入了并行计算框架，大大简化了多线程开发。我们知道一个线程有五个状态：新建状态(NEW)、可运行状态(Runnable，也叫作运行状态)、阻塞状态(Blocked)、等待状态(Waiting)、结束状态(Terminated)，线程的状态只能由新建转变为了运行状态后才能被阻塞或等待，最后终结，不可能产生本末倒置的情况，比如把一个结束状态的线程转变为新建状态，则会出现异常，例如如下代码会抛出异常： public static void main(String[] args) throws InterruptedException { // 创建一个线程，新建状态 Thread t = new Thread(new Runnable() { @Override public void run() { System.out.println(\"线程正在运行\"); } }); // 运行状态 t.start(); // 是否是运行状态，若不是则等待10毫秒 while (!t.getState().equals(Thread.State.TERMINATED)) { TimeUnit.MICROSECONDS.sleep(10); } // 直接由结束转变为云心态 t.start(); } 此段程序运行时会报java.lang.IllegalThreadStateException异常，原因就是不能从结束状态直接转变为运行状态，我们知道一个线程的运行时间分为3部分：T1为线程启动时间，T2为线程的运行时间，T3为线程销毁时间，如果一个线程不能被重复使用，每次创建一个线程都需要经过启动、运行、销毁时间，这势必增大系统的响应时间，有没有更好的办法降低线程的运行时间呢？ T2是无法避免的，只有通过优化代码来实现降低运行时间。T1和T2都可以通过线程池(Thread Pool)来缩减时间，比如在容器(或系统)启动时，创建足够多的线程，当容器(或系统)需要时直接从线程池中获得线程，运算出结果，再把线程返回到线程池中___ExecutorService就是实现了线程池的执行器，我们来看一个示例代码： public static void main(String[] args) throws InterruptedException { // 2个线程的线程池 ExecutorService es = Executors.newFixedThreadPool(2); // 多次执行线程体 for (int i = 0; i &lt; 4; i++) { es.submit(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }); } // 关闭执行器 es.shutdown(); } 此段代码首先创建了一个包含两个线程的线程池，然后在线程池中多次运行线程体，输出运行时的线程名称，结果如下：** pool-1-thread-1 pool-1-thread-2 pool-1-thread-1 pool-1-thread-2** 本次代码执行了4遍线程体，按照我们之前阐述的” 一个线程不可能从结束状态转变为可运行状态 “，那为什么此处的2个线程可以反复使用呢？这就是我们要搞清楚的重点。 线程池涉及以下几个名词： 工作线程(Worker)：线程池中的线程，只有两个状态：可运行状态和等待状态，没有任务时它们处于等待状态，运行时它们循环的执行任务。 任务接口(Task)：这是每个任务必须实现的接口，以供工作线程调度器调度，它主要规定了任务的入口、任务执行完的场景处理，任务的执行状态等。这里有两种类型的任务：具有返回值(异常)的Callable接口任务和无返回值并兼容旧版本的Runnable接口任务。 任务对列(Work Quene)：也叫作工作队列，用于存放等待处理的任务，一般是BlockingQuene的实现类，用来实现任务的排队处理。 我们首先从线程池的创建说起，Executors.newFixedThreadPool(2)表示创建一个具有两个线程的线程池，源代码如下： public class Executors { //生成一个最大为nThreads的线程池执行器 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>()); } } 这里使用了LinkedBlockingQueue作为队列任务管理器，所有等待处理的任务都会放在该对列中，需要注意的是，此队列是一个阻塞式的单端队列。线程池建立好了，那就需要线程在其中运行了，线程池中的线程是在submit第一次提交任务时建立的，代码如下： public Future&lt;?> submit(Runnable task) { //检查任务是否为null if (task == null) throw new NullPointerException(); //把Runnable任务包装成具有返回值的任务对象，不过此时并没有执行，只是包装 RunnableFuture&lt;Object> ftask = newTaskFor(task, null); //执行此任务 execute(ftask); //返回任务预期执行结果 return ftask; } 此处的代码关键是execute方法，它实现了三个职责。 创建足够多的工作线程数，数量不超过最大线程数量，并保持线程处于运行或等待状态。 把等待处理的任务放到任务队列中 从任务队列中取出任务来执行 其中此处的关键是工作线程的创建，它也是通过new Thread方式创建的一个线程，只是它创建的并不是我们的任务线程(虽然我们的任务实现了Runnable接口，但它只是起了一个标志性的作用)，而是经过包装的Worker线程，代码如下： private final class Worker implements Runnable { // 运行一次任务 private void runTask(Runnable task) { /* 这里的task才是我们自定义实现Runnable接口的任务 */ task.run(); /* 该方法其它代码略 */ } // 工作线程也是线程，必须实现run方法 public void run() { try { Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) { runTask(task); task = null; } } finally { workerDone(this); } } // 任务队列中获得任务 Runnable getTask() { /* 其它代码略 */ for (;;) { return r = workQueue.take(); } } } 此处为示意代码，删除了大量的判断条件和锁资源。execute方法是通过Worker类启动的一个工作线程，执行的是我们的第一个任务，然后改线程通过getTask方法从任务队列中获取任务，之后再继续执行，但问题是任务队列是一个BlockingQuene，是阻塞式的，也就是说如果该队列的元素为0，则保持等待状态，直到有任务进入为止，我们来看LinkedBlockingQuene的take方法，代码如下： public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { try { // 如果队列中的元素为0，则等待 while (count.get() == 0) notEmpty.await(); } catch (InterruptedException ie) { notEmpty.signal(); // propagate to a non-interrupted thread throw ie; } // 等待状态结束，弹出头元素 x = extract(); c = count.getAndDecrement(); // 如果队列数量还多于一个，唤醒其它线程 if (c > 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); // 返回头元素 return x; } 分析到这里，我们就明白了线程池的创建过程：创建一个阻塞队列以容纳任务，在第一次执行任务时创建做够多的线程(不超过许可线程数)，并处理任务，之后每个工作线程自行从任务对列中获得任务，直到任务队列中的任务数量为0为止，此时，线程将处于等待状态，一旦有任务再加入到队列中，即召唤醒工作线程进行处理，实现线程的可复用性。 使用线程池减少的是线程的创建和销毁时间，这对于多线程应用来说非常有帮助，比如我们常用的Servlet容器，每次请求处理的都是一个线程，如果不采用线程池技术，每次请求都会重新创建一个新的线程，这会导致系统的性能符合加大，响应效率下降，降低了系统的友好性。 省略了很多东西，因为有一些东西现在对于自己来说还不是那么实用，后边还有几个章节的内容也没有整理，是因为感觉是一些更加广泛的东西。有一些东西仍然很有针对性，但是在这里就不给出了。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"《编写高质量代码》学习笔记(2)","slug":"《编写高质量代码》学习笔记-2","date":"2017-11-18T15:48:00.000Z","updated":"2020-12-09T03:20:42.027Z","comments":true,"path":"2017/11/18/bian-xie-gao-zhi-liang-dai-ma-xue-xi-bi-ji-2/","link":"","permalink":"http://www.wmyskxz.com/2017/11/18/bian-xie-gao-zhi-liang-dai-ma-xue-xi-bi-ji-2/","excerpt":"写着写着发现简书提醒我文章接近字数极限，建议我换一篇写了。","text":"写着写着发现简书提醒我文章接近字数极限，建议我换一篇写了。 建议52：推荐使用String直接量赋值一般对象都是通过new关键字生成的，但是String还有第二种生成方式，也就是我们经常使用的直接声明方式，这种方式是极力推荐的，但不建议使用new String（”A”）的方式赋值。为什么呢？我们看如下代码： public class Client58 { public static void main(String[] args) { String str1 = \"詹姆斯\"; String str2 = \"詹姆斯\"; String str3 = new String(\"詹姆斯\"); String str4 = str3.intern(); // 两个直接量是否相等 System.out.println(str1 == str2); // 直接量和对象是否相等 System.out.println(str1 == str3); // 经过intern处理后的对象与直接量是否相等 System.out.println(str1 == str4); } } 注意看上面的程序，我们使用”==”判断的是两个对象的引用地址是否相同，也就是判断是否为同一个对象，打印的结果是true,false,true。即有两个直接量是同一个对象(进过intern处理后的String与直接量是同一个对象)，但直接通过new生成的对象却与之不等，原因何在？ 原因是Java为了避免在一个系统中大量产生String对象(为什么会大量产生，因为String字符串是程序中最经常使用的类型)，于是就设计了一个字符串池(也叫作字符串常量池，String pool或String Constant Pool或String Literal Pool),在字符串池中容纳的都是String字符串对象，它的创建机制是这样的：创建一个字符串时，首先检查池中是否有字面值相等的字符串，如果有，则不再创建，直接返回池中该对象的引用，若没有则创建之，然后放到池中，并返回新建对象的引用，这个池和我们平常说的池非常接近。对于此例子来说，就是创建第一个”詹姆斯”字符串时，先检查字符串池中有没有该对象，发现没有，于是就创建了”詹姆斯”这个字符串并放到池中，待创建str2字符串时，由于池中已经有了该字符串，于是就直接返回了该对象的引用，此时，str1和str2指向的是同一个地址，所以使用”==”来判断那当然是相等的了。 那为什么使用new String(“詹姆斯”)就不相等了呢？因为直接声明一个String对象是不检查字符串池的，也不会把对象放到字符串池中，那当然”==”为false了。 那为什么intern方法处理后即又相等了呢？因为intern会检查当前对象在对象池中是否存在字面值相同的引用对象，如果有则返回池中的对象，如果没有则放置到对象池中，并返回当前对象。 可能有人要问了，放到池中，是不是要考虑垃圾回收问题呀？不用考虑了，虽然Java的每个对象都保存在堆内存中但是字符串非常特殊，它在编译期已经决定了其存在JVM的常量池(Constant Pool),垃圾回收不会对它进行回收的。 通过上面的介绍，我们发现Java在字符串的创建方面确实提供了非常好的机制，利用对象池不仅可以提高效率，同时减少了内存空间的占用，建议大家在开发中使用直接量赋值方式，除非必要才建立一个String对象。 建议54：正确使用String、StringBuffer、StringBuilderCharSequence接口有三个实现类与字符串有关，String、StringBuffer、StringBuilder，虽然它们都与字符串有关，但其处理机制是不同的。 String类是不可变的量，也就是创建后就不能再修改了，比如创建了一个”abc”这样的字符串对象，那么它在内存中永远都会是”abc”这样具有固定表面值的一个对象，不能被修改，即使想通过String提供的方法来尝试修改，也是要么创建一个新的字符串对象，要么返回自己，比如： String str = \"abc\"; String str1 = str.substring(1); 其中str是一个字符串对象，其值是”abc”,通过substring方法又重新生成了一个字符串str1，它的值是”bc”,也就是说str引用的对象一但产生就永远不会变。为什么上面还说有可能不创建对象而返回自己呢？那是因为采用substring(0)就不会创建对象。JVM从字符串池中返回str的引用，也就是自身的引用。 StringBuffer是一个可变字符串，它与String一样，在内存中保存的都是一个有序的字符序列(char 类型的数组)，不同点是StringBuffer对象的值是可改变的，例如： StringBuffer sb = new StringBuffer(\"a\"); sb.append(\"b\"); 从上面的代码可以看出sb的值在改变，初始化的时候是”a” ，经过append方法后，其值变成了”ab”。可能有人会问了，这与String类通过 “+” 连接有什么区别呢？例如： String s = \"a\"; s = s + \"b\"; 有区别，字符串变量s初始化时是 “a” 对象的引用，经过加号计算后，s变量就修改为了 “ab” 的引用，但是初始化的 “a” 对象还没有改变，只是变量s指向了新的引用地址，再看看StringBuffer的对象，它的引用地址虽不变，但值在改变。 StringBuffer和StringBuilder基本相同，都是可变字符序列，不同点是：StringBuffer是线程安全的，StringBuilder是线程不安全的，翻翻两者的源代码，就会发现在StringBuffer的方法前都有关键字syschronized,这也是StringBuffer在性能上远远低于StringBuffer的原因。 在性能方面，由于String类的操作都是产生String的对象，而StringBuilder和StringBuffer只是一个字符数组的再扩容而已，所以String类的操作要远慢于StringBuffer 和 StringBuilder。 弄清楚了三者之间的原理，我们就可以在不同的场景下使用不同的字符序列了： 使用String类的场景：在字符串不经常变化的场景中可以使用String类，例如常量的声明、少量的变量运算等； 使用StringBuffer的场景：在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等； 使用StringBuilder的场景：在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在单线程的环境中，则可以考虑使用StringBuilder，如SQL语句的拼接，JSON封装等。 *注意：在适当的场景选用字符串类型 * 事实上这个问题被多个地方研究了很多次，我自己也写了一篇专门的文章来介绍String类：http://www.jianshu.com/p/e494552f2cf0 建议55：注意字符串的位置看下面一段程序： public class Client55 { public static void main(String[] args) { String str1 = 1 + 2 + \"apples\"; String str2 = \"apples\" + 1 + 2; System.out.println(str1); System.out.println(str2); } } 想想两个字符串输出的结果的苹果数量是否一致，如果一致，会是几呢？ 答案是不一致，str1的值是”3apples” ,str2的值是“apples12”，这中间悬殊很大，只是把“apples” 调换了一下位置，为何会发生如此大的变化呢？ 这都源于java对于加号的处理机制：在使用加号进行计算的表达式中，只要遇到String字符串，则所有的数据都会转换为String类型进行拼接，如果是原始数据，则直接拼接，如是是对象，则调用toString方法的返回值然后拼接，如： str = str + new ArrayList(); 上面就是调用ArrayList对象的toString方法返回值进行拼接的。再回到前面的问题上，对与str1 字符串，Java的执行顺序是从左到右，先执行1+2，也就是算术加法运算，结果等于3，然后再与字符串进行拼接，结果就是 “3 apples”,其它形式类似于如下计算： String str1 = (1 + 2 ) + \"apples\" ; 而对于str2字符串，由于第一个参与运算的是String类型，加1后的结果是“apples 1” ，这仍然是一个字符串，然后再与2相加，结果还是一个字符串，也就是“apples12”。这说明如果第一个参数是String，则后续的所有计算都会转变为String类型，谁让字符串是老大呢！ 注意： 在“+” 表达式中，String字符串具有最高优先级。 建议57：推荐在复杂字符串操作中使用正则表达式 这是一个很自然的选择，因为正则表达式实在是太强大了。 建议58：强烈建议使用UTF编码Java的乱码问题由来已久，有经验的开发人员肯定遇到过乱码，有时从Web接收的乱码，有时从数据库中读取的乱码，有时是在外部接口中接收的乱码文件，这些都让我们困惑不已，甚至是痛苦不堪，看如下代码： public class Client58 { public static void main(String[] args) throws UnsupportedEncodingException { String str = \"汉字\"; // 读取字节 byte b[] = str.getBytes(\"UTF-8\"); // 重新生成一个新的字符串 System.out.println(new String(b)); } } Java文件是通过IDE工具默认创建的，编码格式是GBK，大家想想看上面的输出结果会是什么？可能是乱码吧？两个编码格式不同。我们暂时不说结果，先解释一下Java中的编码规则。Java程序涉及的编码包括两部分： (1)、Java文件编码：如果我们使用记事本创建一个.java后缀的文件，则文件的编码格式就是操作系统默认的格式。如果是使用IDE工具创建的，如Eclipse，则依赖于IDE的设置，Eclipse默认是操作系统编码（Windows一般为GBK）； (2)、Class文件编码：通过javac命令生成的后缀名为.class的文件是UTF-8编码的UNICODE文件，这在任何操作系统上都是一样的，只要是.class文件就会使UNICODE格式。需要说明的是，UTF是UNICODE的存储和传输格式，它是为了解决UNICODE的高位占用冗余空间而产生的，使用UTF编码就意味着字符集使用的是UNICODE. 再回到我们的例子上，getBytes方法会根据指定的字符集取出字节数组(这里按照UNICODE格式来提取)，然后程序又通过new String(byte [] bytes)重新生成一个字符串，来看看String的这个构造函数：通过操作系统默认的字符集解码指定的byte数组，构造一个新的String，结果已经很清楚了，如果操作系统是UTF-8的话，输出就是正确的，如果不是，则会是乱码。由于这里使用的是默认编码GBK，那么输出的结果也就是乱码了。我们再详细分解一下运行步骤： 步骤1：创建Client58.java文件：该文件的默认编码格式GBK（如果是Eclipse，则可以在属性中查看到）。 步骤2：编写代码(如上)； 步骤3：保存，使用javac编译，注意我们没有使用”javac -encoding GBK Client58.java” 显示声明Java的编码方式，javac会自动按照操作系统的编码(GBK)读取Client58.java文件，然后将其编译成.class文件。 步骤4：生成.class文件。编译结束，生成.class文件，并保存到硬盘上，此时 .class文件使用的UTF-8格式编码的UNICODE字符集，可以通过javap 命令阅读class文件，其中” 汉字”变量也已经由GBK转变成UNICODE格式了。 步骤5：运行main方法，提取”汉字”的字节数组。”汉字” 原本是按照UTF-8格式保存的，要再提取出来当然没有任何问题了。 步骤6：重组字符串，读取操作系统默认的编码GBK，然后重新编码变量b的所有字节。问题就在这里产生了：因为UNICODE的存储格式是两个字节表示一个字符(注意：这里是指UCS-2标准)，虽然GBK也是两个字节表示一个字符，但两者之间没有映射关系，只要做转换只能读取映射表，不能实现自动转换—-于是JVM就按照默认的编码方式(GBK)读取了UNICODE的两个字节。 步骤7：输出乱码，程序运行结束，问题清楚了，解决方案也随之产生，方案有两个。 步骤8：修改代码，明确指定编码即可，代码如下：System.out.println(new String(b,&quot;UTF-8&quot;)); 步骤9：修改操作系统的编码方式，各个操作系统的修改方式不同，不再赘述。 我们可以把字符串读取字节的过程看做是数据传输的需要(比如网络、存储)，而重组字符串则是业务逻辑的需求，这样就可以是乱码重现：通过JDBC读取的字节数组是GBK的，而业务逻辑编码时采用的是UTF-8，于是乱码就产生了。对于此类问题，最好的解决办法就是使用统一的编码格式，要么都用GBK，要么都用UTF-8，各个组件、接口、逻辑层、都用UTF-8，拒绝独树一帜的情况。 问题清楚了，我们看看以下代码： public class Client58 { public static void main(String[] args) throws UnsupportedEncodingException { String str = \"汉字\"; // 读取字节 byte b[] = str.getBytes(\"GB2312\"); // 重新生成一个新的字符串 System.out.println(new String(b)); } } 仅仅修改了读取字节的编码方式(修改成了GB2312)，结果会怎样呢？又或者将其修改成GB18030，结果又是怎样的呢？结果都是”汉字”，不是乱码。这是因为GB2312是中文字符集的V1.0版本，GBK是V2.0版本，GB18030是V3.0版本，版本是向下兼容的，只是它们包含的汉字数量不同而已，注意UNICODE可不在这个序列之内。 注意：一个系统使用统一的编码。 建议60：性能考虑，数组是首选数组在实际的系统开发中用的越来越少了，我们通常只有在阅读一些开源项目时才会看到它们的身影，在Java中它确实没有List、Set、Map这些集合类用起来方便，但是在基本类型处理方面，数组还是占优势的，而且集合类的底层也都是通过数组实现的，比如对一数据集求和这样的计算： //对数组求和 public static int sum(int datas[]) { int sum = 0; for (int i = 0; i &lt; datas.length; i++) { sum += datas[i]; } return sum; } 对一个int类型 的数组求和，取出所有数组元素并相加，此算法中如果是基本类型则使用数组效率是最高的，使用集合则效率次之。再看使用List求和： // 对列表求和计算 public static int sum(List&lt;Integer> datas) { int sum = 0; for (int i = 0; i &lt; datas.size(); i++) { sum += datas.get(i); } return sum; } 注意看sum += datas.get(i);这行代码，这里其实已经做了一个拆箱动作，Integer对象通过intValue方法自动转换成了一个int基本类型，对于性能濒于临界的系统来说该方案是比较危险的，特别是大数量的时候，首先，在初始化List数组时要进行装箱操作，把一个int类型包装成一个Integer对象，虽然有整型池在，但不在整型池范围内的都会产生一个新的Integer对象，而且众所周知，基本类型是在栈内存中操作的，而对象是堆内存中操作的，栈内存的特点是：速度快，容量小；堆内存的特点是：速度慢，容量大（从性能上讲，基本类型的处理占优势）。其次，在进行求和运算时(或者其它遍历计算)时要做拆箱动作，因此无谓的性能消耗也就产生了。在实际测试中发现：对基本类型进行求和运算时，数组的效率是集合的10倍。 注意：性能要求较高的场景中使用数组代替集合。 建议64：多种最值算法，适时选择对一批数据进行排序，然后找出其中的最大值或最小值，这是基本的数据结构知识。在Java中我们可以通过编写算法的方式，也可以通过数组先排序再取值的方式来实现，下面以求最大值为例，解释一下多种算法： *(1)、自行实现，快速查找最大值 *先看看用快速查找法取最大值的算法，代码如下： public static int max(int[] data) { int max = data[0]; for (int i : data) { max = max > i ? max : i; } return max; } 这是我们经常使用的最大值算法，也是速度最快的算法。它不要求排序，只要遍历一遍数组即可找出最大值。 (2)、先排序，后取值对于求最大值，也可以采用先排序后取值的方式，代码如下： public static int max(int[] data) { Arrays.sort(data); return data[data.length - 1]; } 从效率上讲，当然是自己写快速查找法更快一些了，只用遍历一遍就可以计算出最大值，但在实际测试中发现，如果数组量少于10000，两个基本上没有区别，但在同一个毫秒级别里，此时就可以不用自己写算法了，直接使用数组先排序后取值的方式。 如果数组元素超过10000，就需要依据实际情况来考虑：自己实现，可以提高性能；先排序后取值，简单，通俗易懂。排除性能上的差异，两者都可以选择，甚至后者更方便一些，也更容易想到。 现在问题来了，在代码中为什么先使用data.clone拷贝再排序呢？那是因为数组也是一个对象，不拷贝就改变了原有的数组元素的顺序吗？除非数组元素的顺序无关紧要。那如果要查找仅次于最大值的元素(也就是老二)，该如何处理呢？要注意，数组的元素时可以重复的，最大值可能是多个，所以单单一个排序然后取倒数第二个元素时解决不了问题的。 此时，就需要一个特殊的排序算法了，先要剔除重复数据，然后再排序，当然，自己写算法也可以实现，但是集合类已经提供了非常好的方法，要是再使用自己写算法就显得有点重复造轮子了。数组不能剔除重复数据，但Set集合却是可以的，而且Set的子类TreeSet还能自动排序，代码如下： public static int getSecond(Integer[] data) { //转换为列表 List&lt;Integer> dataList = Arrays.asList(data); //转换为TreeSet，剔除重复元素并升序排列 TreeSet&lt;Integer> ts = new TreeSet&lt;Integer>(dataList); //取得比最大值小的最大值，也就是老二了 return ts.lower(ts.last()); } 剔除重复元素并升序排列，这都是由TreeSet类实现的，然后可再使用lower方法寻找小于最大值的值，大家看，上面的程序非常简单吧?那如果是我们自己编写代码会怎么样呢？那至少要遍历数组两遍才能计算出老二的值，代码复杂度将大大提升。因此在实际应用中求最值，包括最大值、最小值、倒数第二小值等，使用集合是最简单的方式，当然从性能方面来考虑，数组才是最好的选择。 注意：最值计算时使用集合最简单，使用数组性能最优。 建议82：由点及面，集合大家族总结Java中的集合类实在是太丰富了，有常用的ArrayList、HashMap,也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap，有阻塞式的ArrayBlockingQueue，也有非阻塞式的PriorityQueue等，整个集合大家族非常庞大，可以划分以下几类： (1)、List：实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack，其中ArrayList是一个动态数组，LinkedList是一个双向链表，Vector是一个线程安全的动态数组，Stack是一个对象栈，遵循先进后出的原则。 (2)、Set：Set是不包含重复元素的集合，其主要实现类有：EnumSet、HashSet、TreeSet，其中EnumSet是枚举类型专用Set，所有元素都是枚举类型；HashSet是以哈希码决定其元素位置的Set，其原理与HashMap相似，它提供快速的插入和查找方法；TreeSet是一个自动排序的Set，它实现了SortedSet接口。 (3)、Map：Map是一个大家族，他可以分为排序Map和非排序Map，排序Map主要是TreeMap类，他根据key值进行自动排序；非排序Map主要包括：HashMap、HashTable、Properties、EnumMap等，其中Properties是HashTable的子类，它的主要用途是从Property文件中加载数据，并提供方便的操作，EnumMap则是要求其Key必须是某一个枚举类型。Map中还有一个WeakHashMap类需要说明，它是一个采用弱键方式实现的Map类，它的特点是：WeakHashMap对象的存在并不会阻止垃圾回收器对键值对的回收，也就是说使用WeakHashMap装载数据不用担心内存溢出的问题，GC会自动删除不用的键值对，这是好事。但也存在一个严重的问题：GC是静悄悄的回收的(何时回收，God，Knows！)我们的程序无法知晓该动作，存在着重大的隐患。 (4)、Queue：对列，它分为两类，一类是阻塞式队列，队列满了以后再插入元素会抛出异常，主要包括：ArrayBlockingQueue、PriorityQueue、LinkedBlockingQueue，其中ArrayBlockingQueue是一个以数组方式实现的有界阻塞队列；另一类是非阻塞队列，无边界的，只要内存允许，都可以持续追加元素，我们经常使用的是PriorityQuene类。还有一种队列，是双端队列，支持在头、尾两端插入和移除元素，它的主要实现类是：ArrayDeque、LinkedBlockingDeque、LinkedList。 (5)、数组：数组与集合的最大区别就是数组能够容纳基本类型，而集合就不行，更重要的一点就是所有的集合底层存储的都是数组。 (6)、工具类：数组的工具类是java.util.Arrays和java.lang.reflect.Array，集合的工具类是java.util.Collections，有了这两个工具类，操作数组和集合就会易如反掌，得心应手。 (7)、扩展类：集合类当然可以自行扩展了，想写一个自己的List？没问题，但最好的办法还是”拿来主义”，可以使用Apache的common-collections扩展包，也可以使用Google的google-collections扩展包，这些足以应对我们的开发需要。 建议83：推荐使用枚举定义常量常量声明是每一个项目都不可或缺的，在Java1.5之前，我们只有两种方式的声明：类常量和接口常量，若在项目中使用的是Java1.5之前的版本，基本上都是如此定义的。不过，在1.5版本以后有了改进，即新增了一种常量声明方式：枚举声明常量，看如下代码： enum Season { Spring, Summer, Autumn, Winter; } 这是一个简单的枚举常量命名，清晰又简单。顺便提一句，JLS(Java Language Specification，Java语言规范)提倡枚举项全部大写，字母之间用下划线分割，这也是从常量的角度考虑的(当然，使用类似类名的命名方式也是比较友好的)。 那么枚举常量与我们经常使用的类常量和静态常量相比有什么优势？问得好，枚举的优点主要表现在四个方面： 1.枚举常量简单：简不简单，我们来对比一下两者的定义和使用情况就知道了。先把Season枚举翻写成接口常量，代码如下： interface Season { int SPRING = 0; int SUMMER = 1; int AUTUMN = 2; int WINTER = 3; } 此处定义了春夏秋冬四个季节，类型都是int，这与Season枚举的排序值是相同的。首先对比一下两者的定义，枚举常量只需定义每个枚举项，不需要定义枚举值，而接口常量(或类常量)则必须定义值，否则编译不通过，即使我们不需要关注其值是多少也必须定义；其次，虽然两者被引用的方式相同(都是 “类名 . 属性”，如Season.SPRING),但是枚举表示的是一个枚举项，字面含义是春天，而接口常量确是一个int类型，虽然其字面含义也是春天，但在运算中我们势必要关注其int值。 2.枚举常量属于稳态型:例如我们要描述一下春夏秋冬是什么样子，使用接口常量应该是这样写。 public void describe(int s) { // s变量不能超越边界，校验条件 if (s >= 0 &amp;&amp; s &lt; 4) { switch (s) { case Season.SPRING: System.out.println(\"this is spring\"); break; case Season.SUMMER: System.out.println(\"this is summer\"); break; ...... } } } 很简单，先使用switch语句判断哪一个是常量，然后输出。但问题是我们得对输入值进行检查，确定是否越界，如果常量非常庞大，校验输入就成了一件非常麻烦的事情，但这是一个不可逃避的过程，特别是如果我们的校验条件不严格，虽然编译能照样通过，但是运行期就会产生无法预知的后果。 我们再来看看枚举常量是否能够避免校验的问题，代码如下： public void describe(Season s){ switch(s){ case Spring: System.out.println(\"this is \"+Season.Spring); break; case Summer: System.out.println(\"this is summer\"+Season.Summer); break; ...... } } 不用校验，已经限定了是Season枚举，所以只能是Season类的四个实例，即春夏秋冬4个枚举项，想输入一个int类型或其它类型？门都没有！这是我们最看重枚举的地方：在编译期间限定类型，不允许发生越界的情况。 3.枚举具有内置方法：有一个简单的问题：如果要列出所有的季节常量，如何实现呢？接口常量或类常量可以通过反射来实现，这没错，只是虽然能实现，但会非常繁琐，大家可以自己写一个反射类实现此功能(当然，一个一个地动手打印出输出常量，也可以算是列出)。对于此类问题可以非常简单的解决，代码如下： public void query() { for (Season s : Season.values()) { System.out.println(s); } } 通过values方法获得所有的枚举项，然后打印出来即可。如此简单，得益于枚举内置的方法，每个枚举都是java.lang.Enum的子类，该基类提供了诸如获得排序值的ordinal方法、compareTo比较方法等，大大简化了常量的访问。 4.枚举可以自定义的方法：这一点似乎并不是枚举的优点，类常量也可以有自己的方法呀，但关键是枚举常量不仅可以定义静态方法，还可以定义非静态方法，而且还能够从根本上杜绝常量类被实例化。比如我们要在常量定义中获得最舒服季节的方法，使用常量枚举的代码如下： enum Season { Spring, Summer, Autumn, Winter; public static Season getComfortableSeason(){ return Spring; } } 我们知道，每个枚举项都是该枚举的一个实例，对于我们的例子来说，也就表示Spring其实是Season的一个实例，Summer也是其中一个实例，那我们在枚举中定义的静态方法既可以在类(也就是枚举Season)中引用，也可以在实例(也就是枚举项Spring、Summer、Autumn、Winter)中引用，看如下代码： public static void main(String[] args) { System.out.println(\"The most comfortable season is \"+Season.getComfortableSeason()); } 那如果使用类常量要如何实现呢？代码如下： class Season { public final static int SPRING = 0; public final static int SUMMER = 1; public final static int AUTUMN = 2; public final static int WINTER = 3; public static int getComfortableSeason(){ return SPRING; } } 想想看，我们怎么才能打印出”The most comfortable season is Spring” 这句话呢？除了使用switch和if判断之外没有其它办法了。 虽然枚举在很多方面比接口常量和类常量好用，但是有一点它是比不上接口常量和类常量的，那就是继承，枚举类型是不能继承的，也就是说一个枚举常量定义完毕后，除非修改重构，否则无法做扩展，而接口常量和类常量则可以通过继承进行扩展。但是，一般常量在项目构建时就定义完毕了，很少会出现必须通过扩展才能实现业务逻辑的场景。 注意： 在项目中推荐使用枚举常量代替接口常量或类常量。 建议88：用枚举实现工厂方法模式更简洁工厂方法模式(Factory Method Pattern)是” 创建对象的接口，让子类决定实例化哪一个类，并使一个类的实例化延迟到其它子类”。工厂方法模式在我们的开发中经常会用到。下面以汽车制造为例，看看一般的工厂方法模式是如何实现的，代码如下： //抽象产品 interface Car{ } //具体产品类 class FordCar implements Car{ } //具体产品类 class BuickCar implements Car{ } //工厂类 class CarFactory{ //生产汽车 public static Car createCar(Class&lt;? extends Car> c){ try { return c.newInstance(); } catch (InstantiationException | IllegalAccessException e) { e.printStackTrace(); } return null; } } 这是最原始的工厂方法模式，有两个产品：福特汽车和别克汽车，然后通过工厂方法模式来生产。有了工厂方法模式，我们就不用关心一辆车具体是怎么生成的了，只要告诉工厂” 给我生产一辆福特汽车 “就可以了，下面是产出一辆福特汽车时客户端的代码： public static void main(String[] args) { //生产车辆 Car car = CarFactory.createCar(FordCar.class); } 这就是我们经常使用的工厂方法模式，但经常使用并不代表就是最优秀、最简洁的。此处再介绍一种通过枚举实现工厂方法模式的方案，谁优谁劣你自行评价。枚举实现工厂方法模式有两种方法： (1)、枚举非静态方法实现工厂方法模式 我们知道每个枚举项都是该枚举的实例对象，那是不是定义一个方法可以生成每个枚举项对应产品来实现此模式呢？代码如下： enum CarFactory { // 定义生产类能生产汽车的类型 FordCar, BuickCar; // 生产汽车 public Car create() { switch (this) { case FordCar: return new FordCar(); case BuickCar: return new BuickCar(); default: throw new AssertionError(\"无效参数\"); } } } create是一个非静态方法，也就是只有通过FordCar、BuickCar枚举项才能访问。采用这种方式实现工厂方法模式时，客户端要生产一辆汽车就很简单了，代码如下： public static void main(String[] args) { // 生产车辆 Car car = CarFactory.BuickCar.create(); } (2)、通过抽象方法生成产品 枚举类型虽然不能继承，但是可以用abstract修饰其方法，此时就表示该枚举是一个抽象枚举，需要每个枚举项自行实现该方法，也就是说枚举项的类型是该枚举的一个子类，我们俩看代码： enum CarFactory { // 定义生产类能生产汽车的类型 FordCar{ public Car create(){ return new FordCar(); } }, BuickCar{ public Car create(){ return new BuickCar(); } }; //抽象生产方法 public abstract Car create(); } 首先定义一个抽象制造方法create，然后每个枚举项自行实现，这种方式编译后会产生CarFactory的匿名子类，因为每个枚举项都要实现create抽象方法。客户端调用与上一个方案相同，不再赘述。 大家可能会问，为什么要使用枚举类型的工厂方法模式呢？那是因为使用枚举类型的工厂方法模式有以下三个优点： 避免错误调用的发生：一般工厂方法模式中的生产方法(也就是createCar方法)，可以接收三种类型的参数：类型参数(如我们的例子)、String参数(生产方法中判断String参数是需要生产什么产品)、int参数(根据int值判断需要生产什么类型的的产品)，这三种参数都是宽泛的数据类型，很容易发生错误(比如边界问题、null值问题)，而且出现这类错误编译器还不会报警，例如： public static void main(String[] args) { // 生产车辆 Car car = CarFactory.createCar(Car.class); } Car是一个接口，完全合乎createCar的要求，所以它在编译时不会报任何错误，但一运行就会报出InstantiationException异常，而使用枚举类型的工厂方法模式就不存在该问题了，不需要传递任何参数，只需要选择好生产什么类型的产品即可。 性能好，使用简洁：枚举类型的计算时以int类型的计算为基础的，这是最基本的操作，性能当然会快，至于使用便捷，注意看客户端的调用，代码的字面意思就是” 汽车工厂，我要一辆别克汽车，赶快生产”。 降低类间耦合：不管生产方法接收的是Class、String还是int的参数，都会成为客户端类的负担，这些类并不是客户端需要的，而是因为工厂方法的限制必须输入的，例如Class参数，对客户端main方法来说，他需要传递一个FordCar.class参数才能生产一辆福特汽车，除了在create方法中传递参数外，业务类不需要改Car的实现类。这严重违背了迪米特原则(Law of Demeter 简称LoD),也就是最少知识原则：一个对象应该对其它对象有最少的了解。 而枚举类型的工厂方法就没有这种问题了，它只需要依赖工厂类就可以生产一辆符合接口的汽车，完全可以无视具体汽车类的存在。 建议93：Java的泛型是可以擦除的Java泛型(Generic) 的引入加强了参数类型的安全性，减少了类型的转换，它与C++中的模板(Temeplates) 比较类似，但是有一点不同的是：Java的泛型在编译器有效，在运行期被删除，也就是说所有的泛型参数类型在编译后会被清除掉，我们来看一个例子，代码如下： public class Foo { //arrayMethod接收数组参数，并进行重载 public void arrayMethod(String[] intArray) { } public void arrayMethod(Integer[] intArray) { } //listMethod接收泛型List参数，并进行重载 public void listMethod(List&lt;String> stringList) { } public void listMethod(List&lt;Integer> intList) { } } 程序很简单，编写了4个方法，arrayMethod方法接收String数组和Integer数组，这是一个典型的重载，listMethod接收元素类型为String和Integer的list变量。现在的问题是，这段程序是否能编译？如果不能？问题出在什么地方？ 事实上，这段程序时无法编译的，编译时报错信息如下： 这段错误的意思：简单的的说就是方法签名重复，其实就是说listMethod(List intList)方法在编译时擦除类型后是listMethod(List intList)与另一个方法重复。这就是Java泛型擦除引起的问题：在编译后所有的泛型类型都会做相应的转化。转换规则如下： List、List、List擦除后的类型为List List[] 擦除后的类型为List[]. List&lt;? extends E&gt; 、List&lt;? super E&gt; 擦除后的类型为List. List&lt;T extends Serializable &amp; Cloneable &gt;擦除后的类型为List&lt; Serializable&gt;. 明白了这些规则，再看如下代码： public static void main(String[] args) { List&lt;String> list = new ArrayList&lt;String>(); list.add(\"abc\"); String str = list.get(0); } 进过编译后的擦除处理，上面的代码和下面的程序时一致的： public static void main(String[] args) { List list = new ArrayList(); list.add(\"abc\"); String str = (String) list.get(0); } Java编译后字节码中已经没有泛型的任何信息了，也就是说一个泛型类和一个普通类在经过编译后都指向了同一字节码，比如Foo类，经过编译后将只有一份Foo.class类，不管是Foo还是Foo引用的都是同一字节码。Java之所以如此处理，有两个原因： 避免JVM的大换血。C++泛型生命期延续到了运行期，而Java是在编译期擦除掉的，我们想想，如果JVM也把泛型类型延续到运行期，那么JVM就需要进行大量的重构工作了。 版本兼容：在编译期擦除可以更好的支持原生类型(Raw Type)，在Java1.5或1.6…平台上，即使声明一个List这样的原生类型也是可以正常编译通过的，只是会产生警告信息而已。 明白了Java泛型是类型擦除的，我们就可以解释类似如下的问题了： 1.泛型的class对象是相同的：每个类都有一个class属性，泛型化不会改变class属性的返回值，例如： public static void main(String[] args) { List&lt;String> list = new ArrayList&lt;String>(); List&lt;Integer> list2 = new ArrayList&lt;Integer>(); System.out.println(list.getClass()==list2.getClass()); } 以上代码返回true，原因很简单，List和List擦除后的类型都是List，没有任何区别。 *2.泛型数组初始化时不能声明泛型，如下代码编译时通不过： * List&lt;String>[] listArray = new List&lt;String>[]; 原因很简单，可以声明一个带有泛型参数的数组，但不能初始化该数组，因为执行了类型擦除操作，List[]与List[] 就是同一回事了，编译器拒绝如此声明。 3.instanceof不允许存在泛型参数:以下代码不能通过编译，原因一样，泛型类型被擦除了： List&lt;String> list = new ArrayList&lt;String>(); System.out.println(list instanceof List&lt;String>); 建议98：建议的采用顺序是List中泛型顺序依次为T、?、ObjectList、List、List这三者都可以容纳所有的对象，但使用的顺序应该是首选List，次之List，最后选择List，原因如下： (1)、List是确定的某一个类型 List表示的是List集合中的元素都为T类型，具体类型在运行期决定；List&lt;？&gt;表示的是任意类型，与List类似，而List则表示List集合中的所有元素为Object类型，因为Object是所有类的父类，所以List也可以容纳所有的类类型，从这一字面意义上分析，List更符合习惯：编码者知道它是某一个类型，只是在运行期才确定而已。 (2)List可以进行读写操作 List可以进行诸如add，remove等操作，因为它的类型是固定的T类型，在编码期不需要进行任何的转型操作。 List是只读类型的，不能进行增加、修改操作，因为编译器不知道List中容纳的是什么类型的元素，也就无法校验类型是否安全了，而且List&lt;?&gt;读取出的元素都是Object类型的，需要主动转型，所以它经常用于泛型方法的返回值。注意List&lt;？&gt;虽然无法增加，修改元素，但是却可以删除元素，比如执行remove、clear等方法，那是因为它的删除动作与泛型类型无关。 List 也可以读写操作，但是它执行写入操作时需要向上转型(Up cast)，在读取数据的时候需要向下转型，而此时已经失去了泛型存在的意义了。 打个比方，有一个篮子用来容纳物品，比如西瓜，番茄等.List的意思是说，“嘿，我这里有一个篮子，可以容纳固定类别的东西，比如西瓜，番茄等”。List的意思是说：“嘿，我有一个篮子，我可以容纳任何东西，只要是你想得到的”。而List就更有意思了，它说” 嘿，我也有一个篮子，我可以容纳所有物质，只要你认为是物质的东西都可以容纳进来 “。 推而广之，Dao应该比Dao&lt;？&gt;、Dao更先采用，Desc则比Desc&lt;？&gt;、Desc更优先采用。 建议101：注意Class类的特殊性Java语言是先把Java源文件编译成后缀为class的字节码文件，然后再通过ClassLoader机制把这些类文件加载到内存中，最后生成实例执行的，这是Java处理的基本机制，但是加载到内存中的数据的如何描述一个类的呢？比如在Dog.class文件中定义一个Dog类，那它在内存中是如何展现的呢？ Java使用一个元类(MetaClass)来描述加载到内存中的类数据，这就是Class类，它是一个描述类的类对象，比如Dog.class文件加载到内存中后就会有一个class的实例对象描述之。因为是Class类是“类中类”，也就有预示着它有很多特殊的地方： 1.无构造函数：Java中的类一般都有构造函数，用于创建实例对象，但是Class类却没有构造函数，不能实例化，Class对象是在加载类时由Java虚拟机通过调用类加载器中的difineClass方法自动构造的。 2.可以描述基本类型：虽然8个基本类型在JVM中并不是一个对象，它们一般存在于栈内存中，但是Class类仍然可以描述它们，例如可以使用int.class表示int类型的类对象。 3.其对象都是单例模式：一个Class的实例对象描述一个类，并且只描述一个类，反过来也成立。一个类只有一个Class实例对象，如下代码返回的结果都为true： // 类的属性class所引用的对象与实例对象的getClass返回值相同 boolean b1=String.class.equals(new String().getClass()); boolean b2=\"ABC\".getClass().equals(String.class); // class实例对象不区分泛型 boolean b3=ArrayList.class.equals(new ArrayList&lt;String>().getClass()); Class类是Java的反射入口，只有在获得了一个类的描述对象后才能动态的加载、调用，一般获得一个Class对象有三种途径： 类属性方式：如String.class 对象的getClass方法，如new String().getClass() forName方法加载：如Class.forName(“ java.lang.String”) 获得了Class对象后，就可以通过getAnnotations()获得注解，通过getMethods()获得方法，通过getConstructors()获得构造函数等，这位后续的反射代码铺平了道路。 建议106：动态代理可以使代理模式更加灵活Java的反射框架提供了动态代理(Dynamic Proxy)机制，允许在运行期对目标类生成代理，避免重复开发。我们知道一个静态代理是通过主题角色(Proxy)和具体主题角色(Real Subject)共同实现主题角色(Subject)的逻辑的，只是代理角色把相关的执行逻辑委托给了具体角色而已，一个简单的静态代理如下所示： interface Subject { // 定义一个方法 public void request(); } // 具体主题角色 class RealSubject implements Subject { // 实现方法 @Override public void request() { // 实现具体业务逻辑 } } class Proxy implements Subject { // 要代理那个实现类 private Subject subject = null; // 默认被代理者 public Proxy() { subject = new RealSubject(); } // 通过构造函数传递被代理者 public Proxy(Subject _subject) { subject = _subject; } @Override public void request() { before(); subject.request(); after(); } // 预处理 private void after() { // doSomething } // 善后处理 private void before() { // doSomething } } 这是一个简单的静态代理。Java还提供了java.lang.reflect.Proxy用于实现动态代理：只要提供一个抽象主题角色和具体主题角色，就可以动态实现其逻辑的，其实例代码如下： interface Subject { // 定义一个方法 public void request(); } // 具体主题角色 class RealSubject implements Subject { // 实现方法 @Override public void request() { // 实现具体业务逻辑 } } class SubjectHandler implements InvocationHandler { // 被代理的对象 private Subject subject; public SubjectHandler(Subject _subject) { subject = _subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 预处理 System.out.println(\"预处理...\"); //直接调用被代理的方法 Object obj = method.invoke(subject, args); // 后处理 System.out.println(\"后处理...\"); return obj; } } 注意这里没有代理主题角色，取而代之的是SubjectHandler 作为主要的逻辑委托处理，其中invoke方法是接口InvocationHandler定义必须实现的，它完成了对真实方法的调用。 我们来详细解释一下InvocationHandler接口，动态代理是根据被代理的接口生成的所有方法的，也就是说给定一个或多个接口，动态代理会宣称“我已经实现该接口下的所有方法了”，那大家想想看，动态代理是怎么才能实现接口中的方法呢？在默认情况下所有方法的返回值都是空的，是的，虽然代理已经实现了它，但是没有任何的逻辑含义，那怎么办？好办，通过InvocationHandler接口的实现类来实现，所有的方法都是由该Handler进行处理的，即所有被代理的方法都由InvocationHandler接管实际的处理任务。 我们开看看动态代理的场景，代码如下： public static void main(String[] args) { //具体主题角色，也就是被代理类 Subject subject = new RealSubject(); //代理实例的处理Handler InvocationHandler handler =new SubjectHandler(subject); //当前加载器 ClassLoader cl = subject.getClass().getClassLoader(); //动态代理 Subject proxy = (Subject) Proxy.newProxyInstance(cl,subject.getClass().getInterfaces(),handler); //执行具体主题角色方法 proxy.request(); } 此时就实现了，不用显式创建代理类即实现代理的功能，例如可以在被代理的角色执行前进行权限判断，或者执行后进行数据校验。 动态代理很容易实现通用的代理类，只要在InvocationHandler的invoke方法中读取持久化的数据即可实现，而且还能实现动态切入的效果，这也是AOP(Aspect Oriented Programming)变成理念。 建议110：提倡异常封装Java语言的异常处理机制可以去确保程序的健壮性，提高系统的可用率，但是Java API提供的异常都是比较低级的(这里的低级是指 “ 低级别的 “ 异常)，只有开发人员才能看的懂，才明白发生了什么问题。而对于终端用户来说，这些异常基本上就是天书，与业务无关，是纯计算机语言的描述，那该怎么办？这就需要我们对异常进行封装了。异常封装有三方面的优点： (1)、提高系统的友好性例如，打开一个文件，如果文件不存在，则回报FileNotFoundException异常，如果该方法的编写者不做任何处理，直接抛到上层，则会降低系统的友好性，代码如下所示： public static void doStuff() throws FileNotFoundException { InputStream is = new FileInputStream(\"无效文件.txt\"); /* 文件操作 */ } 此时doStuff的友好性极差，出现异常时(如果文件不存在)，该方法直接把FileNotFoundException异常抛到上层应用中(或者是最终用户)，而上层应用(或用户要么自己处理)，要么接着抛，最终的结果就是让用户面对着” 天书 “ 式的文字发呆，用户不知道这是什么问题，只是知道系统告诉他” 哦，我出错了，什么错误？你自己看着办吧 “。 解决办法就是封装异常，可以把异常的阅读者分为两类：开发人员和用户。开发人员查找问题，需要打印出堆栈信息，而用户则需要了解具体的业务原因，比如文件太大、不能同时编写文件等，代码如下： public static void doStuff2() throws MyBussinessException{ try { InputStream is = new FileInputStream(\"无效文件.txt\"); } catch (FileNotFoundException e) { //方便开发人员和维护人员而设置的异常信息 e.printStackTrace(); //抛出业务异常 throw new MyBussinessException(); } /* 文件操作 */ } (2)、提高系统的可维护性看如下代码： public void doStuff3(){ try{ //doSomething }catch(Exception e){ e.printStackTrace(); } } 这是大家很容易犯的错误，抛出异常是吧?分类处理多麻烦，就写一个catch块来处理所有的异常吧，而且还信誓旦旦的说” JVM会打印出栈中的错误信息 “，虽然这没错，但是该信息只有开发人员自己看的懂，维护人员看到这段异常时基本上无法处理，因为需要到代码逻辑中去分析问题。 正确的做法是对异常进行分类处理，并进行封装输出，代码如下： public void doStuff4(){ try{ //doSomething }catch(FileNotFoundException e){ log.info(\"文件未找到，使用默认配置文件....\"); e.printStackTrace(); }catch(SecurityException e1){ log.info(\" 无权访问，可能原因是......\"); e1.printStackTrace(); } } 如此包装后，维护人员看到这样的异常就有了初步的判断，或者检查配置，或者初始化环境，不需要直接到代码层级去分析了。 (3)、解决Java异常机制自身的缺陷Java中的异常一次只能抛出一个，比如doStuff方法有两个逻辑代码片段，如果在第一个逻辑片段中抛出异常，则第二个逻辑片段就不再执行了，也就无法抛出第二个异常了，现在的问题是：如何才能一次抛出两个(或多个)异常呢？ 其实，使用自行封装的异常可以解决该问题，代码如下： class MyException extends Exception { // 容纳所有的异常 private List&lt;Throwable> causes = new ArrayList&lt;Throwable>(); // 构造函数，传递一个异常列表 public MyException(List&lt;? extends Throwable> _causes) { causes.addAll(_causes); } // 读取所有的异常 public List&lt;Throwable> getExceptions() { return causes; } } MyException异常只是一个异常容器，可以容纳多个异常，但它本身并不代表任何异常含义，它所解决的是一次抛出多个异常的问题，具体调用如下： public void doStuff() throws MyException { List&lt;Throwable> list = new ArrayList&lt;Throwable>(); // 第一个逻辑片段 try { // Do Something } catch (Exception e) { list.add(e); } // 第二个逻辑片段 try { // Do Something } catch (Exception e) { list.add(e); } // 检查是否有必要抛出异常 if (list.size() > 0) { throw new MyException(list); } } 这样一来，DoStuff方法的调用者就可以一次获得多个异常了，也能够为用户提供完整的例外情况说明。可能有人会问：这种情况会出现吗？怎么回要求一个方法抛出多个异常呢？ 绝对有可能出现，例如Web界面注册时，展现层依次把User对象传递到逻辑层，Register方法需要对各个Field进行校验并注册，例如用户名不能重复，密码必须符合密码策略等，不要出现用户第一次提交时系统显示” 用户名重复 “，在用户修改用户名再次提交后，系统又提示” 密码长度小于6位 “ 的情况，这种操作模式下的用户体验非常糟糕，最好的解决办法就是异常封装，建立异常容器，一次性地对User对象进行校验，然后返回所有的异常。 建议114：不要在构造函数中抛出异常Java异常的机制有三种： Error类及其子类表示的是错误，它是不需要程序员处理也不能处理的异常，比如VirtualMachineError虚拟机错误，ThreadDeath线程僵死等。 RunTimeException类及其子类表示的是非受检异常，是系统可能会抛出的异常，程序员可以去处理，也可以不处理，最经典的就是NullPointException空指针异常和IndexOutOfBoundsException越界异常。 Exception类及其子类(不包含非受检异常)，表示的是受检异常，这是程序员必须处理的异常，不处理则程序不能通过编译，比如IOException表示的是I/O异常，SQLException表示的数据库访问异常。 我们知道，一个对象的创建过程经过内存分配，静态代码初始化、构造函数执行等过程，对象生成的关键步骤是构造函数，那是不是也允许在构造函数中抛出异常呢？从Java语法上来说，完全可以在构造函数中抛出异常，三类异常都可以，但是从系统设计和开发的角度来分析，则尽量不要在构造函数中抛出异常，我们以三种不同类型的异常来说明之。 (1)、构造函数中抛出错误是程序员无法处理的在构造函数执行时，若发生了VirtualMachineError虚拟机错误，那就没招了，只能抛出，程序员不能预知此类错误的发生，也就不能捕捉处理。 (2)、构造函数不应该抛出非受检异常我们来看这样一个例子，代码如下： class Person { public Person(int _age) { // 不满18岁的用户对象不能建立 if (_age &lt; 18) { throw new RuntimeException(\"年龄必须大于18岁.\"); } } public void doSomething() { System.out.println(\"doSomething......\"); } } 这段代码的意图很明显，年龄不满18岁的用户不会生成一个Person实例对象，没有对象，类行为doSomething方法就不可执行，想法很好，但这会导致不可预测的结果，比如我们这样引用Person类： public static void main(String[] args) { Person p = new Person(17); p.doSomething(); /*其它的业务逻辑*/ } 很显然，p对象不能建立，因为是一个RunTimeException异常，开发人员可以捕捉也可以不捕捉，代码看上去逻辑很正确，没有任何瑕疵，但是事实上，这段程序会抛出异常，无法执行。这段代码给了我们两个警示： 1.加重了上层代码编写者的负担：捕捉这个RuntimeException异常吧，那谁来告诉我有这个异常呢？只有通过文档约束了，一旦Person类的构造函数经过重构后再抛出其它非受检异常，那main方法不用修改也是可以测试通过的，但是这里就可能会产生隐藏的缺陷，而写还是很难重现的缺陷。不捕捉这个RuntimeException异常，这个是我们通常的想法，既然已经写成了非受检异常，main方法的编码者完全可以不处理这个异常嘛，大不了不执行Person的方法！这是非常危险的，一旦产生异常，整个线程都不再继续执行，或者链接没有关闭，或者数据没有写入数据库，或者产生内存异常，这些都是会对整个系统产生影响。 2.后续代码不会执行：main方法的实现者原本是想把p对象的建立作为其代码逻辑的一部分，执行完doSomething方法后还需要完成其它逻辑，但是因为没有对非受检异常进行捕捉，异常最终会抛出到JVM中，这会导致整个线程执行结束后，后面所有的代码都不会继续执行了，这就对业务逻辑产生了致命的影响。 (3)、构造函数尽可能不要抛出受检异常我们来看下面的例子，代码如下： //父类 class Base { // 父类抛出IOException public Base() throws IOException { throw new IOException(); } } //子类 class Sub extends Base { // 子类抛出Exception异常 public Sub() throws Exception { } } 就这么一段简单的代码，展示了在构造函数中抛出受检异常的三个不利方面： 1.导致子类膨胀：在我们的例子中子类的无参构造函数不能省略，原因是父类的无参构造函数抛出了IOException异常，子类的无参构造函数默认调用的是父类的构造函数，所以子类无参构造函数也必须抛出IOException或其父类。 2.违背了里氏替换原则：”里氏替换原则” 是说父类能出现的地方子类就可以出现，而且将父类替换为子类也不会产生任何异常。那我们回头看看Sub类是否可以替换Base类，比如我们的上层代码是这样写的：public static void main(String[] args) { try { Base base = new Base(); } catch (Exception e) { e.printStackTrace(); } } 然后，我们期望把new Base()替换成new Sub()，而且代码能够正常编译和运行。非常可惜，编译不通过，原因是Sub的构造函数抛出了Exception异常，它比父类的构造函数抛出更多的异常范围要宽，必须增加新的catch块才能解决。 可能大家要问了，为什么Java的构造函数允许子类的构造函数抛出更广泛的异常类呢？这正好与类方法的异常机制相反，类方法的异常是这样要求的： // 父类 class Base { // 父类方法抛出Exception public void testMethod() throws Exception { } } // 子类 class Sub extends Base { // 父类方法抛出Exception @Override public void testMethod() throws IOException { } } 子类的方法可以抛出多个异常，但都必须是覆写方法的子类型，对我们的例子来说，Sub类的testMethod方法抛出的异常必须是Exception的子类或Exception类，这是Java覆写的要求。构造函数之所以于此相反，是因为构造函数没有覆写的概念，只是构造函数间的引用调用而已，所以在构造函数中抛出受检异常会违背里氏替换原则原则，使我们的程序缺乏灵活性。 3.子类构造函数扩展受限：子类存在的原因就是期望实现扩展父类的逻辑，但父类构造函数抛出异常却会让子类构造函数的灵活性大大降低，例如我们期望这样的构造函数。 // 父类 class Base { public Base() throws IOException{ } } // 子类 class Sub extends Base { public Sub() throws Exception{ try{ super(); }catch(IOException e){ //异常处理后再抛出 throw e; }finally{ //收尾处理 } } } 很不幸，这段代码编译不通过，原因是构造函数Sub没有把super()放在第一句话中，想把父类的异常重新包装再抛出是不可行的(当然，这里有很多种 “曲线” 的实现手段，比如重新定义一个方法，然后父子类的构造函数都调用该方法，那么子类构造函数就可以自由处理异常了)，这是Java语法机制。 将以上三种异常类型汇总起来，对于构造函数，错误只能抛出，这是程序人员无能为力的事情；非受检异常不要抛出，抛出了 “ 对己对人 “ 都是有害的；受检异常尽量不抛出，能用曲线的方式实现就用曲线方式实现，总之一句话：在构造函数中尽可能不出现异常。 注意 ：在构造函数中不要抛出异常，尽量曲线实现。 建议117：多使用异常，把性能问题放一边我们知道异常是主逻辑的例外逻辑，举个简单的例子来说，比如我在马路上走(这是主逻辑)，突然开过一辆车，我要避让(这是受检异常，必须处理)，继续走着，突然一架飞机从我头顶飞过(非受检异常)，我们可以选在继续行走(不捕捉)，也可以选择指责其噪音污染(捕捉，主逻辑的补充处理)，再继续走着，突然一颗流星砸下来，这没有选择，属于错误，不能做任何处理。这样具备完整例外场景的逻辑就具备了OO的味道，任何一个事务的处理都可能产生非预期的效果，问题是需要以何种手段来处理，如果不使用异常就需要依靠返回值的不同来进行处理了，这严重失去了面向对象的风格。 我们在编写用例文档（User case Specification）时，其中有一项叫做 “ 例外事件 “，是用来描述主场景外的例外场景的，例如用户登录的用例，就会在” 例外事件 “中说明” 连续3此登录失败即锁定用户账号 “，这就是登录事件的一个异常处理，具体到我们的程序中就是： public void login(){ try{ //正常登陆 }catch(InvalidLoginException lie){ // 用户名无效 }catch(InvalidPasswordException pe){ //密码错误的异常 }catch(TooMuchLoginException){ //多次登陆失败的异常 } } 如此设计则可以让我们的login方法更符合实际的处理逻辑，同时使主逻辑(正常登录，try代码块)更加清晰。当然了，使用异常还有很多优点，可以让正常代码和异常代码分离、能快速查找问题(栈信息快照)等，但是异常有一个缺点：性能比较慢。 Java的异常机制确实比较慢，这个”比较慢”是相对于诸如String、Integer等对象来说的，单单从对象的创建上来说，new一个IOException会比String慢5倍，这从异常的处理机制上也可以解释：因为它要执行fillInStackTrace方法，要记录当前栈的快照，而String类则是直接申请一个内存创建对象，异常类慢一筹也就在所难免了。 而且，异常类是不能缓存的，期望先建立大量的异常对象以提高异常性能也是不现实的。 难道异常的性能问题就没有任何可以提高的办法了？确实没有，但是我们不能因为性能问题而放弃使用异常，而且经过测试，在JDK1.6下，一个异常对象的创建时间只需1.4毫秒左右(注意是毫秒，通常一个交易是在100毫秒左右)，难道我们的系统连如此微小的性能消耗都不予许吗？ ** 注意：性能问题不是拒绝异常的借口。** 建议121：线程优先级只使用三个等级线程的优先级(Priority)决定了线程获得CPU运行的机会，优先级越高获得的运行机会越大，优先级越低获得的机会越小。Java的线程有10个级别(准确的说是11个级别，级别为0的线程是JVM的，应用程序不能设置该级别)，那是不是说级别是10的线程肯定比级别是9的线程先运行呢?我们来看如下一个多线程类： class TestThread implements Runnable { public void start(int _priority) { Thread t = new Thread(this); // 设置优先级别 t.setPriority(_priority); t.start(); } @Override public void run() { // 消耗CPU的计算 for (int i = 0; i &lt; 100000; i++) { Math.hypot(924526789, Math.cos(i)); } // 输出线程优先级 System.out.println(\"Priority：\" + Thread.currentThread().getPriority()); } } 该多线程实现了Runnable接口，实现了run方法，注意在run方法中有一个比较占用CPU的计算，该计算毫无意义， public static void main(String[] args) { //启动20个不同优先级的线程 for (int i = 0; i &lt; 20; i++) { new TestThread().start(i % 10 + 1); } } 这里创建了20个线程，每个线程在运行时都耗尽了CPU的资源，因为优先级不同，线程调度应该是先处理优先级高的，然后处理优先级低的，也就是先执行2个优先级为10的线程，然后执行2个优先级为9的线程，2个优先级为8的线程……但是结果却并不是这样的。** Priority：5 Priority：7 Priority：10 Priority：6 Priority：9 Priority：6 Priority：5 Priority：7 Priority：10 Priority：3 Priority：4 Priority：8 Priority：8 Priority：9 Priority：4 Priority：1 Priority：3 Priority：1 Priority：2 Priority：2** println方法虽然有输出损耗，可能会影响到输出结果，但是不管运行多少次，你都会发现两个不争的事实：(1)、并不是严格按照线程优先级来执行的比如线程优先级为5的线程比优先级为7的线程先执行，优先级为1的线程比优先级为2的线程先执行，很少出现优先级为2的线程比优先级为10的线程先执行(注意，这里是” 很少 “，是说确实有可能出现，只是几率低，因为优先级只是表示线程获得CPU运行的机会，并不代表强制的排序号)。(2)、优先级差别越大，运行机会差别越明显比如优先级为10的线程通常会比优先级为2的线程先执行，但是优先级为6的线程和优先级为5的线程差别就不太明显了，执行多次，你会发现有不同的顺序。 这两个现象是线程优先级的一个重要表现，之所以会出现这种情况，是因为线程运行是需要获得CPU资源的，那谁能决定哪个线程先获得哪个线程后获得呢？这是依照操作系统设置的线程优先级来分配的，也就是说，每个线程要运行，需要操作系统分配优先级和CPU资源，对于JAVA来说，JVM调用操作系统的接口设置优先级，比如windows操作系统优先级都相同吗？ 事实上，不同的操作系统线程优先级是不同的，Windows有7个优先级，Linux有140个优先级，Freebsd则由255个(此处指的优先级个数，不同操作系统有不同的分类，如中断级线程，操作系统级等，各个操作系统具体用户可用的线程数量也不相同)。Java是跨平台的系统，需要把这10个优先级映射成不同的操作系统的优先级，于是界定了Java的优先级只是代表抢占CPU的机会大小，优先级越高，抢占CPU的机会越大，被优先执行的可能性越高，优先级相差不大，则抢占CPU的机会差别也不大，这就是导致了优先级为9的线程可能比优先级为10的线程先运行。 Java的缔造者们也觉察到了线程优先问题，于是Thread类中设置了三个优先级，此意就是告诉开发者，建议使用优先级常量，而不是1到10的随机数字。常量代码如下： public class Thread implements Runnable { /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; } 在编码时直接使用这些优先级常量，可以说在大部分情况下MAX_PRIORITY的线程回比MIN_PRIORITY的线程优先运行，但是不能认为是必然会先运行，不能把这个优先级做为核心业务的必然条件，Java无法保证优先级高肯定会先执行，只能保证高优先级有更多的执行机会。因此，建议在开发时只使用此三类优先级，没有必要使用其他7个数字，这样也可以保证在不同的操作系统上优先级的表现基本相同。 大家也许会问，如果优先级相同呢？这很好办，也是由操作系统决定的。基本上是按照FIFO原则(先入先出，First Input First Output)，但也是不能完全保证。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"《编写高质量代码》学习笔记(1)","slug":"《编写高质量代码》学习笔记-1","date":"2017-11-15T15:33:00.000Z","updated":"2020-12-09T03:20:41.929Z","comments":true,"path":"2017/11/15/bian-xie-gao-zhi-liang-dai-ma-xue-xi-bi-ji-1/","link":"","permalink":"http://www.wmyskxz.com/2017/11/15/bian-xie-gao-zhi-liang-dai-ma-xue-xi-bi-ji-1/","excerpt":"前言看大神推荐的书单中入门有这么一本书，所以决定把这本书的精华（自认为很有用的点），或许是我自己现在能用到的点都提炼出来，供大家参考学习。 以下内容均出自《编写高质量代码 改善Java程序的151个建议》——秦小波 著一书。","text":"前言看大神推荐的书单中入门有这么一本书，所以决定把这本书的精华（自认为很有用的点），或许是我自己现在能用到的点都提炼出来，供大家参考学习。 以下内容均出自《编写高质量代码 改善Java程序的151个建议》——秦小波 著一书。 建议1：不要在常量和变量中出现易混淆的字母包名全小写，类名首字母全大写，常量全部大写并用下划线分隔，变量采用驼峰命名法命名等，这些都是最基本的Java编码规范，是每个Javaer都应熟知的规则，但是在变量的声明中药注意不要引入容易混淆的字母。看下面的例子，请思考以下程序打印的i等于多少： public class Client{ public static void main(String[] args){ long i = 1l; System.out.println(“i 的两倍是：” + (i + i)); }} 肯定有人会说，这么简单的例子还能出错？运行结果肯定是22！实践是检验真理的唯一标准，将这一段程序拷贝到任一编译器中，run以下，你会发现运行结果是2，而不是22，难道是编译器显示有问题？少了一个“2”？ 因为赋值给i的值就是“1”，只是后面加了长整型变量的标示字母“l”（L的小写）而已。 **如果字母和数字必须混合使用，字母“l”务必大写，字母“O”则增加注释。** *** ## 建议9：少用静态导入 从Java 5开始引入了静态导入语法（import static），其目的是为了减少字符输入量，提高代码的可阅读性，以便更好的理解程序。先来看一个例子： ```java public class MathUtils{ //计算圆面积 public static double calCircleArea(double r){ return Math.PI ＊ r ＊ r; } //计算球面积 public static double calBallArea(double r){ return 4＊ Math.PI ＊ r ＊ r; } }这是很简单的数学工具类，我们在这两个计算面积的方法中都引入了java.lang.Math类（该类是默认导入的）中的PI（圆周率）常量，而Math这个类写在这里有点多余，特别是如果MathUtils中的方法比较多时，如果每次都要敲入Math这个类，繁琐且多余，静态导入可解决此类问题，使用静态导入后的程序如下： import static java.lang.Math.PI; public class MathUtils{ //计算圆面积 public static double calCircleArea(double r){ return PI ＊ r ＊ r; } //计算球面积 public static double calBallArea(double r){ return 4 ＊ PI ＊ r ＊ r; } } 静态导入的作用是把Math类中的PI常量引入到本类中，这会使程序更简单，更容易阅读，只要看到PI就知道这是圆周率，不用每次都要把类名写全了。这是看上去很好用的一个功能，为什么要少用呢？ 滥用静态导入会使程序更难阅读，更难维护。静态导入后，代码中就不用再写类名了，但是我们知道类是“一类事物的描述”，缺少了类名的修饰，静态属性和静态方法的表象意义可以被无限放大，这会让阅读者很难弄清楚其属性或方法代表何意，甚至是哪一个类的属性（方法）都要思考一番（当然，IDE友好提示功能是另说），特别是在一个类中有多个静态导入语句时，若还使用了*（星号）通配符，把一个类的所有静态元素都导入进来了，那简直就是恶梦。我们来看一段例子： import static java.lang.Double.＊; import static java.lang.Math.＊; import static java.lang.Integer.＊; import static java.text.NumberFormat.＊; public class Client { //输入半径和精度要求，计算面积 public static void main(String[] args) { double s = PI ＊ parseDouble(args[0]); NumberFormat nf = getInstance(); nf.setMaximumFractionDigits(parseInt(args[1])); formatMessage(nf.format(s)); } //格式化消息输出 public static void formatMessage(String s){ System.out.println(\"圆面积是：\"+s); } } 就这么一段程序，看着就让人火大：常量PI，这知道，是圆周率；parseDouble方法可能是Double类的一个转换方法，这看名称也能猜测到。那紧接着的getInstance方法是哪个类的？是Client本地类？不对呀，没有这个方法，哦，原来是NumberFormate类的方法，这和formateMessage本地方法没有任何区别了—这代码也太难阅读了，非机器不可阅读。 所以，对于静态导入，一定要遵循两个规则： 不使用*（星号）通配符，除非是导入静态常量类（只包含常量的类或接口）。 方法名是具有明确、清晰表象意义的工具类。 何为具有明确、清晰表象意义的工具类？我们来看看JUnit 4中使用的静态导入的例子，代码如下： import static org.junit.Assert.＊; public class DaoTest { @Test public void testInsert(){ //断言 assertEquals(\"foo\", \"foo\"); assertFalse(Boolean.FALSE); } } 我们从程序中很容易判断出assertEquals方法是用来断言两个值是否相等的，assertFalse方法则是断言表达式为假，如此确实减少了代码量，而且代码的可读性也提高了，这也是静态导入用到正确地方所带来的好处。 建议16：易变业务使用脚本语言编写Java世界一直在遭受着异种语言的入侵，比如PHP，Ruby，Groovy、Javascript等，这些入侵者都有一个共同特征：全是同一类语言—–脚本语言，它们都是在运行期解释执行的。为什么Java这种强编译型语言会需要这些脚本语言呢？那是因为脚本语言的三大特征，如下所示： 灵活：脚本语言一般都是动态类型，可以不用声明变量类型而直接使用，可以再运行期改变类型。 便捷：脚本语言是一种解释性语言，不需要编译成二进制代码，也不需要像Java一样生成字节码。它的执行时依靠解释器解释的，因此在运行期间变更代码很容易，而且不用停止应用； 简单：只能说部分脚本语言简单，比如Groovy，对于程序员来说，没有多大的门槛。 脚本语言的这些特性是Java缺少的，引入脚本语言可以使Java更强大，于是Java6开始正式支持脚本语言。但是因为脚本语言比较多，Java的开发者也很难确定该支持哪种语言，于是JSCP（Java Community ProCess）很聪明的提出了JSR233规范，只要符合该规范的语言都可以在Java平台上运行（它对JavaScript是默认支持的）。 先来看一个简单的例子： function formual(var1, var2){ return var1 + var2 * factor; } 这就是一个简单的脚本语言函数，可能你会很疑惑:factor(因子)这个变量是从那儿来的？它是从上下文来的，类似于一个运行的环境变量。该js保存在C:/model.js中，下一步需要调用JavaScript公式，代码如下： import java.io.FileNotFoundException; import java.io.FileReader; import java.util.Scanner; import javax.script.Bindings; import javax.script.Invocable; import javax.script.ScriptContext; import javax.script.ScriptEngine; import javax.script.ScriptEngineManager; import javax.script.ScriptException; public class Client16 { public static void main(String[] args) throws FileNotFoundException, ScriptException, NoSuchMethodException { // 获得一个JavaScript执行引擎 ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"javascript\"); // 建立上下文变量 Bindings bind = engine.createBindings(); bind.put(\"factor\", 1); // 绑定上下文，作用于是当前引擎范围 engine.setBindings(bind, ScriptContext.ENGINE_SCOPE); Scanner input =new Scanner(System.in); while(input.hasNextInt()){ int first = input.nextInt(); int second = input.nextInt(); System.out.println(\"输入参数是：\"+first+\",\"+second); // 执行Js代码 engine.eval(new FileReader(\"C:/model.js\")); // 是否可调用方法 if (engine instanceof Invocable) { Invocable in = (Invocable) engine; // 执行Js中的函数 Double result = (Double) in.invokeFunction(\"formula\", first, second); System.out.println(\"运算结果是：\" + result.intValue()); } } } } 上段代码使用Scanner类接受键盘输入的两个数字，然后调用JavaScript脚本的formula函数计算其结果，注意，除非输入了一个非int数字，否则当前JVM会一直运行，这也是模拟生成系统的在线变更情况。运行结果如下： 输入参数是;1,2 运算结果是：3 此时，保持JVM的运行状态，我们修改一下formula函数，代码如下： function formual(var1, var2){ return var1 + var2 - factor; } 其中,乘号变成了减号，计算公式发生了重大改变。回到JVM中继续输入，运行结果如下： 输入参数：1,2 运行结果是：2 修改Js代码，JVM没有重启，输入参数也没有任何改变，仅仅改变脚本函数即可产生不同的效果。这就是脚本语言对系统设计最有利的地方：可以随时发布而不用部署；这也是我们javaer最喜爱它的地方—-即使进行变更，也能提供不间断的业务服务。 Java6不仅仅提供了代码级的脚本内置，还提供了jrunscript命令工具，它可以再批处理中发挥最大效能，而且不需要通过JVM解释脚本语言，可以直接通过该工具运行脚本。想想看。这是多么大的诱惑力呀！而且这个工具是可以跨操作系统的，脚本移植就更容易了。 建议17：慎用动态编译动态编译一直是java的梦想，从Java6开始支持动态编译了，可以再运行期直接编译.java文件，执行.class，并且获得相关的输入输出，甚至还能监听相关的事件。不过，我们最期望的还是定一段代码，直接编译，然后运行，也就是空中编译执行（on-the-fly），看如下代码： import java.io.IOException; import java.lang.reflect.Method; import java.net.URI; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.SimpleJavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.ToolProvider; public class Client17 { public static void main(String[] args) throws Exception { // Java源代码 String sourceStr = \"public class Hello { public String sayHello (String name) {return \\\"Hello,\\\"+name+\\\"!\\\";}}\"; // 类名及文件名 String clsName = \"Hello\"; // 方法名 String methodName = \"sayHello\"; // 当前编译器 JavaCompiler cmp = ToolProvider.getSystemJavaCompiler(); // Java标准文件管理器 StandardJavaFileManager fm = cmp.getStandardFileManager(null, null, null); // Java文件对象 JavaFileObject jfo = new StringJavaObject(clsName, sourceStr); // 编译参数，类似于javac &lt;options>中的options List&lt;String> optionsList = new ArrayList&lt;String>(); // 编译文件的存放地方，注意：此处是为Eclipse工具特设的 optionsList.addAll(Arrays.asList(\"-d\", \"./bin\")); // 要编译的单元 List&lt;JavaFileObject> jfos = Arrays.asList(jfo); // 设置编译环境 JavaCompiler.CompilationTask task = cmp.getTask(null, fm, null, optionsList, null, jfos); // 编译成功 if (task.call()) { // 生成对象 Object obj = Class.forName(clsName).newInstance(); Class&lt;? extends Object> cls = obj.getClass(); // 调用sayHello方法 Method m = cls.getMethod(methodName, String.class); String str = (String) m.invoke(obj, \"Dynamic Compilation\"); System.out.println(str); } } } class StringJavaObject extends SimpleJavaFileObject { // 源代码 private String content = \"\"; // 遵循Java规范的类名及文件 public StringJavaObject(String _javaFileName, String _content) { super(_createStringJavaObjectUri(_javaFileName), Kind.SOURCE); content = _content; } // 产生一个URL资源路径 private static URI _createStringJavaObjectUri(String name) { // 注意，此处没有设置包名 return URI.create(\"String:///\" + name + Kind.SOURCE.extension); } // 文本文件代码 @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException { return content; } } 上面代码较多，可以作为一个动态编译的模板程序。只要是在本地静态编译能够实现的任务，比如编译参数，输入输出，错误监控等，动态编译都能实现。 Java的动态编译对源提供了多个渠道。比如，可以是字符串，文本文件，字节码文件，还有存放在数据库中的明文代码或者字节码。**汇总一句话，只要符合Java规范的就可以在运行期动态加载，**其实现方式就是实现JavaFileObject接口，重写getCharContent、openInputStream、openOutputStream，或者实现JDK已经提供的两个SimpleJavaFileObject、ForwardingJavaFileObject,具体代码可以参考上个例子。 动态编译虽然是很好的工具，让我们可以更加自如的控制编译过程，但是在我们目前所接触的项目中还是使用较少。原因很简单，静态编译已经能够帮我们处理大部分的工作，甚至是全部的工作，即使真的需要动态编译，也有很好的替代方案，比如Jruby、Groovy等无缝的脚本语言。另外，我们在使用动态编译时，需要注意以下几点： 在框架中谨慎使用：比如要在struts中使用动态编译，动态实现一个类，它若继承自ActionSupport就希望它成为一个Action。能做到，但是debug很困难；再比如在Spring中，写一个动态类，要让它注入到Spring容器中，这是需要花费老大功夫的。 不要在要求性能高的项目中使用：如果你在web界面上提供了一个功能，允许上传一个java文件然后运行，那就等于说:”我的机器没有密码，大家都可以看看”，这是非常典型的注入漏洞，只要上传一个恶意Java程序就可以让你所有的安全工作毁于一旦。 动态编译要考虑安全问题：如果你在Web界面上提供了一个功能，允许上传一个Java文件然后运行，那就等于说：“我的机器没有密码，大家都来看我的隐私吧”，这就是非常典型的注入漏洞，只要上传一个而已Java程序就可以让你所有的安全工作毁于一旦。 记录动态编译过程：建议记录源文件，目标文件，编译过程，执行过程等日志，不仅仅是为了诊断，还是为了安全和审计，对Java项目来说，空中编译和运行时很不让人放心的，留下这些依据可以很好地优化程序。 建议21：用偶判断，不用奇判断判断一个数是奇数还是偶数是小学里的基本知识，能够被2整除的整数是偶数，不能被2整除的数是奇数，这规则简单明了，还有什么可考虑的？好，我们来看一个例子，代码如下： import java.util.Scanner; public class Client21 { public static void main(String[] args) { // 接收键盘输入参数 Scanner input = new Scanner(System.in); System.out.println(\"输入多个数字判断奇偶：\"); while (input.hasNextInt()) { int i = input.nextInt(); String str = i + \"-->\" + (i % 2 == 1 ? \"奇数\" : \"偶数\"); System.out.println(str); } } } 输入多个数字，然后判断每个数字的奇偶性，不能被2整除的就是奇数，其它的都是偶数，完全是根据奇偶数的定义编写的程序，我们开看看打印的结果： 输入多个数字判断奇偶：1 2 0 -1 -2 1--&gt;奇数 2--&gt;偶数 0--&gt;偶数 -1--&gt;偶数 -2--&gt;偶数前三个还很靠谱，第四个参数-1怎么可能是偶数呢，这Java也太差劲了吧。如此简单的计算也会出错！别忙着下结论，我们先来了解一下Java中的取余(%标识符)算法，模拟代码如下： // 模拟取余计算，dividend被除数，divisor除数 public static int remainder(int dividend, int divisor) { return dividend - dividend / divisor * divisor; } 看到这段程序，大家都会心的笑了，原来Java这么处理取余计算的呀，根据上面的模拟取余可知，当输入-1的时候，运算结果为-1，当然不等于1了，所以它就被判定为偶数了，也就是我们的判断失误了。问题明白了，修正也很简单，改为判断是否是偶数即可。代码如下： i % 2 == 0 ? \"偶数\" : \"奇数\"; 注意：对于基础知识，我们应该”知其然，并知其所以然”。 建议22：用整数类型处理货币在日常生活中，最容易接触到的小数就是货币，比如，你付给售货员10元钱购买一个9.6元的零食，售货员应该找你0.4元，也就是4毛钱才对，我们来看下面的程序： public class Client22 { public static void main(String[] args) { System.out.println(10.00-9.60); } } 我们的期望结果是0.4，也应该是这个数字，但是打印出来的却是:0.40000000000000036,这是为什么呢？ 这是因为在计算机中浮点数有可能（注意是有可能）是不准确的，它只能无限接近准确值，而不能完全精确。为什么会如此呢？这是由浮点数的存储规则所决定的，我们先来看看0.4这个十进制小数如何转换成二进制小数，使用”乘2取整，顺序排列”法（不懂，这就没招了，这太基础了），我们发现0.4不能使用二进制准确的表示，在二进制数世界里它是一个无限循环的小数，也就是说，”展示” 都不能 “展示”，更别说在内存中存储了(浮点数的存储包括三部分：符号位、指数位、尾数，具体不再介绍)，可以这样理解，在十进制的世界里没有办法唯一准确表示1/3，那么在二进制的世界里当然也无法准确表示1/5(如果二进制也有分数的话倒是可以表示)，在二进制的世界里1/5是一个无限循环的小数。 大家可能要说了，那我对结果取整不就对了吗？代码如下: public class Client22 { public static void main(String[] args) { NumberFormat f = new DecimalFormat(\"#.##\"); System.out.println(f.format(10.00-9.60)); } } 打印出的结果是0.4，看似解决了。但是隐藏了一个很深的问题。我们来思考一下金融行业的计算方法，会计系统一般记录小数点后的4为小数，但是在汇总、展现、报表中、则只记录小数点后的2位小数，如果使用浮点数来计算货币，想想看，在大批量加减乘除后结果会有很大的差距(其中还涉及到四舍五入的问题)！会计系统要求的就是准确，但是因为计算机的缘故不准确了，那真是罪过，要解决此问题有两种方法： (1)使用BigDecimal BigDecimal是专门为弥补浮点数无法精确计算的缺憾而设计的类，并且它本身也提供了加减乘除的常用数学算法。特别是与数据库Decimal类型的字段映射时，BigDecimal是最优的解决方案。 (2)使用整型 把参与运算的值扩大100倍，并转为整型，然后在展现时再缩小100倍，这样处理的好处是计算简单，准确，一般在非金融行业(如零售行业)应用较多。此方法还会用于某些零售POS机，他们输入和输出的全部是整数，那运算就更简单了。 建议23：不要让类型默默转换我们做一个小学生的题目，光速每秒30万公里，根据光线的旅行时间，计算月球和地球，太阳和地球之间的距离。代码如下： public class Client23 { // 光速是30万公里/秒，常量 public static final int LIGHT_SPEED = 30 * 10000 * 1000; public static void main(String[] args) { System.out.println(\"题目1：月球照射到地球需要一秒，计算月亮和地球的距离。\"); long dis1 = LIGHT_SPEED * 1; System.out.println(\"月球与地球的距离是：\" + dis1 + \" 米 \"); System.out.println(\"-------------------------------\"); System.out.println(\"题目2：太阳光照射到地球需要8分钟，计算太阳到地球的距离.\"); // 可能要超出整数范围，使用long型 long dis2 = LIGHT_SPEED * 60 * 8; System.out.println(\"太阳与地球之间的距离是：\" + dis2 + \" 米\"); } } 估计有人鄙视了，这种小学生的乘法有神么可做的，不错，就是一个乘法运算，我们运行之后的结果如下： 题目1：月球照射到地球需要一秒，计算月亮和地球的距离。 月球与地球的距离是：300000000 米 ------------------------------- 题目2：太阳光照射到地球需要8分钟，计算太阳到地球的距离. 太阳与地球之间的距离是：-2028888064 米 太阳和地球的距离竟然是负的，诡异。dis2不是已经考虑到int类型可能越界的问题，并使用了long型吗，怎么还会出现负值呢？ 那是因为Java是先运算然后进行类型转换的，具体的说就是因为dis2的三个运算参数都是int型，三者相乘的结果虽然也是int型，但是已经超过了int的最大值，所以其值就是负值了(为什么是负值，因为过界了就会重头开始)，再转换为long型，结果还是负值。 问题知道了，解决起来也很简单，只要加个小小的L即可，代码如下： long dis2 = LIGHT_SPEED * 60L * 8; 60L是一个长整型，乘出来的结果也是一个长整型的（此乃Java的基本转换规则，向数据范围大的方向转换，也就是加宽类型），在还没有超过int类型的范围时就已经转换为long型了，彻底解决了越界问题。在实际开发中，更通用的做法是主动声明类型转化(注意，不是强制类型转换)，代码如下： long dis2 = 1L * LIGHT_SPEED * 60L * 8 既然期望的结果是long型，那就让第一个参与的参数也是Long(1L)吧，也就说明”嗨”我已经是长整型了，你们都跟着我一块转为长整型吧。 注意：基本类型转换时，使用主动声明方式减少不必要的Bug. 建议25：不要让四舍五入亏了一方本建议还是来重温一个小学数学问题：四舍五入。四舍五入是一种近似精确的计算方法，在Java5之前，我们一般是通过Math.round来获得指定精度的整数或小数的，这种方法使用非常广泛，代码如下： public class Client25 { public static void main(String[] args) { System.out.println(\"10.5近似值: \"+Math.round(10.5)); System.out.println(\"-10.5近似值: \"+Math.round(-10.5)); } } 输出结果为：10.5近似值: 11 -10.5近似值: -10 这是四舍五入的经典案例，也是初级面试官很乐意选择的考题，绝对值相同的两个数字，近似值为什么就不同了呢？这是由Math.round采用的舍入规则决定的(采用的是正无穷方向舍入规则)，我们知道四舍五入是有误差的：其误差值是舍入的一半。我们以舍入运用最频繁的银行利息计算为例来阐述此问题。 我们知道银行的盈利渠道主要是利息差，从储户手里收拢资金，然后房贷出去，期间的利息差额便是所获得利润，对一个银行来说，对付给储户的利息计算非常频繁，人民银行规定每个季度末月的20日为银行结息日，一年有4次的结息日。 场景介绍完毕，我们回头来看看四舍五入，小于5的数字被舍去，大于5的数字进位后舍去，由于单位上的数字都是自然计算出来的，按照利率计算可知，被舍去的数字都分布在0~9之间，下面以10笔存款利息计算作为模型，以银行家的身份来思考这个算法： 四舍：舍弃的数值是：0.000、0.001、0.002、0.003、0.004因为是舍弃的，对于银行家来说就不需要付款给储户了，那每舍一个数字就会赚取相应的金额：0.000、0.001、0.002、0.003、0.004. 五入：进位的数值是：0.005、0.006、0.007、0.008、0.009，因为是进位，对银行家来说，每进一位就会多付款给储户，也就是亏损了，那亏损部分就是其对应的10进制补数：0.005、.0004、0.003、0.002、0.001. 因为舍弃和进位的数字是均匀分布在0~9之间，对于银行家来说，没10笔存款的利息因采用四舍五入而获得的盈利是：0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = - 0.005； 也就是说，每10笔利息计算中就损失0.005元，即每笔利息计算就损失0.0005元，这对一家有5千万储户的银行家来说(对国内银行来说，5千万是个小数字)，每年仅仅因为四舍五入的误差而损失的金额是：5000100000.00054=100000.0；即，每年因为一个算法误差就损失了10万元，事实上以上的假设条件都是非常保守的，实际情况可能损失的更多。那各位可能要说了，银行还要放贷呀，放出去这笔计算误差不就抵消了吗？不会抵消，银行的贷款数量是非常有限的其数量级根本无法和存款相比。 这个算法误差是由美国银行家发现的(那可是私人银行，钱是自己的，白白损失了可不行)，并且对此提出了一个修正算法，叫做银行家舍入(Banker’s Round)的近似算法，其规则如下： 舍去位的数值小于5时，直接舍去； 舍去位的数值大于等于6时，进位后舍去； 当舍去位的数值等于5时，分两种情况：5后面还有其它数字(非0)，则进位后舍去；若5后面是0(即5是最后一个数字)，则根据5前一位数的奇偶性来判断是否需要进位，奇数进位，偶数舍去。 以上规则汇总成一句话：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。我们举例说明，取2位精度： round(10.5551) = 10.56 round(10.555) = 10.56 round(10.545) = 10.56 要在Java5以上的版本中使用银行家的舍入法则非常简单，直接使用RoundingMode类提供的Round模式即可，示例代码如下： import java.math.BigDecimal; import java.math.RoundingMode; public class Client25 { public static void main(String[] args) { // 存款 BigDecimal d = new BigDecimal(888888); // 月利率，乘3计算季利率 BigDecimal r = new BigDecimal(0.001875*3); //计算利息 BigDecimal i =d.multiply(r).setScale(2,RoundingMode.HALF_EVEN); System.out.println(\"季利息是：\"+i); } } 在上面的例子中，我们使用了BigDecimal类，并且采用了setScale方法设置了精度，同时传递了一个RoundingMode.HALF_EVEN参数表示使用银行家法则进行近似计算，BigDecimal和RoundingMode是一个绝配，想要采用什么方式使用RoundingMode设置即可。目前Java支持以下七种舍入方式： ROUND_UP：原理零方向舍入。向远离0的方向舍入，也就是说，向绝对值最大的方向舍入，只要舍弃位非0即进位。 ROUND_DOWN：趋向0方向舍入。向0方向靠拢，也就是说，向绝对值最小的方向输入，注意：所有的位都舍弃，不存在进位情况。 ROUND_CEILING：向正无穷方向舍入。向正最大方向靠拢，如果是正数，舍入行为类似于ROUND_UP；如果为负数，则舍入行为类似于ROUND_DOWN.注意：Math.round方法使用的即为此模式。 ROUND_FLOOR：向负无穷方向舍入。向负无穷方向靠拢，如果是正数，则舍入行为类似ROUND_DOWN，如果是负数，舍入行为类似以ROUND_UP。 HALF_UP：最近数字舍入(5舍)，这就是我们经典的四舍五入。 HALF_DOWN：最近数字舍入(5舍)。在四舍五入中，5是进位的，在HALF_DOWN中却是舍弃不进位。 HALF_EVEN：银行家算法，在普通的项目中舍入模式不会有太多影响，可以直接使用Math.round方法，但在大量与货币数字交互的项目中，一定要选择好近似的计算模式，尽量减少因算法不同而造成的损失。 注意：根据不同的场景，慎重选择不同的舍入模式，以提高项目的精准度，减少算法损失。 建议28：优先使用整型池首先看看如下代码： import java.util.Scanner; public class Client28 { public static void main(String[] args) { Scanner input = new Scanner(System.in); while (input.hasNextInt()) { int tempInt = input.nextInt(); System.out.println(\"\\n=====\" + tempInt + \" 的相等判断=====\"); // 两个通过new产生的对象 Integer i = new Integer(tempInt); Integer j = new Integer(tempInt); System.out.println(\" new 产生的对象：\" + (i == j)); // 基本类型转换为包装类型后比较 i = tempInt; j = tempInt; System.out.println(\" 基本类型转换的对象：\" + (i == j)); // 通过静态方法生成一个实例 i = Integer.valueOf(tempInt); j = Integer.valueOf(tempInt); System.out.println(\" valueOf产生的对象：\" + (i == j)); } } } 输入多个数字，然后按照3中不同的方式产生Integer对象，判断其是否相等，注意这里使用了”==”，这说明判断的不是同一个对象。我们输入三个数字127、128、555，结果如下： 127 =====127 的相等判断===== new 产生的对象：false 基本类型转换的对象：true valueOf产生的对象：true 128 =====128 的相等判断===== new 产生的对象：false 基本类型转换的对象：false valueOf产生的对象：false 555 =====555 的相等判断===== new 产生的对象：false 基本类型转换的对象：false valueOf产生的对象：false 很不可思议呀，数字127的比较结果竟然和其它两个数字不同，它的装箱动作所产生的对象竟然是同一个对象，valueOf产生的也是同一个对象，但是大于127的数字和128和555的比较过程中产生的却不是同一个对象，这是为什么？我们来一个一个解释。 (1)new产生的Integer对象new声明的就是要生成一个新的对象，没二话，这是两个对象，地址肯定不等，比较结果为false。 (2)装箱生成的对象对于这一点，首先要说明的是装箱动作是通过valueOf方法实现的，也就是说后两个算法相同的，那结果肯定也是一样的，现在问题是：valueOf是如何生成对象的呢？我们来阅读以下Integer.valueOf的源码 /** * Returns an {@code Integer} instance representing the specified * {@code int} value. If a new {@code Integer} instance is not * required, this method should generally be used in preference to * the constructor {@link #Integer(int)}, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an {@code int} value. * @return an {@code Integer} instance representing {@code i}. * @since 1.5 */ public static Integer valueOf(int i) { assert IntegerCache.high >= 127; if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 这段代码的意思已经很明了了，如果是-128到127之间的int类型转换为Integer对象，则直接从cache数组中获得，那cache数组里是什么东西，JDK7的源代码如下： /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the -XX:AutoBoxCacheMax=&lt;size> option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low)); } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); } private IntegerCache() {} } cache是IntegerCache内部类的一个静态数组，容纳的是-128到127之间的Integer对象。通过valueOf产生包装对象时，如果int参数在-128到127之间，则直接从整型池中获得对象，不在该范围内的int类型则通过new生成包装对象。 明白了这一点，要理解上面的输出结果就迎刃而解了，127的包装对象是直接从整型池中获得的，不管你输入多少次127这个数字，获得的对象都是同一个，那地址自然是相等的。而128、555超出了整型池范围，是通过new产生一个新的对象，地址不同，当然也就不相等了。 以上的理解也是整型池的原理，整型池的存在不仅仅提高了系统性能，同时也节约了内存空间，这也是我们使用整型池的原因，也就是在声明包装对象的时候使用valueOf生成，而不是通过构造函数来生成的原因。顺便提醒大家，在判断对象是否相等的时候，最好使用equals方法，避免使用”==”产生非预期效果。 注意：通过包装类型的valueOf生成的包装实例可以显著提高空间和时间性能。 建议29：优先选择基本类型包装类型是一个类，它提供了诸如构造方法，类型转换，比较等非常实用的功能，而且在Java5之后又实现了与基本类型的转换，这使包装类型如虎添翼，更是应用广泛了，在开发中包装类型已经随处可见，但无论是从安全性、性能方面来说，还是从稳定性方面来说，基本类型都是首选方案。我们看一段代码： public class Client29 { public static void main(String[] args) { Client29 c = new Client29(); int i = 140; // 分别传递int类型和Integer类型 c.testMethod(i); c.testMethod(new Integer(i)); } public void testMethod(long a) { System.out.println(\" 基本类型的方法被调用\"); } public void testMethod(Long a) { System.out.println(\" 包装类型的方法被调用\"); } } 在上面的程序中首先声明了一个int变量i，然后加宽转变成long型，再调用testMethod()方法,分别传递int和long的基本类型和包装类型，诸位想想该程序是否能够编译？如果能编译，输出结果又是什么呢？ 首先，这段程序绝对是能够编译的。不过，说不能编译的同学还是动了一番脑筋的，你可能猜测以下这些地方不能编译： (1)testMethod方法重载问题。定义的两个testMethod()方法实现了重载，一个形参是基本类型，一个形参是包装类型，这类重载很正常。虽然基本类型和包装类型有自动装箱、自动拆箱功能，但并不影响它们的重载，自动拆箱(装箱)只有在赋值时才会发生，和编译重载没有关系。 (2)c.testMethod(i) 报错。i 是int类型，传递到testMethod(long a)是没有任何问题的，编译器会自动把 i 的类型加宽，并将其转变为long型，这是基本类型的转换法则，也没有任何问题。 (3)c.testMethod(new Integer(i))报错。代码中没有testMethod(Integer i)方法，不可能接收一个Integer类型的参数，而且Integer和Long两个包装类型是兄弟关系，不是继承关系，那就是说肯定编译失败了？不，编译时成功的，稍后再解释为什么这里编译成功。 既然编译通过了，我们看一下输出： 基本类型的方法被调用 基本类型的方法被调用c.testMethod(i)的输出是正常的，我们已经解释过了，那第二个输出就让人困惑了，为什么会调用testMethod（long a）方法呢？这是因为自动装箱有一个重要原则：基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转变成宽类型的包装类型。这句话比较拗口，简单的说就是，int可以加宽转变成long，然后再转变成Long对象，但不能直接转变成包装类型，注意这里指的都是自动转换，不是通过构造函数生成，为了解释这个原则，我们再来看一个例子： public class Client29 { public static void main(String[] args) { Client29 c = new Client29(); int i = 140; c.testMethod(i); } public void testMethod(Long a) { System.out.println(\" 包装类型的方法被调用\"); } } 这段程序的编译是不通过的，因为i是一个int类型，不能自动转变为Long型，但是修改成以下代码就可以通过了：int i = 140; long a =（long）i； c.testMethod(a);这就是int先加宽转变成为long型，然后自动转换成Long型，规则说明了，我们继续来看testMethod(Integer.valueOf(i))是如何调用的，Integer.valueOf(i)返回的是一个Integer对象，这没错，但是Integer和int是可以互相转换的。没有testMethod(Integer i)方法？没关系，编译器会尝试转换成int类型的实参调用，Ok，这次成功了，与testMethod（i）相同了，于是乎被加宽转变成long型—结果也很明显了。整个testMethod(Integer.valueOf(i))的执行过程是这样的： (1)i 通过valueOf方法包装成一个Integer对象 (2)由于没有testMethod(Integer i)方法，编译器会”聪明”的把Integer对象转换成int。 (3)int自动拓宽为long，编译结束 使用包装类型确实有方便的方法，但是也引起一些不必要的困惑，比如我们这个例子，如果testMethod()的两个重载方法使用的是基本类型，而且实参也是基本类型，就不会产生以上问题，而且程序的可读性更强。自动装箱(拆箱)虽然很方便，但引起的问题也非常严重，我们甚至都不知道执行的是哪个方法。 注意：重申，基本类型优先考虑。 建议31：在接口中不要存在实现代码看到这样的标题，大家是否感到郁闷呢？接口中有实现代码吗？这怎么可能呢？确实，接口中可以声明常量，声明抽象方法，可以继承父接口，但就是不能有具体实现，因为接口是一种契约(Contract),是一种框架性协议，这表明它的实现类都是同一种类型，或者具备相似特征的一个集合体。对于一般程序，接口确实没有任何实现，但是在那些特殊的程序中就例外了，阅读如下代码： public class Client31 { public static void main(String[] args) { //调用接口的实现 B.s.doSomeThing(); } } // 在接口中存在实现代码 interface B { public static final S s = new S() { public void doSomeThing() { System.out.println(\"我在接口中实现了\"); } }; } // 被实现的接口 interface S { public void doSomeThing(); } 仔细看main方法，注意那个B接口。它调用了接口常量，在没有实现任何显示实现类的情况下，它竟然打印出了结果，那B接口中的s常量(接口是S)是在什么地方被实现的呢？答案在B接口中。 在B接口中声明了一个静态常量s，其值是一个匿名内部类(Anonymous Inner Class)的实例对象，就是该匿名内部类（当然，也可以不用匿名，直接在接口中是实现内部类也是允许的）实现了S接口。你看，在接口中也存在着实现代码吧！ 这确实很好，很强大，但是在一般的项目中，此类代码是严禁出现的，原因很简单：这是一种非常不好的编码习惯，接口是用来干什么的？接口是一个契约，不仅仅约束着实现，同时也是一个保证，保证提供的服务(常量和方法)是稳定的、可靠的，如果把实现代码写到接口中，那接口就绑定了可能变化的因素，这会导致实现不再稳定和可靠，是随时都可能被抛弃、被更改、被重构的。所以，接口中虽然可以有实现，但应避免使用。 注意：接口中不能出现实现代码。 建议32：静态变量一定要先声明后赋值这个标题是否像上一个建议的标题一样让人郁闷呢？什么叫做变量一定要先声明后赋值？Java中的变量不都是先声明后使用的吗？难道还能先使用后声明?能不能暂且不说，我们看一个例子，代码如下： public class Client32 { public static int i = 1; static { i = 100; } public static void main(String[] args) { System.out.println(i); } } 这段程序很简单，输出100嘛，对，确实是100，我们稍稍修改一下，代码如下： public class Client32 { static { i = 100; } public static int i = 1; public static void main(String[] args) { System.out.println(i); } } 注意变量 i 的声明和赋值调换了位置，现在的问题是：这段程序能否编译？如过可以编译，输出是多少？还要注意，这个变量i可是先使用(也就是赋值)后声明的。 答案是：可以编译，没有任何问题，输出结果为1。对，输出是 1 不是100.仅仅调换了位置，输出就变了，而且变量 i 还是先使用后声明的，难道颠倒了？ 这要从静态变量的诞生说起，静态变量是类加载时被分配到数据区(Data Area)的，它在内存中只有一个拷贝，不会被分配多次，其后的所有赋值操作都是值改变，地址则保持不变。我们知道JVM初始化变量是先声明空间，然后再赋值，也就是说：在JVM中是分开执行的，等价于： int i ; //分配空间 i = 100; //赋值 静态变量是在类初始化的时候首先被加载的，JVM会去查找类中所有的静态声明，然后分配空间，注意这时候只是完成了地址空间的分配，还没有赋值，之后JVM会根据类中静态赋值(包括静态类赋值和静态块赋值)的先后顺序来执行。对于程序来说，就是先声明了int类型的地址空间，并把地址传递给了i，然后按照类的先后顺序执行赋值操作，首先执行静态块中i = 100,接着执行 i = 1,那最后的结果就是 i =1了。 哦，如此而已，如果有多个静态块对 i 继续赋值呢？i 当然还是等于1了，谁的位置最靠后谁有最终的决定权。 有些程序员喜欢把变量定义放到类最底部，如果这是实例变量还好说，没有任何问题，但如果是静态变量，而且还在静态块中赋值了，那这结果就和期望的不一样了，所以遵循Java通用的开发规范”变量先声明后赋值使用”，是一个良好的编码风格。 注意：再次重申变量要先声明后使用，这不是一句废话。 建议35：避免在构造函数中初始化其它类构造函数是一个类初始化必须执行的代码，它决定着类初始化的效率，如果构造函数比较复杂，而且还关联了其它类，则可能产生想不到的问题，我们来看如下代码： public class Client35 { public static void main(String[] args) { Son son = new Son(); son.doSomething(); } } // 父类 class Father { public Father() { new Other(); } } // 相关类 class Other { public Other() { new Son(); } } // 子类 class Son extends Father { public void doSomething() { System.out.println(\"Hi, show me Something!\"); } } 这段代码并不复杂，只是在构造函数中初始化了其它类，想想看这段代码的运行结果是什么？会打印出”Hi ，show me Something!”吗？ 答案是这段代码不能运行，报StatckOverflowError异常，栈(Stack)内存溢出，这是因为声明变量son时，调用了Son的无参构造函数，JVM又默认调用了父类的构造函数，接着Father又初始化了Other类，而Other类又调用了Son类，于是一个死循环就诞生了，知道内存被消耗完停止。 大家可能觉得这样的场景不会出现在开发中，我们来思考这样的场景，Father是由框架提供的，Son类是我们自己编写的扩展代码，而Other类则是框架要求的拦截类(Interceptor类或者Handle类或者Hook方法)，再来看看问题，这种场景不可能出现吗? 可能大家会觉得这样的场景不会出现，这种问题只要系统一运行就会发现，不可能对项目产生影响。 那是因为我们这里展示的代码比较简单，很容易一眼洞穿，一个项目中的构造函数可不止一两个，类之间的关系也不会这么简单，要想瞥一眼就能明白是否有缺陷这对所有人员来说都是不可能完成的任务，解决此类问题最好的办法就是：不要在构造函数中声明初始化其他类，养成良好习惯。 建议36：使用构造代码块精简程序什么叫做代码块(Code Block)？用大括号把多行代码封装在一起，形成一个独立的数据体，实现特定算法的代码集合即为代码块，一般来说代码快不能单独运行的，必须要有运行主体。在Java中一共有四种类型的代码块： 普通代码块：就是在方法后面使用”{}”括起来的代码片段，它不能单独运行，必须通过方法名调用执行； 静态代码块：在类中使用static修饰，并用”{}”括起来的代码片段，用于静态变量初始化或对象创建前的环境初始化。 同步代码块：使用synchronized关键字修饰，并使用”{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。 构造代码块：在类中没有任何前缀和后缀,并使用”{}”括起来的代码片段； 我么知道一个类中至少有一个构造函数(如果没有，编译器会无私的为其创建一个无参构造函数)，构造函数是在对象生成时调用的，那现在为你来了：构造函数和代码块是什么关系，构造代码块是在什么时候执行的？在回答这个问题之前，我们先看看编译器是如何处理构造代码块的，看如下代码： public class Client36 { { // 构造代码块 System.out.println(\"执行构造代码块\"); } public Client36() { System.out.println(\"执行无参构造\"); } public Client36(String name) { System.out.println(\"执行有参构造\"); } } 这是一段非常简单的代码，它包含了构造代码块、无参构造、有参构造，我们知道代码块不具有独立执行能力，那么编译器是如何处理构造代码块的呢？很简单，编译器会把构造代码块插入到每个构造函数的最前端，上面的代码等价于： public class Client36 { public Client36() { System.out.println(\"执行构造代码块\"); System.out.println(\"执行无参构造\"); } public Client36(String name) { System.out.println(\"执行构造代码块\"); System.out.println(\"执行有参构造\"); } } 每个构造函数的最前端都被插入了构造代码块，很显然，在通过new关键字生成一个实例时会先执行构造代码块，然后再执行其他代码，也就是说：构造代码块会在每个构造函数内首先执行（需要注意的是：构造代码块不是在构造函数之前运行的，它依托于构造函数的执行），明白了这一点，我们就可以把构造代码块应用到如下场景中： 初始化实例变量(Instance Variable):如果每个构造函数都要初始化变量，可以通过构造代码块来实现。当然也可以通过定义一个方法，然后在每个构造函数中调用该方法来实现，没错，可以解决，但是要在每个构造函数中都调用该方法，而这就是其缺点，若采用构造代码块的方式则不用定义和调用，会直接由编译器写入到每个构造函数中，这才是解决此问题的绝佳方式。 初始化实例环境：一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建该对象的时候创建次场景，例如在JEE开发中，要产生HTTP Request必须首先建立HTTP Session，在创建HTTP Request时就可以通过构造代码块来检查HTTP Session是否已经存在，不存在则创建之。 以上两个场景利用了构造代码块的两个特性：在每个构造函数中都运行和在构造函数中它会首先运行。很好的利用构造代码块的这连个特性不仅可以减少代码量，还可以让程序更容易阅读，特别是当所有的构造函数都要实现逻辑，而且这部分逻辑有很复杂时，这时就可以通过编写多个构造代码块来实现。每个代码块完成不同的业务逻辑（当然了构造函数尽量简单，这是基本原则），按照业务顺序一次存放，这样在创建实例对象时JVM就会按照顺序依次执行，实现复杂对象的模块化创建。 建议37：构造代码块会想你所想上一建议中我们提议使用构造代码块来简化代码，并且也了解到编译器会自动把构造代码块插入到各个构造函数中，那我们接下来看看，编译器是不是足够聪明，能为我们解决真实的开发问题，有这样一个案例，统计一个类的实例变量数。你可要说了，这很简单，在每个构造函数中加入一个对象计数器补救解决了嘛？或者我们使用上一建议介绍的，使用构造代码块也可以，确实如此，我们来看如下代码是否可行： public class Client37 { public static void main(String[] args) { new Student(); new Student(\"张三\"); new Student(10); System.out.println(\"实例对象数量：\"+Student.getNumOfObjects()); } } class Student { // 对象计数器 private static int numOfObjects = 0; { // 构造代码块，计算产生的对象数量 numOfObjects++; } public Student() { } // 有参构造调用无参构造 public Student(String stuName) { this(); } // 有参构造不调用无参构造 public Student(int stuAge) { } //返回在一个JVM中，创建了多少实例对象 public static int getNumOfObjects(){ return numOfObjects; } } 这段代码可行吗？能计算出实例对象的数量吗？如果编译器把构造代码块插入到各个构造函数中，那带有String形参的构造函数就可能有问题，它会调用无参构造，那通过它生成的Student对象就会执行两次构造代码块：一次是无参构造函数调用构造代码块，一次是执行自身的构造代码块，这样的话计算就不准确了，main函数实际在内存中产生了3个对象，但结果确是4。不过真的是这样吗？我们运行之后，结果是： 实例对象数量：3； 实例对象的数量还是3，程序没有问题，奇怪吗？不奇怪，上一建议是说编译器会把构造代码块插入到每一个构造函数中，但是有一个例外的情况没有说明：如果遇到this关键字(也就是构造函数调用自身的其它构造函数时)，则不插入构造代码块，对于我们的例子来说，编译器在编译时发现String形参的构造函数调用了无参构造，于是放弃插入构造代码块，所以只执行了一次构造代码块。 那Java编译器为何如此聪明？这还要从构造代码块的诞生说起，构造代码块是为了提取构造函数的共同量，减少各个构造函数的代码产生的，因此，Java就很聪明的认为把代码插入到this方法的构造函数中即可，而调用其它的构造函数则不插入，确保每个构造函数只执行一次构造代码块。 还有一点需要说明，大家千万不要以为this是特殊情况，那super也会类似处理了，其实不会，在构造块的处理上，super方法没有任何特殊的地方，编译器只把构造代码块插入到super方法之后执行而已。仅此不同。 注意：放心的使用构造代码块吧，Java已经想你所想了。 建议38：使用静态内部类提高封装性Java中的嵌套类(Nested Class)分为两种：静态内部类(也叫静态嵌套类，Static Nested Class)和内部类(Inner Class)。本次主要看看静态内部类。什么是静态内部类呢？是内部类，并且是静态(static修饰)的即为静态内部类，只有在是静态内部类的情况下才能把static修饰符放在类前，其它任何时候static都是不能修饰类的。 静态内部类的形式很好理解，但是为什么需要静态内部类呢？那是因为静态内部类有两个优点：加强了类的封装和提高了代码的可读性，我们通过下面代码来解释这两个优点。 public class Person { // 姓名 private String name; // 家庭 private Home home; public Person(String _name) { name = _name; } /* home、name的setter和getter方法略 */ public static class Home { // 家庭地址 private String address; // 家庭电话 private String tel; public Home(String _address, String _tel) { address = _address; tel = _tel; } /* address、tel的setter和getter方法略 */ } } 其中，Person类中定义了一个静态内部类Home,它表示的意思是”人的家庭信息”，由于Home类封装了家庭信息，不用再Person中再定义homeAddr,homeTel等属性，这就使封装性提高了。同时我们仅仅通过代码就可以分析出Person和Home之间的强关联关系，也就是说语义增强了，可读性提高了。所以在使用时就会非常清楚它表达的含义。 public static void main(String[] args) { // 定义张三这个人 Person p = new Person(\"张三\"); // 设置张三的家庭信息 p.setHome(new Home(\"北京\", \"010\")); } 定义张三这个人，然后通过Person.Home类设置张三的家庭信息，这是不是就和我们真是世界的情形相同了？先登记人的主要信息，然后登记人员的分类信息。可能你由要问了，这和我们一般定义的类有神么区别呢？又有什么吸引人的地方呢？如下所示： 1.提高封装性：从代码的位置上来讲，静态内部类放置在外部类内，其代码层意义就是，静态内部类是外部类的子行为或子属性，两者之间保持着一定的关系，比如在我们的例子中，看到Home类就知道它是Person的home信息。 2.提高代码的可读性：相关联的代码放在一起，可读性肯定提高了。 3.形似内部，神似外部：静态内部类虽然存在于外部类内，而且编译后的类文件也包含外部类(格式是：外部类+$+内部类)，但是它可以脱离外部类存在，也就说我们仍然可以通过new Home()声明一个home对象，只是需要导入”Person.Home”而已。 解释了这么多，大家可能会觉得外部类和静态内部类之间是组合关系(Composition)了，这是错误的，外部类和静态内部类之间有强关联关系，这仅仅表现在”字面上”，而深层次的抽象意义则依类的设计. 那静态类内部类和普通内部类有什么区别呢？下面就来说明一下： 静态内部类不持有外部类的引用：在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性(如果是private权限也能访问，这是由其代码位置决定的)，其它的则不能访问。 静态内部类不依赖外部类：普通内部类与外部类之间是相互依赖关系，内部类实例不能脱离外部类实例，也就是说它们会同生共死，一起声明，一起被垃圾回收，而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类也是可以存在的。 普通内部类不能声明static的方法和变量：普通内部类不能声明static的方法和变量，注意这里说的是变量，常量(也就是final static 修饰的属性)还是可以的，而静态内部类形似外部类，没有任何限制。 建议39：使用匿名类的构造函数阅读如下代码，看上是否可以编译： public static void main(String[] args) { List list1=new ArrayList(); List list2=new ArrayList(){}; List list3=new ArrayList(){{}}; System.out.println(list1.getClass() == list2.getClass()); System.out.println(list2.getClass() == list3.getClass()); System.out.println(list1.getClass() == list3.getClass()); } 注意ArrayList后面的不通点：list1变量后面什么都没有，list2后面有一对{},list3后面有两个嵌套的{},这段程序能否编译呢？若能编译，那输结果是什么呢？ 答案是能编译，输出的是3个false。list1很容易理解，就是生命了ArrayList的实例对象，那list2和list3代表的是什么呢？ (1)、list2 = new ArrayList(){}：list2代表的是一个匿名类的声明和赋值，它定义了一个继承于ArrayList的匿名类，只是没有任何覆写的方法而已，其代码类似于： // 定义一个继承ArrayList的内部类 class Sub extends ArrayList { } // 声明和赋值 List list2 = new Sub(); (2)、list3 = new ArrayList(){ {} }：这个语句就有点奇怪了，带了两对{}，我们分开解释就明白了，这也是一个匿名类的定义，它的代码类似于： // 定义一个继承ArrayList的内部类 class Sub extends ArrayList { { //初始化代码块 } } // 声明和赋值 List list3 = new Sub(); 看到了吧，就是多了一个初始化块而已，起到构造函数的功能，我们知道一个类肯定有一个构造函数，而且构造函数的名称和类名相同，那问题来了：匿名类的构造函数是什么呢？它没有名字呀！很显然，初始化块就是它的构造函数。当然，一个类中的构造函数块可以是多个，也就是说会出现如下代码： List list4 = new ArrayList(){{} {} {} {} {}}; 上面的代码是正确无误，没有任何问题的，现在清楚了，匿名类虽然没有名字，但也是可以有构造函数的，它用构造函数块来代替构造函数，那上面的3个输出就很明显了：虽然父类相同，但是类还是不同的。 建议45：覆写equals方法时不要识别不出自己我们在写一个JavaBean时，经常会覆写equals方法，其目的是根据业务规则判断两个对象是否相等，比如我们写一个Person类，然后根据姓名判断两个实例对象是否相同时，这在DAO（Data Access Objects）层是经常用到的。具体操作时先从数据库中获得两个DTO(Data Transfer Object,数据传输对象)，然后判断他们是否相等的，代码如下： public class Person { private String name; public Person(String _name) { name = _name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public boolean equals(Object obj) { if(obj instanceof Person){ Person p = (Person) obj; return name.equalsIgnoreCase(p.getName().trim()); } return false; } } 覆写的equals方法做了多个校验，考虑到Web上传递过来的对象有可能输入了前后空格，所以用trim方法剪切了一下，看看代码有没有问题，我们写一个main： public static void main(String[] args) { Person p1= new Person(\"张三\"); Person p2= new Person(\"张三 \"); List&lt;Person> list= new ArrayList&lt;Person>(); list.add(p1); list.add(p2); System.out.println(\"列表中是否包含张三：\"+list.contains(p1)); System.out.println(\"列表中是否包含张三：\"+list.contains(p2)); } 上面的代码产生了两个Person对象(注意p2变量中的那个张三后面有一个空格)，然后放到list中，最后判断list是否包含了这两个对象。看上去没有问题，应该打印出两个true才对，但是结果却是： 列表中是否包含张三：true 列表中是否包含张三：false 刚刚放到list中的对象竟然说没有，这太让人失望了，原因何在呢？list类检查是否包含元素时时通过调用对象的equals方法来判断的，也就是说 contains(p2)传递进去，会依次执行p2.equals(p1),p2.equals(p2),只有一个返回true，结果都是true，可惜 的是比较结果都是false，那问题出来了：难道 p2.equals(p2)因为false不成？ 还真说对了，p2.equals(p2)确实是false，看看我们的equals方法，它把第二个参数进行了剪切！也就是说比较的如下等式： &quot;张三 &quot;.equalsIgnoreCase(&quot;张三&quot;); 注意前面的那个张三，是有空格的，那结果肯定是false了，错误也就此产生了，这是一个想做好事却办成了 “坏事” 的典型案例，它违背了equlas方法的自反性原则：对于任何非空引用x，x.equals(x)应该返回true，问题直到了，解决非常简单，只要把trim()去掉即可。注意解决的只是当前问题，该equals方法还存在其它问题。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz_javaweb分享自己的Java Web学习之路以及各种Java学习资料","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"}],"tags":[],"author":"我没有三颗心脏"},{"title":"【翻译】线程和进程基础","slug":"【翻译】线程和进程基础","date":"2017-11-06T01:48:00.000Z","updated":"2020-12-09T04:41:52.816Z","comments":true,"path":"2017/11/06/fan-yi-xian-cheng-he-jin-cheng-ji-chu/","link":"","permalink":"http://www.wmyskxz.com/2017/11/06/fan-yi-xian-cheng-he-jin-cheng-ji-chu/","excerpt":"前言 所有的内容均来自：http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html这是一篇很棒的介绍进程和线程的文章，本文属于自己感兴趣翻译过来的文章，有兴趣的读者也可以去拜读一下原文。","text":"前言 所有的内容均来自：http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html这是一篇很棒的介绍进程和线程的文章，本文属于自己感兴趣翻译过来的文章，有兴趣的读者也可以去拜读一下原文。 进程和线程基础在我们开始讨论线程，进程，时间片以及各种神奇的“调度机制”之前，先来建立一个类比。 我首先要做的就是说明线程和进程是如何工作的。我能想到的最好的方式（不涉及实时系统的设计）就是把线程和进程想象成一些实际的情形。 进程就像是一个房子让我们用一个常规的、日常的物品来模拟进程和线程——房子。 房子实际上是一个容器，具有一定的属性（例如楼面面积，房间数目等等）。 如果你能这样看待，那么你就会发现房子不会自己主动去做任何事——它只是一个被动的物体。这就是进程实际上所担任的角色。我们待会儿会讨论到。 线程就像居住者住在房子里的人们是活跃的对象——他们使用不同的房间，看电视，做饭，洗澡等等。我们很快就会发现这就是线程的行为模式。 单线程如果你曾经一个人生活过，那么你就会知道这是一种什么感觉——你知道，你可以在任何时候在家里做任何你想做的事，因为房子里没有其他人。如果你想打开立体声音响，使用洗手间，吃晚餐，随便你，你只要继续做就行了。 多线程当你把另一个人加入房子时，事情会发生戏剧性的变化。假设你结婚了，所以现在你的配偶也住在那里。你不能在任何一个特定的时间进入洗手间，你需要先检查一下，确保你的配偶不在里面！ 如果你有两个负责任的成年人住在一所房子里，一般来说，你可能会对“安全”相当松懈-因为你知道另一个大人会尊重你的空间，不会试图放火烧厨房(故意！)等等。 现在，把几个孩子扔到一起，突然之间事情变得有趣多了。 回到进程和线程就像房子占据了房地产的一部分一样，进程也会占据一定的内存。就像房子的住户可以自由进入任何他们想要的房间一样，一个进程的线程都可以访问这个内存。如果一个线程分配了一些东西(妈妈出去买了一个游戏)，所有其他的线程都能立即访问它(因为它存在于公共地址空间-它在房子里)。同样，如果进程分配内存，那么这个新内存也可以用于所有线程。这里的技巧是，确认内存是否应该对进程中的所有线程都可用。如果是，那么您需要让所有线程同步它们对它的访问。如果不是，那么我们假设它是特定于特定线程的。在这种情况下，因为只有该线程才能访问它，所以我们可以假定不需要同步-线程不会自行启动！ 正如我们从日常生活中所知道的，事情并不那么简单。现在我们已经了解了基本特性(要点：所有内容都是共享的)，让我们来看看事情变得更有趣的地方，以及为什么。 下图显示了我们将代表线程和进程的方式。进程是圆，表示“容器”概念(地址空间)，三个squigley lines（不知道是什么）是线程。你会在书中看到这样的图表。 相互排斥如果你想洗个澡，而且有人已经在用浴室，你就得等着。线程是如何处理这个的？ 它用的是一种叫做互斥的操作。它几乎意味着你所想的-当涉及到特定的资源时，许多线程是互斥的。 如果你正在洗澡，你想要独占浴室。要做到这一点，你通常会进入浴室并把门从里面锁起来。任何想使用浴室的人都会被锁上的。当你完成任务时，你会打开门，让其他人进入。 这就是线程所做的。线程使用一个名为互斥的对象(相互排斥的缩写)。这个对象就像门上的锁-一旦线程拥有互斥锁，没有其他线程可以获得互斥锁，直到拥有的线程释放(解锁)它。就像门锁一样，等待获得互斥锁的线程将被禁止。 互斥锁和门锁的另一个有趣的相同点是互斥锁实际上是一个“咨询”锁。如果一个线程不符合使用互斥锁的约定，那么保护就没有用了。在我们的房子比喻中，这就像有人通过墙壁闯进厕所，无视了门和锁的约定。 优先级如果浴室现在锁着，有许多人在等着使用它，那该怎么做？显然，所有的人都坐在外面，等着在浴室里的人出去。真正的问题是，“当门打开时会发生什么？谁能下一个进入？“ 你会认为，让等了最长的时间得那个成为下一个是“公平的”。或者，让最年长的人成为下一个是“公平”的。或者最高的。或者最重要的。有许多方法可以确定什么是“公平”。 我们通过线程的两个因素来解决这个问题：优先级和等待长度。 假设两个人同时出现在(上锁的)卫生间的门前。其中一人有一个紧迫的事情(他们开会已经很晚了)，而另一个却没有。让那个时间紧迫的人下一次进去，是不是很有道理呢？当然会了。唯一的问题是你如何决定谁更“重要”。这可以通过分配优先级来完成(让我们使用一个像中微子（Neutrino）这样的数字，是最低的可用优先级，255是这个版本中的最高值)。房子里有紧迫事情的人将被给予更高的优先权，而那些不被优先考虑的人将被给予较低的优先权。 和线程一样。线程继承其父线程的调度算法，但可以调用pthread_setschedparam()来更改其调度策略和优先级(如果它有权限这样做)。 如果有多个线程等待，并且互斥锁被解锁，我们将把互斥锁给予等待线程中最高优先级的那个。但是，假设两个人都具有相同的优先级。现在你要做什么？好吧，在这种情况下，让等待最长的人下一个或许是“公平的”。这不仅是“公平的”，而且也是在内核所做的。在一堆线程等待的情况下，我们首先是按优先级等级来决定，其次是等待长度。 互斥量肯定不是我们将遇到的唯一的同步对象。让我们看看其他的。 信号量让我们从浴室搬到厨房，因为这是一个在社会上可以接受同时容纳一个人以上的地点。在厨房里，你可能不想让每个人都在里面。事实上，你可能想要限制你的厨房里所能容纳的人数(太多的厨师，等等)。 假设你不想同时拥有两个以上的人。你能用互斥体来实现吗？这不是我们定义的。为什么不呢？这实际上是一个非常有趣的问题。让我们把它分成几个步骤。 数量为1的信号量浴室可以有两种情况中的一种，两种状态相互联系（with two states that go hand-in-hand with each other）： 门没有锁，房间里没有人 门是锁着的，房间里有一个人 没有其他的组合是可能的-当房间里没人的时候不能上锁(不然我们怎么解锁？)，而且当有人在房间里时不能解锁(他们怎么保证他们的隐私？)。这是一个信号量的示例，其计数为1-最多只能有一个人在该房间，或者一个线程使用信号量。 这里的关键（key）(请原谅双关语)是我们描述锁的方式。在典型的浴室锁中，你可以锁定和解锁它只有从内部-没有外部可访问的钥匙。实际上，这意味着互斥对象的所有权是一个原子操作-在获取互斥锁的过程中，没有可能有其他线程得到它，结果是你一直拥有互斥锁。在我们的房子比喻中，这是不太明显的，因为人类比计算机聪明太多（smarter than ones and zeros）。 数量大于1的信号量假设我们在厨房安装了传统的钥匙锁。这个锁的工作方式是，如果你有一个钥匙，你可以打开门并进入。任何使用这个锁的人都同意，当他们进去时，他们会立即把门从里面锁起来，这样外面的人总是需要钥匙。 现在，控制我们想要多少人在厨房里-把两个钥匙挂在门外，这就变成了一件简单的事情！厨房总是锁着的。当有人想走进厨房时，他们会发现门外有一把钥匙。如果是的话，他们就带着它，打开厨房的门，进去，用钥匙锁上门。 因为进入厨房的人在厨房的时候一定要带钥匙，所以我们可以通过限制门上的钥匙的数量来直接控制进入厨房的人数。 对于线程，这就需要通过信号量来完成了。“普通”信号量就像一个互斥体一样工作-你要么拥有互斥量，在这种情况下，你可以访问资源，或者你没有，在这种情况下，你没有访问权限。我们刚才在厨房描述的信号量是一个计数信号，它保持计数的记录(线程所允许的keys数量)。 互斥的信号量我们只是问了一个问题“你能用一个互斥量来做吗？”关于用计数实现一个锁，答案是否定的，反过来呢？我们能用信号量作为互斥量吗？ 是的。事实上，在某些操作系统中，这正是他们所做的-他们没有互斥锁，只有信号量！那么，为什么要麻烦互斥锁呢？ 要回答这个问题，看看你的洗手间。你的房子的建造者是如何实现“互斥”的？我猜你没有挂在墙上的钥匙！ 互斥锁（Mutexes）是一个“特殊用途”信号量。如果您希望一个线程在特定的代码段中运行，那么互斥锁是迄今为止最有效的实现。 结束语 这篇文章真的可谓是生动有趣，把线程和进程用了生活中的比喻来描述，很是深刻。原文中的描述虽然简单，但有些单词还是有些拿不准，我都打出来了，甚至有一些描述有些生硬，如有错误，请指出。 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术文章","slug":"想要跟你们分享/技术文章","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"翻译文","slug":"翻译文","permalink":"http://www.wmyskxz.com/tags/%E7%BF%BB%E8%AF%91%E6%96%87/"}],"author":"wmyskxz"},{"title":"Java学习笔记(4)——并发基础","slug":"Java学习笔记-4-——并发基础","date":"2017-10-31T05:50:00.000Z","updated":"2020-12-09T05:06:39.694Z","comments":true,"path":"2017/10/31/java-xue-xi-bi-ji-4-bing-fa-ji-chu/","link":"","permalink":"http://www.wmyskxz.com/2017/10/31/java-xue-xi-bi-ji-4-bing-fa-ji-chu/","excerpt":"前言当我们使用计算机时，可以同时做许多事情，例如一边打游戏一边听音乐。这是因为操作系统支持并发任务，从而使得这些工作得以同时进行。","text":"前言当我们使用计算机时，可以同时做许多事情，例如一边打游戏一边听音乐。这是因为操作系统支持并发任务，从而使得这些工作得以同时进行。 那么提出一个问题：如果我们要实现一个程序能一边听音乐一边玩游戏怎么实现呢？我们使用了循环来模拟过程，因为播放音乐和打游戏都是连续的，但是结果却不尽人意，因为函数体总是要执行完之后才能返回。那么到底怎么解决这个问题？下面来说。 并行与并发并行性和并发性是既相似又有区别的两个概念。 并行性是指两个或多个事件在同一时刻发生。而并发性是指连个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机环境下（一个处理器），每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。例如，在1秒钟时间内，0-15ms程序A运行；15-30ms程序B运行；30-45ms程序C运行；45-60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。 如果在计算机系统中有多个处理机，这些可以并发执行的程序就可以被分配到多个处理机上，实现并发执行，即利用每个处理机爱处理一个可并发执行的程序。这样，多个程序便可以同时执行。以此就能提高系统中的资源利用率，增加系统的吞吐量。 进程和线程进程是指一个内存中运行的应用程序。一个应用程序可以同时启动多个进程，那么上面的问题就有了解决的思路：我们启动两个进程，一个用来打游戏，一个用来播放音乐。这当然是一种解决方案，但是想象一下，如果一个应用程序需要执行的任务非常多，例如LOL游戏吧，光是需要播放的音乐就有非常多，人物本身的语音，技能的音效，游戏的背景音乐，塔攻击的声音等等等，还不用说游戏本身，就光播放音乐就需要创建许多许多的进程，而进程本身是一种非常消耗资源的东西，这样的设计显然是不合理的。更何况大多数的操作系统都不需要一个进程访问其他进程的内存空间，也就是说，进程之间的通信很不方便，此时我们就得引入“线程”这门技术，来解决这个问题。 线程是指进程中的一个执行任务（控制单元），一个进程可以同时并发运行多个线程。打开我们的任务管理器，在【查看】里面点击【选择列】，有一个线程数的勾选项，找到并勾选，可以看到： 进程和线程的区别：进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的，又称为轻型进程或进程元。 因为一个进程中的多个线程是并发运行的，那么从微观角度上考虑也是有先后顺序的，那么哪个线程执行完全取决于CPU调度器(JVM来调度)，程序员是控制不了的。我们可以把多线程并发性看作是多个线程在瞬间抢CPU资源，谁抢到资源谁就运行，这也造就了多线程的随机性。下面我们将看到更生动的例子。 Java程序的进程(Java的一个程序运行在系统中)里至少包含主线程和垃圾回收线程(后台线程)： 你可以简单的这样认为，但实际上有四个线程（了解就好）：[1] main——main线程，用户程序入口[2] Reference Handler——清除Reference的线程[3] Finalizer——调用对象finalize方法的线程[4] Signal Dispatcher——分发处理发送给JVM信号的线程 多线程的优势：尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是： 资源利用率更好 程序设计在某些情况下更简单 程序响应更快 （1）资源利用率更好想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要： 1| 5秒读取文件A 2| 2秒处理文件A 3| 5秒读取文件B 4| 2秒处理文件B 5| --------------------- 6| 总共需要14秒 从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序： 1| 5秒读取文件A 2| 5秒读取文件B + 2秒处理文件A 3| 2秒处理文件B 4| --------------------- 5| 总共需要12秒 CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。 总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。 ###（2）程序设计更简单 在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 （3）程序响应更快有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单赶快找、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？ 在上面的场景中，可以使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。 ####多线程的还有一些优势也显而易见： ① 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。 ② 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高. ③ Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程. 上下文切换即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务的时候，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是打开中英文字典，但是在放下英文技术书之前，大脑必须先记住这本书独到了多少页的多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文切换也会影响多线程的执行速度。 创建线程的两种方式继承Thead类： 运行结果发现打游戏和播放音乐交替出现，说明已经成功了。 实现Runnable接口：也能完成效果。 以上就是传统的两种创建线程的方式，事实上还有第三种，我们后边再讲。 多线程一定快吗？先来一段代码，通过并行和串行来分别执行累加操作，分析：下面的代码并发执行一定比串行执行快吗？ 以下是我测试的结果，可以看出，当不超过1百万的时候，并行是明显比串行要慢的，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。 继承Thread类还是实现Runnable接口？吃苹果比赛想象一个这样的例子：给出一共50个苹果，让三个同学一起来吃，并且给苹果编上号码，让他们吃的时候顺便要说出苹果的编号： 运行结果可以看到，使用继承方式实现，每一个线程都吃了50个苹果。这样的结果显而易见：是因为显式地创建了三个不同的Person对象，而每个对象在堆空间中有独立的区域来保存定义好的50个苹果。 而使用实现方式则满足要求，这是因为三个线程共享了同一个Apple对象，而对象中的num数量是一定的。 所以可以简单总结出继承方式和实现方式的区别： 对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。就我个人意见，我更倾向于实现Runnable接口这种方法。因为线程池可以有效的管理实现了Runnable接口的线程，如果线程池满了，新的线程就会排队等候执行，直到线程池空闲出来为止。而如果线程是通过实现Thread子类实现的，这将会复杂一些。 有时我们要同时融合实现Runnable接口和Thread子类两种方式。例如，实现了Thread子类的实例可以执行多个实现了Runnable接口的线程。一个典型的应用就是线程池。 常见的错误：调用run()方法而非start()方法创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法，如下所示： 1| Thread newThread = new Thread(MyRunnable()); 2| newThread.run(); //should be start(); 起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法。 吃苹果比赛的问题：线程不安全问题尽管，Java并不保证线程的顺序执行，具有随机性，但吃苹果比赛的案例运行多次也并没有发现什么太大的问题。这并不是因为程序没有问题，而只是问题出现的不够明显，为了让问题更加明显，我们使用Thread.sleep()方法（经常用来模拟网络延迟）来让线程休息10ms，让其他线程去抢资源。（注意：在程序中并不是使用Thread.sleep(10)之后,程序才出现问题,而是使用之后,问题更明显.） 为什么会出现这样的错误呢？ 先来分析第一种错误：为什么会吃重复的苹果呢？就拿B和C都吃了编号为47的苹果为例吧： ① A线程拿到了编号为48的苹果，打印输出然后让num减1，睡眠10ms，此时num为47。 ② 这时B和C同时都拿到了编号为47的苹果，打印输出，在其中一个线程作出了减一操作的时候，A线程从睡眠中醒过来，拿到了编号为46的苹果，然后输出。在这期间并没有任何操作不允许B和C线程不能拿到同一个编号的苹果，之前没有明显的错误仅仅可能只是因为运行速度太快了。 再来分析第二种错误：照理来说只应该存在1-50编号的苹果，可是0和-1是怎么出现的呢？ ① 当num=1的时候，A，B，C三个线程同时进入了try语句进行睡眠。 ② C线程先醒过来，输出了编号为1的苹果，然后让num减一，当C线程醒过来的时候发现num为0了。 ③ A线程醒过来一看，0都没有了，只有-1了。 归根结底是因为没有任何操作来限制线程来获取相同的资源并对他们进行操作，这就造成了线程安全性问题。 如果我们把打印和减一的操作分成两个步骤，会更加明显：ABC三个线程同时打印了50的苹果，然后同时做出减一操作。 像这样的原子操作，是不允许分步骤进行的，必须保证同步进行，不然可能会引发不可设想的后果。 要解决上述多线程并发访问一个资源的安全性问题，就需要引入线程同步的概念。 线程同步多个执行线程共享一个资源的情景，是最常见的并发编程情景之一。为了解决访问共享资源错误或数据不一致的问题，人们引入了临界区的概念：用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。 为了帮助编程人员实现这个临界区，Java（以及大多数编程语言）提供了同步机制，当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已经有其他线程进入临界区。如果没有其他线程进入临界区，他就可以进入临界区。如果已经有线程进入了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入临界区的线程不止一个，JVM会选择其中的一个，其余的将继续等待。 synchronized关键字如果一个对象已用synchronized关键字声明，那么只有一个执行线程被允许访问它。使用synchronized的好处显而易见：保证了多线程并发访问时的同步操作，避免线程的安全性问题。但是坏处是：使用synchronized的方法/代码块的性能比不用要低一些。所以好的做法是：尽量减小synchronized的作用域。 我们还是先来解决吃苹果的问题，考虑一下synchronized关键字应该加在哪里呢？发现如果还再把synchronized关键字加在if里面的话，0和-1又会出来了。这其实是因为当ABC同是进入到if语句中，等待临界区释放的时，拿到1编号的线程已经又把num减一操作了，而此时最后一个等待临界区的进程拿到的就会是-1了。 同步锁（Lock）Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 参考资料： http://study.163.com/course/courseMain.htm?courseId=1003108028 《Java零基础入门教程》 《Java并发编程的艺术》 《Java 7并发编程实战手册》 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"wmyskxz"},{"title":"Java学习笔记(3)——String类详解","slug":"Java学习笔记-3-——String类详解","date":"2017-10-25T03:15:00.000Z","updated":"2020-12-09T05:06:36.054Z","comments":true,"path":"2017/10/25/java-xue-xi-bi-ji-3-string-lei-xiang-jie/","link":"","permalink":"http://www.wmyskxz.com/2017/10/25/java-xue-xi-bi-ji-3-string-lei-xiang-jie/","excerpt":"前言 因为没有成功地为IDEA配上反编译工具，所以自己下载了一个XJad工具，背景是白色的，所以忍着强迫症硬是把IDEA的主体也给换成白色了，感觉为了这篇文章付出了诸多啊….","text":"前言 因为没有成功地为IDEA配上反编译工具，所以自己下载了一个XJad工具，背景是白色的，所以忍着强迫症硬是把IDEA的主体也给换成白色了，感觉为了这篇文章付出了诸多啊…. 字符串简介《Thinging in Java》中有一句话：可以证明，字符串操作是计算机程序设计中最常见的行为。 把多个字符按照一定的顺序排列起来，就叫字符串（就像羊肉串一样，串起来的），具体是怎么排列的，你可以跟进String的源代码去看一下，会发现它其实内部维护的是一个char类型的数组： // 也就是说 String str = \"ABCD\"; // 定义一个字符串对象，其实等价于： char[] cr = new char[]{'A','B','C','D'}; 字符串的分类其实说起来会有些别扭，为什么字符串会有分类这种东西。了解的朋友可能会知道字符串的操作除了String，还有StringBuffer和StringBuilder（区别我们在下面来说） 不可变的字符串String是一个奇葩。 String对象不可变，也就是说当对象创建完毕之后，该对象的内容（字符序列）是不允许改变的，如果内容改变则会创建一个新的String对象，返回到原地址中。 细心的朋友也许会发现，String类维护的char数组不仅被final所修饰，并且查看JDK源码你就会发现，String类中每一个看起来会修改String值得方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串对象。而最初的String对象则丝毫未动。我们可以简单的来看一个实例（从替换操作中就能明显看出）： replace方法就是替换字符串中的内容，如果替换之后跟原来的字符串相同则返回this，如果不相同则new一个新的对象返回。这明显体现了内容改变则返回新对象而不是直接修改String对象的值。 表面的错觉关于String对象是否可变，有些操作确实会给人错觉，先来看一段程序： 从结果来看，s1的值最初是“A”，经过赋值以后，变成了“C”,经过字符串连接运算并赋值以后，变成了“BC”。String对象的内容真的改变了吗？实际上，这只是错觉而已。有疑惑的朋友可以去看我的上一篇笔记，你就能知道： String对象“A”，“B”，“C”在全程中都没有任何改变，改变的只是引用s1所指向的内容，也就是s1的值。 String对象的创建有两种方式： // 第一种：直接赋一个字面量 String str1 = \"ABCD\"; // 第二种：通过构造器创建 String str2 = new String(\"ABCD\"); 那么这两种方式有什么不同呢？这里可能会涉及到一个面试题： 上述的两种方法分别创建了几个String对象？ 回答这个问题也特别简单，首先你需要直到JVM的内存模型是怎样的，在上一篇笔记中也有简单提到，这里需要补充的是：常量池（专门存储常量的地方，都指的是方法区中）分为编译常量池（不研究，存储字节码的相关信息）和运行常量池（存储常量数据）。 先来看一张结果图： 当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD 当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。 所以结论：String str1 = “ABCD”;最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用.String str2 = new String(“ABCD”);最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。 String对象的空值一种是表示引用为空（null）的空值： String str1 = null; // 没有初始化，没有分配内存空间 另外一种表示内容为空的空值： String str2 = \"; // 分配有内存空间，有内容。 所以当你需要判断字符串是否为空的时候，实际上应该这样： 字符串的比较 从上图可以明显看出，使用“==”，只能比较引用的内存地址是否相同，而使用“equals”方法，则比较的是字符串的内容。 我们可以跟到String类的equals方法： “+”号是怎么来连接字符串的先来直接看一个简单的例子，程序中创建了三个String对象，str是hello和wrold两个字符串连接赋值后的对象，程序的结果很明显，但我们关心的是，hello和world是怎样连接起来的呢？ 我们在XJad（Java反编译程序，把生成的class反编译成java）中打开刚刚生成的class文件会发现： 编译器自动引入了一个java.lang.StringBuilder类。虽然我们在源代码中并没有使用StringBuilder类，但是编译器却自作主张地使用了它，因为它更高效。 在这个例子中，编译器创建了一个StringBuilde对象，用以构造最终的String，并为每个字符串调用了一次StringBuilder的append()方法，总计两次。最后调用toString()生成结果。这是编译器自动优化的结果，包括自动生成的Tester()无参数默认的构造函数也是。 现在，你也许会觉得可以随意使用String对象，反正编译器会为你自动地优化性能。可是在这之前，我们先要看看编译器究竟能给我们优化到什么程度（下面再详细介绍StringBuilder）。 可变的字符串StringBuilder/StringBuffer：当对象创建完毕之后，该对象的内容可以发生改变，当内容发生改变的时候，对象保持不变。 接着上面的问题，我们继续来看一个例子： 程序的结果显而易见，我们来看看反编译之后的代码：可以看到，对比两个对象，后者的循环部分的代码更简短、更简单，而且它只生成了一个StringBuilder对象。 结论是：如果字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。但如果你还使用循环，多次地改变字符串的内容，那就更适合StringBuilder对象。 但是如果你想要走捷径，例如append(a+”:”+c)，则编译器就会调入陷阱，从而为你另外创建一个StringBuilder对象处理括号内的字符串操作。 String对象的比较StringBuilder是Java SE5引入的，在这之前Java用的是StringBuffer。后者线程安全（只需要了解，该对象方法中所有的方法都是用了synchronized修饰符），因此开销也会大。有没有用synchronized修饰符，就是这两者唯一的区别。我们可以简单地来比较一下这三个String对象在拼接字符串中的性能： 创建好三个方法，分别测试三个类型的对象的拼接效率： 面试题最后再有一个String的面试题： 说说下面的String对象，彼此之间是否相等？ 如果你自己写几个判断相等的语句，分别判断str1和另外五个是否相等，则会发现：str1和str2/str3相等，和另外几个都不相等。我们先来看一下反编译之后的代码： 知识点（纯干货）： 单独使用””引号创建的字符串都是直接量,编译期就已经确定存储到常量池中； 使用new String(“”)创建的对象会存储到堆内存中,是运行期才创建； 使用只包含直接量的字符串连接符如”aa” + “bb”创建的也是直接量编译期就能确定,已经确定存储到常量池中(str2和str3)； 使用包含String直接量(无final修饰符)的字符串表达式(如”aa” + s1)创建的对象是运行期才创建的,存储在堆中； 通过变量/调用方法去连接字符串,都只能在运行时期才能确定变量的值和方法的返回值,不存在编译优化操作. 文章结尾其实还想写关于正则表达的东西的，还是改天找时间另外研究研究写一篇像样的吧。关于String的操作，就简单给一下图吧，感兴趣也可以自己百度或者跟踪进源代码里面去看，这里就不细说了： 参考资料： http://study.163.com/course/courseMain.htm?courseId=1003108028 《Java零基础入门教程》 《Thinking in Java》第四版 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"wmyskxz"},{"title":"Java学习笔记(2)——数据类型","slug":"Java学习笔记-2-——数据类型","date":"2017-09-19T09:46:00.000Z","updated":"2020-12-09T05:06:33.600Z","comments":true,"path":"2017/09/19/java-xue-xi-bi-ji-2-shu-ju-lei-xing/","link":"","permalink":"http://www.wmyskxz.com/2017/09/19/java-xue-xi-bi-ji-2-shu-ju-lei-xing/","excerpt":"终于要写点干货了，其实思考了很久下面一篇文章要写什么，主要的纠结点在于，既想要分享那些精美的知识，又怕这些知识不太好嚼。后来想想还是对初学者不太好友算了..一来这系列文章叫做学习笔记，我的。另外写得足够有料，才能发挥笔记的作用，不然索然无味的，连收藏、喜欢的意义也没有了。","text":"终于要写点干货了，其实思考了很久下面一篇文章要写什么，主要的纠结点在于，既想要分享那些精美的知识，又怕这些知识不太好嚼。后来想想还是对初学者不太好友算了..一来这系列文章叫做学习笔记，我的。另外写得足够有料，才能发挥笔记的作用，不然索然无味的，连收藏、喜欢的意义也没有了。 写在文章之前终于写点干货了，想先简单谈谈自己的一些看法。对于我自己而言，我比较厌烦那些繁琐的无聊的知识点，反而更在乎一些实际应用的东西。但了解一些底层的东西是非常有意义的，它有助于我们理解程序。 每一点知识的积累，终会有用武之地。也许，它会使您在面试过程中正确地回答一道面试题；也许，它会让您更加清楚Java底层的实现方式；也许，它能让您在学业上感到更加充实…（以上摘自梁勇著的Java深入解析_前言） Java中的数据类型Java是一种强类型的语言。这意味着必须为每一个变量都声明一种类型。 在Java中，你可以把数据类型分为两部分，一部分是基本类型（primitive type）：4种整形、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。 另外一部分是引用类型（reference type），如String和List。每个基本类型都有一个对应的引用类型，称作装箱基本类型（boxed primitive）。装箱基本类中对应于int、double、boolean的是Integer、Double和Boolean。 Java中的特例Java是一种完全面向对象的语言，从理论上来说，在Java中应该不存在对象以外的事务，即所有的类型都是对象。然而，在Java8中的8种基本数据类型不是对象，之所以这样设计，是因为相对于对象来说，基本数据在使用上更加方便，并且在效率上也高于对象类型。所以这就需要去了解一下Java中创建对象的过程。 创建对象的过程 当程序运行时，对象是怎么进行安排放置的呢？特别是内存是怎样分配的呢？ Java大体上会把内存分为四块区域：堆、栈、静态区、常量区。 堆 ： 位于RAM中，用于存放所有的java对象。 栈 ： 位于RAM中，引用就存在于栈中。 静态区: 位于RAM中，被static修饰符修饰的变量会被放在这里 常量区：位于ROM中， 很明显，放常量的。（其实常量通常直接存放在程序代码的内部，因为这样非常安全，因为它们永远都不会被改变） 所以当我们创建对象，例如实例化一个Person类： Person p = new Person() 首先，会在堆中开辟一块空间存放这个新来的Person对象。然后，会创建一个引用p，存放在栈中，这个引用p指向Person对象（事实上是，p的值就是Person对象的内存地址）。 这样，我们通过访问p，然后得到了Person的内存地址，进而找到了Person对象。 然后又有了这样一句代码： Person p2 = p; 这句代码的含义是： 创建了一个新的引用p2，保存在栈中，引用的地址也指向Person的地址。这个时候，你通过p2来改变Person对象的状态，也会改变p的结果。因为它们指向同一个对象。（String除外，之后会专门讲String） 此时，内存中是这样的： 有一个很通俗的方式来讲解引用和对象。大家对于快捷方式应该不会陌生吧？我们桌面的图标大部分都是快捷方式。它并不是我们安装在电脑上的应用的可执行文件（不是.exe文件)，那么为什么点击它可以打开应用程序呢？是因为快捷方式连接了文件，这就像是引用和对象的关系了。 我们不直接对文件进行操作，而是通过快捷方式来进行操作。快捷方式不能独立存在，同样，引用也不能独立存在（你可以只创建一个引用，但是当你要使用它的时候必须得给它赋值，否则它将毫无用处）。 一个文件可以有多个快捷方式，同样一个对象也可以有多个引用。而一个引用只能同时对应一个对象。 在java里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。java表面上看起来没有指针，但它的引用其实质就是一个指针。在java里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个简单的赋值过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。 特例：基本数据类型为什么要有特例呢？是因为new将对象存储在“堆”里，一是用new创建一个对象——特别是小的，简单的变量（Java中数据定长，为了可移植性）往往不是很明智而且有效的方法，二是因为“堆”空间本来就有限，如果频繁的操作会导致不可想象的错误，并且别忘了第一篇文章里面提到的，Java的设计初衷是什么。 所以针对这些类型，Java采取了与C和C++相同的方法，也就是说，不用new来创建变量，二是创建一个并非是引用的“自动”变量。这个变量直接存储“值”并置于常量区中，因此更加高效。 先来看一个例子： int i = 2; int j = 2; 我们需要知道的是，在常量区中，相同的常量只会存在一个。当执行第一句代码时。先查找常量区中有没有2，没有，则开辟一个空间存放2，然后在栈中存入一个变量i，让i指向2； 执行第二句的时候，查找发现2已经存在了，所以就不开辟新空间了。直接在栈中保存一个新变量j，让j指向2； 当然，java堆每一个基本数据类型都提供了对应的包装类。我们依旧可以用new操作符来创建我们想要的变量。 Integer i = new Integer(1); Integer j = new Integer(1); 但是，用new操作符创建的对象是不同的，也就是说，此时，i和j指向不同的内存地址。因为每次调用new操作符，都会在堆开辟新的空间。 深入了解Integer来看一个例子： 第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。第二个返回false是为什么呢？下面细说第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。 我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。 跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是Java的一个缓存机制。Integer类的内部类缓存了-128到127的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的。了解就行了，不必去深究。） 为什么引入缓存机制这回到了为什么引入基础类型这个特例的问题上。我们看看Java语言规范是怎么规定的： If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1**), or the boolean literal true or false (§3.10.3**), or a character literal between ‘\\u0000’ and’\\u007f’ inclusive (§3.10.4**), then let a and b be the results of any two boxing conversions of p. It is always the case that a == b. Ideally, boxing a primitive value would always yield an identical reference. In practice, this may not be feasible using existing implementation techniques. The rule above is a pragmatic compromise, requiring that certain common values always be boxed into indistinguishable objects. The implementation may cache these, lazily or eagerly. For other values, the rule disallows any assumptions about the identity of the boxed values on the programmer’s part. This allows (but does not require) sharing of some or all of these references. Notice that integer literals of type long are allowed, but not required, to be shared. This ensures that in most common cases, the behavior will be the desired one, without imposing an undue performance penalty, especially on small devices. Less memory-limited implementations might, for example, cache all char and short values, as well as int and long values in the range of -32K to +32K. 事实上，不光是Integer这么特别，还包括boolean还有char类型。并且文章的最后提到了为了实现更少内存的可能。 另一个特例：StringString是一个特殊的类，因为它被final修饰符所修饰，是一个不可改变的类。当然，看过java源码后你会发现，基本类型的各个包装类也被final所修饰。这里以String为例。 我们来看这样一个例子： 执行第一句 ： 常量区开辟空间存放“abc”，s1存放在栈中指向“abc”执行第二句，s2 也指向 “abc”，执行第三句，因为“abc”已经存在，所以直接指向它。所以三个变量指向同一块内存地址，结果都为true。当s1内容改变的时候。这个时候，常量区开辟新的空间存放“bcd”，s1指向“bcd”，而s2和s3指向“abc”所以只有s2和s3相等。 这种情况下，s1,s2,s3都是字符串常量，类似于基本数据类型。（如果执行的是s1 = “abc”,那么结果会都是true） 我们再看一个例子： 执行第一行代码： 在堆里分配空间存放String对象，在常量区开辟空间存放常量“abc”，String对象指向常量，s1指向该对象。执行第二行代码：s2指向上一步new出来的string对象。执行第三行代码： 在堆里分配新的空间存放String对象，新对象指向常量“abc”，s3指向该对象。到这里，很明显，s1和s2指向的是同一个对象 接着就很诡异了，我们让s1 依旧= “abc”,但是结果s1和s2指向的地址不同了。 怎么回事呢？这就是String类的特殊之处了，new出来的String不再是上面的字符串常量，而是字符串对象。 由于String类是不可改变的，所以String对象也是不可改变的，我们每次给String赋值都相当于执行了一次new String()，然后让变量指向这个新对象，而不是在原来的对象上修改。 当然，java还提供了StringBuffer类，这个是可以在原对象上做修改的。如果你需要修改原对象，那么请使用StringBuffer类。 引发的问题：值传递还是引用传递？java是值传递还是引用传递的呢？毫无疑问，java是值传递的。那么什么又叫值传递和引用传递呢？ 我们先来看一个例子： 这是一个很经典的例子，我们希望调用了swap函数以后，a和b的值可以互换，但是事实上并没有。为什么会这样呢？ 这就是因为java是值传递的。也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传进去的参数本身，而是它的副本。说起来比较拗口，但是其实原理很简单。我们可以这样理解： 一个有形参的函数，当别的函数调用它的时候，必须要传递数据。比如swap函数，别的函数要调用swap就必须传两个整数过来。 这个时候，有一个函数按耐不住寂寞，扔了两个整数过来，但是，swap函数有洁癖，它不喜欢用别人的东西，于是它把传过来的参数复制了一份，然后对复制的数据修修改改，而别人传过来的参数动根本没动。 所以，当swap函数执行完毕之后，交换了的数据只是swap自己复制的那一份，而原来的数据没变。 也可以理解为别的函数把数据传递给了swap函数的形参，最后改变的只是形参而实参没变，所以不会起到任何效果。 我们再来看一个复杂一点的例子(Person类添加了get，set方法)： 可以看到，我们把p1传进去，它并没有被替换成新的对象。因为change函数操作的不是p1这个引用本身，而是这个引用的一个副本。 你依然可以理解为，主函数将p1复制了一份然后变成了chagne函数的形参，最终指向新Person对象的是那个副本引用，而实参p1并没有改变。 再来看一个例子： 这次为什么就改变了呢？分析一下。首先，new了一个Person对象，暂且叫他小明吧。然后p1指向小明。小明10岁了，随着时间的推移，小明的年龄要变了，调用了一下changgeAge方法，把小明的引用传了进去。传递的过程中，changgeAge也有洁癖，于是复制了一份小明的引用，这个副本也指向小明。然后changgeAge通过自己的副本引用，改变了小明的年龄。由于是小明这个对象被改变了，所以所有小明的引用调用方法得到的年龄都会改变所以就变了。 最后简单的总结一下。 java的传值过程，其实传的是副本，不管是变量还是引用。所以，不要期待把变量传递给一个函数来改变变量本身。 “+”是怎么连接字符串的？ 先抛个砖：对Java程序员来说，使用运算符“+”来连接字符串是非常普遍的，当“+”两边的操作数是String类型时（如果只有一个操作数是String类型，则系统也会将另外一个操作数转换成String类型），就会执行字符串连接的运算。但是，运算符“+”是怎样连接String对象的呢？编译器又是如何实现的呢? 之后我再来补这个内容，先发表啦。 浮点类型 浮点类型用于表示有小数部分的数值。在Java中有两种浮点类型，一个是4字节的float，一个是8字节的double。我们平时用来编写程序用来表示增长率、物品重量等方面也非常有用。不过，在使用浮点类型时，也需要留意一些问题。 浮点类型只是近似的存储请问一个问题：0.1+0.2等于多少？请不要慌着报答案，我没有开玩笑的意思，看一下Java给出的答案你就知道了： 结果似乎有些令人惊讶，这么简单的算术竟然也会算错。 其实，这并不是计算错误，这只是浮点数类型存储的问题。计算机使用二进制来存储数据，而二进制无法准确的表示分数 1/10 ，就像使用十进制时，无法准确地表示 1/3 一样。 数量级差很大的浮点运算当浮点数值的数量级相差很大的时候，运算又会有什么问题呢？ 又发生了预期外的结果。从输出结果来看，f3竟然和f4是相等的，也就是意味着对f3+1并没有改变f3的值。 这同样是因为浮点数的存储造成的，二进制所能表示的两个相邻的浮点值之间存在一定的空隙。浮点值越大，这个间隙也会越大。当浮点值大道一定程度的时，如果对浮点值的改变很小（例如上面的30000000+1），就不足以使浮点值发生改变。就好比蒸发掉大海中的一滴水，大海还是大海，几乎不存在变化。 如果想要准确的存储，就去使用BigDecimal吧，有必要了解的可以去自行百度，这里就不做过多介绍了，已经是Java封装好的类库了 抛出一个有趣的问题 我们知道，在Java中，long类型占用了8个字节，float类型占用了4个字节。 照理来说，long类型的容量应该比float大许多，然而事实正好相反，float反而拥有比8字节long类型更大的取值范围。这同样是因为浮点数的存储格式造成的。有兴趣的可以去自行百度了解。 参考资料：http://www.jianshu.com/p/39753aad9a38 ，原文作者:CleverFan《Java深入解析》——梁勇著《Effective Java》——第二版《Java核心技术 卷I》——第九版《Java编程思想》——第四版 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"wmyskxz"},{"title":"Java学习笔记(1)——搭建好所需要的环境","slug":"Java学习笔记-1-——搭建好所需要的环境","date":"2017-09-18T14:01:00.000Z","updated":"2020-12-09T05:06:29.791Z","comments":true,"path":"2017/09/18/java-xue-xi-bi-ji-1-da-jian-hao-suo-xu-yao-de-huan-jing/","link":"","permalink":"http://www.wmyskxz.com/2017/09/18/java-xue-xi-bi-ji-1-da-jian-hao-suo-xu-yao-de-huan-jing/","excerpt":"前言：后来仔细思考了一下，从零开始学习Java的系列标题略长（实际改过来的也不短），并且不能正确反映写文的目的，所以决定从这一篇开始改为Java学习笔记。之前的一篇文章在一觉醒来以后也觉得有些不太好还有一些需要添加的地方，所以后来这一个系列是时刻更新的东西，用笔记来命名再好不过了。","text":"前言：后来仔细思考了一下，从零开始学习Java的系列标题略长（实际改过来的也不短），并且不能正确反映写文的目的，所以决定从这一篇开始改为Java学习笔记。之前的一篇文章在一觉醒来以后也觉得有些不太好还有一些需要添加的地方，所以后来这一个系列是时刻更新的东西，用笔记来命名再好不过了。 搭建好我们需要的环境在搭建环境之前，我们需要先来了解以下下面的这些名词： 术语名 缩写 解释 Java Development Kit JDK 编写Java程序的从程序员使用的软件 Java Runtime Environment JRE 运行Java程序的用户使用的软件 Standard Edition SE 用于桌面或简单的服务器应用的Java平台 Enterprise Edition EE 用于复杂的服务器应用的Java平台 Micro Edition ME 用于手机和其他小型设备的Java平台 Java 2 J2 一个过时的术语，用于描述1998年~2006年之间的Java版本 Software Development Kit SDK 一个过时的术语，用于描述1998年~2006年之间的JDK Update u Oracle的术语，用于发布修改的bug NetBeans — Oracle的集成开发环境 安装Java除了相关的集成开发环境IDE(Integrated Development Environment )，还需要下载好能支撑Java运行的JDK。这里有一个有趣的故事是：支撑Java运行的这么一个文件，这么一个系统，恰恰呢就是Java语言本身编写的。所以先下好JDK，官网这里：http://www.oracle.com/technetwork/java/javase/downloads/index.html 进去以后点击JDK进入，然后点击Accept License Agreement，然后根据自己的系统下载不同的JDK就可以。 关于Eclipse还是IDEA我个人还是比较推荐IDEA吧，从安装软件的大小上面就能看出明显的差别… 但也不是那么绝对，IDEA据说是一把双刃剑，我现在没有明显得感受过，但是刚打开这个软件的时候，就略微有一点卡，是因为IDEA本身的检错差错功能十分强大，几乎是实时查错，反正我是一用就爱上了，放上几张图你们感受下： 关于IDEA的弊端其实自己想也能想得到，当项目达到一定程度的时候，它自身的强大的纠错功能，会让系统变得卡顿起来，还有就是它太强大了，开过车的人都不会像要走路，大概就是一样。具体的优点在下面列出，这里推荐两篇CleverFan的文章： IDEA入门级教程——你怎么还在用Eclipse？ IDEA(jetbrain通用)优雅级使用教程 关于IDEA的安装教程网上一搜一大堆..这里不再赘述.. IDEA的简单介绍及设置IDEA的社区版是免费的，我还一直在想着该怎么破解…毕竟这小几百美刀一年的价格对于我这样的平民窟铁头娃来说，实在不太友好，结果用了半天…半点提示没有… 据说IDEA的使用量已经超过Eclipse很久了，那么什么让IDEA这么受欢迎呢？下面摘了一些上面外链文章的精华还有一些来自于百度的精华，来说说最智能的IDE：IDEA。 智能提示重构代码如果你写的代码过于复杂，或者有更好的方式来替代你写的代码，那么IDEA会给你一个提示，告诉你还可以有更好的方式。如下图： 我们学java的时候学过增强的for循环，其实它的学名叫做foreach语句，上面的代码我使用了普通的for循环，IDEA告诉我，使用foreach语句更好。 更友好的代码提示功能使用eclipse的都应该清楚，如果你想要输入StringBuffer，那么你必须得按着顺序输入，直接输sb是不行的，但是在IDEA里你可以这样输入。 不仅如此，看下一个例子 还可以这样提示。这些只是一些很简单的例子，但是已经足够强大了。 什么叫智能？上面的其实都是很基础的功能，IDEA正真智能的 地方在于它会不断的分析你的代码，并且智能的进行反馈。我们 再看一个简单的例子。 这是一个普通的structs程序。在配置文件里定义了一个action并设置了两种不同的返回值。打开我们的action，我们可以看到，你可以直接从代码的左侧找到跳转到对应配置文件的快捷按钮。如果你的某一个方法是覆盖了父类方法，那么你也可以直接查看父类方法。更人性化的是，IDEA可以分析出你的action方法可以跳转到哪些界面？你是不是也有点心动了呢？ 强大的纠错能力我们总是会犯一些低级错误，比如一不留神打错一个字母，可能找了好久都找不到错误所在，IDEA的纠错能力也许可以帮到你，再看一个例子。 我们只创建了两个jsp，当你的返回值中出现了你没创建的文件时，IDEA会提示错误，这样就可以避免你因为写错单词而造成的错误。 以上内容均转自上文外链第一篇文章。原文作者：CleverFan 配置IDEA 我只讲一些非常实用的配置，还有一些常用的快捷键。另外我在安装过程中遇到有搜狗输入法卡在IDEA界面的情况，升级搜狗输入法8.6之后完美解决。如果一开始的字体太小，你可以直接按住Ctrl滚动鼠标的滚轮来调节字体大小哦。 你可以在File菜单下找到Setting，或者直接按下快捷键【Ctrl+Alt+S】 学习编程一定养成习惯不要去装什么中文包，强行让自己习惯英文的界面，我有直观的感受是，现在看这些个菜单或者去Java官方查一些API函数都比较得心应手。 设置自动导入包 如上图标注 1 和 2 所示，默认 IntelliJ IDEA 是没有开启自动 import 包的功能。 勾选标注 1 选项，IntelliJ IDEA 将在我们书写代码的时候自动帮我们优化导入的包，比如自动去掉一些没有用到的包。 勾选标注 2 选项，IntelliJ IDEA 将在我们书写代码的时候自动帮我们导入需要用到的包。但是对于那些同名的包，还是需要手动Alt + Enter 进行导入的，IntelliJ IDEA 目前还无法智能到替我们做判断。 实时代码模板（Live Templates）看以下的图： 当我们输入psvm按下Enter会自动创建man函数（事实上也可以通过输入main然后按下【Ctrl+J】智能提示功能来创建），然后输入sout按下Enter就会自动创建好System.out.println(“”);这么一句。同时这么赞的功能还允许用户自己定义自己的模板，具体的设置在这里： 这里创建了自己的一个模板，叫做syso，代码在下面，感兴趣的自己去研究下： System.out.println(“$val$的值是：—“+ $val$ + “，当前方法=$CLASS_NAME$.$METHOD_NAME$()”);$END$ $VAR1$、$CLASS_NAME$、$METHOD_NAME$ 都为自己定义的变量名。设置变量名只要用两个 $ 包住即可。 每个变量在代码输出的时候都是一次光标位置，光标跳动顺序从左到右，每次跳动按 Enter。 $END$，表示最后都编辑完后光标所处的位置 $SELECTION$，表示设置环绕实时代码模板，环绕功能下面会模板专门进行介绍。 除了两个特例，其他被$包裹的都是自定义变量 这里有Jetbrains的官网介绍：https://www.jetbrains.com/help/idea/live-template-abbreviation.html有兴趣的可以去了解一下，变量也可以这样定义哦。 文件代码模板这个我想大家都知道吧，你每次新建一个文件的时候，总会有一些已经存在的代码或者文字，这个就是文件代码模板。 DEA 默认新建类自带的类注释格式一般不够友好或是规范，所以我们一般需要自己根据喜好或者一些要求设置。 先看一个例子： 只需要如下设置就可以了： 这样就可以每次在新建类的时候都能自动生成平时看代码时候别人写在开头那种屌屌的说明了。建议的格式如下： Postfix Completion先看一个例子： 怎么设置的呢？在设置的地方官方也给了相应的gif动图的演示，非常友好，大家可以自己去看一下。 简单举几个例子好了： 一些快捷键【Ctrl + D】复制当前行到下一行【Ctrl + C】复制当前行【Ctrl + V】粘贴到当前行【Ctrl + / 】注释或取消注释当前行【Ctrl + Shift + Enter】这个功能特别棒，对于强迫症患者来说特别受用，大概是这样：（你们自己具体感受下） 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"wmyskxz"},{"title":"Java学习笔记(0)——了解Java","slug":"Java学习笔记-0-——了解Java","date":"2017-09-17T15:08:00.000Z","updated":"2020-12-09T05:06:26.761Z","comments":true,"path":"2017/09/17/java-xue-xi-bi-ji-0-liao-jie-java/","link":"","permalink":"http://www.wmyskxz.com/2017/09/17/java-xue-xi-bi-ji-0-liao-jie-java/","excerpt":"","text":"前言： 这里是一些关于写文的原因，目的和其他的有的没的，跟Java没有一点关系，如果是想要学习干货的童鞋可以直接跳过。 系列文章最开始的名字是：从零开始学习Java，一来是觉得太长了（改了之后也不短），另外一个一觉醒来觉得好像这个名字不能准确反映自己写文的目的，并且我发现要把一些概念解释得特别清楚给没有编程基础的人看，对我来说是很有难度的一件事情，所以决定把名字改了，笔记是可以改的，就像今天突然想起这一篇有些东西还需要添加就来改了，这也是我喜欢的并乐意做的事情，share。——17.9.18更新 写文的几个原因：这学期笔者也开了Java的课，上的第一节课老师说：教材，你们花两个星期大概看一下就可以扔了。有些同学当笑话听了，有些同学不以为然，而我当真了，我真的把郑莉著的教材《Java语言程序设计》（第2版）“看了一遍”，还不到两个星期，当然其中有一些问题没有去深究，比如数据库还有线程的东西，因为老师说的后面一句话我也认真听了：可以申请不来上课。所以就着笔者c++微薄的基础拉完了一遍教材，很是粗糙，想要重新学习一下，这是一个原因。 昨晚看到简书上的一位博主：CleverFan。他写下的重新认识Java系列，很是受用，本来保持得很好的生物钟，也因为看到他的文章，硬是看到了接近2点，（在此推荐一下）也由此也产生了写文的冲动，这也是一个原因。 今天去看了一下关于Java方面比较权威的两本儿书，一本《Thinking in Java》、《Java核心技术 卷Ⅰ》，觉得写得特别棒，也产生了一些自己的想法，想要分享。 写文的目的：首先需要说的是笔者是一名学渣渣。我也是正在学习，写文更多的目的是在于交流想法，分享学习成果，也是给自己增加一些积累。还有就是觉得有些教材讲得太生涩难懂，这一点也是我看CleverFan的博文想到的，希望自己能通过一些更加好玩的方式写出来。也希望文章有什么问题能够及时反馈给我。 关于更新：因为个人性格的原因，我总是希望能把一件事情做得很好，所以如果有很久没有更新的情况，那就当我正在努力想怎么写文吧…hhh 我会尽可能快的更新文章，也尽可能用通俗易懂的方式说明，会把读者大大们当成是第一次接触Java去细致的讲解，也希望读者大大们能支持我的文章，关于后期维权的东西还没有去想，所以希望如果有转载的请注明一下原文出处谢谢。 正式开始之前先问自己一个问题：Java是什么？如果你的答案仅仅是停留在：是一门编程语言的话，希望看完这篇文章的你，对Java有一个更加全面深入的了解。至少在学习一门语言之前，了解一下自己要学的是什么，对吧？ Java的简单描述 以下大内容部分提炼自Java核心技术 卷Ⅰ 。 Java最初的设计初衷是：能够用于像有线电视转换盒一类处理能力和内存都很有限，并且CPU厂商各不相同的一些消费设备上。然而时至今日在Java的开发者编写的白皮书中（这是Java设计者用来解释设计的初衷以及完成的情况的简短摘要），对Java的描述却是这样的： 你不必全部都读一遍，笔者读来大体的感觉是：为使用者创造了一个更加容易，甚至是dead simple的面向对象的语言，并同时具有移植性好，安全，开发周期短等一系列优点，也为你在烦恼c/c++的复杂性的时候提供了一个新的选择。白皮书的描述更偏向于讲述这是一个更加简单友好的工具，Sun对Java的设计目标就是：微程序员减少复杂性。用他们的话说就是：我们关心的是，减少开发健壮代码所需的时间以及困难。 事实上，Java的成功也源于其类库能够让人们轻松地完成原本有一定难度的事情。例如：联网和多线程。尽管Java对于解决传统的单机程序设计问题非常有用，但同样重要的是，它解决了在万维网（WWW）上的程序设计问题（把超文本页面转换到屏幕上的浏览器）。在白皮书的最后提到了HotJava TM Browser，这是Java开发者使用Java开发的一款用来炫耀Java的强大之处的浏览器，HotJava浏览器具有的在执行网页中内嵌代码的能力在1995年的SunWorld大会上，引发了人们延续至今的对Java的狂热追逐。 Java的成功源自语言本身的一些特性，以及Sun公司的进一步研发和推广。白皮书中对于Java的11个关键术语进行了组织： 关于这一段的描述，《Java核心技术 卷Ⅰ》有有趣简单的描述，感兴趣的可以去百度一下。然而笔者认为，事实上，这些特性现在浏览一遍，心里面知道就行了，没必要去深入，也没有什么用。事实上这一篇文章都是。 Java与其他语言的区别 Java是由c++发展而来的，因为最初开发Java的是Sun公司那一批拥有UNIX应用背景的人，Java更像是C++语法的一个“纯净”版本。这里没有头文件、指针运算（甚至指针语法，但并不代表取消了指针机制，这在后面会讲到）、结构、联合、操作符重载、虚基类等。然而，设计者并没有试图清除C++中所有不适当的特性。例如，switch语法的语法在Java中就没有改变。事实上，Java还有许多奇怪的语法，后面也会提到。 JavaScript和Java除了语法类似，名字类似 ，其他再无什么关系。JavaScript是一种在网页中使用的脚本语言，而Java则是一种强大的面向对象的语言，重点在对象和对象的接口上，而并非所使用的工具上。 面向对象设计是一种程序设计技术。用木匠打一个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是使用的工具；一个“非面向对象的”木匠首先考虑的是自己的工具。 关于Java applet其实很简单，网页中运行的Java程序就是applet，只不过需要一些特别的语法来说明。网页中的嵌入的applet程序就如同在网页中嵌入了一副图片，不同的是，这幅图片能够对于用户的操作作出响应，改变外观、传递数据等。关于这方面可以做一些相关的了解，但笔者并不打算深入研究这方面的东西。 了解面向对象所有的编程语言都提供抽象的机制。就像汇编语言是对于底层机器的轻微抽象。接着出现了所谓的“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。这些语言在汇编语言的基础上有了大幅的改进，但是它们所作的主要抽象仍要求在解决问题的时候要基于计算机的结构，而不是基于所要解决问题的结构来考虑。程序员必须建立起在机器模型和实际待解问题之间的模型的联系。而建立这种映射是费力的，这不是属于编程语言的固有的功能，这使得程序难以编写，并且维护代价高昂。 面向对象的方式通过向程序员提供表示问题空间中的元素的工具而更进一步。那么什么是面向对象呢？所谓对象，其实就是抽象化的数据本身。万物皆是对象，一只狗，一个人，一栋建筑，而这些对象拥有他们自己的一些行为，比如狗要吃饭，要跑，把这些称为属于狗的方法，然后把用一个叫做“类”的东西来打包（封装）好狗这个对象还有属于它的方法，也就是数据和功能。这就是面向对象，它的本质就是：程序可以通过添加新类型的对象使自身适用于某个特定的问题。仅此而已。 写在文章的最后：整篇文章读了好几遍，最开始本来是打算把整一段《Java核心技术 卷Ⅰ》关于Java简史的东西贴出来的，但发现好像用处并不会很大，只有增加篇幅的作用。文章的大部分内容来自于上文提到的两部经典教材，第一次写文，希望喜欢的多多支持，有什么不足也能及时提出，谢谢。 按照惯例黏一个尾巴： 欢迎转载，转载请注明出处！简书ID：@我没有三颗心脏github：wmyskxz欢迎关注公众微信号：wmyskxz分享自己的学习 &amp; 学习资料 &amp; 生活想要交流的朋友也可以加qq群：3382693","categories":[{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[],"author":"wmyskxz"}],"categories":[{"name":"游戏","slug":"游戏","permalink":"http://www.wmyskxz.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/categories/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"},{"name":"想要跟你们分享","slug":"想要跟你们分享","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/"},{"name":"技术人生","slug":"技术人生","permalink":"http://www.wmyskxz.com/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"},{"name":"观点&思考&总结","slug":"想要跟你们分享/观点-思考-总结","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E8%A7%82%E7%82%B9-%E6%80%9D%E8%80%83-%E6%80%BB%E7%BB%93/"},{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/categories/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"前端","slug":"前端","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"},{"name":"基础知识","slug":"基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"网络","slug":"基础知识/网络","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/"},{"name":"好奇星人","slug":"想要跟你们分享/好奇星人","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"},{"name":"面试资料","slug":"面试资料","permalink":"http://www.wmyskxz.com/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/"},{"name":"后端","slug":"后端","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"基础","slug":"后端/Java/基础","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E5%9F%BA%E7%A1%80/"},{"name":"版本特性","slug":"后端/Java/版本特性","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"},{"name":"技术文章","slug":"想要跟你们分享/技术文章","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/"},{"name":"编码之前需要知道的事","slug":"基础知识/编码之前需要知道的事","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"中间件","slug":"后端/中间件","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Redis","slug":"后端/中间件/Redis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"},{"name":"Python","slug":"后端/Python","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Python/"},{"name":"设计模式","slug":"基础知识/设计模式","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"React","slug":"前端/React","permalink":"http://www.wmyskxz.com/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"其他","slug":"后端/中间件/其他","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%85%B6%E4%BB%96/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术类","slug":"读书笔记/技术类","permalink":"http://www.wmyskxz.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%B1%BB/"},{"name":"喜欢的三观","slug":"想要跟你们分享/喜欢的三观","permalink":"http://www.wmyskxz.com/categories/%E6%83%B3%E8%A6%81%E8%B7%9F%E4%BD%A0%E4%BB%AC%E5%88%86%E4%BA%AB/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"},{"name":"Kafka","slug":"后端/中间件/Kafka","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/"},{"name":"基础知识","slug":"后端/中间件/基础知识","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"领域驱动设计","slug":"后端/领域驱动设计","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"},{"name":"SpringCloud","slug":"后端/Java/SpringCloud","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringCloud/"},{"name":"微服务","slug":"后端/微服务","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Docker","slug":"后端/中间件/Docker","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Docker/"},{"name":"Ruby","slug":"后端/Ruby","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Ruby/"},{"name":"MongoDB","slug":"后端/中间件/MongoDB","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/"},{"name":"Elasticserch","slug":"后端/中间件/Elasticserch","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/%E4%B8%AD%E9%97%B4%E4%BB%B6/Elasticserch/"},{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"},{"name":"Shiro","slug":"后端/Java/Shiro","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Shiro/"},{"name":"SpringData","slug":"后端/Java/SpringData","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringData/"},{"name":"SpringBoot","slug":"后端/Java/SpringBoot","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringBoot/"},{"name":"数据结构与算法","slug":"基础知识/数据结构与算法","permalink":"http://www.wmyskxz.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"SSM","slug":"后端/Java/SSM","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SSM/"},{"name":"MyBatis","slug":"后端/Java/MyBatis","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/MyBatis/"},{"name":"SpringMVC","slug":"后端/Java/SpringMVC","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/SpringMVC/"},{"name":"Spring","slug":"后端/Java/Spring","permalink":"http://www.wmyskxz.com/categories/%E5%90%8E%E7%AB%AF/Java/Spring/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://www.wmyskxz.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"一周精彩内容分享","slug":"一周精彩内容分享","permalink":"http://www.wmyskxz.com/tags/%E4%B8%80%E5%91%A8%E7%B2%BE%E5%BD%A9%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/"},{"name":"快速入门","slug":"快速入门","permalink":"http://www.wmyskxz.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"name":"比特币","slug":"比特币","permalink":"http://www.wmyskxz.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"},{"name":"Offer一箩筐","slug":"Offer一箩筐","permalink":"http://www.wmyskxz.com/tags/Offer%E4%B8%80%E7%AE%A9%E7%AD%90/"},{"name":"版本特性","slug":"版本特性","permalink":"http://www.wmyskxz.com/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"},{"name":"MoreThanJava","slug":"MoreThanJava","permalink":"http://www.wmyskxz.com/tags/MoreThanJava/"},{"name":"翻译文","slug":"翻译文","permalink":"http://www.wmyskxz.com/tags/%E7%BF%BB%E8%AF%91%E6%96%87/"},{"name":"Redis","slug":"Redis","permalink":"http://www.wmyskxz.com/tags/Redis/"},{"name":"项目实录","slug":"项目实录","permalink":"http://www.wmyskxz.com/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BD%95/"},{"name":"初学JavaWeb","slug":"初学JavaWeb","permalink":"http://www.wmyskxz.com/tags/%E5%88%9D%E5%AD%A6JavaWeb/"}]}