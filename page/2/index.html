<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      
        <meta name="robots" content="noindex,follow">
      
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      

<div class='l_main'>
  
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/06/04/morethanjava-ji-qi-zhi-ling-dao-hui-bian-zai-dao-gao-ji-bian-cheng-yu-yan/">
      「MoreThanJava」机器指令到汇编再到高级编程语言
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年6月4日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-cf10d459bcd9084c.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="Part-1-机器指令"><a href="#Part-1-机器指令" class="headerlink" title="Part 1. 机器指令"></a>Part 1. 机器指令</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-6ee293ad1efc6c9c.png" alt=""></p>
<p><a href="https://www.wmyskxz.com/2020/06/02/morethanjava-yi-wen-liao-jie-er-jin-zhi-he-cpu-gong-zuo-yuan-li/">上一次</a> 我们已经了解了 <strong>二进制和 CPU 的基本原理</strong>，知道了程序运行时，CPU 每秒数以亿次、十亿次、百亿次地震荡着时钟，同步执行着微小的 <strong>「电子操作」</strong>，例如：从内存读取一个字节的数据到 CPU 又或者判断字节中的某一位是 <code>0</code> 还是 <code>1</code>。 </p>
<p><strong>CPU</strong> 本身有一组 <strong>规定好的</strong> 可以执行的 <strong>「基本动作」</strong>（被称为 <strong>机器指令</strong>）：</p>
<ol>
<li>读取指令；2. 执行指令；3. 写寄存器；</li>
</ol>
<p><strong>这几乎就是 CPU 工作的全部了。</strong> 这些动作虽然每次只能执行一次，但是每秒可以执行数十亿次，这个数量级的「小操作」累加成为一个大的「有用的操作」。</p>
<p>处理器所做的一切都是基于这些微小的操作！幸运的是，我们已经不再需要了解这些操作的详细信息就可以编写和使用各类程序。诸如 <strong>Java</strong> 这一类的 <strong>「高级语言」</strong> 的 <strong>目的</strong> 就是 <strong>将这些微小的电子操作组织成由人类可读的「程序语言」表示的大型有用单元</strong>。</p>
<h2 id="机器指令演示"><a href="#机器指令演示" class="headerlink" title="机器指令演示"></a>机器指令演示</h2><p>一条 <strong>机器指令</strong> 一般由内存中的几个字节组成，它们告诉 CPU 应该执行一个什么样的 <strong>「机器操作」</strong>（是取数据还是写寄存器等..）。处理器依次查看 CPU 中的机器指令，并执行每一条。内存中的一组机器指令被称为 <strong>「机器语言程序」</strong>，或称为 <strong>「可执行程序」</strong>。</p>
<p>下面我们来使用机器语言来演示一个控制灯泡亮度的机器语言程序。</p>
<h3 id="先和硬件做好规定"><a href="#先和硬件做好规定" class="headerlink" title="先和硬件做好规定"></a>先和硬件做好规定</h3><p>假设灯泡由内存中的某一个程序控制，该程序能够完全打开和关闭灯泡，可以使灯泡变亮或变暗，机器指令一个字节长度，并且与机器操作对应如下：</p>
<table>
<thead>
<tr>
<th align="left">机器指令</th>
<th align="left">机器操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00000000</td>
<td align="left">停止程序</td>
</tr>
<tr>
<td align="left">00000001</td>
<td align="left">完全打开灯泡</td>
</tr>
<tr>
<td align="left">00000010</td>
<td align="left">完全关闭灯泡</td>
</tr>
<tr>
<td align="left">00000100</td>
<td align="left">灯泡暗淡 10％</td>
</tr>
<tr>
<td align="left">00001000</td>
<td align="left">将灯泡照亮 10％</td>
</tr>
<tr>
<td align="left">00010000</td>
<td align="left">如果灯泡完全点亮，则跳过下一条说明</td>
</tr>
<tr>
<td align="left">00100000</td>
<td align="left">如果灯泡完全熄灭，请跳过下一条说明</td>
</tr>
<tr>
<td align="left">01000000</td>
<td align="left">转到程序的开始（地址 0）</td>
</tr>
</tbody></table>
<h3 id="Demo-程序-amp-amp-演示"><a href="#Demo-程序-amp-amp-演示" class="headerlink" title="Demo 程序 &amp;&amp; 演示"></a>Demo 程序 &amp;&amp; 演示</h3><p>根据上方作出的规定，我们写下如下的程序：（为了方便理解，我把对应的机器操作也写在了后面，实际的程序只包含机器指令）</p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">机器指令</th>
<th align="left">机器操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">00000001</td>
<td align="left">完全打开灯泡</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">00000010</td>
<td align="left">完全关闭灯泡</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">00000001</td>
<td align="left">完全打开灯泡</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">00000100</td>
<td align="left">灯泡暗淡10％</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">00000100</td>
<td align="left">灯泡暗淡10％</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">00000000</td>
<td align="left">停止程序</td>
</tr>
</tbody></table>
<p>所以这样的一段程序执行效果就如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-2a922323d1f45ffd.gif" alt=""></p>
<p>您可以尝试自己利用 <code>01000000</code>（跳转到程序开始） 来改写程序来达到让「灯逐渐变亮又逐渐变暗」的目的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面演示的程序 <strong>核心思想</strong> 是：</p>
<ul>
<li>机器语言程序是内存中一系列机器指令的集合；</li>
<li>机器指令由一个或多个字节组成（在此示例中，仅一个字节）；</li>
<li>处理器一次运行一条机器指令的程序；</li>
<li>所有的小机器操作加起来都是有用的；</li>
</ul>
<p>在实际的 CPU 中，拥有更多的机器指令，而且更详细，并且不同的 CPU，指令集是不同的。典型的 CPU 拥有一千或更多的机器指令。</p>
<h1 id="Part-2-汇编语言"><a href="#Part-2-汇编语言" class="headerlink" title="Part 2. 汇编语言"></a>Part 2. 汇编语言</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-4834493064c41421.png" alt=""></p>
<ul>
<li>图片来源：<a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html</a></li>
</ul>
<h2 id="机器语言太-“反人类”"><a href="#机器语言太-“反人类”" class="headerlink" title="机器语言太 “反人类”"></a>机器语言太 “反人类”</h2><p>我们已经可以开始写一些程序使用了，但是使用 <strong>机器语言编写代码会十分辛苦</strong>，比如：</p>
<pre class=" language-text"><code class="language-text">00000001 00000010 00000001
00000100 00000100 00000000</code></pre>
<p>即使你刚看过你也会对这一段就在 <em>上方的实例代码</em> 没有什么感知，这是因为机器语言是设计给机器的，人类记忆和使用起来就会显得十分麻烦。</p>
<p>如此你就会感知到 <strong>上个世纪</strong> 的程序员使用 <strong>打孔卡片</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-aa97150420cde053.png" alt=""></p>
<p>使用 <strong>纸带</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-9aed2e64ac966c45.png" alt=""></p>
<p>甚至是 <strong>直接插拔线路 or 按下开关</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-e420ae77ac52711a.png" alt=""></p>
<p>是一件多么硬核的事情…</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-8ea1cb3a5bfecc68.jpg" alt=""></p>
<blockquote>
<p>如果你对它们如何工作以及多么硬核感兴趣，可以参考一下下方的链接：</p>
<ul>
<li>开发语言小传之一：最早的编程语言——机器语言 - <a href="https://blog.csdn.net/killer080414/article/details/42219091" target="_blank" rel="noopener">https://blog.csdn.net/killer080414/article/details/42219091</a></li>
<li>50年前的登月程序和程序员有多硬核 - <a href="https://coolshell.cn/articles/19612.html、" target="_blank" rel="noopener">https://coolshell.cn/articles/19612.html、</a></li>
</ul>
<p>再附带一个宝藏网站(哥伦比亚大学出版的计算机历史，非常详细)，有条件的同学 <strong>非常推荐</strong> 进去浏览一下：</p>
<ul>
<li><a href="http://www.columbia.edu/cu/computinghistory/index.html" target="_blank" rel="noopener">http://www.columbia.edu/cu/computinghistory/index.html</a></li>
</ul>
</blockquote>
<h2 id="汇编语言诞生"><a href="#汇编语言诞生" class="headerlink" title="汇编语言诞生"></a>汇编语言诞生</h2><p>CPU 的指令都是 <strong>二进制</strong> 的，这显然对于人类来说是 <strong>不可读</strong> 的。为了解决二进制指令的可读性问题，工程师将那些指令写成了 <strong>八进制</strong>。二进制转八进制是轻而易举的，但是八进制的可读性也不行。</p>
<p>很自然地，最后还是用文字表达，加法指令写成 <code>ADD</code>。内存地址也不再直接引用，而是 <strong>用标签</strong> 表示。</p>
<p>这样的话，就多出一个步骤，<strong>要把这些文字指令翻译成二进制</strong>，这个步骤就称为 <code>assembling</code>，完成这个步骤的程序就叫做 <code>assembler</code>。它处理的文本，自然就叫做 <code>aseembly code</code>。标准化以后，称为 <code>assembly language</code>，缩写为 <code>asm</code>，中文译为 <strong>汇编语言</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-203e229b0c87bd18.png" alt=""></p>
<ul>
<li>图片来源：<a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html</a></li>
</ul>
<h2 id="理解汇编语言"><a href="#理解汇编语言" class="headerlink" title="理解汇编语言"></a>理解汇编语言</h2><p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 <code>x86</code> 汇编语言，即 <code>Intel</code> 公司的 CPU 使用的那一种。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>要学习汇编语言，首先必须了解两个知识点：<strong>寄存器</strong> 和 <strong>内存模型</strong>。</p>
<p>先来看寄存器。<strong>CPU 本身只负责运算，不负责储存数据</strong>。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，<strong>为了避免被拖慢</strong>，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-d3febfa4f6248c7d.png" alt=""></p>
<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<h4 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h4><p>早期的 <code>x86</code> CPU 只有 <code>8</code> 个寄存器，而且每个都有不同的用途。现在的寄存器已经有 <code>100</code> 多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<blockquote>
<ul>
<li>EAX</li>
<li>EBX</li>
<li>ECX</li>
<li>EDX</li>
<li>EDI</li>
<li>ESI</li>
<li>EBP</li>
<li>ESP</li>
</ul>
</blockquote>
<p>上面这 <code>8</code> 个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-949e1a35f38f8898.png" alt=""></p>
<p>我们常常看到 <code>32</code> 位 CPU、<code>64</code> 位 CPU 这样的名称，其实指的就是寄存器的大小。<code>32</code> 位 CPU 的寄存器大小就是 <code>4</code> 个字节。</p>
<h3 id="内存模型：Heap（堆）"><a href="#内存模型：Heap（堆）" class="headerlink" title="内存模型：Heap（堆）"></a>内存模型：Heap（堆）</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从 <code>0x1000</code> 到 <code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-78b083f070d65ab6.png" alt=""></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用 <code>malloc</code> 命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到 <code>10</code> 个字节内存，那么从起始地址 <code>0x1000</code> 开始给他分配，一直分配到地址 <code>0x100A</code>，如果再要求得到 <code>22</code> 个字节，那么就分配到 <code>0x1020</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-e575954166da5090.png" alt=""></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做 <strong>Heap（堆）</strong>。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h3 id="内存模型：Stack（栈）"><a href="#内存模型：Stack（栈）" class="headerlink" title="内存模型：Stack（栈）"></a>内存模型：Stack（栈）</h3><p>除了 Heap 以外，其他的内存占用叫做 <strong>Stack（栈）</strong>。简单说，Stack 是由于 <strong>函数运行</strong> 而 <strong>临时占用</strong> 的内存区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-0a9073ba882f158a.png" alt=""></p>
<p>例如我们在执行一个叫 <code>main</code> 的函数时，会为它在内存里面创建一个 <strong>帧</strong>，用来保存所有 <code>main</code> 中使用的内部变量。<code>main</code> 函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-393e553bd956109f.png" alt=""></p>
<p>如果在 <code>main</code> 函数 <strong>内部调用了其他函数</strong>，例如 <code>add_a_and_b</code> 函数，那么执行到这一行的时候，系统也会为 <code>add_a_and_b</code> 新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code> 和 <code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-2b3d6f5af3c0770b.png" alt=""></p>
<p>等到 <code>add_a_and_b</code> 运行结束，它的帧就会被回收，系统会回到函数 <code>main</code> 刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的 <strong>层层调用</strong>，并且 <strong>每一层都能使用自己的本地变量</strong>。</p>
<p>我们可以把栈理解为一个下方密封，而上方打开的「桶」。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-d03701d8ad5833a8.png" alt=""></p>
<p>生成的新帧放入我们称之为 <strong>「入栈」</strong>，而释放帧我们称之为 <strong>「出栈」</strong>。<strong>栈的特点</strong> 就是，<strong>最晚入栈的帧最早出栈</strong>（因为最内层的函数调用，最先结束运行），这就叫做 <strong>“后进先出”</strong> 的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个栈就都释放了。</p>
<h2 id="汇编语言演示"><a href="#汇编语言演示" class="headerlink" title="汇编语言演示"></a>汇编语言演示</h2><p>举个简单的例子，我们需要计算：</p>
<pre class=" language-text"><code class="language-text">(1 + 4) * 2 + 3</code></pre>
<p>我们按照 <strong>「后缀表示法」</strong> 进行一下转换：</p>
<pre class=" language-text"><code class="language-text">1，4，+，2，*，3，+</code></pre>
<p>我们平常使用的方法是 <strong>「中缀表示法」</strong>，也就是把计算符号放中间，例如 <code>1 + 3</code>，后缀则是把符号放最后，例如 <code>1, 3, +</code>。</p>
<p>这样做的好处是没有先乘除后加减的影响，也没有括号，直接运算就行了。<em>（例如 <code>1, 3, +</code>，先把 <code>1</code> 和 <code>3</code> 保存起来碰到 <code>+</code> 知道是加法则直接相加）</em></p>
<p>OK，我们从头开始使用汇编语言来编写一下程序，首先第一步：把 <code>1</code> 保存起来（放入寄存器）：</p>
<pre class=" language-arm"><code class="language-arm">MOV  1</code></pre>
<p>之后是 <code>4, +</code>，那就直接加一下：</p>
<pre class=" language-arm"><code class="language-arm">ADD 4</code></pre>
<p>然后是 <code>2, *</code>，那就直接乘一下（<code>SHL</code> 是向左移动一位的意思，二进制中左移一个单位就相当于乘以 <code>2</code>，例如 <code>01</code> 表示 <code>1</code>，而 <code>10</code> 则表示 <code>2</code>）：</p>
<pre class=" language-arm"><code class="language-arm">SHL 0</code></pre>
<p>最后是 <code>3, +</code>，再加一下：</p>
<pre class=" language-arm"><code class="language-arm">ADD 3</code></pre>
<p>完整程序如下：</p>
<pre class=" language-arm"><code class="language-arm">MOV  1
ADD  4
SHL  0
ADD  3</code></pre>
<p>这似乎看起来比 <code>00001111</code> 这样的二进制要好上太多了！程序员们感动到落泪：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-efd40f79c24dbafe.png" alt=""></p>
<h1 id="Part-3-高级编程语言"><a href="#Part-3-高级编程语言" class="headerlink" title="Part 3. 高级编程语言"></a>Part 3. 高级编程语言</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-3188bcc7ce7f2b9e.png" alt=""></p>
<p>摆脱了 <strong>二进制</strong>，我们有了更可读的 <strong>汇编语言</strong>，但仍然十分繁琐和复杂，每一条汇编指令代表一个基本操作，例如：「从内存 x 位置获取一个数字并放入寄存器 A」、「将寄存器 A 中的数字添加到寄存器 B 的数字上」。<strong>这样的编程风格既费时又容易出错，并且一旦出错还很难发现。</strong></p>
<p>例如，我们来看一看 <strong>「1969 年阿波罗 11号登月计划」</strong> 用来 <strong>防止登月舱计算机耗尽自身资源</strong> 的 BAILOUT 代码：</p>
<pre class=" language-arm"><code class="language-arm">POODOO    INHINT
    CA  Q
    TS  ALMCADR

    TC  BANKCALL
    CADR  VAC5STOR  # STORE ERASABLES FOR DEBUGGING PURPOSES.

    INDEX  ALMCADR
    CAF  0
ABORT2    TC  BORTENT

OCT77770  OCT  77770    # DONT MOVE
    CA  V37FLBIT  # IS AVERAGE G ON
    MASK  FLAGWRD7
    CCS  A
    TC  WHIMPER -1  # YES.  DONT DO POODOO.  DO BAILOUT.

    TC  DOWNFLAG
    ADRES  STATEFLG

    TC  DOWNFLAG
    ADRES  REINTFLG

    TC  DOWNFLAG
    ADRES  NODOFLAG

    TC  BANKCALL
    CADR  MR.KLEAN
    TC  WHIMPER</code></pre>
<ul>
<li>出处：改变世界的代码行 - <a href="https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX" target="_blank" rel="noopener">https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX</a></li>
</ul>
<p>似乎不太容易读的样子…</p>
<blockquote>
<p>阿波罗登月计划的源代码在 Github 上已经公开，有兴趣的可以去下方链接膜拜一下（可以去感受一下当时程序员的工程能力）：</p>
<ul>
<li><a href="https://github.com/chrislgarry/Apollo-11" target="_blank" rel="noopener">https://github.com/chrislgarry/Apollo-11</a></li>
</ul>
<p>另外附一下当时代码的设计负责人 Margaret Heafield Hamilton（女程序员）和完成的堆起来跟人一样高的代码量：<br><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-8707d4533e93307d.png" alt=""></p>
</blockquote>
<h2 id="第一个高级语言：FORTRAN"><a href="#第一个高级语言：FORTRAN" class="headerlink" title="第一个高级语言：FORTRAN"></a>第一个高级语言：FORTRAN</h2><p>当 <strong>John Backus</strong> 在 <code>1950</code> 年以一名科学程序员的身份加入 IBM 时，已经可以使用诸如 <code>ADD</code> 之类的助记词代替数字代码来编写程序，也就是我们的汇编语言。这使编程变得容易一些，但是即使是一个简单的程序也需要数十次操作，并且仍然很难找到错误。</p>
<p>巴克斯认为，应该有可能创建一种编程语言，使一系列计算可以用类似于数学符号的形式来表达。然后，使用特定的翻译程序（以今天的术语来说是编译器）可以将其转换为计算机可以理解的数字代码。</p>
<p>Backus 在 <code>1953</code> 年向他的经理提出了这个想法。他得到了预算，并被鼓励雇用一个小团队来测试该想法的可行性。三年后，该团队发布了一本手册，其中描述了 IBM Mathematical Formula Translating System（简称 FORTRAN）。不久之后， IBM 向 IBM 704 的用户提供了第一个 FORTRAN 编译器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-7af2b672fb5f3f27.png" alt="FORTRAN 之父"></p>
<p>Backus 和他的团队创造了世界上第一种高级编程语言。<strong>科学家和工程师将不再需要将其程序编写为数字代码或冗长的助记符</strong>。</p>
<h3 id="FORTRAN-代码演示"><a href="#FORTRAN-代码演示" class="headerlink" title="FORTRAN 代码演示"></a>FORTRAN 代码演示</h3><p>下面演示计算并输出 <code>8 * 6</code> 的代码实例：</p>
<pre class=" language-fortran"><code class="language-fortran"><span class="token keyword">program</span> VF0944
<span class="token keyword">implicit none</span>

<span class="token keyword">integer</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c
a<span class="token operator">=</span> <span class="token number">8</span>
b<span class="token operator">=</span> <span class="token number">6</span>
c<span class="token operator">=</span> a<span class="token operator">*</span>b

<span class="token keyword">print</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token string">'Hello World, a, b, c= '</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c
<span class="token keyword">end program</span> VF0944</code></pre>
<p><em>对比汇编代码，是不是看上去要清晰（人类可读）多了呢？</em></p>
<h3 id="FORTRAN-的意义"><a href="#FORTRAN-的意义" class="headerlink" title="FORTRAN 的意义"></a>FORTRAN 的意义</h3><p>FORTRAN 的问世在计算机史上具有划时代的意义，它使计算机语言从原始的低级汇编语言走出来，进入了更高的境界，使得 <strong>计算机语言不再是计算机专家的专利</strong>，使广大的工程技术人员有了进行计算机编程的手段。</p>
<p>由此计算机更快地深入到了社会之中，它在工业部门中初露头角，更是在火箭、导弹、人造地球卫星的设计中大显身手，因此有人称 FORTRAN 语言使计算机的工业应用成了可能，是推动第二次世界大战以后西方工业经济复苏和进入第二次工业革命的无形力量，是 “看不见的蒸汽机”。</p>
<h2 id="FORTRAN-后时代"><a href="#FORTRAN-后时代" class="headerlink" title="FORTRAN 后时代"></a>FORTRAN 后时代</h2><p>FORTRAN 高级程序设计语言的出现孕育了计算机软件业，继其之后，计算机高级程序语言的开发进入到了一个蓬勃发展的时代。</p>
<h3 id="1959"><a href="#1959" class="headerlink" title="1959"></a><strong>1959</strong></h3><p>Grace Hopper 发明了第一个面向企业业务的编程语言，又称 “面向商业的通用语言”，也常常简称 COBOL。</p>
<h3 id="1964"><a href="#1964" class="headerlink" title="1964"></a><strong>1964</strong></h3><p>美国达特茅斯学院约翰·凯梅尼和托马斯·卡茨认为，像 FORTRAN 那样的语言太过专业，编程非常困难。于是他们简化了 FORTRAN，并设计出了更适合初学者的 BASIC 语言。</p>
<h3 id="1970"><a href="#1970" class="headerlink" title="1970"></a><strong>1970</strong></h3><p>尼古拉斯·沃斯非常痴迷于编程语言，他率先提出了结构化程序设计思想并发明了 Pascal 语言。</p>
<p>此外他还提出了 Wirth 定律，意为 “软件变慢的速度比硬件变快的速度更快”，这让摩尔定律变得充满讽刺。之后的 Electron.js 也确实证明了这一点。</p>
<h3 id="1972"><a href="#1972" class="headerlink" title="1972"></a><strong>1972</strong></h3><p>丹尼斯·里奇在贝尔实验室工作期间发明了 C 语言，开启了现代程序语言的革命。之后，他又添加了段错误和其他一些帮助开发人员的实用功能，大大提升了编程效率。</p>
<p>除了 C 语言之外， 他和贝尔实验室的同事还创造了伟大的 Unix 操作系统。</p>
<h3 id="1980"><a href="#1980" class="headerlink" title="1980"></a><strong>1980</strong></h3><p>Alan Kay 发明了面向对象的编程语言 Smalltalk，在 Smalltalk 中，一切皆对象。</p>
<h3 id="1987"><a href="#1987" class="headerlink" title="1987"></a><strong>1987</strong></h3><p>拉里·沃尔发明了 Perl 语言。</p>
<h3 id="1983"><a href="#1983" class="headerlink" title="1983"></a><strong>1983</strong></h3><p>Jean Ichbiah 发现 Ada Lovelace 的程序从未运行成功过，因此决定用她的名字创建一种语言，于是 Ada 语言诞生了。</p>
<h3 id="1986"><a href="#1986" class="headerlink" title="1986"></a><strong>1986</strong></h3><p>Brac Box 和 Tol Move 通过融合 C 语言和 Smalltalk 的特征，发明了 Objective-C。但由于其语法晦涩，不太容易理解。</p>
<h3 id="1983-1"><a href="#1983-1" class="headerlink" title="1983"></a><strong>1983</strong></h3><p>Bjarne Stroustrup 在 C 语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言并将其命名为 C++。</p>
<p>C++ 大大提升了应用程序的编程效率。</p>
<h3 id="1991"><a href="#1991" class="headerlink" title="1991"></a><strong>1991</strong></h3><p>Guido van Rossum 讨厌带有大括号的编程语言，于是他参考 Monty Python 和 Flying Circus 语法，并发明了 Python。</p>
<h3 id="1993"><a href="#1993" class="headerlink" title="1993"></a><strong>1993</strong></h3><p>Roberto Ierusalimschy 和其朋友创造了一门巴西本地的脚本语言。在本地化过程中，由于一个小的错误使得索引从1开始，而不是0。这门语言就是 Lua。</p>
<h3 id="1994"><a href="#1994" class="headerlink" title="1994"></a><strong>1994</strong></h3><p>Rasmus Lerdorf 为他个人主页的 CGI 脚本制作了一个模板引擎，用来统计他自己网站的访问量。</p>
<p>这个文件被上传到网上之后用它的人越来越多。后来又用 C 语言重新编写，还添加了数据库访问功能。这门语言就是 PHP。</p>
<h3 id="1995"><a href="#1995" class="headerlink" title="1995"></a><strong>1995</strong></h3><p>松本行弘发明了 Ruby 语言。</p>
<h3 id="1995-1"><a href="#1995-1" class="headerlink" title="1995"></a><strong>1995</strong></h3><p>Brendan Eich 利用周末时间设计了一种语言，用于为世界各地的网页浏览器提供支持，并最终推出了 Skynet。他最初去了 Netscape，并将这门语言命名为 LiveScript，后来在代码审查期间 Java 逐渐开始风靡，因此他们决定将其改名为 JavaScript。</p>
<p>后来 Java 使其陷入了商标麻烦，于是 JavaScript 被更名为 ECMAScript。但是人们还是习惯称之为 JavaScript。</p>
<h3 id="1996"><a href="#1996" class="headerlink" title="1996"></a><strong>1996</strong></h3><p>James Gosling 发明了 <strong>Java</strong>，这是 <strong>第一个真正意义上面向对象得编程语言</strong>，其中设计模式在实用主义中占统治地位。</p>
<h3 id="More…"><a href="#More…" class="headerlink" title="More…"></a><strong>More…</strong></h3><blockquote>
<p>对于这一段计算机历史感兴趣的同学可以拜读一下「IT 通史 12.2 节 - 高级计算机程序设计语言」的内容，在线预览链接如下：</p>
<ul>
<li><a href="https://books.google.com.hk/books?id=ZrAol3RzcNkC&amp;printsec=frontcover&amp;hl=zh-CN#v=onepage&amp;q&amp;f=false" target="_blank" rel="noopener">https://books.google.com.hk/books?id=ZrAol3RzcNkC&amp;printsec=frontcover&amp;hl=zh-CN#v=onepage&amp;q&amp;f=false</a></li>
</ul>
</blockquote>
<h2 id="高级语言分类"><a href="#高级语言分类" class="headerlink" title="高级语言分类"></a>高级语言分类</h2><p>CPU 终究只认识二进制指令，在我们发明高级语言之后，仍然无可避免的需要进行 <strong>「翻译」</strong> 工作。按照翻译方式的不同，我们又把高级语言分为了 <strong>「编译型」</strong> 和 <strong>「解释型」</strong>。</p>
<h3 id="编译型"><a href="#编译型" class="headerlink" title="编译型"></a>编译型</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-9cdee01ebffd03fa.png" alt=""></p>
<p><strong>编译型专业解释为：</strong></p>
<p>使用 <strong>专门的编译器</strong>，针对 <strong>特定的平台</strong>，将高级语言源代码 <strong>一次性</strong> 的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式，并且只需要编译一次，以后再也不用编译。其实可以简单理解成谷歌/ 百度翻译，我们把要翻译的文字全部放进去，一次翻译，下次使用直接使用上一次翻译好的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-f53a05407cbcf42f.png" alt=""></p>
<ul>
<li><strong>优点（较解释型）</strong>：执行效率高(有解释器省去很多翻译的过程)</li>
<li><strong>缺点（较解释型）</strong>：开发效率低(写完所有的代码才能检查 <code>bug</code>，得多恐怖呀？？？)</li>
</ul>
<h3 id="解释型"><a href="#解释型" class="headerlink" title="解释型"></a>解释型</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-eb0add81015d2b0f.png" alt=""></p>
<p><strong>解释型专业解释为：</strong></p>
<p>使用 <strong>专门的解释器</strong> 对源程序逐行解释成 <strong>特定平台</strong> 的机器码并 <strong>立即执行</strong>，它不需要事先编译，直接将代码解释称机器码直接运行，也就是说只要某一平台提供了相应的解释器即可运行代码。其实可以理解成同声传译，我们需要翻译的时候，找一个翻译员，对方说一句翻译员翻译一句，下次翻译还是需要一个翻译员一句一句的翻译。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-06dcaf7ccfd6c791.png" alt=""></p>
<ul>
<li><strong>缺点（较编译型）</strong>：执行效率低(写一次翻译一次)</li>
<li><strong>优点（较编译型）</strong>：开发效率高(写一行翻译一行，错了马上就知道，妈妈再也不用担心我找不到 bug 了)</li>
</ul>
<h3 id="半解释半编译的-Java"><a href="#半解释半编译的-Java" class="headerlink" title="半解释半编译的 Java"></a>半解释半编译的 Java</h3><p>不同厂商、不同时间开发的 CPU 的指令集是不一样的，这就是上方为什么提到要使用 <strong>专门的解释器</strong>，要用于 <strong>特定的平台</strong> 的原因。</p>
<p>所以 Java 为了实现 <strong>「一次编译，到处运行」</strong> 的目的，采用了一种特别的方案：先 <strong>编译</strong> 为 <strong>与任何具体及其环境及操作系统环境无关的中间代码</strong>（也就是 <code>.class</code> 字节码文件），然后交由各个平台特定的 Java 解释器（也就是 JVM）来负责 <strong>解释</strong> 运行。</p>
<p>编程人员和计算机都无法直接读懂字节码文件，它必须由专用的 Java 解释器来解释执行，因此 Java 是一种在 <strong>编译基础上进行解释运行</strong> 的语言。（Java 程序运行流程如下）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-81a0bce7dbea21a5.png" alt=""></p>
<p><strong>Java 解释器</strong> 负责将字节码文件翻译成具体硬件环境和操作系统平台下的机器代码，以便执行。因此 Java 程序不能直接运行在现有的操作系统平台上，它必须运行在被称为 Java 虚拟机的软件平台之上。</p>
<p><strong>Java 虚拟机（JVM）</strong> 是运行 Java 程序的软件环境（我们后面会详细说到，这是学习 Java 绕不过的题），Java 解释器是 Java 虚拟机的一部分。在运行 Java 程序时，首先会启动 JVM，然后由它来负责解释执行 Java 的字节码程序，并且 Java 字节码程序只能运行于 JVM 之上。这样利用 JVM 就可以把 Java 字节码程序和具体的硬件平台以及操作系统环境分隔开来，只要在不同的计算机上安装了针对特定平台的 JVM，Java 程序就可以运行，而不用考虑当前具体的硬件平台及操作系统环境，也不用考虑字节码文件是在何种平台上生成的。</p>
<p>JVM 把这种不同软、硬件平台的具体差别隐藏起来，从而 <strong>实现了真正的二进制代码级的跨平台移植</strong>。JVM 是 Java 平台架构的基础，Java 的跨平台特性正是通过在 JVM 中运行 Java 程序实现的。Java 的这种运行机制可以通过下图来说明：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-ffb2a690be748121.png" alt=""></p>
<p>Java 语言这种「一次编写，到处运行」的方式，有效地解决了目前大多数高级程序设计语言需要针对不同系统来编译产生不同机器代码的问题，即硬件环境和操作平台的异构问题，大大降低了程序开发、维护和管理的开销。</p>
<ul>
<li><strong>提示：</strong> Java 程序通过 JVM 可以实现跨平台特性，但 JVM 是不跨平台的。也就是说，<strong>不同操作系统之上的 JVM 是不同的</strong>，Windows 平台之上的 JVM 不能用在 Linux 平台，反之亦然。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Introduction to Computer Science using Java | CHAPTER 4 - <a href="http://programmedlessons.org/Java9/chap04/ch04_01.html" target="_blank" rel="noopener">http://programmedlessons.org/Java9/chap04/ch04_01.html</a></li>
<li>汇编语言入门教程 - <a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html</a></li>
<li>CPU 是怎么认识代码的？ | 知乎@Zign - <a href="https://www.zhihu.com/question/348237008/answer/843382847" target="_blank" rel="noopener">https://www.zhihu.com/question/348237008/answer/843382847</a></li>
<li>改变世界的代码行 - <a href="https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX" target="_blank" rel="noopener">https://www.infoq.cn/article/5CaYH8NbS6BmptWKRgkX</a></li>
<li>The History of FORTRAN - <a href="https://www.obliquity.com/computer/fortran/history.html" target="_blank" rel="noopener">https://www.obliquity.com/computer/fortran/history.html</a></li>
<li>《IT 通史》 | @李彦</li>
<li>A Brief Totally Accurate History Of Programming Languages - <a href="https://medium.com/commitlog/a-brief-totally-accurate-history-of-programming-languages-cd93ec806124" target="_blank" rel="noopener">https://medium.com/commitlog/a-brief-totally-accurate-history-of-programming-languages-cd93ec806124</a></li>
<li>编程语言分类 - <a href="https://www.cnblogs.com/nickchen121/p/10722720.html" target="_blank" rel="noopener">https://www.cnblogs.com/nickchen121/p/10722720.html</a></li>
</ol>
<h1 id="往期精彩"><a href="#往期精彩" class="headerlink" title="往期精彩"></a>往期精彩</h1><ol>
<li><a href="https://www.wmyskxz.com/2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/">「MoreThanJava」当大学选择了计算机之后应该知道的</a></li>
<li><a href="https://www.wmyskxz.com/2020/04/07/morethanjava-ji-suan-ji-fa-zhan-shi-cong-zhi-bu-ji-dao-ibm/">「MoreThanJava」计算机发展史—从织布机到IBM</a></li>
<li><a href="https://www.wmyskxz.com/2020/06/01/morethanjava-ji-suan-ji-xi-tong-gai-shu/">「MoreThanJava」计算机系统概述</a></li>
<li><a href="https://www.wmyskxz.com/2020/06/02/morethanjava-yi-wen-liao-jie-er-jin-zhi-he-cpu-gong-zuo-yuan-li/">「MoreThanJava」一文了解二进制和CPU工作原理</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-14186da97253f1b8.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/06/02/morethanjava-yi-wen-liao-jie-er-jin-zhi-he-cpu-gong-zuo-yuan-li/">
      「MoreThanJava」一文了解二进制和CPU工作原理
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年6月2日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-8dfb481bc47e9a8a.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="Part-1-原来，我们是这样记数的"><a href="#Part-1-原来，我们是这样记数的" class="headerlink" title="Part 1. 原来，我们是这样记数的"></a>Part 1. 原来，我们是这样记数的</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-9c0d647650be0bd5.png" alt=""></p>
<blockquote>
<p>本节内容节选自下方 <a href="https://www.jianshu.com/p/58844323e4fb" target="_blank" rel="noopener">参考资料 1</a></p>
</blockquote>
<p>在讨论「二进制」和「CPU 如何工作」之前，我们先来讨论一下我们生活中最稀疏平常的 <strong>数字</strong>，我们与之频繁地打交道：一个约定的时间、一件商品的价格、一个人的身高….却很少有人细细想过，这些数字是如何表达出来的？为什么你理所当然地把 <code>1024</code> 理解为「一千零二十四」而不是别的含义？</p>
<p>也许你从未想过，在这简单的记数中，沉淀着人类的大智慧。</p>
<h2 id="一进制计数法"><a href="#一进制计数法" class="headerlink" title="一进制计数法"></a>一进制计数法</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-37eb3ad5f5ceb2bc.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://www.goethe.de/ins/cn/cn/kul/mag/20629923.html" target="_blank" rel="noopener">https://www.goethe.de/ins/cn/cn/kul/mag/20629923.html</a></li>
</ul>
<p>早在数字的概念产生之前，人类就学会了使用树枝、石子、贝壳等自然界随处可见的小物件表示猎物的、果实的、部落人口的数量。比如在某个角落堆上一堆石子，每打到 1 只猎物，就扔 1 颗石子进去，每吃掉 2 只猎物，就从中取走 2 颗石子。他们并不在意石子的总数，只是时不时地瞅一眼，心底大致有数。</p>
<p>其实这是一种最朴素的记数方式，数学家称之为 <strong>一进制记数法</strong>（unary numeral system）。我们把它符号化一下，比如用斜杠 <code>/</code> 来表示：</p>
<ul>
<li><code>1</code> 就是 <code>/</code>；</li>
<li><code>2</code> 就是 <code>//</code>；</li>
<li><code>4</code> 就是 <code>////</code>；</li>
</ul>
<p>好像没毛病，我们平时掰手指用的就是这种记数法，但数字一大，场面就要失控了。</p>
<h2 id="符值相加记数法"><a href="#符值相加记数法" class="headerlink" title="符值相加记数法"></a>符值相加记数法</h2><p>为了解决记录大数的问题，于是我们得发明一些其他符号来表示更大的数值，比如用横杠 <code>-</code> 表示 <code>10</code>，用十字 <code>+</code> 表示 <code>100</code>。那么：</p>
<ul>
<li><code>16</code> 就是 <code>-//////</code>;</li>
<li><code>32</code> 就是 <code>---//</code>;</li>
<li><code>128</code> 就是 <code>+--////////</code>;</li>
</ul>
<p>漂亮….这种靠符号类型和符号数量表示数字的方法被称为 <strong>符值相加记数法</strong>（sign-value notation），古埃及和古罗马用的都是它，只不过符号各不相同。</p>
<p>古埃及的记数符号：</p>
<table>
<thead>
<tr>
<th align="left">1</th>
<th align="left">10</th>
<th align="left">100</th>
<th align="left">1000</th>
<th align="left">10000</th>
<th align="left">100000</th>
<th align="left">1000000</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="https://upload-images.jianshu.io/upload_images/7896890-d2bfaae365873d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td>
<td align="left"><img src="https://upload-images.jianshu.io/upload_images/7896890-7db2e56461b8924e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td>
<td align="left"><img src="https://upload-images.jianshu.io/upload_images/7896890-c5fae91ba1ce71ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td>
<td align="left"><img src="https://upload-images.jianshu.io/upload_images/7896890-f8681a482a77520a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td>
<td align="left"><img src="https://upload-images.jianshu.io/upload_images/7896890-c757d42165bcdc28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td>
<td align="left"><img src="https://upload-images.jianshu.io/upload_images/7896890-7912e7e489139b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></td>
<td align="left"><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-4f50da2d5ab50e09.png" alt=""></td>
</tr>
</tbody></table>
<p><code>1024</code> 在古埃及就写作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-71394410027b72cf.png" alt=""></p>
<p><strong>你会发现，符值相加记数法的一大优点是，符号的顺序可以任意打乱，数字含义不受影响</strong>。我国藏族曾用石子表示 <code>1</code>、木棍表示 <code>10</code>、果核表示 <code>100</code>、蚕豆表示 <code>1000</code>、瓦片表示 <code>10000</code>，那么，当你把 <code>1</code> 颗蚕豆、<code>2</code> 根木棍和 <code>4</code> 颗石子胡乱地攥在手里，别人依然知道它们是 <code>1024</code>。</p>
<p>古罗马的做法略有不同，他们对五进制情有独钟：</p>
<table>
<thead>
<tr>
<th align="left">1</th>
<th align="left">5</th>
<th align="left">10</th>
<th align="left">50</th>
<th align="left">100</th>
<th align="left">500</th>
<th align="left">1000</th>
</tr>
</thead>
<tbody><tr>
<td align="left">I</td>
<td align="left">V</td>
<td align="left">X</td>
<td align="left">L</td>
<td align="left">C</td>
<td align="left">D</td>
<td align="left">M</td>
</tr>
</tbody></table>
<p>这些符号沿用至今，想必大家（至少对前 <code>3</code> 个）都比较熟悉，许多钟表仍保留着使用罗马数字的习惯，<code>1~12</code> 分别表示为：<code>I</code>、<code>II</code>、<code>III</code>、<code>IV</code>、<code>V</code>、<code>VI</code>、<code>VII</code>、<code>VIII</code>、<code>IX</code>、<code>X</code>、<code>XI</code>、<code>XII</code>。你会发现，罗马记数法是符值相加记数法的变种，因为它不光「相加」，还「相减」。这种方式就不允许符号乱序了，<code>IV</code> 和 <code>VI</code> 表示的是不同的数字。</p>
<p>那罗马人何苦要使用这种更复杂的记数法呢？无非是为了读写方便。同样表示 <code>9</code>，<code>IX</code> 比 <code>VIIII</code> 更简洁。</p>
<p>其实有一种更好使的方法——用另外一些列符号来表示符号的数量。比如用 <code>A</code> 表示 <code>1</code> 个符号，用 <code>B</code> 表示 <code>2</code> 个符号，以此类推，用 <code>I</code> 表示 <code>9</code> 个符号。</p>
<p>如此，上文表示 <code>256</code> 的 <code>++-----//////</code> 就可以写作 <code>B+E-F/</code>。你一定感觉莫名其妙，这种写法哪里方便了。其实中文的数字表示就是这种形式，只不过我们用得太习惯了，以至于没有发现。</p>
<p>在中文中，<code>个</code>、<code>十</code>、<code>百</code> 代替了 <code>/</code>、<code>-</code>、<code>+</code>，而 <code>一</code>、<code>二</code>、<code>三</code> 代替了 <code>A</code>、<code>B</code>、<code>C</code>。<code>256</code> 就写作 <code>二百五十六个</code>，<code>个</code> 比较累赘，我们通常把它省略了。</p>
<p>其实像日语、英语用的也同样是这种记数法，简洁、优雅。</p>
<p>美中不足的是，这种形式虽便于读写，却不便于计算。中国古人为算筹和算盘这类经典算具搭建起广阔的舞台，却没给笔算留出一席之地。想象一下，如果让你把这些汉字写在草稿纸上，列个竖式，你的内心一定非常别扭。</p>
<h2 id="位值制记数法"><a href="#位值制记数法" class="headerlink" title="位值制记数法"></a>位值制记数法</h2><p>公元5世纪，印度数学家阿耶波多（Aryabhata 476–550）创立了现在广泛使用的 <strong>位值制记数法</strong>（positional notation/place-value notation），该记数法使用的主要符号，是同为印度人发明的阿拉伯数字：<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>、<code>6</code>、<code>7</code>、<code>8</code>、<code>9</code>。</p>
<p>与符值相加记数法类比，位值制中的 <code>1</code>、<code>2</code>、<code>3</code> 代替的是 <code>A</code>、<code>B</code>、<code>C</code>，那 <code>/</code>、<code>-</code>、<code>+</code> 呢？是 <strong>靠阿拉伯数字的位置来表示的</strong>。众所周知，最右位相当于 <code>/</code>，次右位相当于 <code>-</code>。<strong>靠每个位置上的数值来表示数字，故名位值制。</strong></p>
<p>严谨的数学家用一种多项式高度概括了位值制记数法的本质，在十进制中，这个多项式是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-dfcce5601d9697db.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-963f0c31560dddc4.png" alt=""></p>
<p>这是一个 <code>n</code> 位十进制数，a<sub>i</sub> 就是第 i 位上的数值。为便于直观理解，举个 <code>1024</code> 的例子吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-efaba514c3963401.png" alt=""></p>
<p>由于我们熟悉了十进制，这样费心费力的展开可能会让你觉得好笑，但当我们把它推广到其他进制时，这个多项式的价值就体现了出来。<strong>n 位 b 进制数的位值制表示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-8be4e9f989860c24.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-c9b2417647078572.png" alt=""></p>
<p><code>1024</code> 用二进制怎么表示？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-dc93b38b42e51e50.png" alt=""></p>
<p>因此，<code>1024</code> 的二进制写作 <code>10000000000</code>。</p>
<p>除了最普遍的十进制和计算机中的二进制，常见的还有七进制（如 <code>1</code> 周 <code>7</code> 天）、十二进制（如 <code>1</code> 年 <code>12</code> 个月）、十六进制（如古代 <code>1</code> 斤 <code>16</code> 两）、六十进制（如六十甲子）等等，只要有意义，任何进制都可以为你所用。</p>
<h2 id="非标准位值制"><a href="#非标准位值制" class="headerlink" title="非标准位值制"></a>非标准位值制</h2><p>在上述的多项式中，如果 a<sub>i</sub> 或 b 的取值奇葩一点，就形成了 <strong>非标准位值制</strong>（non-standard positional numeral systems），这类记数法往往应用于专业领域，很难在日常生活中见到。比如标准位值制中的三进制 a<sub>i</sub> 的取值为 <code>0</code>、<code>1</code>、<code>2</code>，但在一种名为平衡三进制（balanced ternary）的非标准位值制中，a<sub>i</sub> 取 <code>-1</code>、<code>0</code>、<code>1</code>，苏联曾使用这种进制研发电子计算机。</p>
<h1 id="Part-2-二进制简介"><a href="#Part-2-二进制简介" class="headerlink" title="Part 2. 二进制简介"></a>Part 2. 二进制简介</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-27cff50f594a44fa.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://zhuanlan.zhihu.com/p/26743163" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26743163</a></li>
</ul>
<p>至此，你对「二进制」应该会感觉亲切了些，它只是一种数制而已，本质上与我们熟悉的十进制没有很大的差别，我们这一 Part 来稍微理解一下二进制。（至于电脑为什么使用二进制我们在下一 Part 中介绍）</p>
<h2 id="二进制的基本运算"><a href="#二进制的基本运算" class="headerlink" title="二进制的基本运算"></a>二进制的基本运算</h2><p>十进制中的那些基本运算原则，二进制中同样适用，只不过需要稍加变幻而已，下面我们分别就加、减、乘、除四则运算来介绍。</p>
<h3 id="二级制加法"><a href="#二级制加法" class="headerlink" title="二级制加法"></a>二级制加法</h3><p>根据「逢二进一」规则，二进制数加法的法则为：</p>
<pre class=" language-text"><code class="language-text">0＋0＝0
0＋1＝1＋0＝1
1＋1＝0　（进位为1） 
1＋1＋1＝1 （进位为1）</code></pre>
<p>例如：<code>1101</code> 和 <code>1011</code> 相加过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-933f183b9a4acbf8.png" alt=""></p>
<h3 id="二进制数的减法"><a href="#二进制数的减法" class="headerlink" title="二进制数的减法"></a>二进制数的减法</h3><p>根据「借一有二」的规则，二进制数减法的法则为：</p>
<pre class=" language-text"><code class="language-text">0－0＝0
1－1＝0
1－0＝1
0－1＝1 （借位为1）</code></pre>
<p>例如：<code>1101</code> 减去 <code>1011</code> 的过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-a6fede2d315e2a21.png" alt=""></p>
<h3 id="二进制的乘法"><a href="#二进制的乘法" class="headerlink" title="二进制的乘法"></a>二进制的乘法</h3><p>二进制数乘法过程可仿照十进制数乘法进行。但由于二进制数只有 <code>0</code> 或 <code>1</code> 两种可能的乘数位，导致二进制乘法更为简单。二进制数乘法的法则为：</p>
<pre class=" language-text"><code class="language-text">0×0＝0
0×1＝1×0＝0
1×1＝1</code></pre>
<p>例如：<code>1001</code> 和 <code>1010</code> 相乘的过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-dca5a2f6f8860787.png" alt=""></p>
<h3 id="二进制的除法"><a href="#二进制的除法" class="headerlink" title="二进制的除法"></a>二进制的除法</h3><p>二进制数除法与十进制数除法很类似。</p>
<p>例如：<code>100110</code> ÷ <code>110</code> 的过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-375b3b027c046f7a.png" alt=""></p>
<h2 id="二进制为什么能表示所有的数据"><a href="#二进制为什么能表示所有的数据" class="headerlink" title="二进制为什么能表示所有的数据"></a>二进制为什么能表示所有的数据</h2><p><strong>因为编码规定。</strong></p>
<p>之前我们有说到，所有保存的程序和数据在计算机中都被描述为 <strong>文件</strong>，也就是说我们能够知道当前的数据集合被期望的用途是什么，也就能够找到对应的 <strong>处理器</strong> 来正确处理当前的数据。</p>
<h3 id="例如保存文字"><a href="#例如保存文字" class="headerlink" title="例如保存文字"></a>例如保存文字</h3><p>拿文字举例，为了让一串 <code>0</code>、<code>1</code> 能够代表特定的文字，人们规定使用一个字节中的七位来表达特定的文字， 这就是大名鼎鼎 <strong>ASCII</strong> <em>(American Standard Code for Information Interchange)</em> 码，ASCll 码能够表达 <strong>2<sup>7</sup>=128</strong> 种字符(编码从 <code>0~127</code>)，对于 <code>26</code> 个英文字母和一些常用的可打印字符，这完全足够了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-df89cd6ae2e84d8a.png" alt=""></p>
<p>可是，世界文化是多元的，面对类似汉字这样的象形文字，ASCll码表用起来自然是捉襟见肘。</p>
<p>穷则思变，一个字节不行，那就两个字节，这就是大名鼎鼎的 <strong>Unicode</strong> 码，不难看出，Unicode 码有 <strong>2<sup>16</sup>=65536</strong> 种表示方式，这样就足以表达一些常用的字符了，值得一提的是，Unicode 码算是在 ASCll 码上的一种扩充,其第 <code>0~127</code> 个编码字符与 ASCll 码表一模一样。</p>
<h3 id="再比如图片"><a href="#再比如图片" class="headerlink" title="再比如图片"></a>再比如图片</h3><p>这里涉及一点点物理知识，话说很久以前，牛顿通过三棱镜把白色的光分解成七种不同颜色的光，后来又通过各种实验发现红、绿、蓝三种颜色的光是无法被分解的，因此我们就称为红蓝绿为光的三原色。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-8d9230810da43450.png" alt=""></p>
<p>至此人类已经知道了：<strong>可以通过组合不同比例的红、绿、蓝三种颜色来获得各种各样的颜色</strong>，那么我们就可以在计算机上模拟了。现在的计算机，一般使用 <code>32</code> 位来表示颜色，<code>32</code> 位平分给四个分量，也就是每个分量 <code>8</code> 位。</p>
<p><strong>为啥是四个颜色分量?</strong></p>
<p>因为颜色模型中有一个 alpha 值，用来表示透明度，这一点我们先不考虑。总之三种颜色，每个使用 <code>8</code> 位来表示的话，我们就能够表示 <code>256 * 256 * 256 = 16777216</code> 种颜色了，已经足够基础的使用了。</p>
<p>先来看一张图片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-70225ac6658d4f8f.png" alt=""></p>
<p>这张图像的尺寸是 <code>600px * 664px</code>（px 是一种图片单位，中文名称为像素，你可以暂时理解为一个点）。我们把它放大一下，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-a103e42d30efff7d.png" alt=""></p>
<p>看见了吗？实际上，大部分图像（你拍摄的照片、你扫描的图片、你使用 iPad 画的图片等等…）都是位图文件，位图就是由像素点构成的，它就像是一个网格一样，每个格子里面填一个颜色。（除了位图外，还有一种图是矢量图，它描述的是形状而非网格）</p>
<p>OK，我想你已经能理解图像是由像素点组成的了（事实上我们的显示器也是），我们只需要在编码中附带上一些额外的信息，例如图像有多大的尺寸、时间、作者、颜色深度、是否支持透明度之类的就能够对图像进行正确表示了。（视频可以简单理解成一张张连续不断的图片）</p>
<p>要让显示器正确显示图片或者视频，只需要让显示器上每个像素显示特定的颜色就好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-5f5e7ffa6fc68d6b.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://www.bbc.co.uk/bitesize/topics/zf2f9j6/articles/z2tgr82" target="_blank" rel="noopener">https://www.bbc.co.uk/bitesize/topics/zf2f9j6/articles/z2tgr82</a></li>
</ul>
<h1 id="Part-3-为什么是二进制？"><a href="#Part-3-为什么是二进制？" class="headerlink" title="Part 3. 为什么是二进制？"></a>Part 3. 为什么是二进制？</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-e00888bf0a3f657b.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://zhuanlan.zhihu.com/p/33439000" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33439000</a></li>
</ul>
<p>可为什么一定是二进制呢？使用人类习惯的十进制不好吗？</p>
<h2 id="理由一：物理上易于实现"><a href="#理由一：物理上易于实现" class="headerlink" title="理由一：物理上易于实现"></a>理由一：物理上易于实现</h2><p>计算机依靠电力工作，这也就意味着需要将数字信号映射到电信号，实现这种映射最简单的方法是：</p>
<ul>
<li>0 - 没有电（0 V）</li>
<li>1 - 有点（5 V）</li>
</ul>
<p>二进制在技术上最容易实现。这是因为具有两种 <strong>稳定状态</strong> 的物理器件很多，如门电路的导通与截止、电压的高与低等，而它们恰好可以对应表示 “1” 和 “0” 这两个数码。假如采用十进制，那么就要制造具有 <code>10</code> 种 <strong>稳定状态</strong> 的物理电路，而这是非常困难的。</p>
<h2 id="理由二：机器可靠性高"><a href="#理由二：机器可靠性高" class="headerlink" title="理由二：机器可靠性高"></a>理由二：机器可靠性高</h2><p>为什么使用更复杂的数字系统是一个问题？</p>
<p>假设我们使用三元（3 位数字）数字系统涉及计算机，如果我们具有从 <code>0 V</code> 到 <code>5 V</code> 的电压，那么我们可以进行以下的映射：</p>
<ul>
<li>0 - 0 V;</li>
<li>1 - 2.5 V;</li>
<li>2 - 5 V;</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-977dc494363f41b4.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://pmihaylov.com/intro-binary-numbers/" target="_blank" rel="noopener">https://pmihaylov.com/intro-binary-numbers/</a></li>
</ul>
<p>看起来合理吧？但是，想象一下，我以 <code>2.5 V</code> 的电压发送了一个数字。但是由于电路中的一些噪声，我在输出端得到 <code>2.3 V</code> 的电压，因此将其视为 <code>0</code>。结果是？</p>
<p>有人给我发送了 <code>1</code>，但我将其视为 <code>0</code>。数据丢失可是一个非常严重的问题。</p>
<p>使用二进制则可靠得多，由于电压的高和低、电流的有和无等都是一种 <strong>质的变化</strong>，两种物理状态稳定、分明，因此，二进制码传输的抗干扰能力强，鉴别信息的可靠性高。</p>
<h3 id="为什么计算机系统必须有时钟"><a href="#为什么计算机系统必须有时钟" class="headerlink" title="为什么计算机系统必须有时钟"></a>为什么计算机系统必须有时钟</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-c08828d17e50d517.png" alt=""></p>
<ul>
<li>图片来源：<a href="http://programmedlessons.org/Java9/chap02/ch02_11.html" target="_blank" rel="noopener">http://programmedlessons.org/Java9/chap02/ch02_11.html</a></li>
</ul>
<p>建立数字系统的目的是 <strong>仅在某些时间点测试开/关（二进制）值</strong>，这使电线（或其他设备）有时间更换。<strong>这就是计算机系统有时钟的原因。</strong></p>
<p>时钟会周期性地进行信号的测量，图中所示的 T1 和 T2 就是可以测量信号的时间点。</p>
<p>时钟利用所有这些时间点来保持同步。更快的时钟意味着每秒可以对电线进行更多次测试，并且整个系统运行得更快。<code>2 GHz</code> 处理器每秒检查二进制值 <code>20</code> 亿次。在这些时间之间，允许值改变并稳定下来。处理器芯片速度越快，每秒可以测试的次数就越多，每秒可以做出的决策就越多。</p>
<h2 id="理由三：运算规则简单"><a href="#理由三：运算规则简单" class="headerlink" title="理由三：运算规则简单"></a>理由三：运算规则简单</h2><p>数学推导已经证明，对 <code>N</code> 进制数进行算术求和或求积运算，其运算规则各有 <code>N(N+1)/2</code> 种。如采用十进制，则 <code>N=10</code>，就有 <code>55</code> 种求和或求积的运算规则；而采用二进制，则 <code>N=2</code>，仅有 <code>3</code> 种求和或求积的运算规则，以上面提到的加法为例：</p>
<pre class=" language-text"><code class="language-text">0+0=0，0+1=1 (1+0=1)，1+1=10</code></pre>
<p>因而可以大大简化运算器等物理器件的设计。</p>
<h2 id="理由四：逻辑判断方便"><a href="#理由四：逻辑判断方便" class="headerlink" title="理由四：逻辑判断方便"></a>理由四：逻辑判断方便</h2><p>采用二进制后，仅有的两个符号 “1” 和 “0” 正好可以与逻辑命题的两个值 “真” 和 “假” 相对应，能够方便地使用逻辑代数这一有力工具来分析和设计计算机的逻辑电路。</p>
<p>虽然在 1950 年代就造出了更加高效的三元计算机，但在效率和复杂度的取舍上，始终抵不过二进制。二进制仍然在当今世界中长期存在。</p>
<h1 id="Part-4-CPU-的实际工作方式"><a href="#Part-4-CPU-的实际工作方式" class="headerlink" title="Part 4. CPU 的实际工作方式"></a>Part 4. CPU 的实际工作方式</h1><p>上面我们了解到计算机以二进制的形式运行，它们只有两种状态：开（1）和关（0），为了执行二进制计算，我们需要采用一种特殊的电子元器件，称为 <strong>「晶体管」</strong>。暂时我们把它理解为一种开关吧，通电就打开，没电流通过就关闭。</p>
<h2 id="利用”开关”搭建逻辑电路"><a href="#利用”开关”搭建逻辑电路" class="headerlink" title="利用”开关”搭建逻辑电路"></a>利用”开关”搭建逻辑电路</h2><p>我们知道，给电灯通上电，它就会亮：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-4c57ef7067df1a32.png" alt=""></p>
<p>于是，结合上开关，我们就能搭建出最基础的 <strong>与门</strong> 和 <strong>或门</strong>。</p>
<h4 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-c8a7c22d1504ec72.png" alt=""></p>
<p>该电路的逻辑是：<strong>只有当 A 和 B 同时开启时，LED 灯才会亮</strong>，也就是认为输出 1，我们可以利用电信号来简单模拟一下：</p>
<table>
<thead>
<tr>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>1</strong></td>
</tr>
</tbody></table>
<h4 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-a24d55abcb73e973.png" alt=""></p>
<p>该电路的逻辑是：<strong>当 A 或者 B 开启时，LED 灯就会亮</strong>，也就是认为输出 1，我们可以利用电信号来简单模拟一下：</p>
<table>
<thead>
<tr>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">Y</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left"><strong>1</strong></td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left"><strong>1</strong></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left"><strong>1</strong></td>
</tr>
</tbody></table>
<h4 id="其他门"><a href="#其他门" class="headerlink" title="其他门"></a>其他门</h4><p>类似地，我们可以借助更多的电子元器件来创造出基础的 <code>7</code> 种逻辑门电路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-af9398c82d989eb9.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://www.zhihu.com/question/348237008/answer/843382847" target="_blank" rel="noopener">https://www.zhihu.com/question/348237008/answer/843382847</a> | @Zign</li>
</ul>
<p>这里需要特别提一下 <strong>异或门</strong>，我们需要先知道有一种电子元器件可以利用电气特性对 <strong>输入取反</strong>，也就是说输入 <code>1</code> 则输出 <code>0</code>，输入 <code>0</code> 则输出 <code>1</code>，那么我们就可以 <strong>简单模拟</strong> 出异或门逻辑电路（实际会更复杂些，这里仅展示出异或的意思）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-5a9ab9bf3e964ac4.png" alt=""></p>
<p><code>A&#39;</code> 和 <code>B&#39;</code> 分别表示 <code>A</code> 和 <code>B</code> 开关的反值，从图中我们很容易知道只有当 <code>A</code>、<code>B</code> 只存在一个输入 <code>1</code> 时，整个电路才会输出 <code>1</code>。</p>
<h2 id="利用逻辑门简单计算加法"><a href="#利用逻辑门简单计算加法" class="headerlink" title="利用逻辑门简单计算加法"></a>利用逻辑门简单计算加法</h2><p>OK，上面我们了解到我们能够利用 “开关” 来模拟逻辑的运算，我们接下来试着还原一个简单的加法运算器是如何实现的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-c86406337d2101c0.png" alt=""></p>
<p>仅需两个门，就可以完成基本的二进制加法运算。上图是利用 <code>logic.ly</code> 创建的半加法器，<code>A</code>、<code>B</code> 相当于使我们计算的两个数，最后一块相当于是我们的数显芯片，它的功能是根据输入显示数字，从上到下的引脚（也就是图中输入的地方，通常我们这样称呼）分别对应了 <strong>2<sup>0</sup>=1</strong>、<strong>2<sup>1</sup>=2</strong>、<strong>2<sup>2</sup>=4</strong>、<strong>2<sup>3</sup>=8</strong> 的输入，没有任何输入时显示为 <code>0</code>，如果 <code>引脚 1</code>（对应 <strong>2<sup>0</sup>=1</strong>）像上图一样有输入，则显示 <code>0 + 1 = 1</code>。</p>
<p>我们来理解一下上方的电路：</p>
<ul>
<li>如果仅打开一个输入，但不同时打开两个输入，则此处的 XOR 门（异或门）将打开，此时对应输入 <code>引脚 1</code>，显示 <code>数字 1</code>（类似于 <code>1 + 0 和 0 + 1</code>)；</li>
<li>如果两个输入均打开，则 AND 门(与门)将打开，此时对应输入 <code>引脚 2</code>，显示 <code>数字 2</code>（类似于 <code>1 + 1</code>）；</li>
<li>如果没有输入，则 AND 门和 XOR 门都保持关闭，此时显示 <code>数字 0</code>（类似于 <code>0 + 0</code>）；</li>
</ul>
<p>因此，如果两个都打开，则 XOR 保持关闭，并且 AND 门打开，得出正确的答案为 <code>2</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-faba821169fea5f9.png" alt=""></p>
<p>但这只是最基础的半加法运算器，不是太有用，因为它只能解决最简单的数学问题之一。但如果我们把它们两个与另一个输入连接，就会得到一个完整的加法器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-6dca746d15cf3470.png" alt=""></p>
<p>仔细思考几遍，你就会得知这个三个输入的加法器已经可以计算 <code>3</code> 个二进制数字的加法运算了，我们如法炮制，可以通过连接更多的”进位”来使这个加法器能够运算更多的数，这当然也意味着这个计算链条更长。 </p>
<p>大多数其他数学运算都可以加法完成。乘法只是重复加法，减法可以通过一些奇特的位反转来完成，而除法只是重复减法。并且，尽管所有现代计算机都具有基于硬件的解决方案以加快更复杂的操作，但从技术上讲，您可以使用完整的加法器来完成全部操作。</p>
<h2 id="总线和内存"><a href="#总线和内存" class="headerlink" title="总线和内存"></a>总线和内存</h2><p>现在，我们的计算机只不过是一个计算器，它记不住任何内容也对输出没有任何操作，上述电路只是接了一个显示单元而已。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-956374844ba7ede9.png" alt=""></p>
<p>上面展示的是一个存储单元。它使用了大量的 NAND 门，并且在实际生产中，根据存储技术的不同，它们可能会大不相同，但其功能是相同的。</p>
<p>您给它一些输入，并打开“写”位（<code>Write</code> 输入 <code>1</code>），它将把输入存储在单元内。这不仅是一个存储单元，因为我们还需要一种从中读取信息的方法。这是通过一个使能器完成的，该使能器是「存储器」中每个位的“与”门的集合，所有位都与另一个输入（即“读取”位）绑定在一起。写入和读取位通常也称为“设置”(<code>set</code>)和“启用”(<code>enable</code>)。</p>
<p>上面整个存储单元都包裹在所谓的寄存器中。这些寄存器连接到 <strong>总线</strong>，总线是围绕整个系统运行的一束电线，并连接到每个组件。即使现代计算机也具有总线，尽管它们可能具有多个总线以提高多任务处理性能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-3bce2841c2943d7d.png" alt=""></p>
<p>每个寄存器仍有一个读写位，但是在这种设置下，输入和输出是一样的。这实际上很好。例如：如果要将 R1 的内容复制到 R2，则应打开 R1 的读取位，这会将 R1 的内容压入总线。当读取位打开时，您将打开 R2 的写入位，这会将总线内容复制到 R2 中。</p>
<p>寄存器也用于制作 RAM。RAM 通常布置在网格中，并且导线有两个方向：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-6304075655ebd668.png" alt=""></p>
<p>解码器采用二进制输入并打开相应的编号线。例如，<code>11</code> 在二进制数中是 <code>3</code>，即最高的 <code>2</code> 位数字，因此解码器将打开最高的线路。每个路口都有一个寄存器。所有这些都连接到中央总线以及中央写入和读取输入。只有跨寄存器的两条导线也都打开时，读和写输入才会打开，从而有效地允许您选择要从中进行读写的寄存器。同样，现代 RAM 要复杂得多，但是此设置仍然有效。</p>
<h2 id="时钟，步进器和解码器"><a href="#时钟，步进器和解码器" class="headerlink" title="时钟，步进器和解码器"></a>时钟，步进器和解码器</h2><p>寄存器无处不在，是在 CPU 中移动数据并将信息存储在 CPU 中的基本工具。那么，是什么告诉他们移动数据的呢？</p>
<p>时钟是 CPU 核心中的第一个组件，它将按设置的时间间隔（以赫兹或每秒周期为单位）关闭和打开。这就是您看到的最直观的 CPU 速度指标。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-9328e2e8da259a45.png" alt=""></p>
<p>时钟具有三种不同的状态：基本时钟，使能时钟和设置时钟。基本时钟将打开半个周期，另一半关闭。使能时钟用于打开寄存器，并且需要更长的时间才能确保数据被使能。设置时钟必须始终与使能时钟同时打开，否则可能会写入错误的数据。</p>
<p>时钟连接到步进器，步进器将从 <code>1</code> 到最大步数进行计数，并在完成后将自身重置为 <code>1</code>。时钟还连接到 CPU 可以写入的每个寄存器的 AND 门：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-adb69d888b76aa4a.png" alt=""></p>
<p>这些 “与” 门还连接到另一个组件的输出，即指令解码器。指令解码器接受 <code>SET R2 TO R1</code> 之类的指令，并将其解码为 CPU 可以理解的内容。它有自己的内部寄存器，称为“指令寄存器”，该寄存器存储了当前操作。它的精确程度取决于您正在运行的系统，但是一旦解码，它将打开正确的设置并启用正确寄存器的位，这些寄存器将根据时钟触发。</p>
<p>程序指令存储在 RAM（或现代系统中的 L1 高速缓存，更靠近 CPU）中。由于程序数据与其他所有变量一样都存储在寄存器中，因此可以随时对其进行操作以在程序中跳转。这就是程序通过循环和 <code>if</code> 语句获取结构的方式。跳转指令将指令解码器正在读取的存储器中的当前位置设置到其他位置。</p>
<h2 id="一切如何配合"><a href="#一切如何配合" class="headerlink" title="一切如何配合"></a>一切如何配合</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-df60ac37b74140ff.png" alt=""></p>
<p>现在，我们对 CPU 工作原理的有了一些基本的了解。主总线跨越整个系统，并连接到所有寄存器。完整的加法器以及其他一系列运算都打包在算术逻辑单元或 ALU 中。该 ALU 将与总线建立连接，并且还将具有自己的寄存器来存储正在操作的第二个数字。</p>
<p>为了执行计算，将程序数据从系统 RAM 加载到控制部分。控制部分从 RAM 中读取两个数字，将第一个数字加载到 ALU 的指令寄存器中，然后将第二个数字加载到总线上。同时，它向 ALU 发送指令代码，告知其操作方法。然后，ALU 执行所有计算，并将结果存储在另一个寄存器中，CPU 可以从该寄存器中读取该值，然后继续该过程。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>原来，我们是这样记数的 - <a href="https://www.jianshu.com/p/58844323e4fb" target="_blank" rel="noopener">https://www.jianshu.com/p/58844323e4fb</a></li>
<li>二进制数的运算方法 - <a href="https://www.jianshu.com/p/560aba49c9a4" target="_blank" rel="noopener">https://www.jianshu.com/p/560aba49c9a4</a></li>
<li>文字,图片,视频,音频的二进制表示 - <a href="https://blog.csdn.net/c46550/article/details/91040925" target="_blank" rel="noopener">https://blog.csdn.net/c46550/article/details/91040925</a></li>
<li>知乎 - 计算机只认识0和1但是怎么表示图像和影视等等众多应用的？ | @kross - <a href="https://www.zhihu.com/question/36269548" target="_blank" rel="noopener">https://www.zhihu.com/question/36269548</a></li>
<li>Introduction to binary numbers - <a href="https://pmihaylov.com/intro-binary-numbers/" target="_blank" rel="noopener">https://pmihaylov.com/intro-binary-numbers/</a></li>
<li>What is Binary, and Why Do Computers Use It? - <a href="https://www.howtogeek.com/367621/what-is-binary-and-why-do-computers-use-it/" target="_blank" rel="noopener">https://www.howtogeek.com/367621/what-is-binary-and-why-do-computers-use-it/</a></li>
<li>CPU 是怎样认识代码的？ | 知乎 - <a href="https://www.zhihu.com/question/348237008/answer/843382847" target="_blank" rel="noopener">https://www.zhihu.com/question/348237008/answer/843382847</a> | @Zign</li>
<li>HTG Explains: How Does a CPU Actually Work? - <a href="https://www.howtogeek.com/367931/htg-explains-how-does-a-cpu-actually-work/" target="_blank" rel="noopener">https://www.howtogeek.com/367931/htg-explains-how-does-a-cpu-actually-work/</a></li>
</ol>
<h1 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h1><ol>
<li><a href="https://www.wmyskxz.com/2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/">「MoreThanJava」当大学选择了计算机之后应该知道的</a></li>
<li><a href="https://www.wmyskxz.com/2020/04/07/morethanjava-ji-suan-ji-fa-zhan-shi-cong-zhi-bu-ji-dao-ibm/">「MoreThanJava」计算机发展史—从织布机到IBM</a></li>
<li><a href="https://www.wmyskxz.com/2020/06/01/morethanjava-ji-suan-ji-xi-tong-gai-shu/">「MoreThanJava」计算机系统概述</a></li>
<li><a href="https://www.wmyskxz.com/2020/03/25/dong-yi-dian-python-xi-lie-kuai-su-ru-men-1/">妈妈再也不担心我面试被Redis问得脸都绿了</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8CCPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/7896890-9cbc4c6fcde7e558.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/06/01/morethanjava-ji-suan-ji-xi-tong-gai-shu/">
      「MoreThanJava」计算机系统概述
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年6月1日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-b0ce9c1dfef8c12a.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<blockquote>
<ul>
<li>计算机是由 <strong>硬件</strong> 和 <strong>软件</strong> 组件组成的复杂系统。希望通过本篇文章能够扩展和加深您对「计算机系统」的了解和认识。</li>
</ul>
</blockquote>
<h1 id="Part-1-硬件和软件"><a href="#Part-1-硬件和软件" class="headerlink" title="Part 1. 硬件和软件"></a>Part 1. 硬件和软件</h1><p>想一想《复仇者联盟》系列电影？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-315f7539244e4a25.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://new.qq.com/cmsn/20181208/20181208006498.html" target="_blank" rel="noopener">https://new.qq.com/cmsn/20181208/20181208006498.html</a></li>
</ul>
<p>当你开始想《复仇者联盟》时，通常你都不会考虑任何关于 “物理” 方面的东西，例如影片是存储在哪一种物理媒介(例如 DVD、电影胶卷)上，或者是播放影片所需的物理设备（例如 DVD 机、电影放映机）。<strong>因为一张 DVD 是有实体的物理设备，而电影本身确是一种没有实体的数据信息。</strong></p>
<p><strong>硬件</strong> 这个词通常就用于称呼那些有实体的「物理设备」，如电视机、DVD 播放器和电脑等。</p>
<p><strong>软件</strong> 则是指与 <strong>硬件</strong> 一起使用的「数据信息」，如电影、音乐、小说、网页、计算机程序等。</p>
<blockquote>
<p>「数据信息」是非常有趣的东西，你此刻正在查看的网页、浏览的视频，它们的实际数据可能存储在中国乃至世界的任何一个角落。在数据从源头的物理设备复制到你的物理设备之前，可能已经辗转复制了成几百次，最终到达浏览器并交由系统渲染，在屏幕上还原出这些数据。</p>
</blockquote>
<h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-1f2c555480dcb47e.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://zhuanlan.zhihu.com/p/33574137" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33574137</a></li>
</ul>
<p>计算机系统的主要 <strong>硬件组成</strong> 是：</p>
<ul>
<li>CPU（处理器）；</li>
<li>主要存储器（内存）；</li>
<li>辅助存储器（硬盘）；</li>
<li>输入设备（如键盘、鼠标）；</li>
<li>输出设备（如显示器）；</li>
</ul>
<p>对于典型的台式计算机来说，CPU、主存、辅存、电源加上其他支持的硬件设备（如光驱，也就是放光盘的设备）通常都是放在金属外壳中，上述的这些组件也都是连接到俗称「主板」的计算机电路板上，而各种输入输出设备则通过暴露在金属外壳背面的连接器连接。</p>
<blockquote>
<p>当然排除部分比较硬核的「搞机玩家」，如「鞋盒低成本版」：<br><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-a8a06126b86bd017.png" alt=""></p>
<p>再比如「终极水冷」：<br><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-d29363f57865bcf2.png" alt=""></p>
</blockquote>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p><strong>主板是用来连接其他硬件的「桥梁」。</strong></p>
<p>如果把电脑比作是航空母舰，那么主板就是航母主体，其他控制中心、动能装置、武器设备等都必须安装在这个航母上才能协同使用，缺一不可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-ecce2bf77411ba0f.png" alt=""></p>
<ul>
<li>图片及引用：<a href="https://www.zhihu.com/question/59272639（作者知乎：@黎小白）" target="_blank" rel="noopener">https://www.zhihu.com/question/59272639（作者知乎：@黎小白）</a></li>
</ul>
<p>我们来看一个典型的主板组成，这里只介绍一些重要常用的组件。（完整的可以参看上方图片下面的链接）</p>
<h4 id="图中-1-gt-CPU-插槽"><a href="#图中-1-gt-CPU-插槽" class="headerlink" title="图中 1 -&gt; CPU 插槽"></a>图中 1 -&gt; CPU 插槽</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-d59c70cebf40bf0d.png" alt=""></p>
<p>CPU 插槽（英语：CPU socket）是计算机里主板上固定住 CPU 并导通电气讯号的一种插槽。不同 CPU 系列使用不同插槽。</p>
<h4 id="图中-4-gt-内存插槽"><a href="#图中-4-gt-内存插槽" class="headerlink" title="图中 4 -&gt; 内存插槽"></a>图中 4 -&gt; 内存插槽</h4><p>内存插槽是指主板上用来插内存条的插槽。</p>
<p>DDR4 内存条（第四代内存条）拥有与 DDR3、DDR2 或 DDR 内存条相同的外观，但是 DDR4 内存条插槽的缺口与 DDR3、DDR2 或 DDR 内存插槽不同，以防止插入错误的内存条。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-65171f10062da1cd.png" alt=""></p>
<ul>
<li>PS：这里只展示了 ASUS X99-DELUXE 的内存安装方式，不同主板的内存安装方式可能不同，具体请按照主板说明书进行，<strong>否则系统将可能无法启动</strong>。</li>
</ul>
<h4 id="图中-5-gt-PCI-扩展插槽"><a href="#图中-5-gt-PCI-扩展插槽" class="headerlink" title="图中 5 -&gt; PCI 扩展插槽"></a>图中 5 -&gt; PCI 扩展插槽</h4><p>凡是显卡、网卡、声卡和 SCSI 卡等符合 PCI 接口规格的设备，都可以使用这些 PCI 扩展插槽。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-a4d387d1c9ead63f.png" alt=""></p>
<h4 id="图中-9-amp-10-gt-主板电源插槽"><a href="#图中-9-amp-10-gt-主板电源插槽" class="headerlink" title="图中 9&amp;10 -&gt; 主板电源插槽"></a>图中 9&amp;10 -&gt; 主板电源插槽</h4><p>这些电源插槽用来连接一个 ATX +12V 电源。24-pin 插槽用于主板供电，8-pin 插槽用于 CPU 供电。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-dd332955468f2512.png" alt=""></p>
<p>电源所提供的连接插头已经过特别设计，只能以一个特定方向插入主板上的电源插槽。找到正确的插入方向后，仅需稳稳地将之套进插槽中即可。</p>
<h4 id="图中-11-gt-后侧面板连接端口"><a href="#图中-11-gt-后侧面板连接端口" class="headerlink" title="图中 11 -&gt; 后侧面板连接端口"></a>图中 11 -&gt; 后侧面板连接端口</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-b124398dd989ff56.png" alt=""></p>
<h4 id="图中-12-gt-USB-连接插槽"><a href="#图中-12-gt-USB-连接插槽" class="headerlink" title="图中 12 -&gt; USB 连接插槽"></a>图中 12 -&gt; USB 连接插槽</h4><p>这个插槽用来连接 USB 模块，可在前面板或后侧连接端口扩展 USB 模块。</p>
<p>USB 连接插槽分为 USB 2.0 和 USB 3.0。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-5a7f81eb3c17c60f.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-44852a59b87379e5.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-0da3f8e5a7a29a25.png" alt=""></p>
<ul>
<li><strong>注意：</strong> 请勿将 1394 排线连接到 USB 2.0 插槽上，同理，也不要将 USB 2.0 排线接到 1394 插槽上，这么做可能会导致主板的损毁。</li>
</ul>
<h4 id="图中-14-gt-SATA-设备连接插槽"><a href="#图中-14-gt-SATA-设备连接插槽" class="headerlink" title="图中 14 -&gt; SATA 设备连接插槽"></a>图中 14 -&gt; SATA 设备连接插槽</h4><p>这些插槽可支持使用 Serial ATA（SATA）排线来连接 SATA 硬盘和光驱。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-7c0b1ef50f4237c2.png" alt=""></p>
<blockquote>
<p>PS：上面是一些常见的主要组成，其结构会因不同主板而又略微的不同，例如有些主板没有显示器接口（独立显卡）。</p>
</blockquote>
<h3 id="CPU（中央处理器）"><a href="#CPU（中央处理器）" class="headerlink" title="CPU（中央处理器）"></a>CPU（中央处理器）</h3><p>CPU 常常被比喻为计算机系统的 “大脑”，这非常符合。</p>
<p><strong>处理器</strong> 执行计算机系统的 <strong>所有基本计算</strong>。其他组件则是通过执行诸如 <strong>「存储数据」</strong> 或 <strong>「将数据移入和移出处理器」</strong> 之类的工作来促进计算。但是处理器是发生基本动作的地方。</p>
<p>处理器非常努力，但同时它也不那么”聪明”，它唯一要做的就是执行老板（正在运行的程序）的命令（指令），它从来不问那些命令到底是做什么，只负责执行。<strong>这也就是为什么程序和 CPU 之间存在一个称为「操作系统」的中间人的原因。</strong></p>
<ul>
<li>（Ps: 关于 CPU 其他知识我们会在之后来详细说。）</li>
</ul>
<h4 id="Hz-代表什么？"><a href="#Hz-代表什么？" class="headerlink" title="Hz 代表什么？"></a>Hz 代表什么？</h4><p>通常我们讨论 CPU 时，都会说这个 CPU 的是多少多少赫兹的，它其实 <strong>代表的就是 CPU 执行指令的速度（≈运行速度）</strong>。</p>
<p>每个 CPU 都有一个非常简单但非常重要的组件，它被称为 <strong>时钟</strong>。其唯一的目的就是 <strong>按一致的方式</strong> 来 <strong>打开</strong> 和 <strong>关闭</strong> 电信号，就像是您的心脏每秒跳动一次一样，时钟也会周期性地产生高电压信号和低电压信号。</p>
<p><code>1 Hz</code> 表示每秒 <code>1</code> 个周期，也就是每秒产生一个高压信号一个低压信号，<code>3 Ghz</code> 也就是表示每秒 <code>3</code> 千万个周期。因此，如果一条指令需要 <code>5</code> 个时钟周期才能完成，则 CPU 的时钟越快，该指令将被执行得越快。<em>（但现在 CPU 的快慢并不能简单考虑 Hz 大小，还得附加考虑”多核”和每个周期内能够完成的工作量的因素）</em></p>
<blockquote>
<p><strong>CPU 可以有多快？</strong></p>
<p>普通台式计算机可以在不到百万分之一秒的时间内执行一条指令，即使是真空中传播的光，在这段时间内也只能走 10 厘米左右，而超级计算机（在所有计算机中速度最快）可以在不到十亿分之一秒的时间内执行一条指令！</p>
</blockquote>
<h4 id="CPU-的基本要素"><a href="#CPU-的基本要素" class="headerlink" title="CPU 的基本要素"></a>CPU 的基本要素</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-075f72b01fc5a6ba.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/" target="_blank" rel="noopener">https://www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/</a></li>
</ul>
<ol>
<li><strong>寄存器：</strong> 寄存器是一个很小的地方，用于保存处理器的数据。寄存器用于存储信息，例如指令，存储地址和任何类型的数据，例如位序列或任何字符等。处理器的寄存器应足够大以存储所有给定的信息。<code>64</code> 位处理器应至少具有 <code>64</code> 位寄存器和 <code>32</code> 位处理器的 <code>2</code> 位寄存器。<strong>寄存器是所有存储设备中最快的。</strong></li>
<li><strong>L1和L2高速缓存存储器：</strong> 高速缓存存储器是一种类型的存储器，位于处理器的芯片中，或者可以通过总线单独连接。高速缓冲存储器的用途是存储程序指令，这些指令被软件一次又一次地用于操作。当 CPU 处理数据时，首先将数据查找到高速缓存中。如果找到了数据，则它将相应地使用该数据；如果未找到，则处理器开始在较大的内存中查找，这实际上是耗时的。高速缓存的成本很高，但速度确实很快。</li>
</ol>
<h4 id="CPU-如何执行程序指令-简单原理"><a href="#CPU-如何执行程序指令-简单原理" class="headerlink" title="CPU 如何执行程序指令 | 简单原理"></a>CPU 如何执行程序指令 | 简单原理</h4><p>典型的 CPU 可以简单看成由 <strong>「控制单元」</strong> 和 <strong>「逻辑单元」</strong> 组成。</p>
<p>在执行一条指令之前，必须将程序指令和数据从输入设备或辅助存储设备放入内存中，一旦必要的数据和指令存储在内存中，中央处理单元就会对 <strong>每个指令</strong> 执行以下四个步骤：</p>
<ol>
<li>「控制单元」从「存储器」中获取指令；</li>
<li>「控制单元」对指令进行解码（确定含义），并指示将必要的数据从存储器移至「逻辑单元」；</li>
<li>「逻辑单元」执行算术或逻辑指令；</li>
<li>「逻辑单元」将该运算的结果存储在存储器或寄存器中；</li>
</ol>
<p>控制单元最终指示存储器将结果释放到输出设备或辅助存储设备。这一套步骤下来就被称为 <strong>「机器周期」</strong>。单个机器周期指令可以由大量子指令组成，每个子指令必须至少占用一个时钟周期（上面提到的一个上下脉冲时间）。</p>
<p>每种类型的中央处理单元都 <strong>只能理解一组特定的指令</strong>，称为 <strong>「指令集」</strong>。正如人们可以理解许多不同的语言一样，每种不同类型的CPU都有其可以理解的指令集。</p>
<p><strong>将指令和数据存储在内存中是一回事，而控制单元能够找到它们又是另一回事。它是如何做到的？</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-d017900a2b2d2040.png" alt=""></p>
<p>每个指令和每个数据在「存储器」中的位置都有一个地址标识。也就是说，每个位置都有一个地址号码，就像公寓前面的邮箱一样。并且，与邮箱一样，位置的地址号保持不变，但是位置的内容（指令和数据）可能会更改。</p>
<p>但是，与邮箱不同，内存位置只能容纳固定数量的数据；地址只能容纳固定数量的字节-在现代计算机中通常为两个字节。</p>
<h4 id="32-位-和-64-位？"><a href="#32-位-和-64-位？" class="headerlink" title="32 位 和 64 位？"></a>32 位 和 64 位？</h4><p>您可能已经听说过 <code>N</code> 位处理器的概念。最常见的是 <code>32</code> 位和 <code>64</code> 位处理器。这些位确定传入和传出处理器的 <strong>数据量大小</strong>。具体会有以下几点不同：</p>
<blockquote>
<p><strong>一、处理数据的能力不同</strong></p>
<p><code>32</code> 位和 <code>64</code> 位表示 CPU 一次能处理的最大位数，理论上来说，<code>64</code> 位系统处理的数据效率比 <code>32</code> 位更高，相当于单车道和双车道开车似得，双车道单位时间可以有更多的车辆通行。但需要内存跟上，而且程序本身也是 <code>64</code> 位编译才能发挥 <code>64</code> 位系统的优势。</p>
</blockquote>
<blockquote>
<p><strong>二、支持的内存不同</strong>（寻址能力不同）</p>
<p>简单来说，<code>32</code> 位系统的最多能在是 <strong>2<sup>32</sup>=4294967296=4 (GB)</strong> 左右的内存里面找程序所需要的数据，而 <code>64</code> 位系统这就最大支持 <strong>128 GB</strong> 内存；</p>
</blockquote>
<blockquote>
<p><strong>三、软件兼容性不同</strong></p>
<p><code>32</code> 位系统无法运行 <code>64</code> 位软件，<code>64</code> 位系统可以安装多数 <code>32</code> 位软件，以前因为大部分软件都是基于 <code>32</code> 位架构环境下开发，所以 <code>64</code> 位系统的兼容性不如 <code>32</code> 位。但现在 <code>64</code> 位兼容性也很强了，基本都是可以兼容各类软件了，而且 <code>64</code> 位的病毒都少了很多。</p>
<p>特别是大量消耗内存的软件，如 PS，<code>64</code> 位和 <code>32</code> 位软件在 <code>64</code> 位系统里区别很大，<code>64</code> 位真的快许多。</p>
</blockquote>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="内存和硬盘的差别"><a href="#内存和硬盘的差别" class="headerlink" title="内存和硬盘的差别"></a>内存和硬盘的差别</h4><p><strong>内存</strong> 中通常放置的是您 <strong>短期存储</strong> 的数据，而 <strong>硬盘</strong> 中存放的则是 <strong>长期存储</strong> 的数据。</p>
<p>想象一下您正在办公，并且您拥有一个 <strong>办公桌</strong> 和一个 <strong>文件柜</strong>，那么此时办公桌的区域则代表了内存，文件柜则代表了硬盘。</p>
<p>刚开始工作不久，你就把需要使用的物品放置在了您的办公桌上，以便于使用，但由于桌子大小的限制，不能在桌上存放太多的东西。必须保留但不一定很快就可以访问的项目存储在文件柜中。根据文件柜的大小的不同，可以存储许多东西。</p>
<p>内存和硬盘之间的重要区别是前者在计算机关闭时会清除。另一方面，无论关闭计算机多少次，硬盘都将保持不变（除非物理破坏）。因此，类似于办公桌和文件柜，您离开办公室时在办公桌上留下的所有文件都会被丢弃。文件柜中的所有内容都将保留。</p>
<h4 id="数据如何表示？"><a href="#数据如何表示？" class="headerlink" title="数据如何表示？"></a>数据如何表示？</h4><p>在主存储器和辅助存储器中，信息都以 <strong>位(bit)</strong> 模式存储。这是一个单一的开/关值，仅开/关这两种值是可能的。（也就是俗称的「二进制」）</p>
<p>有很多方法可以实现这一点，下面我们来列举一些：</p>
<ul>
<li>机械上电器的开关（如电灯开关）；</li>
<li>电线上的高低电压；</li>
<li>单个晶体管；</li>
<li>磁盘表面的一小部分；</li>
<li>磁带表面的一小部分；</li>
<li>卡上打了一个洞；（如上一篇文章提到的制表机）</li>
<li>More..</li>
</ul>
<p>在主存储器和辅助存储器中，位的实现方式不同，但是从逻辑上讲，两种类型的存储器都存储表示为位模式的信息。</p>
<h4 id="字节-存储单位"><a href="#字节-存储单位" class="headerlink" title="字节 | 存储单位"></a>字节 | 存储单位</h4><p>一位能表示的信息太少了，以至于通常计算机内存被分成八位一组，每个八位组称为一个 <strong>字节</strong>。</p>
<p>一个字节大约足以容纳一个字符。 当某些数据需要八个以上的位时，将使用几个字节。通常，四个字节用于表示整数。</p>
<p>通常，我们需要用成千上百，甚至上亿，几十亿的字节来表示某一些数据，这样大数量的字节数我们又规定了一些单位，如下表所示：（仅列出常用单位）</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">字节数</th>
<th align="left">2 的幂</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节</td>
<td align="left">1</td>
<td align="left">2<sup>0</sup></td>
</tr>
<tr>
<td align="left">千字节(kilobyte，俗称 1 Kb)</td>
<td align="left">1024</td>
<td align="left">2<sup>10</sup></td>
</tr>
<tr>
<td align="left">兆字节(megabyte，俗称 1 Mb)</td>
<td align="left">1,048,576</td>
<td align="left">2<sup>20</sup></td>
</tr>
<tr>
<td align="left">十亿字节(gigabyte，俗称 1 Gb)</td>
<td align="left">1,073,741,824</td>
<td align="left">2<sup>30</sup></td>
</tr>
<tr>
<td align="left">万亿字节(terabyte，俗称 1 Tb)</td>
<td align="left">1,099,511,627,776</td>
<td align="left">2<sup>40</sup></td>
</tr>
</tbody></table>
<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><p>计算机系统的硬盘将字节记录在磁性表面上，就像录音带的表面一样。 数据的记录（写入）和读取使用类似于磁带的读写头完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-f247145d094e28d1.png" alt=""></p>
<ul>
<li>图片来源：<a href="http://programmedlessons.org/Java9/chap03/ch03_11.html" target="_blank" rel="noopener">http://programmedlessons.org/Java9/chap03/ch03_11.html</a></li>
</ul>
<p>上图显示了一个可移动臂末端的一个磁盘和一个读/写头。手臂沿着磁盘的半径移动。由于磁盘正在旋转，它将在磁盘上的圆形轨道中记录数据。稍后，要读取数据，必须将其移至正确的位置，然后必须等待直到旋转磁盘将数据放置到位。与录音带一样，无需更改即可读取数据。记录新数据时，它将替换以前在该位置记录的任何数据。与音频磁带不同，读/写磁头实际上并不接触磁盘，而是略高于磁盘。<em>（由于磁盘在计算机启动时一直在旋转，因此如果读写头接触到磁盘，磁盘很快就会磨损。）</em></p>
<p>通常，称为计算机系统硬盘的组件包含许多单独的磁盘和上述的读/写磁头。磁盘的两面都涂有磁性材料（因此，每个磁盘都有两个读/写磁头），并且所有磁盘都连接到一个主轴上。所有磁盘和磁头均密封在无尘的金属容器中。由于硬盘的操作涉及机械运动（比电子过程要慢得多），因此读写数据要比使用主存储器慢得多。</p>
<h4 id="文件（File）"><a href="#文件（File）" class="headerlink" title="文件（File）"></a>文件（File）</h4><p>硬盘（和其他辅助存储设备）用于长期存储大信息块，例如程序和数据集。通常，硬盘内存被组织成 <strong>文件</strong>，一个文件是已经被赋予了名称，并存储在辅助存储器的 <strong>信息集合</strong>。该信息可以是程序，也可以是数据。</p>
<p>文件中的信息表示方式与任何数字信息相同——它由位组成，通常分为八位字节。文件通常很大；它们的大小以千字节(Kb)或兆字节(Mb)为单位。</p>
<h4 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h4><p>主存储之外的大多数数据集合都组织成文件。跟踪所有这些信息是操作系统的工作之一。如果计算机是网络的一部分，那么跟踪所有计算机上的所有文件是一项艰巨的工作，并且涉及网络上的所有操作系统。</p>
<p>应用程序（包括您可能编写的程序）不会直接读取，写入，创建或删除文件。 由于操作系统必须跟踪所有内容，因此所有其他程序都要求操作系统执行文件操作任务。例如，假设某个程序刚刚计算出一组数字，则需要保存它们。以下可能发生的操作方式：</p>
<ol>
<li><p><strong>👨‍💻‍程序：</strong> 要求操作系统创建一个名称为RESULTS.DAT的文件</p>
</li>
<li><p><strong>💻操作系统：</strong> 获取请求；查找磁盘的未使用部分并创建一个空文件。程序完成时会被告知。</p>
</li>
<li><p><strong>👨‍💻‍程序：</strong> 要求操作系统将数字保存在文件中。</p>
</li>
<li><p><strong>💻操作系统：</strong> 从程序的主内存中获取数字，并将其写入文件。程序完成时会被告知。</p>
</li>
<li><p><strong>👨‍💻‍程序：</strong> 继续进行任何操作。</p>
</li>
</ol>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p><strong>就硬盘而言，所有文件都是相同的</strong>。在电子级别，包含程序的文件和包含数据的文件之间没有区别。所有文件都被命名为字节集合。当然，这些文件的用途不同。操作系统可以获取程序文件，将其复制到主内存中，然后开始运行。操作系统也可以获取数据文件，并在需要时将其信息提供给正在运行的程序。</p>
<p>然而，我们通常会看到文件名的最后一部分（扩展名）通常会显示该文件的 <strong>预期用途</strong>。例如，<code>mydata.txt</code> 的扩展名 <code>.txt</code> 意味着该文件应被用作文本（即字符）的集合，<code>program.exe</code> 扩展名 <code>.exe</code> 就标识着该文件是一个 “可执行文件”，也就是一个程序，在 Windows 中可以直接运行。</p>
<p><strong>当文件以非预期用途使用时会发生什么？例如，如果您尝试在 “.EXE” 文件上使用文字处理器，该怎么办？</strong></p>
<p>这当然会出现问题。因为 <code>.exe</code> 文件中包含的信息使用的是文字处理器无法理解的位模式表示。</p>
<p>就像遇到某人说您不懂的语言一样。他们发出的声音与您相同（大部分情况下），但是它们发出的声音（单词和句子）的模式不同。</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-cca6032f387fe6fc.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://www.aqniu.com/learn/48019.html" target="_blank" rel="noopener">https://www.aqniu.com/learn/48019.html</a></li>
</ul>
<p>计算机软件由 <strong>程序</strong> 和 <strong>数据</strong> 组成的。</p>
<p><strong>程序</strong> 包含用于处理器（CPU）的指令。<strong>数据</strong> 可以是程序需要的任何信息：字符数据，数字数据，图像数据，音频数据和无数其他类型。但是，程序和数据之间的区别并不像您想象的那么清晰。</p>
<p><strong>记住这个重要的基本思想：</strong> 程序和数据都以相同的方式被保存在计算机存储器中。也就是说在存储器中（主存储器和辅助存储器），程序和数据并无任何区别。</p>
<p>举个例子：这就像你写或者画东西在纸上一样，对于纸来说，并无什么特别的区分。</p>
<blockquote>
<p>可以使用相同的电子的存储方式来保存数据和程序对于计算机科学来说是一个重要的概念，这意味着计算机系统提供可以根据需求来将内存用于程序或数据。</p>
</blockquote>
<h3 id="程序类型"><a href="#程序类型" class="headerlink" title="程序类型"></a>程序类型</h3><p>有两类程序：应用程序、系统程序。</p>
<p><strong>应用程序</strong> 是人们用来完成工作的程序。<strong>系统程序</strong> 用来使硬件和软件平稳运行。</p>
<p><strong>重要的系统程序是操作系统</strong>。当计算机运行时，操作系统始终存在。它协调计算机系统其他硬件和软件组件的操作。操作系统负责启动应用程序，运行它们并管理它们所需的资源。当应用程序正在运行时，操作系统将为其管理硬件的详细信息。例如，当您在键盘上键入字符时，操作系统将确定它们打算用于哪个应用程序，并完成将其放置在那里的工作。</p>
<p>一些 <strong>「嵌入式系统」</strong> 不使用操作系统，而是直接在处理器上运行其程序。例如：交通灯、微波炉、洗衣机等等。</p>
<p>用于台式计算机的现代操作系统几乎都带有用户界面，该界面使用户能够通过使用窗口，按钮，菜单，图标，鼠标和键盘轻松地与应用程序（以及与操作系统本身）进行交互。例如：Unix，Linux，Android，Mac OS 和 Windows。</p>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>操作系统是一个复杂的程序，可以使计算机系统的硬件和软件组件保持协调和运行。就像一家小商店的所有者一样，他通过拜访客户，接受送货，在架子上储货，进行簿记等来保持一切井井有条。店主必须及时处理出现的任务。没有店主，商店就无法运转。</p>
<p>大多数计算机系统都可以运行多种操作系统中的任何一种。例如，大多数基于奔腾的计算机都可以运行 Linux 或 Windows 操作系统。尽管某些计算机有多个操作系统，但通常在一个计算机系统上仅安装一个操作系统。无论如何，一次只能控制一个操作系统。计算机用户可以在计算机打开时进行选择，并且操作系统将一直处于控制状态，直到计算机关闭为止。</p>
<p>首次启动计算机时，硬件会自动加载操作系统并开始运行。此过程称为 <strong>启动</strong>。之所以说这是个奇怪的术语，是因为操作系统本身参与了其自身的运行，这一过程就像某人 “自己拉自己一把” 一样。操作系统运行后，将用于启动应用程序。</p>
<h4 id="一个应用程序启动时的场景"><a href="#一个应用程序启动时的场景" class="headerlink" title="一个应用程序启动时的场景"></a>一个应用程序启动时的场景</h4><ol>
<li><p>用户要求运行应用程序。</p>
<ul>
<li>通过单击图标，选择菜单或通过其他方式可以完成此操作。</li>
</ul>
</li>
<li><p>操作系统确定应用程序的名称。</p>
</li>
<li><p>操作系统在存储应用程序及其存储数据的硬盘上找到文件。</p>
</li>
<li><p>操作系统发现主内存的未使用部分足以容纳应用程序。</p>
</li>
<li><p>操作系统在主内存的该部分中复制应用程序及其数据。</p>
<ul>
<li>硬盘上的软件未更改；主内存保存磁盘上的内容的副本。</li>
</ul>
</li>
<li><p>操作系统为应用程序申请资源。</p>
</li>
<li><p>最后，操作系统启动应用程序运行。</p>
</li>
</ol>
<p><strong>总结：</strong> 在应用程序运行时，操作系统在后台管理资源，为应用程序进行输入和输出，并使其他所有程序保持运行。</p>
<h1 id="Part-2-网络（Network）"><a href="#Part-2-网络（Network）" class="headerlink" title="Part 2. 网络（Network）"></a>Part 2. 网络（Network）</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-ce1b4b514dfac1dc.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://www.aqniu.com/learn/27008.html" target="_blank" rel="noopener">https://www.aqniu.com/learn/27008.html</a></li>
</ul>
<p>一个计算机网络由连接的两台或更多台计算机组成，以便它们可以交换数据和程序。当计算机是网络的成员时，它运行的程序和使用的数据可以位于网络上其他计算机的硬盘上。</p>
<p>在商业和工业环境中，大多数计算机都在网络上。在联网计算机上运行的操作系统必须管理其分享的网络资源（以及管理其所有其他职责）。操作系统能够找到存储在其他网络计算机上的程序和数据，并将它们复制到其自己的主内存中。</p>
<p>网络中的每台计算机都有一个网络接口卡。这是一种通过电缆发送和接收数据的输入/输出设备。网络上计算机的网络接口卡通过电缆连接在一起。</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网（LAN）是局限于相对较小区域的网络。它通常局限于地理区域，例如写作实验室，学校或建筑物。</p>
<p>每台计算机都有一个其他计算机用来访问它的网络地址。通常，计算机共享一台打印机。局域网中也可能有一台功能特别强大的计算机，称为「服务器」，其硬盘上装有其他计算机可能需要的应用程序和数据。</p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>广域网（WAN）连接较大地理区域的网络，例如四川到北京或世界各地。专用的越洋电缆或卫星上行链路可用于连接这种类型的全球网络。</p>
<p>广域网使用各种特殊的硬件来管理数据流。当两台计算机共享数据时，这些硬件使两台计算机直接连接在一起。实际上，两台计算机之间可能有数十个网络设备。但对于用户而言，使用 WAN 和 LAN 并无差别。</p>
<p>所有这些设备都 <strong>使用相同的方法来处理数据</strong>。没有通用的数据处理方法，大型网络将变得毫无希望。关于如何通过网络表示和传输数据的协议称为 <strong>「协议」</strong>。通常，大型网络使用称为 <strong>TCP / IP</strong> 的协议（用于传输控制协议/ Internet协议）。</p>
<h2 id="互联网（Internet）"><a href="#互联网（Internet）" class="headerlink" title="互联网（Internet）"></a>互联网（Internet）</h2><p>互联网包含所有连接在一起的计算机的一个庞大的全球网络。在这个庞大的网络上，<strong>每台计算机</strong> 必须具有 <strong>唯一的网络地址</strong>（称为 IP 地址），就像世界上的每部电话都具有唯一的电话号码（包括国家/地区代码和区号）一样。</p>
<p>例如这是一个典型的 IP 地址：<code>149.152.21.203</code>，IP 地址实际上是 <code>32</code> 位二进制数。联网设备使用这些地址在网络上路由信息。上面的示例显示了使用十进制数字写入这些位的标准方法（每 8 位转换成十进制并使用 <code>.</code> 隔开）。</p>
<p>但是，即使以十进制形式书写，该地址也无法被人类识别。万维网的功能之一是它允许人类使用 计算机名称而不是数字。例如：这是一个典型的计算机名称：<code>wmyskxz.com</code>。这就要容易记住的多，在 Web 浏览器中使用它时，它将自动转换为计算机 IP 地址的 <code>32</code> 个二进制数字。</p>
<h2 id="全球资讯网（World-Wide-Web）"><a href="#全球资讯网（World-Wide-Web）" class="headerlink" title="全球资讯网（World Wide Web）"></a>全球资讯网（World Wide Web）</h2><p>还记得我们上面提到的 <strong>重要思想</strong> 吗：程序和数据都以 <strong>相同的方式</strong> 保存在计算机内存中。计算机存储器（主存储器和辅助存储器）在存储程序和数据时没有区别。</p>
<p>通信设备也不区分程序和数据。就其而言，它就是所有信息，并且所有信息都以相同的方式传输。<strong>互联网就像是全球包裹递送服务</strong>。它关心的是将包裹从一个地址移到另一个地址，而不用担心包裹中的内容。</p>
<p><strong>互联网提供硬件基础，而信息传输协议服务于万维网。</strong></p>
<p>与任何数据一样，用于 Web 的数据也通过 Internet 传输。使 Web 数据与众不同的原因在于，它是针对 Web 浏览器（例如您可能正在使用的浏览器）而设计的。浏览器是一种程序，可以读取网页并以一种格式正确的方式显示它们。</p>
<p>网页是一组数据，其中包含有关如何在监视器上显示信息的信息。使用称为 <strong>超文本标记语言（HTML）</strong> 的语言来提供此信息 。如果要查看描述此页面的 HTML，您可以直接右击正在浏览的网页然后会看到「显示源代码」的选项。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Introduction to Computer Systems - <a href="http://programmedlessons.org/Java9/chap01/ch01_01.html" target="_blank" rel="noopener">http://programmedlessons.org/Java9/chap01/ch01_01.html</a></li>
<li>How does the processor work - <a href="https://pmihaylov.com/how-does-the-processor-work/" target="_blank" rel="noopener">https://pmihaylov.com/how-does-the-processor-work/</a></li>
<li>How Computers Work: The CPU and Memory - <a href="https://homepage.cs.uri.edu/faculty/wolfe/book/Readings/Reading04.htm" target="_blank" rel="noopener">https://homepage.cs.uri.edu/faculty/wolfe/book/Readings/Reading04.htm</a></li>
<li>What Is CPU (Central Processing Unit) And How It’s Work? - <a href="https://www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/" target="_blank" rel="noopener">https://www.deskdecode.com/what-is-cpu-central-processing-unit-and-how-its-work/</a></li>
<li>Computer Memory - <a href="http://programmedlessons.org/Java9/chap03/ch03_01.html" target="_blank" rel="noopener">http://programmedlessons.org/Java9/chap03/ch03_01.html</a></li>
<li>计算机原理-CPU到底有多快？内存：是我的250倍 - <a href="https://blog.csdn.net/pyf09/article/details/95256493" target="_blank" rel="noopener">https://blog.csdn.net/pyf09/article/details/95256493</a></li>
<li>电脑系统32位和64位的区别 - <a href="https://www.jianshu.com/p/d0e95bed5b60" target="_blank" rel="noopener">https://www.jianshu.com/p/d0e95bed5b60</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7896890-4016b3c2d9f38bb6.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/04/07/morethanjava-ji-suan-ji-fa-zhan-shi-cong-zhi-bu-ji-dao-ibm/">
      「MoreThanJava」计算机发展史—从织布机到IBM
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年4月7日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-e35d7d3c28cb7f92.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="一、织布机-一切的开端"><a href="#一、织布机-一切的开端" class="headerlink" title="一、织布机 | 一切的开端"></a>一、织布机 | 一切的开端</h1><p>如今代表智能现代的计算机与老式织布机的血缘关系超乎你的想象。无论是摆在写字台上的 <strong>台式机</strong>、塞在口袋里的 <strong>掌上电脑</strong>、挂在腰上的 <strong>移动电话</strong>、乃至你家中的很多 <strong>家用电器</strong>，其实都是 <code>1804</code> 年诞生的 <strong>一台织布机的后代——雅卡尔传空纸带提花机</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-72c7e7b9335fd26c.png" alt="雅卡尔的穿孔纸带提花机"></p>
<ul>
<li>图片源自：<a href="http://blog.sciencenet.cn/blog-528739-903746.html" target="_blank" rel="noopener">http://blog.sciencenet.cn/blog-528739-903746.html</a></li>
</ul>
<h2 id="织物与织布机"><a href="#织物与织布机" class="headerlink" title="织物与织布机"></a>织物与织布机</h2><h4 id="常见的织物"><a href="#常见的织物" class="headerlink" title="常见的织物"></a>常见的织物</h4><p>常见的织物有 <strong>「机织物」</strong> 和 <strong>「针织物」</strong> 两种。</p>
<p>我们平时最为熟悉的 <strong>「针织物」</strong> 借助的工具是 <strong>“针”</strong>，利用织针按照一定方向弯曲成线圈形态，然后再将线圈相互串套而形成的织物，可以横向或者纵向地进行，横向编织称为纬编织物，而纵向编织称为经编织物。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-d09b3796c5652a7a.png" alt="针织物"></p>
<p>而 <strong>「机织物」</strong> 由两条或两组以上的相互垂直的两个系统纱线或者丝线，在 <strong>织机</strong> 上按照一定规律相互交织而形成的织物叫机织物，<strong>纵向的纱线</strong> 叫 <strong>经纱</strong>，<strong>横向的纱线</strong> 叫 <strong>纬纱</strong>，基本组织有平纹、斜纹和缎纹。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-481c33adbc622475.png" alt="机织物"></p>
<h4 id="织机是如何工作和迭代的"><a href="#织机是如何工作和迭代的" class="headerlink" title="织机是如何工作和迭代的"></a>织机是如何工作和迭代的</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-95fdaccdef2889ca.png" alt=""></p>
<p>在织机上，经纱在经轴上逐根排列，根据织物纹样的要求，<strong>部分经纱被抬起</strong>，另一部分经纱则保持不动 <strong>形成织口</strong>，<strong>纬纱从织口中引入</strong>，经纱抬起的规律不同以及纱线颜色的排列变化，就会给织物带来不同的纹样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-0961b4fb28a101fd.gif" alt=""></p>
<p><strong>可是，经纱有那么多，是如何挑选出引入没根纬纱时要提起哪些经纱的呢？</strong></p>
<p>最原始的织机是手动完成的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-a3d9a4231f9aae6b.png" alt="海南省黎族老太太编织传统的毯织品。"></p>
<ul>
<li>图片引用自：<a href="https://www.sohu.com/a/301616592_99894978" target="_blank" rel="noopener">https://www.sohu.com/a/301616592_99894978</a></li>
</ul>
<p>而到了战国时期的 <strong>多综式提花织机</strong>，则发明了 <strong>综框</strong> 来完成这项工作，棕框的上下梁间有垂直排列的综丝，经纱穿入综丝中，织物纹样的变化有一个规律，也就意味着经纱是随着纬纱的引入被 <strong>有规律的循环提起</strong>，将 <strong>提起规律相同的经纱</strong> 穿入 <strong>同一个综框的综丝</strong> 中，当综框被提升时，穿入的所有经纱都会被同时提起，每一个综框都有一个脚踏板，踩下脚踏板则可通过机械装置控制其抬升：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-38d0c56843297d7e.gif" alt=""></p>
<p>不过采用综框也有一个明显的限制，那就是 <strong>无法织出比较复杂的纹样</strong>，因为纹样复杂则代表着需要更多的经纬纱以及经纱提升的规律更复杂，意味着可能引入成百上千次纬纱才能完成一个循环。</p>
<p>如果仍然采用综框控制纱线提升，则可能需要成百上千个综框，这在机械上实现是非常困难的，因此便有了 <strong>束综提花织机</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-d34ece70de4c25fe.png" alt=""></p>
<p>束综提花织机没有综框，而是被 <strong>设计成两层</strong>，每一根经纱会穿入综丝中实现 <strong>单独的控制</strong>，<strong>上层</strong> 的人将需要提起的经纱提起，而 <strong>下层</strong> 的人则再经纱提起后通过梭子将纬纱送入织口，并用打纬装置将引入的纬纱打牢。</p>
<p>然而通常来说，这类织机上会有成千上万根纬纱，纹样复杂，于是聪明的老祖宗们发明了 <strong>花本</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-d575751906c799f2.png" alt=""></p>
<p>简单来说，花本存储了纹样信息。图中花本的竖线连接穿入了经纱的综丝，横线存储了每一次引入纬纱时提花信息，当竖线越过横线覆盖在横线前方时，表明对应的经纱要被提起。</p>
<blockquote>
<p>如果还是没有理解到这个过程的话，这里有一个比较硬核的视频，教你如何手工来制作一个简易织布机：<a href="https://www.bilibili.com/video/BV1Hi4y1b7im" target="_blank" rel="noopener">戳这里</a></p>
</blockquote>
<h2 id="“识字”的机器-雅卡尔织机的诞生"><a href="#“识字”的机器-雅卡尔织机的诞生" class="headerlink" title="“识字”的机器 | 雅卡尔织机的诞生"></a>“识字”的机器 | 雅卡尔织机的诞生</h2><p>上面说到的束综提花织机虽然是一大进步，但可想而知的是，它仍然效率缓慢并且织布工人的劳动量非常大，也非常辛苦。虽然聪明的祖先们进行了很多机械化的尝试，但仍然没有取得跨越式的发展。</p>
<p>时间来到 <code>18</code> 世纪的欧洲。欧洲游历和学徒的传统，造就了许多城市独特的支柱产业，例如威尼斯的玻璃业和法国里昂的 <strong>丝织业</strong>。<code>1725</code> 年，里昂的织匠 <strong>布乔</strong> <em>(B.Bouchon)</em> 做出了开拓性的发明：他用 <strong>打孔纸带</strong> 控制经线的提起和放下，从而让织出花样成为了一种半自动的工作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-bd456560f6eff8d9.png" alt=""></p>
<p>做为一个乐器工人的儿子，布乔把家学和自己的工作结合得很好。然而，柔软的打孔纸带不能织出太宽的织物，这是它的致命伤之一；而纸带依然需要有人照看，每穿过一次纬线，纸带就需要向下移动一格。布乔提花机的最大贡献，在于实现了花纹的二进制存储——以机器能够识别的方式。<strong>历史上第一次，机器能够读出存储介质中的内容，并且照其行事。</strong></p>
<p>在布乔提出构想 <code>65</code> 后的 <code>1790</code> 年，<strong>约瑟夫·玛丽·雅卡尔</strong> 根据前人的成果设计了新式织机，不过正在此时，轰轰烈烈的法国大革命爆发了，雅卡尔也停下了手中的工作，投入到了家乡里昂的里昂保卫战中，这一拖就拖到了 <code>1805</code> 年，雅卡尔终于组装完成了首台 <strong>自动提花织机</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-a848c33d8c2fce75.png" alt="雅卡尔织机"></p>
<p>雅卡尔将 <strong>穿孔纸带</strong> 改进为 <strong>穿孔卡片</strong>，根据纹样图案在卡片上打孔，<strong>通过孔的有无</strong> 带动一系列机械运动装置来 <strong>控制经纱的提升</strong>，一张卡片对应循环内一次引纬时经纱提升的信息，引纬完成后，可通过脚踏板控制卡孔卡片转动，下一张卡片翻转至工作位置以控制新一次引纬的提花：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-1aa4e10f24c21827.gif" alt=""></p>
<p>雅卡尔织机大幅度节省了时间和工作量 <em>(全自动且效率是之前的二十五倍)</em>，而且只需一位工人，很快就被广泛使用在工厂生产中，雅卡尔也荣获了拿破仑授予的荣誉勋章。然而，迎接这位发明家的，却是失业的纺织工人迎面扔来的石头。最终导致雅卡尔客死异乡。</p>
<blockquote>
<p><strong>雅卡尔 = 贾卡</strong>。笔者在写文的时候，发现不同的资料文献中对于该织机作者的翻译会有偏差，有的叫 <strong>雅卡尔织机</strong>，有的叫 <strong>贾卡织机</strong>，但都是同一个人啦..</p>
</blockquote>
<h1 id="二、差分机-程序设计思想开始萌芽"><a href="#二、差分机-程序设计思想开始萌芽" class="headerlink" title="二、差分机 | 程序设计思想开始萌芽"></a>二、差分机 | 程序设计思想开始萌芽</h1><p><strong>穿孔卡片控制织物纹样的设计成为了程序设计思想的萌芽</strong>，为信息技术的发展开展了一条新的道路。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-6bd664ed3668b50c.png" alt=""></p>
<p>时间来到 <code>19</code> 世纪初，法国人 <strong>巴贝奇</strong> <em>(Chanles Badbbage)</em> 在贾卡织机的启发下，设计并制造了 <strong>差分机</strong>。</p>
<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><blockquote>
<p>以下内容大部分摘录自下方引用资料：<a href="https://www.jianshu.com/p/5d739419b93d" target="_blank" rel="noopener">现代计算机真正的鼻祖——超越时代的伟大思想</a></p>
</blockquote>
<p><code>18</code> 世纪末，法国政府在开创米制之后，决定在数学中统一采用十进制，竟奇葩地想把原本 <code>90</code> 度的直角划分成 <code>100</code> 度、把原本 <code>60</code> 秒的 <code>1</code> 分钟划分成 <code>100</code> 秒，尽管从现在看来这样的想法绝逼是一种倒退，但他们在当时真就实施了。这一改制带来的不光是人们在使用时直观上的别扭，原本制作好的数学用表 <em>（如三角函数表）</em> 都需要全部重制。</p>
<p>法国政府将这项丧心病狂的工程交给了 <strong>数学家普罗尼</strong>  <em>（Gaspard de Prony）<em>，普罗尼正头疼着要如何才能完成这项艰巨的任务，突然想起著名经济学家 *</em>亚当·斯密** *（Adam Smith）</em> 的那本《富国论》，他决定采用书中提出的 <strong>劳动分工</strong> 的做法，将制表的工作人员分成三组：</p>
<ul>
<li><strong>第一组</strong> 由五六名牛逼的数学家组成，他们负责制定运算中所需的公式；</li>
<li><strong>第二组</strong> 由九到十个擅长数学的人组成，他们负责计算出一些关键数据，并把第一组制定好的公式进行简化；</li>
<li><strong>第三组</strong> 由约一百名计算人员组成，他们利用第二组提供的关键数据和公式，做最简单的加减操作就能得出最终结果。</li>
</ul>
<p>第三组的工作简单到什么程度，就是他们甚至都不知道自己正在算什么玩意儿，事实上他们的文化程度大部分都不高，里头好多都是理发师、失业人员什么的。可见即便文盲都能完成的计算，在那个时代还是得依靠人力去做。</p>
<p>而为了保证用表的正确性，普罗尼要求 <strong>每个数至少算两遍</strong>，并且 <strong>要在法国的不同地点用不同的方法计算</strong>。这项劳民伤财的工程整整进行了十年才完成，然而不幸的是，<strong>最终的表里仍然有错</strong>。说到这一点，可以说，那个时代基本没有一版数学用表是完全正确的，有些版本甚至错误百出，要知道数学用表出错有时后果会很严重，比如航海表一出错就可能直接导致船毁人亡。</p>
<p><strong>巴贝奇</strong> 在了解到普罗尼的事迹后泪流满面，决心要做一套完全正确的数学用表，为达目的，他尝试了各种减少错误的手段，比如调整纸张和墨水的颜色以提高数字的识别度，直接拿现有的多个版本的表进行誊抄、比对、让不同人员反复校对，在 <code>1827</code> 年出版了一个版本，结果里头还是有错。<strong>只要是人为的就没有完美的</strong>，巴贝奇彻底跪了，他发誓要造一台机器，让机器去生产数学表。</p>
<p>这就是史上著名的 <strong>差分机</strong> 了。</p>
<h2 id="重要的差分思想"><a href="#重要的差分思想" class="headerlink" title="重要的差分思想"></a>重要的差分思想</h2><p>其实早在巴贝奇出生前，有个叫 <strong>米勒</strong> <em>（Johann Helfrich von Müller）</em> 的德国工程师就提出了差分机的思想，但仅仅是提了一下，并没有进行具体设计和制造，他最终还是把研制差分机的历史重任让给了巴贝奇。</p>
<p>之所以叫差分机这个名字，是因为它计算所使用的是帕斯卡在 <code>1654</code> 年提出的差分思想：<strong>n 次多项式的 n 次数值差分为同一常数</strong>。举个简单例子好了，对于函数 <strong>F(x) = 12x + 12</strong>，x 取自然数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-96ac031c5ffac9ce.png" alt="一次差分定义为∆F(x) = F(x+1) - F(x)"></p>
<p><strong>对于一次多项式，每个相邻的 x 所对应的 F(x) 之差都是一个常数</strong>，这个常数很明显就是 x 的系数。那么二次多项式呢？对于函数 <strong>F(x) = 15x<sup>2</sup> + 12x + 12</strong>，x 取自然数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-d43781e80d39a256.png" alt="二次差分定义为∆F2(x) = F1(x+1) - F1(x)"></p>
<p><strong>对于二次多项式，每个相邻的 x 所对应的一次差分之差仍然都是一个常数</strong>，我们可以导出这一常数的通用公式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-5dd3b237960e875d.png" alt=""></p>
<p>在上述例子中，<code>a = 15</code>，故二次差分常数 <code>2a</code> 即为 <code>30</code>。</p>
<p>差分规律是一项伟大的发现，有了差分，在计算多项式时就可以 <strong>用加法替代乘法</strong>，我们只需要算出几个初始值，后面对于任意 x 所对应的 F(x) 均可以通过加法得出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-ffaac883073ee372.png" alt=""></p>
<p>学过高数的朋友应该知道，<strong>一个函数在满足一定条件的情况下可以用多项式逼近</strong> <em>（幂级数展开）</em>，于是常用的三角函数、对数函数都可以通过多项式来计算的，而机械时期的计算设备最擅长的就是做加法，有了差分思想，巴贝奇看到差分机的前途一片光明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-4af5848f1dd487b2.png" alt="幂级数展开 - 即使现在计算机也是沿用这样的方式进行计算"></p>
<h2 id="完成一半的差分机（Difference-Engine）"><a href="#完成一半的差分机（Difference-Engine）" class="headerlink" title="完成一半的差分机（Difference Engine）"></a>完成一半的差分机（Difference Engine）</h2><p>从 <code>1812</code> 年到 <code>1822</code> 年，巴贝奇克服重重困难完成了一台可以计算六位数二次多项式的模型机，他给皇家学会的主席写信，希望政府可以出资，赞助他建造真正可用的大型差分机。政府也觉得这事儿很有意义，尤其对海军很有价值，于是在 <code>1823</code> 年拨款 <code>1500</code> 英镑，巴贝奇如鱼得水，号称只要两三年时间就能完工。</p>
<p>谁知实行起来要比想象中困难得多，那个时代的机械制造水平实在落后，差分机是十分精密的仪器，巴贝奇跑遍了欧洲都没找到多少能用的零件，于是在制造差分机之前，他还要先想着怎么制造各类零件。</p>
<p>在英国当时一个牛逼的机械师 <strong>克莱门特</strong> <em>（Joseph Clement）</em> 的帮助下，他们真的在提高机械制造方面下足了功夫，不但做出了差分机能用的零件，还培养出大批优秀的技师。本来这两人强强联合势必能把差分机做好，但是巴贝奇是个精益求精的人，经常改动设计方案，导致工程时常要返工，工作量大大增加，外加亲人的相继去世，后来又和克莱门特闹掰，到了 <code>1833</code> 年，十年都过去了，巴贝奇只做出了机器的一小部分，却已经花费了 <code>3</code> 万英镑 <em>（远超最初预算）</em>。政府对巴贝奇大失所望，终于在 <code>1842</code> 年正式宣布不再出资，到头来巴贝奇给后世留下的就只有一个半成品，以及在 <code>1839</code> 年修订好的一大堆设计图纸，现存于伦敦科学博物馆。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-0f9393f025abd4f7.png" alt="伦敦科学博物馆·差分机设计图纸&amp;半成品"></p>
<p>值得一提的是，巴贝奇做不出差分机实在不是客观原因所致，与他同时代的瑞典人 <strong>乔治·舒茨</strong> <em>（Per Georg Scheutz）</em> 就根据他的设计在 <code>1843</code> 年做出了切实能用的差分机，巴贝奇倒是提供了不少指导和帮助，也算是了却了自己一桩心愿吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-aa122f4a39fd7aa8.png" alt="乔治·舒茨和他的差分机"></p>
<p><code>150</code> 年后，为了纪念巴贝奇 <code>200</code> 年诞辰，从 <code>1989</code> 到 <code>1991</code> 年人们根据巴贝奇的设计图纸建造了第一台真正的巴贝奇差分机，机器完美运行，工程师们惊奇地发现，巴贝奇的图纸里只有极少的错误，而且这些错误八成是当时为防止图纸被盗用而刻意为之的。这台差分机被保护在伦敦科学博物馆的玻璃柜里，后来又造了一台，放在美国硅谷的计算机历史博物馆，每天由导游给参观者讲解和演示，人们得以近距离膜拜。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-76551574069fa951.png" alt="伦敦科学博物馆·史上第一台巴贝奇差分机"></p>
<h2 id="差分机的工作原理简析"><a href="#差分机的工作原理简析" class="headerlink" title="差分机的工作原理简析"></a>差分机的工作原理简析</h2><p>在巴贝奇 <code>1839</code> 年的设计中，差分机可以支持七次多项式的计算。由于每次参与计算的都是函数值和 1~7 次差分值的最新值，于是仅需响应的 <code>8</code> 个计数器。巴贝奇设计的计算器由 <code>31</code> 个计数轮垂直叠加而成，即支持 <code>31</code> 位十进制数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-51570ca62e27c868.png" alt=""></p>
<p>加上传动装置和进位装置，就成了这样一幅丧心病狂的样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-de4a0dfde8a07622.png" alt=""></p>
<p>巴贝奇使用梯形的传动轮实现两个计数轮之间的相加，由于有梯形齿，传动轮可以同时带动两个计数轮，也可以只带动一个。于是在进行两数相加时，传动轮先顺时针旋转，将右侧计数轮上的数字加到左侧轮上，而后上升一段距离，逆时针旋转相同度数，将右侧计数轮的示数还原到原来的位置。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-8612e1ae802b8c45.gif" alt=""></p>
<p>仔细观察可以发现，这两个轮子上的数字排列顺序是相反的。在两轮相加的过程中，左侧轮作为累加轮朝数值增大的方向旋转，而右侧轮作为加数轮则朝数值减少方向旋转。在巴贝奇改进的并行差分算法中，两个步骤交替进行，同一个计数轮需要交替充当累加轮和加数轮的角色，于是当机器运行起来，这些齿轮需要正反方向交替旋转。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-0dfe223c50520813.gif" alt=""></p>
<p><strong>差分机的进位机构比较复杂</strong>，简单地说，每个计数轮都有一个针对高位的 <strong>“进位提示器”</strong>，当计数轮从 <code>9</code> 转到 <code>0</code>，其对应的 <strong>“进位提示器”</strong> 就被拨到 <strong>“需要进位”</strong> 的状态，每次计算，计数轮都要转动两次，第一次是每位数相加，第二次是按照“进位提示器”进行进位。我们直观地感受一下连续进位是什么样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-bf16b69710fd8b72.gif" alt=""></p>
<p>最后我们来欣赏一下差分机整个运行起来的样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-d768f67672d25643.gif" alt=""></p>
<p>还有另外一个适用乐高还原的硬核版本：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-6270f64576778e99.gif" alt=""></p>
<blockquote>
<p>如果对这一部分感兴趣的童鞋请进一步阅读原版文章：<a href="https://www.jianshu.com/p/5d739419b93d" target="_blank" rel="noopener">现代计算机真正的鼻祖——超越时代的伟大思想</a></p>
</blockquote>
<h1 id="三、分析机-第一台真正意义上的-Computer"><a href="#三、分析机-第一台真正意义上的-Computer" class="headerlink" title="三、分析机 | 第一台真正意义上的 Computer"></a>三、分析机 | 第一台真正意义上的 Computer</h1><p>尽管没能亲手实现差分机，但巴贝奇并不会气馁，或者说他本来就是根本停不下来的那种人。明知实现不了，巴贝奇仍在一刻不停地改进着自己的设计，直到有一天，他构思出了一种空前的机器——分析机，正式成为现代计算机史上的第一位伟大先驱。 <em>(Father of computing)</em></p>
<p><code>1834</code> 年，分析机概念诞生之际，巴贝奇自己都为之感到无比震惊。在此之前，任何一台计算机器都只能完成其被预定赋予的计算任务，要么是简单的加减乘除，要么像差分机那样只能做差分运算，它们都属于 <code>calculator</code>，而分析机才是真正的 <code>computer</code>，它不局限于特定功能，而竟然是可编程的，可以用来 <strong>计算任意函数</strong>——现代人无论如何也无法想象在一坨齿轮上写程序是怎样一种体验吧！</p>
<p>巴贝奇设计的分析机主要包括三大部分： </p>
<ol>
<li>用于存储数据的计数装置，巴贝奇称之为 <strong>“仓库”（store）</strong>，相当于现在 <strong>CPU 中的存储器</strong>，这部分是从差分机上的计数装置改进而来的，我们很容易想象它的模样；</li>
<li>专门负责四则运算的装置，巴贝奇称之为 <strong>“工厂”（mill）</strong>，相当于现在 <strong>CPU 中的运算器</strong>，这部分的结构相对复杂，巴贝奇针对乘除法还做了一些优化； </li>
<li>控制操作顺序、选择所需处理的数据和输出结果的装置，巴贝奇没有起名字，由于其呈桶状，我们可以叫它 <strong>“控制桶”</strong>，控制桶显然相当于现在 <strong>CPU 中的控制器</strong>。 </li>
</ol>
<p>以上三部分，加上巴贝奇并没有疏漏的输入输出设备，我们惊讶地发现，<strong>分析机的组成部分和现在冯·诺依曼架构所要求的五大部件一模一样！</strong> </p>
<p>巴贝奇另一大了不起的创举就是将 <strong>穿孔卡片（punched card）</strong> 引入了计算机器领域，用于控制数据输入和计算，从那时起，到第一台电子计算机诞生为止，期间几乎所有的数字计算机都使用了穿孔卡片。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-88a98d9aed673a97.png" alt="穿孔卡片的提花原理"></p>
<p>巴贝奇在一次巴黎展览会上看到了贾卡的提花机，对其印象十分深刻，由于一直在研究计算机器，自然想到可以把穿孔卡片也应用到分析机上。于是分析机中的输入数据、存储地址、运算类型都使用穿孔卡片来表示。在机器运行时，卡片上有孔和无孔的地方会导致对应的金属杆执行不同操作，可编程性由此体现。下图可以直观地展现这一原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-2594db4842db5453.gif" alt=""></p>
<p>整个分析机就是在类似这样的齿轮和拉杆作用下实现可编程运算的：先从数据卡片读入数据到存储器，再将存储器中的数据传输到运算器，运算器算完后又将数据传回存储器。</p>
<p>可惜的是，巴贝奇穷其一生也没能真正把分析机做出来，留给后世的又是一台模型机和两千多张图纸，以及这样一段遗言：</p>
<blockquote>
<p>如果一个人不因我一生的借鉴而却步，仍然一往直前制成一台本身具有全部数学分析能力的机器……那么我愿将我的声誉毫不吝啬地让给他，因为只有他能够完全理解我的种种努力以及这些努力所得成果的真正价值。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-06d4d4c8fc8d4b88.png" alt="伦敦科学博物馆·分析机设计图纸&amp;模型机"></p>
<p>可以说，巴贝奇一生的奋斗都是孤独的，在那个年代，人们看不到分析机的巨大价值和意义，有了先前差分机的失败，政府也不再愿理会分析机的想法。巴贝奇的思想超前了整整一个世纪，但庆幸的是在有生之年，依然有着三位难能可贵的支持者： </p>
<ol>
<li><p>首先是他的儿子 <strong>亨利·巴贝奇</strong> <em>（Henry Prevost Babbage）</em>，直到巴贝奇过世后，亨利也继续着分析机的建造工作，但终究也力不从心未能完成； </p>
</li>
<li><p>而后是后来成为了意大利总理的数学家 <strong>闵那布利</strong> <em>（Luigi Federico Menabrea）</em>，他在巴贝奇 <code>1840</code> 年演讲时详细记录下了分析机的思想； </p>
</li>
<li><p>最后就是著名诗人拜伦的女儿，史上大名鼎鼎的 <strong>女程序员艾达</strong> <em>（Ada Lovelace）</em>，她将闵那布利记录分析机的文章翻译成英文，巴贝奇建议她在翻译时增添一些自己的理解，结果艾达注解的长度是原文的两倍，其中针对计算伯努利数的算法被视为史上第一个计算机程序，这篇名为《关于巴贝奇先生发明的分析机简讯》的译文被视为程序设计方面的第一篇著作，而 <strong>艾达本人则成了世界上第一位程序员</strong>。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-98adb01dd7db4d4d.png" alt="艾达和她的伯努利数程序"></p>
<p>艾达几乎是那个时候唯一一个真正理解分析机的人，她不仅编写了许多可以在分析机上运行的程序，甚至还看到了巴贝奇自己都没有看到的事情——她说：分析机不光能用来计算，它应该还能用来表示其他东西，比如音乐。这是多么远大的目光啊！<strong>后来美国国防部将一种编程语言命名为 <code>Ada</code></strong>，就是为了纪念这位与巴贝奇同样具有超前思想的伟大女性。</p>
<h1 id="四、制表机-穿孔时代的到来"><a href="#四、制表机-穿孔时代的到来" class="headerlink" title="四、制表机 | 穿孔时代的到来"></a>四、制表机 | 穿孔时代的到来</h1><p>从 <code>1790</code> 年开始，美国每 <code>10</code> 进行一次人口普查。百年间，随着人口繁衍和移民的增多，从 <code>1790</code> 年的 <code>400</code> 万不到，到 <code>1880</code> 年的 <code>5000</code> 多万，人口总数呈爆炸式地增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-85d1fc8fa7c22b0f.png" alt="1790~1880 年美国人口增长曲线"></p>
<p>不像现在这个的互联网时代，人一出生，各种信息就已经电子化、登记好了，甚至还能数据挖掘，你无法想象，在那个计算设备简陋得基本只能靠手摇进行四则运算的 <code>19</code> 世纪，千万级的人口统计就已经成了当时政府的 <strong>“不能承受之重”</strong>。<code>1880</code> 年开始的第 <code>10</code> 次人口普查，历时 <code>8</code> 年才最终完成，也就是说，他们在休息两年之后就要开始第 <code>11</code> 次普查了，而这一次普查，需要的时间恐怕要超过 <code>10</code> 年，那第 <code>12</code> 次、<code>13</code> 次呢？本来就是 <code>10</code> 年一次的统计，如果每次耗时都在 <code>10</code> 年以上，这件事情就变得没有意义了。</p>
<p>这可愁煞了当时的人口调查办公室，他们决定面向全社会招标，寻求能减轻手工劳动、提高统计效率的发明。正所谓机会都是给有准备的人的，一位毕业于哥伦比亚大学的年轻人 <strong>赫尔曼·霍尔瑞斯</strong> <em>（Herman Hollerith）</em> 带着他在 <code>1884</code> 年申请的专利从众多方案中脱颖而出。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-cf061bfcfb4fecfa.png" alt=""></p>
<h2 id="制表机"><a href="#制表机" class="headerlink" title="制表机"></a>制表机</h2><p>他发明的机器叫 <strong>制表机</strong> <em>（tabulator/tabulating machine）</em>，顾名思义，就是专门用来制作数据统计表的机器。制表机主要由示数装置、穿孔机、读卡装置和分类箱组成。</p>
<p>示数装置包含 <code>4</code> 行、<code>10</code> 列共 <code>40</code> 个示数表盘，每个盘面被均匀地分成 <code>100</code> 格，并装有两根指针，和钟表十分相像，“分针” 转一圈可计 <code>100</code>，“时针” 转一圈则计 <code>10000</code>。可见，整个示数装置可以表达很庞大的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-8625118289db09b4.png" alt=""></p>
<p>制表机的工作是围绕穿孔卡片展开的：操作员先使用穿孔机制作穿孔卡片，再使用读卡装置识别卡片上的信息，机器自动完成统计并在示数表盘上实时显示结果，最后，将卡片投入分类箱的某一格中，进行分类存放，以供下次统计使用。</p>
<h2 id="穿孔卡片的应用"><a href="#穿孔卡片的应用" class="headerlink" title="穿孔卡片的应用"></a>穿孔卡片的应用</h2><p>此前的某一天，霍尔瑞斯正在火车站排队检票，目光不经意落到检票员手中咔咔直响的打孔机上。他发现，检票员会特意根据乘客的性别和年龄段，在车票的不同地方打孔。越来越多的人过检，他进一步确认了这个规律。一个灵感朝他袭来：如果有一张更大的卡，上面有更多的位置可以打孔，就可以用来表示更多的身份信息，包括国籍、人种、性别、生日等等。</p>
<p>这就是用在 <code>1890</code> 年人口普查中的穿孔卡片，一张卡片记录一个居民的信息。卡片设计长约 <code>18.73cm</code>，宽约 <code>8.26cm</code>，正好是当时一张美元纸币的尺寸，因为霍尔瑞斯直接用财政部装钱的盒子来装卡片。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-570346b25b2b4607.png" alt=""></p>
<p>卡片设有 <code>300</code> 多个孔位，与雅卡尔和巴贝奇的做法一样，靠每个孔位打孔与否来表示信息。<strong>尽管这种形式颇有几分二进制的意味，但当时的设计还远不够成熟，并没有用到二进制真正的价值</strong>。举个例子，我们现在一般用 <code>1</code> 位数据就可以表示性别，比如 <code>1</code> 表示男性，<code>0</code> 表示女性，而霍尔瑞斯在卡片上用了两个孔位，表示男性就其中一处打孔，表示女性就在另一处打孔。其实性别还凑合，表示日期时浪费得就多了，<code>12</code> 个月需要 <code>12</code> 个孔位，而常规的二进制编码只需要 <code>4</code> 位。当然，这样的局限也与制表机中简单的电路实现有关。</p>
<p>细心的读者可能发现卡片的右下角被切掉了，那不是残缺，而是为了避免放反而专门设计的，和现在的二维码只有 <code>3</code> 个角是一个道理。</p>
<p>这类实用的细节设计在穿孔机上表现得更为出色。下图为一位操作员正在使用穿孔机给卡片打孔的情景，她并不需要在卡片上吃力地搜寻孔位，而是直接对着孔距更大的操作面板打孔，一根杠杆将两者的孔位一一对应。操作面板还做成了弧形，颇有一分如今人体工程学键盘的风姿。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-6ba5887699128198.png" alt=""></p>
<p>在制表机前，穿孔卡片（或纸带）多用于存储指令而不是数据。比较有代表性的，一是雅卡尔提花机，用穿孔卡片控制经线提沉；二是自动钢琴，用穿孔纸带控制琴键压放。美剧《西部世界》中，每次故事循环的开始，都会给一个自动钢琴的特写，弹奏起看似宁静安逸、实则诡异违和的背景乐。</p>
<p>是霍尔瑞斯将穿孔卡片作为 <strong>数据存储介质</strong> 开来，并开启了一个崭新的 <strong>数据处理纪元</strong>。后来人们也把这类卡片称为霍尔瑞斯卡片，穿孔卡片和穿孔纸带作为输入输出载体，统治了计算领域整整一个世纪。</p>
<h2 id="统计原理"><a href="#统计原理" class="headerlink" title="统计原理"></a>统计原理</h2><p>打好了孔，下一步就是将卡片上的信息统计起来。读卡装置的组成如下图所示，其外形和使用方式有点类似现在的重型订书机，将卡片置于压板和底座之间，按压手柄，就完成了对这张卡片的信息读取。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-d00dd611762a4742.png" alt=""></p>
<p>原理上，通过电路通断识别卡上信息。底座中内嵌着诸多管状容器，位置与卡片孔位一一对应，容器里盛有水银，水银与导线相连。底座上方的压板中嵌着诸多金属针，同样与孔位一一对应，针的上部抵着弹簧，可以伸缩，压板的上下面由导电材料制成。<strong>这样，当把卡片放在底座上，按下压板时，卡片有孔的地方，针可以通过，与水银接触，电路接通，没孔的地方，针就被挡住</strong>。</p>
<p>这一基本原理与雅卡尔提花机类似，不难理解。重头戏是，<strong>如何将电路通断对应到所需要的统计信息呢</strong>？霍尔瑞斯在专利中给出了一个简单的例子，如下图所示。这是涉及性别、国籍和人种 <code>3</code> 项信息的统计电路图，虚线为控制电路，实线为工作电路。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-6b440bf3e1e76edf.png" alt=""></p>
<p>图顶有7根金属针，从左至右标的分别是：G（类似于总开关）、Female（女）、Male（男）、Foreign（外国籍）、Native（本国籍）、Colored（有色人种）、White（白种人）。</p>
<p>工作电路中分散着标识为 <strong>m<sup>1</sup>~m<sup>10</sup></strong> 的电磁继电器。</p>
<p>图底从右至左为标识为 <strong>M<sup>1</sup>~M<sup>6</sup></strong> 的 <code>6</code> 组电磁铁，所对应的统计信息为（为贴合穿孔的形象，我特意选择使用圆圈进行标记）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-4c1d4827e0e248a7.png" alt=""></p>
<p>以 <strong>M<sup>1</sup></strong> 为例，如果表示 Native、White 和 Male 的针同时与水银接触，接通的控制电路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-0deeb706f014bfaf.png" alt=""></p>
<p>这一示例首先展示了针 G 的作用，它把控着所有控制电路的通断，目的有二：</p>
<ol>
<li><p>在卡片上留出一个专供 G 通过的孔，以防止卡片没有放正（照样可以有部分针穿过错误的孔）而统计到错误的信息。</p>
</li>
<li><p>令 G 比其他针短，或者 G 下的水银比其他容器里少，从而确保其他针都已经接触到水银之后，G 才最终将整个电路接通。众所周知，电路通断的瞬间容易产生火花，这样的设计可以将此类元器件的损耗集中在 G 身上，便于后期维护。</p>
</li>
</ol>
<p>不得不感慨，这些发明家做设计真的特别实用、细致。</p>
<p>控制电路的接通引起图中标有橘黄色箭头的 <code>3</code> 个电磁继电器 <strong>m<sup>1</sup></strong> 、 <strong>m<sup>3</sup></strong> 和 <strong>m<sup>5</sup></strong> 闭合，进而接通 <strong>M<sup>1</sup></strong> 所在的工作电路：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-1a218e0fdff71392.png" alt=""></p>
<p>最终，通电的 <strong>M<sup>1</sup></strong> 将产生磁场，牵引相关杠杆，拨动齿轮完成计数，最终体现到示数表盘上指针的旋转。虽然霍尔瑞斯的专利中没有给出这一计数装置的具体结构，可以想象，从 <code>17</code> 世纪开始，机械计算器中的齿轮传动技术已经发展到足够成熟的水平，霍尔瑞斯无需重新设计，完全可以使用现成的装置，正如他在专利中所说的“any suitable mechanical counter”（任何合适的机械计数器都可以）。</p>
<p><strong>电磁铁不单控制着计数装置，还控制着分类箱盖子的开合</strong>。将分类箱上的电磁铁接入工作电路，每次完成计数的同时，对应格子的盖子会在电磁铁的作用下自动打开，熟练的操作员甚至不用转头去看，就可以顺手将卡片投到正确的格子里，由此完成卡片的快速分类。</p>
<p>每天工作的最后一步，就是将示数表盘上的结果誊抄下来，置零，第二天继续。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-2cd1655d6215a46a.png" alt="分类箱侧视图"></p>
<h2 id="单元记录时代"><a href="#单元记录时代" class="headerlink" title="单元记录时代"></a>单元记录时代</h2><p>在制表机的高效运转下，<code>1890</code> 年的人口普查只花了 <code>6</code> 年时间。<code>1896</code> 年，霍尔瑞斯成立制表机公司（The Tabulating Machine Company）并不断改进自己的产品，先后与英国、意大利、德国、俄罗斯、澳大利亚、加拿大、法国、挪威、美国波多黎各、古巴、菲律宾等多个国家和地区合作开展了人口普查。</p>
<p>到 <code>1914</code> 年，制表机公司每天生产的穿孔卡片多达 <code>200</code> 万张。不多久，一些竞争对手逐渐起家，历史迎来了繁荣的数据处理时代。它们的产品也不再局限于人口普查，逐渐扩展到会计、库存管理等一些同样需要跟大数据打交道的领域，这些机器作为制表机的后裔被统称为单元记录设备（unit record equipment）。</p>
<p>围绕穿孔卡片的制卡、读卡、数据处理和卡片分类是它们的标准功能，穿孔机、读卡器、分类器是它们的标准配置。这些部件的自动化程度越来越高，比如手动的读卡装置很快被自动读卡机所取代，读卡速度从每分钟 <code>100</code> 张逐步提高至每分钟 <code>2000</code> 张。随着识别精度的提高，卡片的孔距也越来越小，具有 <code>80～90</code> 列孔位的卡片成为主流，有些卡片的孔位甚至多达 <code>130</code> 列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-87b5752513fdf87c.png" alt="20 世纪典型的 80 系穿孔卡片"></p>
<p>机器的功能也逐渐强大，不再只是简单地统计穿孔数目，减法、乘法等运算能力陆续登场。<code>1928</code> 年，哥伦比亚大学的科学家们甚至用单元记录设备计算月球的运行轨迹，他们在 <code>50</code> 万张卡片上打了 <code>2000</code> 万个孔，彰显着单元记录设备的无限潜力。</p>
<p>机器的电路实现越来越复杂，但同时也越来越通用。<code>1890</code> 年所用的那台制表机的 <strong>线路是固定的，遇到新的统计任务，改造起来十分麻烦。</strong></p>
<p><code>1906</code> 年，霍尔瑞斯便引入了接插线板（plugboard）——一块布满导电孔的板卡，可通过改变导线插脚在板上的位置改变线路逻辑。试想一下，接插线板的内部已经布好了具有各种功能的线路，但它们都处在断开状态，各自连接着接插线板上的某两个孔位，像一窝嗷嗷待哺的小鸟长大着嘴巴，外部的导线就像美味的虫子，当虫子的头尾分别与小鸟的上喙和下喙接触，线路就被导通，这只小鸟就开始工作了。如此，每次使用就可以激活不同的 “小鸟”，从而完成不同的任务。<strong>这已经是一种可编程性的体现。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-446be02c4d4984e4.png" alt=""></p>
<p><code>1911</code> 年，制表机公司与另外 <code>3</code> 家公司合并成立 <strong>CTR</strong> 公司 <em>（Computing-Tabulating-Recording Company）</em>，制表机公司作为其子公司继续运营到 <code>1933</code> 年。</p>
<p><code>1924</code> 年，<strong>CTR</strong> 更名为 <strong>国际商业机器公司</strong>（<strong>I</strong>nternational <strong>B</strong>usiness <strong>M</strong>achines Corporation），就是现在大名鼎鼎的 <strong>IBM</strong> 公司。可见，在如今众多年轻的 IT 公司中，拥有百年历史的 IBM 是位当之无愧的前辈，它完整地参与和见证了整个现代计算机的发展史。IBM 保持了制表机公司在单元记录市场的龙头地位，到 <code>1955</code> 年，其每天生产的穿孔卡片多达 <code>7250</code> 万张。</p>
<p><code>1937</code> 年开始，单元记录设备逐步电子化，与电子计算机的界线渐渐模糊，并最终为后者让路。随着 <code>1976</code> 年 IBM 一型最核心的单元记录产品的停产，短暂的单元记录时代也宣告谢幕，它仿佛是电子计算时代来临前的预演和铺垫，许多设计被沿用下来，比如穿孔卡片和接插线板。</p>
<p>有趣的是，即使电子计算机逐渐普及，许多机构由于用惯了单元记录设备，迟迟不愿更换，少数机构甚至一直用到了 <code>21</code> 世纪。</p>
<blockquote>
<p>在翻阅资料的时候发现了一个特别有趣的谈计算机发展是的简书专栏，感兴趣的童鞋可以进一步去阅读：<a href="https://www.jianshu.com/nb/28009636" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.sohu.com/a/163216426_660519" target="_blank" rel="noopener">机织布、针织布和无纺布的概念介绍</a></li>
<li><a href="http://zhongxue.hujiang.com/cy/yuwen/p43333/" target="_blank" rel="noopener">从织布机到计算机</a></li>
<li><a href="https://songshuhui.net/archives/51079" target="_blank" rel="noopener">记忆传承，信息永生（四）</a></li>
<li><a href="http://blog.sciencenet.cn/blog-528739-903746.html" target="_blank" rel="noopener">织布机与计算机</a></li>
<li><a href="https://www.bilibili.com/video/BV1JE411x7eN?from=search&seid=2914951861463322720" target="_blank" rel="noopener">计算机发展的引路者——贾卡织机的前世今生</a></li>
<li><a href="https://pansci.asia/archives/92736" target="_blank" rel="noopener">布爾與電腦——《科學月刊》</a></li>
<li><a href="https://www.computerhope.com/issues/ch001335.htm" target="_blank" rel="noopener">Who is the father of the computer?</a></li>
<li><a href="https://www.jianshu.com/p/5d739419b93d" target="_blank" rel="noopener">现代计算机真正的鼻祖——超越时代的伟大思想</a></li>
<li><a href="https://www.jianshu.com/p/49f23b77dced" target="_blank" rel="noopener">制表机：穿孔时代的到来</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2%E2%80%94%E4%BB%8E%E7%BB%87%E5%B8%83%E6%9C%BA%E5%88%B0IBM/7896890-358a8b89021d5361.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/">
      「MoreThanJava」当大学选择了计算机之后应该知道的
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年4月2日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-4dfcc42f11323eb0.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="一、计算机-互联网-高薪-996？"><a href="#一、计算机-互联网-高薪-996？" class="headerlink" title="一、计算机 = 互联网 = 高薪 = 996？"></a>一、计算机 = 互联网 = 高薪 = 996？</h1><h2 id="你真的了解计算机专业吗？"><a href="#你真的了解计算机专业吗？" class="headerlink" title="你真的了解计算机专业吗？"></a>你真的了解计算机专业吗？</h2><p>不论你是自己选择的计算机专业还是家人帮你报的名，首先恭喜你！因为计算机是少数的几个 <strong>「不用拼爹」，完完全全可以凭借自己的努力就能够获得回报的专业</strong>，而且从近 20 年来看，回报还相当不错！</p>
<p>那 <strong>计算机专业</strong> 是做什么的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-1bea29656c745df0.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://mp.weixin.qq.com/s/1sb8YqFZm4yRZBzA_Zbn3g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1sb8YqFZm4yRZBzA_Zbn3g</a></li>
</ul>
<p><strong>简单来说</strong>，计算机专业是以 <strong>计算机等技术</strong> 为主要研究工具，<strong>以扩展人类的信息功能</strong> 为主要目标的一门学科。</p>
<h4 id="计算机是个大门类"><a href="#计算机是个大门类" class="headerlink" title="计算机是个大门类"></a>计算机是个大门类</h4><p>翻开本科专业目录，会发现计算机是个大类，包括计算机科学与技术、软件工程、网络工程、信息安全、物联网工程等等等好多专业。其中，最核心、最基础的专业就是 <strong>计算机科学与技术</strong>  <em>(Computer Science and Technology - CS)</em> 了，这也是各院校计算机系招生的主要专业。</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/10586245?fr=aladdin" target="_blank" rel="noopener">百度百科</a> 给出的计算机专业概念的论述是：<strong>计算机专业是指计算机硬件与软件相结合、面向系统、更偏向应用的宽口径专业</strong>。</p>
</blockquote>
<p>总之计算机是个很大的门类，不光编写应用软件的 <strong>软件工程师</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-cc837e5689795b3f.png" alt=""></p>
<p>还有制作硬件的 <strong>硬件工程师</strong>，例如我们日常使用大到手机，小刀计算器，一切物理设备的底层逻辑都是由它们负责编写的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-8de1ed62818f37b1.png" alt=""></p>
<p>还有 <strong>网络工程师</strong>，但也有黑帽子、白帽子、运维等等很多的分别：<em>(这图感觉明显比较黑和帅呢..)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-b78a90e3753c365e.png" alt=""></p>
<p><strong>and more…</strong></p>
<p>另外想说一点是，随着技术的进步和世界的复杂程度的加深，社会分工越来越细之后，大学专业也随之变得越来越细化，这些都不要紧，无论在哪一个方向 <strong>深耕</strong> 都能带来不菲的收获。<em>(即行行出状元)</em></p>
<h4 id="计算机专业都学哪些课程"><a href="#计算机专业都学哪些课程" class="headerlink" title="计算机专业都学哪些课程"></a>计算机专业都学哪些课程</h4><p>了解一门专业最快的方式就是了解它的课程。我们来看一下 <a href="https://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">网易云课堂顶尖中文大学计算机专业课程体系</a> 给出的标准的 CS 体系的课程表：<em>(链接可戳，下图课程全部免费)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-3ab257ae0073d4ff.png" alt="网易云课堂给出的计算机专业课程体系图"></p>
<p>可以看到计算机专业的课程大致分为基础课程和专业课程两类：</p>
<ul>
<li><strong>主要基础课程</strong>：高等数学、大学英语、线性代数、大学物理、概率论、离散数学等；</li>
<li><strong>主要专业课程</strong>：数据结构、C 语言程序设计、数据库原理、操作系统、计算机网络、算法分析与设计、编译原理、软件工程等；</li>
</ul>
<h2 id="“计算机热”-还能持续多久？"><a href="#“计算机热”-还能持续多久？" class="headerlink" title="“计算机热” 还能持续多久？"></a>“计算机热” 还能持续多久？</h2><p>计算机有多热门呢？看一下现在 <strong>漫天飞</strong> 的程序员培训广告就知道了，在前几年，这些地方还被英语培训占据着。<em>(关于计算机培训逐步替代英语培训这事儿，有兴趣了解更多可以 <a href="http://www.ruanyifeng.com/survivor/directions/technology-training.html" target="_blank" rel="noopener">戳这里</a>)</em></p>
<p>于是总有人担心，报选计算机的 <strong>人太多</strong>，<strong>竞争太激烈了</strong>，或者是传言说计算机行业已经 <strong>快饱和了</strong>、<strong>互联网泡沫正在酝酿</strong> 等，但实际情况是怎么样的呢？</p>
<p>我们先来看一段采访：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-e1fc794a420b0d74.png" alt=""></p>
<p>全球最大豪华车制造商戴姆勒奔驰（Daimler Benz） 的总经理在最近的一次采访中表示：</p>
<blockquote>
<p>“我们的竞争对手哪里是其他汽车公司，我们的竞争对手已经变成了特斯拉，谷歌，苹果，亚马逊等科技公司……</p>
<p>科技公司的发展让我们不安，我们面临着巨大的转变。”</p>
</blockquote>
<p>不难发现，全社会正在 <strong>信息化中加速前进</strong>，计算机和互联网已经 <strong>渗透到生活的方方面面</strong>，促使许多传统行业发生变革：</p>
<ul>
<li><p><strong>招聘</strong>：LinkedIn 的出现，正在蚕食美国4000亿美元的利润丰厚的招聘行业。</p>
</li>
<li><p><strong>零售</strong>：Amazon 的出现，让美国零售业人人自危，尤其是知名百货 Macy’s，因业绩不振已经连续关店及裁员。</p>
</li>
<li><p><strong>交通</strong>：Uber 一辆“出租车”都没有，却是全球最大的打车公司，改变交通行业的游戏规则。</p>
</li>
<li><p><strong>住宿</strong>：Airbnb 从不盖楼造宾馆，但是把目前世界最大的连锁酒店集团 Marriott 逼的不得不重新进行战略布局。</p>
</li>
<li><p><strong>医疗</strong>：人工智能医疗机器人、智能诊断、可穿戴医疗设备…新的技术给医疗行业多个领域带来发展机会。</p>
</li>
<li><p><strong>金融</strong>：金融领域也因为互联网和数据的发展，发生着剧变……一夜之间铺遍所有商家的 “扫码支付” 就是最好的例子。</p>
</li>
<li><p>就连 <strong>国防领域</strong>，也越来越以软件为基础，对科技人才的需求日趋迫切：</p>
<ul>
<li><p>软件驱动的无人机发动空袭，不再让人类飞行员面临风险；</p>
</li>
<li><p>情报机构利用软件进行大规模数据挖掘，以发现和追踪潜在的恐怖主义活动；</p>
</li>
</ul>
</li>
</ul>
<p>从某种程度上来说，计算机行业不但不会饱和，并在大口 “侵食” 其它行业！几乎所有的公司和领域，都需要计算机相关的人才！</p>
<p>有人说，未来世界将只剩下三种职业：</p>
<ol>
<li>娱乐人士；</li>
<li>Pizza 快递员；</li>
<li>程序员；</li>
</ol>
<p>不过，基于现在的发展来看，娱乐可以被 VR／AR 渗透，Pizza 快递会由送餐机器人完成，而世界最终需要的，就是程序员。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-f2affd1192354c41.png" alt=""></p>
<h2 id="对程序员的认识"><a href="#对程序员的认识" class="headerlink" title="对程序员的认识"></a>对程序员的认识</h2><h4 id="高薪是真的，996-也是真的"><a href="#高薪是真的，996-也是真的" class="headerlink" title="高薪是真的，996 也是真的"></a>高薪是真的，996 也是真的</h4><p>工作 996，生病 ICU（重症监护病房）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-f33e253bbf80012f.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://36kr.com/p/5191849" target="_blank" rel="noopener">https://36kr.com/p/5191849</a></li>
</ul>
<p>诚然，程序员的薪资水平普遍都要率高于其他一些传统行业：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-580a432ce4a64e81.png" alt=""></p>
<ul>
<li>图片引用自：<a href="http://www.emuban.com/article/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc%2FaW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTg0NTg0ODA0NTk2JmRpPWZiNWZjMWE5NjRkMzQ2MDVmZmFkMTY2ZmI4ZDU5ODU3JmltZ3R5cGU9MCZzcmM9aHR0cCUzQSUyRiUyRnBpYy5kaW5nZGFuZ3lpeGlhLmNuJTJGcGljJTJGMjAxODA4MTklMkYyMDE4MDYxOTEzMjU0NjQyMS5qcGdAQOWNgeWkp%2BmrmOiWquihjOS4mizorqHnrpfmnLrkuJPkuJrljaDmja7ljYrlo4HmsZ%2FlsbFAQDIwMTjorqHnrpfmnLrkuJPkuJrkuI7lhbbku5bkuJPkuJrlr7nmr5Torr7orqE%3D.html" target="_blank" rel="noopener">设计资源网</a></li>
</ul>
<p><strong>但高薪的同时，也意味着高投入</strong>。</p>
<p>中国的信息技术产业，特别是过去十多年崛起的一些大型互联网公司，他们的重点主要还是在对技术应用的开发上。过去十多年来，中国互联网产业的发展所提供的机会，使得业界认识到：投入到应用中的收益，显然比基础研究的收益更大。</p>
<p>随着这些基础的开源技术开发工具的进步，中国的程序员的入行门槛也越来越低，这和市场对程序员的需求数量越来越多这一趋势又是匹配的。随着资本参与互联网的大战，“快” 成为互联网行业的共识。其实由于开源生态的存在，技术开发如今本身已经快得不能再快了，但市场竞争是残酷的，没有最快只有更快。</p>
<p>这就产生了一个矛盾：产业迅速膨胀，从业人员的水分也越来越高，但市场对公司的效率要求也越来越高。<strong>在这种态势下，技术应用方面的研发，很容易落入劳动密集型的实质当中</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-4ecd8972692d4cc2.png" alt=""></p>
<p>难怪如今程序员往往自嘲为 <strong>“码农”</strong>，意思是 <strong>“写代码的农民工”</strong>。程序员褪去了 “智力劳动者” 的光环，似乎成为了和车间工人没太大区别的工种：无论是从工作的复杂程度来看，还是工作时长对工作的产出来看，都越来越接近了。</p>
<blockquote>
<p>当然，把程序员和传统的产业工人做类比其实并不完全正确，这主要是因为：脑力劳动，或者说智力和知识，在信息技术开发的工作中起的作用太大了。</p>
</blockquote>
<h4 id="程序员的「行业偏见」"><a href="#程序员的「行业偏见」" class="headerlink" title="程序员的「行业偏见」"></a>程序员的「行业偏见」</h4><p>在极光大数据的 <code>2018</code> 年中国程序员研究报告里，对于 <strong>「外行对你的职业最大的误解是什么」</strong> 的这个问题，有 <code>46.1%</code> 的程序员选择了 <em>“很会修电脑”</em>，<code>42.7%</code> 的人选择了 <em>“可以轻易开发出任何软件”</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-55b543f52c7022bf.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://www.pingwest.com/a/160607" target="_blank" rel="noopener">https://www.pingwest.com/a/160607</a></li>
</ul>
<p>每个行业都存在各自的行业偏见，例如遇到健身教练就想让人帮你 <code>3</code> 天瘦 <code>10</code> 斤，还得不打针、不吃药、不节食、不运动。这些偏见都无可厚非，重要的是你怎么看待这事儿，是选择被贴标签就靠近标签，还是选择做自己。</p>
<h2 id="什么样的人适合学习计算机？"><a href="#什么样的人适合学习计算机？" class="headerlink" title="什么样的人适合学习计算机？"></a>什么样的人适合学习计算机？</h2><p>4 点吧：<strong>兴趣</strong>、<strong>逻辑</strong>、<strong>就业</strong>、<strong>静下来学习</strong>。</p>
<h4 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h4><p>计算机行业的 <strong>知识迭代</strong> 相比其他行业来说速度要 <strong>快</strong> 上不少，加之市场对程序员的 <strong>要求</strong> 也越来越 <strong>高</strong>，这就要求了程序员需要更多的时间来学习。而说到底，计算机是一个偏实践性的理论知识学科，你不仅需要 <strong>花费大量的时间学习</strong> 枯燥的基础的理论知识，还需要再画 <strong>大量时间去动手实践</strong> 最终将这些知识 <strong>融会贯通</strong> 起来，这个过程可能略显枯燥和冗长，而 <strong>兴趣会帮助你跨过不少的无趣</strong>。</p>
<p>在 <a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与漫画》</a> 一书中有这样一段描述：</p>
<blockquote>
<p>在达·芬奇的年代，绘画并不是一件很酷的事情，达·芬奇用自己的工作推动绘画成为一种伟大的表达方式。同样，编程到底能够有多酷，取决于我们能够用这种新媒介做出怎样的工作。</p>
</blockquote>
<p><strong>「兴趣是最好的老师」</strong> 这句话再怎么吹也不为过，你对一件事情的兴趣和热爱，在很大程度上决定了你做一件事情所取得的成绩。</p>
<p>看到有网友调侃：”给我妈买的智能洗衣机教了 n 遍都不会用，后来给她买了台麻将机，不仅会用还会修呢。”</p>
<p>还看到有网友吐槽说：「也可以先结婚后恋爱的..」，这… 你们自己品吧…</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-6b3135e795c9d775.png" alt=""></p>
<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>现代的计算机还没有足够的「聪明」，当你实现一些东西和想法的时候，需要考虑 <strong>「足够多」</strong> 的细节，这就涉及到 <strong>「逻辑思考，讲求因果」</strong> 的能力了。</p>
<p>这事儿我在 <a href="https://www.zhihu.com/question/22508677/answer/141334678" target="_blank" rel="noopener">「知乎讨论 - 编程到底难在哪里？」</a> 看到了许多有趣生动的例子，这里我们截取一个关于 <strong>「树上有十只鸟，开枪打死一只，还剩几只?」</strong> 问题的讨论来论述：<em>(例子略长.. 不感兴趣的读者可以跳过..)</em></p>
<blockquote>
<p>某日，老师在课堂上想考考学生们的智商，就问一个男孩: “树上有十只鸟，开枪打死一只，还剩几只?”　　</p>
<ul>
<li>🙋‍♂️:“是无声手枪，还是其他没有声音的枪么?”　　</li>
<li>“不是.”　　</li>
<li>🙋‍♂️：“枪声有多大?”　　</li>
<li>“80~100 分贝.”　</li>
<li>🙋‍♂️：“那就是说会震的耳朵疼?”　　</li>
<li>“是.”　　</li>
<li>🙋‍♂️：“在这个城市里打鸟犯不犯法?”　　</li>
<li>“不犯.”　　</li>
<li>🙋‍♂️：“您确定那只鸟真的被打死啦?”　　</li>
<li>“确定.” (老师已经不耐烦了)，”拜托，你告诉我还剩几只就行了,OK?”　　</li>
<li>🙋‍♂️：“OK.鸟里有没有聋子?”　　</li>
<li>“没有.”　　</li>
<li>🙋‍♂️：“有没有鸟智力有问题，呆傻到听到枪响不知道飞的?”　　</li>
<li>“没有，智商都在 200 以上!”　　</li>
<li>🙋‍♂️：“有没有关在笼子里的?”　　</li>
<li>“没有.”　　</li>
<li>🙋‍♂️：“边上还有没有其他的树，树上还有没有其他鸟?”　　</li>
<li>“没有.” </li>
<li>🙋‍♂️：“方圆十里呢?” </li>
<li>“就这么一棵树!”　　</li>
<li>🙋‍♂️：“有没有残疾或饿的飞不动的鸟?”　　</li>
<li>“没有，都身体倍棒.”　　</li>
<li>🙋‍♂️：“算不算怀孕肚子里的小鸟?”　　</li>
<li>“都是公的.”　　</li>
<li>🙋‍♂️：“都不可能怀孕?”　　</li>
<li>“………，决不可能.”　　</li>
<li>🙋‍♂️：“打鸟的人眼里有没有花?保证是十只?”　　</li>
<li>“没有花，就十只.” 老师脑门上的汗已经流下来了，　　</li>
<li>🙋‍♂️：“有没有傻的不怕死的?”　　</li>
<li>“都怕死.”　　</li>
<li>🙋‍♂️：“有没有因为情侣被打中，自己留下来的?”　　</li>
<li>“笨蛋，之前不是说都是公的嘛!”　　</li>
<li>🙋‍♂️：“同性恋可不可以啊？”　　</li>
<li>“………….，性取向都很正常!”　　</li>
<li>🙋‍♂️：“会不会一枪打死两只?”　　</li>
<li>“不会.”　　</li>
<li>🙋‍♂️：“一枪打死三只呢?”　　</li>
<li>“不会.”　　</li>
<li>🙋‍♂️：“四只呢?”　　</li>
<li>“更不会!”　　</li>
<li>🙋‍♂️：“五只呢?”　　</li>
<li>“绝对不会!!!”　　</li>
<li>🙋‍♂️：“那六只总有可能吧?”　　</li>
<li>“除非你他妈的是猪生的才有可能!一枪只能打死一只!”　　</li>
<li>🙋‍♂️：“…好吧，那么所有的鸟都可以自由活动么?”　　</li>
<li>“完全可以.”　　</li>
<li>🙋‍♂️：“它们受到惊吓起飞时会不会惊慌失措而互相撞上?”</li>
<li>“不会，每只鸟都装有卫星导航系统，而且可以自动飞行.”</li>
<li>🙋‍♂️：“恩，如果您的回答没有骗人，” <strong>学生满怀信心的回答，“打死的鸟要是挂在树上没掉下来，那么就剩一只，如果掉下来，就一只不剩.”</strong></li>
<li>老师推推眼镜，强忍着要昏倒的感觉，颤抖地说道：<strong>“你可以去当程序员了……”</strong></li>
</ul>
</blockquote>
<h4 id="静下来学习"><a href="#静下来学习" class="headerlink" title="静下来学习"></a>静下来学习</h4><p><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与漫画》</a> 一书中有描述说：</p>
<blockquote>
<p>程序员因为常常埋头于编程，而没有更多的时间精力去与学习如何与别人相处。这常常导致他们看起来有点“呆”——就像书呆子经常只和书打交道一样，程序员大部分时间只对着计算机屏幕。</p>
</blockquote>
<p>这也从侧面反映出了编程这件事的特点。我们需要 <strong>「静下来沉淀学习」</strong> 的能力，如果你渴望几个月速成，或者不想学习新技术，指望二十来岁拿一个学位证，可以吃到退休，那么你就不太适合计算机行业。</p>
<h1 id="二、对「大学」了解多一些"><a href="#二、对「大学」了解多一些" class="headerlink" title="二、对「大学」了解多一些"></a>二、对「大学」了解多一些</h1><h2 id="为什么你可以不读大学？"><a href="#为什么你可以不读大学？" class="headerlink" title="为什么你可以不读大学？"></a>为什么你可以不读大学？</h2><p>可不要被这个标题吓到，读书，念大学仍然是当今社会下的主流选择，这里只是借 <a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a> 大大的文章来提供一种 <strong>全新的视角</strong>，我相信读者会跟我一样，看完会带来一定思考的。</p>
<blockquote>
<p>以下内容均引用自：<a href="http://www.ruanyifeng.com/survivor/collapse/university.html" target="_blank" rel="noopener">为什么你可以不读大学 | 阮一峰</a></p>
</blockquote>
<h4 id="什么知识才是有用的知识？"><a href="#什么知识才是有用的知识？" class="headerlink" title="什么知识才是有用的知识？"></a>什么知识才是有用的知识？</h4><p>在 <strong>农业社会</strong>，上一代人的知识可以一成不变地用在下一代。而在信息社会，前几年的知识，再过几年就不能用了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-df4149f6f9ce0641.png" alt=""></p>
<p>举例来说，眼下就业前景最好的行业，我觉得有两个：区块链和 VR。它们在五年前都是不存在的，那时就业最好的是苹果 iOS 系统的应用开发，可是再往前推五年，它也是不存在的。伴随着它们的是，很多旧工作岗位的消失，比如塞班、黑莓、Windows Phone 的开发。</p>
<p>这种情况下，大学应该教什么，我们根本不知道。学生毕业后的行业，现在根本还没有出现。因此，大学只能重点教 <strong>基础类课程</strong>，而且各个方向都必须教到，因为不知道学生将来会用到哪个方向的东西。这样就会耗费大量的时间，学习专业的各种基础知识，其中许多对人生来说是没用的。学生常常感叹：<strong>「考试一结束，有些课程这辈子再没有用到的机会了」</strong>。</p>
<p>更糟糕的是，学生的培养计划，都是一些二三十年前毕业、然后一直待在大学里、与社会生产实践脱节的人制定的。他们的知识和思维早已过时了。这样的人指定你应该学习的知识，很可能在你学的时候就已经过时了。</p>
<h4 id="大学的四年时间"><a href="#大学的四年时间" class="headerlink" title="大学的四年时间"></a>大学的四年时间</h4><p>退一步说，就算你在大学里能学到了真正的知识，那也不应该在那里待四年。如果只学最需要学习的东西，一年就够了。</p>
<p><strong>四年时间足以让一个人在任何领域成为资深业者，甚至专家</strong>。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-47b3674a9ab934df.png" alt=""></p>
<p><code>18</code> 岁是人生最有热情和精力投入一项事业的时候，但是，大学将你一连四年关在教室和图书馆里，把考试和绩点伪装成你奋斗的目标，人为将你与真实世界隔离，引导你去关注那些对未来人生毫不重要的事情。经过这样四年的歧途，等你真正走上社会、要跟全世界竞争的时候，你的竞争力不是变强了，而是变弱了。换句话说，四年制大学很可能是削弱你，而不是让你变得更强。</p>
<p><code>2014</code> 年诺贝尔物理学奖得主中村修二，就曾经写过一篇长文，名字就叫 <a href="https://www.jiemian.com/article/887630.html" target="_blank" rel="noopener">《东亚教育浪费了太多的生命》</a>。</p>
<p>我们时代的很多成功者—-乔布斯、比尔盖茨、扎克伯格等等—-都是退学生，这绝不是偶然的。不是他们在大学待不下去，而是他们发现，没必要在那个地方待四年。如果他们咬着牙忍受下去，熬到拿到文凭的那一天，苹果公司和微软公司可能都不会有了。</p>
<h4 id="不是说知识无用"><a href="#不是说知识无用" class="headerlink" title="不是说知识无用"></a>不是说知识无用</h4><p>注意，我不是说知识无用，而是说知识（尤其是非学术的知识）不一定要通过大学获得，通过互联网一样可以接受高等教育，而且更高效和便宜。</p>
<p><strong>技术已经成为人类社会发展的主导性力量，学习和教育变得比以往更重要、更关键</strong>。但是很不幸，我们的学习和教育制度已经完全过时，传授的知识有用的少，没用的多；传授方法仍然依靠灌输和记忆，而不是启发和理解，极其低效，浪费学生的时间，打击学习热情，磨灭对知识的兴趣；对年轻人的成长，正面影响少，负面影响大，而且看不到改变的希望。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-de5a1eeab222f95b.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://zhuanlan.zhihu.com/p/54933216" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54933216</a></li>
</ul>
<p>以前，人生的选择很少，你不得不去读大学，因为没有其他地方可以接受高等教育。社会还把很多机会与文凭挂钩，先有文凭，然后才能有就业、职称、住房等等。</p>
<p>但是，时代已经变了，文凭正变得越来越不重要。那些与文凭挂钩的东西，正在一项项脱钩。</p>
<p>互联网将教育的自主权，交到了每个人自己手里。上什么课程、什么时间上，都完全由你决定。你可以一边工作，一边利用夜晚和周末，学习网络课程。这样的话，不仅早早就会有收入，而且只学那些对自己最有用、最感兴趣的内容，学习的效率很高。如果发现对学术有兴趣，将来再回大学，攻读更高的学位，也是完全可以的。</p>
<p><strong>大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程”画地为牢“限制住。你要主动去接触和学习，那些自己感兴趣的东西</strong>。引用一个网友的话，“你要做的就是自主、跨界、终身学习“。</p>
<h2 id="中国大学的教育理念"><a href="#中国大学的教育理念" class="headerlink" title="中国大学的教育理念"></a>中国大学的教育理念</h2><p>在吴军老师 <a href="https://book.douban.com/subject/26584286/" target="_blank" rel="noopener">《大学之路》</a> 中介绍了大学的基本教育理念有两种：</p>
<ol>
<li><strong>纽曼的教育理念</strong>：倡导通才教育，本科阶段讲求知识面的广阔，要求更多的课外活动，而不要求专业的深度，专业的深造放到大四或者研究生阶段。具体像是哈佛大学，耶鲁大学，本科生在入学时有足够多的课程可以选择，但不需要确定专业，本科学习的后期才要求确定专业，保证本科生能够在尝试中找到自己心仪的专业，以确定未来自己的发展方向。</li>
<li><strong>德国洪堡教育体制</strong>：强调专才教育，要求学生入学时就选定发展方向，讲求专业的深度。<strong>中国目前的高等教育模式就来自洪堡教育体制</strong>。</li>
</ol>
<p>在纽曼的教育理念之下，学生一毕业并不能马上达到专业工作的要求，但事业和未来发展会有后劲。洪堡教育体制则更适合需要迅速发展生产的时代，比如工业革命后需要大量科学家的美国。洪堡教育体制下毕业的学生能够迅速为国家所用，实现自身脱贫，有助于社会的迅速工业化。</p>
<p>纽曼的教育理念和洪堡教育体制很难简单地说谁更好一点，而是要看 <strong>社会发展所处的阶段</strong>。</p>
<p>改革开放初期需要尽快发展经济，类似于工业革命背景之下的美国，显然洪堡教育体制下的大学教育见效更快。社会发展趋于稳定之后，纽曼的教育理念能够帮助学生找到发展的后劲。这也是为什么现在高考开始出现 <strong>“3 + 3”</strong>、某些地方大学计划可以自选专业课的原因。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-ca9f410f973b3272.png" alt="高考 3+3 改革"></p>
<blockquote>
<p>虽然专才教育能够培养出很好的执行层面的人(无论是科学家、工程师，还是律师和医生)，但是却很难培养出拥有广阔事业的领袖以及实业家。当一个国家已经处于稳步发现阶段，当一个学生来自中上产之家，正朝着精英目标努力，这个时候，倘若缺少博雅的素质教育，路就跟难走得远。今天，中国的高中生一进高中就开始专攻那些高考必考的课程，而一进入大学，他们就被限制在不允许修改的专业中，这不仅失去了得到通才教育的机会，甚至被剥夺了培养自己学习兴趣的可能，我自己在读高中时受到了很多的通才教育，以至于到今天我所具备的人文和社会科学方面的素养，足以让我成为一个受人尊敬的人。可以说，没有好的通才教育，一个人的事业发展就不会有后劲。——吴军《大学之路》</p>
</blockquote>
<h1 id="三、我该如何学习？"><a href="#三、我该如何学习？" class="headerlink" title="三、我该如何学习？"></a>三、我该如何学习？</h1><h2 id="先做好终身学习的心里准备"><a href="#先做好终身学习的心里准备" class="headerlink" title="先做好终身学习的心里准备"></a>先做好终身学习的心里准备</h2><p>美国有一个谚语 <strong>「手里拿着锤子，看什么都是钉子」</strong>。指的是人们被自己的所拥有的知识能力所局限，导致自己做什么事情都想用手头已有的锤子来解决问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-c331b3d0a9b0ec0e.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://m.zcool.com.cn/work/ZNDA2NDkwNzY=.html" target="_blank" rel="noopener">https://m.zcool.com.cn/work/ZNDA2NDkwNzY=.html</a></li>
</ul>
<p>要克服这种铁锤人综合症的方法就是：<strong>在精通某一领域的同时接受各个领域的知识，并且将他们用来解决现实世界中的问题</strong>。</p>
<p>如此，再遇见钉子我们就有了一个工具箱。既有锤子，也有螺丝刀，还有钳子…</p>
<p>但是，要在短短的四年时间里做到这一点是有一定困难的：</p>
<ul>
<li><strong>首先，学校要有能力开出足够可供学生选择的课程</strong>。这一点，即使是如上交这样 <em>(有大量政府投入的)</em> 的学校都很难做到。每年到了选课的季节，都是对学校教务系统服务器的一次大考。学生们需要像抢春运火车票一样来抢仅有的上百门选修课。</li>
<li><strong>其次，即使强行开出这些课程，但是课程的质量往往无法得到保障</strong>。在我的学校，许多选修课完全算不上吸引人，也很少教课教的好的老师 <em>(我大学有一门课，老师上课不讲课就放视频，学生安静地待到下课就可以走了…)</em>，于是这些选修课成了同学赶作业，玩手机的时间。</li>
</ul>
<p><strong>唯一的解决办法就是延长教育时间</strong>。 在美国许多名校，例如哈弗，普林斯顿采用本科给学生以通识教育，学生可以自由选课 <em>(哈弗为了 <code>6000</code> 名本科开出了 <code>2000</code> 多门课)</em>。之后再通过 <code>1-2</code> 年的研究生教育让学生实现专业教育。这个与中国研究生的轻教育重科研有所不同。</p>
<p>但是对于我们普通人来说，我们很难有机会进入这些顶级大学，接触到这样的资源，那我们应该怎么办呢？</p>
<p>这个就要抛出所秉持的观念：<strong>坚持终身教育</strong>。这里引用吴军在《大学之路》里面的一段话：</p>
<blockquote>
<p>可能许多人认识不到教育是一辈子的事情，我们不必担心输在起跑线上，因为世界上大部分人跑到一半就不会再跑了，这就给了长跑者机会</p>
<p>并且，一个善于学习的人，随着年龄的增长，他会找到自己的兴趣点，如果他还能够学习，就有了目的性和针对性。</p>
</blockquote>
<p>在大学里我们需要养成一种自学的习惯。不仅仅是自学学校所定制的专业课，并且要有能根据自己的兴趣，要解决的问题而高效自学的能力。</p>
<p>并且养成习惯：</p>
<p>遇见问题 -&gt; 分析问题 -&gt; 搜集相关资料 -&gt; 学习相关资料 -&gt; 解决问题。</p>
<p>通过这样的方式，我们才能够跳出环境给我们带来的局限性，拥有更丰富的的人生。</p>
<h2 id="方向不对，努力白费"><a href="#方向不对，努力白费" class="headerlink" title="方向不对，努力白费"></a>方向不对，努力白费</h2><h4 id="有一个清晰的目标很重要"><a href="#有一个清晰的目标很重要" class="headerlink" title="有一个清晰的目标很重要"></a>有一个清晰的目标很重要</h4><p>就说说我的两个同学吧。</p>
<p><strong>同学 A | 大佬程序员：</strong></p>
<p>一个是在大一刚进来，正当同学们还处于刚进入大学的那种朦朦胧胧、放放松松时，就已经决定好了要走技术这条路线的 <strong>同学 A</strong>。</p>
<p>在大一刚开学时就开始早早准备自学 C/ C++，等到我们开始上学校为我们开设的课程时，他已经利用一个暑假的时间，自己基于 Unix 改写自己的 <strong>操作系统</strong>。在我们上机的课堂上还听他吐槽自己实现的垃圾桶删不了文件，有 BUG。</p>
<p>后来等到我们开始学习计算机网络时，他又自己仿写了一个类 <strong>Nginx 服务器</strong>。</p>
<p>再等我们大四准备实习时，他俨然已经成为了 <strong>Offer 收割机</strong>，想去哪儿就去哪儿 <em>(尽管我们学校仅仅是一个二本院校)</em>。当时看着他简历上的两个项目：自己实现的操作系统和服务器，心里就是一句：「卧槽！牛逼！」。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-522544089486dd3d.gif" alt=""></p>
<p><strong>同学 B | 大佬销售员：</strong></p>
<p>大一就开始卖我们电脑.. 后来大二开学开始代理学校的电信、移动等移动业务，再后来还开展了驾校的业务，大四的时候吧，我们都还在找实习呢，他已经在学校周边开办起了自己的公司..成为了自己的 <strong>CEO</strong>.. </p>
<h4 id="为之努力，并且永远不要怕晚"><a href="#为之努力，并且永远不要怕晚" class="headerlink" title="为之努力，并且永远不要怕晚"></a>为之努力，并且永远不要怕晚</h4><p>后来想起这两位同学，常常会以 <strong>“他们目标好清晰”</strong> 这样的句式来 <strong>掩盖他们为之付出的努力</strong>，方向固然重要，但为之努力也同样。如果不是 <strong>同学 A</strong> 牺牲其他同学玩耍的时间自学学习编程，他不会成为后来人人眼红的 <strong>Offer 收割机</strong>，如果不是 <strong>同学 B</strong> 勤勤恳恳不怕辛苦经营、探索各种业务，那也不会后来早早成为自己的 <strong>CEO</strong>。</p>
<p><strong>为之努力，并且永远不要觉得晚</strong>。说来惭愧，我的大学几乎可以说是从大三开始的，当我突然开始意识到我即将进入社会却身无长物时，我突然觉得需要一些些的改变和努力。于是我当天就开始制定计划，从那天到学期结束还有 <strong>七个星期零 2 天</strong>，于是有了下面这个计划：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-1d688e96c0175d0c.png" alt="七个星期零2天的计划 &amp; 总结"></p>
<p>从最基础的 Servlet/ JSP 到 SpringBoot 一整个基础的学习过来，也到了暑假，发现自己还是有差距所以毅然决定留校学习，于是有了 <strong>暑期计划</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-0c1101bd415c3d0b.png" alt="暑期计划"></p>
<p>这一段时间，给自己的简历上增加项目、学习巩固基础的数据结构、算法知识，然后 <strong>参加秋招</strong> <em>(<a href="https://www.wmyskxz.com/2018/08/15/qiu-zhao-ti-qian-pi-cvte-yi-mian-gua-a-li-san-mian-gua/">当时的面经</a>)</em>，意识到自己的差距，并且想明白了自己想要继续学习更多的知识之后，决定 <strong>考研</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-1878855356bb1675.png" alt=""></p>
<p>两个月的拼搏，虽然最终以 <code>4</code> 分的差距未能如愿择校，但后来春招也算是如愿进入了自己比较心仪的公司。</p>
<p><strong>这一切的 “逆袭” 对于我来说，也不过仅仅一年的时间。</strong></p>
<blockquote>
<p>我把这些经历也记录在了这里 - <a href="https://www.wmyskxz.com/2019/01/01/2018-nian-zhong-zong-jie/">2018 年终总结</a></p>
</blockquote>
<h2 id="锻炼独立思考、自主研究解决问题的能力"><a href="#锻炼独立思考、自主研究解决问题的能力" class="headerlink" title="锻炼独立思考、自主研究解决问题的能力"></a>锻炼独立思考、自主研究解决问题的能力</h2><p>在前一段时间里，我接触到一个词：<strong>「二手人生」</strong>。它概括的是这样一种处境：<strong>「你发现你在生活里遇到的所有问题，在搜索引擎里都能找到答案」</strong>。</p>
<p>比如说，怎么搭配衣服才低调优雅，去哪吃饭便宜又美味，买哪款耳机更划算，工作还是考研，要不要入手比特币，都有人替你解答了。你还发现有一批人用照片、视频、段子、广告为你提供了一个精心加工过的世界，这个世界常常比你自个儿的世界要美丽有趣深刻好笑有品位得多。<strong>如果把当代生活比作一场开卷考，比起你自己慢慢找答案，达人们已经为你提供了一套高分答案放到你面前让你参考</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-84fd8bb3c8aa16f9.png" alt=""></p>
<p>渐渐地你养成了一种 <strong>学生式习惯，当生活给你发了一份新卷子，你的第一反应就是先翻到网上，去看参考答案</strong>。</p>
<p>事实证明，后来我们接触的大部分事情 (无论生活还是学习上)，都不太容易有一个标准答案，<strong>当问题来临时，如何独立思考、自主研究解决问题，是非常重要的能力</strong>。</p>
<p>自我写博客以来，常常收到读者们发来的问题，有一些是他们真实地遇到了不可解决的问题寻求我的帮助，有一些问题则显得我很意外，就像下面这样：<em>(网站链接 <a href="https://lmbtfy.cn/" target="_blank" rel="noopener">戳这里</a>)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-e9795883eb364393.gif" alt=""></p>
<p>为什么会这样呢？我想大概就是学生时代遗留下来的习惯吧，习惯了更轻松一些的向别人寻求帮助或者是翻找参考答案，很少自己主动地去思考并得出问题的答案。</p>
<blockquote>
<p>这里给出一个问问题的标准模板：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-e24425ee93b35663.png" alt=""></p>
</blockquote>
<h2 id="学会编程而不是学会-Java"><a href="#学会编程而不是学会-Java" class="headerlink" title="学会编程而不是学会 Java"></a>学会编程而不是学会 Java</h2><p>其实技术是相通的。编程的落脚点还是应该放在 <strong>解决问题</strong> 上，而不是使用某种工具上。更重要的是我们通过学习某一种编程语言，来帮助我们养成 <strong>计算机的思维方式</strong>，这也要求了我们在掌握一种技术时，不仅要 <strong>知其然，还要知其所以然</strong>。</p>
<p>例如在「码农翻身」的一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=417056471&idx=1&sn=0ef5cbe0e336f34fc267f209b20d5379&scene=21#wechat_redirect" target="_blank" rel="noopener">「学会编程， 而不是学会Java」</a> 里就提到了一个问题，模仿 Java 的 <code>ArrayList</code> 实现一个自己的 <code>SimpleList</code> 类：<em>(现在看不懂也没关系)</em></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleList</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">SimpleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>T e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这个题目不要求实现复杂的算法， 也不需要进行面向对象的设计，也不需要考虑多线程下的线程安全， 况且已经给了提示：「用一个Object数组来实现」。如果说有一点语法层面的难度， 那就是使用了一点泛型。 </p>
<p>这个 <code>SimpleList</code> 要求的就是能对一个数组进行操作，核心就两点：</p>
<ol>
<li><p>能往数组添加数据， 记录size ，如果数组空间不够了， 需要增大空间</p>
</li>
<li><p>能删除数组指定位置的数据，并且把之后的数据往前挪动。</p>
</li>
</ol>
<p>难吗？这其实是编程序的基本素养，编程的本质，和用什么语言实现没有关系。</p>
<h2 id="写更多更多的代码"><a href="#写更多更多的代码" class="headerlink" title="写更多更多的代码"></a>写更多更多的代码</h2><h4 id="技术没有捷径"><a href="#技术没有捷径" class="headerlink" title="技术没有捷径"></a>技术没有捷径</h4><p>技术不要想着有捷径可寻，十年入行是有道理的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-32b4cf7afd0494fd.png" alt=""></p>
<p>现在随便走进一家书店，都会在技术类的书架上看到一堆的类似于《24小时学会Java》、《21天C++从入门到精通》这样的的书 (上面的漫画就很好地调侃了)，然而这一类「标题党」书籍，都是让你「走马观花」地瞧上一瞧，也没有时间让你写几个真正有意义的程序，这样的 <strong>「一知半解」</strong> 是一件极其危险的事情。</p>
<p>踏踏实实铺平基础知识，才是正道。</p>
<h4 id="做-ABC-的程序员而不是-ABR"><a href="#做-ABC-的程序员而不是-ABR" class="headerlink" title="做 ABC 的程序员而不是 ABR"></a>做 ABC 的程序员而不是 ABR</h4><ul>
<li><strong>ABC</strong>: Always Be Coding…</li>
<li><strong>ABR</strong>: Always Be Reading…</li>
</ul>
<p>看时会，做时废？人们口中常说的 <strong>「经验」</strong>，其实是指从自己 <strong>「一手实践」</strong> 中得到的 <strong>「一手经验」</strong>，而不是指那些从文章从别人口中获取到的「二手经验」。所以要保持 <strong>「保持始终编程」</strong>，你编写的代码越多，那么你的水平就会提升得越多。</p>
<p>去 <strong>造重复的轮子</strong>、<strong>与其他程序员交流</strong>、<strong>动手实践自己的想法</strong>。最佳实践就是集中训练，并且不断地探索新领域并挑战自己。</p>
<h2 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h2><p>自学是程序员必须掌握的一项技能，上面已经说到了大学的课程设计不是以 <strong>培养程序员</strong> 为目的的，而是以 <strong>教授最基础的知识技能</strong>，所以自学很重要。</p>
<h4 id="一些高质量的自学资料和平台"><a href="#一些高质量的自学资料和平台" class="headerlink" title="一些高质量的自学资料和平台"></a>一些高质量的自学资料和平台</h4><blockquote>
<p>部分摘录自：<a href="https://zhuanlan.zhihu.com/p/113820077" target="_blank" rel="noopener">Github 近90k点赞的计算机专业课程,在家也能上名校! | JavaGuide</a></p>
</blockquote>
<p><a href="https://github.com/ossu/computer-science#intro-cs" target="_blank" rel="noopener">computer-science</a></p>
<ol>
<li>star :56.1k</li>
<li>Github 地址：<a href="https://github.com/ossu/computer-science#intro-cs" target="_blank" rel="noopener">https://github.com/ossu/computer-science#intro-cs</a></li>
<li>介绍：通往计算机科学免费自学教育之路！计算机专业课程</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-9981342a8857add8.png" alt=""></p>
<p><a href="https://github.com/keithnull/TeachYourselfCS-CN" target="_blank" rel="noopener">TeachYourselfCS-CN (自学计算机科学)</a></p>
<ol>
<li>star :0.8k</li>
<li>Github 地址：<a href="https://github.com/keithnull/TeachYourselfCS-CN" target="_blank" rel="noopener">https://github.com/keithnull/TeachYourselfCS-CN</a></li>
<li>介绍：TeachYourselfCS 的中文翻译。内容超级棒！如果你是一个自学成才的工程师，或者从编程培训班毕业，那么你很有必要学习计算机科学。幸运的是，不必为此花上数年光阴和不菲费用去攻读一个学位：仅仅依靠自己，你就可以获得世界一流水平的教育。在这份指引中会为你解答：你应当学习 <strong>哪些科目</strong>，为什么？对于这些科目，<strong>最好的书籍或者视频课程是什么</strong>？</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-4c6825dc10824da0.png" alt=""></p>
<p><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener">REKCARC-TSC-UHT(清华大学计算机系课程攻略)</a></p>
<ol>
<li>star :12.2k</li>
<li>Github 地址：<a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener">https://github.com/PKUanonym/REKCARC-TSC-UHT</a></li>
<li>介绍：清华大学计算机系课程攻略。受 <a href="https://github.com/QSCTech/zju-icicles" target="_blank" rel="noopener">浙江大学相关项目</a> 启发，创立了本项目。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-411647071772abb6.png" alt=""></p>
<p><a href="https://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">网易云课堂 - 顶尖中文大学计算机专业课程体系</a></p>
<ol>
<li>地址：<a href="https://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">https://study.163.com/curricula/cs.htm</a></li>
<li>介绍：汇集全国多家知名大学里广受学生好评的计算机老师，每一门课程都由他们亲自制作，权威、专业！人人都可以在这里体验到时下最流行的 MOOC，系统地掌握计算机专业知识。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-3100026e92aaee8c.png" alt=""></p>
<p><strong>and more…</strong></p>
<p>类似的资料有很多，重点还是要自己能够静得下心来学习，如果纠结「看书还是看视频」，我的建议是 <strong>「都看！」</strong>。</p>
<h4 id="不要在寝室学习"><a href="#不要在寝室学习" class="headerlink" title="不要在寝室学习"></a>不要在寝室学习</h4><p>宿舍里面吃的喝的玩的，要啥啥都有，而且环境复杂.. 很难不被各种奇怪的东西影响.. 所以要学习就不要呆在宿舍。</p>
<h2 id="对自己有更高的标准，才会有更多选择"><a href="#对自己有更高的标准，才会有更多选择" class="headerlink" title="对自己有更高的标准，才会有更多选择"></a>对自己有更高的标准，才会有更多选择</h2><blockquote>
<p>这里直接引用<a href="https://book.douban.com/subject/26761696/" target="_blank" rel="noopener">《精进》</a> 的段落。</p>
</blockquote>
<p>决策心理学认为，人在面临选择时，通常会采用 <strong>“满意原则”</strong>，而不是 <strong>“最优原则”</strong>。所谓 “满意原则”，就是人会从自己最熟悉的待选项开始逐一考察，如果发现了一个能满足内心标准的选项，觉得它是 <code>OK</code> 的，就会采纳它，不会继续寻找其他选项了。</p>
<p>拿怎样度过大学生涯来举例子。很多大一新生来到大学后，以为你刚刚从原本严苛的高中生活中解放出来，所以一时间不知道怎么适应大学生活，整天耽于玩乐，荒废了学业。本来他们完全可以选择认真地对待学习，可是他们却选择了相反的大学之路，其中一个最重要的原因就是没有在心中设立一个比较高的标准。</p>
<p>特别是那些考入二三流大学的学生，在这方面的问题可能更加严重，因为高考本身带来的挫败感、二三流高校学生的身份设定及环境暗示、不称职的老师引发的失望以及同学间放任自流气氛的带动作用，都容易让他们在一个低标准下自觉“满意”地度过每一天。</p>
<p><strong>一个成熟的人，他的标准来自他的内心，而大多数人，却受环境所左右</strong>。一个年轻人，进入一所不那么优秀的高校，对自己的标准会不由自主地降低以适应这个环境，减少自身与环境的冲突，而这种做法对他们的人生也许是致命的。一个二三流大学的学生，能够勇敢地以 “985” 高校学生中的中档乃至高档水准来要求自己才是更恰当的做法，他也一定会从中受益。</p>
<p>如果心中有了更高的标准，他甚至可以选择 “炒掉” 自己的学校、专业，打破旧环境的束缚，寻找更高层次的新环境，比如选择做这些事：</p>
<ol>
<li>选择网络上高水平的在线课程，不选择本校水平稀烂的课程；</li>
<li>选择国内或国外优秀的教材，不选择国内某些拼凑而成的注水教材；</li>
<li>选择与最优秀的同学或学长交流，不选择与班级里成天玩乐的同学为伍；</li>
<li>选择参加具有挑战性的各类竞赛，不选择只满足于完成基本的课程作业；</li>
<li>……</li>
</ol>
<p><strong>首先意识到你是有更多选择的，意识到现在环境给你的选项远远不是你可以获得的全部，然后你便可以让更高的标准推动着你，去发现更多的选项，最后做出对自己来说更好的选择</strong>。</p>
<p>这个方法，不论是对于什么身份、什么年龄、什么处境的人应该都是适用的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665516406&idx=1&sn=e6642108d466268b47b118d8143bd6f1&chksm=80d67535b7a1fc235c61db117588e583163eeb47e1ee7f1b78e0878a4e2c6d408a6357b792e7&mpshare=1&scene=1&srcid=%23rd" target="_blank" rel="noopener">千万别学计算机 | 码农翻身</a></li>
<li><a href="https://medium.com/@laioffer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E8%BF%98%E8%83%BD%E7%81%AB%E5%A4%9A%E4%B9%85-d093c765252b" target="_blank" rel="noopener">计算机行业还能火多久？</a></li>
<li><a href="https://www.infoq.cn/article/0iTzgfWTY8-ehJV5JoTO" target="_blank" rel="noopener">996.ICU 背后：程序员在互联网公司的真实生态 | InfoQ</a></li>
<li><a href="https://www.zhihu.com/question/22508677/answer/141334678" target="_blank" rel="noopener">编程到底难在哪？ | 知乎</a></li>
<li><a href="https://www.itcodemonkey.com/article/15470.html" target="_blank" rel="noopener">这篇写给想选计算机专业的学弟学妹们 | Crossin的编程教室</a></li>
<li><a href="http://www.ruanyifeng.com/survivor/collapse/university.html" target="_blank" rel="noopener">为什么你可以不读大学 | 阮一峰</a></li>
<li><a href="https://book.douban.com/review/9245959/" target="_blank" rel="noopener">从《大学之路》思考我的大学教育为什么失败？</a></li>
<li><a href="https://book.douban.com/review/8451017/" target="_blank" rel="noopener">纽曼+鸿堡 | 真正的大学生活</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=417056471&idx=1&sn=0ef5cbe0e336f34fc267f209b20d5379&scene=21#wechat_redirect" target="_blank" rel="noopener">学会编程，而不是学会Java</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-d00b6d33f7f28202.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/30/dong-yi-dian-qian-duan-vue-kuai-su-ru-men/">
      懂一点前端—Vue快速入门
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>前端/懂一点系列</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月30日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-1c02ae35202887d4.png" alt=""></p>
<h1 id="01-什么是-Vue"><a href="#01-什么是-Vue" class="headerlink" title="01. 什么是 Vue"></a>01. 什么是 Vue</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-028081a4f57de388.png" alt=""></p>
<p><strong>Vue</strong> <em>(读音 /vjuː/，类似于 view)</em> 是一套用于构建用户界面的渐进式框架，是当下很火的一个 <strong>JavaScript MVVM 库</strong>，是以 <strong>数据驱动和组件化</strong> 的思想构建的。</p>
<h2 id="MVVM-模式简述"><a href="#MVVM-模式简述" class="headerlink" title="MVVM 模式简述"></a>MVVM 模式简述</h2><p>下图不仅概括了 MVVM 模式 <em>（Model-View-ViewModel）</em>，还描述了在 Vue.js 中 ViewModel 是如何和 View 以及 Model 进行交互的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-ed4735335d7728b5.png" alt=""></p>
<p><strong>ViewModel 是 Vue.js 的核心</strong>，它是一个 Vue 实例。Vue 实例是作用于某一个 HTML 元素上的，这个元素可以是 HTML 的 <code>body</code> 元素，也可以是指定了 <code>id</code> 的某个元素。</p>
<p>当创建了 ViewModel 后，双向绑定是如何达成的呢？</p>
<p>首先，我们将上图中的 <em>DOM Listeners</em> 和 <em>Data Bindings</em> 看作两个工具，它们是实现双向绑定的关键。</p>
<ul>
<li>从 View 侧看，ViewModel 中的 DOM Listeners 工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；</li>
<li>从 Model 侧看，当我们更新 Model 中的数据时，Data Bindings 工具会帮我们更新页面中的 DOM 元素。</li>
</ul>
<h2 id="库和框架的区别"><a href="#库和框架的区别" class="headerlink" title="库和框架的区别"></a>库和框架的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-84681aa96817c873.png" alt=""></p>
<p>在这里我们需要稍微注意一下前端 <strong>库(Library)</strong> 和 <strong>框架(Framework)</strong> 的区别，它们的本质都是某人编写的，用于解决常见问题的 <strong>可复用代码</strong> 的集合。</p>
<p>比如，你有一个处理字符串的程序，你为了保持代码的 <strong>DRY</strong> <em>(Don’t Repeat Yourself)</em>，你编写了如下可复用的功能代码：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getWords</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> words <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> words<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">createSentence</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> sentence <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sentence<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>恭喜你，你创建了一个 JavaScript 库！</p>
<p>如果我们用 <em>「构建房子」</em> 来类比 <em>「构建应用」</em> 的话，那么 <strong>使用库</strong> 就像是 <strong>去宜家购物</strong> 一样，我已经有了一个家，现在我需要挑选自己喜欢的一些家具，以达到我自己满意的状态，这一切 <strong>都在我的控制范围之内</strong>；而 <strong>使用框架</strong> 就会像是已经有了一个 <strong>清装房</strong>，在已经规划好的蓝图和选择之中，我们的一些想法会显得十分地有限。</p>
<p><strong>Vue.js 本身只是一个 JavaScript 库</strong>，包括 React 也一样，只不过平时我们所说的 <strong>Vue 框架</strong>，是指包含 Router/ Vuex 等一系列组件之后融合的 <strong>一整套解决方案</strong>。</p>
<blockquote>
<p>更加详细的解释如下：</p>
<ul>
<li><strong>「库」</strong> 是一个封装好的特定的集合，提供给开发者使用，而且是特定于某一方面的集合（方法和函数），库没有控制权，控制权完全在于使用者本身；</li>
<li><strong>「框架」</strong> 顾名思义是一套架构，会基于自身的特点向用户提供一套比较完整的解决方案，如果使用者选定了一套框架，那么就需要根据框架本身做出一定的适应。</li>
</ul>
</blockquote>
<h1 id="02-为什么使用-Vue？"><a href="#02-为什么使用-Vue？" class="headerlink" title="02. 为什么使用 Vue？"></a>02. 为什么使用 Vue？</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-fb93d039c156554c.png" alt=""></p>
<p>说实话，我个人非常喜欢 Vue。在我大学刚尝试学习 HTML + CSS + JavaScript 和 Bootstrap 融合之后，我就接触了 Vue，它对我来说这样的「前端小白」来说，几乎没有什么开发的门槛，很平滑地就得以过渡到 Vue 的使用中去。</p>
<p>典型的 <code>.vue</code> 文件可以简单成如下的样子：<em>(vue-tutorial/typical-case.html)</em></p>
<pre class=" language-vue"><code class="language-vue"><template>
    <!-- HTML 代码 -->
</template>

<script>
    // JavaScript 代码
</script>

<style>
    /* css 代码 */
</style></code></pre>
<p>另外我也非常喜欢尤大大本人，大家可以去看一看 Honeypot 记录的关于 Vue 的 <a href="https://www.youtube.com/watch?v=OrxmtDw4pVI&t=7s" target="_blank" rel="noopener">纪录片</a> <em>(趁着写文的间隙我又看了一遍)</em>，当然如果英文有些吃力也可以围观一下在 B 站上的 <a href="https://www.bilibili.com/video/BV1L7411M7Ut?from=search&seid=11338729656895120592" target="_blank" rel="noopener">带中文字幕的版本</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-7079c8e45951e276.png" alt="B 站翻译版本截图"></p>
<blockquote>
<p>Vue 从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。———— 尤雨溪</p>
</blockquote>
<h2 id="理由一：易上手、学习曲线平滑"><a href="#理由一：易上手、学习曲线平滑" class="headerlink" title="理由一：易上手、学习曲线平滑"></a>理由一：易上手、学习曲线平滑</h2><p>就像上面的典型 <code>.vue</code> 文件的展示一样，在 Vue 中，一切都很自然，例如我们使用 Vue 来构建我们的 <strong>Hello World</strong> 程序：<em>(vue-tutorial/hello-vue.html)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Hello Vue!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    {{ message }}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token comment" spellcheck="true">// 创建一个 Vue 实例或者说是 VieModel 实例</span>
    <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            message<span class="token punctuation">:</span> <span class="token string">'Hello Vue!'</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>可以看到几乎没有多余的部分，只是在创建 Vue 实例时，把 <code>id</code> 为 <code>app</code> 的对象 <em>(此处为一个 <code>div</code>)</em> 绑定到了 Vue 实例中而已。</p>
<h2 id="理由二：文档友好"><a href="#理由二：文档友好" class="headerlink" title="理由二：文档友好"></a>理由二：文档友好</h2><p>由于 Vue 是国人编写的，所以在官网中有完整的中文文档可供开发者参考，并且借由尤大大出色的文笔，非常地清晰易懂，相信看过的朋友会和我有一样的感受：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-0057b8b7a94bccd7.png" alt="官方网站的文档"></p>
<blockquote>
<p>官方文档的地址可戳 <a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<h2 id="理由三：MVVM-天然的双向绑定"><a href="#理由三：MVVM-天然的双向绑定" class="headerlink" title="理由三：MVVM 天然的双向绑定"></a>理由三：MVVM 天然的双向绑定</h2><p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 JavaScript 库，这就让我们能够专注于 View 层的开发，这种轻量级的框架让前端开发更加高效、便捷。</p>
<p>例如，我们使用 <code>v-model</code> 来简单改造一下我们的 <code>hello-vue.html</code> 文件让它编程一个简单的双向绑定示例：<em>(vue-tutorial/v-model-demo.html)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ message }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>将 <code>message</code> 绑定到文本框，当更改文本框的值的时候， <code>&lt;p&gt;&lt;/p&gt;</code> 中的内容也会被更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-f0f4cecc0d5b2725.gif" alt=""></p>
<p>反过来如果我们更改 <code>message</code> 的值的话，文本框的值也会被更新，我们可以在控制台中尝试一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-5c118b0f35854dbd.gif" alt=""></p>
<h2 id="千万不要把框架能力看得比你解决问题的能力还重要"><a href="#千万不要把框架能力看得比你解决问题的能力还重要" class="headerlink" title="千万不要把框架能力看得比你解决问题的能力还重要"></a>千万不要把框架能力看得比你解决问题的能力还重要</h2><p>这里是借鉴了 <a href="https://www.zhihu.com/question/294210442" target="_blank" rel="noopener">知乎中的一个讨论</a>，不论是使用 React 还是 Vue，我们最终还是要以 <strong>解决实际的问题</strong> 为出发点。引用一下尤大大在 <a href="https://www.zhihu.com/question/301860721/answer/545031906" target="_blank" rel="noopener">知乎-Vue 和 React 的优点分别是什么？</a> 上的回答部分截取：</p>
<blockquote>
<p>说了这么多，无非是希望大家能停下来想想所谓的 ”A 技术比 B 技术牛逼“ 背后到底是在争些什么，我们使用这些技术的初衷又是什么。很多时候你说这方面，他说那方面，鸡同鸭讲，即使说到一起去，也往往缺乏对等的信息量或者基础共识，只是各自表达主观看法，最后变成两个阵营各自抱团取暖… 说到底，就算你证明了 A 比 B 牛逼，也不意味着你或者你的项目就牛逼了… 比起争这个，不如多想想怎么让自己变得更牛逼吧。—————— 尤雨溪</p>
</blockquote>
<h1 id="03-Vue-常用指令"><a href="#03-Vue-常用指令" class="headerlink" title="03. Vue 常用指令"></a>03. Vue 常用指令</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-be9c3c7d0f0fcbab.png" alt=""></p>
<p>上面我们已经实际体验了一个 Vue 的指令 <code>v-model</code> 了，在 Vue 中，指令都带有 <code>v-</code> 前缀，以表示它们是 Vue 提供的特殊的 <code>attribute</code>，它们会在渲染 DOM 时进行特殊的响应式行为。</p>
<p>Vue 内置了一些常用的指令，接下来我们将依次来介绍：</p>
<ul>
<li><code>v-if</code> 和 <code>v-else</code> 条件渲染指令；</li>
<li><code>v-show</code> 条件展示指令；</li>
<li><code>v-for</code> 列表渲染指令</li>
<li><code>v-bind</code> 条件绑定指令；</li>
<li><code>v-on</code> 事件处理指令；</li>
</ul>
<blockquote>
<p>大部分照搬的官方教程，写得非常具有参考性，感兴趣的朋友可以直接略过下面部分去参考 <a href="https://cn.vuejs.org/v2/guide" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<h2 id="v-if-和-v-else-条件渲染指令"><a href="#v-if-和-v-else-条件渲染指令" class="headerlink" title="v-if 和 v-else 条件渲染指令"></a>v-if 和 v-else 条件渲染指令</h2><h4 id="v-if-指令"><a href="#v-if-指令" class="headerlink" title="v-if 指令"></a>v-if 指令</h4><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>truthy</code> 值的时候被渲染。例如：<em>(vue-tutorial/v-if-demo)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>现在你看到我了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        seen<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>页面会正确的显示「现在你看到我了！」这几个字。</p>
<h4 id="v-else-指令"><a href="#v-else-指令" class="headerlink" title="v-else 指令"></a>v-else 指令</h4><p>你也可以使用 <code>v-else</code> 来添加一个 “else 块” 来表达条件不满足时应该渲染的模块：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>现在你看到我了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>Oh no!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        seen<span class="token punctuation">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>此时条件 <code>seen</code> 不满足，页面就会显示「Oh no!」的字样。</p>
<h4 id="v-else-if-指令"><a href="#v-else-if-指令" class="headerlink" title="v-else-if 指令"></a>v-else-if 指令</h4><p>这是 <code>2.1.0</code> 版本新增的指令，充当 <code>v-if</code> 的 “else-if 块”，可以用来连续判断条件：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token punctuation">'</span>A<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  A
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token punctuation">'</span>B<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  B
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token punctuation">'</span>C<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  C
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>
  Not A/B/C
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</p>
<h2 id="v-show-条件展示指令"><a href="#v-show-条件展示指令" class="headerlink" title="v-show 条件展示指令"></a>v-show 条件展示指令</h2><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ok<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre>
<p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code> <em>(条件不满足则把元素 display 属性设置为 none)</em>，而 <code>v-if</code> 则在条件不满足时直接不渲染出对象。</p>
<h4 id="v-if-与-v-show"><a href="#v-if-与-v-show" class="headerlink" title="v-if 与 v-show"></a>v-if 与 v-show</h4><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是 <strong>惰性</strong> 的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h2 id="v-for-列表渲染指令"><a href="#v-for-列表渲染指令" class="headerlink" title="v-for 列表渲染指令"></a>v-for 列表渲染指令</h2><p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的别名。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in items<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    {{ item.message }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> example1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#example-1'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    items<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> message<span class="token punctuation">:</span> <span class="token string">'Foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> message<span class="token punctuation">:</span> <span class="token string">'Bar'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>结果：</p>
<ul>
<li>Foo</li>
<li>Bar</li>
</ul>
<blockquote>
<p><strong>注意：永远不要把 v-if 和 v-for 同时用在同一个元素上。</strong></p>
<p>因为当 Vue 处理指令时，<code>v-for</code> 比 <code>v-if</code> 拥有更高的优先级，所以会导致错误，详细的技术细节可以 <a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">戳这里</a></p>
</blockquote>
<h2 id="v-bind-条件绑定指令"><a href="#v-bind-条件绑定指令" class="headerlink" title="v-bind 条件绑定指令"></a>v-bind 条件绑定指令</h2><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：<em>(也可以用缩写 <code>:</code> 来替代 <code>v-bind</code> 指令)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ active: isActive }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据属性 <code>isActive</code> 的 <code>truthiness</code>。</p>
<p>你可以在对象中传入更多属性来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class 属性共存。当有如下模板：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>static<span class="token punctuation">"</span></span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ active: isActive, <span class="token punctuation">'</span>text-danger<span class="token punctuation">'</span>: hasError }<span class="token punctuation">"</span></span>
<span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>和如下 data：</p>
<pre class=" language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  isActive<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  hasError<span class="token punctuation">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span></code></pre>
<p>结果渲染为：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>static active<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p>
<h2 id="v-on-事件处理指令"><a href="#v-on-事件处理指令" class="headerlink" title="v-on 事件处理指令"></a>v-on 事件处理指令</h2><p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。<em>(也可以用缩写 <code>@</code> 来替代 <code>v-on</code> 指令)</em></p>
<p>示例：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>counter +<span class="token punctuation">=</span> 1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Add 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The button above has been clicked {{ counter }} times.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> example1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#example-1'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    counter<span class="token punctuation">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-72b4ee1014d5f762.gif" alt=""></p>
<h4 id="v-on-的事件修饰符"><a href="#v-on-的事件修饰符" class="headerlink" title="v-on 的事件修饰符"></a>v-on 的事件修饰符</h4><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 阻止单击事件继续传播 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.stop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThis<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 提交事件不再重载页面 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">v-on:</span>submit.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onSubmit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 修饰符可以串联 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.stop.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 只有修饰符 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">v-on:</span>submit.prevent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 添加事件监听器时使用事件捕获模式 --></span>
<span class="token comment" spellcheck="true">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.capture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThis<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --></span>
<span class="token comment" spellcheck="true">&lt;!-- 即事件不是从内部元素触发的 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.self</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<blockquote>
<p>另外事件处理还可以支持 <strong>按键码</strong> <em>(某一个键按下)</em>、<strong>系统修饰符</strong> <em>(键盘鼠标按下)</em>，可以参看 <a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">官方教程</a></p>
</blockquote>
<h1 id="04-Todo-List-示例"><a href="#04-Todo-List-示例" class="headerlink" title="04. Todo-List 示例"></a>04. Todo-List 示例</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-17bf7a6193c7bf40.png" alt=""></p>
<p>上面我们了解了一些基本的指令了，接下来我们实际动动手，来搭建一个简单的 <strong>TodoList</strong> demo 小程序。</p>
<h2 id="第一步：明确需求"><a href="#第一步：明确需求" class="headerlink" title="第一步：明确需求"></a>第一步：明确需求</h2><p>TodoList 想必大家都很熟悉，使用来记录我们接下来要做的一些事情的程序，最基本的功能有增加和删除：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-87f3a4def16405b3.gif" alt=""></p>
<p>很简单，可以看出我们只需要一个输入框 <em>(用来记录将要保存的数据)<em>，一个按钮 *(用来添加数据)</em>，和一个集合 *(用来保存数据)</em> 就差不多可以了，上手！</p>
<h2 id="第二步：创建好需要的-data"><a href="#第二步：创建好需要的-data" class="headerlink" title="第二步：创建好需要的 data"></a>第二步：创建好需要的 data</h2><p>先来创建好我们需要的数据 data：</p>
<pre class=" language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    todos<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> nextTodoId<span class="token operator">++</span><span class="token punctuation">,</span>
            text<span class="token punctuation">:</span> <span class="token string">'写代码'</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> nextTodoId<span class="token operator">++</span><span class="token punctuation">,</span>
            text<span class="token punctuation">:</span> <span class="token string">'还是写代码'</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    newTodoText<span class="token punctuation">:</span> <span class="token string">""</span>
<span class="token punctuation">}</span></code></pre>
<p>这里多定义了 <code>id</code> 属性是为了方便我们的删除操作。</p>
<h2 id="第三步：创建好对应的-HTML"><a href="#第三步：创建好对应的-HTML" class="headerlink" title="第三步：创建好对应的 HTML"></a>第三步：创建好对应的 HTML</h2><p>没有任何布局，就直接定义好我们所需要的组件就好了：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newTodoText<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>添加<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in todos<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>{{ item.text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>removeItem(item.id)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>del<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre>
<p>没有任何的特别，只是里面包含了两个我们 <code>未定义</code> 的方法：<code>addItem</code> 和 <code>removeItem</code> 而已。</p>
<h2 id="第三步：定义并实现方法"><a href="#第三步：定义并实现方法" class="headerlink" title="第三步：定义并实现方法"></a>第三步：定义并实现方法</h2><p>Vue 中的方法需要定义在 Vue 实例的 <code>methods</code> 关键字下面：</p>
<pre class=" language-javascript"><code class="language-javascript">methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">addItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> nextTodoId<span class="token punctuation">,</span>
            text<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newTodoText
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>newTodoText <span class="token operator">=</span> <span class="token string">""</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">removeItem</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>todos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>todo <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> todo<span class="token punctuation">.</span>id <span class="token operator">!==</span> id
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里数组的更新需要用到 <code>push</code>，另外删除时我们使用了一个 lambda 表达式来完成，删除时传入了一个要删除元素的 <code>id</code>，然后从数组中挑选出所有 <strong>不等于</strong> 这个 <code>id</code> 的元素重新赋值给原数组，这样就相当于是删除了元素了。</p>
<blockquote>
<p>本文涉及的所有代码都上传到了【More Than Java】项目中。<em>(地址下方)</em></p>
</blockquote>
<h2 id="更好的参考"><a href="#更好的参考" class="headerlink" title="更好的参考"></a>更好的参考</h2><p>上面的代码仅仅是简单实现，更好的参考可以查看 Vue 官方实现的一个更加具有参考性的例子：<a href="https://codesandbox.io/s/o29j95wx9" target="_blank" rel="noopener">https://codesandbox.io/s/o29j95wx9</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Vue【官方文档】 - <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li>
<li>【译】框架与库的差异 - <a href="https://juejin.im/post/5c5fe3e751882561dd7b4e9b" target="_blank" rel="noopener">https://juejin.im/post/5c5fe3e751882561dd7b4e9b</a></li>
<li>Vue.js——60分钟快速入门 - <a href="https://www.cnblogs.com/keepfool/p/5619070.html" target="_blank" rel="noopener">https://www.cnblogs.com/keepfool/p/5619070.html</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/25/dong-yi-dian-python-xi-lie-kuai-su-ru-men-1/">
      妈妈再也不担心我面试被Redis问得脸都绿了
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月25日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-36f1278b896ced09.png" alt=""></p>
<blockquote>
<p>长文前排提醒，收藏向前排提醒，素质三连 <strong>(转发 + 在看 + 留言)</strong> 前排提醒！</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fbe27d1657e593c3.png" alt=""></p>
<p><strong>Redis</strong> 作为一个开源的，高级的键值存储和一个适用的解决方案，已经越来越在构建 <strong>「高性能」</strong>、<strong>「可扩展」</strong> 的 Web 应用上发挥着举足轻重的作用。</p>
<p>当今互联网技术架构中 <strong>Redis</strong> 已然成为了应用得最广泛的中间件之一，它也是中高级后端工程 <strong>技术面试</strong> 中面试官最喜欢问的工程技能之一，不仅仅要求着我们对 <strong>基本的使用</strong> 进行掌握，更要深层次地理解 Redis <strong>内部实现</strong> 的细节原理。</p>
<p>熟练掌握 Redis，甚至可以毫不夸张地说已经半只脚踏入心仪的公司了。下面我们一起来盘点回顾一下 Redis 的面试经典问题，就不要再被面试官问得 <strong>脸都绿了</strong> 呀！</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-62a9826a061d71dc.png" alt=""></p>
<ul>
<li><strong>Ps</strong>： 我把 <strong>重要的知识点</strong> 都做成了 <strong>图片</strong>，希望各位 <strong>“用餐愉快”</strong>。<em>(不错记得付餐费.. 点个赞留个言..)</em></li>
</ul>
<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4e434da31115b92d.png" alt=""></p>
<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><h4 id="先解释-Redis-基本概念"><a href="#先解释-Redis-基本概念" class="headerlink" title="先解释 Redis 基本概念"></a>先解释 Redis 基本概念</h4><p><strong>Redis</strong> (<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver) 是一个使用 <strong>C 语言</strong> 编写的，开源的 <em>(BSD许可)</em> 高性能 <strong>非关系型</strong> <em>(NoSQL)</em> 的 <strong>键值对数据库</strong>。</p>
<h4 id="简单提一下-Redis-数据结构"><a href="#简单提一下-Redis-数据结构" class="headerlink" title="简单提一下 Redis 数据结构"></a>简单提一下 Redis 数据结构</h4><p><strong>Redis</strong> 可以存储 <strong>键</strong> 和 <strong>不同类型数据结构值</strong> 之间的映射关系。键的类型只能是字符串，而值除了支持最 <strong>基础的五种数据类型</strong> 外，还支持一些 <strong>高级数据类型</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-ea1e1248cb5d8f88.png" alt=""></p>
<blockquote>
<p>一定要说出一些高级数据结构 <em>(当然你自己也要了解.. 下面会说到的别担心)</em>，这样面试官的眼睛才会亮。</p>
</blockquote>
<h4 id="Redis-小总结"><a href="#Redis-小总结" class="headerlink" title="Redis 小总结"></a>Redis 小总结</h4><p>与传统数据库不同的是 <strong>Redis</strong> 的数据是 <strong>存在内存</strong> 中的，所以 <strong>读写速度</strong> 非常 <strong>快</strong>，因此 Redis 被广泛应用于 <strong>缓存</strong> 方向，每秒可以处理超过 <code>10</code> 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做 <strong>分布式锁</strong>。</p>
<p>除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h2 id="Redis-优缺点"><a href="#Redis-优缺点" class="headerlink" title="Redis 优缺点"></a>Redis 优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>读写性能优异</strong>， Redis能读的速度是 <code>110000</code> 次/s，写的速度是 <code>81000</code> 次/s。</li>
<li><strong>支持数据持久化</strong>，支持 AOF 和 RDB 两种持久化方式。</li>
<li><strong>支持事务</strong>，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li><strong>数据结构丰富</strong>，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li><strong>支持主从复制</strong>，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>数据库 <strong>容量受到物理内存的限制</strong>，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis <strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 <strong>系统的可用性</strong>。</li>
<li><strong>Redis 较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="为什么要用缓存？为什么使用-Redis？"><a href="#为什么要用缓存？为什么使用-Redis？" class="headerlink" title="为什么要用缓存？为什么使用 Redis？"></a>为什么要用缓存？为什么使用 Redis？</h2><h4 id="提一下现在-Web-应用的现状"><a href="#提一下现在-Web-应用的现状" class="headerlink" title="提一下现在 Web 应用的现状"></a>提一下现在 Web 应用的现状</h4><p>在日常的 Web 应用对数据库的访问中，<strong>读操作的次数远超写操作</strong>，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用 SQL 语句去数据库进行读写操作时，数据库就会 <strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p>
<h4 id="使用-Redis-or-使用缓存带来的优势"><a href="#使用-Redis-or-使用缓存带来的优势" class="headerlink" title="使用 Redis or 使用缓存带来的优势"></a>使用 Redis or 使用缓存带来的优势</h4><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样 <strong>速度</strong> 明显就会快上不少 <em>(高性能)</em>，并且会 <strong>极大减小数据库的压力</strong> <em>(特别是在高并发情况下)</em>。</p>
<blockquote>
<p>记得是 <strong>两个角度</strong> 啊.. <strong>高性能</strong> 和 <strong>高并发</strong>..</p>
</blockquote>
<h4 id="也要提一下使用缓存的考虑"><a href="#也要提一下使用缓存的考虑" class="headerlink" title="也要提一下使用缓存的考虑"></a>也要提一下使用缓存的考虑</h4><p>但是使用内存进行数据存储开销也是比较大的，<strong>限于成本</strong> 的原因，一般我们只是使用 Redis 存储一些 <strong>常用和主要的数据</strong>，比如用户登录的信息等。</p>
<p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p>
<ul>
<li><strong>业务数据常用吗？命中率如何？</strong> 如果命中率很低，就没有必要写入缓存；</li>
<li><strong>该业务数据是读操作多，还是写操作多？</strong> 如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li>
<li><strong>业务数据大小如何？</strong> 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li>
</ul>
<p>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！</p>
<h2 id="使用缓存会出现什么问题？"><a href="#使用缓存会出现什么问题？" class="headerlink" title="使用缓存会出现什么问题？"></a>使用缓存会出现什么问题？</h2><p>一般来说有如下几个问题，回答思路遵照 <strong>是什么</strong> → <strong>为什么</strong> → <strong>怎么解决</strong>：</p>
<ol>
<li>缓存雪崩问题；</li>
<li>缓存穿透问题；</li>
<li>缓存和数据库双写一致性问题；</li>
</ol>
<h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-891c01ada1be7099.png" alt=""></p>
<p>另外对于 <strong>“Redis 挂掉了，请求全部走数据库”</strong> 这样的情况，我们还可以有如下的思路：</p>
<ul>
<li><strong>事发前</strong>：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。</li>
<li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li>
<li><strong>事发后</strong>：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-aa9398e52cf83891.png" alt=""></p>
<h4 id="缓存与数据库双写一致问题"><a href="#缓存与数据库双写一致问题" class="headerlink" title="缓存与数据库双写一致问题"></a>缓存与数据库双写一致问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-1c3e67935d7763d4.png" alt=""></p>
<p>双写一致性上图还是稍微粗糙了些，你还需要知道两种方案 <em>(先操作数据库和先操作缓存)</em> 分别都有什么优势和对应的问题，这里不作赘述，可以参考一下下方的文章，写得非常详细。</p>
<blockquote>
<ul>
<li>面试前必须要知道的Redis面试题 | Java3y - <a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么早期版本选择单线程？"><a href="#Redis-为什么早期版本选择单线程？" class="headerlink" title="Redis 为什么早期版本选择单线程？"></a>Redis 为什么早期版本选择单线程？</h2><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p>因为 Redis 是基于内存的操作，<strong>CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是 <strong>机器内存的大小</strong> 或者 <strong>网络带宽</strong>。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h4 id="简单总结一下"><a href="#简单总结一下" class="headerlink" title="简单总结一下"></a>简单总结一下</h4><ol>
<li>使用单线程模型能带来更好的 <strong>可维护性</strong>，方便开发和调试；</li>
<li>使用单线程模型也能 <strong>并发</strong> 的处理客户端的请求；<em>(I/O 多路复用机制)</em></li>
<li>Redis 服务中运行的绝大多数操作的 <strong>性能瓶颈都不是 CPU</strong>；</li>
</ol>
<blockquote>
<p><strong>强烈推荐</strong> 各位亲看一下这篇文章：</p>
<ul>
<li>为什么 Redis 选择单线程模型 · Why’s THE Design? - <a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">https://draveness.me/whys-the-design-redis-single-thread</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><p>简单总结：</p>
<ol>
<li><strong>纯内存操作</strong>：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；<em>(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)</em></li>
<li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li>
<li><strong>多路 I/O 复用模型，非阻塞 I/O</strong>：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li>
<li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li>
</ol>
<h1 id="二、数据结构篇"><a href="#二、数据结构篇" class="headerlink" title="二、数据结构篇"></a>二、数据结构篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-68ecbdc6cf4c5588.png" alt=""></p>
<h2 id="简述一下-Redis-常用数据结构及实现？"><a href="#简述一下-Redis-常用数据结构及实现？" class="headerlink" title="简述一下 Redis 常用数据结构及实现？"></a>简述一下 Redis 常用数据结构及实现？</h2><p>首先在 Redis 内部会使用一个 <strong>RedisObject</strong> 对象来表示所有的 <code>key</code> 和 <code>value</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-16511ec4f7f30569.png" alt=""></p>
<p>其次 Redis 为了 <strong>平衡空间和时间效率</strong>，针对 <code>value</code> 的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系：<em>(好像乱糟糟的，但至少能看清楚..)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-0801fee369ecca97.png" alt=""></p>
<h2 id="Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>Redis 的 SDS 和 C 中字符串相比有什么优势？</h2><h4 id="先简单总结一下"><a href="#先简单总结一下" class="headerlink" title="先简单总结一下"></a>先简单总结一下</h4><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 <strong>不符合 Redis 对字符串在安全性、效率以及功能方面的要求</strong>。</p>
<h4 id="再来说-C-语言字符串的问题"><a href="#再来说-C-语言字符串的问题" class="headerlink" title="再来说 C 语言字符串的问题"></a>再来说 C 语言字符串的问题</h4><p>这样简单的数据结构可能会造成以下一些问题：</p>
<ul>
<li><strong>获取字符串长度为 O(N) 级别的操作</strong> → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</li>
<li>不能很好的杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；</li>
<li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li>
</ul>
<h4 id="Redis-如何解决的-SDS-的优势"><a href="#Redis-如何解决的-SDS-的优势" class="headerlink" title="Redis 如何解决的 | SDS 的优势"></a>Redis 如何解决的 | SDS 的优势</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9570ea52d515e1cb.png" alt=""></p>
<p>如果去看 Redis 的源码 <code>sds.h/sdshdr</code> 文件，你会看到 SDS 完整的实现细节，这里简单来说一下 Redis 如何解决的：</p>
<ol>
<li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li>
<li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</li>
<li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li>
<li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li>
</ol>
<h2 id="字典是如何实现的？Rehash-了解吗？"><a href="#字典是如何实现的？Rehash-了解吗？" class="headerlink" title="字典是如何实现的？Rehash 了解吗？"></a>字典是如何实现的？Rehash 了解吗？</h2><h4 id="先总体聊一下-Redis-中的字典"><a href="#先总体聊一下-Redis-中的字典" class="headerlink" title="先总体聊一下 Redis 中的字典"></a>先总体聊一下 Redis 中的字典</h4><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p>
<h4 id="说明字典内部结构和-rehash"><a href="#说明字典内部结构和-rehash" class="headerlink" title="说明字典内部结构和 rehash"></a>说明字典内部结构和 rehash</h4><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的 <strong>链地址法</strong> 来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p>
<p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个 <code>hashtable</code> 有值，但是在字典扩容缩容时，需要分配新的 <code>hashtable</code>，然后进行 <strong>渐进式搬迁</strong> <em>(rehash)</em>，这时候两个 <code>hashtable</code> 分别存储旧的和新的 <code>hashtable</code>，待搬迁结束后，旧的将被删除，新的 <code>hashtable</code> 取而代之。</p>
<h4 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h4><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p>
<h2 id="跳跃表是如何实现的？原理？"><a href="#跳跃表是如何实现的？原理？" class="headerlink" title="跳跃表是如何实现的？原理？"></a>跳跃表是如何实现的？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9e9cbfe4fc061f3.png" alt=""></p>
<blockquote>
<p>这是 Redis 中比较重要的一个数据结构，<strong>建议阅读</strong> 之前写过的文章，里面详细介绍了原理和一些细节：</p>
<ul>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
</ul>
</blockquote>
<h2 id="HyperLogLog-有了解吗？"><a href="#HyperLogLog-有了解吗？" class="headerlink" title="HyperLogLog 有了解吗？"></a>HyperLogLog 有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
</ul>
</blockquote>
<h2 id="布隆过滤器有了解吗？"><a href="#布隆过滤器有了解吗？" class="headerlink" title="布隆过滤器有了解吗？"></a>布隆过滤器有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
</ul>
</blockquote>
<h2 id="GeoHash-了解吗？"><a href="#GeoHash-了解吗？" class="headerlink" title="GeoHash 了解吗？"></a>GeoHash 了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(6)——GeoHash查找附近的人 - <a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
</ul>
</blockquote>
<h2 id="压缩列表了解吗？"><a href="#压缩列表了解吗？" class="headerlink" title="压缩列表了解吗？"></a>压缩列表了解吗？</h2><p>这是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，<strong>zset</strong> 和 <strong>hash</strong> 容器对象会在元素个数较少的时候，采用压缩列表（ziplist）进行存储。压缩列表是 <strong>一块连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。</p>
<blockquote>
<p>因为之前自己也没有学习过，所以找了一篇比较好比较容易理解的文章：</p>
<ul>
<li>图解Redis之数据结构篇——压缩列表 - <a href="https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg</a></li>
<li>这一篇稍微底层稍微硬核一点：<a href="http://www.web-lovers.com/redis-source-ziplist.html" target="_blank" rel="noopener">http://www.web-lovers.com/redis-source-ziplist.html</a></li>
</ul>
</blockquote>
<h2 id="快速列表-quicklist-了解吗？"><a href="#快速列表-quicklist-了解吗？" class="headerlink" title="快速列表 quicklist 了解吗？"></a>快速列表 quicklist 了解吗？</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p>
<p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>。</p>
<blockquote>
<p>同上..建议阅读一下以下的文章：</p>
<ul>
<li>Redis列表list 底层原理 - <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li>
</ul>
</blockquote>
<h2 id="Stream-结构有了解吗？"><a href="#Stream-结构有了解吗？" class="headerlink" title="Stream 结构有了解吗？"></a>Stream 结构有了解吗？</h2><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9d8afde068a165f.png" alt=""></p>
<p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p>
<ul>
<li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li>
<li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li>
<li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li>
</ul>
<h4 id="Stream-消息太多怎么办？"><a href="#Stream-消息太多怎么办？" class="headerlink" title="Stream 消息太多怎么办？"></a>Stream 消息太多怎么办？</h4><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p>
<p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> XADD mystream MAXLEN 2 * value 1
1526654998691-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 2
1526654999635-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 3
1526655000369-0
<span class="token operator">></span> XLEN mystream
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token operator">></span> XRANGE mystream - +
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526654999635-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526655000369-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p>
<p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p>
<pre class=" language-bash"><code class="language-bash">XADD mystream MAXLEN ~ 1000 * <span class="token punctuation">..</span>. entry fields here <span class="token punctuation">..</span>.</code></pre>
<p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p>
<h4 id="PEL-是如何避免消息丢失的？"><a href="#PEL-是如何避免消息丢失的？" class="headerlink" title="PEL 是如何避免消息丢失的？"></a>PEL 是如何避免消息丢失的？</h4><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p>
<h4 id="和-Kafka-对比起来呢？"><a href="#和-Kafka-对比起来呢？" class="headerlink" title="和 Kafka 对比起来呢？"></a>和 Kafka 对比起来呢？</h4><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p>
<p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p>
<blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章，里面 <strong>也对 Pub/ Sub 做了详细的描述</strong>：</p>
<ul>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ul>
</blockquote>
<h1 id="三、持久化篇"><a href="#三、持久化篇" class="headerlink" title="三、持久化篇"></a>三、持久化篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-54bd130bf8e635e0.png" alt=""></p>
<h2 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h2><h4 id="先简单谈一谈是什么"><a href="#先简单谈一谈是什么" class="headerlink" title="先简单谈一谈是什么"></a>先简单谈一谈是什么</h4><p><strong>Redis</strong> 的数据 <strong>全部存储</strong> 在 <strong>内存</strong> 中，如果 <strong>突然宕机</strong>，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 <strong>持久化机制</strong>，它会将内存中的数据库状态 <strong>保存到磁盘</strong> 中。</p>
<h4 id="解释一下持久化发生了什么"><a href="#解释一下持久化发生了什么" class="headerlink" title="解释一下持久化发生了什么"></a>解释一下持久化发生了什么</h4><p>我们来稍微考虑一下 <strong>Redis</strong> 作为一个 <strong>“内存数据库”</strong> 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-5c209bc08da11abb.png" alt=""></p>
<p><strong>详细版</strong> 的文字描述大概就是下面这样：</p>
<ol>
<li>客户端向数据库 <strong>发送写命令</strong> <em>(数据在客户端的内存中)</em></li>
<li>数据库 <strong>接收</strong> 到客户端的 <strong>写请求</strong> <em>(数据在服务器的内存中)</em></li>
<li>数据库 <strong>调用系统 API</strong> 将数据写入磁盘 <em>(数据在内核缓冲区中)</em></li>
<li>操作系统将 <strong>写缓冲区</strong> 传输到 <strong>磁盘控控制器</strong> <em>(数据在磁盘缓存中)</em></li>
<li>操作系统的磁盘控制器将数据 <strong>写入实际的物理媒介</strong> 中 <em>(数据在磁盘中)</em></li>
</ol>
<h4 id="分析如何保证持久化安全"><a href="#分析如何保证持久化安全" class="headerlink" title="分析如何保证持久化安全"></a>分析如何保证持久化安全</h4><p>如果我们故障仅仅涉及到 <strong>软件层面</strong> <em>(该进程被管理员终止或程序崩溃)</em> 并且没有接触到内核，那么在 <em>上述步骤 3</em> 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。</p>
<p>如果我们考虑 <strong>停电/ 火灾</strong> 等 <strong>更具灾难性</strong> 的事情，那么只有在完成了第 <strong>5</strong> 步之后，才是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-de083f477fe1bce4.png" alt="机房”火了“"></p>
<p>所以我们可以总结得出数据安全最重要的阶段是：<strong>步骤三、四、五</strong>，即：</p>
<ul>
<li>数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？</li>
<li>内核多久从缓冲区取数据刷新到磁盘控制器？</li>
<li>磁盘控制器多久把数据写入物理媒介一次？</li>
<li><strong>注意：</strong> 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 <strong>尽可能地保证</strong> 数据的安全，这对于所有数据库来说都是一样的。</li>
</ul>
<p>我们从 <strong>第三步</strong> 开始。Linux 系统提供了清晰、易用的用于操作文件的 <code>POSIX file API</code>，<code>20</code> 多年过去，仍然还有很多人对于这一套 <code>API</code> 的设计津津乐道，我想其中一个原因就是因为你光从 <code>API</code> 的命名就能够很清晰地知道这一套 API 的用途：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">/*,mode_t mode */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">close</span> <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fname <span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>参考自：API 设计最佳实践的思考 - <a href="https://www.cnblogs.com/yuanjiangw/p/10846560.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanjiangw/p/10846560.html</a></li>
</ul>
<p>所以，我们有很好的可用的 <code>API</code> 来完成 <strong>第三步</strong>，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。</p>
<p>然后我们来说说 <strong>第四步</strong>。我们知道，除了早期对电脑特别了解那帮人 <em>(操作系统就这帮人搞的)</em>，实际的物理硬件都不是我们能够 <strong>直接操作</strong> 的，都是通过 <strong>操作系统调用</strong> 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 <strong>上述第四步</strong> 提到的 <strong>写缓冲区</strong>，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 <strong>30 秒</strong> 后实际提交写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c08b7572ef02d67b.jpg" alt=""></p>
<p>但是很明显，<strong>30 秒</strong> 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 <code>PROSIX API</code> 提供了另一个解决方案：<code>fsync</code>，该命令会 <strong>强制</strong> 内核将 <strong>缓冲区</strong> 写入 <strong>磁盘</strong>，但这是一个非常消耗性能的操作，每次调用都会 <strong>阻塞等待</strong> 直到设备报告 IO 完成，所以一般在生产环境的服务器中，<strong>Redis</strong> 通常是每隔 1s 左右执行一次 <code>fsync</code> 操作。</p>
<p>到目前为止，我们了解到了如何控制 <code>第三步</code> 和 <code>第四步</code>，但是对于 <strong>第五步</strong>，我们 <strong>完全无法控制</strong>。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。</p>
<blockquote>
<p>普通人简单说一下第一条就过了，如果你详细地对后面两方面 <strong>侃侃而谈</strong>，那面试官就会对你另眼相看了。</p>
</blockquote>
<h2 id="Redis-中的两种持久化方式？"><a href="#Redis-中的两种持久化方式？" class="headerlink" title="Redis 中的两种持久化方式？"></a>Redis 中的两种持久化方式？</h2><h4 id="方式一：快照"><a href="#方式一：快照" class="headerlink" title="方式一：快照"></a>方式一：快照</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9a4d234c53120b33.gif" alt=""></p>
<p><strong>Redis 快照</strong> 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 <code>100</code> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>
<h4 id="方式二：AOF"><a href="#方式二：AOF" class="headerlink" title="方式二：AOF"></a>方式二：AOF</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-e4e08ebef2cf0144.gif" alt=""></p>
<p><strong>快照不是很持久</strong>。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 <code>kill -9</code> 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。</p>
<p><strong>AOF(Append Only File - 仅追加文件)</strong> 它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>
<h4 id="Redis-4-0-的混合持久化"><a href="#Redis-4-0-的混合持久化" class="headerlink" title="Redis 4.0 的混合持久化"></a>Redis 4.0 的混合持久化</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-7de9f7706be6216c.gif" alt=""></p>
<p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-2f7887f84eaa34d9.png" alt=""></p>
<p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<blockquote>
<p>关于两种持久化方式的更多细节 <em>(原理)</em> 可以参考：</p>
<ul>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
</ul>
</blockquote>
<h2 id="RDB-和-AOF-各自有什么优缺点？"><a href="#RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="RDB 和 AOF 各自有什么优缺点？"></a>RDB 和 AOF 各自有什么优缺点？</h2><h4 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB | 优点"></a>RDB | 优点</h4><ol>
<li>只有一个文件 <code>dump.rdb</code>，<strong>方便持久化</strong>。</li>
<li><strong>容灾性好</strong>，一个文件可以保存到安全的磁盘。</li>
<li><strong>性能最大化</strong>，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能</li>
<li>相对于数据集大时，比 AOF 的 <strong>启动效率</strong> 更高。</li>
</ol>
<h4 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB | 缺点"></a>RDB | 缺点</h4><ol>
<li><strong>数据安全性低</strong>。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</li>
</ol>
<h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF | 优点"></a>AOF | 优点</h4><ol>
<li><strong>数据安全</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li>
</ol>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF | 缺点"></a>AOF | 缺点</h4><ol>
<li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li>
<li><strong>数据集大</strong> 的时候，比 rdb <strong>启动效率低</strong>。</li>
</ol>
<h2 id="两种方式如何选择？"><a href="#两种方式如何选择？" class="headerlink" title="两种方式如何选择？"></a>两种方式如何选择？</h2><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的 <strong>数据安全性</strong>，你应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然 <strong>可以承受数分钟以内的数据丢失</strong>，那么你可以 <strong>只使用 RDB 持久化</strong>。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h2 id="Redis-的数据恢复"><a href="#Redis-的数据恢复" class="headerlink" title="Redis 的数据恢复"></a>Redis 的数据恢复</h2><p><strong>Redis</strong> 的数据恢复有着如下的优先级：</p>
<ol>
<li>如果只配置 AOF ，重启时加载 AOF 文件恢复数据；</li>
<li>如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；</li>
<li>如果只配置 RDB，启动将加载 dump 文件恢复数据。</li>
</ol>
<p>拷贝 <strong>AOF</strong> 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程：Redis 虚拟一个客户端，读取 AOF 文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在 <code>loadAppendOnlyFile()</code> 中实现。</p>
<p>拷贝 <strong>RDB</strong> 文件到 Redis 的数据目录，启动 redis-server 即可，因为 RDB 文件和重启前保存的是真实数据而不是命令状态和参数。</p>
<h1 id="四、集群篇"><a href="#四、集群篇" class="headerlink" title="四、集群篇"></a>四、集群篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-83a0181f29cccb73.png" alt=""></p>
<h2 id="主从同步了解吗？"><a href="#主从同步了解吗？" class="headerlink" title="主从同步了解吗？"></a>主从同步了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。</p>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="哨兵模式了解吗？"><a href="#哨兵模式了解吗？" class="headerlink" title="哨兵模式了解吗？"></a>哨兵模式了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h4><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="Redis-集群使用过吗？原理？"><a href="#Redis-集群使用过吗？原理？" class="headerlink" title="Redis 集群使用过吗？原理？"></a>Redis 集群使用过吗？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="集群中数据如何分区？"><a href="#集群中数据如何分区？" class="headerlink" title="集群中数据如何分区？"></a>集群中数据如何分区？</h2><p>Redis 采用方案三。</p>
<h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点之间的通信机制了解吗？"><a href="#节点之间的通信机制了解吗？" class="headerlink" title="节点之间的通信机制了解吗？"></a>节点之间的通信机制了解吗？</h2><p>集群的建立离不开节点之间的通信，例如我们在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="集群数据如何存储的有了解吗？"><a href="#集群数据如何存储的有了解吗？" class="headerlink" title="集群数据如何存储的有了解吗？"></a>集群数据如何存储的有了解吗？</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<h1 id="五、其他问题"><a href="#五、其他问题" class="headerlink" title="五、其他问题"></a>五、其他问题</h1><h2 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h2><blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章：<br>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></p>
</blockquote>
<h2 id="Redis-过期键的删除策略？"><a href="#Redis-过期键的删除策略？" class="headerlink" title="Redis 过期键的删除策略？"></a>Redis 过期键的删除策略？</h2><h4 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h4><p>先抛开 Redis 想一下几种可能的删除策略：</p>
<ol>
<li><strong>定时删除</strong>:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</li>
<li><strong>定期删除</strong>:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ol>
<p>在上述的三种策略中定时删除和定期删除属于不同时间粒度的 <strong>主动删除</strong>，惰性删除属于 <strong>被动删除</strong>。</p>
<h4 id="三种策略都有各自的优缺点"><a href="#三种策略都有各自的优缺点" class="headerlink" title="三种策略都有各自的优缺点"></a>三种策略都有各自的优缺点</h4><ol>
<li>定时删除对内存使用率有优势，但是对 CPU 不友好；</li>
<li>惰性删除对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费；</li>
<li>定期删除是定时删除和惰性删除的折中。</li>
</ol>
<h4 id="Redis-中的实现"><a href="#Redis-中的实现" class="headerlink" title="Redis 中的实现"></a>Redis 中的实现</h4><p>Reids 采用的是 <strong>惰性删除和定时删除</strong> 的结合，一般来说可以借助最小堆来实现定时器，不过 Redis 的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，这样如果在此基础上实现定时删除，就意味着 <code>O(N)</code> 遍历获取最近需要删除的数据。</p>
<h2 id="Redis-的淘汰策略有哪些？"><a href="#Redis-的淘汰策略有哪些？" class="headerlink" title="Redis 的淘汰策略有哪些？"></a>Redis 的淘汰策略有哪些？</h2><h4 id="Redis-有六种淘汰策略"><a href="#Redis-有六种淘汰策略" class="headerlink" title="Redis 有六种淘汰策略"></a>Redis 有六种淘汰策略</h4><table>
<thead>
<tr>
<th align="left">策略</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">volatile-lru</td>
<td align="left">从已设置过期时间的 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-ttl</td>
<td align="left">从已设置过期时间的 KV 集中优先对剩余时间短(time to live)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-random</td>
<td align="left">从已设置过期时间的 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">allkeys-lru</td>
<td align="left">从所有 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">allKeys-random</td>
<td align="left">从所有 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">noeviction</td>
<td align="left">不淘汰策略，若超过最大内存，返回错误信息</td>
</tr>
</tbody></table>
<h4 id="4-0-版本后增加以下两种"><a href="#4-0-版本后增加以下两种" class="headerlink" title="4.0 版本后增加以下两种"></a>4.0 版本后增加以下两种</h4><ul>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<h2 id="More"><a href="#More" class="headerlink" title="More.."></a>More..</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了 - <a href="https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w</a></li>
<li>大厂面试！我和面试官之间关于Redis的一场对弈！ - <a href="https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g</a></li>
<li>Redis面试题（2020最新版） - <a href="https://blog.csdn.net/ThinkWon/article/details/103522351" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/103522351</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/23/dong-yi-dian-python-xi-lie-kuai-su-ru-men/">
      懂一点Python系列——快速入门
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Python/懂一点系列</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月23日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-71e6f0dcd9d841a5.png" alt=""></p>
<blockquote>
<p>本文面相有 <strong>一定编程基础</strong> 的朋友学习，所以略过了 <em>环境安装<em>、</em>IDE 搭建</em> 等一系列简单繁琐的事情。</p>
</blockquote>
<h1 id="一、Python-简介"><a href="#一、Python-简介" class="headerlink" title="一、Python 简介"></a>一、Python 简介</h1><p><strong>Python</strong> 英文原意为 <strong>“蟒蛇”</strong>，直到 <code>1989</code> 年荷兰人 <strong>Guido van Rossum</strong> （简称 Guido）发明了一种 <strong>面向对象</strong> 的 <strong>解释型</strong> 编程语言，并将其命名为  Python，才赋予了它表示一门编程语言的含义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-8cc9b31907c8afca.png" alt=""></p>
<blockquote>
<p>说到 Python 的诞生，极具戏剧色彩，据 Guido 的自述记载，Python 语言是他在圣诞节期间为了打发时间开发出来的，之所以会选择 Python 作为该编程语言的名字，是因为他是一个叫 Monty Python 戏剧团体的忠实粉丝。</p>
</blockquote>
<h2 id="解释型-vs-编译型"><a href="#解释型-vs-编译型" class="headerlink" title="解释型 vs 编译型"></a>解释型 vs 编译型</h2><p>作为电子元器件的 <strong>计算机</strong>，实际上 <strong>只能</strong> 识别某些 <strong>特定的二进制指令</strong> <em>(特殊的 <code>01</code> 组合)</em>，但由于 <strong>人类阅读</strong> 这些 <strong>指令</strong> 非常难以阅读，加上使用这些指令编写程序的 <strong>耗时</strong> 太过于 <strong>冗长</strong>，所以，人们在此基础上再次制定了一套规范，采用特定的 <strong>人类可阅读</strong> 的代码编写，待到要执行时再 <strong>翻译</strong> 回特定二进制指令，这样就帮助了人们更加轻松地理解和阅读程序逻辑了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-4b5f50ce1ddc7077.png" alt=""></p>
<p>这也就是所谓现在的 <strong>“高级编程语言”</strong> 了。</p>
<p>上述 <strong>翻译</strong> 这个过程 <em>(其实相当复杂，涉及语法分析、语义分析、性能优化等等..)</em> 其实也是由一个特定程序来执行的，那 <strong>什么时候将源代码翻译成二进制指令呢？</strong>，不同的编程语言有不同的规定：</p>
<ul>
<li><strong>编译型语言</strong>：必须 <strong>提前</strong> 将所有源代码 <strong>一次性</strong> 转换成二进制指令，生成一个可执行文件 <em>(例如 Windows 下的 <code>.exe</code>)</em> 比如：C 语言、C++、Golang、汇编等。使用的转换工具我们称为 <strong>编译器</strong>。</li>
<li><strong>解释型语言</strong>：允许程序 <strong>一边执行一边转换</strong>，并且不会生成可执行程序，比如 Python、JavaScript、PHP 等。使用的转换工具我们称为 <strong>解释器</strong>。</li>
</ul>
<blockquote>
<p><strong>Java</strong> 和 <strong>C#</strong> 是一种比较奇葩的存在，它们是 <strong>半编译半解释型</strong> 的语言，源码需要先转换成一种中间文件 <em>(字节码文件)</em>，然后再把中间文件拿到 <strong>虚拟机</strong> 中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-e0d8266f6398eb03.png" alt=""></p>
<p><em>上图</em> 就展示了两种不同类型语言的执行流程的不同，两种方式对比起来总结如下：</p>
<ul>
<li><strong>编译型语言一般不能跨平台</strong>：对于不同的 CPU 来说，它们的指令集是有差异的，这就导致了 <strong>可执行文件</strong> <em>(翻译后的指令)</em> 不能跨平台，另外不同的系统之间的命令也会存在差异，例如 Linux 中睡眠是 <code>sleep()</code> 参数是毫秒，而 Windows 中是 <code>Sleep()</code> <em>(首字母大写)</em> 参数是秒，这就导致了 <strong>源代码也不能跨平台</strong>；</li>
<li><strong>解释型语言可跨平台</strong>：这一切都归功于 <strong>解释器</strong>，它本身就是一个可执行文件，官方只要针对不同的平台开发不同的解释器，那么解释器就能够根据相同的语法解析出同样功能的指令；</li>
<li><strong>编译型一般比解释型效率高</strong>：由于解释型是采取一边执行一边翻译的做法，所以会慢上一些，再加上我们强大的 <strong>编译器</strong> 会帮我们做许多代码优化的工作。</li>
</ul>
<h4 id="关于-Python"><a href="#关于-Python" class="headerlink" title="关于 Python"></a>关于 Python</h4><p><strong>Python</strong> 属于典型的解释型语言，所以运行 Python 程序需要解释器的支持，只要你在不同的平台安装了不同的解释器，你的代码就可以随时运行，不用担心任何兼容性问题，真正的 <strong>“一次编写，到处运行”</strong>。</p>
<p><strong>Python</strong> 几乎支持所有常见的平台，比如 Linux、Windows、Mac OS、Android、FreeBSD、Solaris、PocketPC 等，你所写的 Python 代码无需修改就能在这些平台上正确运行。也就是说，Python 的 <strong>可移植性</strong> 是很强的。</p>
<h2 id="面向对象-vs-面向过程"><a href="#面向对象-vs-面向过程" class="headerlink" title="面向对象 vs 面向过程"></a>面向对象 vs 面向过程</h2><p><strong>面向对象</strong> 和 <strong>面向过程</strong> 是我们使用计算机编程解决问题的两种不同方式的方案。</p>
<p><strong>面向过程</strong> 可以说是一种 <strong>基于事件 or 过程</strong> 来描述的编码方式，譬如「把大象放进冰箱」就可以描述成那经典的三个步骤，「把牛放进冰箱」又是另一个相似的经典三步，只是这样单独的事件 or 过程多了之后，随着项目复杂度的增加，项目会变得非常难以维护。</p>
<blockquote>
<p>软件危机最典型的例子莫过于 IBM 的 <code>System/360</code> 的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领 <code>2000</code> 多个程序员夜以继日的工作，共计花费了 <code>5000</code> 人一年的工作量，写出将近 <code>100</code> 万行的源码，总共投入 <code>5</code> 亿美元，是美国的 “曼哈顿” 原子弹计划投入的 <code>1/4</code>。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了史上最畅销的软件工程书籍。</p>
<ul>
<li>引用自：<a href="http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110880" target="_blank" rel="noopener">http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110880</a></li>
</ul>
</blockquote>
<p>尽管 <strong>结构化的程序设计</strong> <em>(将一个大问题逐步划分成一个一个的小问题)</em> 能够帮助我们解决一部分问题，但 <strong>面向过程</strong> 仍然有一些不符合人类惯有的思考方式，譬如说：我今天想去存钱，我不会说「请拿走我的银行卡和钱，然后在我卡上充值上相应的数目，最后把银行卡还给我谢谢」，而我只会说「存钱，谢谢」，因为人大部分时间都是基于 <strong>对象</strong> <em>(或者可以说角色)</em> 来思考的。</p>
<p>对于 <strong>面向过程</strong> 最好的总结可能是：<strong>「程序 = 算法 + 数据结构」</strong>，而对于 <strong>面向对象</strong> 来说则可以更改为：<strong>「程序 = 对象 + 交互」</strong>。</p>
<h2 id="Why-Python？"><a href="#Why-Python？" class="headerlink" title="Why Python？"></a>Why Python？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-8f4e79f34df177e6.png" alt=""></p>
<p>上面的 <em>漫画</em> 很好地说明了 Python 快速构建工具的能力，这也是 <code>Why Python</code> 的一大理由。下面根据惯例列举一些让我们足以选择 Python 的原因。</p>
<h4 id="初学者友善-容易明白且功能强大"><a href="#初学者友善-容易明白且功能强大" class="headerlink" title="初学者友善 | 容易明白且功能强大"></a>初学者友善 | 容易明白且功能强大</h4><p>Python 的设计足够简单和易于使用，这样使得初学者能够从中不断得获取到乐趣以继续 Python 之旅。</p>
<p>另外作为一种非常高级的语言，Python 读起来像英语，这减轻了编码初学者的许多语法学习压力。Python 为您处理了很多复杂性，因此它非常适合初学者，因为它使初学者可以专注于学习编程概念，而不必担心过多的细节。</p>
<p>Python 还一度被爆纳入高考，收编到小学课本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-451180aa92102c5b.png" alt=""></p>
<h4 id="非常灵活"><a href="#非常灵活" class="headerlink" title="非常灵活"></a>非常灵活</h4><p>作为一种 <strong>动态类型</strong> 的语言，Python 确实非常灵活。这意味着没有关于如何构建特征的硬性规则，并且使用不同的方法来解决问题将具有更大的灵活性 <em>（尽管 Python 哲学鼓励使用明显的方法来解决问题）</em>。此外，Python 也更宽容错误，因此您仍然可以编译并运行程序，直到遇到问题为止。</p>
<h4 id="越来越火爆"><a href="#越来越火爆" class="headerlink" title="越来越火爆"></a>越来越火爆</h4><p>Python 在诞生之初，因为其功能不好，运转功率低，不支持多核，根本没有并发性可言，在计算功能不那么好的年代，一直没有火爆起来，甚至很多人根本不知道有这门语言。</p>
<p>随着时代的发展，物理硬件功能不断提高，而软件的复杂性也不断增大，开发效率越来越被企业重视。因此就有了不一样的声音，在软件开发的初始阶段，性能并没有开发效率重要，没必然为了节省不到 <code>1ms</code> 的时间却让开发量增加好几倍，这样划不过来。也就是开发效率比机器效率更为重要，那么 Python 就逐渐得到越来越多开发者的亲睐了。</p>
<p>在 <code>12-14</code> 年，云计算升温，大量创业公司和互联网巨头挤进云计算领域，而最著名的云核算开源渠道 OpenStack 就是基于 Python 开发的。</p>
<p>随后几年的备受关注的人工智能，机器学习首选开发语言也是 Python。</p>
<p>至此，Python 已经成为互联网开发的焦点。在 <em>「Top 10 的编程语言走势图」</em> 可以看到，Python 已经跃居第三位，而且在 <code>2017</code> 年还成为了最受欢迎的语言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-e92d013f1190a7ca.png" alt=""></p>
<h4 id="工作机会-薪资待遇高"><a href="#工作机会-薪资待遇高" class="headerlink" title="工作机会 | 薪资待遇高"></a>工作机会 | 薪资待遇高</h4><ul>
<li>来自 <a href="gooroo.io">gooroo.io</a> 的薪资信息：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-501633340f69b855.png" alt=""></p>
<p>在天使榜上，Python 是需求第二高的技能，也是提供最高平均薪水的技能。</p>
<p>随着大数据的兴起，Python 开发人员需要作为数据科学家，尤其是因为 Python 可以轻松集成到 Web 应用程序中以执行需要机器学习的任务。</p>
<h2 id="快速体验-No-Hello-World"><a href="#快速体验-No-Hello-World" class="headerlink" title="快速体验 | No Hello World !"></a>快速体验 | No Hello World !</h2><p><code>Hello World</code> 似乎是学习编程绕不过去的东西，但使用 <strong>Python</strong>，我们来换点儿别的，Emmm.. 比如，一个 <strong>查询天气</strong> 的小程序 <em>(效果如下图)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-627c3e77b32f2db0.gif" alt=""></p>
<h4 id="源码-amp-解释"><a href="#源码-amp-解释" class="headerlink" title="源码 &amp; 解释"></a>源码 &amp; 解释</h4><p><code>http://wthrcdn.etouch.cn/weather_mini?city=xxx</code> 这个网址可以返回任意城市昨日以及 5 天内的天气预报，包括气温、指数、空气质量、风力等，你可以用浏览器试着访问一下，你会得到一个 <code>weather_mini</code> 的文件，里面就包含了我们想要的一些数据。</p>
<p>不过这里由于我们发起了网络请求用到了第三方库 <code>requests</code>，所以在运行之前还需要使用 <code>pip install requests</code> 命令把该库下载到 Python 的安装目录下。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>
<span class="token keyword">import</span> requests

<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    city <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入城市,回车退出:\n'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> city<span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    req <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://wthrcdn.etouch.cn/weather_mini?city=%s'</span> <span class="token operator">%</span> city<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
</code></pre>
<h4 id="运行你的代码"><a href="#运行你的代码" class="headerlink" title="运行你的代码"></a>运行你的代码</h4><p>你可以在 <strong>当前文件夹</strong> 下执行命令： <code>python hello_python.py</code>，或是使用 <code>python &lt;源文件路径&gt;</code> 运行也行，例如，如果我是 Windows 用户并且将上述源文件保存在了 <code>D</code> 盘下面，那就可以执行 <code>python D:\hello_python.py</code>，然后你就可以看到上面的效果了。当然如果使用 IDE 将更加方便。</p>
<h2 id="Python-vs-Java"><a href="#Python-vs-Java" class="headerlink" title="Python vs Java"></a>Python vs Java</h2><p>引入一张比较著名的图吧，可以很明显地感受到 Python 在写法上要简洁一些吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-60e9032d6e669f4c.png" alt=""></p>
<h1 id="二、Python-基本语法简介"><a href="#二、Python-基本语法简介" class="headerlink" title="二、Python 基本语法简介"></a>二、Python 基本语法简介</h1><p>Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <code>{}</code> 来控制类，函数以及其他逻辑判断。Python 最具特色的就是用 <strong>缩进</strong> 来写模块。</p>
<h2 id="2-0-注释"><a href="#2-0-注释" class="headerlink" title="2.0 注释"></a>2.0 注释</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第一个注释</span>
<span class="token comment" spellcheck="true"># 第二个注释</span>

<span class="token triple-quoted-string string">'''
第三注释
第四注释
'''</span>

<span class="token triple-quoted-string string">"""
第五注释
第六注释
"""</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Python!"</span><span class="token punctuation">)</span></code></pre>
<h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>Python 中的变量赋值不需要类型声明。Python 有五个标准的数据类型：</p>
<ol>
<li><strong>Numbers（数字）</strong>：Python3 中有四种数字类型 <em>(没有 Python2 中的 Long)</em>，分别是 <code>int</code> 长整型、<code>bool</code> 布尔、<code>float</code> 浮点数、<code>complex</code> 复数 <em>(1 + 2j)</em>；</li>
<li><strong>String（字符串）</strong>：Python 中字符串不能改变，并且没有单独的字符类型，一个字符就是长度为 1 的字符串；</li>
<li><strong>Tuple（元组）</strong>：类似于 List，但不能二次赋值，相当于只读列表。eg：<code>(&#39;test1&#39;, &#39;test2&#39;)</code></li>
<li><strong>List（列表）</strong>：类似 Java 中的 Array 类型。eg:<code>[1, 2, ,3]</code></li>
<li><strong>Dictionary（字典）</strong>：类似于 Java 的 Map 类型。eg:<code>{a: 1, b: 2}</code></li>
</ol>
<blockquote>
<p><code>set</code> 集合也属于数据结构，它是一个 <strong>无序</strong> 且 <strong>不重复</strong> 的元素序列。可以使用大括号 <code>{ }</code> 或者 <code>set()</code> 函数创建集合，注意：创建一个空集合必须用 <code>set()</code> 而不是 <code>{ }</code>，因为 <code>{ }</code> 是用来创建一个空字典。</p>
</blockquote>
<pre class=" language-python"><code class="language-python">str <span class="token operator">=</span> <span class="token string">'Hello World!'</span>
<span class="token keyword">print</span> str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>      <span class="token comment" spellcheck="true"># 输出字符串中第三个至第五个之间的字符串</span>

list <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">786</span> <span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'john'</span><span class="token punctuation">,</span> <span class="token number">70.2</span> <span class="token punctuation">]</span>
<span class="token keyword">print</span> list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># 输出第二个至第三个元素</span>

tuple <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">786</span> <span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'john'</span><span class="token punctuation">,</span> <span class="token number">70.2</span> <span class="token punctuation">)</span>
<span class="token keyword">print</span> tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># 输出第二个至第三个的元素</span>

tinydict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'john'</span><span class="token punctuation">,</span><span class="token string">'code'</span><span class="token punctuation">:</span><span class="token number">6734</span><span class="token punctuation">,</span> <span class="token string">'dept'</span><span class="token punctuation">:</span> <span class="token string">'sales'</span><span class="token punctuation">}</span>
<span class="token keyword">print</span> tinydict<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>              <span class="token comment" spellcheck="true"># 输出键为 2 的值</span></code></pre>
<h2 id="2-2-条件语句"><a href="#2-2-条件语句" class="headerlink" title="2.2 条件语句"></a>2.2 条件语句</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 当判断条件为 1 个值时</span>
flag <span class="token operator">=</span> <span class="token boolean">False</span>
name <span class="token operator">=</span> <span class="token string">'luren'</span>
<span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">'python'</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 判断变量否为'python'</span>
    flag <span class="token operator">=</span> <span class="token boolean">True</span>           <span class="token comment" spellcheck="true"># 条件成立时设置标志为真</span>
    <span class="token keyword">print</span> <span class="token string">'welcome boss'</span>  <span class="token comment" spellcheck="true"># 并输出欢迎信息</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> name            <span class="token comment" spellcheck="true"># 条件不成立时输出变量名称</span>

<span class="token comment" spellcheck="true"># 当判断条件为多个值时</span>
num <span class="token operator">=</span> <span class="token number">5</span>     
<span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 判断num的值</span>
    <span class="token keyword">print</span> <span class="token string">'boss'</span>        
<span class="token keyword">elif</span> num <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> <span class="token string">'user'</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> <span class="token string">'roadman'</span>       <span class="token comment" spellcheck="true"># 条件均不成立时输出</span></code></pre>
<h2 id="2-3-循环"><a href="#2-3-循环" class="headerlink" title="2.3 循环"></a>2.3 循环</h2><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>在 Python 中没有 <code>do..while</code> 的循环</p>
<pre class=" language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 小于 5"</span><span class="token punctuation">)</span>
   count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 大于或等于 5"</span><span class="token punctuation">)</span></code></pre>
<h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h4><p><code>for..in</code> 适用于 <code>list/ dict/ set</code> 数据类型，如果需要遍历数字序列，我们也可以借助 <code>range(min, max, step)</code> 函数来生成数列。</p>
<pre class=" language-python"><code class="language-python">sites <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Baidu"</span><span class="token punctuation">,</span> <span class="token string">"Google"</span><span class="token punctuation">,</span><span class="token string">"Runoob"</span><span class="token punctuation">,</span><span class="token string">"Taobao"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> site <span class="token keyword">in</span> sites<span class="token punctuation">:</span>
    <span class="token keyword">if</span> site <span class="token operator">==</span> <span class="token string">"Runoob"</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"菜鸟教程!"</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"循环数据 "</span> <span class="token operator">+</span> site<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有循环数据!"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"完成循环!"</span><span class="token punctuation">)</span>


<span class="token comment" spellcheck="true"># 输出 0/ 3/ 6/ 9</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 替换成 range(5) 则输出 0/ 1/ 2/ 3/ 4</span>
<span class="token comment" spellcheck="true"># 替换成 range(5,9) 则输出 5/ 6/ 7/ 8</span></code></pre>
<h2 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h2><h4 id="函数基本定义和使用"><a href="#函数基本定义和使用" class="headerlink" title="函数基本定义和使用"></a>函数基本定义和使用</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 计算面积函数</span>
<span class="token keyword">def</span> <span class="token function">area</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> width <span class="token operator">*</span> height

<span class="token keyword">def</span> <span class="token function">print_welcome</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Welcome"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>

print_welcome<span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span>
w <span class="token operator">=</span> <span class="token number">4</span>
h <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"width ="</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token string">" height ="</span><span class="token punctuation">,</span> h<span class="token punctuation">,</span> <span class="token string">" area ="</span><span class="token punctuation">,</span> area<span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>在 Python 中，类型属于对象，变量是没有类型的，例如 <code>name = &quot;wmyskxz&quot;</code>，则 <code>&quot;wmyskxz&quot;</code> 是 String 类型，而变量 <code>name</code> 仅仅是一个对象的引用。</p>
<p>Python 中一切都是对象，严格意义我们 <strong>不能说值传递还是引用传递</strong>，我们应该说传 <strong>不可变对象</strong> <em>(string、tuples、number 不可变)</em> 和 <strong>传可变对象</strong> <em>(list、dict 可变)</em>。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">############################################</span>
<span class="token comment" spellcheck="true"># 传递不可变对象</span>
<span class="token keyword">def</span> <span class="token function">ChangeInt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">10</span>

b <span class="token operator">=</span> <span class="token number">2</span>
ChangeInt<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token keyword">print</span> b <span class="token comment" spellcheck="true"># 结果是 2</span>

<span class="token comment" spellcheck="true">############################################</span>
<span class="token comment" spellcheck="true"># 传递可变对象</span>
<span class="token keyword">def</span> <span class="token function">changeme</span><span class="token punctuation">(</span> mylist <span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token string">"修改传入的列表"</span>
   mylist<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"函数内取值: "</span><span class="token punctuation">,</span> mylist<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [10, 20, 30, [1, 2, 3, 4]]</span>
   <span class="token keyword">return</span>

<span class="token comment" spellcheck="true"># 调用changeme函数</span>
mylist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span>
changeme<span class="token punctuation">(</span> mylist <span class="token punctuation">)</span>
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"函数外取值: "</span><span class="token punctuation">,</span> mylist<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [10, 20, 30, [1, 2, 3, 4]]</span>
<span class="token comment" spellcheck="true"># 函数内外值一致，因为都同属于同一个引用</span></code></pre>
<h2 id="2-5-class-类"><a href="#2-5-class-类" class="headerlink" title="2.5 class 类"></a>2.5 class 类</h2><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">people</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true">#定义基本属性</span>
    name <span class="token operator">=</span> <span class="token string">''</span>
    age <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment" spellcheck="true">#定义私有属性,私有属性在类外部无法直接进行访问</span>
    __weight <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment" spellcheck="true">#定义构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>n<span class="token punctuation">,</span>a<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> n
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> a
        self<span class="token punctuation">.</span>__weight <span class="token operator">=</span> w
    <span class="token keyword">def</span> <span class="token function">speak</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 说: 我 %d 岁。"</span> <span class="token operator">%</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>self<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 实例化类</span>
p <span class="token operator">=</span> people<span class="token punctuation">(</span><span class="token string">'wmyskxz'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>speak<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># wmyskxz 说: 我 10 岁。</span></code></pre>
<h4 id="继承-amp-多继承-amp-方法重写"><a href="#继承-amp-多继承-amp-方法重写" class="headerlink" title="继承 &amp; 多继承 &amp; 方法重写"></a>继承 &amp; 多继承 &amp; 方法重写</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 单继承</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClassName</span><span class="token punctuation">(</span>BaseClassName1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>statement<span class="token number">-1</span><span class="token operator">></span>
    <span class="token punctuation">.</span>
    <span class="token operator">&lt;</span>statement<span class="token operator">-</span>N<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 多继承</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClassName</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">,</span> Base3<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>statement<span class="token number">-1</span><span class="token operator">></span>
    <span class="token punctuation">.</span>
    <span class="token punctuation">.</span>
    <span class="token punctuation">.</span>
    <span class="token operator">&lt;</span>statement<span class="token operator">-</span>N<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 方法重写演示</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 定义父类</span>
   <span class="token keyword">def</span> <span class="token function">myMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'调用父类方法'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 定义子类</span>
   <span class="token keyword">def</span> <span class="token function">myMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'调用子类方法'</span><span class="token punctuation">)</span>

c <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 子类实例</span>
c<span class="token punctuation">.</span>myMethod<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 子类调用重写方法</span>
super<span class="token punctuation">(</span>Child<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>myMethod<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#用子类对象调用父类已被覆盖的方法</span>
<span class="token comment" spellcheck="true"># 先输出 "调用子类方法" 再输出 "调用父类方法"</span></code></pre>
<h2 id="2-6-module-模块"><a href="#2-6-module-模块" class="headerlink" title="2.6 module 模块"></a>2.6 module 模块</h2><p>一个 <code>.py</code> 文件就是一个模块，想要使用其他 <code>.py</code> 文件中的方法就需要引入进来。</p>
<ol>
<li><code>import [module]</code></li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入整个random模块，可以是内置/当前路径</span>
<span class="token keyword">import</span> random
<span class="token comment" spellcheck="true"># 使用 `random` 模块下的 `randint` 方法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<ol start="2">
<li><code>from [module] import [name1, name2, ...]</code></li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 从 `random` 模块里导入其中一个方法 `randint`</span>
<span class="token keyword">from</span> random <span class="token keyword">import</span> randint
<span class="token comment" spellcheck="true"># 不一样的是，使用 `randint` 的就不需要先写 `random` 了</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<ol start="3">
<li><code>import [module] as [new_name]</code></li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 但这个名字可能跟其他地方有冲突，因此改名成 `rd`</span>
<span class="token keyword">import</span> random <span class="token keyword">as</span> rd
<span class="token comment" spellcheck="true"># 使用 `rd` 这个名称取代原本的 `random`</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>rd<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<ol start="4">
<li><code>from [module] import *</code></li>
</ol>
<p><strong>不推荐</strong>，容易造成名称冲突，降低可读性和可维护性。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Import 所有 `random` module 底下的东西</span>
<span class="token keyword">from</span> random <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token comment" spellcheck="true"># 使用 `randint` 的时候也不需要先写 `random`</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="module-搜索路径"><a href="#module-搜索路径" class="headerlink" title="module 搜索路径"></a>module 搜索路径</h4><p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：</p>
<ol>
<li>当前目录</li>
<li>如果不在当前目录，Python 则搜索在 shell 变量 <code>PYTHONPATH</code> 下的每个目录。</li>
<li>如果都找不到，Python 会察看默认路径。UNIX 下，默认路径一般为 <code>/usr/local/lib/python/</code>。</li>
</ol>
<h2 id="2-7-package-包"><a href="#2-7-package-包" class="headerlink" title="2.7 package 包"></a>2.7 package 包</h2><p>把两个 module 放在一个新的目录 <code>sample_package</code>，再新增 <code>_init__.py</code> <em>(可以是空，但不能没有)</em>，宣称自己是一个 package :</p>
<pre><code>sample_package
  |-- __init__.py
  |-- 1.py
  |-- 2.py</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># package_runoob 同级目录下创建 test.py 来调用 package_runoob 包</span>
<span class="token comment" spellcheck="true"># 导入包</span>
<span class="token keyword">from</span> package_runoob<span class="token punctuation">.</span>runoob1 <span class="token keyword">import</span> runoob1
<span class="token keyword">from</span> package_runoob<span class="token punctuation">.</span>runoob2 <span class="token keyword">import</span> runoob2

runoob1<span class="token punctuation">(</span><span class="token punctuation">)</span>
runoob2<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>单个py文件就是一个 module，而当多个 <code>.py</code> 文件 + <code>__init__.py</code> 文件时，就等于 package。</p>
</blockquote>
<h1 id="三、基本代码规范"><a href="#三、基本代码规范" class="headerlink" title="三、基本代码规范"></a>三、基本代码规范</h1><p><strong>代码规范</strong> 再怎么强调也不为过：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-6467610c0eb161a8.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://codingpy.com/article/programmers-daily-what-idiot-wrote-this-crappy-code/" target="_blank" rel="noopener">https://codingpy.com/article/programmers-daily-what-idiot-wrote-this-crappy-code/</a></li>
</ul>
<h2 id="3-1-命名规范"><a href="#3-1-命名规范" class="headerlink" title="3.1 命名规范"></a>3.1 命名规范</h2><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>模块尽量使用 <strong>小写命名</strong>，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 正确的模块名</span>
<span class="token keyword">import</span> decoder
<span class="token keyword">import</span> html_parser

<span class="token comment" spellcheck="true"># 不推荐的模块名</span>
<span class="token keyword">import</span> Decoder</code></pre>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><ul>
<li>类名使用 <strong>驼峰</strong> (CamelCase)命名风格，首字母大写，私有类可用一个下划线开头</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Farm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">AnimalFarm</span><span class="token punctuation">(</span>Farm<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">_PrivateFarm</span><span class="token punctuation">(</span>Farm<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span></code></pre>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>函数名 <strong>一律小写</strong>，如有多个单词，用下划线隔开</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token keyword">def</span> <span class="token function">run_with_env</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span> </code></pre>
<ul>
<li>私有函数在函数前加一个下划线 <code>_</code></li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">_private_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span></code></pre>
<h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><ul>
<li>变量名尽量 <strong>小写</strong>, 如有多个单词，用下划线隔开</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    count <span class="token operator">=</span> <span class="token number">0</span>
    school_name <span class="token operator">=</span> <span class="token string">''</span></code></pre>
<ul>
<li>常量使用以下划线分隔的 <strong>大写</strong> 命名</li>
</ul>
<pre class=" language-python"><code class="language-python">MAX_CLIENT <span class="token operator">=</span> <span class="token number">100</span>
MAX_CONNECTION <span class="token operator">=</span> <span class="token number">1000</span>
CONNECTION_TIMEOUT <span class="token operator">=</span> <span class="token number">600</span></code></pre>
<h2 id="3-2-基本编码规范"><a href="#3-2-基本编码规范" class="headerlink" title="3.2 基本编码规范"></a>3.2 基本编码规范</h2><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><ul>
<li>统一使用 4 个空格进行缩进</li>
</ul>
<h4 id="行宽"><a href="#行宽" class="headerlink" title="行宽"></a>行宽</h4><p>每行代码尽量不超过 <code>80</code> 个字符(在特殊情况下可以略微超过 <code>80</code> ，但最长不得超过 <code>120</code>)</p>
<p>理由：</p>
<ul>
<li>这在查看 <code>side-by-side</code> 的 <code>diff</code> 时很有帮助</li>
<li>方便在控制台下查看代码</li>
<li>太长可能是设计有缺陷</li>
</ul>
<h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>简单说，自然语言使用双引号，机器标示使用单引号，因此 <strong>代码里</strong> 多数应该使用 <strong>单引号</strong></p>
<ul>
<li><strong>自然语言</strong> 使用双引号 <code>&quot;...&quot;</code>，例如错误信息；很多情况还是 unicode，使用u”你好世界”</li>
<li><strong>机器标识</strong> 使用单引号 ‘<code>...&#39;</code>，例如 dict 里的 key</li>
<li><strong>正则表达式</strong> 使用原生的双引号 <code>r&quot;...&quot;</code></li>
<li><strong>文档字符串</strong> (docstring) 使用三个双引号 <code>&quot;&quot;&quot;......&quot;&quot;&quot;</code></li>
</ul>
<h4 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h4><ul>
<li>import 语句应该分行书写</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 正确的写法</span>
<span class="token keyword">import</span> os
<span class="token keyword">import</span> sys

<span class="token comment" spellcheck="true"># 不推荐的写法</span>
<span class="token keyword">import</span> sys<span class="token punctuation">,</span>os

<span class="token comment" spellcheck="true"># 正确的写法</span>
<span class="token keyword">from</span> subprocess <span class="token keyword">import</span> Popen<span class="token punctuation">,</span> PIPE</code></pre>
<ul>
<li>import 语句应该使用 absolute import</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 正确的写法</span>
<span class="token keyword">from</span> foo<span class="token punctuation">.</span>bar <span class="token keyword">import</span> Bar

<span class="token comment" spellcheck="true"># 不推荐的写法</span>
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>bar <span class="token keyword">import</span> Bar</code></pre>
<ul>
<li>import 语句应该放在文件头部，置于模块说明及 <code>DocString</code> 之后，于全局变量之前；</li>
<li>import 语句应该按照顺序排列，每组之间用一个空行分隔</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> sys

<span class="token keyword">import</span> msgpack
<span class="token keyword">import</span> zmq

<span class="token keyword">import</span> foo</code></pre>
<ul>
<li>导入其他模块的类定义时，可以使用相对导入</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> myclass <span class="token keyword">import</span> MyClass</code></pre>
<ul>
<li>如果发生命名冲突，则可使用命名空间</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> bar
<span class="token keyword">import</span> foo<span class="token punctuation">.</span>bar

bar<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span><span class="token punctuation">)</span>
foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="DocString"><a href="#DocString" class="headerlink" title="DocString"></a>DocString</h4><p>DocString 的规范中最其本的两点：</p>
<ol>
<li>所有的公共模块、函数、类、方法，都应该写 DocString 。私有方法不一定需要，但应该在 <code>def</code> 后提供一个块注释来说明。</li>
<li>DocString 的结束”””应该独占一行，除非此 DocString 只有一行。</li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""Return a foobar
Optional plotz says to frobnicate the bizbaz first.
"""</span>

<span class="token triple-quoted-string string">"""Oneline docstring"""</span></code></pre>
<h2 id="3-3-注释规范"><a href="#3-3-注释规范" class="headerlink" title="3.3 注释规范"></a>3.3 注释规范</h2><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>在代码的 <strong>关键部分</strong>(或比较复杂的地方), 能写注释的要尽量写注释</li>
<li>比较重要的注释段, 使用多个等号隔开, 可以更加醒目, <strong>突出</strong> 重要性</li>
</ul>
<pre class=" language-python"><code class="language-python">app <span class="token operator">=</span> create_app<span class="token punctuation">(</span>name<span class="token punctuation">,</span> options<span class="token punctuation">)</span>


<span class="token comment" spellcheck="true"># =====================================</span>
<span class="token comment" spellcheck="true"># 请勿在此处添加 get post等app路由行为 !!!</span>
<span class="token comment" spellcheck="true"># =====================================</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="文档注释（DocString）"><a href="#文档注释（DocString）" class="headerlink" title="文档注释（DocString）"></a>文档注释（DocString）</h4><ul>
<li>文档注释以 “”” 开头和结尾, 首行不换行, 如有多行, 末行必需换行, 以下是Google的docstring风格示例</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>
<span class="token triple-quoted-string string">"""Example docstrings.

This module demonstrates documentation as specified by the `Google Python
Style Guide`_. Docstrings may extend over multiple lines. Sections are created
with a section header and a colon followed by a block of indented text.

Example:
    Examples can be given using either the ``Example`` or ``Examples``
    sections. Sections support any reStructuredText formatting, including
    literal blocks::

        $ python example_google.py

Section breaks are created by resuming unindented text. Section breaks
are also implicitly created anytime a new section starts.
"""</span></code></pre>
<ul>
<li>不要在文档注释复制函数定义原型, 而是具体描述其具体内容, 解释具体参数和返回值等</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#  不推荐的写法(不要写函数原型等废话)</span>
<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""function(a, b) -> list"""</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>


<span class="token comment" spellcheck="true">#  正确的写法</span>
<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""计算并返回a到b范围内数据的平均值"""</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>
<ul>
<li>对函数参数、返回值等的说明采用 <code>numpy</code> 标准, 如下所示</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""在这里写函数的一句话总结(如: 计算平均值).

    这里是具体描述.

    参数
    ----------
    arg1 : int
        arg1的具体描述
    arg2 : int
        arg2的具体描述

    返回值
    -------
    int
        返回值的具体描述

    参看
    --------
    otherfunc : 其它关联函数等...

    示例
    --------
    示例使用doctest格式, 在`>>>`后的代码可以被文档测试工具作为测试用例自动运行

    >>> a=[1,2,3]
    >>> print [x + 3 for x in a]
    [4, 5, 6]
    """</span></code></pre>
<blockquote>
<p>更多细致详细的规范可以参考：</p>
<ol>
<li><strong>Google 开源项目指南</strong> - <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/</a></li>
<li><strong>官方 PEP 8 代码规范</strong> - <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></li>
</ol>
</blockquote>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ol>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://juejin.im/post/5e7429a16fb9a07ccc460fe7" target="_blank" rel="noopener">https://juejin.im/post/5e7429a16fb9a07ccc460fe7</a></li>
<li>React入门学习 - <a href="https://juejin.im/post/5da5e9e8e51d4525292d2ed7" target="_blank" rel="noopener">https://juejin.im/post/5da5e9e8e51d4525292d2ed7</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>WhyStudyPython.md | TwoWater - <a href="https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python0/WhyStudyPython.md" target="_blank" rel="noopener">https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python0/WhyStudyPython.md</a></li>
<li>C 语言中文网 | Python 系列教程 - <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">http://c.biancheng.net/python/</a></li>
<li>Crossin的编程教室 - <a href="https://python666.cn/" target="_blank" rel="noopener">https://python666.cn/</a></li>
<li>计算机和编程语言的发展历史 - <a href="https://blog.csdn.net/abc6368765/article/details/83990756" target="_blank" rel="noopener">https://blog.csdn.net/abc6368765/article/details/83990756</a></li>
<li>面向对象葵花宝典 - <a href="http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110879" target="_blank" rel="noopener">http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110879</a></li>
<li>RUNOOB | Python3 系列教程 - <a href="ttps://www.runoob.com/python3">ttps://www.runoob.com/python3</a></li>
<li>Python 基础语法 | springleo’sblog - <a href="https://lq782655835.github.io/blogs/tools/python-grammar.html#_1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">https://lq782655835.github.io/blogs/tools/python-grammar.html#_1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">
      Redis(9)——史上最强【集群】入门实践教程
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月17日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-80c61b0ae541a750.png" alt=""></p>
<h1 id="一、Redis-集群概述"><a href="#一、Redis-集群概述" class="headerlink" title="一、Redis 集群概述"></a>一、Redis 集群概述</h1><h4 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h4><p>到 <a href="#相关阅读">目前</a> 为止，我们所学习的 Redis 都是 <strong>单机版</strong> 的，这也就意味着一旦我们所依赖的 Redis 服务宕机了，我们的主流程也会受到一定的影响，这当然是我们不能够接受的。</p>
<p>所以一开始我们的想法是：搞一台备用机。这样我们就可以在一台服务器出现问题的时候切换动态地到另一台去：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c48d255bc0b13672.gif" alt=""></p>
<p>幸运的是，两个节点数据的同步我们可以使用 Redis 的 <strong>主从同步</strong> 功能帮助到我们，这样一来，有个备份，心里就踏实多了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-4a32b9efa3885655.jpg" alt=""></p>
<h4 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h4><p>后来因为某种神秘力量，Redis 老会在莫名其妙的时间点出问题 <em>(比如半夜 2 点)</em>，我总不能 24 小时时刻守在电脑旁边切换节点吧，于是另一个想法又开始了：给所有的节点找一个 <strong>“管家”</strong>，自动帮我监听照顾节点的状态并切换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-de8d9ce9e77bf211.gif" alt=""></p>
<p>这大概就是 <strong>Redis 哨兵</strong> <em>(Sentinel)</em> 的简单理解啦。什么？管家宕机了怎么办？相较于有大量请求的 Redis 服务来说，管家宕机的概率就要小得多啦.. 如果真的宕机了，我们也可以直接切换成当前可用的节点保证可用..</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c7657fb8140d7cc6.jpg" alt=""></p>
<h4 id="Redis-集群化"><a href="#Redis-集群化" class="headerlink" title="Redis 集群化"></a>Redis 集群化</h4><p>好了，通过上面的一些解决方案我们对 Redis 的 <strong>稳定性</strong> 稍微有了一些底气了，但单台节点的计算能力始终有限，所谓人多力量大，如果我们把 <strong>多个节点组合</strong> 成 <strong>一个可用的工作节点</strong>，那就大大增加了 Redis 的  <strong>高可用、可扩展、分布式、容错</strong> 等特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-8957aa6d1484c5de.png" alt=""></p>
<h1 id="二、主从复制"><a href="#二、主从复制" class="headerlink" title="二、主从复制"></a>二、主从复制</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p>在 <strong>Redis</strong> 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 <code>slaveof</code> 选项，让一个服务器去复制另一个服务器，以下三种方式是 <strong>完全等效</strong> 的：</p>
<ul>
<li><strong>配置文件</strong>：在从服务器的配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li><strong>启动命令</strong>：redis-server 启动命令后加入 <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li><strong>客户端命令</strong>：Redis 服务器启动后，直接通过客户端执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，让该 Redis 实例成为从节点。</li>
</ul>
<p>需要注意的是：<strong>主从复制的开启，完全是在从节点发起的，不需要我们在主节点做任何事情。</strong></p>
<h4 id="第一步：本地启动两个节点"><a href="#第一步：本地启动两个节点" class="headerlink" title="第一步：本地启动两个节点"></a>第一步：本地启动两个节点</h4><p>在正确安装好 Redis 之后，我们可以使用 <code>redis-server --port &lt;port&gt;</code> 的方式指定创建两个不同端口的 Redis 实例，例如，下方我分别创建了一个 <code>6379</code> 和 <code>6380</code> 的两个 Redis 实例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个端口为 6379 的 Redis 实例</span>
redis-server --port 6379
<span class="token comment" spellcheck="true"># 创建一个端口为 6380 的 Redis 实例</span>
redis-server --port 6380</code></pre>
<p>此时两个 Redis 节点启动后，都默认为 <strong>主节点</strong>。</p>
<h4 id="第二步：建立复制"><a href="#第二步：建立复制" class="headerlink" title="第二步：建立复制"></a>第二步：建立复制</h4><p>我们在 <code>6380</code> 端口的节点中执行 <code>slaveof</code> 命令，使之变为从节点：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在 6380 端口的 Redis 实例中使用控制台</span>
redis-cli -p 6380
<span class="token comment" spellcheck="true"># 成为本地 6379 端口实例的从节点</span>
127.0.0.1:6380<span class="token operator">></span> SLAVEOF 127.0.0.1ø 6379
OK</code></pre>
<h4 id="第三步：观察效果"><a href="#第三步：观察效果" class="headerlink" title="第三步：观察效果"></a>第三步：观察效果</h4><p>下面我们来验证一下，主节点的数据是否会复制到从节点之中：</p>
<ul>
<li>先在 <strong>从节点</strong> 中查询一个 <strong>不存在</strong> 的 key：<br>```bash</li>
</ul>
<p>127.0.0.1:6380&gt; GET mykey<br>(nil)</p>
<pre><code>- 再在 **主节点** 中添加这个 key：
```bash
127.0.0.1:6379&gt; SET mykey myvalue
OK</code></pre><ul>
<li>此时再从 <strong>从节点</strong> 中查询，会发现已经从 <strong>主节点</strong> 同步到 <strong>从节点</strong>：<br>```bash</li>
</ul>
<p>127.0.0.1:6380&gt; GET mykey<br>“myvalue”</p>
<pre><code>
#### 第四步：断开复制

通过 `slaveof &lt;masterip&gt; &lt;masterport&gt;` 命令建立主从复制关系以后，可以通过 `slaveof no one` 断开。需要注意的是，从节点断开复制后，**不会删除已有的数据**，只是不再接受主节点新的数据变化。

从节点执行 `slaveof no one` 之后，从节点和主节点分别打印日志如下：、

```bash
# 从节点打印日志
61496:M 17 Mar 2020 08:10:22.749 # Connection with master lost.
61496:M 17 Mar 2020 08:10:22.749 * Caching the disconnected master state.
61496:M 17 Mar 2020 08:10:22.749 * Discarding previously cached master state.
61496:M 17 Mar 2020 08:10:22.749 * MASTER MODE enabled (user request from &#39;id=4 addr=127.0.0.1:55096 fd=8 name= age=1664 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof&#39;)

# 主节点打印日志
61467:M 17 Mar 2020 08:10:22.749 # Connection with replica 127.0.0.1:6380 lost.</code></pre><h2 id="实现原理简析"><a href="#实现原理简析" class="headerlink" title="实现原理简析"></a>实现原理简析</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。下面我们来进行一些必要的说明。</p>
<h4 id="身份验证-主从复制安全问题"><a href="#身份验证-主从复制安全问题" class="headerlink" title="身份验证 | 主从复制安全问题"></a>身份验证 | 主从复制安全问题</h4><p>在上面的 <strong>快速体验</strong> 过程中，你会发现 <code>slaveof</code> 这个命令居然不需要验证？这意味着只要知道了 ip 和端口就可以随意拷贝服务器上的数据了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-d0c7a74da972fca3.jpg" alt=""></p>
<p>那当然不能够了，我们可以通过在 <strong>主节点</strong> 配置 <code>requirepass</code> 来设置密码，这样就必须在 <strong>从节点</strong> 中对应配置好 <code>masterauth</code> 参数 <em>(与主节点 <code>requirepass</code> 保持一致)</em> 才能够进行正常复制了。</p>
<h4 id="SYNC-命令是一个非常耗费资源的操作"><a href="#SYNC-命令是一个非常耗费资源的操作" class="headerlink" title="SYNC 命令是一个非常耗费资源的操作"></a>SYNC 命令是一个非常耗费资源的操作</h4><p>每次执行 <code>SYNC</code> 命令，主从服务器需要执行如下动作：</p>
<ol>
<li><strong>主服务器</strong> 需要执行 <code>BGSAVE</code> 命令来生成 RDB 文件，这个生成操作会 <strong>消耗</strong> 主服务器大量的 <strong>CPU、内存和磁盘 I/O 的资源</strong>；</li>
<li><strong>主服务器</strong> 需要将自己生成的 RDB 文件 发送给从服务器，这个发送操作会 <strong>消耗</strong> 主服务器 <strong>大量的网络资源</strong> <em>(带宽和流量)</em>，并对主服务器响应命令请求的时间产生影响；</li>
<li>接收到 RDB 文件的 <strong>从服务器</strong> 需要载入主服务器发来的 RBD 文件，并且在载入期间，从服务器 <strong>会因为阻塞而没办法处理命令请求</strong>；</li>
</ol>
<p>特别是当出现 <strong>断线重复制</strong> 的情况是时，为了让从服务器补足断线时确实的那一小部分数据，却要执行一次如此耗资源的 <code>SYNC</code> 命令，显然是不合理的。</p>
<h4 id="PSYNC-命令的引入"><a href="#PSYNC-命令的引入" class="headerlink" title="PSYNC 命令的引入"></a>PSYNC 命令的引入</h4><p>所以在 <strong>Redis 2.8</strong> 中引入了 <code>PSYNC</code> 命令来代替 <code>SYNC</code>，它具有两种模式：</p>
<ol>
<li><strong>全量复制：</strong> 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作；</li>
<li><strong>部分复制：</strong> 用于网络中断等情况后的复制，只将 <strong>中断期间主节点执行的写命令</strong> 发送给从节点，与全量复制相比更加高效。<strong>需要注意</strong> 的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制；</li>
</ol>
<p>部分复制的原理主要是靠主从节点分别维护一个 <strong>复制偏移量</strong>，有了这个偏移量之后断线重连之后一比较，之后就可以仅仅把从服务器断线之后确实的这部分数据给补回来了。</p>
<blockquote>
<p>更多的详细内容可以参考下方 <em>参考资料 3</em></p>
</blockquote>
<h1 id="三、Redis-Sentinel-哨兵"><a href="#三、Redis-Sentinel-哨兵" class="headerlink" title="三、Redis Sentinel 哨兵"></a>三、Redis Sentinel 哨兵</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h2 id="快速体验-1"><a href="#快速体验-1" class="headerlink" title="快速体验"></a>快速体验</h2><h4 id="第一步：创建主从节点配置文件并启动"><a href="#第一步：创建主从节点配置文件并启动" class="headerlink" title="第一步：创建主从节点配置文件并启动"></a>第一步：创建主从节点配置文件并启动</h4><p>正确安装好 Redis 之后，我们去到 Redis 的安装目录 <em>(mac 默认在 <code>/usr/local/</code>)*，找到 <code>redis.conf</code> 文件复制三份分别命名为 <code>redis-master.conf</code>/<code>redis-slave1.conf</code>/<code>redis-slave2.conf</code>，分别作为 <code>1</code> 个主节点和 <code>2</code> 个从节点的配置文件 *(下图演示了我本机的 <code>redis.conf</code> 文件的位置)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-34de77bfca56d32e.png" alt=""></p>
<p>打开可以看到这个 <code>.conf</code> 后缀的文件里面有很多说明的内容，全部删除然后分别改成下面的样子：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#redis-master.conf</span>
port 6379
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6379.log"</span>
dbfilename <span class="token string">"dump-6379.rdb"</span>

<span class="token comment" spellcheck="true">#redis-slave1.conf</span>
port 6380
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6380.log"</span>
dbfilename <span class="token string">"dump-6380.rdb"</span>
slaveof 127.0.0.1 6379

<span class="token comment" spellcheck="true">#redis-slave2.conf</span>
port 6381
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6381.log"</span>
dbfilename <span class="token string">"dump-6381.rdb"</span>
slaveof 127.0.0.1 6379</code></pre>
<p>然后我们可以执行 <code>redis-server &lt;config file path&gt;</code> 来根据配置文件启动不同的 Redis 实例，依次启动主从节点：</p>
<pre class=" language-bash"><code class="language-bash">redis-server /usr/local/redis-5.0.3/redis-master.conf
redis-server /usr/local/redis-5.0.3/redis-slave1.conf
redis-server /usr/local/redis-5.0.3/redis-slave2.conf</code></pre>
<p>节点启动后，我们执行 <code>redis-cli</code> 默认连接到我们端口为 <code>6379</code> 的主节点执行 <code>info Replication</code> 检查一下主从状态是否正常：<em>(可以看到下方正确地显示了两个从节点)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-a1c935f094240cac.png" alt=""></p>
<h4 id="第二步：创建哨兵节点配置文件并启动"><a href="#第二步：创建哨兵节点配置文件并启动" class="headerlink" title="第二步：创建哨兵节点配置文件并启动"></a>第二步：创建哨兵节点配置文件并启动</h4><p>按照上面同样的方法，我们给哨兵节点也创建三个配置文件。<em>(哨兵节点本质上是特殊的 Redis 节点，所以配置几乎没什么差别，只是在端口上做区分就好)</em></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># redis-sentinel-1.conf</span>
port 26379
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26379.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2

<span class="token comment" spellcheck="true"># redis-sentinel-2.conf</span>
port 26380
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26380.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2

<span class="token comment" spellcheck="true"># redis-sentinel-3.conf</span>
port 26381
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26381.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2</code></pre>
<p>其中，<code>sentinel monitor mymaster 127.0.0.1 6379 2</code> 配置的含义是：该哨兵节点监控 <code>127.0.0.1:6379</code> 这个主节点，该主节点的名称是 <code>mymaster</code>，最后的 <code>2</code> 的含义与主节点的故障判定有关：至少需要 <code>2</code> 个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>
<p>执行下方命令将哨兵节点启动起来：</p>
<pre class=" language-bash"><code class="language-bash">redis-server /usr/local/redis-5.0.3/redis-sentinel-1.conf --sentinel
redis-server /usr/local/redis-5.0.3/redis-sentinel-2.conf --sentinel
redis-server /usr/local/redis-5.0.3/redis-sentinel-3.conf --sentinel</code></pre>
<p>使用 <code>redis-cil</code> 工具连接哨兵节点，并执行 <code>info Sentinel</code> 命令来查看是否已经在监视主节点了：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 连接端口为 26379 的 Redis 节点</span>
➜  ~ redis-cli -p 26379
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>此时你打开刚才写好的哨兵配置文件，你还会发现出现了一些变化：</p>
<h4 id="第三步：演示故障转移"><a href="#第三步：演示故障转移" class="headerlink" title="第三步：演示故障转移"></a>第三步：演示故障转移</h4><p>首先，我们使用 <code>kill -9</code> 命令来杀掉主节点，<strong>同时</strong> 在哨兵节点中执行 <code>info Sentinel</code> 命令来观察故障节点的过程：</p>
<pre class=" language-bash"><code class="language-bash">➜  ~ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> 6379
longtao          74529   0.3  0.0  4346936   2132   ??  Ss   10:30上午   0:03.09 redis-server *:26379 <span class="token punctuation">[</span>sentinel<span class="token punctuation">]</span>
longtao          73541   0.2  0.0  4348072   2292   ??  Ss   10:18上午   0:04.79 redis-server *:6379
longtao          75521   0.0  0.0  4286728    728 s008  S+   10:39上午   0:00.00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto --exclude-dir<span class="token operator">=</span>.bzr --exclude-dir<span class="token operator">=</span>CVS --exclude-dir<span class="token operator">=</span>.git --exclude-dir<span class="token operator">=</span>.hg --exclude-dir<span class="token operator">=</span>.svn 6379
longtao          74836   0.0  0.0  4289844    944 s006  S+   10:32上午   0:00.01 redis-cli -p 26379
➜  ~ <span class="token function">kill</span> -9 73541</code></pre>
<p>如果 <strong>刚杀掉瞬间</strong> 在哨兵节点中执行 <code>info</code> 命令来查看，会发现主节点还没有切换过来，因为哨兵发现主节点故障并转移需要一段时间：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 第一时间查看哨兵节点发现并未转移，还在 6379 端口</span>
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>一段时间之后你再执行 <code>info</code> 命令，查看，你就会发现主节点已经切换成了 <code>6381</code> 端口的从节点：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 过一段时间之后在执行，发现已经切换了 6381 端口</span>
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6381,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>但同时还可以发现，<strong>哨兵节点认为新的主节点仍然有两个从节点</strong> <em>(上方 slaves=2)</em>，这是因为哨兵在将 <code>6381</code> 切换成主节点的同时，将 <code>6379</code> 节点置为其从节点。虽然 <code>6379</code> 从节点已经挂掉，但是由于 <strong>哨兵并不会对从节点进行客观下线</strong>，因此认为该从节点一直存在。当 <code>6379</code> 节点重新启动后，会自动变成 <code>6381</code> 节点的从节点。</p>
<p>另外，在故障转移的阶段，哨兵和主从节点的配置文件都会被改写：</p>
<ul>
<li><strong>对于主从节点：</strong> 主要是 <code>slaveof</code> 配置的变化，新的主节点没有了 <code>slaveof</code> 配置，其从节点则 <code>slaveof</code> 新的主节点。</li>
<li><strong>对于哨兵节点：</strong> 除了主从节点信息的变化，纪元(epoch) <em>(记录当前集群状态的参数)</em> 也会变化，纪元相关的参数都 +1 了。</li>
</ul>
<h2 id="客户端访问哨兵系统代码演示"><a href="#客户端访问哨兵系统代码演示" class="headerlink" title="客户端访问哨兵系统代码演示"></a>客户端访问哨兵系统代码演示</h2><p>上面我们在 <em>快速体验</em> 中主要感受到了服务端自己对于当前主从节点的自动化治理，下面我们以 Java 代码为例，来演示一下客户端如何访问我们的哨兵系统：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSentinel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
         String masterName <span class="token operator">=</span> <span class="token string">"mymaster"</span><span class="token punctuation">;</span>
         Set<span class="token operator">&lt;</span>String<span class="token operator">></span> sentinels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26380"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26381"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">// 初始化过程做了很多工作</span>
         JedisSentinelPool pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span>masterName<span class="token punctuation">,</span> sentinels<span class="token punctuation">)</span><span class="token punctuation">;</span> 
         Jedis jedis <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         pool<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="客户端原理"><a href="#客户端原理" class="headerlink" title="客户端原理"></a>客户端原理</h4><p>Jedis 客户端对哨兵提供了很好的支持。如上述代码所示，我们只需要向 Jedis 提供哨兵节点集合和 <code>masterName</code> ，构造 <code>JedisSentinelPool</code> 对象，然后便可以像使用普通 Redis 连接池一样来使用了：通过 <code>pool.getResource()</code> 获取连接，执行具体的命令。</p>
<p>在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点；代码中对故障转移没有任何体现，就可以在哨兵完成故障转移后自动的切换主节点。之所以可以做到这一点，是因为在 <code>JedisSentinelPool</code> 的构造器中，进行了相关的工作；主要包括以下两点：</p>
<ol>
<li><strong>遍历哨兵节点，获取主节点信息：</strong> 遍历哨兵节点，通过其中一个哨兵节点 + <code>masterName</code> 获得主节点的信息；该功能是通过调用哨兵节点的 <code>sentinel get-master-addr-by-name</code> 命令实现；</li>
<li><strong>增加对哨兵的监听：</strong> 这样当发生故障转移时，客户端便可以收到哨兵的通知，从而完成主节点的切换。具体做法是：利用 Redis 提供的 <strong>发布订阅</strong> 功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的 + switch-master 频道，当收到消息时，重新初始化连接池。</li>
</ol>
<h2 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h2><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<h1 id="四、Redis-集群"><a href="#四、Redis-集群" class="headerlink" title="四、Redis 集群"></a>四、Redis 集群</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="快速体验-2"><a href="#快速体验-2" class="headerlink" title="快速体验"></a>快速体验</h2><h4 id="第一步：创建集群节点配置文件"><a href="#第一步：创建集群节点配置文件" class="headerlink" title="第一步：创建集群节点配置文件"></a>第一步：创建集群节点配置文件</h4><p>首先我们找一个地方创建一个名为 <code>redis-cluster</code> 的目录：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/Desktop/redis-cluster</code></pre>
<p>然后按照上面的方法，创建六个配置文件，分别命名为：<code>redis_7000.conf</code>/<code>redis_7001.conf</code>…..<code>redis_7005.conf</code>，然后根据不同的端口号修改对应的端口值就好了：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 后台执行</span>
daemonize <span class="token function">yes</span>
<span class="token comment" spellcheck="true"># 端口号</span>
port 7000
<span class="token comment" spellcheck="true"># 为每一个集群节点指定一个 pid_file</span>
pidfile ~/Desktop/redis-cluster/redis_7000.pid
<span class="token comment" spellcheck="true"># 启动集群模式</span>
cluster-enabled <span class="token function">yes</span>
<span class="token comment" spellcheck="true"># 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通</span>
cluster-config-file nodes-7000.conf
<span class="token comment" spellcheck="true"># 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败</span>
cluster-node-timeout 5000
<span class="token comment" spellcheck="true"># 最后将 appendonly 改成 yes(AOF 持久化)</span>
appendonly <span class="token function">yes</span></code></pre>
<p>记得把对应上述配置文件中根端口对应的配置都修改掉 <em>(port/ pidfile/ cluster-config-file)</em>。</p>
<h4 id="第二步：分别启动-6-个-Redis-实例"><a href="#第二步：分别启动-6-个-Redis-实例" class="headerlink" title="第二步：分别启动 6 个 Redis 实例"></a>第二步：分别启动 6 个 Redis 实例</h4><pre class=" language-bash"><code class="language-bash">redis-server ~/Desktop/redis-cluster/redis_7000.conf
redis-server ~/Desktop/redis-cluster/redis_7001.conf
redis-server ~/Desktop/redis-cluster/redis_7002.conf
redis-server ~/Desktop/redis-cluster/redis_7003.conf
redis-server ~/Desktop/redis-cluster/redis_7004.conf
redis-server ~/Desktop/redis-cluster/redis_7005.conf</code></pre>
<p>然后执行 <code>ps -ef | grep redis</code> 查看是否启动成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-452c3152054c36f1.png" alt=""></p>
<p>可以看到 <code>6</code> 个 Redis 节点都以集群的方式成功启动了，<strong>但是现在每个节点还处于独立的状态</strong>，也就是说它们每一个都各自成了一个集群，还没有互相联系起来，我们需要手动地把他们之间建立起联系。</p>
<h4 id="第三步：建立集群"><a href="#第三步：建立集群" class="headerlink" title="第三步：建立集群"></a>第三步：建立集群</h4><p>执行下列命令：</p>
<pre class=" language-bash"><code class="language-bash">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></pre>
<ul>
<li>这里稍微解释一下这个 <code>--replicas 1</code> 的意思是：我们希望为集群中的每个主节点创建一个从节点。</li>
</ul>
<p>观察控制台输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-d5ab644e76e9cc87.png" alt=""></p>
<p>看到 <code>[OK]</code> 的信息之后，就表示集群已经搭建成功了，可以看到，这里我们正确地创建了三主三从的集群。</p>
<h4 id="第四步：验证集群"><a href="#第四步：验证集群" class="headerlink" title="第四步：验证集群"></a>第四步：验证集群</h4><p>我们先使用 <code>redic-cli</code> 任意连接一个节点：</p>
<pre class=" language-bash"><code class="language-bash">redis-cli -c -h 127.0.0.1 -p 7000
127.0.0.1:7000<span class="token operator">></span></code></pre>
<ul>
<li><code>-c</code>表示集群模式；<code>-h</code> 指定 ip 地址；<code>-p</code> 指定端口。</li>
</ul>
<p>然后随便 <code>set</code> 一些值观察控制台输入：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:7000<span class="token operator">></span> SET name wmyskxz
-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>5798<span class="token punctuation">]</span> located at 127.0.0.1:7001
OK
127.0.0.1:7001<span class="token operator">></span></code></pre>
<p>可以看到这里 Redis 自动帮我们进行了 <code>Redirected</code> 操作跳转到了 <code>7001</code> 这个实例上。</p>
<p>我们再使用 <code>cluster info</code> <em>(查看集群信息)</em> 和 <code>cluster nodes</code> <em>(查看节点列表)</em> 来分别看看：<em>(任意节点输入均可)</em></p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:7001<span class="token operator">></span> CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:2
cluster_stats_messages_ping_sent:1365
cluster_stats_messages_pong_sent:1358
cluster_stats_messages_meet_sent:4
cluster_stats_messages_sent:2727
cluster_stats_messages_ping_received:1357
cluster_stats_messages_pong_received:1369
cluster_stats_messages_meet_received:1
cluster_stats_messages_received:2727

127.0.0.1:7001<span class="token operator">></span> CLUSTER NODES
56a04742f36c6e84968cae871cd438935081e86f 127.0.0.1:7003@17003 slave 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 0 1584428884000 4 connected
4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 127.0.0.1:7000@17000 master - 0 1584428884000 1 connected 0-5460
e2539c4398b8258d3f9ffa714bd778da107cb2cd 127.0.0.1:7005@17005 slave a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 0 1584428885222 6 connected
d31cd1f423ab1e1849cac01ae927e4b6950f55d9 127.0.0.1:7004@17004 slave 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 0 1584428884209 5 connected
236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 127.0.0.1:7001@17001 myself,master - 0 1584428882000 2 connected 5461-10922
a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 127.0.0.1:7002@17002 master - 0 1584428884000 3 connected 10923-16383
127.0.0.1:7001<span class="token operator">></span></code></pre>
<h2 id="数据分区方案简析"><a href="#数据分区方案简析" class="headerlink" title="数据分区方案简析"></a>数据分区方案简析</h2><h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点通信机制简析"><a href="#节点通信机制简析" class="headerlink" title="节点通信机制简析"></a>节点通信机制简析</h2><p>集群的建立离不开节点之间的通信，例如我们上访在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="数据结构简析"><a href="#数据结构简析" class="headerlink" title="数据结构简析"></a>数据结构简析</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<blockquote>
<p>更多关于集群内容请自行阅读《Redis 设计与实现》，其中有更多细节方面的介绍 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></p>
</blockquote>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
<li>Redis(6)——GeoHash查找附近的人<a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 设计与实现》 | 黄健宏 著 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></li>
<li>《Redis 深度历险》 | 钱文品 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>深入学习Redis（3）：主从复制 - <a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></li>
<li>Redis 主从复制 原理与用法 - <a href="https://blog.csdn.net/Stubborn_Cow/article/details/50442950" target="_blank" rel="noopener">https://blog.csdn.net/Stubborn_Cow/article/details/50442950</a></li>
<li>深入学习Redis（4）：哨兵 - <a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9609938.html</a></li>
<li>Redis 5 之后版本的高可用集群搭建 - <a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">https://www.jianshu.com/p/8045b92fafb2</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/">
            <section class="post prev white-box shadow" >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          2 / 14
        </p>
        
          <a class="next" rel="next" href="/page/3/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(13)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.86px; color: #868686">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.29px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.57px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.86px; color: #646464">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.43px; color: #6d6d6d">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.43px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 19.71px; color: #727272">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.71px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.86px; color: #868686">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.57px; color: #818181">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.57px; color: #818181">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.14px; color: #686868">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.71px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.43px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.14px; color: #8a8a8a">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.71px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.43px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.57px; color: #818181">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.71px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.29px; color: #7c7c7c">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.71px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.14px; color: #8a8a8a">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.86px; color: #868686">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.14px; color: #686868">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19px; color: #777">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>



    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
