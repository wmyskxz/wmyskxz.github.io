<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      
        <meta name="robots" content="noindex,follow">
      
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      

<div class='l_main'>
  
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/17/java-mian-shi-zhi-shi-dian-jie-xi-si-ban-ben-te-xing-pian/">
      Java面试知识点解析(四)——版本特性篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月17日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<hr>
<blockquote>
<p>对于 Java 各个版本的特性，特别是 Java 8 的新知识点，我们都应该有所了解。<br>前排申明和好文推荐：<a href="http://blinkfox.com" target="_blank" rel="noopener">闪烁之狐</a> » <a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a> » <a href="http://blinkfox.com/java6xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java6新特性及使用</a> » <a href="http://blinkfox.com/java7xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java7新特性及使用</a> » <a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用(一)</a> » <a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-er/" target="_blank" rel="noopener">Java8新特性及使用(二)</a></p>
</blockquote>
<h2 id="（一）Java-5-相关知识点"><a href="#（一）Java-5-相关知识点" class="headerlink" title="（一）Java 5 相关知识点"></a>（一）Java 5 相关知识点</h2><blockquote>
<p>参考文章：<a href="https://www.kancloud.cn/alex_wsc/java/466883" target="_blank" rel="noopener">jdk 1.5新特性</a></p>
</blockquote>
<h4 id="1）增强型-for-循环："><a href="#1）增强型-for-循环：" class="headerlink" title="1）增强型 for 循环："></a>1）增强型 for 循环：</h4><p>答：增强 for 循环：foreach 语句，foreach 简化了迭代器。</p>
<p>格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span> 元素类型 变量名 <span class="token operator">:</span> Collection集合 <span class="token operator">&amp;</span> 数组 <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
<span class="token punctuation">}</span></code></pre>
<p>语法：<br><code>for ( type 变量名：集合变量名 ) { … }</code></p>
<p>注意事项：</p>
<ul>
<li>迭代变量必须在( )中定义！</li>
<li>集合变量可以是数组或实现了Iterable接口的集合类。</li>
</ul>
<p><strong>高级for循环和传统for循环的区别：</strong></p>
<p>高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。</p>
<p>如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。比起普通的for循环，高级for循环还有性能优势，因为它对数组索引的边界值只计算一次（摘自《Effective Java》第46条）。</p>
<p><strong>高级for循环可以遍历map集合吗？</strong></p>
<p>答：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>Object obj <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token punctuation">.</span>Entry entry <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// obj 依次表示Entry</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>总之，for-each 循环在简洁性和预防 Bug 方面有着传统 for 循环无法比拟的优势，并且没有性能损失。应该尽可能地使用 for-each 循环。遗憾的是，有三种常见的情况是无法使用 for-each 循环的：</strong></p>
<ol>
<li><p>过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式地迭代器，以便可以调用它的 remove 方法。</p>
</li>
<li><p>转换——如果需要遍历列表或者数组，并取代它部分或者全部的元素值（增删、或对元素进行赋值），就需要列表迭代器或者数组索引，以便设定元素的值</p>
</li>
<li><p>平行迭代——如果需要并行地遍历多个集合，就需要显式地控制迭代器或者所因变量以便所有迭代器或者索引变量都可以得到同步前移</p>
</li>
</ol>
<h4 id="2）可变参数："><a href="#2）可变参数：" class="headerlink" title="2）可变参数："></a>2）可变参数：</h4><p>解析：什么意思呢？举个例子：在 JDK 1.5 之前，当我们要为一个传递多个类型相同的参数时，我们有两种方法解决，1.直接传递一个数组过去，2.有多少个参数就传递多少个参数。</p>
<p>例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printColor</span><span class="token punctuation">(</span>String red<span class="token punctuation">,</span>String green<span class="token punctuation">,</span>String yellow<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 或者</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printColor</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> colors<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre>
<p>这样编写方法参数虽然能够实现我们想要的效果，但是，这样是不是有点麻烦呢？再者，如果参数个数不确定，我们怎么办呢？Java JDK1.5为我们提供的可变参数就能够完美的解决这个问题</p>
<p>答：</p>
<p><strong>可变参数（…）：</strong>用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。</p>
<p><strong>和以前接收数组不一样的是：</strong></p>
<p>以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。</p>
<p>如果在参数列表中使用了可变参数，<strong>可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。</strong></p>
<p>如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。</p>
<p><strong>可变参数的特点：</strong></p>
<ul>
<li>① 只能出现在参数列表的最后；</li>
<li>② “…” 位于变量类型和变量名之间，前后有无空格都可以;</li>
<li>③ 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</li>
</ul>
<pre class=" language-java"><code class="language-java">Public <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span>  x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//也可以直接（int..args）就是说传不传都可以</span>
        Int sum <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token function">For</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>args<span class="token punctuation">.</span>lengrth<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                Sum<span class="token operator">+=</span>args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>实例：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableParameter</span> <span class="token punctuation">{</span>
      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="3）枚举"><a href="#3）枚举" class="headerlink" title="3）枚举"></a>3）枚举</h4><p>解析：关键字 enum</p>
<p>答：</p>
<p>问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；</p>
<p>解决办法：</p>
<p>1）在 setGrade 方法中做判断，不符合格式要求就抛出异常；<br>2）直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个 Grade 类，私有构造函数，对外提供 5 个静态的常量表示类的实例；<br>3）jdk5 中新定义了枚举类型，专门用于解决此类问题；<br>4）枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；</p>
<p><strong>为什么要有枚举？</strong></p>
<p>问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。</p>
<p>枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。</p>
<p><strong>用普通类如何实现枚举功能，</strong>定义一个Weekday的类来模拟枚举功能。</p>
<p>1、私有的构造方法。<br>2、每个元素分别用一个公有的静态成员变量表示。</p>
<p>可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句转移成了一个个独立的类</p>
<p>示例：定义一个Weekday的类来模拟枚举功能。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeekDay</span> <span class="token punctuation">{</span>

       <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WeekDay SUN <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WeekDay MON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token keyword">public</span> WeekDay <span class="token function">nextDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> SUN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> MON <span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> SUN <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

       <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> SUN<span class="token operator">?</span> <span class="token string">"SUN"</span><span class="token operator">:</span><span class="token string">"MON"</span> <span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>MON<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">nextDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//结果：SUN</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用枚举类实现</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>FRI<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：FRI</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：FRI</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：5</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>WeekDay<span class="token punctuation">.</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"SUN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：SUN</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>WeekDay<span class="token punctuation">.</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：7</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">enum</span> WeekDay<span class="token punctuation">{</span>
             SUN<span class="token punctuation">,</span>MON <span class="token punctuation">,</span>TUE<span class="token punctuation">,</span>WED<span class="token punctuation">,</span> THI<span class="token punctuation">,</span>FRI <span class="token punctuation">,</span>SAT<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>总结：</strong> 枚举是一种特殊的类，其中的每个元素都是该类的一个实例对象，例如可以调用WeekDay.SUN.getClass().getName 和 WeekDay.class.getName()。</p>
<p><strong>注意：</strong> 最后一个枚举元素后面可以加分号，也可以不加分号。</p>
<p><strong>实现带有构造方法的枚举</strong></p>
<ul>
<li>枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。</li>
<li>枚举元素必须位于枚举体中的最开始部分，枚举元素列表的最后要有分号与其他成员分隔。把枚举中的成员方法或变量等放在枚举元素的前面，编译器会报告错误。</li>
<li>带构造方法的枚举：<br>构造方法必须定义成私有的<br>如果有多个构造方法，将根据枚举元素创建时所带的参数决定选择哪个构造方法创建对象。<br>枚举元素 MON 和 MON() 的效果一样，都是调用默认的构造方法。</li>
</ul>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>FRI<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">enum</span> WeekDay<span class="token punctuation">{</span>
             <span class="token function">SUN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">MON</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span>THI <span class="token punctuation">,</span>FRI<span class="token punctuation">,</span>SAT<span class="token punctuation">;</span>

             <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"first"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

             <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                  System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"second"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
             <span class="token comment" spellcheck="true">//结果：</span>
             <span class="token comment" spellcheck="true">//second</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>实现带有抽象方法的枚举</strong></p>
<p>定义枚举TrafficLamp，实现抽象的nextTrafficLamp方法：每个元素分别是由枚举类的子类来生成的实例对象，这些子类采用类似内部类的方式进行定义。增加上表示时间的构造方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TrafficLamp lamp <span class="token operator">=</span> TrafficLamp<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lamp<span class="token punctuation">.</span><span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//结果：GREEN</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> TrafficLamp <span class="token punctuation">{</span>
        <span class="token function">RED</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> GREEN<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> YELLOW<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">YELLOW</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> RED<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> time<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token function">TrafficLamp</span><span class="token punctuation">(</span><span class="token keyword">int</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">abstract</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong><br>1、枚举只有一个成员时，就可以作为一种单例的实现方式。<br>2、查看生成的class文件，可以看到内部类对应的class文件。</p>
<h4 id="4）自动拆装箱"><a href="#4）自动拆装箱" class="headerlink" title="4）自动拆装箱"></a>4）自动拆装箱</h4><p>答：在 Java 中数据类型分为两种：基本数据类型、引用数据类型(对象)</p>
<p>自动装箱：把基本类型变成包装器类型，本质是调用包装器类型的valueOf（）方法</p>
<p><strong>注意</strong>：基本数据类型的数组与包装器类型数组不能互换</p>
<p>在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：</p>
<hr>
<p>int → Integer<br>byte → Byte<br>short → Short<br>long → Long<br>char → Character<br>double → Double<br>float → Float<br>boolean → Boolean</p>
<hr>
<p>在 jdk 1.5 以前基本数据类型和包装类之间需要相互转换：</p>
<p>基本—引用 <code>Integer x = new Integer(x);</code><br>引用—基本 <code>int num = x.intValue();</code></p>
<p>1）<code>Integer x = 1; x = x + 1;</code> 经历了什么过程？装箱→拆箱→装箱<br>2）为了优化，虚拟机为包装类提供了缓冲池，<strong>Integer池</strong>的大小为 -128~127 一个字节的大小。<strong>String池</strong>：Java 为了优化字符串操作也提供了一个缓冲池；</p>
<p>→ 享元模式（Flyweight Pattern）：享元模式的特点是，复用我们内存中已经存在的对象，降低系统创建对象实例。</p>
<p><strong>自动装箱：</strong></p>
<pre class=" language-java"><code class="language-java">Integer num1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></code></pre>
<p><strong>自动拆箱：</strong></p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>基本数据类型的对象缓存：</p>
<pre class=" language-java"><code class="language-java">Integer num1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
Integer num2 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ture</span></code></pre>
<pre class=" language-java"><code class="language-java">Integer num3 <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>
Integer num4 <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3 <span class="token operator">==</span> num4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre>
<pre class=" language-java"><code class="language-java">Integer num5 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Integer num6 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num5 <span class="token operator">==</span> num6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre>
<p><strong>示例：</strong></p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoBox</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//装箱</span>
            Integer iObj <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

             <span class="token comment" spellcheck="true">//拆箱</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iObj <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：15</span>

            Integer i1 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            Integer i2 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：true</span>

            i1 <span class="token operator">=</span> <span class="token number">137</span><span class="token punctuation">;</span>
            i2 <span class="token operator">=</span> <span class="token number">137</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：false</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong><br>如果有很多很小的对象，并且他们有相同的东西，那就可以把他们作为一个对象。<br>如果还有很多不同的东西，那就可以作为外部的东西，作为参数传入。<br>这就是享元设计模式（flyweight）。</p>
<p>例如示例中的Integer对象，在-128~127范围内的Integer对象，用的频率比较高，就会作为同一个对象，因此结果为true。超出这个范围的就不是同一个对象，因此结果为false。</p>
<h4 id="5）泛型-Generics"><a href="#5）泛型-Generics" class="headerlink" title="5）泛型 Generics"></a>5）泛型 Generics</h4><p>答：引用泛型之后，允许指定集合里元素的类型，免去了强制类型转换，并且能在编译时刻进行类型检查的好处。Parameterized Type作为参数和返回值，Generic是vararg、annotation、enumeration、collection的基石。</p>
<p>泛型可以带来如下的好处总结如下：</p>
<ol>
<li>类型安全：抛弃List、Map，使用List、Map给它们添加元素或者使用Iterator遍历时，编译期就可以给你检查出类型错误</li>
<li>方法参数和返回值加上了Type: 抛弃List、Map，使用List、Map</li>
<li>不需要类型转换：List list = new ArrayList();</li>
<li>类型通配符“?”： 假设一个打印List中元素的方法printList,我们希望任何类型T的List都可以被打印</li>
</ol>
<h4 id="6）静态导入"><a href="#6）静态导入" class="headerlink" title="6）静态导入"></a>6）静态导入</h4><p>答：<strong>静态导入：</strong>导入了类中的所有静态成员，简化静态成员的书写。<br>import语句可以导入一个类或某个包中的所有类<br>import static语句导入一个类中的某个静态方法或所有静态方法</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>*<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//导入了Collections类中的所有静态成员</span></code></pre>
<p>静态导入可以导入静态方法，这样就不必写类名而可以直接调用静态方法了。</p>
<p><strong>例子：</strong></p>
<p>原来的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo12</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用静态导入的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>max <span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>abs <span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo12</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong></p>
<p>1、也可以通过import static java.lang.Math.*;导入Math类下所有的静态方法。<br>2、如果将javac设置为了Java5以下，那么静态导入等jdk1.5的特性都会报告错误。</p>
<h4 id="7）新的线程模型和并发库Thread-Framework-重要"><a href="#7）新的线程模型和并发库Thread-Framework-重要" class="headerlink" title="7）新的线程模型和并发库Thread Framework(重要)"></a>7）新的线程模型和并发库Thread Framework(重要)</h4><p>答： 最主要的就是引入了 java.util.concurrent 包，这个都是需要重点掌握的。</p>
<p>HashMap 的替代者 ConcurrentHashMap 和 ArrayList 的替代者 CopyOnWriteArrayList 在大并发量读取时采用 java.util.concurrent 包里的一些类会让大家满意 BlockingQueue、Callable、Executor、Semaphore </p>
<h4 id="8）内省（Introspector）"><a href="#8）内省（Introspector）" class="headerlink" title="8）内省（Introspector）"></a>8）内省（Introspector）</h4><p>答：是 Java 语言对 Bean 类属性、事件的一种缺省处理方法。例如类 A 中有属性 name , 那我们通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问name属性，这就是默认的规则。Java 中提供了一套 API 用来访问某个属性的 getter /setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中。</p>
<p>一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来 调用这些方法。</p>
<blockquote>
<p>扩展阅读：<a href="https://www.jianshu.com/p/205444f4b1eb" target="_blank" rel="noopener">java Introspector(内省) 的介绍</a></p>
</blockquote>
<h4 id="9）注解（Annotations）"><a href="#9）注解（Annotations）" class="headerlink" title="9）注解（Annotations）"></a>9）注解（Annotations）</h4><p>答：</p>
<p>注解(Annotation)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从Java5开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p>
<p>比如，下面这段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> <span class="token string">"This is String."</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的代码中，我重写了toString()方法并使用了@Override注解。但是，即使我们不使用@Override注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将toString()写成了toStrring(){double r}，而且我也没有使用@Override注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。</p>
<p><strong>为什么要引入注解？</strong></p>
<p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p>
<p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>
<p>另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。</p>
<p>目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p>
<blockquote>
<p>参考文章（更多注解戳这里）:<a href="http://blinkfox.com/javazhu-jie-de-li-jie-he-ying-yong/" target="_blank" rel="noopener">Java注解的理解和应用</a></p>
</blockquote>
<h4 id="10）新增-ProcessBuilder-类"><a href="#10）新增-ProcessBuilder-类" class="headerlink" title="10）新增 ProcessBuilder 类"></a>10）新增 ProcessBuilder 类</h4><p>答：</p>
<p><code>ProcessBuilder</code> 类是 Java5 在 <code>java.lang</code> 包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由 <code>Process</code> 类处来实现进程的控制管理。每个 <code>ProcessBuilder</code> 实例管理一个进程属性集。它的 <code>start()</code> 方法利用这些属性创建一个新的 <code>Process</code> 实例。<code>start()</code> 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p><code>ProcessBuilder</code> 是一个 <code>final</code> 类，有两个带参数的构造方法，你可以通过构造方法来直接创建 <code>ProcessBuilder</code> 的对象。而 <code>Process</code> 是一个抽象类，一般都通过 <code>Runtime.exec()</code> 和 <code>ProcessBuilder.start()</code> 来间接创建其实例。<code>ProcessBuilder</code> 为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而 <code>Process</code> 类的功能相对来说简单的多。<code>ProcessBuilder</code> 类不是同步的。如果多个线程同时访问一个 <code>ProcessBuilder</code>，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。</p>
<p>若要使用 <code>ProcessBuilder</code> 创建一个进程，只需要创建 <code>ProcessBuilder</code> 的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的 <code>start()</code> 即可。下面是一个执行打开 Windows 记事本的例子。注意它将要编辑的文件名指定为一个参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PBDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            ProcessBuilder proc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"notepad.exe"</span><span class="token punctuation">,</span> <span class="token string">"testfile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            proc<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error executing notepad."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="11）新增Formatter格式化器-Formatter"><a href="#11）新增Formatter格式化器-Formatter" class="headerlink" title="11）新增Formatter格式化器(Formatter)"></a>11）新增Formatter格式化器(Formatter)</h4><p><code>Formatter</code> 类是Java5中新增的 <code>printf-style</code> 格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的 Java 类型，如 <code>byte</code>，<code>java.math.BigDecimal</code> 和 <code>java.util.Calendar</code> 都支持。 通过 <code>java.util.Formattable</code> 接口提供了针对任意用户类型的有限格式定制。</p>
<p>更详细的介绍见<a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html" target="_blank" rel="noopener">这里</a>。主要使用方法的代码示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>MessageFormat<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>SimpleDateFormat<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span>  
<span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 格式化测试使用的示例类.
 *
 * @author blinkfox on 2017-11-28.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FormatTester</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>FormatTester<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Formatter formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 可重新排序输出.</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%n%4$2s %3$2s %2$2s %1$2s %n"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> " d  c  b  a"</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>FRANCE<span class="token punctuation">,</span> <span class="token string">"e = %+10.4f"</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> "e =    +2,7183"</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%nAmount gained or lost since last statement: $ %(,.2f"</span><span class="token punctuation">,</span> <span class="token number">6217.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// -> "Amount gained or lost since last statement: $ 6,217.58"</span>

        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"打印出格式化后的字符串:{}"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        formatter<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * printf打印.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String filename <span class="token operator">=</span> <span class="token string">"testfile"</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            String line<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Line %d: %s%n"</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to open file named '%s': %s"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * stringFormat使用.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 格式化日期.</span>
        Calendar c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GregorianCalendar</span><span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MAY<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Duke's Birthday: %1$tm %1$te,%1$tY"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// -> s == "Duke's Birthday: May 23, 1995"</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化消息.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String msg <span class="token operator">=</span> <span class="token string">"欢迎光临，当前（{0}）等待的业务受理的顾客有{1}位，请排号办理业务！"</span><span class="token punctuation">;</span>
        MessageFormat mf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageFormat</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        String fmsg <span class="token operator">=</span> mf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>fmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化日期.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"2010-1-10 17:39:21"</span><span class="token punctuation">;</span>
        SimpleDateFormat format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMddHHmmss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"格式化后的日期:{}"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"日期格式化出错！"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="12）新增-Scanner-类（Scanner）"><a href="#12）新增-Scanner-类（Scanner）" class="headerlink" title="12）新增 Scanner 类（Scanner）"></a>12）新增 Scanner 类（Scanner）</h4><p><code>java.util.Scanner</code> 是 Java5 的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。</p>
<p><strong>(1).Scanner概述</strong></p>
<p>可以从字符串(<code>Readable</code>)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。</p>
<p><code>Scanner</code> 默认使用空格作为分割符来分隔文本，但允许你使用 <code>useDelimiter(Pattern pattern)</code> 或 <code>useDelimiter(String pattern)</code> 方法来指定新的分隔符。</p>
<p>主要API如下：</p>
<ul>
<li><code>delimiter()</code>: 返回此 <code>Scanner</code> 当前正在用于匹配分隔符的 <code>Pattern</code>。</li>
<li><code>hasNext()</code>: 判断扫描器中当前扫描位置后是否还存在下一段。</li>
<li><code>hasNextLine()</code>: 如果在此扫描器的输入中存在另一行，则返回true。</li>
<li><code>next()</code>: 查找并返回来自此扫描器的下一个完整标记。</li>
<li><code>nextLine()</code>: 此扫描器执行当前行，并返回跳过的输入信息。</li>
</ul>
<p><strong>(2).扫描控制台输入</strong></p>
<p>当通过 <code>new Scanner(System.in)</code> 创建了一个 <code>Scanner</code> 实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给 <code>Scanner</code>，作为扫描对象。如果要获取输入的内容，则只需要调用 <code>Scanner</code> 的 <code>nextLine()</code> 方法即可。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
* 扫描控制台输入.
*
* @author blinkfox 2017-11-28
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入字符串："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String line <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">">>>"</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p><strong>(3).其它示例</strong></p>
<p>该示例中会从 <code>myNumbers</code> 文件中读取长整型 <code>long</code> 的数据。</p>
<pre class=" language-java"><code class="language-java">Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"myNumbers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">while</span> <span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">long</span> aLong <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目：</p>
<pre class=" language-java"><code class="language-java">String input <span class="token operator">=</span> <span class="token string">"1 fish 2 fish red fish blue fish"</span><span class="token punctuation">;</span>  
Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">useDelimiter</span><span class="token punctuation">(</span><span class="token string">"\\s*fish\\s*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
s<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>将输出：</p>
<pre class=" language-java"><code class="language-java"><span class="token number">1</span>  
<span class="token number">2</span>  
red  
blue  </code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="13）StringBuilder"><a href="#13）StringBuilder" class="headerlink" title="13）StringBuilder"></a>13）StringBuilder</h4><p><code>StringBuilder</code> 也是 Java5 中新增的类，主要用来代替 <code>+</code> 号和 <code>StringBuffer</code> 来更加高效的拼接字符串。<code>StringBuffer</code> 与 <code>StringBuilder</code> 都是继承于 <code>AbstractStringBuilder</code>，主要的区别就是 <code>StringBuffer</code> 的函数上都有 <code>synchronized</code> 关键字，保证线程安全。</p>
<p>关于 <code>StringBuilder</code> 的使用这里就不再详细介绍了，网上文章也有很多。总之，对于动态字符串的拼接推荐使用 <code>StringBuilder</code>。静态字符串的拼接直接使用 <code>+</code> 号或者字符串的 <code>concat(String str)</code> 方法，甚至也使用 <code>StringBuilder</code> 亦可。</p>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<hr>
<h2 id="（二）Java-6-相关知识点"><a href="#（二）Java-6-相关知识点" class="headerlink" title="（二）Java 6 相关知识点"></a>（二）Java 6 相关知识点</h2><blockquote>
<p>关于 JDK 1.6 的新特性，了解一下就可以了…如果有兴趣深入研究的童鞋，右转这里：<a href="http://blinkfox.com/java6xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java6新特性及使用</a></p>
</blockquote>
<h4 id="1）Desktop-类和-SystemTray-类："><a href="#1）Desktop-类和-SystemTray-类：" class="headerlink" title="1）Desktop 类和 SystemTray 类："></a>1）Desktop 类和 SystemTray 类：</h4><p>答：</p>
<p>在JDK6中 ,AWT新增加了两个类:Desktop 和 SystemTray 。</p>
<p>前者可以用来打开系统默认浏览器浏览指定的 URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;</p>
<p>后者可以用来在系统托盘区创建一个托盘程序.</p>
<h4 id="2）使用-JAXB2-来实现对象与-XML-之间的映射"><a href="#2）使用-JAXB2-来实现对象与-XML-之间的映射" class="headerlink" title="2）使用 JAXB2 来实现对象与 XML 之间的映射"></a>2）使用 JAXB2 来实现对象与 XML 之间的映射</h4><p>答：</p>
<p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。</p>
<p>我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。</p>
<p>JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。</p>
<p>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。</p>
<h4 id="3）理解StAX"><a href="#3）理解StAX" class="headerlink" title="3）理解StAX"></a>3）理解StAX</h4><p>答：</p>
<p>StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。 </p>
<p>StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML). </p>
<p>由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本). JDK6里面JAXP的版本就是1.4. 。 </p>
<p>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件，然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； </p>
<p>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 </p>
<h4 id="4）使用Compiler-API"><a href="#4）使用Compiler-API" class="headerlink" title="4）使用Compiler API"></a>4）使用Compiler API</h4><p>答：</p>
<p>现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 </p>
<p>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。 </p>
<h4 id="5）轻量级Http-Server-API"><a href="#5）轻量级Http-Server-API" class="headerlink" title="5）轻量级Http Server API"></a>5）轻量级Http Server API</h4><p>答：</p>
<p>JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法. </p>
<h4 id="6）插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#6）插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="6）插入式注解处理API(Pluggable Annotation Processing API)"></a>6）插入式注解处理API(Pluggable Annotation Processing API)</h4><p>答：</p>
<p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175) </p>
<p>实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境. </p>
<p>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列. </p>
<p>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。 </p>
<h4 id="7）用Console开发控制台程序"><a href="#7）用Console开发控制台程序" class="headerlink" title="7）用Console开发控制台程序"></a>7）用Console开发控制台程序</h4><p>JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. </p>
<h4 id="8）对脚本语言的支持"><a href="#8）对脚本语言的支持" class="headerlink" title="8）对脚本语言的支持"></a>8）对脚本语言的支持</h4><p>如: ruby, groovy, javascript.</p>
<h4 id="9）Common-annotations"><a href="#9）Common-annotations" class="headerlink" title="9）Common annotations"></a>9）Common annotations</h4><p><code>Common annotations</code> 原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。</p>
<h4 id="10）Java-DB-Derby"><a href="#10）Java-DB-Derby" class="headerlink" title="10）Java DB(Derby)"></a>10）Java DB(Derby)</h4><p>从 JDK6 开始，JDK 目录中新增了一个名为 <code>db</code> 的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目 <code>Derby</code>。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性 <code>JDBC 4.0</code> 规范(JSR 221)。</p>
<h4 id="11）JDBC-4-0"><a href="#11）JDBC-4-0" class="headerlink" title="11）JDBC 4.0"></a>11）JDBC 4.0</h4><p>在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。</p>
<ul>
<li>自动加载 <code>java.sql.Driver</code>，而不需要再调用 <code>class.forName</code>；</li>
<li>添加了 <code>java.sql.RowId</code> 数据类型用来可以访问 <code>sql rowid</code> ；</li>
<li>添加了 <code>National Character Set</code> 的支持；</li>
<li>增强了 <code>BLOB</code> 和 <code>CLOB</code> 的支持功能；</li>
<li><code>SQL/XML</code> 和 <code>XML</code> 支持；</li>
<li><code>Wrapper Pattern</code>；</li>
<li><code>SQLException</code> 增强；</li>
<li><code>Connection</code> 和 <code>Statement</code> 接口增强；</li>
<li><code>New Scalar Funtions</code>；</li>
<li><code>JDBC API changes</code>。</li>
</ul>
<hr>
<h2 id="（三）JAVA-7-相关知识点"><a href="#（三）JAVA-7-相关知识点" class="headerlink" title="（三）JAVA 7 相关知识点"></a>（三）JAVA 7 相关知识点</h2><blockquote>
<p>之前已经写过一篇详细介绍 Java 7 特性的文章了，这里就直接黏了：<a href="https://www.jianshu.com/p/6bc2e4c82f6b" target="_blank" rel="noopener">Java 7新特性</a></p>
</blockquote>
<h4 id="1）Diamond-Operator"><a href="#1）Diamond-Operator" class="headerlink" title="1）Diamond Operator"></a>1）Diamond Operator</h4><p>类型判断是一个人特殊的烦恼，入下面的代码：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> anagrams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>通过类型推断后变成：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> anagrams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>注：这个&lt;&gt;被叫做diamond(钻石)运算符，Java 7后这个运算符从引用的声明中推断类型。</strong></p>
<h4 id="2）在switch语句中使用字符串"><a href="#2）在switch语句中使用字符串" class="headerlink" title="2）在switch语句中使用字符串"></a>2）在switch语句中使用字符串</h4><p>switch语句可以使用原始类型或枚举类型。Java引入了另一种类型，我们可以在switch语句中使用：字符串类型。</p>
<p>说我们有一个根据其地位来处理贸易的要求。直到现在，我们使用if-其他语句来完成这个任务。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token function">voidprocessTrade</span><span class="token punctuation">(</span>Trade t<span class="token punctuation">)</span><span class="token punctuation">{</span>

            String status <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>NEW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">newTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>EXECUTE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">executeTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>PENDING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">pendingTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>这种处理字符串的方法是粗糙的。在Java中，我们可以使用增强的switch语句来改进程序，该语句以String类型作为参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidprocessTrade</span><span class="token punctuation">(</span>Trade t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String status <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        caseNEW<span class="token operator">:</span>
            <span class="token function">newTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        caseEXECUTE<span class="token operator">:</span>
            <span class="token function">executeTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        casePENDING<span class="token operator">:</span>
            <span class="token function">pendingTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在上面的程序中，状态字段总是通过使用 <strong>String.equals()</strong> 与案例标签来进行比较。</p>
<h4 id="3）自动资源管理"><a href="#3）自动资源管理" class="headerlink" title="3）自动资源管理"></a>3）自动资源管理</h4><p>Java中有一些资源需要手动关闭，例如<strong>Connections，Files，Input/OutStreams</strong>等。通常我们使用 <strong>try-finally</strong> 来关闭资源：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidoldTry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        fos<span class="token operator">=</span> <span class="token function">newFileOutputStream</span><span class="token punctuation">(</span><span class="token string">"movies.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        dos<span class="token operator">=</span> <span class="token function">newDataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span>

        dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"Java 7 Block Buster"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>

        <span class="token keyword">try</span><span class="token punctuation">{</span>

            fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            dos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// log the exception</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>然而，在Java 7中引入了另一个很酷的特性，可以自动管理资源。它的操作也很简单，我们所要做的就是在 <strong>try</strong> 块中申明资源如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>resources_to_be_cleant<span class="token punctuation">)</span><span class="token punctuation">{</span>

   <span class="token comment" spellcheck="true">// your code</span>

<span class="token punctuation">}</span></code></pre>
<p>以上方法与旧的 <strong>try-finally</strong> 能最终写成下面的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewTry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">(</span>FileOutputStream fos <span class="token operator">=</span> <span class="token function">newFileOutputStream</span><span class="token punctuation">(</span><span class="token string">"movies.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        DataOutputStream dos <span class="token operator">=</span> <span class="token function">newDataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"Java 7 Block Buster"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log the exception</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>上面的代码也代表了这个特性的另一个方面：处理多个资源。<strong>FileOutputStream</strong> 和 <strong>DataOutputStream</strong> 在try语句中一个接一个地含在语句中，每一个都用分号(;)分隔符分隔开。我们不必手动取消或关闭流，因为当空间存在try块时，它们将自动关闭。</p>
<p>在后台，应该自动关闭的资源必须试验 <strong>java.lang.AutoCloseable</strong> 接口。</p>
<p>任何实现 <strong>AutoCloseable</strong> 接口的资源都可以作为自动资源管理的候选。<strong>AutoCloseable</strong> 是 <strong>java.io.Closeable</strong> 接口的父类，JVM会在程序退出<strong>try</strong>块后调用一个方法 <strong>close()</strong>。</p>
<h4 id="4）带下划线的数字文本"><a href="#4）带下划线的数字文本" class="headerlink" title="4）带下划线的数字文本"></a>4）带下划线的数字文本</h4><p>数字文字绝对是对眼睛的一种考验。我相信，如果你给了一个数字，比如说，十个零，你就会像我一样数零。如果不计算从右到左的位置，识别一个文字的话，就很容易出错，而且很麻烦。Not anymore。Java在识别位置时引入了下划线。例如，您可以声明1000，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> thousand <span class="token operator">=</span>  1_000<span class="token punctuation">;</span></code></pre>
<p>或1000000(一百万)如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> million  <span class="token operator">=</span>  1_000_000</code></pre>
<p><strong>请注意，这个版本中也引入了二进制文字-例如“0b1”-因此开发人员不必再将它们转换为十六进制。</strong></p>
<h4 id="5）改进的异常处理"><a href="#5）改进的异常处理" class="headerlink" title="5）改进的异常处理"></a>5）改进的异常处理</h4><p>在异常处理区域有几处改进。Java引入了多个catch功能，以使用单个抓到块捕获多个异常类型。</p>
<p>假设您有一个方法，它抛出三个异常。在当前状态下，您将分别处理它们，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidoldMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionOne</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionTwo e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionTwo</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionThree</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>在一个catch块中逐个捕获一个连续的异常，看起来很混乱。我还看到了捕获十几个异常的代码。这是非常低效和容易出错的。Java为解决这只丑小鸭带来了新的语言变化。请参阅下面的方法oldMultiCatch方法的改进版本：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne <span class="token operator">|</span> ExceptionTwo <span class="token operator">|</span> ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with all Exceptions</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>多个异常通过使用 <strong>“|”</strong> 操作符在一个catch块中捕获。这样，您不必编写数十个异常捕获。但是，如果您有许多属于不同类型的异常，那么您也可以使用“多个catch块”块。下面的代码片段说明了这一点：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewMultiMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionOne</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionTwo <span class="token operator">|</span> ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionTwo and ExceptionThree</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>在上面的例子中，在和ExceptionThree属于不同的层次结构，因此您希望以不同的方式处理它们，但使用一个抓到块。</p>
<h4 id="6）New-file-system-API-NIO-2-0"><a href="#6）New-file-system-API-NIO-2-0" class="headerlink" title="6）New file system API(NIO 2.0)"></a>6）New file system API(NIO 2.0)</h4><p>那些使用Java的人可能还记得框架引起的头痛。在操作系统或多文件系统之间无缝地工作从来都不是一件容易的事情.。有些方法，例如删除或重命名，在大多数情况下都是出乎意料的。使用符号链接是另一个问题。实质上API需要大修。</p>
<p>为了解决上述问题，Java引入了一个新的API，并在许多情况下引入了新的api。</p>
<p>在NIO2.0提出了许多增强功能。在处理多个文件系统时，它还引入了新的类来简化开发人员的生活。</p>
<p><strong>Working With Path（使用路径）：</strong></p>
<p>新的 <strong>java.nio.file</strong> 由包和接口组成例如：<strong>Path,Paths,FileSystem,FileSystems</strong>等等。</p>
<p>路径只是对文件路径的简单引用。它与java.io.File等价(并具有更多的特性)。下面的代码段显示了如何获取对“临时”文件夹的路径引用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidpathInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    Path path<span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"c:\Temp\temp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of Nodes:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getNameCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Name:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Root:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Parent:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<p>最终控制台的输出将是:</p>
<pre class=" language-java"><code class="language-java">Number of Nodes<span class="token operator">:</span><span class="token number">2</span>

File Name<span class="token operator">:</span>temp<span class="token punctuation">.</span>txt

File Root<span class="token operator">:</span>c<span class="token operator">:</span>

File Parent<span class="token operator">:</span>c<span class="token operator">:</span>Temp</code></pre>
<p>删除文件或目录就像在文件中调用delete方法(注意复数)一样简单。在类公开两个删除方法，一个抛出NoSuchFileException，另一个不抛。</p>
<p>下面的delete方法调用抛出NoSuchFileException，因此您必须处理它：</p>
<pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Where as Files.deleteIfExists(path) does not throw exception (as expected) if the file/directory does not exist.</p>
<blockquote>
<p>使用 <strong>Files.deteleIfExists(path)</strong> 则不会抛出异常。</p>
</blockquote>
<p>您可以使用其他实用程序方法，例如Files.copy(.)和Files.move(.)来有效地对文件系统执行操作。类似地，使用 <strong>createSymbolicLink(..)</strong> 方法使用代码创建符号链接。</p>
<p><strong>文件更改通知：</strong></p>
<p>JDK 7中最好的改善算是File change notifications（文件更改通知）了。这是一个长期等待的特性，它最终被刻在NIO 2.0中。<strong>WatchService</strong> API 允许您在对主题(目录或文件)进行更改时接收通知事件。</p>
<blockquote>
<p>具体的创建步骤就不给了，总之它的功能就跟它的名字一般，当文件发生更改的时候，能及时作出反馈。</p>
</blockquote>
<h4 id="7）Fork-and-Join（Fork-Join框架）"><a href="#7）Fork-and-Join（Fork-Join框架）" class="headerlink" title="7）Fork and Join（Fork/Join框架）"></a>7）Fork and Join（Fork/Join框架）</h4><p>在一个 Java 程序中有效地使用并行内核一直是一个挑战。很少有国内开发的框架将工作分配到多个核心，然后加入它们来返回结果集。Java已经将这个特性作为Fork/Join框架结合了起来。</p>
<p>基本上，在把手头的任务变成了小任务，直到小任务简单到可以不进一步分手的情况下解决。这就像一个分而治之的算法.。在这个框架中需要注意的一个重要概念是，理想情况下，没有工作线程是空闲的。他们实现了一个 work-stealing 算法，在空闲的工人“偷”工作从那些工人谁是忙。</p>
<p>支持Fork-Join机制的核心类是 ForkJoinPool和ForkJoinTask。</p>
<p><strong>什么是Fork/Join框架：</strong></p>
<p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>Fork/Join的运行流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-47e0d9433019fb97.png" alt=""></p>
<p><strong>工作窃取算法：</strong></p>
<p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-53555e4f93e990d9.png" alt=""></p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<p><strong>Fork/Join框架使用示例：</strong></p>
<p>让我们通过一个简单的需求来使用下 <code>Fork／Join</code> 框架，需求是：计算<code>1 + 2 + 3 + 4</code>的结果。</p>
<p>使用 <code>Fork/Join</code> 框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是<code>2</code>，由于是<code>4</code>个数字相加，所以 <code>Fork/Join</code> 框架会把这个任务 <code>fork</code> 成两个子任务，子任务一负责计算<code>1 + 2</code>，子任务二负责计算<code>3 + 4</code>，然后再 <code>join</code> 两个子任务的结果。</p>
<p>因为是有结果的任务，所以必须继承 <code>RecursiveTask</code> ，实现代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * CountTask.
 *
 * @author blinkfox on 2018-01-03.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/** 阈值. */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** 计算的开始值. */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** 计算的结束值. */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 构造方法.
     *
     * @param start 计算的开始值
     * @param end 计算的结束值
     */</span>
    <span class="token keyword">public</span> <span class="token function">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 执行计算的方法.
     *
     * @return int型结果
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果任务足够小就计算任务.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果任务大于阈值，就分裂成两个子任务来计算.</span>
            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            CountTask leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
            CountTask rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 等待子任务执行完，并得到结果，再合并执行结果.</span>
            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * main方法.
     *
     * @param args 数组参数
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
        ForkJoinPool fkPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CountTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> fkPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result:"</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java7xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java7新特性及使用</a><br>这里是Java 7的新特性一览表：<a href="http://www.oschina.net/news/20119/new-features-of-java-7" target="_blank" rel="noopener">http://www.oschina.net/news/20119/new-features-of-java-7</a></p>
</blockquote>
<hr>
<h2 id="（四）Java-8-相关知识点"><a href="#（四）Java-8-相关知识点" class="headerlink" title="（四）Java 8 相关知识点"></a>（四）Java 8 相关知识点</h2><blockquote>
<p>关于 Java 8 中新知识点，面试官会让你说说 Java 8 你了解多少，下面分享一下我收集的 Java 8 新增的知识点的内容，前排申明引用自：<a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用</a></p>
</blockquote>
<h4 id="1）接口默认方法和静态方法"><a href="#1）接口默认方法和静态方法" class="headerlink" title="1）接口默认方法和静态方法"></a>1）接口默认方法和静态方法</h4><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p>
<p><strong>1.接口默认方法</strong></p>
<p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>
    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>
    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><code>Defaulable</code> 接口用关键字 <code>default</code> 声明了一个默认方法 <code>notRequired()</code>，<code>Defaulable</code> 接口的实现者之一 <code>DefaultableImpl</code> 实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code> 接口的另一个实现者 <code>OverridableImpl</code> 用自己的方法覆盖了默认方法。</p>
<p><strong>1.1 多重继承的冲突说明：</strong></p>
<p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p>
<ul>
<li>一个声明在类里面的方法优先于任何默认方法</li>
<li>优先选取最具体的实现</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span> B <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 Hello B</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p><strong>1.2 优缺点：</strong></p>
<ul>
<li><strong>优点</strong>: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li>
<li><strong>缺点</strong>: 使得<strong>接口作为协议，类作为具体实现</strong>的界限开始变得有点模糊。</li>
</ul>
<p><strong>1.3 接口默认方法不能重载Object类的任何方法：</strong></p>
<p><strong>接口不能提供对Object类的任何方法的默认实现。</strong>简单地讲，每一个java类都是Object的子类，也都继承了它类中的 <code>equals()/hashCode()/toString()</code> 方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</p>
<p>在 JVM 中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到 <code>java.util.Collection</code> 接口中去：<code>stream()</code>，<code>parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code> 等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p>
<p><strong>2.接口静态方法</strong></p>
<p>Java 8 带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用 <code>static</code> 关键字，例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>下面的一小段代码是上面静态方法的使用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>Java 支持一个实现类可以实现多个接口，如果多个接口中存在同样的 <code>static</code> 方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p>
<h4 id="2）Lambda-表达式"><a href="#2）Lambda-表达式" class="headerlink" title="2）Lambda 表达式"></a>2）Lambda 表达式</h4><p><code>Lambda</code> 表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong><a href="https://www.jianshu.com/p/eb7721f32a5d" target="_blank" rel="noopener">行为参数化</a></strong>，函数作为参数传递进方法中）。</p>
<p>一个 <code>Lambda</code> 可以由用逗号分隔的参数列表、<code>–&gt;</code> 符号与函数体三部分表示。</p>
<p>首先看看在老版本的Java中是如何排列字符串的：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>只需要给静态方法 <code>Collections.sort</code> 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>看到了吧，代码变得更短且更具有可读性，但是实际上还可以写得更短：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p>
<blockquote>
<p>更多 Lambda 表达式的示例在这里：<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a></p>
</blockquote>
<h4 id="3）函数式接口"><a href="#3）函数式接口" class="headerlink" title="3）函数式接口"></a>3）函数式接口</h4><p><code>Lambda</code> 表达式是如何在 Java 的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而<strong>函数式接口</strong>是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为<strong>默认方法</strong>不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 <code>@FunctionalInterface</code> 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<p>示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>  
    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>  
Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123  </span></code></pre>
<blockquote>
<p><strong>注意：</strong> 如果 <code>@FunctionalInterface</code> 如果没有指定，上面的代码也是对的。<br><strong>更多参考：</strong> <a href="https://www.jianshu.com/p/c204e3721733" target="_blank" rel="noopener">Java 8——Lambda表达式</a>、<a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用</a></p>
</blockquote>
<h4 id="4）方法引用"><a href="#4）方法引用" class="headerlink" title="4）方法引用"></a>4）方法引用</h4><p><strong>1.概述：</strong></p>
<p>在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p>
<pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。</p>
<pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>这种特性就叫做<strong>方法引用</strong>(<code>Method Reference</code>)。</p>
<p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p>
<blockquote>
<p><strong>注意</strong>: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。</p>
</blockquote>
<p><strong>2.分类：</strong></p>
<p>方法引用的标准形式是：<code>类名::方法名</code>。（注意：只需要写方法名，不需要写括号）</p>
<p>有以下四种形式的方法引用：</p>
<ul>
<li>引用静态方法: ContainingClass::staticMethodName</li>
<li>引用某个对象的实例方法: containingObject::instanceMethodName</li>
<li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li>
<li>引用构造方法: ClassName::new</li>
</ul>
<p><strong>3.示例：</strong></p>
<p>使用示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    String name<span class="token punctuation">;</span>

    LocalDate birthday<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 使用匿名类</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//使用lambda表达式</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="5）Steam"><a href="#5）Steam" class="headerlink" title="5）Steam"></a>5）Steam</h4><blockquote>
<p>Java8添加的 <code>Stream API(java.util.stream)</code> 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为 <code>Stream API</code> 可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。使用 Steam 写出来的代码真的能让人兴奋，这里链出之前的一篇文章：<a href="https://www.jianshu.com/p/6fab3047c7e7" target="_blank" rel="noopener">Java 8——函数式数据处理（流）</a></p>
</blockquote>
<p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括<code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>peel</code>、<code>distinct</code>、<code>sorted</code>、<code>limit</code> 和 <code>substream</code>。终止操作包括 <code>forEach</code>、<code>toArray</code>、<code>reduce</code>、<code>collect</code>、<code>min</code>、<code>max</code>、<code>count</code>、<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findFirst</code> 和 <code>findAny</code>。 <code>java.util.stream.Collectors</code> 是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p>
<p><strong>1.一些重要方法说明：</strong></p>
<ul>
<li><code>stream</code>: 返回数据流，集合作为其源</li>
<li><code>parallelStream</code>: 返回并行数据流， 集合作为其源</li>
<li><code>filter</code>: 方法用于过滤出满足条件的元素</li>
<li><code>map</code>: 方法用于映射每个元素对应的结果</li>
<li><code>forEach</code>: 方法遍历该流中的每个元素</li>
<li><code>limit</code>: 方法用于减少流的大小</li>
<li><code>sorted</code>: 方法用来对流中的元素进行排序</li>
<li><code>anyMatch</code>: 是否存在任意一个元素满足条件（返回布尔值）</li>
<li><code>allMatch</code>: 是否所有元素都满足条件（返回布尔值）</li>
<li><code>noneMatch</code>: 是否所有元素都不满足条件（返回布尔值）</li>
<li><code>collect</code>: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li>
</ul>
<p><strong>2.一些使用示例：</strong></p>
<p><strong>2.1 Filter 过滤：</strong></p>
<pre><code>stringCollection  
    .stream()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);</code></pre><p><strong>2.2 Sort 排序：</strong></p>
<pre><code>stringCollection  
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);</code></pre><p><strong>2.3 Map 映射：</strong></p>
<pre><code>stringCollection  
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);</code></pre><p><strong>2.4 Match 匹配：</strong></p>
<pre><code>boolean anyStartsWithA = stringCollection  
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(anyStartsWithA);      // true

boolean allStartsWithA = stringCollection  
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ = stringCollection  
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));
System.out.println(noneStartsWithZ);      // true  </code></pre><p><strong>2.5 Count 计数：</strong></p>
<pre><code>long startsWithB = stringCollection  
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();
System.out.println(startsWithB);    // 3  </code></pre><p><strong>2.6  Reduce 规约：</strong></p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection  
        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<h4 id="6）Optional"><a href="#6）Optional" class="headerlink" title="6）Optional"></a>6）Optional</h4><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，<code>Optional</code>类已经成为Java 8类库的一部分。</p>
<p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回<code>true</code>，否从返回<code>false</code>。为了防止Optional为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。<code>map()</code>函数对当前<code>Optional</code>的值进行转化，然后返回一个新的<code>Optional</code>实例。<code>orElse()</code>方法和<code>orElseGet()</code>方法类似，但是<code>orElse</code>接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p>
<pre class=" language-java"><code class="language-java">Full Name is set<span class="token operator">?</span> <span class="token boolean">false</span>  
Full Name<span class="token operator">:</span> <span class="token punctuation">[</span>none<span class="token punctuation">]</span>  
Hey Stranger<span class="token operator">!</span>  </code></pre>
<p>让我们来看看另一个例子：</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>下面是程序的输出：</p>
<pre class=" language-java"><code class="language-java">First Name is set<span class="token operator">?</span> <span class="token boolean">true</span>  
First Name<span class="token operator">:</span> Tom  
Hey Tom<span class="token operator">!</span> </code></pre>
<h4 id="7）Date-Time-API"><a href="#7）Date-Time-API" class="headerlink" title="7）Date/Time API"></a>7）Date/Time API</h4><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p><strong>1.Clock 时钟：</strong></p>
<p><code>Clock</code>类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用<code>Instant</code>类来表示，<code>Instant</code>类也可以用来创建老的<code>java.util.Date</code>对象。代码如下:</p>
<pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date  </span></code></pre>
<p><strong>2.Timezones 时区：</strong></p>
<p>在新API中时区使用<code>ZoneId</code>来表示。时区可以很方便的使用静态方法<code>of</code>来获取到。时区定义了到UTS时间的时间差，在<code>Instant</code>时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">// prints all available timezone ids</span>
ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span>
<span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre>
<p><strong>3.LocalTime 本地时间：</strong></p>
<p><code>LocalTime</code>定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false  </span>
<span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3  </span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239  </span></code></pre>
<p><code>LocalTime</code>提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59  </span>
DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter  
        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37  </span></code></pre>
<p><strong>4.LocalDate 本地日期：</strong></p>
<p>LocalDate表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY  </span></code></pre>
<p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p>
<pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter  
        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24  </span></code></pre>
<p><strong>5.LocalDateTime 本地日期时间：</strong></p>
<p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY  </span>
Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER  </span>
<span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439  </span></code></pre>
<p>只要附加上时区信息，就可以将其转换为一个时间点<code>Instant</code>对象，<code>Instant</code>时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。代码如下:</p>
<pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester  
        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014  </span></code></pre>
<p>格式化<code>LocalDateTime</code>和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p>
<pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>  
    DateTimeFormatter
        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13  </span></code></pre>
<p>和<code>java.text.NumberFormat</code>不一样的是新版的<code>DateTimeFormatter</code>是不可变的，所以它是线程安全的。</p>
<p>关于Java8中日期API更多的使用示例可以参考<a href="http://blinkfox.com/java-8zhong-guan-yu-ri-qi-he-shi-jian-apide-20ge-shi-yong-shi-li/" target="_blank" rel="noopener">Java 8中关于日期和时间API的20个使用示例</a>。</p>
<h4 id="8）重复注解"><a href="#8）重复注解" class="headerlink" title="8）重复注解"></a>8）重复注解</h4><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p>
<p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>
        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>
        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但Java编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p>
<p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class)</code>经编译器处理后将会返回Filters的实例）。</p>
<h4 id="9）扩展注解的支持"><a href="#9）扩展注解的支持" class="headerlink" title="9）扩展注解的支持"></a>9）扩展注解的支持</h4><p>Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="10）Base-64"><a href="#10）Base-64" class="headerlink" title="10）Base 64"></a>10）Base 64</h4><p>在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>程序在控制台上输出了编码后的字符与解码后的字符：</p>
<pre class=" language-java"><code class="language-java">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ<span class="token operator">==</span>  
Base64 <span class="token keyword">finally</span> in Java <span class="token number">8</span><span class="token operator">!</span>  </code></pre>
<p>Base64类同时还提供了对URL、MIME友好的编码器与解码器（<code>Base64.getUrlEncoder() / Base64.getUrlDecoder()</code>, <code>Base64.getMimeEncoder() / Base64.getMimeDecoder()</code>）。</p>
<h4 id="11）JavaFX"><a href="#11）JavaFX" class="headerlink" title="11）JavaFX"></a>11）JavaFX</h4><p><code>JavaFX</code>是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考<a href="http://www.javafxchina.net/blog/docs/" target="_blank" rel="noopener">JavaFX中文文档</a>。</p>
<h4 id="12）HashMap的底层实现有变化"><a href="#12）HashMap的底层实现有变化" class="headerlink" title="12）HashMap的底层实现有变化"></a>12）HashMap的底层实现有变化</h4><p>Java8中，HashMap内部实现又引入了红黑树（数组+链表+红黑树），使得HashMap的总体性能相较于Java7有比较明显的提升。</p>
<h4 id="13）JVM内存管理方面，由元空间代替了永久代。"><a href="#13）JVM内存管理方面，由元空间代替了永久代。" class="headerlink" title="13）JVM内存管理方面，由元空间代替了永久代。"></a>13）JVM内存管理方面，由元空间代替了永久代。</h4><p>区别：</p>
<ol>
<li>元空间并不在虚拟机中，而是使用本地内存</li>
<li>默认情况下，元空间的大小仅受本地内存限制</li>
<li>也可以通过-XX：MetaspaceSize指定元空间大小</li>
</ol>
<hr>
<h2 id="（五）Java-9-相关知识点"><a href="#（五）Java-9-相关知识点" class="headerlink" title="（五）Java 9 相关知识点"></a>（五）Java 9 相关知识点</h2><blockquote>
<p>引用自文章：<a href="http://www.importnew.com/24528.html" target="_blank" rel="noopener">Java 9 中的 9 个新特性</a>、<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html" target="_blank" rel="noopener">Java 9 新特性概述——IBM</a>、<a href="https://yifeng.studio/2017/03/12/translation-java-9-features-with-examples/" target="_blank" rel="noopener">【译】使用示例带你提前了解 Java 9 中的新特性</a></p>
</blockquote>
<h4 id="1）Java-9-PEPK（JShell）"><a href="#1）Java-9-PEPK（JShell）" class="headerlink" title="1）Java 9 PEPK（JShell）"></a>1）Java 9 PEPK（JShell）</h4><p>Oracle 公司（Java Library 开发者）新引进一个代表 Java Shell 的称之为 “jshell” 或者 REPL（Read Evaluate Print Loop）的新工具。该工具可以被用来执行和测试任何 Java 中的结构，如 class，interface，enum，object，statements 等。使用非常简单。</p>
<p>JDK 9 EA（Early Access）下载地址：<a href="https://jdk9.java.net/download/" target="_blank" rel="noopener">https://jdk9.java.net/download/</a></p>
<pre><code>G:\&gt;jshell
|  Welcome to JShell -- Version 9-ea
|  For an introduction type: /help intro
jshell&gt; int a = 10
a ==&gt; 10
jshell&gt; System.out.println(&quot;a value = &quot; + a )
a value = 10</code></pre><h4 id="2）集合工厂方法"><a href="#2）集合工厂方法" class="headerlink" title="2）集合工厂方法"></a>2）集合工厂方法</h4><p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p>
<pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ints <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p>
<h4 id="3）接口中的私有方法"><a href="#3）接口中的私有方法" class="headerlink" title="3）接口中的私有方法"></a>3）接口中的私有方法</h4><p>在 Java 8 中，我们可以在接口中使用默认或者静态方法提供一些实现方式，但是不能创建私有方法。</p>
<p>为了避免冗余代码和提高重用性，Oracle 公司准备在 Java SE 9 接口中引入私有方法。也就是说从 Java SE 9 开始，我们也能够在接口类中使用 ‘private’ 关键字写私有化方法和私有化静态方法。</p>
<p>接口中的私有方法与 class 类中的私有方法在写法上并无差异，如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Card</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> Long <span class="token function">createCardID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Method implementation goes here.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayCardDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Method implementation goes here.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="4）Java-平台级模块系统"><a href="#4）Java-平台级模块系统" class="headerlink" title="4）Java 平台级模块系统"></a>4）Java 平台级模块系统</h4><blockquote>
<p>这里只给出解决的问题，仅限了解….</p>
</blockquote>
<p>Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。</p>
<h4 id="5）进程-API"><a href="#5）进程-API" class="headerlink" title="5）进程 API"></a>5）进程 API</h4><p>Java SE 9 迎来一些 Process API 的改进，通过添加一些新的类和方法来优化系统级进程的管控。</p>
<p>Process API 中的两个新接口：</p>
<ul>
<li>java.lang.ProcessHandle</li>
<li>java.lang.ProcessHandle.Info</li>
</ul>
<p><strong>Process API 示例</strong></p>
<pre class=" language-java"><code class="language-java">ProcessHandle currentProcess <span class="token operator">=</span> ProcessHandle<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Process Id: = "</span> <span class="token operator">+</span> currentProcess<span class="token punctuation">.</span><span class="token function">getPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="6）Try-With-Resources-Improvement"><a href="#6）Try-With-Resources-Improvement" class="headerlink" title="6）Try With Resources Improvement"></a>6）Try With Resources Improvement</h4><p>我们知道，Java SE 7 引入了一个新的异常处理结构：<code>Try-With-Resources</code>，来自动管理资源。这个新的声明结构主要目的是实现“Automatic Better Resource Management”（“自动资源管理”）。</p>
<p>Java SE 9 将对这个声明作出一些改进来避免一些冗长写法，同时提高可读性。</p>
<p><strong>Java SE 7 示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">testARM_Before_Java9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    BufferedReader reader1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"journaldev.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>BufferedReader reader2 <span class="token operator">=</span> reader1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reader2<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>Java SE 9 示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">testARM_Java9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    BufferedReader reader1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"journaldev.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>reader1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reader1<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="7）CompletableFuture-API-Improvements"><a href="#7）CompletableFuture-API-Improvements" class="headerlink" title="7）CompletableFuture API Improvements"></a>7）CompletableFuture API Improvements</h4><p>在 Java SE 9 中，Oracle 公司将改进 CompletableFuture API 来解决一些 Java SE 8 中出现的问题。这些被添加的 API 将用来支持一些延时和超时操作，实用方法和更好的子类化。</p>
<pre class=" language-java"><code class="language-java">Executor exe <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">delayedExecutor</span><span class="token punctuation">(</span>50L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这里的 delayedExecutor() 是静态实用方法，用来返回一个在指定延时时间提交任务到默认执行器的新 Executor 对象。</p>
<h4 id="8）反应式流-（-Reactive-Streams-）"><a href="#8）反应式流-（-Reactive-Streams-）" class="headerlink" title="8）反应式流 （ Reactive Streams ）"></a>8）反应式流 （ Reactive Streams ）</h4><p> 反应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的反应式 库 RxJava 和 R eactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。</p>
<p>Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 F low.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。 </p>
<h4 id="9）改进的-Stream-API"><a href="#9）改进的-Stream-API" class="headerlink" title="9）改进的 Stream API"></a>9）改进的 Stream API</h4><p>长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p>
<pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。</p>
<p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 <code>stram</code> 将一个 Optional 对象转换为一个(可能是空的) Stream 对象：</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。</p>
<h4 id="10）HTTP-2"><a href="#10）HTTP-2" class="headerlink" title="10）HTTP/2"></a>10）HTTP/2</h4><p>Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 <code>HttpURLConnection</code> API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p>
<pre class=" language-java"><code class="language-java">HttpClient client <span class="token operator">=</span> HttpClient<span class="token punctuation">.</span><span class="token function">newHttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

HttpRequest req <span class="token operator">=</span>
   HttpRequest<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span>URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://www.google.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">,</span><span class="token string">"Java"</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

HttpResponse<span class="token operator">&lt;</span>String<span class="token operator">></span> resp <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> HttpResponse<span class="token punctuation">.</span>BodyHandler<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><code>HttpResponse&lt;String&gt; resp = client.send(req, HttpResponse.BodyHandler.asString());</code></p>
<p>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</p>
<h4 id="11）Optional-Class-Improvements"><a href="#11）Optional-Class-Improvements" class="headerlink" title="11）Optional Class Improvements"></a>11）Optional Class Improvements</h4><p>在 Java SE 9 中，Oracle 公司添加了一些新的实用方法到 <code>java.util.Optional</code> 类里面。这里我将使用一些简单的示例来描述其中的一个：stream 方法。</p>
<p>如果一个值出现在给定 Optional 对象中，stream() 方法可以返回包含该值的一个顺序 Stream 对象。否则，将返回一个空 Stream。</p>
<p><code>stream()</code> 方法已经被添加，并用来在 Optional 对象中使用，如：</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>Optional<span class="token operator">></span> emp <span class="token operator">=</span> <span class="token function">getEmployee</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
Stream empStream <span class="token operator">=</span> emp<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Optional<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span></code></pre>
<p>这里的 <code>Optional.stream()</code> 方法被用来转化 Employee 可选流对象 到 Employee 流中，如此我们便可以在后续代码中使用这个结果。</p>
<h4 id="12）多版本兼容-JAR"><a href="#12）多版本兼容-JAR" class="headerlink" title="12）多版本兼容 JAR"></a>12）多版本兼容 JAR</h4><p>我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：</p>
<pre class=" language-xml"><code class="language-xml">multirelease.jar
├── META-INF
│   └── versions
│       └── 9
│           └── multirelease
│               └── Helper.class
├── multirelease
    ├── Helper.class
    └── Main.class</code></pre>
<p>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/">
      Java面试知识点解析(三)——JVM篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月16日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<hr>
<h2 id="（一）JVM-基础知识"><a href="#（一）JVM-基础知识" class="headerlink" title="（一）JVM 基础知识"></a>（一）JVM 基础知识</h2><blockquote>
<p>问题和答案都是自行整理的，所以仅供参考！欢迎指正！</p>
</blockquote>
<h4 id="1）Java-是如何实现跨平台的？"><a href="#1）Java-是如何实现跨平台的？" class="headerlink" title="1）Java 是如何实现跨平台的？"></a>1）Java 是如何实现跨平台的？</h4><p><strong>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</strong></p>
<p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p>
<p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-10b94c75252f5e5e.png" alt=""></p>
<h4 id="2）什么是-JVM-？"><a href="#2）什么是-JVM-？" class="headerlink" title="2）什么是 JVM ？"></a>2）什么是 JVM ？</h4><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p>
<p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h4 id="3）JVM-由哪些部分组成？"><a href="#3）JVM-由哪些部分组成？" class="headerlink" title="3）JVM 由哪些部分组成？"></a>3）JVM 由哪些部分组成？</h4><p>解析：这是对 JVM 体系结构的考察</p>
<p>答：JVM 的结构基本上由 4 部分组成：</p>
<ul>
<li><p>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p>
</li>
<li><p>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p>
</li>
<li><p>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p>
</li>
<li><p>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-f42e851debb0a070.png" alt=""></p>
<h4 id="4）类加载器是有了解吗？"><a href="#4）类加载器是有了解吗？" class="headerlink" title="4）类加载器是有了解吗？"></a>4）类加载器是有了解吗？</h4><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p>
<p>答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p>
<p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<p><strong>面试官：Java 虚拟机是如何判定两个 Java 类是相同的？</strong></p>
<p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p>
<h4 id="5）类加载器是如何加载-class-文件的？"><a href="#5）类加载器是如何加载-class-文件的？" class="headerlink" title="5）类加载器是如何加载 class 文件的？"></a>5）类加载器是如何加载 class 文件的？</h4><p>答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-9b726ee9e5ed7e03.png" alt=""></p>
<p>第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中</p>
<p>第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接</p>
<p>第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等</p>
<p><strong>面试官：能详细讲讲吗？</strong></p>
<p>答：</p>
<p><strong>1.加载</strong></p>
<p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p><strong>2.连接</strong></p>
<p><strong>验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证：</strong>验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证：</strong>对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li>
<li><strong>字节码验证：</strong>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证：</strong>确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备：为类的<code>静态变量</code>分配内存，并将其初始化为默认值</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为： <code>public static int value = 3;</code></p>
<p>那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>public static</code>指令是在程序编译后，存放于类构造器 <code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<ul>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</li>
</ul>
<p>假设上面的类变量 value 被定义为： <code>public static final int value = 3;</code></p>
<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中</p>
<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p><strong>3.初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>① 声明类变量是指定初始值</li>
<li>② 使用静态代码块为类变量指定初始值</li>
</ul>
<p>JVM初始化步骤</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li>
</ul>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(一):java类的加载机制 - 纯洁的微笑</a></p>
</blockquote>
<h4 id="7）双亲委派模型（Parent-Delegation-Model）？"><a href="#7）双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="7）双亲委派模型（Parent Delegation Model）？"></a>7）双亲委派模型（Parent Delegation Model）？</h4><p>解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性</p>
<p>答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-b4a569a5cc980a34.png" alt=""></p>
<p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）</p>
<p><strong>面试官：双亲委派模型的工作过程？</strong></p>
<p>答：</p>
<p>1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p>
<blockquote>
<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，<br>等下次加载的时候就可以直接返回了。</p>
</blockquote>
<p>2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p>
<blockquote>
<p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p>
</blockquote>
<p><strong>面试官：为什么这样设计呢？</strong></p>
<p>解析：这是对于使用这种模型来组织累加器的好处</p>
<p>答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException. </p>
<blockquote>
<p>参考文章： <a href="https://segmentfault.com/a/1190000002579346" target="_blank" rel="noopener">JVM 的 工作原理，层次结构 以及 GC工作原理</a></p>
</blockquote>
<hr>
<h2 id="（二）JVM-内存管理"><a href="#（二）JVM-内存管理" class="headerlink" title="（二）JVM 内存管理"></a>（二）JVM 内存管理</h2><h4 id="1）JVM-内存划分："><a href="#1）JVM-内存划分：" class="headerlink" title="1）JVM 内存划分："></a>1）JVM 内存划分：</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-cf626e0e356e89d7.png" alt=""></p>
<p>答：</p>
<ol>
<li><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<ul>
<li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li>
</ul>
</li>
<li><p>堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</p>
</li>
<li><p>程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
</li>
<li><p>虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程；</p>
</li>
<li><p>本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务</p>
</li>
</ol>
<h4 id="2）对象分配规则？"><a href="#2）对象分配规则？" class="headerlink" title="2）对象分配规则？"></a>2）对象分配规则？</h4><p>答：</p>
<ul>
<li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</li>
<li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p>
</li>
<li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
</li>
<li><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 </p>
</li>
</ul>
<h4 id="3）Java-的内存模型："><a href="#3）Java-的内存模型：" class="headerlink" title="3）Java 的内存模型："></a>3）Java 的内存模型：</h4><p>答：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d385883cf2bc0725.png" alt=""></p>
<p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p>
<p><strong>面试官：两个线程之间是如何通信的呢？</strong></p>
<p>答：在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-ef21427c586e224c.png" alt=""></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ul>
<li>1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去</li>
<li>2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-7a3d44fd74ad5da8.png" alt=""></p>
<p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。</p>
<h4 id="5）内存屏障？"><a href="#5）内存屏障？" class="headerlink" title="5）内存屏障？"></a>5）内存屏障？</h4><p>解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></p>
<p>答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p><strong>面试官：内存屏障为何重要？</strong></p>
<p>答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h4 id="5）类似-Xms、-Xmn这些参数的含义："><a href="#5）类似-Xms、-Xmn这些参数的含义：" class="headerlink" title="5）类似-Xms、-Xmn这些参数的含义："></a>5）类似-Xms、-Xmn这些参数的含义：</h4><p>答：</p>
<p>堆内存分配：</p>
<ol>
<li>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64</li>
<li>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4</li>
<li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</li>
<li>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</li>
</ol>
<p>非堆内存分配：</p>
<ol>
<li>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；</li>
<li>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</li>
<li>-Xmn2G：设置年轻代大小为2G。</li>
<li>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</li>
</ol>
<h4 id="6）内存泄漏和内存溢出"><a href="#6）内存泄漏和内存溢出" class="headerlink" title="6）内存泄漏和内存溢出"></a>6）内存泄漏和内存溢出</h4><p>答：</p>
<p>概念：</p>
<ol>
<li>内存溢出指的是内存不够用了。</li>
<li>内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收</li>
<li>内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。</li>
</ol>
<p>内存泄漏的原因分析：</p>
<ol>
<li>长生命周期的对象引用短生命周期的对象</li>
<li>没有将无用对象置为null</li>
</ol>
<blockquote>
<p>小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。</p>
</blockquote>
<h4 id="7）简述一下-Java-中创建一个对象的过程？"><a href="#7）简述一下-Java-中创建一个对象的过程？" class="headerlink" title="7）简述一下 Java 中创建一个对象的过程？"></a>7）简述一下 Java 中创建一个对象的过程？</h4><p>解析：回答这个问题首先就要清楚类的生命周期</p>
<p>答：下图展示的是类的生命周期流向：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-b1d7d32f1eb7e1c5.png" alt=""></p>
<p>Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。</p>
<p>大致过程如下：</p>
<p><strong>1.检测类是否被加载：</strong></p>
<p>当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。</p>
<p><strong>2.为对象分配内存：</strong></p>
<p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p>
<p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<ul>
<li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</li>
<li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</li>
</ul>
<p>分配内存的时候也需要考虑线程安全问题，有两种解决方案：</p>
<ul>
<li>第一种是采用同步的办法，使用CAS来保证操作的原子性。</li>
<li>另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。</li>
</ul>
<p><strong>3.为分配的内存空间初始化零值：</strong></p>
<p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p>
<p><strong>4.对对象进行其他设置：</strong></p>
<p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。</p>
<p><strong>5.执行 init 方法：</strong></p>
<p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。</p>
<p>到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d3f0b79374e52e6b.png" alt=""></p>
<blockquote>
<p>参考文章：<a href="http://cxis.me/2016/12/01/Java创建对象的过程简介/" target="_blank" rel="noopener">Java创建对象的过程简介</a></p>
</blockquote>
<p><strong>面试官：对象的内存布局是怎样的？</strong></p>
<p>答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。</p>
<ul>
<li><p>对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。</p>
</li>
<li><p>实例数据：就是数据啦</p>
</li>
<li><p>对齐填充：不是必然的存在，就是为了对齐的嘛</p>
</li>
</ul>
<p><strong>面试官：对象是如何定位访问的？</strong></p>
<p>答：对象的访问定位有两种：句柄定位和直接指针</p>
<ul>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-24ab9d16017066ac.png" alt=""></p>
<ul>
<li>直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-37413a4771387b81.png" alt=""></p>
<p><strong>比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。</strong></p>
<blockquote>
<p>参考文章：<a href="https://troywu0.gitbooks.io/spark/content/java对象创建的过程.html" target="_blank" rel="noopener">JAVA对象创建的过程</a></p>
</blockquote>
<hr>
<h2 id="（三）GC-相关"><a href="#（三）GC-相关" class="headerlink" title="（三）GC 相关"></a>（三）GC 相关</h2><h4 id="1）如何判断一个对象是否已经死去？"><a href="#1）如何判断一个对象是否已经死去？" class="headerlink" title="1）如何判断一个对象是否已经死去？"></a>1）如何判断一个对象是否已经死去？</h4><p>答：</p>
<ol>
<li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
</li>
<li><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
</li>
</ol>
<h4 id="2）垃圾回收算法有哪些？"><a href="#2）垃圾回收算法有哪些？" class="headerlink" title="2）垃圾回收算法有哪些？"></a>2）垃圾回收算法有哪些？</h4><p>答：</p>
<ol>
<li><p>引用计数：<br>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
</li>
<li><p>标记-清除：<br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-629206f5d8336bc5.png" alt=""></p>
<ol start="3">
<li>复制算法：<br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-45baf8ef2625fba4.png" alt=""></p>
<ol start="4">
<li>标记-整理：<br>此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-4b2c9593a91f5816.png" alt=""></p>
<ol start="5">
<li>分代收集算法：<ul>
<li>分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。</li>
<li>在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</a></p>
</blockquote>
<h4 id="3）GC什么时候开始？"><a href="#3）GC什么时候开始？" class="headerlink" title="3）GC什么时候开始？"></a>3）GC什么时候开始？</h4><p>答：GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。</p>
<ol>
<li><p>对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；</p>
</li>
<li><p>Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；</p>
</li>
<li><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p>
</li>
</ol>
<h4 id="4）引用的分类？"><a href="#4）引用的分类？" class="headerlink" title="4）引用的分类？"></a>4）引用的分类？</h4><p>答：</p>
<ul>
<li><p>强引用：通过new出来的引用，只要强引用还存在，则不会回收。</p>
</li>
<li><p>软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。</p>
</li>
<li><p>弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。</p>
</li>
<li><p>虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。</p>
</li>
</ul>
<blockquote>
<p>扩展阅读：<a href="https://www.jianshu.com/p/39753aad9a38" target="_blank" rel="noopener">重新认识java（一） —- 万物皆对象</a> ，文章中有对这四个引用有详细的描述，还有一些典型的应用，这里就不摘过来啦…</p>
</blockquote>
<h4 id="5）垃圾收集器？"><a href="#5）垃圾收集器？" class="headerlink" title="5）垃圾收集器？"></a>5）垃圾收集器？</h4><p>解析：如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<p>答：</p>
<p><strong>1. Serial 收集器</strong></p>
<p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会 Stop The World（服务暂停）</p>
<p>参数控制： <code>-XX:+UseSerialGC</code> 串行收集器</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-ecea7511ae962fcc.png" alt=""></p>
<p><strong>2.ParNew 收集器</strong></p>
<p>ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：</p>
<p><code>-XX:+UseParNewGC</code> ParNew收集器<br><code>-XX:ParallelGCThreads</code> 限制线程数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-82bf115baf89fdbd.png" alt=""></p>
<p><strong>3.Parallel Scavenge收集器</strong></p>
<p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p>
<p><strong>4.Parallel Old 收集器</strong></p>
<p>Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在 JDK 1.6 中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p>
<p><strong>5.CMS收集器</strong></p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p><strong>优点:</strong> 并发收集、低停顿<br><strong>缺点:</strong> 产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制：</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d691b23585b39e9e.png" alt=""></p>
<p><strong>6.G1收集器</strong></p>
<p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<ol>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ol>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-8e8b4f853fd38684.png" alt=""></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-6fb4792713799689.png" alt=""></p>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-fbf007a6f9e8bc6c.png" alt=""></p>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-8ef492a1c182ae1a.png" alt=""></p>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</a></p>
</blockquote>
<hr>
<h2 id="（四）其他-JVM-相关面试题整理"><a href="#（四）其他-JVM-相关面试题整理" class="headerlink" title="（四）其他 JVM 相关面试题整理"></a>（四）其他 JVM 相关面试题整理</h2><h4 id="1）64-位-JVM-中，int-的长度是多数？"><a href="#1）64-位-JVM-中，int-的长度是多数？" class="headerlink" title="1）64 位 JVM 中，int 的长度是多数？"></a>1）64 位 JVM 中，int 的长度是多数？</h4><p>答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h4 id="2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h4><p>答：Sun有一个Java System属性来确定JVM的位数：32或64：</p>
<pre class=" language-java"><code class="language-java">sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">32</span> <span class="token comment" spellcheck="true">// 32 bit JVM</span>
sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">64</span> <span class="token comment" spellcheck="true">// 64 bit JVM</span></code></pre>
<p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.arch.data.model"</span><span class="token punctuation">)</span> </code></pre>
<h4 id="3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h4><p>答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<h4 id="4）你能保证-GC-执行吗？"><a href="#4）你能保证-GC-执行吗？" class="headerlink" title="4）你能保证 GC 执行吗？"></a>4）你能保证 GC 执行吗？</h4><p>答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。</p>
<h4 id="5）怎么获取-Java-程序使用的内存？堆使用的百分比？"><a href="#5）怎么获取-Java-程序使用的内存？堆使用的百分比？" class="headerlink" title="5）怎么获取 Java 程序使用的内存？堆使用的百分比？"></a>5）怎么获取 Java 程序使用的内存？堆使用的百分比？</h4><p>答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<h4 id="6）Java-中堆和栈有什么区别？"><a href="#6）Java-中堆和栈有什么区别？" class="headerlink" title="6）Java 中堆和栈有什么区别？"></a>6）Java 中堆和栈有什么区别？</h4><p>答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-19ed61ccd60a57df.png" alt=""></p>
<hr>
<blockquote>
<p>小结：JVM 是自己之前没有去了解过得知识，所以这次写这篇文章写了很久，也学到了很多东西；在考虑要不要开微信公众号来着…</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol>
<li>《深入理解 Java 虚拟机》</li>
<li>《深入分析 Java Web技术内幕》</li>
</ol>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/">
      Java面试知识点解析(二)——高并发编程篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月10日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<hr>
<h2 id="（一）高并发编程基础知识"><a href="#（一）高并发编程基础知识" class="headerlink" title="（一）高并发编程基础知识"></a>（一）高并发编程基础知识</h2><blockquote>
<p>这里涉及到一些基础的概念，我重新捧起了一下《实战 Java 高并发程序设计》这一本书，感觉到心潮澎湃，这或许就是笔者叙述功底扎实的魅力吧，喜欢。对于并发的基础可以参照一下我之前写过的一篇博文：<a href="https://www.jianshu.com/p/cd9d0927be35" target="_blank" rel="noopener">Java学习笔记（4）——并发基础</a></p>
</blockquote>
<h4 id="1）多线程和单线程的区别和联系？"><a href="#1）多线程和单线程的区别和联系？" class="headerlink" title="1）多线程和单线程的区别和联系？"></a>1）多线程和单线程的区别和联系？</h4><p>答：</p>
<ol>
<li><p>在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。</p>
</li>
<li><p>多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。</p>
</li>
</ol>
<p>结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。</p>
<p><strong>面试官：那使用多线程有什么优势？</strong></p>
<p>解析：尽管面临很多挑战，多线程有一些优点仍然使得它一直被使用，而这些优点我们应该了解。</p>
<p>答：</p>
<p>（1）资源利用率更好</p>
<p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p>
<pre><code>1| 5秒读取文件A
2| 2秒处理文件A
3| 5秒读取文件B
4| 2秒处理文件B
5| ---------------------
6| 总共需要14秒</code></pre><p>从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</p>
<pre><code>1| 5秒读取文件A
2| 5秒读取文件B + 2秒处理文件A
3| 2秒处理文件B
4| ---------------------
5| 总共需要12秒</code></pre><p>CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。</p>
<p>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。</p>
<p>（2）程序设计在某些情况下更简单</p>
<p>在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</p>
<p>（3）程序响应更快</p>
<p>有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单赶快找、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？</p>
<p>在上面的场景中，可以使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<blockquote>
<p><strong>多线程还有一些优势也显而易见：</strong><br>① 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。<br>② 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.<br>③ Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程.</p>
</blockquote>
<h4 id="2）多线程一定快吗？"><a href="#2）多线程一定快吗？" class="headerlink" title="2）多线程一定快吗？"></a>2）多线程一定快吗？</h4><p>答：不一定。</p>
<p>比如，我们尝试使用并行和串行来分别执行累加的操作观察是否并行执行一定比串行执行更快：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-a698017d4c0dbf79.png" alt=""></p>
<p>以下是我测试的结果，可以看出，当不超过1百万的时候，并行是明显比串行要慢的，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-e515dc406651240b.png" alt=""></p>
<h4 id="3）什么是同步？什么又是异步？"><a href="#3）什么是同步？什么又是异步？" class="headerlink" title="3）什么是同步？什么又是异步？"></a>3）什么是同步？什么又是异步？</h4><p>解析：这是对多线程基础知识的考察</p>
<p>答：同步和异步通常用来形容一次方法调用。</p>
<p>同步方法调用一旦开始，调用者必须等到方法返回后，才能继续后续的行为。这就好像是我们去商城买一台空调，你看中了一台空调，于是就跟售货员下了单，然后售货员就去仓库帮你调配物品，这天你热的实在不行，就催着商家赶紧发货，于是你就在商店里等着，知道商家把你和空调都送回家，一次愉快的购物才结束，这就是同步调用。</p>
<p>而异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。回到刚才买空调的例子，我们可以坐在里打开电脑，在网上订购一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。这就是异步调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-a8d7703b4874703a.png" alt=""></p>
<p><strong>面试官：那并发（Concurrency）和并行（Parallelism）的区别呢？</strong></p>
<p>解析：并行性和并发性是既相似又有区别的两个概念。</p>
<p><strong>答：并行性是指两个或多个事件在同一时刻发生。而并发性是指连个或多个事件在同一时间间隔内发生。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-672dfca5db6de845.png" alt=""></p>
<p>在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机环境下（一个处理器），每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。例如，在1秒钟时间内，0-15ms程序A运行；15-30ms程序B运行；30-45ms程序C运行；45-60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。</p>
<p>如果在计算机系统中有多个处理机，这些可以并发执行的程序就可以被分配到多个处理机上，实现并发执行，即利用每个处理机处理一个可并发执行的程序。这样，多个程序便可以同时执行。以此就能提高系统中的资源利用率，增加系统的吞吐量。</p>
<h4 id="4）线程和进程的区别：（必考）"><a href="#4）线程和进程的区别：（必考）" class="headerlink" title="4）线程和进程的区别：（必考）"></a>4）线程和进程的区别：（必考）</h4><p>答：</p>
<ol>
<li><p>进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位；</p>
</li>
<li><p>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）；</p>
</li>
<li><p>线程上下文的切换比进程上下文切换要快很多。</p>
<ul>
<li><p>（1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。</p>
</li>
<li><p>（2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</p>
</li>
</ul>
</li>
</ol>
<p><strong>面试官：进程间如何通讯？线程间如何通讯？</strong></p>
<p>答：进程间通讯依靠 IPC 资源，例如管道（pipes）、套接字（sockets）等；</p>
<p>线程间通讯依靠 JVM 提供的 API，例如 wait()、notify()、notifyAll() 等方法，线程间还可以通过共享的主内存来进行值的传递。</p>
<blockquote>
<p>关于线程和进程有一篇写得非常不错的文章，不过是英文的，我进行了翻译，相信阅读之后会对进程和线程有不一样的理解：<a href="https://www.jianshu.com/p/11e6cb1c3d38" target="_blank" rel="noopener">线程和进程基础——翻译文</a></p>
</blockquote>
<h4 id="5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？"><a href="#5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？" class="headerlink" title="5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？"></a>5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？</h4><p>答：阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个而资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。</p>
<p>非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。</p>
<p><strong>面试官：临界区是什么？</strong></p>
<p>答：临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。</p>
<p>比如，在一个办公室里有一台打印机，打印机一次只能执行一个任务。如果小王和小明同时需要打印文件，很显然，如果小王先下发了打印任务，打印机就开始打印小王的文件了，小明的任务就只能等待小王打印结束后才能打印，这里的打印机就是一个临界区的例子。</p>
<p>在并行程序中，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务，那么最可能的结果就是打印出来的文件就会是损坏的文件，它既不是小王想要的，也不是小明想要的。</p>
<h4 id="6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？"><a href="#6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？" class="headerlink" title="6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？"></a>6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？</h4><p>答：死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-a6041256aed650a5.png" alt=""></p>
<ol>
<li><p>死锁应该是最糟糕的一种情况了，它表示两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 </p>
</li>
<li><p>饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：<br>1）它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。在自然界中，母鸡喂食雏鸟时，很容易出现这种情况，由于雏鸟很多，食物有限，雏鸟之间的食物竞争可能非常厉害，小雏鸟因为经常抢不到食物，有可能会被饿死。线程的饥饿也非常类似这种情况。<br>2）另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。<br>与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行）</p>
</li>
<li><p>活锁是一种非常有趣的情况。不知道大家是不是有遇到过这样一种情况，当你要坐电梯下楼，电梯到了，门开了，这时你正准备出去，但不巧的是，门外一个人挡着你的去路，他想进来。于是你很绅士的靠左走，避让对方，但同时对方也很绅士，但他靠右走希望避让你。结果，你们又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右走，他也立即向左走，结果又撞上了！不过介于人类的只能，我相信这个动作重复 2、 3 次后，你应该可以顺利解决这个问题，因为这个时候，大家都会本能的对视，进行交流，保证这种情况不再发生。<br>但如果这种情况发生在两个线程间可能就不会那么幸运了，如果线程的智力不够，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有的资源而正常执行。这种情况就是活锁。</p>
</li>
</ol>
<h4 id="7）多线程产生死锁的-4-个必要条件？"><a href="#7）多线程产生死锁的-4-个必要条件？" class="headerlink" title="7）多线程产生死锁的 4 个必要条件？"></a>7）多线程产生死锁的 4 个必要条件？</h4><p>答：</p>
<ol>
<li><p>互斥条件：一个资源每次只能被一个线程使用；</p>
</li>
<li><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</p>
</li>
<li><p>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；</p>
</li>
<li><p>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ol>
<p><strong>面试官：如何避免死锁？（经常接着问这个问题哦~）</strong></p>
<p>答：指定获取锁的顺序，举例如下：</p>
<ol>
<li><p>比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</p>
</li>
<li><p>获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！</p>
</li>
</ol>
<h4 id="8）如何指定多个线程的执行顺序？"><a href="#8）如何指定多个线程的执行顺序？" class="headerlink" title="8）如何指定多个线程的执行顺序？"></a>8）如何指定多个线程的执行顺序？</h4><p>解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现）</p>
<p>答：</p>
<ol>
<li><p>设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。</p>
</li>
<li><p>在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。</p>
</li>
</ol>
<h4 id="9）Java-中线程有几种状态？"><a href="#9）Java-中线程有几种状态？" class="headerlink" title="9）Java 中线程有几种状态？"></a>9）Java 中线程有几种状态？</h4><p>答：六种（查看 Java 源码也可以看到是 6 种），并且某个时刻 Java 线程只能处于其中的一个状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-7b69db5925631d29.png" alt=""></p>
<ol>
<li><p>新建（NEW）状态：表示新创建了一个线程对象，而此时线程并没有开始执行。</p>
</li>
<li><p>可运行（RUNNABLE）状态：线程对象创建后，其它线程（比如 main 线程）调用了该对象的 start() 方法，才表示线程开始执行。当线程执行时，处于 RUNNBALE 状态，表示线程所需的一切资源都已经准备好了。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。</p>
</li>
<li><p>阻塞（BLOCKED）状态：如果线程在执行过程终于到了 synchronized 同步块，就会进入 BLOCKED 阻塞状态，这时线程就会暂停执行，直到获得请求的锁。</p>
</li>
<li><p>等待（WAITING）状态：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况；</p>
</li>
<li><p>计时等待（TIMED_WAITING）状态：Object.wait、Thread.join、Lock.tryLock和Condition.await 等方法有超时参数，还有 Thread.sleep 方法、LockSupport.parkNanos 方法和 LockSupport.parkUntil 方法，这些方法会导致线程进入计时等待状态，如果超时或者出现通知，都会切换会可运行状态；</p>
</li>
<li><p>终止（TERMINATED）状态：当线程执行完毕，则进入该状态，表示结束。</p>
</li>
</ol>
<p>注意：从 NEW 状态出发后，线程不能再回到 NEW 状态，同理，处于 TERMINATED 状态的线程也不能再回到 RUNNABLE 状态。</p>
<hr>
<h2 id="（二）高并发编程-JUC-包"><a href="#（二）高并发编程-JUC-包" class="headerlink" title="（二）高并发编程-JUC 包"></a>（二）高并发编程-JUC 包</h2><blockquote>
<p>在 Java 5.0 提供了 java.util.concurrent（简称 JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。</p>
</blockquote>
<h4 id="1）sleep-和-wait-n-、wait-的区别："><a href="#1）sleep-和-wait-n-、wait-的区别：" class="headerlink" title="1）sleep( ) 和 wait( n)、wait( ) 的区别："></a>1）sleep( ) 和 wait( n)、wait( ) 的区别：</h4><p>答：</p>
<ol>
<li><p>sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；</p>
</li>
<li><p>wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。</p>
</li>
</ol>
<h4 id="2）synchronized-关键字："><a href="#2）synchronized-关键字：" class="headerlink" title="2）synchronized 关键字："></a>2）synchronized 关键字：</h4><p>答：底层实现：</p>
<ol>
<li><p>进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；</p>
</li>
<li><p>当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。</p>
</li>
</ol>
<p>含义：（monitor 机制）</p>
<p>Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。</p>
<p>该关键字是一个几种锁的封装。</p>
<h4 id="3）volatile-关键字："><a href="#3）volatile-关键字：" class="headerlink" title="3）volatile 关键字："></a>3）volatile 关键字：</h4><p>答：该关键字可以保证可见性不保证原子性。</p>
<p>功能：</p>
<ol>
<li><p>主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；</p>
</li>
<li><p>禁止 JVM 进行的指令重排序。</p>
</li>
</ol>
<p>解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。</p>
<h4 id="4）volatile-能使得一个非原子操作变成原子操作吗？"><a href="#4）volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="4）volatile 能使得一个非原子操作变成原子操作吗？"></a>4）volatile 能使得一个非原子操作变成原子操作吗？</h4><p>答：能。</p>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p><strong>面试官：volatile 修饰符的有过什么实践？</strong></p>
<p>答：</p>
<ol>
<li><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。</p>
</li>
<li><p>volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
</li>
</ol>
<h4 id="5）ThreadLocal（线程局部变量）关键字："><a href="#5）ThreadLocal（线程局部变量）关键字：" class="headerlink" title="5）ThreadLocal（线程局部变量）关键字："></a>5）ThreadLocal（线程局部变量）关键字：</h4><p>答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p>
<p>ThreadLocal 内部实现机制：</p>
<ol>
<li><p>每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；</p>
</li>
<li><p>Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；</p>
</li>
<li><p>Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-219b164cba63247a.png" alt=""></p>
<h4 id="6）线程池有了解吗？（必考）"><a href="#6）线程池有了解吗？（必考）" class="headerlink" title="6）线程池有了解吗？（必考）"></a>6）线程池有了解吗？（必考）</h4><p>答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：</p>
<blockquote>
<ul>
<li>当前线程池大小 ：表示线程池中实际工作者线程的数量；</li>
<li>最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；</li>
<li>核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。</li>
</ul>
</blockquote>
<ol>
<li><p>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；</p>
</li>
<li><p>如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；</p>
</li>
<li><p>如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。</p>
</li>
</ol>
<p><strong>面试官：我们为什么要使用线程池？</strong></p>
<p>答：</p>
<ol>
<li><p>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
</li>
<li><p>可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机）</p>
</li>
</ol>
<p><strong>面试官：核心线程池内部实现了解吗？</strong></p>
<p>答：对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。</p>
<p>为何 ThreadPoolExecutor 有如此强大的功能呢？我们可以来看一下 ThreadPoolExecutor 最重要的构造函数：</p>
<pre><code>    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)</code></pre><p>函数的参数含义如下：</p>
<ul>
<li>corePoolSize：指定了线程池中的线程数量</li>
<li>maximumPoolSize：指定了线程池中的最大线程数量</li>
<li>keepAliveTime：当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过了 corePoolSize 的空闲线程，在多长时间内，会被销毁。</li>
<li>unit: keepAliveTime 的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</li>
</ul>
<h4 id="7）Atomic关键字："><a href="#7）Atomic关键字：" class="headerlink" title="7）Atomic关键字："></a>7）Atomic关键字：</h4><p><strong>答：可以使基本数据类型以原子的方式实现自增自减等操作。参考博客：<a href="http://blog.csdn.net/qq_25827845/article/details/70225658" target="_blank" rel="noopener">concurrent.atomic包下的类AtomicInteger的使用</a></strong></p>
<h4 id="8）创建线程有哪几种方式？"><a href="#8）创建线程有哪几种方式？" class="headerlink" title="8）创建线程有哪几种方式？"></a>8）创建线程有哪几种方式？</h4><p>答：有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象;二是直接继承Thread类。</p>
<p><strong>面试官：两种方式有什么区别呢？</strong></p>
<ol>
<li>继承方式:<ul>
<li>（1）Java中类是单继承的,如果继承了Thread了,该类就不能再有其他的直接父类了.</li>
<li>（2）从操作上分析,继承方式更简单,获取线程名字也简单.(操作上,更简单)</li>
<li>（3）从多线程共享同一个资源上分析,继承方式不能做到.</li>
</ul>
</li>
<li>实现方式:<ul>
<li>（1）Java中类可以多实现接口,此时该类还可以继承其他类,并且还可以实现其他接口(设计上,更优雅).<ul>
<li>（2）从操作上分析,实现方式稍微复杂点,获取线程名字也比较复杂,得使用Thread.currentThread()来获取当前线程的引用.</li>
<li>（3）从多线程共享同一个资源上分析,实现方式可以做到(是否共享同一个资源).</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="9）run-方法和-start-方法有什么区别？"><a href="#9）run-方法和-start-方法有什么区别？" class="headerlink" title="9）run() 方法和 start() 方法有什么区别？"></a>9）run() 方法和 start() 方法有什么区别？</h4><p>答：start() 方法会新建一个线程并让这个线程执行 run() 方法；而直接调用 run() 方法知识作为一个普通的方法调用而已，它只会在当前线程中，串行执行 run() 中的代码。</p>
<h4 id="10）你怎么理解线程优先级？"><a href="#10）你怎么理解线程优先级？" class="headerlink" title="10）你怎么理解线程优先级？"></a>10）你怎么理解线程优先级？</h4><p>答：Java 中的线程可以有自己的优先级。优先极高的线程在竞争资源时会更有优势，更可能抢占资源，当然，这只是一个概率问题。如果运行不好，高优先级线程可能也会抢占失败。</p>
<p>由于线程的优先级调度和底层操作系统有密切的关系，在各个平台上表现不一，并且这种优先级产生的后果也可能不容易预测，无法精准控制，比如一个低优先级的线程可能一直抢占不到资源，从而始终无法运行，而产生饥饿（虽然优先级低，但是也不能饿死它啊）。因此，在要求严格的场合，还是需要自己在应用层解决线程调度的问题。</p>
<p>在 Java 中，使用 1 到 10 表示线程优先级，一般可以使用内置的三个静态标量表示：</p>
<pre><code>public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;</code></pre><p>数字越大则优先级越高，但有效范围在 1 到 10 之间，默认的优先级为 5 。</p>
<h4 id="11）在-Java-中如何停止一个线程？"><a href="#11）在-Java-中如何停止一个线程？" class="headerlink" title="11）在 Java 中如何停止一个线程？"></a>11）在 Java 中如何停止一个线程？</h4><p>答：Java 提供了很丰富的 API 但没有为停止线程提供 API 。</p>
<p>JDK 1.0 本来有一些像 stop()，suspend() 和 resume() 的控制方法但是由于潜在的死锁威胁因此在后续的 JDK 版本中他们被弃用了，之后 Java API 的设计者就没有提供一个兼容且线程安全的方法来停止任何一个线程。</p>
<p>当 run() 或者 call() 方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run() 方法的循环或者是取消任务来中断线程。</p>
<h4 id="12）多线程中的忙循环是什么？"><a href="#12）多线程中的忙循环是什么？" class="headerlink" title="12）多线程中的忙循环是什么？"></a>12）多线程中的忙循环是什么？</h4><p>答：忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(),sleep() 或yield() 它们都放弃了 CPU 控制权，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。</p>
<p>在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存，为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<h4 id="13）10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#13）10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="13）10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>13）10 个线程和 2 个线程的同步代码，哪个更容易写？</h4><p>答：从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<h4 id="14）你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？"><a href="#14）你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？" class="headerlink" title="14）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？"></a>14）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</h4><p>答：wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<pre><code>// The standard idiom for using the wait method
synchronized (obj) {
while (condition does not hold)
obj.wait(); // (Releases lock, and reacquires on wakeup)
... // Perform action appropriate to condition
}</code></pre><p>参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。</p>
<h4 id="15）什么是多线程环境下的伪共享（false-sharing）？"><a href="#15）什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="15）什么是多线程环境下的伪共享（false sharing）？"></a>15）什么是多线程环境下的伪共享（false sharing）？</h4><p>答：伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-3cbee585a5f68f02.png" alt=""></p>
<p>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。</p>
<h4 id="16）用-wait-notify-写一段代码来解决生产者-消费者问题？"><a href="#16）用-wait-notify-写一段代码来解决生产者-消费者问题？" class="headerlink" title="16）用 wait-notify 写一段代码来解决生产者-消费者问题？"></a>16）用 wait-notify 写一段代码来解决生产者-消费者问题？</h4><p>解析：这是常考的基础类型的题，只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。</p>
<p>答：</p>
<pre><code>import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Java program to solve Producer Consumer problem using wait and notify
 * method in Java. Producer Consumer is also a popular concurrency design pattern.
 *
 * @author Javin Paul
 */
public class ProducerConsumerSolution {

    public static void main(String args[]) {
        Vector sharedQueue = new Vector();
        int size = 4;
        Thread prodThread = new Thread(new Producer(sharedQueue, size), &quot;Producer&quot;);
        Thread consThread = new Thread(new Consumer(sharedQueue, size), &quot;Consumer&quot;);
        prodThread.start();
        consThread.start();
    }
}

class Producer implements Runnable {

    private final Vector sharedQueue;
    private final int SIZE;

    public Producer(Vector sharedQueue, int size) {
        this.sharedQueue = sharedQueue;
        this.SIZE = size;
    }

    @Override
    public void run() {
        for (int i = 0; i &lt; 7; i++) {
            System.out.println(&quot;Produced: &quot; + i);
            try {
                produce(i);
            } catch (InterruptedException ex) {
                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
    }

    private void produce(int i) throws InterruptedException {

        // wait if queue is full
        while (sharedQueue.size() == SIZE) {
            synchronized (sharedQueue) {
                System.out.println(&quot;Queue is full &quot; + Thread.currentThread().getName()
                                    + &quot; is waiting , size: &quot; + sharedQueue.size());

                sharedQueue.wait();
            }
        }

        // producing element and notify consumers
        synchronized (sharedQueue) {
            sharedQueue.add(i);
            sharedQueue.notifyAll();
        }
    }
}

class Consumer implements Runnable {

    private final Vector sharedQueue;
    private final int SIZE;

    public Consumer(Vector sharedQueue, int size) {
        this.sharedQueue = sharedQueue;
        this.SIZE = size;
    }

    @Override
    public void run() {
        while (true) {
            try {
                System.out.println(&quot;Consumed: &quot; + consume());
                Thread.sleep(50);
            } catch (InterruptedException ex) {
                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
    }

    private int consume() throws InterruptedException {
        // wait if queue is empty
        while (sharedQueue.isEmpty()) {
            synchronized (sharedQueue) {
                System.out.println(&quot;Queue is empty &quot; + Thread.currentThread().getName()
                                    + &quot; is waiting , size: &quot; + sharedQueue.size());

                sharedQueue.wait();
            }
        }

        // Otherwise consume element and notify waiting producer
        synchronized (sharedQueue) {
            sharedQueue.notifyAll();
            return (Integer) sharedQueue.remove(0);
        }
    }
}

Output:
Produced: 0
Queue is empty Consumer is waiting , size: 0
Produced: 1
Consumed: 0
Produced: 2
Produced: 3
Produced: 4
Produced: 5
Queue is full Producer is waiting , size: 4
Consumed: 1
Produced: 6
Queue is full Producer is waiting , size: 4
Consumed: 2
Consumed: 3
Consumed: 4
Consumed: 5
Consumed: 6
Queue is empty Consumer is waiting , size: 0</code></pre><h4 id="17）用-Java-写一个线程安全的单例模式（Singleton）？"><a href="#17）用-Java-写一个线程安全的单例模式（Singleton）？" class="headerlink" title="17）用 Java 写一个线程安全的单例模式（Singleton）？"></a>17）用 Java 写一个线程安全的单例模式（Singleton）？</h4><p>解析：有多种方法，但重点掌握的是双重校验锁。</p>
<p>答：</p>
<p>1.饿汉式单例</p>
<p>饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：</p>
<pre><code>public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton (){}

    public static Singleton getInstance() {
        return instance;
    }
}</code></pre><p>2.加入 synchronized 的懒汉式单例</p>
<p>所谓懒汉式单例模式就是在调用的时候才去创建这个实例，我们在对外的创建实例方法上加如 synchronized 关键字保证其在多线程中很好的工作：</p>
<pre><code>public class Singleton {    

    private static Singleton instance;    

    private Singleton (){}    

    public static synchronized Singleton getInstance() {    
        if (instance == null) {    
            instance = new Singleton();    
    }    
    return instance;    
    }    
}  </code></pre><p>3.使用静态内部类的方式创建单例</p>
<p>这种方式利用了 classloder 的机制来保证初始化 instance 时只有一个线程，它跟饿汉式的区别是：饿汉式只要 Singleton 类被加载了，那么 instance 就会被实例化（没有达到 lazy loading 的效果），而这种方式是 Singleton 类被加载了，instance 不一定被初始化。只有显式通过调用 getInstance() 方法时才会显式装载 SingletonHoder 类，从而实例化 singleton</p>
<pre><code>public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {// 静态内部类  
        private static Singleton singleton = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.singleton;
    }
}</code></pre><p>4.双重校验锁</p>
<p>为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：</p>
<pre><code>public class Singleton {  

    private static Singleton singleton;  

    private Singleton() {  
    }  

    public static Singleton getInstance(){  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
} </code></pre><p>这种是用双重判断来创建一个单例的方法，那么我们为什么要使用两个if判断这个对象当前是不是空的呢 ？因为当有多个线程同时要创建对象的时候，多个线程有可能都停止在第一个if判断的地方，等待锁的释放，然后多个线程就都创建了对象，这样就不是单例模式了，所以我们要用两个if来进行这个对象是否存在的判断。</p>
<p>5.使用 static 代码块实现单例</p>
<p>静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。</p>
<pre><code>public class Singleton{  

    private static Singleton instance = null;  

    private Singleton(){}  

    static{  
        instance = new Singleton();  
    }  

    public static Singleton getInstance() {   
        return instance;  
    }   
}  </code></pre><p>6.使用枚举数据类型实现单例模式</p>
<p>枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：</p>
<pre><code>public class ClassFactory{   

    private enum MyEnumSingleton{  
        singletonFactory;  

        private MySingleton instance;  

        private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化  
            instance = new MySingleton();  
        }  

        public MySingleton getInstance(){  
            return instance;  
        }  
    }   

    public static MySingleton getInstance(){  
        return MyEnumSingleton.singletonFactory.getInstance();  
    }  
}  </code></pre><blockquote>
<p>小结：关于 Java 中多线程编程，线程安全等知识一直都是面试中的重点和难点，还需要熟练掌握。</p>
</blockquote>
<hr>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">① 知名互联网公司校招 Java 开发岗面试知识点解析</a><br><a href="https://zhuanlan.zhihu.com/p/23533393" target="_blank" rel="noopener">② 最近5年133个Java面试问题列表</a><br>③ 《实战 Java 高并发程序设计 —— 葛一鸣 郭超 编著》</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/09/java-mian-shi-zhi-shi-dian-jie-xi-yi-ji-chu-zhi-shi-pian/">
      Java面试知识点解析(一)——基础知识篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月9日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<hr>
<h2 id="（一）Java-基础知识点"><a href="#（一）Java-基础知识点" class="headerlink" title="（一）Java 基础知识点"></a>（一）Java 基础知识点</h2><h4 id="1）面向对象的特性有哪些？"><a href="#1）面向对象的特性有哪些？" class="headerlink" title="1）面向对象的特性有哪些？"></a>1）面向对象的特性有哪些？</h4><p>答：封装、继承和多态<em>（应要多算一个那就是抽象）</em></p>
<ul>
<li><p><strong>封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。</strong><br>但封装不仅仅是 private + getter/setter ，使用封装可以对 setter 进行更深层次的定制，例如你可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。<strong>使用封装不仅仅安全，更可以简化操作。</strong>（封装扩展阅读：<a href="https://zhuanlan.zhihu.com/p/20174473" target="_blank" rel="noopener">oc面向对象三大特性之一 &lt;封装&gt;</a>）</p>
</li>
<li><p><strong>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。</strong><br>继承的缺点：<strong>1）</strong>继承是一种强耦合关系，父类变子类也必须变；<strong>2）</strong>继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。</p>
</li>
<li><p><strong>多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。</strong><br>比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。</p>
</li>
</ul>
<p><strong>多态的条件</strong>：<strong>1）</strong>继承；<strong>2）</strong>重写；<strong>3）</strong>向上转型。<br><strong>多态的好处</strong>：当把不同的子类对象都当作父类类型来看，<strong>可以屏蔽不同子类对象之间的实现差异，</strong>从而写出通用的代码达到通用编程，以适应需求的不断变化。（多态扩展阅读：<a href="https://www.jianshu.com/p/5771df145452" target="_blank" rel="noopener">重新认识java（五） —- 面向对象之多态（向上转型与向下转型）</a>）</p>
<ul>
<li><strong>抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。</strong></li>
</ul>
<h4 id="2）面向对象和面向过程的区别？"><a href="#2）面向对象和面向过程的区别？" class="headerlink" title="2）面向对象和面向过程的区别？"></a>2）面向对象和面向过程的区别？</h4><p>答：面向过程是<strong>一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程</strong>，即先干啥，后干啥。</p>
<p>面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-e6027912a8d8c7b6.png" alt=""></p>
<ul>
<li><strong>面向过程的缺陷：</strong><br>向过程的设计,是<strong>采用置顶而下的设计方式</strong>，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</li>
<li><strong>问题：</strong>1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。</li>
</ul>
<p>面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出<strong>面向对象</strong>思想。</p>
<p>面向对象是一种基于面向过程的新的编程思想，是<strong>一种站在对象的角度思考问题</strong>的思想，我们把多个功能合理的放到不同对象里，<strong>强调的是具备某些功能的对象。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-521c9e98caea7217.png" alt=""></p>
<ul>
<li>面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</li>
<li><strong>注意：</strong> 不要粗浅的认为面向对象一定就优于面向过程的设计</li>
</ul>
<blockquote>
<p>看到知乎上有一句有意思的话：</p>
<p>你的程序要完成一个任务，相当于讲一个故事。</p>
<p>面向过程：编年体；<br>面向对象：纪传体。</p>
<p>而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。</p>
</blockquote>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/28427324" target="_blank" rel="noopener">面向过程 VS 面向对象</a></p>
<h4 id="3）JDK-和-JRE-的区别是什么？"><a href="#3）JDK-和-JRE-的区别是什么？" class="headerlink" title="3）JDK 和 JRE 的区别是什么？"></a>3）JDK 和 JRE 的区别是什么？</h4><p>解析：这是考察一些基本的概念</p>
<p>答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 </p>
<p>Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。</p>
<blockquote>
<ul>
<li>还有其他的一些名词也可以再看一下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-8672d90bb496f196.png" alt=""></p>
</blockquote>
<h4 id="4）Java-中覆盖和重载是什么意思？"><a href="#4）Java-中覆盖和重载是什么意思？" class="headerlink" title="4）Java 中覆盖和重载是什么意思？"></a>4）Java 中覆盖和重载是什么意思？</h4><p>解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。</p>
<p>答：<strong>覆盖（Override）是指子类对父类方法的一种重写，</strong>只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。</p>
<p><strong>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</strong></p>
<p>面试官： 那么构成重载的条件有哪些？</p>
<p>答：参数类型不同、参数个数不同、参数顺序不同。</p>
<p>面试官： 函数的返回值不同可以构成重载吗？为什么？</p>
<p>答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下：</p>
<p>如下两个方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>
<p>只要编译器可以根据语境明确判断出语义，比如在 <code>int x = f();</code> 中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用” ），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用：</p>
<pre class=" language-java"><code class="language-java"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>此时 Java 如何才能判断调用的是哪一个 <code>f()</code> 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。</p>
<h4 id="5）抽象类和接口的区别有哪些？"><a href="#5）抽象类和接口的区别有哪些？" class="headerlink" title="5）抽象类和接口的区别有哪些？"></a>5）抽象类和接口的区别有哪些？</h4><p>答：</p>
<ol>
<li>抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；</li>
<li>抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。</li>
<li>抽象类只能单继承，接口可以继承多个父接口；</li>
<li>Java 8 中接口中会有 default 方法，即方法可以被实现。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-dc431887834333f7.png" alt=""></p>
<p><strong>面试官：抽象类和接口如何选择？</strong></p>
<p>答：</p>
<ol>
<li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p>
</li>
<li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p>
</li>
</ol>
<h4 id="6）Java-和-C-的区别："><a href="#6）Java-和-C-的区别：" class="headerlink" title="6）Java 和 C++ 的区别："></a>6）Java 和 C++ 的区别：</h4><p>解析：虽然我们不太懂C++，但是就是会这么问，尤其是三面（总监级别）面试中。</p>
<p>答：</p>
<ol>
<li><p>都是面向对象的语言，都支持封装、继承和多态</p>
</li>
<li><p>指针：Java不提供指针来直接访问内存，程序更加安全</p>
</li>
<li><p>继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承</p>
</li>
<li><p>内存： Java有自动内存管理机制，不需要程序员手动释放无用内存</p>
</li>
</ol>
<h4 id="7）“static”-关键字是什么意思？"><a href="#7）“static”-关键字是什么意思？" class="headerlink" title="7）“static” 关键字是什么意思？"></a>7）“static” 关键字是什么意思？</h4><p>答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p>
<p>面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？</p>
<p>答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 </p>
<p>Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</p>
<p>扩展阅读：<a href="https://www.jianshu.com/p/3eb769986bd3" target="_blank" rel="noopener">重新认识java（六） —- java中的另类：static关键字（附代码块知识）</a></p>
<h4 id="8）Java-是值传递还是引用传递？"><a href="#8）Java-是值传递还是引用传递？" class="headerlink" title="8）Java 是值传递还是引用传递？"></a>8）Java 是值传递还是引用传递？</h4><p>解析：这类题目，面试官会手写一个例子，让你说出函数执行结果。</p>
<p>答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 </p>
<p>一般认为，Java 内的传递都是值传递.，Java 中实例对象的传递是引用传递，Java 是值传递的！</p>
<blockquote>
<ul>
<li>我们先来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-89340c032fb5b240.png" alt=""></p>
<p>这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？</p>
<p>这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。</p>
<blockquote>
<ul>
<li>再来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-75c3162752d36403.png" alt=""></p>
<p>我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？</p>
<p>你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！</p>
<h4 id="9）JDK-中常用的包有哪些？"><a href="#9）JDK-中常用的包有哪些？" class="headerlink" title="9）JDK 中常用的包有哪些？"></a>9）JDK 中常用的包有哪些？</h4><p>答：java.lang、java.util、java.io、java.net、java.sql。</p>
<h4 id="10）JDK，JRE-和-JVM-的联系和区别？"><a href="#10）JDK，JRE-和-JVM-的联系和区别？" class="headerlink" title="10）JDK，JRE 和 JVM 的联系和区别？"></a>10）JDK，JRE 和 JVM 的联系和区别？</h4><p>答：JDK 是 Java 开发工具包，是 Java 开发环境的核心组件，并提供编译、调试和运行一个 Java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。</p>
<p>JRE 是 Java 运行时环境，是 JVM 的实施实现，提供了运行 Java 程序的平台。JRE 包含了 JVM，但是不包含 Java 编译器 / 调试器之类的开发工具。</p>
<p>JVM 是 Java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。</p>
<p>这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因。</p>
<p>区别：</p>
<p>&emsp;&emsp;1. JDK 用于开发，JRE 用于运行 Java 程序；<br>&emsp;&emsp;2. JDK 和 JRE 中都包含 JVM；<br>&emsp;&emsp;3. JVM 是 Java 编程语言的核心并且具有平台独立性。</p>
<h4 id="11）Integer-的缓存机制"><a href="#11）Integer-的缓存机制" class="headerlink" title="11）Integer 的缓存机制"></a>11）Integer 的缓存机制</h4><p>解析：考察的是对源码的熟悉程度</p>
<blockquote>
<ul>
<li>看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-90331ba04ebe13fc.png" alt=""></p>
<blockquote>
<p>第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。</p>
<p>第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。</p>
<p>第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。</p>
</blockquote>
<p>我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-bd248da68e02bb2e.png" alt=""></p>
<p>跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的，了解就行了，不必去深究。）</p>
<h4 id="12）下述两种方法分别创建了几个-Sring-对象？"><a href="#12）下述两种方法分别创建了几个-Sring-对象？" class="headerlink" title="12）下述两种方法分别创建了几个 Sring 对象？"></a>12）下述两种方法分别创建了几个 Sring 对象？</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一种：直接赋一个字面量</span>
String str1 <span class="token operator">=</span> <span class="token string">"ABCD"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 第二种：通过构造器创建</span>
String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>解析：考察的是对 String 对象和 JVM 内存划分的知识。</p>
<p>答：<code>String str1 = &quot;ABCD&quot;;</code>最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用.</p>
<p><code>String str2 = new String(&quot;ABCD&quot;);</code>最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。</p>
<blockquote>
<p>我们来看图理解一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-70af9f49c51c9902.png" alt=""></p>
</blockquote>
<ul>
<li>当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD</li>
<li>当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。</li>
</ul>
<p>String 对象是一个特殊的存在，需要注意的知识点也比较多，这里给一个之前写的 String 详解的文章链接：<a href="https://www.jianshu.com/p/e494552f2cf0" target="_blank" rel="noopener">传送门</a> 其中包含的问题大概有：<strong>1）“+” 怎么连接字符串；2）字符串的比较；3）StringBuilder/StringBuffer/String 的区别；</strong></p>
<h4 id="13）i-与-i-到底有什么不同？"><a href="#13）i-与-i-到底有什么不同？" class="headerlink" title="13）i++ 与 ++i 到底有什么不同？"></a>13）i++ 与 ++i 到底有什么不同？</h4><p>解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，<strong>前置++和后置++一样，在参与运算之前都会将变量的值加 1</strong></p>
<p>答：实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。<strong>二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-4c68b98e2d0f4d2a.png" alt=""></p>
<h4 id="14）交换变量的三种方式"><a href="#14）交换变量的三种方式" class="headerlink" title="14）交换变量的三种方式"></a>14）交换变量的三种方式</h4><p>答：</p>
<blockquote>
<ul>
<li>第一种：通过第三个变量</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Value v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 无效的交换：形参的改变无法反作用于实参</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> y<span class="token punctuation">;</span>
        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有效的交换：通过引用（变量指向一个对象）来修改成员变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> value<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>x <span class="token operator">=</span> value<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Value</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>5<br>10<br>10<br>5</p>
</blockquote>
<p>这有点类似于C/C++语言中的指针，不过相对来说更加安全。</p>
<p>事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。</p>
<blockquote>
<p>第二种：通过通过相加的方式（相同的 Value 类不再重复展示）</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1的交换结果：<br>10<br>5</p>
</blockquote>
<p>核心的算法就是swap方法:</p>
<pre class=" language-java"><code class="language-java">v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在v.x中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y本来的值即为v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y的值也就是以前x.y的值</span></code></pre>
<p>这样就可以不通过临时变量，来达到交换两个变量的目的，如果觉得上面的方法不太容易理解，我们也可以用另一个参数z来表示上述过程：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> z <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在z中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉以前的v.y就等于v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉现在的v.y即以前的v.x，即为v.y</span></code></pre>
<p>但并<strong>不推荐这种做法</strong>，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。</p>
<blockquote>
<ul>
<li>第三种：通过异或的方式：</li>
</ul>
</blockquote>
<p>位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：<br><code>（x ^ y ^ y） == x</code>这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1交换之后的结果为：<br>10<br>5</p>
</blockquote>
<p>跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。<strong>异或的方法比相加更加可取的地方在于，异或不存在数据溢出。</strong></p>
<h4 id="15）Java-对象初始化顺序？"><a href="#15）Java-对象初始化顺序？" class="headerlink" title="15）Java 对象初始化顺序？"></a>15）Java 对象初始化顺序？</h4><p>答：不考虑静态成员的初始化，调用一个对象的构造函数时，程序<strong>先调用父类的构造函数</strong>（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），<strong>之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行</strong>，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；<strong>最后调用自身构造函数。</strong></p>
<blockquote>
<ul>
<li>我们可以写一段程序来对初始化顺序进行一个简单的验证：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> Member m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Initial Block()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Derive()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Member m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getInt()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Member</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Member</span><span class="token punctuation">(</span>String m<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Member() "</span><span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>程序的输出结果是：<br>Base()<br>Member() Member 1<br>Initial Block()<br>Member() Member 2<br>getInt()<br>Derive()</p>
</blockquote>
<h4 id="16）true、false-与-null-是关键字吗？"><a href="#16）true、false-与-null-是关键字吗？" class="headerlink" title="16）true、false 与 null 是关键字吗？"></a>16）true、false 与 null 是关键字吗？</h4><p>答：不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。</p>
<p>面试官：那 goto 与 const 呢？</p>
<p>答：是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。</p>
<h4 id="17）exception-和-error-有什么区别？"><a href="#17）exception-和-error-有什么区别？" class="headerlink" title="17）exception 和 error 有什么区别？"></a>17）exception 和 error 有什么区别？</h4><p>答：exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。</p>
<p>exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 </p>
<h4 id="18）throw-和-throws-有什么区别？"><a href="#18）throw-和-throws-有什么区别？" class="headerlink" title="18）throw 和 throws 有什么区别？"></a>18）throw 和 throws 有什么区别？</h4><p>答：throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p>
<blockquote>
<p>小结：本节主要阐述了 Java 基础知识，并没有涉及到一些高级的特性，这些问题一般难度不大，适当复习下，应该没问题。</p>
</blockquote>
<hr>
<h2 id="（二）Java-中常见集合"><a href="#（二）Java-中常见集合" class="headerlink" title="（二）Java 中常见集合"></a>（二）Java 中常见集合</h2><p>集合这方面的考察相当多，这部分是面试中必考的知识点。</p>
<h4 id="1）说说常见的集合有哪些吧？"><a href="#1）说说常见的集合有哪些吧？" class="headerlink" title="1）说说常见的集合有哪些吧？"></a>1）说说常见的集合有哪些吧？</h4><p>答：Map接口和Collection接口是所有集合框架的父接口：</p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<h4 id="2）HashMap和Hashtable的区别有哪些？（必问）"><a href="#2）HashMap和Hashtable的区别有哪些？（必问）" class="headerlink" title="2）HashMap和Hashtable的区别有哪些？（必问）"></a>2）HashMap和Hashtable的区别有哪些？（必问）</h4><p>答：</p>
<ol>
<li><p>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</p>
</li>
<li><p>前者允许null作为Key；后者不允许null作为Key</p>
</li>
</ol>
<h4 id="3）HashMap的底层实现你知道吗？"><a href="#3）HashMap的底层实现你知道吗？" class="headerlink" title="3）HashMap的底层实现你知道吗？"></a>3）HashMap的底层实现你知道吗？</h4><p>答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-47e48966bd6fec65.png" alt=""></p>
<h4 id="4）ConcurrentHashMap-和-Hashtable-的区别？（必问）"><a href="#4）ConcurrentHashMap-和-Hashtable-的区别？（必问）" class="headerlink" title="4）ConcurrentHashMap 和 Hashtable 的区别？（必问）"></a>4）ConcurrentHashMap 和 Hashtable 的区别？（必问）</h4><p> <strong>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶。</strong></p>
<p><strong>面试官：ConcurrentHashMap的具体实现知道吗？</strong></p>
<p><strong>答：</strong></p>
<p><strong>1.  该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</strong></p>
<p><strong>2.  Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</strong></p>
<h4 id="5）HashMap-的长度为什么是2的幂次方？"><a href="#5）HashMap-的长度为什么是2的幂次方？" class="headerlink" title="5）HashMap 的长度为什么是2的幂次方？"></a>5）HashMap 的长度为什么是2的幂次方？</h4><p><strong>答：</strong></p>
<p><strong>1.  通过将 Key 的 hash 值与 length - 1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率</strong></p>
<p><strong>2.  如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</strong></p>
<h4 id="6）List和Set的区别是啥？"><a href="#6）List和Set的区别是啥？" class="headerlink" title="6）List和Set的区别是啥？"></a>6）List和Set的区别是啥？</h4><p><strong>答：List元素是有序的，可以重复；Set元素是无序的，不可以重复。</strong></p>
<h4 id="7）List、Set和Map的初始容量和加载因子："><a href="#7）List、Set和Map的初始容量和加载因子：" class="headerlink" title="7）List、Set和Map的初始容量和加载因子："></a>7）List、Set和Map的初始容量和加载因子：</h4><p><strong>答：</strong></p>
<p><strong>1. List</strong></p>
<ul>
<li><p><strong>ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。</strong></p>
</li>
<li><p><strong>Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。</strong></p>
</li>
</ul>
<p><strong>2. Set</strong></p>
<p><strong>HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32</strong></p>
<p><strong>3. Map</strong></p>
<p><strong>HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32</strong></p>
<h4 id="8）Comparable接口和Comparator接口有什么区别？"><a href="#8）Comparable接口和Comparator接口有什么区别？" class="headerlink" title="8）Comparable接口和Comparator接口有什么区别？"></a>8）Comparable接口和Comparator接口有什么区别？</h4><p><strong>答：</strong></p>
<p><strong>1.  前者简单，但是如果需要重新定义比较类型时，需要修改源代码。</strong></p>
<p><strong>2.  后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 具体解析参考博客：<a href="http://blog.csdn.net/qq_25827845/article/details/51287142" target="_blank" rel="noopener">Java集合框架—Set</a></strong></p>
<h4 id="9）Java集合的快速失败机制-“fail-fast”"><a href="#9）Java集合的快速失败机制-“fail-fast”" class="headerlink" title="9）Java集合的快速失败机制 “fail-fast”"></a>9）Java集合的快速失败机制 “fail-fast”</h4><p><strong>答：</strong></p>
<p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p>
<p><strong>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</strong></p>
<p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1.  在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p>
<p><strong>2.  使用CopyOnWriteArrayList来替换ArrayList</strong></p>
<h4 id="10）ArrayList-和-Vector-的区别"><a href="#10）ArrayList-和-Vector-的区别" class="headerlink" title="10）ArrayList 和 Vector 的区别"></a>10）ArrayList 和 Vector 的区别</h4><p>答：</p>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList 与 Vector 的区别主要包括两个方面：</p>
<ol>
<li><p>同步性：<br>Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
</li>
<li><p>数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。</p>
</li>
</ol>
<p><strong>面试官：那 ArrayList 和 LinkedList 的区别呢？</strong></p>
<p>答：</p>
<ol>
<li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；</li>
<li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li>
<li>LinkedList 比 ArrayList 需要更多的内存；</li>
</ol>
<p><strong>面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</strong></p>
<p>答：它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 </li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。 </li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 </li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h4 id="11）如何去掉一个-Vector-集合中重复的元素？"><a href="#11）如何去掉一个-Vector-集合中重复的元素？" class="headerlink" title="11）如何去掉一个 Vector 集合中重复的元素？"></a>11）如何去掉一个 Vector 集合中重复的元素？</h4><p>答：</p>
<pre class=" language-java"><code class="language-java">Vector newVector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object obj <span class="token operator">=</span> vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newVector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newVector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>还有一种简单的方式，利用了 Set 不允许重复元素的特性：</p>
<pre class=" language-java"><code class="language-java">HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。</p>
</blockquote>
<h4 id="12）如何权衡是使用无序的数组还是有序的数组？"><a href="#12）如何权衡是使用无序的数组还是有序的数组？" class="headerlink" title="12）如何权衡是使用无序的数组还是有序的数组？"></a>12）如何权衡是使用无序的数组还是有序的数组？</h4><p>答：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>oh…..复习下来还真是酸爽….前路漫漫啊….</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<hr>
<h2 id="（一）Java-基础知识点-1"><a href="#（一）Java-基础知识点-1" class="headerlink" title="（一）Java 基础知识点"></a>（一）Java 基础知识点</h2><h4 id="1）面向对象的特性有哪些？-1"><a href="#1）面向对象的特性有哪些？-1" class="headerlink" title="1）面向对象的特性有哪些？"></a>1）面向对象的特性有哪些？</h4><p>答：封装、继承和多态<em>（应要多算一个那就是抽象）</em></p>
<ul>
<li><p><strong>封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。</strong><br>但封装不仅仅是 private + getter/setter ，使用封装可以对 setter 进行更深层次的定制，例如你可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。<strong>使用封装不仅仅安全，更可以简化操作。</strong>（封装扩展阅读：<a href="https://zhuanlan.zhihu.com/p/20174473" target="_blank" rel="noopener">oc面向对象三大特性之一 &lt;封装&gt;</a>）</p>
</li>
<li><p><strong>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。</strong><br>继承的缺点：<strong>1）</strong>继承是一种强耦合关系，父类变子类也必须变；<strong>2）</strong>继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。</p>
</li>
<li><p><strong>多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。</strong><br>比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。</p>
</li>
</ul>
<p><strong>多态的条件</strong>：<strong>1）</strong>继承；<strong>2）</strong>重写；<strong>3）</strong>向上转型。<br><strong>多态的好处</strong>：当把不同的子类对象都当作父类类型来看，<strong>可以屏蔽不同子类对象之间的实现差异，</strong>从而写出通用的代码达到通用编程，以适应需求的不断变化。（多态扩展阅读：<a href="https://www.jianshu.com/p/5771df145452" target="_blank" rel="noopener">重新认识java（五） —- 面向对象之多态（向上转型与向下转型）</a>）</p>
<ul>
<li><strong>抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。</strong></li>
</ul>
<h4 id="2）面向对象和面向过程的区别？-1"><a href="#2）面向对象和面向过程的区别？-1" class="headerlink" title="2）面向对象和面向过程的区别？"></a>2）面向对象和面向过程的区别？</h4><p>答：面向过程是<strong>一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程</strong>，即先干啥，后干啥。</p>
<p>面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-e6027912a8d8c7b6.png" alt=""></p>
<ul>
<li><strong>面向过程的缺陷：</strong><br>向过程的设计,是<strong>采用置顶而下的设计方式</strong>，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</li>
<li><strong>问题：</strong>1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。</li>
</ul>
<p>面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出<strong>面向对象</strong>思想。</p>
<p>面向对象是一种基于面向过程的新的编程思想，是<strong>一种站在对象的角度思考问题</strong>的思想，我们把多个功能合理的放到不同对象里，<strong>强调的是具备某些功能的对象。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-521c9e98caea7217.png" alt=""></p>
<ul>
<li>面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</li>
<li><strong>注意：</strong> 不要粗浅的认为面向对象一定就优于面向过程的设计</li>
</ul>
<blockquote>
<p>看到知乎上有一句有意思的话：</p>
<p>你的程序要完成一个任务，相当于讲一个故事。</p>
<p>面向过程：编年体；<br>面向对象：纪传体。</p>
<p>而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。</p>
</blockquote>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/28427324" target="_blank" rel="noopener">面向过程 VS 面向对象</a></p>
<h4 id="3）JDK-和-JRE-的区别是什么？-1"><a href="#3）JDK-和-JRE-的区别是什么？-1" class="headerlink" title="3）JDK 和 JRE 的区别是什么？"></a>3）JDK 和 JRE 的区别是什么？</h4><p>解析：这是考察一些基本的概念</p>
<p>答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 </p>
<p>Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。</p>
<blockquote>
<ul>
<li>还有其他的一些名词也可以再看一下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-8672d90bb496f196.png" alt=""></p>
</blockquote>
<h4 id="4）Java-中覆盖和重载是什么意思？-1"><a href="#4）Java-中覆盖和重载是什么意思？-1" class="headerlink" title="4）Java 中覆盖和重载是什么意思？"></a>4）Java 中覆盖和重载是什么意思？</h4><p>解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。</p>
<p>答：<strong>覆盖（Override）是指子类对父类方法的一种重写，</strong>只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。</p>
<p><strong>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</strong></p>
<p>面试官： 那么构成重载的条件有哪些？</p>
<p>答：参数类型不同、参数个数不同、参数顺序不同。</p>
<p>面试官： 函数的返回值不同可以构成重载吗？为什么？</p>
<p>答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下：</p>
<p>如下两个方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>
<p>只要编译器可以根据语境明确判断出语义，比如在 <code>int x = f();</code> 中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用” ），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用：</p>
<pre class=" language-java"><code class="language-java"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>此时 Java 如何才能判断调用的是哪一个 <code>f()</code> 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。</p>
<h4 id="5）抽象类和接口的区别有哪些？-1"><a href="#5）抽象类和接口的区别有哪些？-1" class="headerlink" title="5）抽象类和接口的区别有哪些？"></a>5）抽象类和接口的区别有哪些？</h4><p>答：</p>
<ol>
<li>抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；</li>
<li>抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。</li>
<li>抽象类只能单继承，接口可以继承多个父接口；</li>
<li>Java 8 中接口中会有 default 方法，即方法可以被实现。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-dc431887834333f7.png" alt=""></p>
<p><strong>面试官：抽象类和接口如何选择？</strong></p>
<p>答：</p>
<ol>
<li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p>
</li>
<li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p>
</li>
</ol>
<h4 id="6）Java-和-C-的区别：-1"><a href="#6）Java-和-C-的区别：-1" class="headerlink" title="6）Java 和 C++ 的区别："></a>6）Java 和 C++ 的区别：</h4><p>解析：虽然我们不太懂C++，但是就是会这么问，尤其是三面（总监级别）面试中。</p>
<p>答：</p>
<ol>
<li><p>都是面向对象的语言，都支持封装、继承和多态</p>
</li>
<li><p>指针：Java不提供指针来直接访问内存，程序更加安全</p>
</li>
<li><p>继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承</p>
</li>
<li><p>内存： Java有自动内存管理机制，不需要程序员手动释放无用内存</p>
</li>
</ol>
<h4 id="7）“static”-关键字是什么意思？-1"><a href="#7）“static”-关键字是什么意思？-1" class="headerlink" title="7）“static” 关键字是什么意思？"></a>7）“static” 关键字是什么意思？</h4><p>答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p>
<p>面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？</p>
<p>答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 </p>
<p>Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</p>
<p>扩展阅读：<a href="https://www.jianshu.com/p/3eb769986bd3" target="_blank" rel="noopener">重新认识java（六） —- java中的另类：static关键字（附代码块知识）</a></p>
<h4 id="8）Java-是值传递还是引用传递？-1"><a href="#8）Java-是值传递还是引用传递？-1" class="headerlink" title="8）Java 是值传递还是引用传递？"></a>8）Java 是值传递还是引用传递？</h4><p>解析：这类题目，面试官会手写一个例子，让你说出函数执行结果。</p>
<p>答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 </p>
<p>一般认为，Java 内的传递都是值传递.，Java 中实例对象的传递是引用传递，Java 是值传递的！</p>
<blockquote>
<ul>
<li>我们先来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-89340c032fb5b240.png" alt=""></p>
<p>这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？</p>
<p>这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。</p>
<blockquote>
<ul>
<li>再来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-75c3162752d36403.png" alt=""></p>
<p>我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？</p>
<p>你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！</p>
<h4 id="9）JDK-中常用的包有哪些？-1"><a href="#9）JDK-中常用的包有哪些？-1" class="headerlink" title="9）JDK 中常用的包有哪些？"></a>9）JDK 中常用的包有哪些？</h4><p>答：java.lang、java.util、java.io、java.net、java.sql。</p>
<h4 id="10）JDK，JRE-和-JVM-的联系和区别？-1"><a href="#10）JDK，JRE-和-JVM-的联系和区别？-1" class="headerlink" title="10）JDK，JRE 和 JVM 的联系和区别？"></a>10）JDK，JRE 和 JVM 的联系和区别？</h4><p>答：JDK 是 Java 开发工具包，是 Java 开发环境的核心组件，并提供编译、调试和运行一个 Java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。</p>
<p>JRE 是 Java 运行时环境，是 JVM 的实施实现，提供了运行 Java 程序的平台。JRE 包含了 JVM，但是不包含 Java 编译器 / 调试器之类的开发工具。</p>
<p>JVM 是 Java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。</p>
<p>这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因。</p>
<p>区别：</p>
<p>&emsp;&emsp;1. JDK 用于开发，JRE 用于运行 Java 程序；<br>&emsp;&emsp;2. JDK 和 JRE 中都包含 JVM；<br>&emsp;&emsp;3. JVM 是 Java 编程语言的核心并且具有平台独立性。</p>
<h4 id="11）Integer-的缓存机制-1"><a href="#11）Integer-的缓存机制-1" class="headerlink" title="11）Integer 的缓存机制"></a>11）Integer 的缓存机制</h4><p>解析：考察的是对源码的熟悉程度</p>
<blockquote>
<ul>
<li>看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-90331ba04ebe13fc.png" alt=""></p>
<blockquote>
<p>第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。</p>
<p>第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。</p>
<p>第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。</p>
</blockquote>
<p>我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-bd248da68e02bb2e.png" alt=""></p>
<p>跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的，了解就行了，不必去深究。）</p>
<h4 id="12）下述两种方法分别创建了几个-Sring-对象？-1"><a href="#12）下述两种方法分别创建了几个-Sring-对象？-1" class="headerlink" title="12）下述两种方法分别创建了几个 Sring 对象？"></a>12）下述两种方法分别创建了几个 Sring 对象？</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一种：直接赋一个字面量</span>
String str1 <span class="token operator">=</span> <span class="token string">"ABCD"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 第二种：通过构造器创建</span>
String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>解析：考察的是对 String 对象和 JVM 内存划分的知识。</p>
<p>答：<code>String str1 = &quot;ABCD&quot;;</code>最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用.</p>
<p><code>String str2 = new String(&quot;ABCD&quot;);</code>最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。</p>
<blockquote>
<p>我们来看图理解一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-70af9f49c51c9902.png" alt=""></p>
</blockquote>
<ul>
<li>当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD</li>
<li>当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。</li>
</ul>
<p>String 对象是一个特殊的存在，需要注意的知识点也比较多，这里给一个之前写的 String 详解的文章链接：<a href="https://www.jianshu.com/p/e494552f2cf0" target="_blank" rel="noopener">传送门</a> 其中包含的问题大概有：<strong>1）“+” 怎么连接字符串；2）字符串的比较；3）StringBuilder/StringBuffer/String 的区别；</strong></p>
<h4 id="13）i-与-i-到底有什么不同？-1"><a href="#13）i-与-i-到底有什么不同？-1" class="headerlink" title="13）i++ 与 ++i 到底有什么不同？"></a>13）i++ 与 ++i 到底有什么不同？</h4><p>解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，<strong>前置++和后置++一样，在参与运算之前都会将变量的值加 1</strong></p>
<p>答：实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。<strong>二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-4c68b98e2d0f4d2a.png" alt=""></p>
<h4 id="14）交换变量的三种方式-1"><a href="#14）交换变量的三种方式-1" class="headerlink" title="14）交换变量的三种方式"></a>14）交换变量的三种方式</h4><p>答：</p>
<blockquote>
<ul>
<li>第一种：通过第三个变量</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Value v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 无效的交换：形参的改变无法反作用于实参</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> y<span class="token punctuation">;</span>
        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有效的交换：通过引用（变量指向一个对象）来修改成员变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> value<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>x <span class="token operator">=</span> value<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Value</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>5<br>10<br>10<br>5</p>
</blockquote>
<p>这有点类似于C/C++语言中的指针，不过相对来说更加安全。</p>
<p>事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。</p>
<blockquote>
<p>第二种：通过通过相加的方式（相同的 Value 类不再重复展示）</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1的交换结果：<br>10<br>5</p>
</blockquote>
<p>核心的算法就是swap方法:</p>
<pre class=" language-java"><code class="language-java">v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在v.x中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y本来的值即为v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y的值也就是以前x.y的值</span></code></pre>
<p>这样就可以不通过临时变量，来达到交换两个变量的目的，如果觉得上面的方法不太容易理解，我们也可以用另一个参数z来表示上述过程：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> z <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在z中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉以前的v.y就等于v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉现在的v.y即以前的v.x，即为v.y</span></code></pre>
<p>但并<strong>不推荐这种做法</strong>，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。</p>
<blockquote>
<ul>
<li>第三种：通过异或的方式：</li>
</ul>
</blockquote>
<p>位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：<br><code>（x ^ y ^ y） == x</code>这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1交换之后的结果为：<br>10<br>5</p>
</blockquote>
<p>跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。<strong>异或的方法比相加更加可取的地方在于，异或不存在数据溢出。</strong></p>
<h4 id="15）Java-对象初始化顺序？-1"><a href="#15）Java-对象初始化顺序？-1" class="headerlink" title="15）Java 对象初始化顺序？"></a>15）Java 对象初始化顺序？</h4><p>答：不考虑静态成员的初始化，调用一个对象的构造函数时，程序<strong>先调用父类的构造函数</strong>（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），<strong>之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行</strong>，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；<strong>最后调用自身构造函数。</strong></p>
<blockquote>
<ul>
<li>我们可以写一段程序来对初始化顺序进行一个简单的验证：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> Member m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Initial Block()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Derive()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Member m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getInt()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Member</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Member</span><span class="token punctuation">(</span>String m<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Member() "</span><span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>程序的输出结果是：<br>Base()<br>Member() Member 1<br>Initial Block()<br>Member() Member 2<br>getInt()<br>Derive()</p>
</blockquote>
<h4 id="16）true、false-与-null-是关键字吗？-1"><a href="#16）true、false-与-null-是关键字吗？-1" class="headerlink" title="16）true、false 与 null 是关键字吗？"></a>16）true、false 与 null 是关键字吗？</h4><p>答：不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。</p>
<p>面试官：那 goto 与 const 呢？</p>
<p>答：是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。</p>
<h4 id="17）exception-和-error-有什么区别？-1"><a href="#17）exception-和-error-有什么区别？-1" class="headerlink" title="17）exception 和 error 有什么区别？"></a>17）exception 和 error 有什么区别？</h4><p>答：exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。</p>
<p>exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 </p>
<h4 id="18）throw-和-throws-有什么区别？-1"><a href="#18）throw-和-throws-有什么区别？-1" class="headerlink" title="18）throw 和 throws 有什么区别？"></a>18）throw 和 throws 有什么区别？</h4><p>答：throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p>
<blockquote>
<p>小结：本节主要阐述了 Java 基础知识，并没有涉及到一些高级的特性，这些问题一般难度不大，适当复习下，应该没问题。</p>
</blockquote>
<hr>
<h2 id="（二）Java-中常见集合-1"><a href="#（二）Java-中常见集合-1" class="headerlink" title="（二）Java 中常见集合"></a>（二）Java 中常见集合</h2><p>集合这方面的考察相当多，这部分是面试中必考的知识点。</p>
<h4 id="1）说说常见的集合有哪些吧？-1"><a href="#1）说说常见的集合有哪些吧？-1" class="headerlink" title="1）说说常见的集合有哪些吧？"></a>1）说说常见的集合有哪些吧？</h4><p>答：Map接口和Collection接口是所有集合框架的父接口：</p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<h4 id="2）HashMap和Hashtable的区别有哪些？（必问）-1"><a href="#2）HashMap和Hashtable的区别有哪些？（必问）-1" class="headerlink" title="2）HashMap和Hashtable的区别有哪些？（必问）"></a>2）HashMap和Hashtable的区别有哪些？（必问）</h4><p>答：</p>
<ol>
<li><p>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</p>
</li>
<li><p>前者允许null作为Key；后者不允许null作为Key</p>
</li>
</ol>
<h4 id="3）HashMap的底层实现你知道吗？-1"><a href="#3）HashMap的底层实现你知道吗？-1" class="headerlink" title="3）HashMap的底层实现你知道吗？"></a>3）HashMap的底层实现你知道吗？</h4><p>答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-47e48966bd6fec65.png" alt=""></p>
<h4 id="4）ConcurrentHashMap-和-Hashtable-的区别？（必问）-1"><a href="#4）ConcurrentHashMap-和-Hashtable-的区别？（必问）-1" class="headerlink" title="4）ConcurrentHashMap 和 Hashtable 的区别？（必问）"></a>4）ConcurrentHashMap 和 Hashtable 的区别？（必问）</h4><p> <strong>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶。</strong></p>
<p><strong>面试官：ConcurrentHashMap的具体实现知道吗？</strong></p>
<p><strong>答：</strong></p>
<p><strong>1.  该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</strong></p>
<p><strong>2.  Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</strong></p>
<h4 id="5）HashMap-的长度为什么是2的幂次方？-1"><a href="#5）HashMap-的长度为什么是2的幂次方？-1" class="headerlink" title="5）HashMap 的长度为什么是2的幂次方？"></a>5）HashMap 的长度为什么是2的幂次方？</h4><p><strong>答：</strong></p>
<p><strong>1.  通过将 Key 的 hash 值与 length - 1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率</strong></p>
<p><strong>2.  如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</strong></p>
<h4 id="6）List和Set的区别是啥？-1"><a href="#6）List和Set的区别是啥？-1" class="headerlink" title="6）List和Set的区别是啥？"></a>6）List和Set的区别是啥？</h4><p><strong>答：List元素是有序的，可以重复；Set元素是无序的，不可以重复。</strong></p>
<h4 id="7）List、Set和Map的初始容量和加载因子：-1"><a href="#7）List、Set和Map的初始容量和加载因子：-1" class="headerlink" title="7）List、Set和Map的初始容量和加载因子："></a>7）List、Set和Map的初始容量和加载因子：</h4><p><strong>答：</strong></p>
<p><strong>1. List</strong></p>
<ul>
<li><p><strong>ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。</strong></p>
</li>
<li><p><strong>Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。</strong></p>
</li>
</ul>
<p><strong>2. Set</strong></p>
<p><strong>HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32</strong></p>
<p><strong>3. Map</strong></p>
<p><strong>HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32</strong></p>
<h4 id="8）Comparable接口和Comparator接口有什么区别？-1"><a href="#8）Comparable接口和Comparator接口有什么区别？-1" class="headerlink" title="8）Comparable接口和Comparator接口有什么区别？"></a>8）Comparable接口和Comparator接口有什么区别？</h4><p><strong>答：</strong></p>
<p><strong>1.  前者简单，但是如果需要重新定义比较类型时，需要修改源代码。</strong></p>
<p><strong>2.  后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 具体解析参考博客：<a href="http://blog.csdn.net/qq_25827845/article/details/51287142" target="_blank" rel="noopener">Java集合框架—Set</a></strong></p>
<h4 id="9）Java集合的快速失败机制-“fail-fast”-1"><a href="#9）Java集合的快速失败机制-“fail-fast”-1" class="headerlink" title="9）Java集合的快速失败机制 “fail-fast”"></a>9）Java集合的快速失败机制 “fail-fast”</h4><p><strong>答：</strong></p>
<p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p>
<p><strong>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</strong></p>
<p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1.  在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p>
<p><strong>2.  使用CopyOnWriteArrayList来替换ArrayList</strong></p>
<h4 id="10）ArrayList-和-Vector-的区别-1"><a href="#10）ArrayList-和-Vector-的区别-1" class="headerlink" title="10）ArrayList 和 Vector 的区别"></a>10）ArrayList 和 Vector 的区别</h4><p>答：</p>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList 与 Vector 的区别主要包括两个方面：</p>
<ol>
<li><p>同步性：<br>Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
</li>
<li><p>数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。</p>
</li>
</ol>
<p><strong>面试官：那 ArrayList 和 LinkedList 的区别呢？</strong></p>
<p>答：</p>
<ol>
<li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；</li>
<li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li>
<li>LinkedList 比 ArrayList 需要更多的内存；</li>
</ol>
<p><strong>面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</strong></p>
<p>答：它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 </li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。 </li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 </li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h4 id="11）如何去掉一个-Vector-集合中重复的元素？-1"><a href="#11）如何去掉一个-Vector-集合中重复的元素？-1" class="headerlink" title="11）如何去掉一个 Vector 集合中重复的元素？"></a>11）如何去掉一个 Vector 集合中重复的元素？</h4><p>答：</p>
<pre class=" language-java"><code class="language-java">Vector newVector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object obj <span class="token operator">=</span> vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newVector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newVector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>还有一种简单的方式，利用了 Set 不允许重复元素的特性：</p>
<pre class=" language-java"><code class="language-java">HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。</p>
</blockquote>
<h4 id="12）如何权衡是使用无序的数组还是有序的数组？-1"><a href="#12）如何权衡是使用无序的数组还是有序的数组？-1" class="headerlink" title="12）如何权衡是使用无序的数组还是有序的数组？"></a>12）如何权衡是使用无序的数组还是有序的数组？</h4><p>答：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p>
<hr>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>oh…..复习下来还真是酸爽….前路漫漫啊….</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/08/spring-boot-kuai-su-ru-men/">
      Spring Boot【快速入门】
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb基础/SpringBoot</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月8日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-9323041dd0ce883e.png" alt=""></p>
<h2 id="Spring-Boot-概述"><a href="#Spring-Boot-概述" class="headerlink" title="Spring Boot 概述"></a>Spring Boot 概述</h2><blockquote>
<p><strong>Build Anything with Spring Boot：</strong> Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.</p>
</blockquote>
<p>上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p>
<h4 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a>什么是 Spring Boot</h4><ul>
<li>它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。</li>
<li>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：<a href="http://www.ityouknow.com/springboot/2016/01/06/springboot(%E4%B8%80)-%E5%85%A5%E9%97%A8%E7%AF%87.html" target="_blank" rel="noopener">springboot(一)：入门篇——纯洁的微笑</a>）</li>
</ul>
<h4 id="使用-Spring-Boot-有什么好处"><a href="#使用-Spring-Boot-有什么好处" class="headerlink" title="使用 Spring Boot 有什么好处"></a>使用 Spring Boot 有什么好处</h4><p>回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：</p>
<ul>
<li>1）配置 web.xml，加载 spring 和 spring mvc</li>
<li>2）配置数据库连接、配置日志文件</li>
<li>3）配置家在配置文件的读取，开启注解</li>
<li>4）配置mapper文件</li>
<li><strong>…..</strong></li>
</ul>
<p>而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… </p>
<ul>
<li>划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。</li>
</ul>
<hr>
<h2 id="Spring-Boot-快速搭建"><a href="#Spring-Boot-快速搭建" class="headerlink" title="Spring Boot 快速搭建"></a>Spring Boot 快速搭建</h2><h4 id="第一步：新建项目"><a href="#第一步：新建项目" class="headerlink" title="第一步：新建项目"></a>第一步：新建项目</h4><p>选择 Spring Initializr ，然后选择默认的 url 点击【Next】：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-3e2c9c5742c10c86.png" alt=""></p>
<p>然后修改一下项目的信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-28dbe478ff25a3a0.png" alt=""></p>
<p>勾选上 Web 模板：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-532868b7e6760e03.png" alt=""></p>
<p>选择好项目的位置，点击【Finish】：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-931cc2fb5c8964e9.png" alt=""></p>
<p>如果是第一次配置 Spring Boot 的话可能需要等待一会儿 IDEA 下载相应的 依赖包，默认创建好的项目结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-9ac7acc56d5a32f0.png" alt=""></p>
<p>项目结构还是看上去挺清爽的，少了很多配置文件，我们来了解一下默认生成的有什么：</p>
<ul>
<li>SpringbootApplication： 一个带有 main() 方法的类，用于启动应用程序</li>
<li>SpringbootApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文</li>
<li>application.properties：一个空的 properties 文件，可以根据需要添加配置属性</li>
<li>pom.xml： Maven 构建说明文件</li>
</ul>
<h4 id="第二步：HelloController"><a href="#第二步：HelloController" class="headerlink" title="第二步：HelloController"></a>第二步：HelloController</h4><p>在【cn.wmyskxz.springboot】包下新建一个【HelloController】：</p>
<pre><code>package cn.wmyskxz.springboot;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 测试控制器
 *
 * @author: @我没有三颗心脏
 * @create: 2018-05-08-下午 16:46
 */
@RestController
public class HelloController {

    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello Spring Boot!&quot;;
    }
}</code></pre><ul>
<li><strong>@RestController 注解：</strong> 该注解是 @Controller 和 @ResponseBody 注解的合体版</li>
</ul>
<h4 id="第三步：利用-IDEA-启动-Spring-Boot"><a href="#第三步：利用-IDEA-启动-Spring-Boot" class="headerlink" title="第三步：利用 IDEA 启动 Spring Boot"></a>第三步：利用 IDEA 启动 Spring Boot</h4><p>我们回到 SpringbootApplication 这个类中，然后右键点击运行：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-bf1aa6ed5c0db7b4.png" alt=""></p>
<ul>
<li><strong>注意</strong>：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat </li>
</ul>
<p>等待一会儿就会看到下方的成功运行的提示信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-63e43dc6a277de3e.png" alt=""></p>
<p>可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “<code>/hello</code>” 地址试一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-6111e1913c5bf6d6.png" alt=""></p>
<p>可以看到页面成功显示出我们返回的信息。</p>
<hr>
<h2 id="解析-Spring-Boot-项目"><a href="#解析-Spring-Boot-项目" class="headerlink" title="解析 Spring Boot 项目"></a>解析 Spring Boot 项目</h2><blockquote>
<p>这一部分参考自：<a href="http://tengj.top/2017/02/26/springboot1/" target="_blank" rel="noopener">Spring Boot干货系列（一）优雅的入门篇 ——嘟嘟独立博客</a></p>
</blockquote>
<h4 id="解析-pom-xml-文件"><a href="#解析-pom-xml-文件" class="headerlink" title="解析 pom.xml 文件"></a>解析 pom.xml 文件</h4><p>让我们来看看默认生成的 pom.xml 文件中到底有一些什么特别：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt;
    &lt;artifactId&gt;springboot&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;springboot&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre><p>我们可以看到一个比较陌生一些的标签 <code>&lt;parent&gt;</code> ，这个标签是在配置 Spring Boot 的父级依赖：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;</code></pre><p>有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的 Maven 默认依赖，<strong>使用它之后，常用的包依赖就可以省去 version 标签。</strong></p>
<p>关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\repository\org\springframework\boot\spring-boot-dependencies\2.0.1.RELEASE\spring-boot-dependencies-2.0.1.RELEASE.pom 文件来查看，挺长的…</p>
<h4 id="应用入口类"><a href="#应用入口类" class="headerlink" title="应用入口类"></a>应用入口类</h4><p>Spring Boot 项目通常有一个名为 <em>Application 的入口类，入口类里有一个 main 方法， *</em>这个 main 方法其实就是一个标准的 Javay 应用的入口方法。** </p>
<p><strong>@SpringBootApplication</strong> 是 Spring Boot 的核心注解，它是一个组合注解，该注解组合了：<strong>@Configuration、@EnableAutoConfiguration、@ComponentScan；</strong> 若不是用 @SpringBootApplication 注解也可以使用这三个注解代替。</p>
<ul>
<li>其中，<strong>@EnableAutoConfiguration 让 Spring Boot 根据类路径中的 jar 包依赖为当前项目进行自动配置</strong>，例如，添加了 spring-boot-starter-web 依赖，会自动添加 Tomcat 和 Spring MVC 的依赖，那么 Spring Boot 会对 Tomcat 和 Spring MVC 进行自动配置。</li>
<li><strong>Spring Boot 还会自动扫描 @SpringBootApplication 所在类的同级包以及下级包里的 Bean</strong> ，所以入口类建议就配置在 grounpID + arctifactID 组合的包名下（这里为 cn.wmyskxz.springboot 包）</li>
</ul>
<h4 id="Spring-Boot-的配置文件"><a href="#Spring-Boot-的配置文件" class="headerlink" title="Spring Boot 的配置文件"></a>Spring Boot 的配置文件</h4><p>Spring Boot 使用一个全局的配置文件 application.properties 或 application.yml，放置在【src/main/resources】目录或者类路径的 /config 下。</p>
<p>Spring Boot 不仅支持常规的 properties 配置文件，还支持 yaml 语言的配置文件。yaml 是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p>
<p>Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。</p>
<blockquote>
<ul>
<li>简单实例一下</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-bcd65f7469b06608.png" alt=""></p>
<p>我们同样的将 Tomcat 默认端口设置为 8080 ，并将默认的访问路径从 “<code>/</code>” 修改为 “<code>/hello</code>” 时，使用 properties 文件和 yml 文件的区别如上图。</p>
<ul>
<li>注意： yml 需要在 “<code>:</code>” 后加一个空格，幸好 IDEA 很好地支持了 yml 文件的格式有良好的代码提示；</li>
</ul>
<blockquote>
<ul>
<li>我们可以自己配置多个属性</li>
</ul>
</blockquote>
<p>我们直接把 .properties 后缀的文件删掉，使用 .yml 文件来进行简单的配置，然后使用 @Value 来获取配置属性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-0e808a82254d6a4b.png" alt=""></p>
<p>重启 Spring Boot ，输入地址：localhost:8080/hello 能看到正确的结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-c85216e8ea7910f0.png" alt=""></p>
<ul>
<li><strong>注意：</strong> 我们并没有在 yml 文件中注明属性的类型，而是在使用的时候定义的。</li>
</ul>
<p>你也可以在配置文件中使用当前配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-37e91abbc4550982.png" alt=""></p>
<p>仍然可以得到正确的结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-eabc3cd39b44fd0d.png" alt=""></p>
<ul>
<li><strong>问题：</strong> 这样写配置文件繁琐而且可能会造成类的臃肿，因为有许许多多的 @Value 注解。</li>
</ul>
<blockquote>
<ul>
<li>封装配置信息</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-2599817d8f2f50d2.png" alt=""></p>
<p>我们可以把配置信息封装成一个类，首先在我们的 name 和 age 前加一个 student 前缀，然后新建一个 StudentProperties 的类用来封装这些信息，并用上两个注解：</p>
<ul>
<li>@Component：表明当前类是一个 Java Bean </li>
<li>@ConfigurationProperties(prefix = “student”)：表示获取前缀为 sutdent 的配置信息</li>
</ul>
<p>这样我们就可以在控制器中使用，重启得到正确信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-84dc1215d01f3fa9.png" alt=""></p>
<h4 id="Spring-Boot-热部署"><a href="#Spring-Boot-热部署" class="headerlink" title="Spring Boot 热部署"></a>Spring Boot 热部署</h4><p>在目前的 Spring Boot 项目中，当发生了任何修改之后我们都需要重新启动才能够正确的得到效果，这样会略显麻烦，Spring Boot 提供了热部署的方式，当发现任何类发生了改变，就会通过 JVM 类加载的方式，加载最新的类到虚拟机中，这样就不需要重新启动也能看到修改后的效果了。</p>
<blockquote>
<ul>
<li>做法也很简单，修改 pom.xml 即可！</li>
</ul>
</blockquote>
<p>我们往 pom.xml 中添加一个依赖就可以了：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt;
&lt;/dependency&gt;</code></pre><p>重新启动 Spring Boot ，然后修改任意代码，就能观察到控制台的自动重启现象：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-cec869956c3cf158.png" alt=""></p>
<blockquote>
<p>关于如何在 IDEA 中配置热部署：<a href="https://blog.csdn.net/xusheng_Mr/article/details/78771746" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
<hr>
<h2 id="Spring-Boot-使用"><a href="#Spring-Boot-使用" class="headerlink" title="Spring Boot 使用"></a>Spring Boot 使用</h2><p>上面已经完成了 Spring Boot 项目的简单搭建，我们仅仅需要进行一些简单的设置，写一个 HelloController 就能够直接运行了，不要太简单…接下来我们再深入了解一下 Spring Boot 的使用。</p>
<h4 id="Spring-Boot-支持-JSP"><a href="#Spring-Boot-支持-JSP" class="headerlink" title="Spring Boot 支持 JSP"></a>Spring Boot 支持 JSP</h4><p>Spring Boot 的默认视图支持是 Thymeleaf 模板引擎，但是这个我们不熟悉啊，我们还是想要使用 JSP 怎么办呢？</p>
<blockquote>
<ul>
<li>第一步：修改 pom.xml 增加对 JSP 文件的支持</li>
</ul>
</blockquote>
<pre><code>&lt;!-- servlet依赖. --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- tomcat的支持.--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre><blockquote>
<ul>
<li>第二步：配置试图重定向 JSP 文件的位置</li>
</ul>
</blockquote>
<p>修改 application.yml 文件，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-7c17f7e10cfb2629.png" alt=""></p>
<blockquote>
<ul>
<li>第三步：修改 HelloController</li>
</ul>
</blockquote>
<p>修改 @RestController 注解为 @Controller ，然后将 hello 方法修改为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-2dc2c39cd962edc1.png" alt=""></p>
<blockquote>
<ul>
<li>第四步：新建 hello.jsp 文件</li>
</ul>
</blockquote>
<p>在【src/main】目录下依次创建 webapp、WEB-INF、views 目录，并创建一个 hello.jsp 文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-a180556d7ead9605.png" alt=""></p>
<blockquote>
<ul>
<li>第五步：刷新网页</li>
</ul>
</blockquote>
<p>因为我们部署了热部署功能，所以只需要等待控制台重启信息完成之后再刷新网页就可以看到正确效果了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-cfd20f747ffca978.png" alt=""></p>
<ul>
<li>关于 404，使用 spring-boot:run 运行项目可以解决：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-27c1bf46487ba5eb.png" alt=""></p>
<h4 id="集成-MyBatis"><a href="#集成-MyBatis" class="headerlink" title="集成 MyBatis"></a>集成 MyBatis</h4><blockquote>
<ul>
<li>第一步：修改 pom.xml 增加对 MySql和 MyBatis 的支持</li>
</ul>
</blockquote>
<pre><code>
&lt;!-- mybatis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- mysql --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.21&lt;/version&gt;
&lt;/dependency&gt;</code></pre><blockquote>
<ul>
<li>第二步：新增数据库链接参数</li>
</ul>
</blockquote>
<p>这里我们就直接使用之前创建好的 student 表了吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-1eda563cfdfbae65.png" alt=""></p>
<blockquote>
<ul>
<li>第三步：创建 Student 实体类和 StudentMapper 映射类</li>
</ul>
</blockquote>
<p>在【cn.wmyskxz.springboot】下新建一个【pojo】包，然后在其下创建一个 Student 类：</p>
<pre><code>public class Student {

    private Integer id;
    private Integer student_id;
    private String name;
    private Integer age;
    private String sex;
    private Date birthday;

    /* getter and setter */
}</code></pre><p>在【cn.wmyskxz.springboot】下新建一个【mapper】包，然后在其下创建一个 StudentMapper 映射类：</p>
<pre><code>package cn.wmyskxz.springboot.mapper;

import cn.wmyskxz.springboot.pojo.Student;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

@Mapper
public interface StudentMapper {

    @Select(&quot;SELECT * FROM student&quot;)
    List&lt;Student&gt; findAll();
}</code></pre><blockquote>
<ul>
<li>第四步：编写 StudentController</li>
</ul>
</blockquote>
<p>在【cn.wmyskxz.springboot】下新建一个【controller】包，然后在其下创建一个 StudentController ：</p>
<pre><code>package cn.wmyskxz.springboot.controller;

import cn.wmyskxz.springboot.mapper.StudentMapper;
import cn.wmyskxz.springboot.pojo.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;

/**
 * Student 控制器
 *
 * @author: @我没有三颗心脏
 * @create: 2018-05-08-下午 20:25
 */
@Controller
public class StudentController {

    @Autowired
    StudentMapper studentMapper;

    @RequestMapping(&quot;/listStudent&quot;)
    public String listStudent(Model model) {
        List&lt;Student&gt; students = studentMapper.findAll();
        model.addAttribute(&quot;students&quot;, students);
        return &quot;listStudent&quot;;
    }
}</code></pre><blockquote>
<p>第五步：编写 listStudent.jsp 文件</p>
</blockquote>
<p>我们简化一下 JSP 的文件，仅显示两个字段的数据：</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;

&lt;table align=&#39;center&#39; border=&#39;1&#39; cellspacing=&#39;0&#39;&gt;
    &lt;tr&gt;
        &lt;td&gt;id&lt;/td&gt;
        &lt;td&gt;name&lt;/td&gt;
    &lt;/tr&gt;
    &lt;c:forEach items=&quot;${students}&quot; var=&quot;s&quot; varStatus=&quot;st&quot;&gt;
        &lt;tr&gt;
            &lt;td&gt;${s.id}&lt;/td&gt;
            &lt;td&gt;${s.name}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/c:forEach&gt;
&lt;/table&gt;</code></pre><blockquote>
<ul>
<li>第六步：重启服务器运行</li>
</ul>
</blockquote>
<p>因为往 pom.xml 中新增加了依赖的包，所以自动重启服务器没有作用，我们需要手动重启一次，然后在地址输入：localhost:8080/listStudent 查看效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Spring-Boot%E3%80%90%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/7896890-5fd3c075d07b5840.png" alt=""></p>
<blockquote>
<p>以上。</p>
</blockquote>
<hr>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>how2j.cn-Spring Boot 系列教程</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz<br>分享自己的学习 &amp; 学习资料 &amp; 生活<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/07/mo-fang-tian-mao-shi-zhan-ssm-zong-jie/">
      模仿天猫实战【SSM】——总结
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb基础/SSM/项目</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月7日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>第一篇文章链接：<a href="https://www.jianshu.com/p/5e44ee046b43" target="_blank" rel="noopener">模仿天猫实战【SSM版】——项目起步</a><br>第二篇文章链接：<a href="https://www.jianshu.com/p/484096db003f" target="_blank" rel="noopener">模仿天猫实战【SSM版】——后台开发</a></p>
<p>总结：项目从4-27号开始写，到今天5-7号才算真正的完工，有许多粗糙的地方，但总算完成了，比想象中的开发周期要久的多，并且大部分的时间都花在了前端页面的编写上…仅以此文来总结一下</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-3eee3c0023557f8e.png" alt=""></p>
<h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><h4 id="功能一览表"><a href="#功能一览表" class="headerlink" title="功能一览表"></a>功能一览表</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-8de7d88e63f5feab.png" alt=""></p>
<p>大致理了一下功能列表，应该是齐全的，其中推荐链接暂时不支持修改。</p>
<h4 id="项目页面一览表"><a href="#项目页面一览表" class="headerlink" title="项目页面一览表"></a>项目页面一览表</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-8265022a0d8fde56.png" alt=""></p>
<ul>
<li><strong>后端页面：</strong> 后台所需要用到的页面，从名字很好区分功能，其中 index.jsp 只有一行代码用于跳转</li>
<li><strong>公共页面：</strong> 都是前端页面，从对天猫页面的分析提取出一些复用比较高的页面用于动态的包含在其他前端页面中。</li>
<li><strong>前台页面：</strong>前台相较于后台页面 CSS 更加复杂，交互也更多，我把每一个页面的需要用到的 css 和 js 代码均保留在了当前 JSP 页面中，方便浏览学习。</li>
</ul>
<h4 id="项目主要逻辑类"><a href="#项目主要逻辑类" class="headerlink" title="项目主要逻辑类"></a>项目主要逻辑类</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-2ee2704c72494225.png" alt=""></p>
<ul>
<li><strong>控制器（Controller）：</strong> 用于控制页面的逻辑， 提取出一个 PageController 来专门控制页面的跳转，ForeController 用于前台所有的逻辑操作</li>
<li><strong>拦截器（Interceptor）：</strong> LoginInteceptor 用于对登录进行判断，因为有一些页面需要登录之后才能访问的，例如：购物车；OtherInterceptor 用于向页面中添加一些其他的数据，例如：购物车数量。</li>
<li><strong>业务层（Service层）：</strong> 业务处理层，其中封装了 Dao 层，用于完成主要的逻辑处理。</li>
</ul>
<blockquote>
<p>不需要登录就能访问的页面（以下为拦截器中的代码片段）：<br><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-0cc94a89ec585ea2.png" alt=""></p>
<ul>
<li>其中包括：主页、搜索结果页、产品展示页、登录页、注册页。</li>
<li>还包括一些其他的路径用于处理逻辑，test 为开发过程中用于测试的页面</li>
</ul>
</blockquote>
<h2 id="前台总结"><a href="#前台总结" class="headerlink" title="前台总结"></a>前台总结</h2><p>前台花费了大部分的时间，不仅仅是繁杂的样式和页面需要自己去编写，业务逻辑也比后台要复杂一些，因为是模仿，所以大部分的 CSS 我都是参照着天猫官网写的（利用FireFox来查看元素和元素样式）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-253d0a2d979404f7.png" alt=""></p>
<p>另外一部分是参照了how2j.cn上模仿的前端教程：<a href="http://how2j.cn/k/tmall-front/tmall-front-790/790.html" target="_blank" rel="noopener">戳这里</a></p>
<h4 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-1a0c952535b9559d.png" alt=""></p>
<p>简要的首页大概就是这样，请别在意轮播下面的【女装/内衣】中的产品，因为在4月份的时候，第一个分类的名字还叫【女装 /男装 /内衣】（好像是这个），后来项目写着写着突然改了…</p>
<p>观察大部分的页面，其实都是包含了其中的三个部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-366e78dae956c6eb.png" alt=""></p>
<p>即顶部导航栏、一个搜索框、还有底部，我们可以单独把他们写成一个 jsp ，并动态的包含在我们的页面中</p>
<blockquote>
<ul>
<li>首页分类栏</li>
</ul>
</blockquote>
<p>因为一开始，我以为分类栏中保存的是一些直接的产品，但是分析前端的时候发现它们只是一些 hot-word 热词，所以为了和天猫的首页保持一致，我直接把分类栏写死了写成了一个单独的 JSP 文件并包含进了主页：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-45ee80b50df9085c.png" alt=""></p>
<p>我还自己写了一个小程序，用来将这些 hor-word 转换成对应的 html 代码，不然这手写 2000 行可能真的够呛…</p>
<h4 id="产品搜索页"><a href="#产品搜索页" class="headerlink" title="产品搜索页"></a>产品搜索页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-c2f1edc856487a15.png" alt=""></p>
<p>并且支持按照【综合（销量*评价）】、【人气（评论量）】、【销量】、【价格】来排序产品，使用 Java 8 的新特性来完成该功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-f8b52056229d0e0f.png" alt=""></p>
<h4 id="产品展示页"><a href="#产品展示页" class="headerlink" title="产品展示页"></a>产品展示页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-7c2807d14ba0aa63.png" alt=""></p>
<p>所有的产品展示图片均是来自how2j.com上的一张图，前面有链接，表示有参照这个教程来做。</p>
<h4 id="购买页"><a href="#购买页" class="headerlink" title="购买页"></a>购买页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-08a11273e23d0019.png" alt=""></p>
<p>在产品页中点击立即购买，或者在购物车点击结算都会跳转到该页面，创建订单。</p>
<h4 id="付款页面"><a href="#付款页面" class="headerlink" title="付款页面"></a>付款页面</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-45fee843691d32a4.png" alt=""></p>
<p>无耻的黏了一张自己的收款二维码…</p>
<h4 id="付款成功页"><a href="#付款成功页" class="headerlink" title="付款成功页"></a>付款成功页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-4412da524b78fbc9.png" alt=""></p>
<p>当点击确认支付按钮之后，就会跳转到该页面来。</p>
<h4 id="购物车页"><a href="#购物车页" class="headerlink" title="购物车页"></a>购物车页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-f9d2c11534b7c884.png" alt=""></p>
<p>该页面支持删除订单和对订单项进行相关的操作，点击结算页面跳转到购买页。</p>
<h4 id="我的订单页"><a href="#我的订单页" class="headerlink" title="我的订单页"></a>我的订单页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-a9bba1fd07a97acc.png" alt=""></p>
<p>该页面用于对订单的管理，可以查看和操作订单。</p>
<h4 id="评价页"><a href="#评价页" class="headerlink" title="评价页"></a>评价页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-7f24722600e49c63.png" alt=""></p>
<p>当完成购买，即经过购买→支付→发货→确认收货的流程之后，即可对产品进行评论，评论完成后能看到其他用户的评价信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-f597c88795ac8eef.png" alt=""></p>
<h4 id="注册页"><a href="#注册页" class="headerlink" title="注册页"></a>注册页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-b3fcc1bebad7c58c.png" alt=""></p>
<p>用户注册页，在前端判断两次密码是否相同，并提交给后台判断用户名是否唯一。</p>
<h4 id="登录页"><a href="#登录页" class="headerlink" title="登录页"></a>登录页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-11c055b0974e3895.png" alt=""></p>
<p>因为分辨率的问题有一点 BUG，不过不影响体验，登录之后顶部导航栏出现用户信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-9bc95b094347e682.png" alt=""></p>
<hr>
<h2 id="后台总结"><a href="#后台总结" class="headerlink" title="后台总结"></a>后台总结</h2><p>前台因为有现成的原型可以参照和模仿，后台需要自己去设计和实现界面，所以我直接找了一个模板代码，很方便也很快的完成了开发，在我的第二篇文章：<a href="https://www.jianshu.com/p/484096db003f" target="_blank" rel="noopener">模仿天猫实战【SSM版】——后台开发</a> 有介绍。</p>
<h4 id="分类管理"><a href="#分类管理" class="headerlink" title="分类管理"></a>分类管理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-8b874a9caba8a982.png" alt=""></p>
<p>其中的分页和搜索功能是我找来的模板中用 js 代码来实现的，分类管理中不仅提供了更改分类名称的功能，还能管理分类下的产品和属性。</p>
<h4 id="产品管理页"><a href="#产品管理页" class="headerlink" title="产品管理页"></a>产品管理页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-ec968f34fdba0fea.png" alt=""></p>
<h4 id="产品图片管理页"><a href="#产品图片管理页" class="headerlink" title="产品图片管理页"></a>产品图片管理页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-c1a5f55b81f871a1.png" alt=""></p>
<p>产品的图片是默认放置在 <code>img/product/产品的id号/</code> 目录下的，并且默认的五张图片分别为：1.jpg、2.jpg…..5.jpg，用于默认显示的图片均为 1.jpg</p>
<h4 id="属性值管理页"><a href="#属性值管理页" class="headerlink" title="属性值管理页"></a>属性值管理页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-44c9c3d0b5bae37d.png" alt=""></p>
<p>产品属性值管理页，能增加的属性值只能为当前分类下拥有的属性。</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-f155c8d139aa1f7c.png" alt=""></p>
<p>提供一个修改密码的功能，给申诉修改密码的用户留一条后路。</p>
<h4 id="订单管理页"><a href="#订单管理页" class="headerlink" title="订单管理页"></a>订单管理页</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-bb85ec56c0820d71.png" alt=""></p>
<p>等待发货的订单有一个发货按钮，用于发货。</p>
<blockquote>
<p>上面有一些产品管理的按钮乱入了..直接拷贝的之前的图片，左侧栏中的产品管理按钮是删除了的…</p>
</blockquote>
<h4 id="推荐链接管理"><a href="#推荐链接管理" class="headerlink" title="推荐链接管理"></a>推荐链接管理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-1dd1a3ec88dc56b6.png" alt=""></p>
<p>暂时不提供修改功能。</p>
<hr>
<h2 id="项目中遇到的一些问题"><a href="#项目中遇到的一些问题" class="headerlink" title="项目中遇到的一些问题"></a>项目中遇到的一些问题</h2><h4 id="轮播失效"><a href="#轮播失效" class="headerlink" title="轮播失效"></a>轮播失效</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-883473b3c260be5f.png" alt=""></p>
<p>Bootstrap 的引入要在 JQuery 之后，不然不能正常使用…</p>
<h4 id="为什么不在-PropertyValue-表中增加-property-name-字段？"><a href="#为什么不在-PropertyValue-表中增加-property-name-字段？" class="headerlink" title="为什么不在 PropertyValue 表中增加 property_name 字段？"></a>为什么不在 PropertyValue 表中增加 property_name 字段？</h4><p>在产品详情页明显感觉到显示产品的属性的时候，特别不方便。</p>
<h4 id="PropertyValue"><a href="#PropertyValue" class="headerlink" title="PropertyValue"></a>PropertyValue</h4><p>新增一个 Property 属性，来完成产品页的传递</p>
<h4 id="后台属性值管理逻辑有点问题"><a href="#后台属性值管理逻辑有点问题" class="headerlink" title="后台属性值管理逻辑有点问题"></a>后台属性值管理逻辑有点问题</h4><p>之前的代码：</p>
<pre><code>&lt;c:forEach items=&quot;${propertyValues}&quot; var=&quot;pv&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;c:forEach items=&quot;${properties}&quot; var=&quot;p&quot;&gt;
                &lt;c:if test=&quot;${p.id==pv.property_id}&quot;&gt;${p.name}&lt;/c:if&gt;
            &lt;/c:forEach&gt;
        &lt;/td&gt;
        &lt;td&gt;${pv.value}&lt;/td&gt;
        &lt;td&gt;&lt;a href=&quot;editPropertyValue?id=${pv.id}&quot;&gt;&lt;span
                class=&quot;glyphicon glyphicon-edit&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;a href=&quot;deletePropertyValue?id=${pv.id}&amp;category_id=${product.category_id}&quot;&gt;&lt;span
                    class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;</code></pre><p>非常糟糕，逻辑就是错的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-f65e97fdeb5b4ecc.png" alt=""></p>
<p>利用上面为 PropertyValue 添加的 Property 来完成功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-8e0814d7b3eb7ee7.png" alt=""></p>
<blockquote>
<ul>
<li>下面的 select 标签也是错的</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-890297352553a12f.png" alt=""></p>
<p>生成出来的代码是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-3848bd97481ea5a7.png" alt=""></p>
<p>我想要绑定一个隐藏的 input ，看来这样写是不行的，搜索了一下，可以通过为 <code>&lt;select&gt;</code> 标签写 <code>onchange</code> 属性来完成：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-41859dc0dc714c79.png" alt=""></p>
<h4 id="使用-Java-8-的新特性来排序"><a href="#使用-Java-8-的新特性来排序" class="headerlink" title="使用 Java 8 的新特性来排序"></a>使用 Java 8 的新特性来排序</h4><p>使用了 Java 8 的 Lambda 表达式来完成前端的排序工作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-a5b7d31c428fc275.png" alt=""></p>
<h4 id="注册页-1"><a href="#注册页-1" class="headerlink" title="注册页"></a>注册页</h4><p>天猫的注册搞得很高大上的样子，淘宝也弄成了一样的，不是很好模仿出效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-e8c8b999970823a2.png" alt=""></p>
<p>所以照着改了一改，弄成了这个样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-0e7b1c5090bede21.png" alt=""></p>
<p>在前端通过 JS 来判断完成确认密码的功能，然后这是注册成功的页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-227ec2309e4921c5.png" alt=""></p>
<h4 id="发现-OrderItem-少设计了一个字段"><a href="#发现-OrderItem-少设计了一个字段" class="headerlink" title="发现 OrderItem 少设计了一个字段"></a>发现 OrderItem 少设计了一个字段</h4><p>这是最初设计的数据库表与表之间的关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E3%80%91%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/7896890-5b661e7395805c1e.png" alt=""></p>
<p>当我按照流程一步一步完成着项目，在完成立即购买这个功能时，我需要按照user_id来返回订单项时，不容易实现，我们需要为 OrderItem 增加一个字段（user_id）：</p>
<pre><code>CREATE TABLE `order_item` (
    `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
    `product_id` INT(11) NOT NULL COMMENT &#39;对应产品id&#39;,
    `order_id` INT(11) NOT NULL COMMENT &#39;对应订单id&#39;,
    `user_id` INT(11) NOT NULL COMMENT &#39;对应用户id&#39;,
    `number` INT(11) NULL DEFAULT NULL COMMENT &#39;对应产品购买的数量&#39;,
    INDEX `fk_order_item_product` (`product_id`),
    INDEX `fk_order_item_order` (`order_id`),
    INDEX `fk_order_item_user` (`user_id`),
    PRIMARY KEY (`id`),
    CONSTRAINT `fk_order_item_order` FOREIGN KEY (`order_id`) REFERENCES `order_` (`id`),
    CONSTRAINT `fk_order_item_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`),
    CONSTRAINT `fk_order_item_product` FOREIGN KEY (`product_id`) REFERENCES `product` (`id`)
)COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB;</code></pre><p>然后运行 TestMybatisGenerator 来重新生成相关的文件.</p>
<h4 id="更改-OrderItem-表中的-order-id-字段默认为空"><a href="#更改-OrderItem-表中的-order-id-字段默认为空" class="headerlink" title="更改 OrderItem 表中的 order_id 字段默认为空"></a>更改 OrderItem 表中的 order_id 字段默认为空</h4><p>order_id 是用于判断当前的 OrderItem 是否存在于购物车中的依据，最开始我们将这个字段设计为不能为空，那么就只能在购物车中存在，当我们不需要经过购物车而要直接购买的时候，就不能得到满足…</p>
<h4 id="修复购物车逻辑问题"><a href="#修复购物车逻辑问题" class="headerlink" title="修复购物车逻辑问题"></a>修复购物车逻辑问题</h4><p>之前给 cart.jsp 页面的 List<OrderItem> 仅仅是通过 listByUserId 方法来获取，但其实真正的购物车是那些 order_id 为空的，所以我在 OrderItemService 中新增了一个方法：listForCart 来返回那些真正属于购物车的订单项：</p>
<pre><code>@Override
public List&lt;OrderItem&gt; listForCart(Integer user_id) {
    OrderItemExample example = new OrderItemExample();
    example.or().andUser_idEqualTo(user_id).andOrder_idIsNull();
    List&lt;OrderItem&gt; result = orderItemMapper.selectByExample(example);
    setProduct(result);
    return result;
}</code></pre><hr>
<h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>完成之后的项目直接上传 Github，代码可能有些乱，可读性不是很高，但结构还是清晰的，还是值得参考：<a href="https://github.com/wmyskxz/Tmall_SSM" target="_blank" rel="noopener">传送门</a></p>
<blockquote>
<p>后期再对代码进行维护吧…菜鸟学习代码，勿喷….</p>
</blockquote>
<h4 id="关于-sql-语句"><a href="#关于-sql-语句" class="headerlink" title="关于 sql 语句"></a>关于 sql 语句</h4><p>这里给一个连接提供建表语句以及一些数据：<a href="https://pan.baidu.com/s/18e_ZBRv3TL7Jhgqy0fMLGg" target="_blank" rel="noopener">传送门</a></p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/04/28/mo-fang-tian-mao-shi-zhan-ssm-ban-hou-tai-kai-fa/">
      模仿天猫实战【SSM版】——后台开发
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb基础/SSM/项目</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年4月28日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>上一篇文章链接：<a href="https://www.jianshu.com/p/5e44ee046b43" target="_blank" rel="noopener">模仿天猫实战【SSM版】——项目起步</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-3eee3c0023557f8e.png" alt=""></p>
<h2 id="后台需求分析"><a href="#后台需求分析" class="headerlink" title="后台需求分析"></a>后台需求分析</h2><p>在开始码代码之前，还是需要先清楚自己要做什么事情，后台具体需要实现哪些功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-ccc3aa2fdf8e00de.png" alt=""></p>
<ul>
<li><strong>注意：</strong> 订单、用户、订单、推荐链接均不提供增删的功能。</li>
</ul>
<hr>
<h2 id="后台界面设计"><a href="#后台界面设计" class="headerlink" title="后台界面设计"></a>后台界面设计</h2><p>不像前端那样有原型直接照搬就可以了，后台的设计还真的有难到我…毕竟我是一个对美有一定要求的人，一方面想尽量的简洁、简单，另一方面又不想要太难看，那怎么办呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-c27798bcd2932a19.png" alt=""></p>
<p>那当然是找模板了，找到一个顺眼的下载下来就开始改，</p>
<p>这个模板的原地址在这里：<a href="http://www.cssmoban.com/cssthemes/7381.shtml" target="_blank" rel="noopener">戳这里</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-f1c023b9fdbb91ff.png" alt=""></p>
<p>顺便安利一下 FireFox ，真是开发神器，配合着修改，棒棒哒：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-16d9367e5b6b201e.png" alt=""></p>
<h4 id="经过一番折腾…"><a href="#经过一番折腾…" class="headerlink" title="经过一番折腾…"></a>经过一番折腾…</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-c5f593fb37178a82.png" alt=""></p>
<p>摁，就这风格了，而且我还发现右上角的【Search】框是下载的模板用 js 实现的…对于管理来说更加方便了….而且居然还实现了分页….</p>
<p>一个邪恶的想法又诞生了…</p>
<h4 id="一些规定"><a href="#一些规定" class="headerlink" title="一些规定"></a>一些规定</h4><blockquote>
<ul>
<li>为了降低项目的难度，我们做了很多的精简，现在我们作出如下的规定：</li>
</ul>
</blockquote>
<ul>
<li><strong>全站没有商家，只有一家 Tmall ，后台没有验证，可以直接进入</strong></li>
<li><strong>前台的路径就是默认路径，后台的路径需要加上 “/admin” 后缀，</strong>如访问后台则为：localhost/admin （<strong>默认为分类管理页</strong>）</li>
<li><strong>管理路径统一为：admin/listXxxxx</strong>，如分类管理路径为：admin/listCategory，用户管理路径为：admin/listUser，诸如此类</li>
<li><strong>编辑路径统一为：admin/editXxxxx</strong>，如编辑分类路径为：admin/editCategory，产品编辑页为：admin/editProduct，诸如此类</li>
<li><strong>删除路径统一为：admin/deleteXxxxx</strong></li>
<li><strong>更新路径统一为：admin/updateXxxxx</strong></li>
</ul>
<blockquote>
<ul>
<li>关于页面路径的一些规定：</li>
</ul>
</blockquote>
<ul>
<li>前端页面统一在【WEB-INF/views】下，后端页面统一在【WEB-INF/views/admin】下</li>
</ul>
<hr>
<h2 id="分类管理"><a href="#分类管理" class="headerlink" title="分类管理"></a>分类管理</h2><p>正式开始编写我们的代码，以 Category 为例。</p>
<h4 id="编写-Service-层"><a href="#编写-Service-层" class="headerlink" title="编写 Service 层"></a>编写 Service 层</h4><p>我们需要在这一层上考虑需要完成的功能，对应我们上面画的后台功能图，分类管理也就是完成分类的查询还有修改的工作：</p>
<pre><code>package cn.wmyskxz.service;

import cn.wmyskxz.pojo.Category;

import java.util.List;

public interface CategoryService {

    /**
     * 返回分类列表
     * @return
     */
    List&lt;Category&gt; list();

    /**
     * 通过id获取对应的数据
     * @param id
     * @return
     */
    Category get(Integer id);

    /**
     * 更新分类
     * @param category
     * @return
     */
    void update(Category category);
}</code></pre><ul>
<li>编写 CategoryServiceImpl ：<br>在同一包下编写实现类</li>
</ul>
<pre><code>package cn.wmyskxz.service;

import cn.wmyskxz.mapper.CategoryMapper;
import cn.wmyskxz.pojo.Category;
import cn.wmyskxz.pojo.CategoryExample;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * CategoryService 的实现类
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-27-下午 16:35
 */
@Service
public class CategoryServiceImpl implements CategoryService {

    @Autowired
    CategoryMapper categoryMapper;

    public List&lt;Category&gt; list() {
        CategoryExample example = new CategoryExample();
        List&lt;Category&gt; categories = categoryMapper.selectByExample(example);
        return categories;
    }

    public Category get(Integer id) {
        return categoryMapper.selectByPrimaryKey(id);
    }

    public void update(Category category) {
        categoryMapper.updateByPrimaryKey(category);
    }
}</code></pre><h4 id="编写-CategoryController"><a href="#编写-CategoryController" class="headerlink" title="编写 CategoryController"></a>编写 CategoryController</h4><p>根据业务需求可以很容易的编写出来：</p>
<pre><code>package cn.wmyskxz.controller;

import cn.wmyskxz.pojo.Category;
import cn.wmyskxz.service.CategoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.List;

/**
 * Category 的控制类
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-27-下午 16:37
 */
@Controller
@RequestMapping(&quot;/admin&quot;)
public class CategoryController {

    @Autowired
    CategoryService categoryService;

    @RequestMapping(&quot;/listCategory&quot;)
    public String list(Model model) {
        List&lt;Category&gt; categories = categoryService.list();
        model.addAttribute(&quot;categories&quot;, categories);
        return &quot;admin/listCategory&quot;;
    }

    @RequestMapping(&quot;/editCategory&quot;)
    public String edit(Category category,Model model) {
        model.addAttribute(&quot;category&quot;, category);
        return &quot;admin/editCategory&quot;;
    }

    @RequestMapping(&quot;/updateCategory&quot;)
    public String update(Category category) {
        categoryService.update(category);
        return &quot;redirect:listCategory&quot;;
    }
}</code></pre><h4 id="JSP-相关文件编写"><a href="#JSP-相关文件编写" class="headerlink" title="JSP 相关文件编写"></a>JSP 相关文件编写</h4><p>自己研究了一会儿这个模板，感觉还是挺好改的，然后就给改成了大概以下这个样子（<em>自己在数据库中加入了 16 条数据</em>）：</p>
<ul>
<li>分类管理页</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-4a983d7478357872.png" alt=""></p>
<ul>
<li>分类编辑页</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-16014296cfec5ea8.png" alt=""></p>
<p>模板下载下来之后文件目录是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-971cc1225aa97f5a.png" alt=""></p>
<p>我们直接整个拷贝【assets】文件夹放在【webapp】目录下，然后根据模板里面的代码就可以开始修改了，修改下来的两个文件源码如下：</p>
<ul>
<li>listCategory.jsp</li>
</ul>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;模仿天猫-后台&lt;/title&gt;
    &lt;!-- Bootstrap Styles--&gt;
    &lt;link href=&quot;../assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;!-- FontAwesome Styles--&gt;
    &lt;link href=&quot;../assets/css/font-awesome.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;!-- Morris Chart Styles--&gt;

    &lt;!-- Custom Styles--&gt;
    &lt;link href=&quot;../assets/css/custom-styles.css&quot; rel=&quot;stylesheet&quot; /&gt;
    &lt;!-- Google Fonts--&gt;
    &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39; /&gt;
    &lt;!-- TABLE STYLES--&gt;
    &lt;link href=&quot;../assets/js/dataTables/dataTables.bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;wrapper&quot;&gt;
    &lt;nav class=&quot;navbar navbar-default top-navbar&quot; role=&quot;navigation&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.sidebar-collapse&quot;&gt;
                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;a class=&quot;navbar-brand&quot; href=&quot;listCategory&quot;&gt;Tmall&lt;/a&gt;
        &lt;/div&gt;
    &lt;/nav&gt;

    &lt;!--/. NAV TOP  --&gt;
    &lt;nav class=&quot;navbar-default navbar-side&quot; role=&quot;navigation&quot;&gt;
        &lt;div class=&quot;sidebar-collapse&quot;&gt;
            &lt;ul class=&quot;nav&quot; id=&quot;main-menu&quot;&gt;

                &lt;li&gt;
                    &lt;a class=&quot;active-menu&quot; href=&quot;listCategory&quot;&gt;&lt;i class=&quot;fa fa-bars&quot;&gt;&lt;/i&gt; 分类管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listUser&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 用户管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listOrder&quot;&gt;&lt;i class=&quot;fa fa-list-alt&quot;&gt;&lt;/i&gt; 订单管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listProduct&quot;&gt;&lt;i class=&quot;fa fa-th-list&quot;&gt;&lt;/i&gt; 产品管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listLink&quot;&gt;&lt;i class=&quot;fa fa-link&quot;&gt;&lt;/i&gt; 推荐链接管理&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

    &lt;/nav&gt;
    &lt;!-- /. NAV SIDE  --&gt;
    &lt;div id=&quot;page-wrapper&quot;&gt;
        &lt;div id=&quot;page-inner&quot;&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;h1 class=&quot;page-header&quot;&gt;
                        分类管理
                        &lt;small&gt;&lt;/small&gt;
                    &lt;/h1&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;!-- Advanced Tables --&gt;
                    &lt;div class=&quot;panel panel-default&quot;&gt;
                        &lt;div class=&quot;panel-heading&quot;&gt;
                            分类管理表
                        &lt;/div&gt;
                        &lt;div class=&quot;panel-body&quot;&gt;
                            &lt;div class=&quot;table-responsive&quot;&gt;
                                &lt;table class=&quot;table table-striped table-bordered table-hover&quot; id=&quot;dataTables-example&quot;&gt;
                                    &lt;thead&gt;
                                    &lt;tr&gt;
                                        &lt;th&gt;分类id&lt;/th&gt;
                                        &lt;th&gt;分类名称&lt;/th&gt;

                                        &lt;th&gt;编辑分类&lt;/th&gt;
                                        &lt;th&gt;产品管理&lt;/th&gt;
                                        &lt;th&gt;属性管理&lt;/th&gt;
                                    &lt;/tr&gt;
                                    &lt;/thead&gt;
                                    &lt;tbody&gt;
                                    &lt;c:forEach items=&quot;${categories}&quot; var=&quot;c&quot;&gt;
                                        &lt;tr&gt;
                                            &lt;td&gt;${c.id}&lt;/td&gt;
                                            &lt;td&gt;${c.name}&lt;/td&gt;

                                            &lt;td&gt;&lt;a href=&quot;editCategory?id=${c.id}&amp;name=${c.name}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-th-list&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
                                            &lt;td&gt;&lt;a href=&quot;listProduct?category_id=${c.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-shopping-cart&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
                                            &lt;td&gt;&lt;a href=&quot;listProperty?category_id=${c.id}&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-edit&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
                                        &lt;/tr&gt;
                                    &lt;/c:forEach&gt;
                                    &lt;/tbody&gt;
                                &lt;/table&gt;
                            &lt;/div&gt;

                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;!--End Advanced Tables --&gt;
                &lt;/div&gt;
            &lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- /. PAGE WRAPPER  --&gt;
&lt;/div&gt;
&lt;!-- /. WRAPPER  --&gt;
&lt;!-- JS Scripts--&gt;
&lt;!-- jQuery Js --&gt;
&lt;script src=&quot;../assets/js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;
&lt;!-- Bootstrap Js --&gt;
&lt;script src=&quot;../assets/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- Metis Menu Js --&gt;
&lt;script src=&quot;../assets/js/jquery.metisMenu.js&quot;&gt;&lt;/script&gt;
&lt;!-- DATA TABLE SCRIPTS --&gt;
&lt;script src=&quot;../assets/js/dataTables/jquery.dataTables.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;../assets/js/dataTables/dataTables.bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(document).ready(function () {
        $(&#39;#dataTables-example&#39;).dataTable();
    });
&lt;/script&gt;
&lt;!-- Custom Js --&gt;
&lt;script src=&quot;../assets/js/custom-scripts.js&quot;&gt;&lt;/script&gt;


&lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li>editCategory.jsp</li>
</ul>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;/&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;/&gt;
    &lt;title&gt;模仿天猫-后台&lt;/title&gt;
    &lt;!-- Bootstrap Styles--&gt;
    &lt;link href=&quot;../assets/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;/&gt;
    &lt;!-- FontAwesome Styles--&gt;
    &lt;link href=&quot;../assets/css/font-awesome.css&quot; rel=&quot;stylesheet&quot;/&gt;
    &lt;!-- Morris Chart Styles--&gt;

    &lt;!-- Custom Styles--&gt;
    &lt;link href=&quot;../assets/css/custom-styles.css&quot; rel=&quot;stylesheet&quot;/&gt;
    &lt;!-- Google Fonts--&gt;
    &lt;link href=&#39;https://fonts.googleapis.com/css?family=Open+Sans&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;/&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;wrapper&quot;&gt;
    &lt;nav class=&quot;navbar navbar-default top-navbar&quot; role=&quot;navigation&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.sidebar-collapse&quot;&gt;
                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;
                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;a class=&quot;navbar-brand&quot; href=&quot;listCategory&quot;&gt;Tmall&lt;/a&gt;
        &lt;/div&gt;
    &lt;/nav&gt;

    &lt;!--/. NAV TOP  --&gt;
    &lt;nav class=&quot;navbar-default navbar-side&quot; role=&quot;navigation&quot;&gt;
        &lt;div class=&quot;sidebar-collapse&quot;&gt;
            &lt;ul class=&quot;nav&quot; id=&quot;main-menu&quot;&gt;

                &lt;li&gt;
                    &lt;a class=&quot;active-menu&quot; href=&quot;listCategory&quot;&gt;&lt;i class=&quot;fa fa-bars&quot;&gt;&lt;/i&gt; 分类管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listUser&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 用户管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listOrder&quot;&gt;&lt;i class=&quot;fa fa-list-alt&quot;&gt;&lt;/i&gt; 订单管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listProduct&quot;&gt;&lt;i class=&quot;fa fa-th-list&quot;&gt;&lt;/i&gt; 产品管理&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;listLink&quot;&gt;&lt;i class=&quot;fa fa-link&quot;&gt;&lt;/i&gt; 推荐链接管理&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

    &lt;/nav&gt;
    &lt;!-- /. NAV SIDE  --&gt;
    &lt;div id=&quot;page-wrapper&quot;&gt;
        &lt;div id=&quot;page-inner&quot;&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;h1 class=&quot;page-header&quot;&gt;
                        分类管理
                        &lt;small&gt; - id:${category.id} &lt;/small&gt;
                    &lt;/h1&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-6&quot;&gt;
                    &lt;!-- Advanced Tables --&gt;
                    &lt;div class=&quot;panel panel-default&quot;&gt;
                        &lt;div class=&quot;panel-heading&quot;&gt;
                            编辑分类
                        &lt;/div&gt;
                        &lt;div class=&quot;panel-body&quot;&gt;
                            &lt;div class=&quot;row col-lg-12&quot;&gt;
                                &lt;form action=&quot;updateCategory&quot; role=&quot;form&quot;&gt;
                                    &lt;div class=&quot;form-group&quot;&gt;
                                        &lt;%-- 隐藏id属性，一并提交 --%&gt;
                                        &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${category.id}&quot;&gt;
                                        &lt;label&gt;分类名称：&lt;/label&gt;
                                        &lt;input name=&quot;name&quot; class=&quot;form-control&quot; value=&quot;${category.name}&quot;&gt; &lt;br/&gt;
                                        &lt;div class=&quot;pull-right&quot;&gt;
                                            &lt;input type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;
                                &lt;/form&gt;
                            &lt;/div&gt;

                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;!--End Advanced Tables --&gt;
                &lt;/div&gt;
            &lt;/div&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- /. PAGE WRAPPER  --&gt;
&lt;/div&gt;
&lt;!-- /. WRAPPER  --&gt;
&lt;!-- JS Scripts--&gt;
&lt;!-- jQuery Js --&gt;
&lt;script src=&quot;../assets/js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;
&lt;!-- Bootstrap Js --&gt;
&lt;script src=&quot;../assets/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="这样就完成了-Category-的后台管理模块"><a href="#这样就完成了-Category-的后台管理模块" class="headerlink" title="这样就完成了 Category 的后台管理模块"></a>这样就完成了 Category 的后台管理模块</h4><p>其他模块的思路跟 Category 如出一辙，就比较偏向于体力劳动了…</p>
<ul>
<li><strong>注意：</strong> 所有本类的 id 属性均为 <code>id</code> ，所有外键的 id 都是 <code>属性名_id</code> 这样的格式，保持统一！</li>
</ul>
<hr>
<h2 id="Example-条件查询"><a href="#Example-条件查询" class="headerlink" title="Example 条件查询"></a>Example 条件查询</h2><p>MyBatis 逆向工程自动生成文件的时候自动生成了 Example 条件查询类，我们到底应该怎么使用它呢，这里简要的说明一下。</p>
<p>不得不说这个东西还挺神奇，也很方便，比如我们需要查询 category_id 对应下的属性表，我们可以这样写：</p>
<pre><code>public List&lt;Property&gt; list(Integer category_id) {
    PropertyExample example = new PropertyExample();
    example.or().andCategory_idEqualTo(category_id);
    List&lt;Property&gt; properties = propertyMapper.selectByExample(example);
    return properties;
}</code></pre><p>通过方法名其实也很容易看懂这些是什么意思，我们首先创建了一个 PropertyExample 实例对象，然后通过 <code>.or()</code> 方法开启条件查询，<code>.andCategory_idEqualTo()</code> 匹配对应的 category_id ，自动生成的 sql 语句就像这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-77a9f0157eba3e78.png" alt=""></p>
<blockquote>
<p><a href="https://blog.csdn.net/biandous/article/details/65630783" target="_blank" rel="noopener">更多详情戳这里 - 引用其他博客的详细说明</a></p>
</blockquote>
<hr>
<h2 id="IDEA-快速重构"><a href="#IDEA-快速重构" class="headerlink" title="IDEA 快速重构"></a>IDEA 快速重构</h2><p>当我编写好了 PropertyService 、PropertyServiceImpl、 PropertyController 之后再想要去编写 Product 的这一系列文件的时候，发现其实很多代码都是重复的，只是很少一部分的代码需要改动，暂时不考虑设计模式的话，我们可以使用 IDEA 来完成快速重构：</p>
<ul>
<li>直接复制 PropertyController 的代码到 ProductController 中，然后【Ctrl + F】搜索 Property ：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-02324398e7cb52b3.png" alt=""></p>
<p>我们可以发现所有的 Property 都高亮了，然后我们怎么批量修改呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-22868fcd1d7ab8ff.gif" alt=""></p>
<p>然后继续疯狂码代码…</p>
<hr>
<h2 id="开发过程中遇到的一些问题"><a href="#开发过程中遇到的一些问题" class="headerlink" title="开发过程中遇到的一些问题"></a>开发过程中遇到的一些问题</h2><h4 id="PropertyValue-遇到的麻烦"><a href="#PropertyValue-遇到的麻烦" class="headerlink" title="PropertyValue 遇到的麻烦"></a>PropertyValue 遇到的麻烦</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-320fc236c47427d3.png" alt=""></p>
<p>PropertyValue 属性值表，这个表关联了两个外键，一个指向 Product ，另一个指向 Property ，当我按照之前的设计把 listProduct.jsp 设计成下面这个样子的时候，点击【编辑属性】，Property 的信息应该怎么传递？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-663fe5770f82dc3d.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-c1937d1fb2ff0ad2.png" alt=""></p>
<ul>
<li>也就是说，如何处理从 listProduct 跳转到 listPropertyValue 页面时凭空跳出来的 Property 的相关信息？</li>
</ul>
<p><strong>解决方案：</strong></p>
<p>在 PropertyValueServiceImpl 中增加：</p>
<pre><code>@Autowired
PropertyService propertyService;</code></pre><p>我们现在有 category_id 和 product_id ，我们可以利用 Property 和 Category 之间的联系，通过 category_id 查询出所有对应的 Property ，然后再筛选出同时匹配 property_id 和 product_id 的 PropertyValue：</p>
<pre><code>public List&lt;PropertyValue&gt; list(Integer product_id, Integer category_id) {
    PropertyValueExample example = new PropertyValueExample();
    List&lt;PropertyValue&gt; propertyValues = new ArrayList&lt;PropertyValue&gt;();
    List&lt;Property&gt; properties = propertyService.list(category_id);
    for (Property property : properties) {
        // 筛选出同时匹配 property_id 和 product_id 的值
        example.or().andProperti_idEqualTo(property.getId()).andProduct_idEqualTo(product_id);
        propertyValues.addAll(propertyValueMapper.selectByExample(example));
    }
    return propertyValues;
}</code></pre><p>emmm…这样的思路出来之后，对应的 Controller 就清晰了：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/listPropertyValue"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">list</span><span class="token punctuation">(</span>Model model<span class="token punctuation">,</span> Integer product_id<span class="token punctuation">,</span> Integer category_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> propertyValues <span class="token operator">=</span> propertyValueService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>product_id<span class="token punctuation">,</span> category_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"propertyValues"</span><span class="token punctuation">,</span> propertyValues<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Product product <span class="token operator">=</span> productService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">"admin/listPropertyValue"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>加入一条数据测试：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-6e15372ceb60a814.png" alt=""></p>
<ul>
<li>bingo！</li>
</ul>
<p><strong>另一个问题是添加属性值：</strong> </p>
<p>添加的属性值必须是当前 Category 下有的属性值，所以我们可以在 Controller 上自动注入一个 PropertyService 通过 category_id 查询到当前分类下所有的 Property 然后传递给 listPropertyValue ：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>
PropertyService propertyService<span class="token punctuation">;</span>

<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/listPropertyValue"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">list</span><span class="token punctuation">(</span>Model model<span class="token punctuation">,</span> Integer product_id<span class="token punctuation">,</span> Integer category_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> propertyValues <span class="token operator">=</span> propertyValueService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>product_id<span class="token punctuation">,</span> category_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"propertyValues"</span><span class="token punctuation">,</span> propertyValues<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Product product <span class="token operator">=</span> productService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"product"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>Property<span class="token operator">></span> properties <span class="token operator">=</span> propertyService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>category_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"properties"</span><span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">"admin/listPropertyValue"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>期间发现一个 BUG，PropertyValue 表里的 property_id 居然写成了 properti_id，吓得我赶紧检查了一下所有表的字段，其他的没问题，重新生成一下逆向工程</p>
</blockquote>
<p><strong>然后获取属性名称：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-913cf5641162aaa8.png" alt=""></p>
<ul>
<li>完善之后大概是这样：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-63c0a4d1c28f7633.png" alt=""></p>
<h4 id="产品图片管理"><a href="#产品图片管理" class="headerlink" title="产品图片管理"></a>产品图片管理</h4><p>产品图片的管理需要涉及到文件的上传操作，我们需要先提供必要的 jar 包依赖：</p>
<ul>
<li>commons-fileupload</li>
<li>commons-io</li>
</ul>
<p>同样的搜索 maven 库添加依赖到 pom.xml中：</p>
<pre><code>&lt;!-- 上传文件fileupload --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p><strong>产品图片如何管理？</strong></p>
<ul>
<li><strong>规定一：</strong><br>所有的产品图片均保存在【img/product/】对应的 product_id 目录下，并且默认的文件名为 1，2，3，4，5 ，例如 product_id 为 1 的产品的产品图片 1 保存于：【img/product/1/1.jpg】</li>
<li><strong>规定二：</strong><br>每一个产品对应五张图片，文件名分别为 1.jpg ，2.jpg 以此类推，不能少也不能多，删除也只是将对应目录下的图片删除，id 并不改变</li>
<li><strong>规定三：</strong><br>默认产品打开的大图即为该产品图片目录中的 1.jpg</li>
</ul>
<blockquote>
<ul>
<li>界面大概设计成了这样：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-77a779e13d7b2d50.png" alt=""></p>
<blockquote>
<ul>
<li>莫名其妙一个 BUG：</li>
</ul>
</blockquote>
<p>我把表单设计成了这样，隐藏了两个属性，一个 product_id，一个 id：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-7ef327a861da75d4.png" alt=""></p>
<p>为了方便操作，我想要直接申明两个参数用来接收上面的两个属性，大概是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-dc05f02505bc41ac.png" alt=""></p>
<p>但是上面两种方法都不行，我还查了一些资料在 @RequestParam 注解里设置了 required 属性，仍然获取不到，但是我改成用 ProductImage 来接收就好了..Why?</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-6bf39c8f3fe9ca82.png" alt=""></p>
<p>后来写着写着，又必须要使用上面两种方法了….</p>
<blockquote>
<ul>
<li>根据我们的规定来完成代码</li>
</ul>
</blockquote>
<p>ProductImageService 层还是跟之前的没有多大的区别，但是值得注意的是，根据我们的规定，我们的删除需要做一些改动（根据 product_id 批量删除）：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>service<span class="token punctuation">;</span>

<span class="token keyword">import</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>PropertyValueMapper<span class="token punctuation">;</span>
<span class="token keyword">import</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * cn.wmyskxz.pojo.PropertyValueValueService 实现类
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-28-上午 7:47
 */</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertyValueServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">PropertyValueService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    PropertyValueMapper propertyValueMapper<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    PropertyService propertyService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    ProductService productService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>PropertyValue propertyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        propertyValueMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        propertyValueMapper<span class="token punctuation">.</span><span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteByProductId</span><span class="token punctuation">(</span>Integer product_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 按条件查询出需要删除的列表</span>
        PropertyValueExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyValueExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        example<span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andProduct_idEqualTo</span><span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer category_id <span class="token operator">=</span> productService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCategory_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> propertyValues <span class="token operator">=</span> <span class="token function">list</span><span class="token punctuation">(</span>product_id<span class="token punctuation">,</span> category_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 循环删除</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> propertyValues<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            propertyValueMapper<span class="token punctuation">.</span><span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span>propertyValues<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>PropertyValue propertyValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        propertyValueMapper<span class="token punctuation">.</span><span class="token function">updateByPrimaryKey</span><span class="token punctuation">(</span>propertyValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> <span class="token function">list</span><span class="token punctuation">(</span>Integer product_id<span class="token punctuation">,</span> Integer category_id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        PropertyValueExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropertyValueExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span> propertyValues <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>PropertyValue<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>Property<span class="token operator">></span> properties <span class="token operator">=</span> propertyService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>category_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Property property <span class="token operator">:</span> properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 筛选出同时匹配 property_id 和 product_id 的值</span>
            example<span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andProperty_idEqualTo</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andProduct_idEqualTo</span><span class="token punctuation">(</span>product_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            propertyValues<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>propertyValueMapper<span class="token punctuation">.</span><span class="token function">selectByExample</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> propertyValues<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> PropertyValue <span class="token function">get</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> propertyValueMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>首先在 ProductController 中 add 和 delete 方法中增加以下代码：</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>
ProductImageService productImageService<span class="token punctuation">;</span>

<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/addProduct"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">add</span><span class="token punctuation">(</span>Product product<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    productService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>product<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 创建新的 Product 时默认创建 5 个对应的 ProductImage 数据</span>
    ProductImage productImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    productImage<span class="token punctuation">.</span><span class="token function">setProduct_id</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        productImage<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        productImageService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>productImage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token string">"redirect:listProduct?category_id="</span> <span class="token operator">+</span> product<span class="token punctuation">.</span><span class="token function">getCategory_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/deleteProduct"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">delete</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 在删除产品的时候将对应的 5 个 ProductImage 数据也删除了</span>
    productImageService<span class="token punctuation">.</span><span class="token function">deleteByProductId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 同时删除目录下的相关文件</span>
    String path <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">deleteDir</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 删除外键对应的数据</span>
    propertyValueService<span class="token punctuation">.</span><span class="token function">deleteByProductId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> category_id <span class="token operator">=</span> productService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCategory_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    productService<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token string">"redirect:listProduct?category_id="</span> <span class="token operator">+</span> category_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 递归删除目录下的所有文件及子目录下所有文件
 *
 * @param dir 将要删除的文件目录
 * @return boolean Returns "true" if all deletions were successful.
 * If a deletion fails, the method stops attempting to
 * delete and returns "false".
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">deleteDir</span><span class="token punctuation">(</span>File dir<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//递归删除目录中的子目录下</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token function">deleteDir</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 目录此时为空，可以删除</span>
    <span class="token keyword">return</span> dir<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>然后编写我们的 ProductImageController ：</p>
<pre><code>package cn.wmyskxz.controller;

import cn.wmyskxz.pojo.Product;
import cn.wmyskxz.pojo.ProductImage;
import cn.wmyskxz.service.ProductImageService;
import cn.wmyskxz.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.util.List;

/**
 * ProductImage 的控制器
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-28-下午 14:10
 */
@Controller
@RequestMapping(&quot;/admin&quot;)
public class ProductImageController {

    @Autowired
    ProductImageService productImageService;

    @Autowired
    ProductService productService;

    @RequestMapping(&quot;/editProductImage&quot;)
    public String edit(Model model, Integer product_id) {
        List&lt;ProductImage&gt; productImages = productImageService.list(product_id);
        model.addAttribute(&quot;productImages&quot;, productImages);
        Product product = productService.get(product_id);
        model.addAttribute(&quot;product&quot;, product);
        return &quot;admin/editProductImage&quot;;
    }

    @RequestMapping(value = &quot;/updateProductImage&quot;, method = RequestMethod.POST)
    public String update(HttpServletRequest request,
//                         @RequestParam(&quot;productImage&quot;) ProductImage productImage,
                         Integer product_id, 
                         Integer id,
                         @RequestParam(&quot;picture&quot;) MultipartFile picture) {

        // 上传文件到指定位置
        String filePath = request.getSession().getServletContext()
                .getRealPath(&quot;img/product/&quot; + product_id);
        // 因为 id 是自增长键，所以需要 % 5 来作为文件名
        String fileName = (id % 5 == 0 ? 5 : id % 5) + &quot;.jpg&quot;;
        File uploadPicture = new File(filePath, fileName);
        if (!uploadPicture.exists()) {
            uploadPicture.mkdirs();
        }
        // 保存
        try {
            picture.transferTo(uploadPicture);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return &quot;redirect:editProductImage?product_id=&quot; + product_id;
    }

    @RequestMapping(&quot;/deleteProductImage&quot;)
    public String delete(Integer id, Integer product_id, HttpServletRequest request) {
        // 不删除表中的数据（在 ProductController 中统一删除），删除对应文件
        String filePath = request.getSession().getServletContext()
                .getRealPath(&quot;img/product/&quot; + product_id);
        String fileName = id + &quot;.jpg&quot;;
        new File(filePath, fileName).delete();

        return &quot;redirect:editProductImage?product_id=&quot; + product_id;
    }
}
</code></pre><blockquote>
<ul>
<li>再优化一下界面的东西，增加没有图片显示的 error 图片，大概就是这个样子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-1503d0b3ed63d785.png" alt=""></p>
<p>这里就只贴一下 table 的代码吧：</p>
<pre><code>&lt;c:forEach items=&quot;${productImages}&quot; var=&quot;pi&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;${pi.product_id}&lt;/td&gt;
        &lt;td&gt;${pi.id}&lt;/td&gt;
        &lt;td&gt;&lt;img class=&quot;col-md-8&quot;
                 src=&quot;../img/product/${pi.product_id}/${pi.id%5==0?5:pi.id%5}.jpg&quot;
                 onerror=&quot;this.src=&#39;../img/product/error.png&#39;&quot;&gt;&lt;/td&gt;
        &lt;td class=&quot;col-md-5&quot;&gt;
            &lt;form action=&quot;updateProductImage&quot; method=&quot;post&quot;
                  enctype=&quot;multipart/form-data&quot;&gt;
                &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;${pi.id}&quot;&gt;
                &lt;input type=&quot;hidden&quot; name=&quot;product_id&quot;
                       value=&quot;${pi.product_id}&quot;&gt;
                &lt;input type=&quot;file&quot; name=&quot;picture&quot; class=&quot;pull-left&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; value=&quot;上传&quot;&gt;
            &lt;/form&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;a href=&quot;deleteProductImage?product_id=${pi.product_id}&amp;id=${pi.id}&quot;&gt;&lt;span
                    class=&quot;glyphicon glyphicon-trash&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/c:forEach&gt;</code></pre><h4 id="在写图片管理的时候又遇到一个坑"><a href="#在写图片管理的时候又遇到一个坑" class="headerlink" title="在写图片管理的时候又遇到一个坑"></a>在写图片管理的时候又遇到一个坑</h4><p><strong>在删除顶层数据库数据的时候，要注意删除其下的有外键关联的数据</strong>，特别是 product_id 这个东西，是很多表的外键，删除 product 之前需要先清空有关联的其他表的数据….</p>
<p>总之坑是很多啦..不过项目在进展总归是好事…耐心耐心…</p>
<h4 id="接着码代码…"><a href="#接着码代码…" class="headerlink" title="接着码代码…."></a>接着码代码….</h4><p>还剩下一些体力活的东西，就先结博文啦…（心累.jpg）</p>
<p>有一些催更的朋友，希望能别催啦…每天都在码啦，而且本身也是很low的东西，写完之后我会上传 github 的。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/7896890-dc0bd48aaa532767.jpg" alt=""></p>
<p>当我给自己埋了一个大坑说要模仿天猫，并且陷进去的时候，一方面痛苦着一方面也察觉了自己很多不足的地方，就觉得还是很值得，现在来做一下简短的总结。</p>
<ul>
<li>进度比想象中慢了很多，虽然一步一步按照之前的分析图来编写代码总体是顺畅的，但是有那种写着写着突然发现之前的设计有问题的感觉，中途也改了几次，<strong>发现自己分析问题不够全面。</strong></li>
<li>项目中有许多类似的代码，并且在 Controller 和 Impl 中不断有其他的东西加入，总觉得是糟糕的代码，但是又不知道应该进一步如何改进。</li>
<li><strong>方向永远比努力重要，在行动之前思考清楚，</strong>我一直觉得是很重要的一点，我觉得通过对项目的分析，对我项目的进展有一个整体的构思，各个模块该有什么功能都比较清晰，特别在编写 JSP 文件的时候能明显感觉不会很迷茫，这是比较好的一点</li>
<li><strong>发现自己阅读代码量很少，</strong>这种感觉体现在很多地方，一是写代码时感觉到自己思想的局限性，二是觉得自己写的代码有很多的相似性，虽然这个项目是自己突发奇想的想要去做的，但是有很多细节的地方，是自己没有去注意到的，比如类型要求、边界判断、事务处理等等等…</li>
</ul>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/04/27/mo-fang-tian-mao-shi-zhan-ssm-ban-xiang-mu-qi-bu/">
      模仿天猫实战【SSM版】——项目起步
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb基础/SSM/项目</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年4月27日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-3eee3c0023557f8e.png" alt=""></p>
<blockquote>
<p><strong>前言：</strong>现在自己的学习似乎遇到了瓶颈，感觉学习了 SSM 之后有一些迷茫，不知道接下来该往哪里去努力了，我觉得这是个很不好的状态，为了度过这段时期，我准备把天猫模仿下来（给自己找点事做）之后开始去巩固 Java 的基础知识，也准备好暑假去找实习。</p>
</blockquote>
<h2 id="第一步：需求分析"><a href="#第一步：需求分析" class="headerlink" title="第一步：需求分析"></a>第一步：需求分析</h2><p>首先要确定要实现哪些功能，需要对需求进行完整的分析，才能在编写项目的时候有条不紊，<strong>我们的目的很明确：就是模仿天猫前端 + 自己实现后端。</strong>并且尽最大努力去降低这个项目的复杂度（<em>毕竟高深的东西不懂</em>）。</p>
<h4 id="前端需求分析"><a href="#前端需求分析" class="headerlink" title="前端需求分析"></a>前端需求分析</h4><p><strong>规定：全天猫没有店铺，就只有唯一一家叫做 Tmall 的商家，卖所有的东西。</strong></p>
<blockquote>
<ul>
<li>1.数据的显示：</li>
</ul>
</blockquote>
<p><strong>首页数据显示分析：</strong></p>
<p>首先是搜索栏下方的九个商品，需要从数据库中取出销量最高的几个产品，关于标红的关键字，是要满足一定条件的，比如：这一个星期内销量超过多少…</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-ee6c3bed893d7229.png" alt=""></p>
<p>接着是分类导航栏，首先是商品分类右边固定的两个链接【天猫超市】和【天猫国际】，还有紧跟着的八个超链，这个可以设计为一个单表，存储它显示的文字和链接过去的地址，然后是具体的 16 个分类以及轮播：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-e85879cb8e4d5aa8.png" alt=""></p>
<p>下面的具体产品展示比较复杂，我们可以自己做一下简化，比如就展示几个产品比较多的固定的几个分类就好了，其他的就直接舍弃：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-84ef80bc6a962d35.png" alt=""></p>
<ul>
<li><strong>总结：</strong> 总之就是需要显示各种数据库中的数据</li>
</ul>
<blockquote>
<ul>
<li>2.登录/注册页</li>
</ul>
</blockquote>
<p>需要有一个登录/注册页，能够完成用户的登录和注册功能，并能提供基础的例如判断空值等功能。</p>
<blockquote>
<ul>
<li>3.产品搜索页</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-3740347e272b1ef0.png" alt=""></p>
<p>左上角的图标我们可以统一简化成 Tmall 的图片，商品图片，我们可以整个大分类使用一张图，主要就是实现排序功能还有搜索功能</p>
<blockquote>
<ul>
<li>4.产品展示页</li>
</ul>
</blockquote>
<p>天猫原生的产品展示页有些复杂，我们可以自己简化一下，就不要选这么多东西，都是一口价，</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-6e04b72b9365b941.png" alt=""></p>
<p>另外下方规格参数和评价都不能省略：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-67d2078a8f016c95.png" alt=""></p>
<blockquote>
<ul>
<li>5.购物车/购买页面</li>
</ul>
</blockquote>
<hr>
<h2 id="第二步：表结构设计"><a href="#第二步：表结构设计" class="headerlink" title="第二步：表结构设计"></a>第二步：表结构设计</h2><p>根据对于前端的分析，数据库有了一些眉目，为了简化项目的难度，所以我们需要自己想点办法，先来构思一下大概需要一些什么样的表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-70e86e80be27582b.png" alt=""></p>
<p>我大概就想出来需要用到这些表，我们一个一个来创建它们：</p>
<h4 id="表一：分类表"><a href="#表一：分类表" class="headerlink" title="表一：分类表"></a>表一：分类表</h4><p>首先我们需要一个表来存储我们的分类信息，也就是【女装/内衣】、【男装/运动户外】在内的 16 个分类，为了高度一致，这 16 个分类不能多也不能少。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-5ac9b6db283570f1.png" alt=""></p>
<p>为了简化任务，可以观察出，【热门手机】、【特色手机】分栏下的东西都是【手机/数码/电脑办公】类别里的东西，所以我们直接砍掉，右边的一些图片超链也给直接砍掉，我们规定每一行显示的产品数目就可以了，这样就简单多了。</p>
<pre><code>CREATE TABLE category (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) NOT NULL COMMENT &#39;分类的名字&#39;,
  PRIMARY KEY (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><h4 id="表二：商品分类右边的超链表"><a href="#表二：商品分类右边的超链表" class="headerlink" title="表二：商品分类右边的超链表"></a>表二：商品分类右边的超链表</h4><p>即在【天猫国际】右边的 8 个超链，我们单独新建一个表来存储超链显示的文字和链接的地址，这样就可以任意的修改其内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-4c4dd522d7725685.png" alt=""></p>
<p>百度翻译【推荐链接】翻译为【Referral links】，那我们也这么给我们的表命名好了：</p>
<pre><code>CREATE TABLE referal_link (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  text varchar(255) NOT NULL COMMENT &#39;超链显示的文字&#39;,
  link varchar(255) NOT NULL COMMENT &#39;超链的地址&#39;,
  PRIMARY KEY (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><h4 id="表三：产品表"><a href="#表三：产品表" class="headerlink" title="表三：产品表"></a>表三：产品表</h4><p>每个分类下都要一定的产品，这些产品还有自己的一些属性，所以另外需要属性表，这个表另外创建，我们先来观察一下一个产品表需要一些什么东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-1c882a1c5e908c2a.png" alt=""></p>
<ul>
<li>用于展示的 5 张<strong>图片</strong></li>
<li><strong>产品名称</strong></li>
<li><strong>小标题</strong>（即名称下面一排标红的小字）</li>
<li><strong>价格</strong>（就一口价，没别的）</li>
<li><strong>销量</strong>（别月销量了，能简化就简化一下）</li>
<li><strong>累计评价</strong>（还需要设计一个评价表）</li>
<li><strong>库存</strong></li>
<li><strong>属性</strong>（需要关联另外的属性表）</li>
</ul>
<pre><code>CREATE TABLE product (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) NOT NULL COMMENT &#39;产品的名称&#39;,
  sub_title varchar(255) DEFAULT NULL COMMENT &#39;小标题&#39;,
  price float DEFAULT NULL COMMENT &#39;价格&#39;,
  sale int(11) DEFAULT NULL COMMENT &#39;销量&#39;,
  stock int(11) DEFAULT NULL COMMENT &#39;库存&#39;,
  category_id int(11) DEFAULT NULL COMMENT &#39;对应的分类id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_product_category FOREIGN KEY (category_id) REFERENCES category (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><ul>
<li><strong>注意：</strong> 其中产品图片，累计评价，属性都作为单独的表存在并让当前表的 id 作为外键</li>
</ul>
<h4 id="表四：属性表"><a href="#表四：属性表" class="headerlink" title="表四：属性表"></a>表四：属性表</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-755570d44559ce1a.png" alt=""></p>
<p>去掉详细的规格参数划分，其实属性也就是一个名字而已（简化简化简化）。</p>
<pre><code>CREATE TABLE property (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) DEFAULT NULL COMMENT &#39;属性名称&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应的产品id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_property_product FOREIGN KEY (product_id) REFERENCES product(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><blockquote>
<ul>
<li><strong>突然想到的问题：</strong><br>每一个产品的属性其实是很多的，如果每一个产品都对应很多属性的话，对于天猫这样的数据量来说，应该会让数据库爆炸的吧…</li>
<li><strong>改进方法：</strong><br>将属性表关联到 category 表上，因为其实每一个分类下的产品的属性差不多！</li>
</ul>
</blockquote>
<h4 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h4><p>根据以上问题，修改一下数据库表之间的关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-8dcfd056d47a8b0f.png" alt=""></p>
<p>并将属性表的外键修改为 category 的主键：</p>
<pre><code>CREATE TABLE property (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) DEFAULT NULL COMMENT &#39;属性名称&#39;,
  category_id int(11) NOT NULL COMMENT &#39;对应的分类id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_property_category FOREIGN KEY (category_id) REFERENCES category(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><h4 id="表五：属性值表"><a href="#表五：属性值表" class="headerlink" title="表五：属性值表"></a>表五：属性值表</h4><p>其中就是保存了对应属性的值，并且应该有两个外键，一个指向 Property 表，而另一个则指向 Product 表</p>
<pre><code>CREATE TABLE property_value (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;,
  properti_id int(11) NOT NULL COMMENT &#39;对应属性id&#39;,
  value varchar(255) DEFAULT NULL COMMENT &#39;具体的属性值&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_property_value_property FOREIGN KEY (properti_id) REFERENCES property (id),
  CONSTRAINT fk_property_value_product FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><h4 id="表六：产品图片表"><a href="#表六：产品图片表" class="headerlink" title="表六：产品图片表"></a>表六：产品图片表</h4><p>这个表名义上是保存了产品的图片，其实只是保存了产品图片的位置即图片名称，我们可以规定所有的产品图片都放在一个统一的文件夹下面，然后<strong>通过 id 来获取对应名称的图片</strong>：</p>
<pre><code>CREATE TABLE product_image (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  product_id int(11) DEFAULT NULL COMMENT &#39;对应的产品id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_product_image_product FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><ul>
<li><strong>注意：</strong> 我们通过把产品图片的文件命名为 id.jpg ，然后通过相对路径来获取到产品图片</li>
</ul>
<h4 id="表七：用户表"><a href="#表七：用户表" class="headerlink" title="表七：用户表"></a>表七：用户表</h4><p>用户表很简单，也没有权限之类的东西：</p>
<pre><code>CREATE TABLE user (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) NOT NULL COMMENT &#39;用户名称&#39;,
  password varchar(255) NOT NULL COMMENT &#39;用户密码&#39;,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><ul>
<li>我们或许会在之后把密码弄成 “<strong>*****</strong>” 这种形式的，但是现在一切为了简单！</li>
</ul>
<h4 id="表八：评价表"><a href="#表八：评价表" class="headerlink" title="表八：评价表"></a>表八：评价表</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-048235277c4287f2.png" alt=""></p>
<p>评价表对应了用户和产品两个表，也比较简单，我们为了简单，把上面红色的部分全部砍掉，因为没有商家，所以也不需要回复用户的评价，都砍掉砍掉！</p>
<pre><code>CREATE TABLE review (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  content varchar(4000) DEFAULT NULL COMMENT &#39;评价内容&#39;,
  user_id int(11) NOT NULL COMMENT &#39;对应的用户id&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应的产品id&#39;,
  createDate datetime DEFAULT NULL COMMENT &#39;评价时间&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_review_product FOREIGN KEY (product_id) REFERENCES product (id),
    CONSTRAINT fk_review_user FOREIGN KEY (user_id) REFERENCES user (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><h4 id="表九：订单表"><a href="#表九：订单表" class="headerlink" title="表九：订单表"></a>表九：订单表</h4><p>由于 Order 是 MySql 的一个关键字，所以我们在订单表的最后添加一个下划线：</p>
<pre><code>CREATE TABLE order_ (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  order_code varchar(255) NOT NULL COMMENT &#39;订单号&#39;,
  address varchar(255) NOT NULL COMMENT &#39;收货地址&#39;,
  post varchar(255) NOT NULL COMMENT &#39;邮编&#39;,
  receiver varchar(255) NOT NULL COMMENT &#39;收货人姓名&#39;,
  mobile varchar(255) NOT NULL COMMENT &#39;手机号码&#39;,
  user_message varchar(255) NOT NULL COMMENT &#39;用户备注的信息&#39;,
  create_date datetime NOT NULL COMMENT &#39;订单创建时间&#39;,
  pay_date datetime DEFAULT NULL COMMENT &#39;订单支付时间&#39;,
  delivery_date datetime DEFAULT NULL COMMENT &#39;发货日期&#39;,
  confirm_date datetime DEFAULT NULL COMMENT &#39;确认收货日期&#39;,
  user_id int(11) DEFAULT NULL COMMENT &#39;对应的用户id&#39;,
  status varchar(255) NOT NULL COMMENT &#39;订单状态&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES user (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><h4 id="表十：订单项表"><a href="#表十：订单项表" class="headerlink" title="表十：订单项表"></a>表十：订单项表</h4><p>一个订单里面可能有多个订单项，一个产品也可能对应多个订单项，所以这个表应该有两个外键：</p>
<pre><code>CREATE TABLE order_item (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;,
  order_id int(11) NOT NULL COMMENT &#39;对应订单id&#39;,
  number int(11) DEFAULT NULL COMMENT &#39;对应产品购买的数量&#39;,
  PRIMARY KEY (id) COMMENT &#39;邮编&#39;,
  CONSTRAINT fk_order_item_product FOREIGN KEY (product_id) REFERENCES product (id),
  CONSTRAINT fk_order_item_order FOREIGN KEY (order_id) REFERENCES order_ (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><h4 id="汇总："><a href="#汇总：" class="headerlink" title="汇总："></a>汇总：</h4><p>我们在创建表之前，应该创建一个新的数据库，并命名为【tmall_ssm】</p>
<pre><code>DROP DATABASE IF EXISTS tmall_ssm;
CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8;</code></pre><p>将这十个表汇个总就是：</p>
<pre><code>DROP DATABASE IF EXISTS tmall_ssm;
CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8;

use tmall_ssm;

CREATE TABLE category (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) NOT NULL COMMENT &#39;分类的名字&#39;,
  PRIMARY KEY (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE referal_link (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  text varchar(255) NOT NULL COMMENT &#39;超链显示的文字&#39;,
  link varchar(255) NOT NULL COMMENT &#39;超链的地址&#39;,
  PRIMARY KEY (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE product (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) NOT NULL COMMENT &#39;产品的名称&#39;,
  sub_title varchar(255) DEFAULT NULL COMMENT &#39;小标题&#39;,
  price float DEFAULT NULL COMMENT &#39;价格&#39;,
  sale int(11) DEFAULT NULL COMMENT &#39;销量&#39;,
  stock int(11) DEFAULT NULL COMMENT &#39;库存&#39;,
  category_id int(11) DEFAULT NULL COMMENT &#39;对应的分类id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_product_category FOREIGN KEY (category_id) REFERENCES category (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE property (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) DEFAULT NULL COMMENT &#39;属性名称&#39;,
  category_id int(11) NOT NULL COMMENT &#39;对应的分类id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_property_category FOREIGN KEY (category_id) REFERENCES category(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE property_value (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;,
  properti_id int(11) NOT NULL COMMENT &#39;对应属性id&#39;,
  value varchar(255) DEFAULT NULL COMMENT &#39;具体的属性值&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_property_value_property FOREIGN KEY (properti_id) REFERENCES property (id),
  CONSTRAINT fk_property_value_product FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE product_image (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  product_id int(11) DEFAULT NULL COMMENT &#39;对应的产品id&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_product_image_product FOREIGN KEY (product_id) REFERENCES product (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE user (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  name varchar(255) NOT NULL COMMENT &#39;用户名称&#39;,
  password varchar(255) NOT NULL COMMENT &#39;用户密码&#39;,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE review (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  content varchar(4000) DEFAULT NULL COMMENT &#39;评价内容&#39;,
  user_id int(11) NOT NULL COMMENT &#39;对应的用户id&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应的产品id&#39;,
  createDate datetime DEFAULT NULL COMMENT &#39;评价时间&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_review_product FOREIGN KEY (product_id) REFERENCES product (id),
  CONSTRAINT fk_review_user FOREIGN KEY (user_id) REFERENCES user (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE order_ (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  order_code varchar(255) NOT NULL COMMENT &#39;订单号&#39;,
  address varchar(255) NOT NULL COMMENT &#39;收货地址&#39;,
  post varchar(255) NOT NULL COMMENT &#39;邮编&#39;,
  receiver varchar(255) NOT NULL COMMENT &#39;收货人姓名&#39;,
  mobile varchar(255) NOT NULL COMMENT &#39;手机号码&#39;,
  user_message varchar(255) NOT NULL COMMENT &#39;用户备注的信息&#39;,
  create_date datetime NOT NULL COMMENT &#39;订单创建时间&#39;,
  pay_date datetime DEFAULT NULL COMMENT &#39;订单支付时间&#39;,
  delivery_date datetime DEFAULT NULL COMMENT &#39;发货日期&#39;,
  confirm_date datetime DEFAULT NULL COMMENT &#39;确认收货日期&#39;,
  user_id int(11) DEFAULT NULL COMMENT &#39;对应的用户id&#39;,
  status varchar(255) NOT NULL COMMENT &#39;订单状态&#39;,
  PRIMARY KEY (id),
  CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES user (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE order_item (
  id int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;唯一索引id&#39;,
  product_id int(11) NOT NULL COMMENT &#39;对应产品id&#39;,
  order_id int(11) NOT NULL COMMENT &#39;对应订单id&#39;,
  number int(11) DEFAULT NULL COMMENT &#39;对应产品购买的数量&#39;,
  PRIMARY KEY (id) COMMENT &#39;邮编&#39;,
  CONSTRAINT fk_order_item_product FOREIGN KEY (product_id) REFERENCES product (id),
  CONSTRAINT fk_order_item_order FOREIGN KEY (order_id) REFERENCES order_ (id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</code></pre><p>直接复制进 MySql 中执行，就能看到我们创建好的十个数据库：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-559c02b039ba4d57.png" alt=""></p>
<hr>
<h2 id="第三步：创建-SSM-开发环境"><a href="#第三步：创建-SSM-开发环境" class="headerlink" title="第三步：创建 SSM 开发环境"></a>第三步：创建 SSM 开发环境</h2><p>根据之前我写过的博文：<a href="https://www.jianshu.com/p/3098050b0d14" target="_blank" rel="noopener">IDEA 整合 SSM</a> 搭建好 SSM 开发环境，这里给出完整的项目结构和 pom.xml 文件：</p>
<ul>
<li>完整的项目结构：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-7371e706e33bf2f4.png" alt=""></p>
<ul>
<li>pom.xml 文件：</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;name&gt;wmyskxz&lt;/name&gt;
    &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt;
    &lt;artifactId&gt;wmyskxz&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
                &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
                &lt;version&gt;6.1.7&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;connectors&gt;
                        &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;
                            &lt;port&gt;8888&lt;/port&gt;
                            &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt;
                        &lt;/connector&gt;
                    &lt;/connectors&gt;
                    &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version}
                    &lt;/webAppSourceDirectory&gt;
                    &lt;contextPath&gt;/&lt;/contextPath&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;properties&gt;
        &lt;!-- 设置项目编码编码 --&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;!-- spring版本号 --&gt;
        &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt;
        &lt;!-- mybatis版本号 --&gt;
        &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;!-- pageHelper --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
            &lt;version&gt;5.1.2-beta&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--jsqlparser--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
            &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- jstl标签 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;
            &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt;
            &lt;version&gt;1.2.5&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- java ee --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax&lt;/groupId&gt;
            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
            &lt;version&gt;7.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现slf4j接口并整合 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- JSON --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.8.7&lt;/version&gt;
        &lt;/dependency&gt;


        &lt;!-- 数据库 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.41&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- 数据库连接池 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- MyBatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis/spring整合包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- Spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre><hr>
<h2 id="MyBatis-逆向工程"><a href="#MyBatis-逆向工程" class="headerlink" title="MyBatis 逆向工程"></a>MyBatis 逆向工程</h2><p>按照正常的流程，我们应该去创建数据库对应的 POJO 和 DAO 类还有对应的 mapper 映射文件，按照上面的分析我们一共有十张表，想象一下为这十张表做这些无技术含量的机械化的繁杂的工作是多么头疼的一件事，我们希望的是：<strong>有人帮我自动创建好这些！</strong></p>
<ul>
<li><strong>MyBatis 官方提供了一种名为 “逆向工程” 的机制</strong>，其可以针对数据库中的单表自动生成 MyBatis 执行所需要的代码</li>
<li>包括：</li>
</ul>
<p><strong>Java 实体类、Mapper映射配置、Mapper代理接口</strong></p>
<h4 id="第一步：添加必要的-jar-包"><a href="#第一步：添加必要的-jar-包" class="headerlink" title="第一步：添加必要的 jar 包"></a>第一步：添加必要的 jar 包</h4><p>我们使用逆向工程，需要先导入 Mybatis Generator 的官方包，由于我们使用的是 Maven 搭建的 SSM 项目，所有我们可以去 Maven 的官网去查询需要的相关包：<a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-048c0f3c81ce740d.png" alt=""></p>
<p>戳进去点击最新的包：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-8b63aa02666d95ed.png" alt=""></p>
<p>就可以在下方找到 Maven 依赖添加的语句：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-6242885479edbf79.png" alt=""></p>
<p>直接粘进 pom.xml 就可以了，这里就不演示了。</p>
<h4 id="第二步：generatorConfig-xml"><a href="#第二步：generatorConfig-xml" class="headerlink" title="第二步：generatorConfig.xml"></a>第二步：generatorConfig.xml</h4><p>在【resources】下创建 generatorConfig.xml 配置文件，该配置文件说明了一些逆向工程的细节：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;

    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;

        &lt;!-- 是否去除自动生成的代码中的注释 true：是 false：否--&gt;
        &lt;commentGenerator&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;!-- 数据库连接信息：驱动类、连接地址、用户名、密码 --&gt;
        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/tmall_ssm&quot;
                        userId=&quot;root&quot; password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 默认 false，把 JDBC DECIMAL 和 NUMERIC 类型解析为 Integer
             为 true 时解析为 java.math.BigDecimal --&gt;
        &lt;javaTypeResolver&gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
        &lt;/javaTypeResolver&gt;

        &lt;!-- targetProject：生成 POJO 类的位置 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;cn.wmyskxz.pojo&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;
            &lt;!-- trimStrings：从数据库返回的值被清理前后的空格 --&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
        &lt;/javaModelGenerator&gt;

        &lt;!-- targetProject：生成xml映射文件存放位置 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;
            &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/sqlMapGenerator&gt;

        &lt;!-- targetProject：生成mapper类存放位置 --&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.wmyskxz.mapper&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;!-- enableSubPackages：是否让 schema 作为包的后缀--&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/javaClientGenerator&gt;

        &lt;!--生成对应表及类名
            tableName:要生成的表名
            domainObjectName:生成后的实例名
            enableCountByExample:Count语句中加入where条件查询，默认为true开启
            enableUpdateByExample:Update语句中加入where条件查询，默认为true开启
            enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启
            enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启
            selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启
        --&gt;
        &lt;table tableName=&quot;category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot;
               selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;!-- 使用数据库中实际的字段名作为生成的实体类的属性 --&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 使用自增长键 --&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;property&quot; domainObjectName=&quot;Property&quot; enableCountByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot;
               selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;product_image&quot; domainObjectName=&quot;ProductImage&quot; enableCountByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot;
               selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;order_&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;property_value&quot; domainObjectName=&quot;PropertyValue&quot; enableCountByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot;
               selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;review&quot; domainObjectName=&quot;Review&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot;
               enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot; selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;order_item&quot; domainObjectName=&quot;OrderItem&quot; enableCountByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot;
               selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;

        &lt;table tableName=&quot;referal_link&quot; domainObjectName=&quot;ReferalLink&quot; enableCountByExample=&quot;false&quot;
               enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;true&quot;
               selectByExampleQueryId=&quot;false&quot;&gt;
            &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;</code></pre><p>这样配置文件也就编写好了</p>
<h4 id="第三步：逆向数据文件生成类"><a href="#第三步：逆向数据文件生成类" class="headerlink" title="第三步：逆向数据文件生成类"></a>第三步：逆向数据文件生成类</h4><p>在编写完配置文件只有，就需要加载该配置文件，利用逆向工程的机制来对数据库的各个表进行一系列文件的生成，我们在【test/java】包下创建【TestMyBatisGenerator】类：</p>
<pre><code>import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.api.ShellCallback;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * 逆向工程测试类
 *
 * @author: @我没有三颗心脏
 * @create: 2018-04-27-上午 8:26
 */
public class TestMybatisGenerator {

    public static void main(String[] args) throws Exception {
        // warnings 为用于放置生成过程中警告信息的集合对象
        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        // 指定是否覆盖重名文件
        boolean overwrite = true;
        // 加载配置文件
        File configFile = new File(MyBatisGenerator.class.getClassLoader().getResource(&quot;generatorConfig.xml&quot;).toURI());
        // 配置解析类
        ConfigurationParser cp = new ConfigurationParser(warnings);
        // 配置解析类解析配置文件并生成 Configuration 配置对象
        Configuration config = cp.parseConfiguration(configFile);
        // ShellCallback 负责如何处理重复文件
        ShellCallback callback = new DefaultShellCallback(overwrite);
        // 逆向工程对象
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
        // 执行逆向文件生成操作
        myBatisGenerator.generate(null);
        // 打印提示信息
        System.out.println(&quot;MyBatis 逆向工程执行成功，刷新项目查看文件！&quot;);
    }
}</code></pre><p>执行该测试类，就能看见自动生成的文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-207d1abeb35a84c0.png" alt=""></p>
<ul>
<li>Oh！这真的是太爽了！突然开心(*^▽^*)</li>
</ul>
<h4 id="看一下自动生成的文件"><a href="#看一下自动生成的文件" class="headerlink" title="看一下自动生成的文件"></a>看一下自动生成的文件</h4><p>以 Category 为例，我们来看一下自动生成的文件：</p>
<blockquote>
<ul>
<li>Category 实体类：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>pojo<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> Integer <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> name<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<ul>
<li>CategoryMapper 映射类：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>mapper<span class="token punctuation">;</span>

<span class="token keyword">import</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>Category<span class="token punctuation">;</span>
<span class="token keyword">import</span> cn<span class="token punctuation">.</span>wmyskxz<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>CategoryExample<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CategoryMapper</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">deleteByPrimaryKey</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span>Category record<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">insertSelective</span><span class="token punctuation">(</span>Category record<span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Category<span class="token operator">></span> <span class="token function">selectByExample</span><span class="token punctuation">(</span>CategoryExample example<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Category <span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">updateByPrimaryKeySelective</span><span class="token punctuation">(</span>Category record<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">updateByPrimaryKey</span><span class="token punctuation">(</span>Category record<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<ul>
<li>CategoryMapper.xml 映射文件：</li>
</ul>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;cn.wmyskxz.mapper.CategoryMapper&quot;&gt;
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;cn.wmyskxz.pojo.Category&quot;&gt;
        &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;
    &lt;/resultMap&gt;
    &lt;sql id=&quot;Example_Where_Clause&quot;&gt;
        &lt;where&gt;
            &lt;foreach collection=&quot;oredCriteria&quot; item=&quot;criteria&quot; separator=&quot;or&quot;&gt;
                &lt;if test=&quot;criteria.valid&quot;&gt;
                    &lt;trim prefix=&quot;(&quot; prefixOverrides=&quot;and&quot; suffix=&quot;)&quot;&gt;
                        &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot;&gt;
                            &lt;choose&gt;
                                &lt;when test=&quot;criterion.noValue&quot;&gt;
                                    and ${criterion.condition}
                                &lt;/when&gt;
                                &lt;when test=&quot;criterion.singleValue&quot;&gt;
                                    and ${criterion.condition} #{criterion.value}
                                &lt;/when&gt;
                                &lt;when test=&quot;criterion.betweenValue&quot;&gt;
                                    and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}
                                &lt;/when&gt;
                                &lt;when test=&quot;criterion.listValue&quot;&gt;
                                    and ${criterion.condition}
                                    &lt;foreach close=&quot;)&quot; collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot;
                                             separator=&quot;,&quot;&gt;
                                        #{listItem}
                                    &lt;/foreach&gt;
                                &lt;/when&gt;
                            &lt;/choose&gt;
                        &lt;/foreach&gt;
                    &lt;/trim&gt;
                &lt;/if&gt;
            &lt;/foreach&gt;
        &lt;/where&gt;
    &lt;/sql&gt;
    &lt;sql id=&quot;Base_Column_List&quot;&gt;
    id, name
  &lt;/sql&gt;
    &lt;select id=&quot;selectByExample&quot; parameterType=&quot;cn.wmyskxz.pojo.CategoryExample&quot; resultMap=&quot;BaseResultMap&quot;&gt;
        select
        &lt;if test=&quot;distinct&quot;&gt;
            distinct
        &lt;/if&gt;
        &#39;false&#39; as QUERYID,
        &lt;include refid=&quot;Base_Column_List&quot;/&gt;
        from category
        &lt;if test=&quot;_parameter != null&quot;&gt;
            &lt;include refid=&quot;Example_Where_Clause&quot;/&gt;
        &lt;/if&gt;
        &lt;if test=&quot;orderByClause != null&quot;&gt;
            order by ${orderByClause}
        &lt;/if&gt;
    &lt;/select&gt;
    &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;
        select
        &lt;include refid=&quot;Base_Column_List&quot;/&gt;
        from category
        where id = #{id,jdbcType=INTEGER}
    &lt;/select&gt;
    &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from category
    where id = #{id,jdbcType=INTEGER}
  &lt;/delete&gt;
    &lt;insert id=&quot;insert&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot;
            useGeneratedKeys=&quot;true&quot;&gt;
    insert into category (name)
    values (#{name,jdbcType=VARCHAR})
  &lt;/insert&gt;
    &lt;insert id=&quot;insertSelective&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot;
            useGeneratedKeys=&quot;true&quot;&gt;
        insert into category
        &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name,
            &lt;/if&gt;
        &lt;/trim&gt;
        &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                #{name,jdbcType=VARCHAR},
            &lt;/if&gt;
        &lt;/trim&gt;
    &lt;/insert&gt;
    &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot;&gt;
        update category
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #{name,jdbcType=VARCHAR},
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #{id,jdbcType=INTEGER}
    &lt;/update&gt;
    &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;cn.wmyskxz.pojo.Category&quot;&gt;
    update category
    set name = #{name,jdbcType=VARCHAR}
    where id = #{id,jdbcType=INTEGER}
  &lt;/update&gt;
&lt;/mapper&gt;</code></pre><p>其中就只有映射文件稍微有些复杂，但细看下来其实跟我们自己写的差不多，甚至自动生成的完成得更好。</p>
<blockquote>
<p>xxxExample</p>
</blockquote>
<p>MybatisGenerator会生成一个类叫做XXXXExample的。，它的作用是进行排序，条件查询的时候使用。</p>
<p>这里有详细的说明，了解一下就好了：<a href="https://blog.csdn.net/biandous/article/details/65630783" target="_blank" rel="noopener">戳这里</a></p>
<h4 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h4><p>我们这里仅仅就用 CategoryMapper 映射类来进行简单测试了：</p>
<pre><code>@Autowired
CategoryMapper categoryMapper;

@Test
public void test() {
    Category category = new Category();
    category.setName(&quot;分类1&quot;);
    categoryMapper.insert(category);
}</code></pre><p>由于我们使用了自增长键 id ，所以仅仅只需要提供 name 属性就可以了，执行，可以看到数据库中有正确的数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%A8%A1%E4%BB%BF%E5%A4%A9%E7%8C%AB%E5%AE%9E%E6%88%98%E3%80%90SSM%E7%89%88%E3%80%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/7896890-b1e9cbc59225eb31.png" alt=""></p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>根据以上的 “折腾” 算是完成了项目的起步工作了吧，我是一边写项目一边写博客的，所以可能有时候想着想着写着写着思绪会有点飘，写得凌乱，这也是没有办法的事，不管写得好还是差我都希望能记录下来，这些都是属于我自己的思路和学习路程。</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/04/25/java-web-fen-ye-gong-neng-xiang-jie/">
      Java Web—【分页功能】详解
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E5%9F%BA%E7%A1%80/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb基础</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年4月25日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-Web--%E3%80%90%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E3%80%91%E8%AF%A6%E8%A7%A3/7896890-0ce014f6dad48288.png" alt=""></p>
<h2 id="分页简介"><a href="#分页简介" class="headerlink" title="分页简介"></a>分页简介</h2><p>分页功能在网页中是非常常见的一个功能，<strong>其作用也就是将数据分割成多个页面来进行显示。</strong></p>
<blockquote>
<ul>
<li><strong>使用场景：</strong> 当取到的数据量达到一定的时候，就需要使用分页来进行数据分割。</li>
</ul>
</blockquote>
<p>当我们不使用分页功能的时候，会面临许多的问题：</p>
<blockquote>
<ul>
<li><strong>客户端的问题：</strong> 如果数据量太多，都显示在同一个页面的话，会因为页面太长<strong>严重影响到用户的体验，也不便于操作</strong>，也会出现<strong>加载太慢</strong>的问题。</li>
<li><strong>服务端的问题：</strong> 如果数据量太多，可能会造成<strong>内存溢出</strong>，而且一次请求携带的数据太多，<strong>对服务器的性能也是一个考验。</strong></li>
</ul>
</blockquote>
<hr>
<h4 id="分页的分类"><a href="#分页的分类" class="headerlink" title="分页的分类"></a>分页的分类</h4><p>分页的实现分为真分页和假分页两种，也就是物理分页和逻辑分页。</p>
<p>1.真分页（物理分页）：</p>
<blockquote>
<ul>
<li><strong>实现原理：</strong> <code>SELECT * FROM xxx [WHERE...] LIMIT #{param1}, #{param2}</code><br>第一个参数是开始数据的索引位置<br>第二个参数是要查询多少条数据</li>
<li><strong>优点：</strong> 不会造成内存溢出</li>
<li><strong>缺点：</strong> 翻页的速度比较慢</li>
</ul>
</blockquote>
<p>2.假分页（逻辑分页）：</p>
<blockquote>
<ul>
<li><strong>实现原理： 一次性将所有的数据查询出来放在内存之中</strong>，每次需要查询的时候就直接从内存之中去取出相应索引区间的数据</li>
<li><strong>优点：</strong> 分页的速度比较快</li>
<li><strong>缺点：</strong> 可能造成内存溢出</li>
</ul>
</blockquote>
<hr>
<h2 id="传统的分页方式"><a href="#传统的分页方式" class="headerlink" title="传统的分页方式"></a>传统的分页方式</h2><p>对于假分页的实现方式很简单，只需要准备一个集合保存从数据库中取出的所有数据，然后根据当前页面的码数，取出对应范围的数据显示就好了，<strong>我们这里基于物理分页来实现。</strong></p>
<h4 id="分页的原理"><a href="#分页的原理" class="headerlink" title="分页的原理"></a>分页的原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-Web--%E3%80%90%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E3%80%91%E8%AF%A6%E8%A7%A3/7896890-bf9595ac0edbf696.png" alt=""></p>
<blockquote>
<ul>
<li><strong>页面中的数据有：</strong><br>结果集：通过 SQL 语句查询得来的——<strong>List<Student></strong></li>
<li><strong>分页条中的数据有：</strong><br>当前页：用户传递到后台——<strong>currentPage</strong><br>总页数：计算的来——<strong>totalPage</strong><br>上一页：计算的来——<strong>prePage</strong><br>下一页：计算的来——<strong>nextPage</strong><br>尾页：计算的来（总页数）——<strong>lastPage</strong><br>页面大小（即每一页显示的条数）：用户传递到后台——<strong>count</strong><br>总条数：通过 SQL 语句查询得来的——<strong>totalCount</strong></li>
</ul>
</blockquote>
<p>可以发现页面功能中需要用到的数据<strong>有两个是需要通过 SQL 语句查询得来</strong>的：一个是页面中显示的数据 <strong>List<Student></strong> ，另一个是数据的总条数 <strong>totalCount</strong>，分别对应以下两条 SQL 语句：</p>
<blockquote>
<ul>
<li><code>SELECT * FROM student LIMIT #{param1}, #{param2}</code></li>
<li><code>SELECT COUNT(*) FROM student</code></li>
</ul>
</blockquote>
<p>通过计算得到的数据有：</p>
<blockquote>
<ul>
<li><strong>总页数：totalPage</strong><br>总页数 = 总条数 % 页面大小 == 0 ? 总条数 / 页面大小 : 总条数 / 页面大小 + 1</li>
<li><strong>上一页：prePage</strong><br>上一页 = 当前页 - 1 &gt; = 1 ? 当前页 - 1 : 1</li>
<li><strong>下一页：nextPage</strong><br>下一页 = 当前页 + 1 &lt;= totalPage ? 当前页 + 1 : totalPage</li>
<li><strong>尾页：lastPage</strong><br>尾页 = 总条数 % 页面大小 == 0 ？ 总条数 - 页面大小 : 总条数 - 总条数 % 页面大小</li>
</ul>
</blockquote>
<p>用户传递的数据：</p>
<blockquote>
<ul>
<li><strong>当前页：currentPage</strong></li>
<li><strong>页面大小：count</strong></li>
</ul>
</blockquote>
<hr>
<p>所有我们可以创建一个 Page 工具类备用：</p>
<pre><code>public class Page {

    int start;        // 开始数据的索引
    int count;        // 每一页的数量
    int total;        // 总共的数据量

    /**
     * 提供一个构造方法
     * @param start
     * @param count
     */    
    public Page(int start, int count) {
        super();
        this.start = start;
        this.count = count;
    }

    /**
     * 判断是否有上一页
     * @return
     */
    public boolean isHasPreviouse(){
        if(start==0)
            return false;
        return true;

    }

    /**
     * 判断是否有下一页
     * @return
     */
    public boolean isHasNext(){
        if(start==getLast())
            return false;
        return true;
    }

    /**
     * 计算得到总页数
     * @return
     */
    public int getTotalPage(){
        int totalPage;
        // 假设总数是50，是能够被5整除的，那么就有10页
        if (0 == total % count)
            totalPage = total /count;
            // 假设总数是51，不能够被5整除的，那么就有11页
        else
            totalPage = total / count + 1;

        if(0==totalPage)
            totalPage = 1;
        return totalPage;
    }

    /**
     * 计算得到尾页
     * @return
     */
    public int getLast(){
        int last;
        // 假设总数是50，是能够被5整除的，那么最后一页的开始就是45
        if (0 == total % count)
            last = total - count;
            // 假设总数是51，不能够被5整除的，那么最后一页的开始就是50
        else
            last = total - total % count;

        last = last&lt;0?0:last;
        return last;
    }

    /* getter and setter */
}</code></pre><hr>
<h2 id="前台实现分页设计"><a href="#前台实现分页设计" class="headerlink" title="前台实现分页设计"></a>前台实现分页设计</h2><p>首先我们在前台需要完成我们分页条的设计，这里可以直接引入 <strong>Bootstrap</strong> 来完成：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-Web--%E3%80%90%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E3%80%91%E8%AF%A6%E8%A7%A3/7896890-925ca8cf718ac094.png" alt=""></p>
<blockquote>
<p>上面是使用 <strong>Bootstrap</strong> 实现一个分页条的简单例子，如果不熟悉的童鞋可以去菜鸟教程中查看：<a href="http://www.runoob.com/bootstrap/bootstrap-pagination.html" target="_blank" rel="noopener">点这里</a></p>
</blockquote>
<hr>
<h4 id="简单版本的分页条"><a href="#简单版本的分页条" class="headerlink" title="简单版本的分页条"></a>简单版本的分页条</h4><p>为了便于理解，我们先来实现一个简单版本的分页条吧：</p>
<blockquote>
<ul>
<li>首页超链：指向了 start 为 0 的首页</li>
</ul>
</blockquote>
<pre><code>&lt;li&gt;
    &lt;a href=&quot;?page.start=0&quot;&gt;
        &lt;span&gt;«&lt;/span&gt;
    &lt;/a&gt;
&lt;/li&gt;</code></pre><blockquote>
<ul>
<li>上一页超链：</li>
</ul>
</blockquote>
<pre><code>&lt;li &gt;
    &lt;a  href=&quot;?page.start=${page.start-page.count}&quot;&gt;
        &lt;span&gt;‹&lt;/span&gt;
    &lt;/a&gt;
&lt;/li&gt;</code></pre><blockquote>
<ul>
<li>下一页超链：</li>
</ul>
</blockquote>
<pre><code>&lt;li &gt;
    &lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt;
        &lt;span&gt;›&lt;/span&gt;
    &lt;/a&gt;
&lt;/li&gt;</code></pre><blockquote>
<ul>
<li>最后一页超链：指向了最后一页</li>
</ul>
</blockquote>
<pre><code>&lt;li &gt;
    &lt;a href=&quot;?page.start=${page.last}&quot;&gt;
        &lt;span&gt;»&lt;/span&gt;
    &lt;/a&gt;
&lt;/li&gt;</code></pre><blockquote>
<ul>
<li>中间页：</li>
</ul>
</blockquote>
<pre><code>&lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;
    &lt;li&gt;
        &lt;a href=&quot;?page.start=${status.index*page.count}&quot; class=&quot;current&quot;&gt;${status.count}&lt;/a&gt;
    &lt;/li&gt;
&lt;/c:forEach&gt;</code></pre><blockquote>
<ul>
<li>所以写完看起来会是这样子的：</li>
</ul>
</blockquote>
<pre><code>&lt;nav&gt;
    &lt;ul class=&quot;pagination&quot;&gt;
        &lt;li&gt;
            &lt;a  href=&quot;?page.start=0&quot;&gt;
                &lt;span&gt;«&lt;/span&gt;
            &lt;/a&gt;
        &lt;/li&gt;

        &lt;li &gt;
            &lt;a  href=&quot;?page.start=${page.start-page.count}&quot;&gt;
                &lt;span&gt;‹&lt;/span&gt;
            &lt;/a&gt;
        &lt;/li&gt;

        &lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;
            &lt;li&gt;
                &lt;a href=&quot;?page.start=${status.index*page.count}&quot; class=&quot;current&quot;&gt;${status.count}&lt;/a&gt;
            &lt;/li&gt;
        &lt;/c:forEach&gt;

        &lt;li &gt;
            &lt;a href=&quot;?page.start=${page.start+page.count}&quot;&gt;
                &lt;span&gt;›&lt;/span&gt;
            &lt;/a&gt;
        &lt;/li&gt;
        &lt;li &gt;
            &lt;a href=&quot;?page.start=${page.last}&quot;&gt;
                &lt;span&gt;»&lt;/span&gt;
            &lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;</code></pre><ul>
<li><strong>存在的问题：</strong><br>① 没有边界判断，即在首页仍然可以点击前一页，不符合逻辑也影响用户体验<br>② 会显示完所有的分页，即如果 totalPage 有50页，那么分页栏将会显得特别长，影响体验</li>
</ul>
<hr>
<h4 id="改良版本的分页条"><a href="#改良版本的分页条" class="headerlink" title="改良版本的分页条"></a>改良版本的分页条</h4><p>1.写好头和尾</p>
<pre><code>&lt;nav class=&quot;pageDIV&quot;&gt;
    &lt;ul class=&quot;pagination&quot;&gt;
    .....
    &lt;/ul&gt;
&lt;/nav&gt;</code></pre><p>2.写好<code>«</code> <code>‹</code>这两个功能按钮<br>使用 <code>&lt;c:if&gt;</code>标签来增加边界判断，如果没有前面的页码了则设置为disable状态</p>
<pre><code>        &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
            &lt;a href=&quot;?page.start=0&quot;&gt;
                &lt;span&gt;«&lt;/span&gt;
            &lt;/a&gt;
        &lt;/li&gt;

        &lt;li &lt;c:if test=&quot;${!page.hasPreviouse}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
            &lt;a href=&quot;?page.start=${page.start-page.count}&quot;&gt;
                &lt;span&gt;‹&lt;/span&gt;
            &lt;/a&gt;
        &lt;/li&gt;</code></pre><p>再通过 JavaScrip 代码来完成禁用功能：</p>
<pre><code>&lt;script&gt;
    $(function () {
        $(&quot;ul.pagination li.disabled a&quot;).click(function () {
            return false;
        });
    });
&lt;/script&gt;</code></pre><p>3.完成中间页码的编写</p>
<pre><code>&lt;c:forEach begin=&quot;0&quot; end=&quot;${page.totalPage-1}&quot; varStatus=&quot;status&quot;&gt;

    &lt;c:if test=&quot;${status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10}&quot;&gt;
        &lt;li &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;disabled&quot;&lt;/c:if&gt;&gt;
            &lt;a
                    href=&quot;?page.start=${status.index*page.count}&quot;
                    &lt;c:if test=&quot;${status.index*page.count==page.start}&quot;&gt;class=&quot;current&quot;&lt;/c:if&gt;
            &gt;${status.count}&lt;/a&gt;
        &lt;/li&gt;
    &lt;/c:if&gt;
&lt;/c:forEach&gt;</code></pre><p>从 <code>0</code> 循环到 <code>page.totalPage - 1</code> ，<code>varStatus</code> 相当于是循环变量</p>
<ul>
<li>status.count 是从1开始遍历</li>
<li>status.index 是从0开始遍历</li>
<li><strong>要求：</strong>显示当前页码的前两个和后两个就可，例如当前页码为3的时候，就显示 1 2 3(当前页) 4 5 的页码</li>
<li><strong>理解测试条件：</strong></li>
<li>10 &lt;= 当前页*每一页显示的数目 - 当前页开始的数据编号 &lt;= 30<br><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-Web--%E3%80%90%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E3%80%91%E8%AF%A6%E8%A7%A3/7896890-1f82d91e47a31c7f.png" alt=""></li>
<li>只要理解了这个判断条件，其他的就都好理解了</li>
</ul>
<blockquote>
<ul>
<li><strong>注意：</strong> 测试条件是需要根据项目的需求动态改变的，不是万能的！</li>
</ul>
</blockquote>
<hr>
<h2 id="后台中的分页"><a href="#后台中的分页" class="headerlink" title="后台中的分页"></a>后台中的分页</h2><p>首页在项目中引入上面提到的 Page 工具类，然后我们在 DAO 类中使用 LIMIT 关键字来查询数据库中的信息：</p>
<pre><code>public List&lt;Student&gt; list() {
    return list(0, Short.MAX_VALUE);
}

public List&lt;Student&gt; list(int start, int count) {

    List&lt;Student&gt; students = new ArrayList&lt;&gt;();

    String sql = &quot;SELECT * FROM student ORDER BY student_id desc limit ?,?&quot;;

    try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) {

        ps.setInt(1, start);
        ps.setInt(2, count);

        // 获取结果集...
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return students;
}</code></pre><p>在 Servlet 中获取分页参数并使首页显示的 StudentList 用 page 的参数来获取：</p>
<pre><code>// 获取分页参数
int start = 0;
int count = 10;

try {
    start = Integer.parseInt(req.getParameter(&quot;page.start&quot;));
    count = Integer.parseInt(req.getParameter(&quot;page.count&quot;));
} catch (Exception e) {
}
Page page = new Page(start, count);

List&lt;Student&gt; students = studentDAO.list(page.getStart(), page.getCount());

....

// 共享数据
req.setAttribute(&quot;page&quot;, page);
req.setAttribute(&quot;students&quot;, students);</code></pre><p>以上即可完成分页功能，但这是基于 Servlet 的版本，在之前写过的项目（<a href="https://www.jianshu.com/p/553fc76bb8eb" target="_blank" rel="noopener">学生管理系统(简易版)</a>）中实际的使用了这种方法，感兴趣的可以去看一下。</p>
<hr>
<h2 id="SSM-中的分页"><a href="#SSM-中的分页" class="headerlink" title="SSM 中的分页"></a>SSM 中的分页</h2><p>在 SSM 项目中，我们可以使用 MyBatis 的一款分页插件： PageHelper 来帮助我们更加简单的完成分页的需求，官网在这里： <a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">PageHelper</a> </p>
<p>在这里，我们演示一下如何使用上面的工具重构我们之前写过的 SSM 项目 —— <a href="https://www.jianshu.com/p/6a594fbea51d" target="_blank" rel="noopener">学生管理系统-SSM 版</a> </p>
<h4 id="第一步：添加相关-jar-依赖包"><a href="#第一步：添加相关-jar-依赖包" class="headerlink" title="第一步：添加相关 jar 依赖包"></a>第一步：添加相关 jar 依赖包</h4><p>PageHelper 需要依赖两个 jar 包，我们直接在 pom.xml 中增加两个 jar 包依赖：</p>
<pre><code>&lt;!-- pageHelper --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.1.2-beta&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--jsqlparser--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h4 id="第二步：配置相关环境"><a href="#第二步：配置相关环境" class="headerlink" title="第二步：配置相关环境"></a>第二步：配置相关环境</h4><p>在 MyBatis 的 SessionFactory 配置中新增加一个属性名 plugins 的配置：</p>
<pre><code>&lt;!-- 配置SqlSessionFactory对象 --&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 注入数据库连接池 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!-- 扫描entity包 使用别名 --&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.wmyskxz.entity&quot;/&gt;
    &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;!-- 让MyBatis支持PageHelper插件 --&gt;
    &lt;property name=&quot;plugins&quot;&gt;
        &lt;array&gt;
            &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;
                &lt;property name=&quot;properties&quot;&gt;
                    &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;
                    &lt;value&gt;
                    &lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><h4 id="第三步：重构项目"><a href="#第三步：重构项目" class="headerlink" title="第三步：重构项目"></a>第三步：重构项目</h4><p>首先我们把 LIMIT 关键字从映射文件中干掉：</p>
<pre><code>&lt;!-- 查询从start位置开始的count条数据--&gt;
&lt;select id=&quot;list&quot; resultMap=&quot;student&quot;&gt;
    SELECT * FROM student ORDER BY student_id desc
&lt;/select&gt;</code></pre><p>然后注释掉查询数据总条数的 SQL 语句：</p>
<pre><code>&lt;!--&amp;lt;!&amp;ndash; 查询数据条目 &amp;ndash;&amp;gt;--&gt;
&lt;!--&lt;select id=&quot;getTotal&quot; resultType=&quot;int&quot;&gt;--&gt;
    &lt;!--SELECT COUNT(*) FROM student--&gt;
&lt;!--&lt;/select&gt;--&gt;</code></pre><p>在 Dao 类和 Service 类中修改相应的地方：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-Web--%E3%80%90%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%E3%80%91%E8%AF%A6%E8%A7%A3/7896890-bfdb81b11494b415.png" alt=""></p>
<p>然后修改掉 StudentController 中的方法：</p>
<pre><code>@RequestMapping(&quot;/listStudent&quot;)
public String listStudent(HttpServletRequest request, HttpServletResponse response) {

    // 获取分页参数
    int start = 0;
    int count = 10;

    try {
        start = Integer.parseInt(request.getParameter(&quot;page.start&quot;));
        count = Integer.parseInt(request.getParameter(&quot;page.count&quot;));
    } catch (Exception e) {
    }

    Page page = new Page(start, count);

    //  使用 PageHelper 来设置分页
    PageHelper.offsetPage(page.getStart(),page.getCount());
    List&lt;Student&gt; students = studentService.list();
    //  使用 PageHelper 来获取总数
    int total = (int) new PageInfo&lt;&gt;(students).getTotal();
    page.setTotal(total);

    request.setAttribute(&quot;students&quot;, students);
    request.setAttribute(&quot;page&quot;, page);

    return &quot;listStudent&quot;;
}</code></pre><p>重启服务器，能看到也能够正确的使用分页功能。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实我自己对于这个工具比较无感..因为只是弱化了少一部分的功能，并没有我想象中的那样 “智能” ，也没有看到什么好的博文能够点通我的认知，希望了解的大大们能无私分享一下，谢谢！</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/page/9/">
            <section class="post prev white-box shadow" >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          10 / 14
        </p>
        
          <a class="next" rel="next" href="/page/11/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.86px; color: #868686">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.29px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.57px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.86px; color: #646464">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.43px; color: #6d6d6d">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.43px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 19.71px; color: #727272">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.71px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.86px; color: #868686">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.57px; color: #818181">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.57px; color: #818181">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.14px; color: #686868">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.71px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.43px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.14px; color: #8a8a8a">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.71px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.43px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.57px; color: #818181">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.71px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.29px; color: #7c7c7c">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.71px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.14px; color: #8a8a8a">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.86px; color: #868686">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.14px; color: #686868">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19px; color: #777">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>



    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
