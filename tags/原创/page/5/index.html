<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>标签：原创 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">
      Redis(5)——亿级数据过滤和布隆过滤器
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月11日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-59d043fad3a66d7f.png" alt=""></p>
<h1 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h1><p><a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">上一次</a> 我们学会了使用 <strong>HyperLogLog</strong> 来对大数据进行一个估算，它非常有价值，可以解决很多精确度不高的统计需求。但是如果我们想知道某一个值是不是已经在 <strong>HyperLogLog</strong> 结构里面了，它就无能为力了，它只提供了 <code>pfadd</code> 和 <code>pfcount</code> 方法，没有提供类似于 <code>contains</code> 的这种方法。</p>
<p>就举一个场景吧，比如你 <strong>刷抖音</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-c7b6b5c8a47caf4a.png" alt=""></p>
<p>你有 <strong>刷到过重复的推荐内容</strong> 吗？这么多的推荐内容要推荐给这么多的用户，它是怎么保证每个用户在看推荐内容时，保证不会出现之前已经看过的推荐视频呢？也就是说，抖音是如何实现 <strong>推送去重</strong> 的呢？</p>
<p>你会想到服务器 <strong>记录</strong> 了用户看过的 <strong>所有历史记录</strong>，当推荐系统推荐短视频时会从每个用户的历史记录里进行 <strong>筛选</strong>，过滤掉那些已经存在的记录。问题是当 <strong>用户量很大</strong>，每个用户看过的短视频又很多的情况下，这种方式，推荐系统的去重工作 <strong>在性能上跟的上么？</strong></p>
<p>实际上，如果历史记录存储在关系数据库里，去重就需要频繁地对数据库进行 <code>exists</code> 查询，当系统并发量很高时，数据库是很难抗住压力的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-099f3600b7022ef6.jpg" alt="image"></p>
<p>你可能又想到了 <strong>缓存</strong>，但是这么多用户这么多的历史记录，如果全部缓存起来，那得需要 <strong>浪费多大的空间</strong> 啊.. <em>(可能老板看一眼账单，看一眼你..)</em> 并且这个存储空间会随着时间呈线性增长，就算你用缓存撑得住一个月，但是又能继续撑多久呢？不缓存性能又跟不上，咋办呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-204e7440395a31b5.png" alt=""></p>
<p>如上图所示，<strong>布隆过滤器(Bloom Filter)</strong> 就是这样一种专门用来解决去重问题的高级数据结构。但是跟 <strong>HyperLogLog</strong> 一样，它也一样有那么一点点不精确，也存在一定的误判概率，但它能在解决去重的同时，在 <strong>空间上能节省 90%</strong> 以上，也是非常值得的。</p>
<h2 id="布隆过滤器是什么"><a href="#布隆过滤器是什么" class="headerlink" title="布隆过滤器是什么"></a>布隆过滤器是什么</h2><p><strong>布隆过滤器（Bloom Filter）</strong> 是 1970 年由布隆提出的。它 <strong>实际上</strong> 是一个很长的二进制向量和一系列随机映射函数 <em>(下面详细说)</em>，实际上你也可以把它 <strong>简单理解</strong> 为一个不怎么精确的 <strong>set</strong> 结构，当你使用它的 <code>contains</code> 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p>
<p>当布隆过滤器说某个值存在时，这个值 <strong>可能不存在</strong>；当它说不存在时，那么 <strong>一定不存在</strong>。打个比方，当它说不认识你时，那就是真的不认识，但是当它说认识你的时候，可能是因为你长得像它认识的另外一个朋友 <em>(脸长得有些相似)</em>，所以误判认识你。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-757891d52045869d.jpg" alt="image"></p>
<h2 id="布隆过滤器的使用场景"><a href="#布隆过滤器的使用场景" class="headerlink" title="布隆过滤器的使用场景"></a>布隆过滤器的使用场景</h2><p>基于上述的功能，我们大致可以把布隆过滤器用于以下的场景之中：</p>
<ul>
<li><strong>大数据判断是否存在</strong>：这就可以实现出上述的去重功能，如果你的服务器内存足够大的话，那么使用 HashMap 可能是一个不错的解决方案，理论上时间复杂度可以达到 O(1 的级别，但是当数据量起来之后，还是只能考虑布隆过滤器。</li>
<li><strong>解决缓存穿透</strong>：我们经常会把一些热点数据放在 Redis 中当作缓存，例如产品详情。 通常一个请求过来之后我们会先查询缓存，而不用直接读取数据库，这是提升性能最简单也是最普遍的做法，但是 <strong>如果一直请求一个不存在的缓存</strong>，那么此时一定不存在缓存，那就会有 <strong>大量请求直接打到数据库</strong> 上，造成 <strong>缓存穿透</strong>，布隆过滤器也可以用来解决此类问题。</li>
<li><strong>爬虫/ 邮箱等系统的过滤</strong>：平时不知道你有没有注意到有一些正常的邮件也会被放进垃圾邮件目录中，这就是使用布隆过滤器 <strong>误判</strong> 导致的。</li>
</ul>
<h1 id="二、布隆过滤器原理解析"><a href="#二、布隆过滤器原理解析" class="headerlink" title="二、布隆过滤器原理解析"></a>二、布隆过滤器原理解析</h1><p>布隆过滤器 <strong>本质上</strong> 是由长度为 <code>m</code> 的位向量或位列表（仅包含 <code>0</code> 或 <code>1</code> 位值的列表）组成，最初所有的值均设置为 <code>0</code>，所以我们先来创建一个稍微长一些的位向量用作展示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-362a693c82af3c8e.png" alt=""></p>
<p>当我们向布隆过滤器中添加数据时，会使用 <strong>多个</strong> <code>hash</code> 函数对 <code>key</code> 进行运算，算得一个证书索引值，然后对位数组长度进行取模运算得到一个位置，每个 <code>hash</code> 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 <code>1</code> 就完成了 <code>add</code> 操作，例如，我们添加一个 <code>wmyskxz</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-fdbf75a56fb03c02.png" alt=""></p>
<p>向布隆过滤器查查询 <code>key</code> 是否存在时，跟 <code>add</code> 操作一样，会把这个 <code>key</code> 通过相同的多个 <code>hash</code> 函数进行运算，查看 <strong>对应的位置</strong> 是否 <strong>都</strong> 为 <code>1</code>，<strong>只要有一个位为 <code>0</code></strong>，那么说明布隆过滤器中这个 <code>key</code> 不存在。如果这几个位置都是 <code>1</code>，并不能说明这个 <code>key</code> 一定存在，只能说极有可能存在，因为这些位置的 <code>1</code> 可能是因为其他的 <code>key</code> 存在导致的。</p>
<p>就比如我们在 <code>add</code> 了一定的数据之后，查询一个 <strong>不存在</strong> 的 <code>key</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-0beb6acc89d5c927.png" alt=""></p>
<p>很明显，<code>1/3/5</code> 这几个位置的 <code>1</code> 是因为上面第一次添加的 <code>wmyskxz</code> 而导致的，所以这里就存在 <strong>误判</strong>。幸运的是，布隆过滤器有一个可以预判误判率的公式，比较复杂，感兴趣的朋友可以自行去阅读，比较烧脑.. 只需要记住以下几点就好了：</p>
<ul>
<li>使用时 <strong>不要让实际元素数量远大于初始化数量</strong>；</li>
<li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行 <strong>重建</strong>，重新分配一个 <code>size</code> 更大的过滤器，再将所有的历史元素批量 <code>add</code> 进行；</li>
</ul>
<h1 id="三、布隆过滤器的使用"><a href="#三、布隆过滤器的使用" class="headerlink" title="三、布隆过滤器的使用"></a>三、布隆过滤器的使用</h1><p><strong>Redis 官方</strong> 提供的布隆过滤器到了 <strong>Redis 4.0</strong> 提供了插件功能之后才正式登场。布隆过滤器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。下面我们来体验一下 Redis 4.0 的布隆过滤器，为了省去繁琐安装过程，我们直接用<br>Docker 吧。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> docker pull redislabs/rebloom <span class="token comment" spellcheck="true"># 拉取镜像</span>
<span class="token operator">></span> docker run -p6379:6379 redislabs/rebloom <span class="token comment" spellcheck="true"># 运行容器</span>
<span class="token operator">></span> redis-cli <span class="token comment" spellcheck="true"># 连接容器中的 redis 服务</span></code></pre>
<p>如果上面三条指令执行没有问题，下面就可以体验布隆过滤器了。</p>
<ul>
<li>当然，如果你不想使用 Docker，也可以在检查本机 Redis 版本合格之后自行安装插件，可以参考这里: <a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">https://blog.csdn.net/u013030276/article/details/88350641</a></li>
</ul>
<h2 id="布隆过滤器的基本用法"><a href="#布隆过滤器的基本用法" class="headerlink" title="布隆过滤器的基本用法"></a>布隆过滤器的基本用法</h2><p>布隆过滤器有两个基本指令，<code>bf.add</code> 添加元素，<code>bf.exists</code> 查询元素是否存在，它的用法和 set 集合的 <code>sadd</code> 和 <code>sismember</code> 差不多。注意 <code>bf.add</code> 只能一次添加一个元素，如果想要一次添加多个，就需要用到 <code>bf.madd</code> 指令。同样如果需要一次查询多个元素是否存在，就需要用到 <code>bf.mexists</code> 指令。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> bf.add codehole user1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.add codehole user2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.add codehole user3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> bf.madd codehole user4 user5 user6
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.mexists codehole user4 user5 user6 user7
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>上面使用的布隆过过滤器只是默认参数的布隆过滤器，它在我们第一次 <code>add</code> 的时候自动创建。Redis 也提供了可以自定义参数的布隆过滤器，只需要在 <code>add</code> 之前使用 <code>bf.reserve</code> 指令显式创建就好了。如果对应的 <code>key</code> 已经存在，<code>bf.reserve</code> 会报错。</p>
<p><code>bf.reserve</code> 有三个参数，分别是 <code>key</code>、<code>error_rate</code> <em>(错误率)</em> 和 <code>initial_size</code>：</p>
<ul>
<li><strong><code>error_rate</code> 越低，需要的空间越大</strong>，对于不需要过于精确的场合，设置稍大一些也没有关系，比如上面说的推送系统，只会让一小部分的内容被过滤掉，整体的观看体验还是不会受到很大影响的；</li>
<li><strong><code>initial_size</code> 表示预计放入的元素数量</strong>，当实际数量超过这个值时，误判率就会提升，所以需要提前设置一个较大的数值避免超出导致误判率升高；</li>
</ul>
<p>如果不适用 <code>bf.reserve</code>，默认的 <code>error_rate</code> 是 <code>0.01</code>，默认的 <code>initial_size</code> 是 <code>100</code>。</p>
<h1 id="四、布隆过滤器代码实现"><a href="#四、布隆过滤器代码实现" class="headerlink" title="四、布隆过滤器代码实现"></a>四、布隆过滤器代码实现</h1><h2 id="自己简单模拟实现"><a href="#自己简单模拟实现" class="headerlink" title="自己简单模拟实现"></a>自己简单模拟实现</h2><p>根据上面的基础理论，我们很容易就可以自己实现一个用于 <code>简单模拟</code> 的布隆过滤器数据结构：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BloomFilter</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">BloomFilter</span><span class="token punctuation">(</span><span class="token keyword">int</span> initSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>initSize <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认创建大小 * 2 的空间</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> location1 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash1</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location2 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash2</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location3 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash3</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        data<span class="token punctuation">[</span>location1<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>location2<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>location3<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> location1 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash1</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location2 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash2</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location3 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash3</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> data<span class="token punctuation">[</span>location1<span class="token punctuation">]</span> <span class="token operator">*</span> data<span class="token punctuation">[</span>location2<span class="token punctuation">]</span> <span class="token operator">*</span> data<span class="token punctuation">[</span>location3<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash1</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash2</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> hashCode <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hashCode <span class="token operator">^</span> <span class="token punctuation">(</span>hashCode <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash3</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> hashCode <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hashCode <span class="token operator">^</span> <span class="token punctuation">(</span>hashCode <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里很简单，内部仅维护了一个 <code>byte</code> 类型的 <code>data</code> 数组，实际上 <code>byte</code> 仍然占有一个字节之多，可以优化成 <code>bit</code> 来代替，这里也仅仅是用于方便模拟。另外我也创建了三个不同的 <code>hash</code> 函数，其实也就是借鉴 <code>HashMap</code> 哈希抖动的办法，分别使用自身的 <code>hash</code> 和右移不同位数相异或的结果。并且提供了基础的 <code>add</code> 和 <code>contains</code> 方法。</p>
<p>下面我们来简单测试一下这个布隆过滤器的效果如何：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 假设我们的数据有 1 百万</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> 1_000_000<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 用一个数据结构保存一下所有实际存在的值</span>
    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> existentNumbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BloomFilter bloomFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BloomFilter</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> randomKey <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        existentNumbers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>randomKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        bloomFilter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>randomKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 验证已存在的数是否都存在</span>
    AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    AtomicInteger finalCount <span class="token operator">=</span> count<span class="token punctuation">;</span>
    existentNumbers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>number <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            finalCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"实际的数据量： %d, 判断存在的数据量: %d \n"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 验证10个不存在的数</span>
    count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> key <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>existentNumbers<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 这里一定是不存在的数</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>输出如下：</p>
<pre class=" language-bash"><code class="language-bash">实际的数据量： 1000000, 判断存在的数据量: 1000000 
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span></code></pre>
<p>这就是前面说到的，当布隆过滤器说某个值 <strong>存在时</strong>，这个值 <strong>可能不存在</strong>，当它说某个值 <strong>不存在时</strong>，那就 <strong>肯定不存在</strong>，并且还有一定的误判率…</p>
<h2 id="手动实现参考"><a href="#手动实现参考" class="headerlink" title="手动实现参考"></a>手动实现参考</h2><p>当然上面的版本特别 low，不过主体思想是不差的，这里也给出一个好一些的版本用作自己实现测试的参考：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>BitSet<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBloomFilter</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     * 位数组的大小
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_SIZE <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 通过这个数组可以创建 6 个不同的哈希函数
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> SEEDS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">71</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">134</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 位数组。数组中的元素只能是 0 或者 1
     */</span>
    <span class="token keyword">private</span> BitSet bits <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitSet</span><span class="token punctuation">(</span>DEFAULT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 存放包含 hash 函数的类的数组
     */</span>
    <span class="token keyword">private</span> SimpleHash<span class="token punctuation">[</span><span class="token punctuation">]</span> func <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHash</span><span class="token punctuation">[</span>SEEDS<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样
     */</span>
    <span class="token keyword">public</span> <span class="token function">MyBloomFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 初始化多个不同的 Hash 函数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SEEDS<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            func<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHash</span><span class="token punctuation">(</span>DEFAULT_SIZE<span class="token punctuation">,</span> SEEDS<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 添加元素到位数组
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>SimpleHash f <span class="token operator">:</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断指定元素是否存在于位数组
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> ret <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>SimpleHash f <span class="token operator">:</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret <span class="token operator">=</span> ret <span class="token operator">&amp;&amp;</span> bits<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 静态内部类。用于 hash 操作！
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SimpleHash</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> cap<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> seed<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">SimpleHash</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>cap <span class="token operator">=</span> cap<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>seed <span class="token operator">=</span> seed<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/**
         * 计算 hash 值
         */</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> h<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>seed <span class="token operator">*</span> <span class="token punctuation">(</span>cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="使用-Google-开源的-Guava-中自带的布隆过滤器"><a href="#使用-Google-开源的-Guava-中自带的布隆过滤器" class="headerlink" title="使用 Google 开源的 Guava 中自带的布隆过滤器"></a>使用 Google 开源的 Guava 中自带的布隆过滤器</h2><p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>28.0-jre<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建布隆过滤器对象</span>
BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> filter <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>
        Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token number">1500</span><span class="token punctuation">,</span>
        <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 判断指定元素是否存在</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 将元素添加进布隆过滤器</span>
filter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
filter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <code>true</code> 时，我们可以 <strong>99％</strong> 确定该元素在过滤器中，当过滤器返回 <code>false</code> 时，我们可以 <strong>100％</strong> 确定该元素不存在于过滤器中。</p>
<p>Guava 提供的布隆过滤器的实现还是很不错的 <em>（想要详细了解的可以看一下它的源码实现）</em>，但是它有一个重大的缺陷就是只能单机使用 <em>（另外，容量扩展也不容易）</em>，而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 <strong>Redis</strong> 中的布隆过滤器了。</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a>\</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 深度历险》 - 钱文品/ 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - <a href="https://juejin.im/post/5de1e37c5188256e8e43adfc" target="_blank" rel="noopener">https://juejin.im/post/5de1e37c5188256e8e43adfc</a></li>
<li>【原创】不了解布隆过滤器？一文给你整的明明白白！ - <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">
      Reids(4)——神奇的HyperLoglog解决统计问题
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月2日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-a408d790b0b4f4b9.png" alt=""></p>
<h1 id="一、HyperLogLog-简介"><a href="#一、HyperLogLog-简介" class="headerlink" title="一、HyperLogLog 简介"></a>一、HyperLogLog 简介</h1><p><strong>HyperLogLog</strong> 是最早由 <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">Flajolet</a> 及其同事在 2007 年提出的一种 <strong>估算基数的近似最优算法</strong>。但跟原版论文不同的是，好像很多书包括 Redis 作者都把它称为一种 <strong>新的数据结构(new datastruct)</strong> <em>(算法实现确实需要一种特定的数据结构来实现)</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/006oOWahly1fpsc3t7fnng30ab05tkjl.gif" alt=""></p>
<h2 id="关于基数统计"><a href="#关于基数统计" class="headerlink" title="关于基数统计"></a>关于基数统计</h2><p><strong>基数统计(Cardinality Counting)</strong> 通常是用来统计一个集合中不重复的元素个数。</p>
<p><strong>思考这样的一个场景：</strong> 如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站上每个网页的 <strong>UV(独立访客，每个用户每天只记录一次)</strong>，然后让你来开发这个统计模块，你会如何实现？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-a9dbcf6374d482ba.png" alt=""></p>
<p>如果统计 <strong>PV(浏览量，用户没点一次记录一次)</strong>，那非常好办，给每个页面配置一个独立的 Redis 计数器就可以了，把这个计数器的 key 后缀加上当天的日期。这样每来一个请求，就执行 <code>INCRBY</code> 指令一次，最终就可以统计出所有的 <strong>PV</strong> 数据了。</p>
<p>但是 <strong>UV</strong> 不同，它要去重，<strong>同一个用户一天之内的多次访问请求只能计数一次</strong>。这就要求了每一个网页请求都需要带上用户的 ID，无论是登录用户还是未登录的用户，都需要一个唯一 ID 来标识。</p>
<p>你也许马上就想到了一个 <em>简单的解决方案</em>：那就是 <strong>为每一个页面设置一个独立的 set 集合</strong> 来存储所有当天访问过此页面的用户 ID。但这样的 <strong>问题</strong> 就是：</p>
<ol>
<li><strong>存储空间巨大：</strong> 如果网站访问量一大，你需要用来存储的 set 集合就会非常大，如果页面再一多.. 为了一个去重功能耗费的资源就可以直接让你 <strong>老板打死你</strong>；</li>
<li><strong>统计复杂：</strong> 这么多 set 集合如果要聚合统计一下，又是一个复杂的事情；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-b8ddfcd39cb46cb5.png" alt=""></p>
<h2 id="基数统计的常用方法"><a href="#基数统计的常用方法" class="headerlink" title="基数统计的常用方法"></a>基数统计的常用方法</h2><p>对于上述这样需要 <strong>基数统计</strong> 的事情，通常来说有两种比 set 集合更好的解决方案：</p>
<h3 id="第一种：B-树"><a href="#第一种：B-树" class="headerlink" title="第一种：B 树"></a>第一种：B 树</h3><p><strong>B 树最大的优势就是插入和查找效率很高</strong>，如果用 B 树存储要统计的数据，可以快速判断新来的数据是否存在，并快速将元素插入 B 树。要计算基础值，只需要计算 B 树的节点个数就行了。</p>
<p>不过将 B 树结构维护到内存中，能够解决统计和计算的问题，但是 <strong>并没有节省内存</strong>。</p>
<h3 id="第二种：bitmap"><a href="#第二种：bitmap" class="headerlink" title="第二种：bitmap"></a>第二种：bitmap</h3><p><strong>bitmap</strong> 可以理解为通过一个 bit 数组来存储特定数据的一种数据结构，<strong>每一个 bit 位都能独立包含信息</strong>，bit 是数据的最小存储单位，因此能大量节省空间，也可以将整个 bit 数据一次性 load 到内存计算。如果定义一个很大的 bit 数组，基础统计中 <strong>每一个元素对应到 bit 数组中的一位</strong>，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-fb4283ad7dbd89a2.png" alt=""></p>
<p>bitmap 还有一个明显的优势是 <strong>可以轻松合并多个统计结果</strong>，只需要对多个结果求异或就可以了，也可以大大减少存储内存。可以简单做一个计算，如果要统计 <strong>1 亿</strong> 个数据的基数值，<strong>大约需要的内存</strong>：<code>100_000_000/ 8/ 1024/ 1024 ≈ 12 M</code>，如果用 <strong>32 bit</strong> 的 int 代表 <strong>每一个</strong> 统计的数据，<strong>大约需要内存</strong>：<code>32 * 100_000_000/ 8/ 1024/ 1024 ≈ 381 M</code></p>
<p>可以看到 bitmap 对于内存的节省显而易见，但仍然不够。统计一个对象的基数值就需要 <code>12 M</code>，如果统计 1 万个对象，就需要接近 <code>120 G</code>，对于大数据的场景仍然不适用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-1ebb3265b4297fa1.png" alt=""></p>
<h2 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h2><p>实际上目前还没有发现更好的在 <strong>大数据场景</strong> 中 <strong>准确计算</strong> 基数的高效算法，因此在不追求绝对精确的情况下，使用概率算法算是一个不错的解决方案。</p>
<p>概率算法 <strong>不直接存储</strong> 数据集合本身，通过一定的 <strong>概率统计方法预估基数值</strong>，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:</p>
<ul>
<li><strong>Linear Counting(LC)</strong>：早期的基数估计算法，LC 在空间复杂度方面并不算优秀，实际上 LC 的空间复杂度与上文中简单 bitmap 方法是一样的（但是有个常数项级别的降低），都是 O(N<sub>max</sub>)</li>
<li><strong>LogLog Counting(LLC)</strong>：LogLog Counting 相比于 LC 更加节省内存，空间复杂度只有 O(log<sub>2</sub>(log<sub>2</sub>(N<sub>max</sub>)))</li>
<li><strong>HyperLogLog Counting(HLL)</strong>：HyperLogLog Counting 是基于 LLC 的优化和改进，在同样空间复杂度情况下，能够比 LLC 的基数估计误差更小</li>
</ul>
<p>其中，<strong>HyperLogLog</strong> 的表现是惊人的，上面我们简单计算过用 <strong>bitmap</strong> 存储 <strong>1 个亿</strong> 统计数据大概需要 <code>12 M</code> 内存，而在 <strong>HyperLoglog</strong> 中，只需要不到 <strong>1 K</strong> 内存就能够做到！在 Redis 中实现的 <strong>HyperLoglog</strong> 也只需要 <strong>12 K</strong> 内存，在 <strong>标准误差 0.81%</strong> 的前提下，<strong>能够统计 2<sup>64</sup> 个数据</strong>！</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-439fe643e2dc081a.png" alt=""></p>
<p><strong>这是怎么做到的？！</strong> 下面赶紧来了解一下！</p>
<h1 id="二、HyperLogLog-原理"><a href="#二、HyperLogLog-原理" class="headerlink" title="二、HyperLogLog 原理"></a>二、HyperLogLog 原理</h1><p>我们来思考一个抛硬币的游戏：你连续掷 n 次硬币，然后说出其中<strong>连续掷为正面的最大次数，我来猜你一共抛了多少次</strong>。</p>
<p>这很容易理解吧，例如：你说你这一次 <em>最多连续出现了 2 次</em> 正面，那么我就可以知道你这一次投掷的次数并不多，所以 <em>我可能会猜是 5</em> 或者是其他小一些的数字，但如果你说你这一次 <em>最多连续出现了 20 次</em> 正面，虽然我觉得不可能，但我仍然知道你花了特别多的时间，所以 <em>我说 GUN…</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-2042926c4383c027.png" alt=""></p>
<p>这期间我可能会要求你重复实验，然后我得到了更多的数据之后就会估计得更准。<strong>我们来把刚才的游戏换一种说法</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-24e8f48f5e3eb81f.png" alt=""></p>
<p>这张图的意思是，我们给定一系列的随机整数，<strong>记录下低位连续零位的最大长度 K</strong>，即为图中的 <code>maxbit</code>，<strong>通过这个 K 值我们就可以估算出随机数的数量 N</strong>。</p>
<h2 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h2><p>我们可以简单编写代码做一个实验，来探究一下 <code>K</code> 和 <code>N</code> 之间的关系：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PfTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BitKeeper</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> maxbit<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> value <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span>2L <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bit <span class="token operator">=</span> <span class="token function">lowZeros</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bit <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxbit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>maxbit <span class="token operator">=</span> bit<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">lowZeros</span><span class="token punctuation">(</span><span class="token keyword">long</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">>></span> i <span class="token operator">&lt;&lt;</span> i <span class="token operator">!=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Experiment</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>
        <span class="token keyword">private</span> BitKeeper keeper<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Experiment</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>keeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out
                <span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %.2f %d\n"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span> <span class="token operator">/</span> Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span>maxbit<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Experiment exp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Experiment</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            exp<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            exp<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>跟上图中的过程是一致的，话说为啥叫 <code>PfTest</code> 呢，包括 Redis 中的命令也一样带有一个 <code>PF</code> 前缀，还记得嘛，因为 <strong>HyperLogLog</strong> 的提出者上文提到过的，叫 <code>Philippe Flajolet</code>。</p>
<p>截取部分输出查看：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//n   n/log2 maxbit</span>
<span class="token number">34000</span> <span class="token number">15.05</span> <span class="token number">13</span>
<span class="token number">35000</span> <span class="token number">15.10</span> <span class="token number">13</span>
<span class="token number">36000</span> <span class="token number">15.14</span> <span class="token number">16</span>
<span class="token number">37000</span> <span class="token number">15.18</span> <span class="token number">17</span>
<span class="token number">38000</span> <span class="token number">15.21</span> <span class="token number">14</span>
<span class="token number">39000</span> <span class="token number">15.25</span> <span class="token number">16</span>
<span class="token number">40000</span> <span class="token number">15.29</span> <span class="token number">14</span>
<span class="token number">41000</span> <span class="token number">15.32</span> <span class="token number">16</span>
<span class="token number">42000</span> <span class="token number">15.36</span> <span class="token number">18</span></code></pre>
<p>会发现 <code>K</code> 和 <code>N</code> 的对数之间存在显著的线性相关性：<strong>N 约等于 2<sup>k</sup></strong></p>
<h2 id="更近一步：分桶平均"><a href="#更近一步：分桶平均" class="headerlink" title="更近一步：分桶平均"></a>更近一步：分桶平均</h2><p><strong>如果 <code>N</code> 介于 2<sup>k</sup> 和 2<sup>k+1</sup> 之间，用这种方式估计的值都等于 2<sup>k</sup>，这明显是不合理的</strong>，所以我们可以使用多个 <code>BitKeeper</code> 进行加权估计，就可以得到一个比较准确的值了：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PfTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BitKeeper</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 无变化, 代码省略</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Experiment</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>
        <span class="token keyword">private</span> BitKeeper<span class="token punctuation">[</span><span class="token punctuation">]</span> keepers<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Experiment</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">Experiment</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>keepers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitKeeper</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>keepers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> m <span class="token operator">=</span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span>1L <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                BitKeeper keeper <span class="token operator">=</span> keepers<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">&amp;</span> <span class="token number">0xfff0000</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">%</span> keepers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                keeper<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">double</span> sumbitsInverse <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>BitKeeper keeper <span class="token operator">:</span> keepers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                sumbitsInverse <span class="token operator">+=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> keeper<span class="token punctuation">.</span>maxbit<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">double</span> avgBits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> keepers<span class="token punctuation">.</span>length <span class="token operator">/</span> sumbitsInverse<span class="token punctuation">;</span>
            <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> avgBits<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>k<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">100000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Experiment exp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Experiment</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            exp<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">double</span> est <span class="token operator">=</span> exp<span class="token punctuation">.</span><span class="token function">estimate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %.2f %.2f\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> est<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>est <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这个过程有点 <strong>类似于选秀节目里面的打分</strong>，一堆专业评委打分，但是有一些评委因为自己特别喜欢所以给高了，一些评委又打低了，所以一般都要 <strong>屏蔽最高分和最低分</strong>，然后 <strong>再计算平均值</strong>，这样的出来的分数就差不多是公平公正的了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-6c927d25750f20d1.png" alt=""></p>
<p>上述代码就有 <strong>1024</strong> 个 “评委”，并且在计算平均值的时候，采用了 <strong>调和平均数</strong>，也就是倒数的平均值，它能有效地平滑离群值的影响：</p>
<pre class=" language-java"><code class="language-java">avg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">104</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">29</span>
avg <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">104</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5.044</span></code></pre>
<p>观察脚本的输出，误差率百分比控制在个位数：</p>
<pre class=" language-java"><code class="language-java"><span class="token number">100000</span> <span class="token number">94274.94</span> <span class="token number">0.06</span>
<span class="token number">200000</span> <span class="token number">194092.62</span> <span class="token number">0.03</span>
<span class="token number">300000</span> <span class="token number">277329.92</span> <span class="token number">0.08</span>
<span class="token number">400000</span> <span class="token number">373281.66</span> <span class="token number">0.07</span>
<span class="token number">500000</span> <span class="token number">501551.60</span> <span class="token number">0.00</span>
<span class="token number">600000</span> <span class="token number">596078.40</span> <span class="token number">0.01</span>
<span class="token number">700000</span> <span class="token number">687265.72</span> <span class="token number">0.02</span>
<span class="token number">800000</span> <span class="token number">828778.96</span> <span class="token number">0.04</span>
<span class="token number">900000</span> <span class="token number">944683.53</span> <span class="token number">0.05</span></code></pre>
<p>真实的 HyperLogLog 要比上面的示例代码更加复杂一些，也更加精确一些。上面这个算法在随机次数很少的情况下会出现除零错误，因为 <code>maxbit = 0</code> 是不可以求倒数的。</p>
<h2 id="真实的-HyperLogLog"><a href="#真实的-HyperLogLog" class="headerlink" title="真实的 HyperLogLog"></a>真实的 HyperLogLog</h2><p>有一个神奇的网站，可以动态地让你观察到 HyperLogLog 的算法到底是怎么执行的：<a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">http://content.research.neustar.biz/blog/hll.html</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-72f00a9983a1395e.png" alt=""></p>
<p>其中的一些概念这里稍微解释一下，您就可以自行去点击 <code>step</code> 来观察了：</p>
<ul>
<li><strong>m 表示分桶个数：</strong> 从图中可以看到，这里分成了 64 个桶；</li>
<li><strong>蓝色的 bit 表示在桶中的位置：</strong> 例如图中的 <code>101110</code> 实则表示二进制的 <code>46</code>，所以该元素被统计在中间大表格 <code>Register Values</code> 中标红的第 46 个桶之中；</li>
<li><strong>绿色的 bit 表示第一个 1 出现的位置</strong>： 从图中可以看到标绿的 bit 中，从右往左数，第一位就是 1，所以在 <code>Register Values</code> 第 46 个桶中写入 1；</li>
<li><strong>红色 bit 表示绿色 bit 的值的累加：</strong> 下一个出现在第 46 个桶的元素值会被累加；</li>
</ul>
<h3 id="为什么要统计-Hash-值中第一个-1-出现的位置？"><a href="#为什么要统计-Hash-值中第一个-1-出现的位置？" class="headerlink" title="为什么要统计 Hash 值中第一个 1 出现的位置？"></a>为什么要统计 Hash 值中第一个 1 出现的位置？</h3><p>因为第一个 1 出现的位置可以同我们抛硬币的游戏中第一次抛到正面的抛掷次数对应起来，根据上面掷硬币实验的结论，记录每个数据的第一个出现的位置 <code>K</code>，就可以通过其中最大值 K<sub>max</sub> 来推导出数据集合中的基数：<strong>N = 2<sup>K<sub>max</sub></sup></strong></p>
<h3 id="PF-的内存占用为什么是-12-KB？"><a href="#PF-的内存占用为什么是-12-KB？" class="headerlink" title="PF 的内存占用为什么是 12 KB？"></a>PF 的内存占用为什么是 12 KB？</h3><p>我们上面的算法中使用了 <strong>1024</strong> 个桶，网站演示也只有 <strong>64</strong> 个桶，不过在 Redis 的 HyperLogLog 实现中，用的是 <strong>16384</strong> 个桶，即：2<sup>14</sup>，也就是说，就像上面网站中间那个 <code>Register Values</code> 大表格有 <strong>16384</strong> 格。</p>
<p><strong>而Redis 最大能够统计的数据量是 2<sup>64</sup></strong>，即每个桶的 <code>maxbit</code> 需要 <strong>6</strong> 个 bit 来存储，最大可以表示 <code>maxbit = 63</code>，于是总共占用内存就是：<strong>(2<sup>14</sup>) x 6 / 8</strong> <em>(每个桶 6 bit，而这么多桶本身要占用 16384 bit，再除以 8 转换成 KB)</em>,算出来的结果就是 <code>12 KB</code>。</p>
<h1 id="三、Redis-中的-HyperLogLog-实现"><a href="#三、Redis-中的-HyperLogLog-实现" class="headerlink" title="三、Redis 中的 HyperLogLog 实现"></a>三、Redis 中的 HyperLogLog 实现</h1><p>从上面我们算是对 <strong>HyperLogLog</strong> 的算法和思想有了一定的了解，并且知道了一个 <strong>HyperLogLog</strong> 实际占用的空间大约是 <code>12 KB</code>，但 Redis 对于内存的优化非常变态，当 <strong>计数比较小</strong> 的时候，大多数桶的计数值都是 <strong>零</strong>，这个时候 Redis 就会适当节约空间，转换成另外一种 <strong>稀疏存储方式</strong>，与之相对的，正常的存储模式叫做 <strong>密集存储</strong>，这种方式会恒定地占用 <code>12 KB</code>。</p>
<h2 id="密集型存储结构"><a href="#密集型存储结构" class="headerlink" title="密集型存储结构"></a>密集型存储结构</h2><p>密集型的存储结构非常简单，就是 <strong>16384 个 6 bit 连续串成</strong> 的字符串位图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-0ba2adb0214afd0c.png" alt=""></p>
<p>我们都知道，一个字节是由 8 个 bit 组成的，这样 6 bit 排列的结构就会导致，有一些桶会 <strong>跨越字节边界</strong>，我们需要 <strong>对这一个或者两个字节进行适当的移位拼接</strong> 才可以得到具体的计数值。</p>
<p>假设桶的编号为 <code>index</code>，这个 6 bity 计数值的起始字节偏移用 <code>offset_bytes</code> 表示，它在这个字节的其实比特位置偏移用 <code>offset_bits</code> 表示，于是我们有：</p>
<pre class=" language-python"><code class="language-python">offset_bytes <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span>
offset_bits <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span></code></pre>
<p>前者是商，后者是余数。比如 <code>bucket 2</code> 的字节偏移是 1，也就是第 2 个字节。它的位偏移是 4，也就是第 2 个字节的第 5 个位开始是 bucket 2 的计数值。需要注意的是 <strong>字节位序是左边低位右边高位</strong>，而通常我们使用的字节都是左边高位右边低位。</p>
<p>这里就涉及到两种情况，<strong>如果 <code>offset_bits</code> 小于等于 2</strong>，说明这 <strong>6 bit 在一个字节的内部</strong>，可以直接使用下面的表达式得到计数值 <code>val</code>：</p>
<pre class=" language-python"><code class="language-python">val <span class="token operator">=</span> buffer<span class="token punctuation">[</span>offset_bytes<span class="token punctuation">]</span> <span class="token operator">>></span> offset_bits  <span class="token comment" spellcheck="true"># 向右移位</span></code></pre>
<p><strong>如果 <code>offset_bits</code> 大于 2</strong>，那么就会涉及到 <strong>跨越字节边界</strong>，我们需要拼接两个字节的位片段：</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 低位值</span>
low_val <span class="token operator">=</span> buffer<span class="token punctuation">[</span>offset_bytes<span class="token punctuation">]</span> <span class="token operator">>></span> offset_bits
<span class="token comment" spellcheck="true"># 低位个数</span>
low_bits <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">-</span> offset_bits
<span class="token comment" spellcheck="true"># 拼接，保留低6位</span>
val <span class="token operator">=</span> <span class="token punctuation">(</span>high_val <span class="token operator">&lt;&lt;</span> low_bits <span class="token operator">|</span> low_val<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0b111111</span></code></pre>
<p>不过下面 Redis 的源码要晦涩一点，看形式它似乎只考虑了跨越字节边界的情况。这是因为如果 6 bit 在单个字节内，上面代码中的 <code>high_val</code> 的值是零，所以这一份代码可以同时照顾单字节和双字节：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 获取指定桶的计数值</span>
<span class="token macro property">#<span class="token directive keyword">define</span> HLL_DENSE_GET_REGISTER(target,p,regnum) do { \
    uint8_t *_p = (uint8_t*) p; \
    unsigned long _byte = regnum*HLL_BITS/8; \ </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _fb <span class="token operator">=</span> regnum<span class="token operator">*</span>HLL_BITS<span class="token operator">&amp;</span><span class="token number">7</span><span class="token punctuation">;</span> \  # <span class="token operator">%</span><span class="token number">8</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">7</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _fb8 <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">-</span> _fb<span class="token punctuation">;</span> \
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> b0 <span class="token operator">=</span> _p<span class="token punctuation">[</span>_byte<span class="token punctuation">]</span><span class="token punctuation">;</span> \
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> b1 <span class="token operator">=</span> _p<span class="token punctuation">[</span>_byte<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> \
    target <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b0 <span class="token operator">>></span> _fb<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>b1 <span class="token operator">&lt;&lt;</span> _fb8<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> HLL_REGISTER_MAX<span class="token punctuation">;</span> \
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 设置指定桶的计数值</span>
<span class="token macro property">#<span class="token directive keyword">define</span> HLL_DENSE_SET_REGISTER(p,regnum,val) do { \
    uint8_t *_p = (uint8_t*) p; \
    unsigned long _byte = regnum*HLL_BITS/8; \
    unsigned long _fb = regnum*HLL_BITS&amp;7; \
    unsigned long _fb8 = 8 - _fb; \
    unsigned long _v = val; \
    _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); \
    _p[_byte] |= _v &lt;&lt; _fb; \
    _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX >> _fb8); \
    _p[_byte+1] |= _v >> _fb8; \
} while(0)</span></code></pre>
<h2 id="稀疏存储结构"><a href="#稀疏存储结构" class="headerlink" title="稀疏存储结构"></a>稀疏存储结构</h2><p>稀疏存储适用于很多计数值都是零的情况。下图表示了一般稀疏存储计数值的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-9d5a9018d2eedbd8.png" alt=""></p>
<p>当 <strong>多个连续桶的计数值都是零</strong> 时，Redis 提供了几种不同的表达形式：</p>
<ul>
<li><code>00xxxxxx</code>：前缀两个零表示接下来的 6bit 整数值加 1 就是零值计数器的数量，注意这里要加 1 是因为数量如果为零是没有意义的。比如 <code>00010101</code> 表示连续 <code>22</code> 个零值计数器。</li>
<li><code>01xxxxxx yyyyyyyy</code>：6bit 最多只能表示连续 <code>64</code> 个零值计数器，这样扩展出的  14bit 可以表示最多连续 <code>16384</code> 个零值计数器。这意味着 HyperLogLog 数据结构中 <code>16384</code> 个桶的初始状态，所有的计数器都是零值，可以直接使用 2 个字节来表示。</li>
<li><code>1vvvvvxx</code>：中间 5bit 表示计数值，尾部 2bit 表示连续几个桶。它的意思是连续 <code>(xx +1)</code> 个计数值都是 <code>(vvvvv + 1)</code>。比如 <code>10101011</code> 表示连续 <code>4</code> 个计数值都是 <code>11</code>。</li>
</ul>
<p>注意 <em>上面第三种方式</em> 的计数值最大只能表示到 <code>32</code>，而 HyperLogLog 的密集存储单个计数值用 6bit 表示，最大可以表示到 <code>63</code>。<strong>当稀疏存储的某个计数值需要调整到大于 <code>32</code> 时，Redis 就会立即转换 HyperLogLog 的存储结构，将稀疏存储转换成密集存储。</strong></p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HyperLogLog 除了需要存储 16384 个桶的计数值之外，它还有一些附加的字段需要存储，比如总计数缓存、存储类型。所以它使用了一个额外的对象头来表示：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> hllhdr <span class="token punctuation">{</span>
    <span class="token keyword">char</span> magic<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* 魔术字符串"HYLL" */</span>
    uint8_t encoding<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 存储类型 HLL_DENSE or HLL_SPARSE. */</span>
    uint8_t notused<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 保留三个字节未来可能会使用 */</span>
    uint8_t card<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 总计数缓存 */</span>
    uint8_t registers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 所有桶的计数器 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>所以 <strong>HyperLogLog</strong> 整体的内部结构就是 <strong>HLL 对象头</strong> 加上 <strong>16384</strong> 个桶的计数值位图。它在 Redis 的内部结构表现就是一个字符串位图。你可以把 <strong>HyperLogLog 对象当成普通的字符串来进行处理：</strong></p>
<pre class=" language-console"><code class="language-console">> PFADD codehole python java golang
(integer) 1
> GET codehole
"HYLL\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80C\x03\x84MK\x80P\xb8\x80^\xf3"</code></pre>
<p>但是 <strong>不可以</strong> 使用 <strong>HyperLogLog</strong> 指令来 <strong>操纵普通的字符串</strong>，<strong>因为它需要检查对象头魔术字符串是否是 “HYLL”</strong>。</p>
<h1 id="四、HyperLogLog-的使用"><a href="#四、HyperLogLog-的使用" class="headerlink" title="四、HyperLogLog 的使用"></a>四、HyperLogLog 的使用</h1><p><strong>HyperLogLog</strong> 提供了两个指令 <code>PFADD</code> 和 <code>PFCOUNT</code>，字面意思就是一个是增加，另一个是获取计数。<code>PFADD</code> 和 <code>set</code> 集合的 <code>SADD</code> 的用法是一样的，来一个用户 ID，就将用户 ID 塞进去就是，<code>PFCOUNT</code> 和 <code>SCARD</code> 的用法是一致的，直接获取计数值：</p>
<pre class=" language-console"><code class="language-console">> PFADD codehole user1
(interger) 1
> PFCOUNT codehole
(integer) 1
> PFADD codehole user2
(integer) 1
> PFCOUNT codehole
(integer) 2
> PFADD codehole user3
(integer) 1
> PFCOUNT codehole
(integer) 3
> PFADD codehole user4 user 5
(integer) 1
> PFCOUNT codehole
(integer) 5</code></pre>
<p>我们可以用 Java 编写一个脚本来试试 HyperLogLog 的准确性到底有多少：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisTest</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      jedis<span class="token punctuation">.</span><span class="token function">pfadd</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">,</span> <span class="token string">"user"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> total <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pfcount</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
    jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>结果输出如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token number">100000</span> <span class="token number">99723</span></code></pre>
<p>发现 <code>10</code> 万条数据只差了 <code>277</code>，按照百分比误差率是 <code>0.277%</code>，对于巨量的 UV 需求来说，这个误差率真的不算高。</p>
<p>当然，除了上面的 <code>PFADD</code> 和 <code>PFCOUNT</code> 之外，还提供了第三个 <code>PFMEGER</code> 指令，用于将多个计数值累加在一起形成一个新的 <code>pf</code> 值：</p>
<pre class=" language-console"><code class="language-console">> PFADD  nosql  "Redis"  "MongoDB"  "Memcached"
(integer) 1

> PFADD  RDBMS  "MySQL" "MSSQL" "PostgreSQL"
(integer) 1

> PFMERGE  databases  nosql  RDBMS
OK

> PFCOUNT  databases
(integer) 6</code></pre>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
</ol>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li>【算法原文】HyperLogLog: the analysis of a near-optimal<br>cardinality estimation algorithm - <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf" target="_blank" rel="noopener">http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>【Redis 作者博客】Redis new data structure: the HyperLogLog - <a href="http://antirez.com/news/75" target="_blank" rel="noopener">http://antirez.com/news/75</a></li>
<li>神奇的HyperLogLog算法 - <a href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html" target="_blank" rel="noopener">http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html</a></li>
<li>深度探索 Redis HyperLogLog 内部数据结构 - <a href="https://zhuanlan.zhihu.com/p/43426875" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43426875</a></li>
<li>《Redis 深度历险》 - 钱文品/ 著</li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Reids%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E7%A5%9E%E5%A5%87%E7%9A%84HyperLoglog%E8%A7%A3%E5%86%B3%E7%BB%9F%E8%AE%A1%E9%97%AE%E9%A2%98/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/01/redis-3/">
      Redis(3)——分布式锁深入探究
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb进阶/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月1日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/7896890-5fe2adf61ccf11aa.png" alt=""></p>
<h1 id="一、分布式锁简介"><a href="#一、分布式锁简介" class="headerlink" title="一、分布式锁简介"></a>一、分布式锁简介</h1><p><strong>锁</strong> 是一种用来解决多个执行线程 <strong>访问共享资源</strong> 错误或数据不一致问题的工具。</p>
<p>如果 <em>把一台服务器比作一个房子</em>，那么 <em>线程就好比里面的住户</em>，当他们想要共同访问一个共享资源，例如厕所的时候，如果厕所门上没有锁…更甚者厕所没装门…这是会出原则性的问题的..</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/7896890-26a364bddb9218eb.png" alt=""></p>
<p>装上了锁，大家用起来就安心多了，本质也就是 <strong>同一时间只允许一个住户使用</strong>。</p>
<p>而随着互联网世界的发展，单体应用已经越来越无法满足复杂互联网的高并发需求，转而慢慢朝着分布式方向发展，慢慢进化成了 <strong>更大一些的住户</strong>。所以同样，我们需要引入分布式锁来解决分布式应用之间访问共享资源的并发问题。</p>
<h2 id="为何需要分布式锁"><a href="#为何需要分布式锁" class="headerlink" title="为何需要分布式锁"></a>为何需要分布式锁</h2><p>一般情况下，我们使用分布式锁主要有两个场景：</p>
<ol>
<li><strong>避免不同节点重复相同的工作</strong>：比如用户执行了某个操作有可能不同节点会发送多封邮件；</li>
<li><strong>避免破坏数据的正确性</strong>：如果两个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现；</li>
</ol>
<h2 id="Java-中实现的常见方式"><a href="#Java-中实现的常见方式" class="headerlink" title="Java 中实现的常见方式"></a>Java 中实现的常见方式</h2><p>上面我们用简单的比喻说明了锁的本质：<strong>同一时间只允许一个用户操作</strong>。所以理论上，能够满足这个需求的工具我们都能够使用 <em>(就是其他应用能帮我们加锁的)</em>：</p>
<ol>
<li><strong>基于 MySQL 中的锁</strong>：MySQL 本身有自带的悲观锁 <code>for update</code> 关键字，也可以自己实现悲观/乐观锁来达到目的；</li>
<li><strong>基于 Zookeeper 有序节点</strong>：Zookeeper 允许临时创建有序的子节点，这样客户端获取节点列表时，就能够当前子节点列表中的序号判断是否能够获得锁；</li>
<li><strong>基于 Redis 的单线程</strong>：由于 Redis 是单线程，所以命令会以串行的方式执行，并且本身提供了像 <code>SETNX(set if not exists)</code> 这样的指令，本身具有互斥性；</li>
</ol>
<p>每个方案都有各自的优缺点，例如 MySQL 虽然直观理解容易，但是实现起来却需要额外考虑 <strong>锁超时</strong>、<strong>加事务</strong> 等，并且性能局限于数据库，诸如此类我们在此不作讨论，重点关注 Redis。</p>
<h2 id="Redis-分布式锁的问题"><a href="#Redis-分布式锁的问题" class="headerlink" title="Redis 分布式锁的问题"></a>Redis 分布式锁的问题</h2><h3 id="1）锁超时"><a href="#1）锁超时" class="headerlink" title="1）锁超时"></a>1）锁超时</h3><p>假设现在我们有两台平行的服务 A B，其中 A 服务在 <strong>获取锁之后</strong> 由于未知神秘力量突然 <strong>挂了</strong>，那么 B 服务就永远无法获取到锁了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/7896890-4ea386c23ef0eec9.png" alt=""></p>
<p>所以我们需要额外设置一个超时时间，来保证服务的可用性。</p>
<p>但是另一个问题随即而来：<strong>如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制</strong>，也会出现问题。因为这时候第一个线程持有锁过期了，而临界区的逻辑还没有执行完，与此同时第二个线程就提前拥有了这把锁，导致临界区的代码不能得到严格的串行执行。</p>
<p>为了避免这个问题，<strong>Redis 分布式锁不要用于较长时间的任务</strong>。如果真的偶尔出现了问题，造成的数据小错乱可能就需要人工的干预。</p>
<p>有一个稍微安全一点的方案是 <strong>将锁的 <code>value</code> 值设置为一个随机数</strong>，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 <strong>确保当前线程占有的锁不会被其他线程释放</strong>，除非这个锁是因为过期了而被服务器自动释放的。</p>
<p>但是匹配 <code>value</code> 和删除 <code>key</code> 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 <strong>保证多个指令的原子性执行</strong>。</p>
<h3 id="延伸的讨论：GC-可能引发的安全问题"><a href="#延伸的讨论：GC-可能引发的安全问题" class="headerlink" title="延伸的讨论：GC 可能引发的安全问题"></a>延伸的讨论：GC 可能引发的安全问题</h3><p><a href="https://martin.kleppmann.com/" target="_blank" rel="noopener">Martin Kleppmann</a> 曾与 Redis 之父 Antirez 就 Redis 实现分布式锁的安全性问题进行过深入的讨论，其中有一个问题就涉及到 <strong>GC</strong>。</p>
<p>熟悉 Java 的同学肯定对 GC 不陌生，在 GC 的时候会发生 <strong>STW(Stop-The-World)</strong>，这本身是为了保障垃圾回收器的正常执行，但可能会引发如下的问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/7896890-cf3a403968a23be4.png" alt=""></p>
<p>服务 A 获取了锁并设置了超时时间，但是服务 A 出现了 STW 且时间较长，导致了分布式锁进行了超时释放，在这个期间服务 B 获取到了锁，待服务 A STW 结束之后又恢复了锁，这就导致了 <strong>服务 A 和服务 B 同时获取到了锁</strong>，这个时候分布式锁就不安全了。</p>
<p>不仅仅局限于 Redis，Zookeeper 和 MySQL 有同样的问题。</p>
<p>想吃更多瓜的童鞋，可以访问下列网站看看 Redis 之父 Antirez 怎么说：<a href="http://antirez.com/news/101" target="_blank" rel="noopener">http://antirez.com/news/101</a></p>
<h3 id="2）单点-多点问题"><a href="#2）单点-多点问题" class="headerlink" title="2）单点/多点问题"></a>2）单点/多点问题</h3><p>如果 Redis 采用单机部署模式，那就意味着当 Redis 故障了，就会导致整个服务不可用。</p>
<p>而如果采用主从模式部署，我们想象一个这样的场景：<em>服务 A</em> 申请到一把锁之后，如果作为主机的 Redis 宕机了，那么 <em>服务 B</em> 在申请锁的时候就会从从机那里获取到这把锁，为了解决这个问题，Redis 作者提出了一种 <strong>RedLock 红锁</strong> 的算法 <em>(Redission 同 Jedis)</em>：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 三个 Redis 集群</span>
RLock lock1 <span class="token operator">=</span> redissionInstance1<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
RLock lock2 <span class="token operator">=</span> redissionInstance2<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
RLock lock3 <span class="token operator">=</span> redissionInstance3<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

RedissionRedLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedissionLock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// do something....</span>
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="二、Redis-分布式锁的实现"><a href="#二、Redis-分布式锁的实现" class="headerlink" title="二、Redis 分布式锁的实现"></a>二、Redis 分布式锁的实现</h1><p>分布式锁类似于 “占坑”，而 <code>SETNX(SET if Not eXists)</code> 指令就是这样的一个操作，只允许被一个客户端占有，我们来看看 <strong>源码(t_string.c/setGenericCommand)</strong> 吧：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// SET/ SETEX/ SETTEX/ SETNX 最底层实现</span>
<span class="token keyword">void</span> <span class="token function">setGenericCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> robj <span class="token operator">*</span>val<span class="token punctuation">,</span> robj <span class="token operator">*</span>expire<span class="token punctuation">,</span> <span class="token keyword">int</span> unit<span class="token punctuation">,</span> robj <span class="token operator">*</span>ok_reply<span class="token punctuation">,</span> robj <span class="token operator">*</span>abort_reply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* initialized to avoid any harmness warning */</span>

    <span class="token comment" spellcheck="true">// 如果定义了 key 的过期时间则保存到上面定义的变量中</span>
    <span class="token comment" spellcheck="true">// 如果过期时间设置错误则返回错误信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>expire<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getLongLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> expire<span class="token punctuation">,</span> <span class="token operator">&amp;</span>milliseconds<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>milliseconds <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">addReplyErrorFormat</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token string">"invalid expire time in %s"</span><span class="token punctuation">,</span>c<span class="token operator">-></span>cmd<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>unit <span class="token operator">==</span> UNIT_SECONDS<span class="token punctuation">)</span> milliseconds <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// lookupKeyWrite 函数是为执行写操作而取出 key 的值对象</span>
    <span class="token comment" spellcheck="true">// 这里的判断条件是：</span>
    <span class="token comment" spellcheck="true">// 1.如果设置了 NX(不存在)，并且在数据库中找到了 key 值</span>
    <span class="token comment" spellcheck="true">// 2.或者设置了 XX(存在)，并且在数据库中没有找到该 key</span>
    <span class="token comment" spellcheck="true">// => 那么回复 abort_reply 给客户端</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> OBJ_SET_NX <span class="token operator">&amp;&amp;</span> <span class="token function">lookupKeyWrite</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> OBJ_SET_XX <span class="token operator">&amp;&amp;</span> <span class="token function">lookupKeyWrite</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> abort_reply <span class="token operator">?</span> abort_reply <span class="token punctuation">:</span> shared<span class="token punctuation">.</span>null<span class="token punctuation">[</span>c<span class="token operator">-></span>resp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 在当前的数据库中设置键为 key 值为 value 的数据</span>
    <span class="token function">genericSetKey</span><span class="token punctuation">(</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span>val<span class="token punctuation">,</span>flags <span class="token operator">&amp;</span> OBJ_SET_KEEPTTL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 服务器每修改一个 key 后都会修改 dirty 值</span>
    server<span class="token punctuation">.</span>dirty<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>expire<span class="token punctuation">)</span> <span class="token function">setExpire</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-></span>db<span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>milliseconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_STRING<span class="token punctuation">,</span><span class="token string">"set"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>c<span class="token operator">-></span>db<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>expire<span class="token punctuation">)</span> <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_GENERIC<span class="token punctuation">,</span>
        <span class="token string">"expire"</span><span class="token punctuation">,</span>key<span class="token punctuation">,</span>c<span class="token operator">-></span>db<span class="token operator">-></span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> ok_reply <span class="token operator">?</span> ok_reply <span class="token punctuation">:</span> shared<span class="token punctuation">.</span>ok<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>就像上面介绍的那样，其实在之前版本的 Redis 中，由于 <code>SETNX</code> 和 <code>EXPIRE</code> 并不是 <strong>原子指令</strong>，所以在一起执行会出现问题。</p>
<p>也许你会想到使用 Redis 事务来解决，但在这里不行，因为 <code>EXPIRE</code> 命令依赖于 <code>SETNX</code> 的执行结果，而事务中没有 <code>if-else</code> 的分支逻辑，如果 <code>SETNX</code> 没有抢到锁，<code>EXPIRE</code> 就不应该执行。</p>
<p>为了解决这个疑难问题，Redis 开源社区涌现了许多分布式锁的 library，为了治理这个乱象，后来在 Redis 2.8 的版本中，加入了 <code>SET</code> 指令的扩展参数，使得 <code>SETNX</code> 可以和 <code>EXPIRE</code> 指令一起执行了：</p>
<pre class=" language-console"><code class="language-console">> SET lock:test true ex 5 nx
OK
... do something critical ...
> del lock:test</code></pre>
<p>你只需要符合 <code>SET key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL]</code> 这样的格式就好了，你也在下方右拐参照官方的文档：</p>
<ul>
<li>官方文档：<a href="https://redis.io/commands/set" target="_blank" rel="noopener">https://redis.io/commands/set</a></li>
</ul>
<p>另外，官方文档也在 <a href="https://redis.io/commands/setnx" target="_blank" rel="noopener"><code>SETNX</code> 文档</a>中提到了这样一种思路：<strong>把 SETNX 对应 key 的 value 设置为 &lt;current Unix time + lock timeout + 1&gt;</strong>，这样在其他客户端访问时就能够自己判断是否能够获取下一个 value 为上述格式的锁了。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面用 Jedis 来模拟实现以下，关键代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String LOCK_SUCCESS <span class="token operator">=</span> <span class="token string">"OK"</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Long RELEASE_SUCCESS <span class="token operator">=</span> 1L<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String SET_IF_NOT_EXIST <span class="token operator">=</span> <span class="token string">"NX"</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String SET_WITH_EXPIRE_TIME <span class="token operator">=</span> <span class="token string">"PX"</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> String <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获取锁的超时时间，超过这个时间则放弃获取锁</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquireTimeout<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 随机生成一个 value</span>
        String requireToken <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String result <span class="token operator">=</span> jedis
                <span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requireToken<span class="token punctuation">,</span> SET_IF_NOT_EXIST<span class="token punctuation">,</span> SET_WITH_EXPIRE_TIME<span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>LOCK_SUCCESS<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> requireToken<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"acquire lock due to error"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span>String identify<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>identify <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    String script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>
    Object result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>script<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">,</span>
            Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>identify<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>RELEASE_SUCCESS<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"release lock success, requestToken:{}"</span><span class="token punctuation">,</span> identify<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"release lock due to error"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"release lock failed, requestToken:{}, result:{}"</span><span class="token punctuation">,</span> identify<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>引用自下方 <em>参考资料 3</em>，其中还有 RedLock 的实现和测试，有兴趣的童鞋可以戳一下</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ol>
<li>【官方文档】Distributed locks with Redis - <a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></li>
<li>Redis【入门】就这一篇! - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/</a></li>
<li>Redission - Redis Java Client 源码 - <a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">https://github.com/redisson/redisson</a></li>
<li>手写一个 Jedis 以及 JedisPool - <a href="https://juejin.im/post/5e5101c46fb9a07cab3a953a" target="_blank" rel="noopener">https://juejin.im/post/5e5101c46fb9a07cab3a953a</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>再有人问你分布式锁，这篇文章扔给他 - <a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5bbb0d8df265da0abd3533a5#heading-0</a></li>
<li>【官方文档】Distributed locks with Redis - <a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></li>
<li>【分布式缓存系列】Redis实现分布式锁的正确姿势 - <a href="https://www.cnblogs.com/zhili/p/redisdistributelock.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/redisdistributelock.html</a></li>
<li>Redis源码剖析和注释（九）— 字符串命令的实现(t_string) - <a href="https://blog.csdn.net/men_wen/article/details/70325566" target="_blank" rel="noopener">https://blog.csdn.net/men_wen/article/details/70325566</a></li>
<li>《Redis 深度历险》 - 钱文品/ 著</li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/02/29/redis-2-tiao-yue-biao/">
      Redis(2)——跳跃表
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb进阶/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年2月29日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-97a4ce9191464f62.png" alt=""></p>
<h1 id="一、跳跃表简介"><a href="#一、跳跃表简介" class="headerlink" title="一、跳跃表简介"></a>一、跳跃表简介</h1><p>跳跃表（skiplist）是一种随机化的数据结构，由 <strong>William Pugh</strong> 在论文<a href="https://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf" target="_blank" rel="noopener">《Skip lists: a probabilistic alternative to balanced trees》</a>中提出，是一种可以于平衡树媲美的层次化链表结构——查找、删除、添加等操作都可以在对数期望时间下完成，以下是一个典型的跳跃表例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-65a5b1a2849fb91c.png" alt=""></p>
<p>我们在上一篇中提到了 Redis 的五种基本结构中，有一个叫做 <strong>有序列表 zset</strong> 的数据结构，它类似于 Java 中的 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set 保证了内部 value 的唯一性，另一方面又可以给每个 value 赋予一个排序的权重值 score，来达到 <strong>排序</strong> 的目的。</p>
<p>它的内部实现就依赖了一种叫做 <strong>「跳跃列表」</strong> 的数据结构。</p>
<h2 id="为什么使用跳跃表"><a href="#为什么使用跳跃表" class="headerlink" title="为什么使用跳跃表"></a>为什么使用跳跃表</h2><p>首先，因为 zset 要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树/ 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p>
<ol>
<li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 _(下面详细说)_；</li>
<li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li>
</ol>
<p>基于以上的一些考虑，Redis 基于 <strong>William Pugh</strong> 的论文做出一些改进后采用了 <strong>跳跃表</strong> 这样的结构。</p>
<h2 id="本质是解决查找问题"><a href="#本质是解决查找问题" class="headerlink" title="本质是解决查找问题"></a>本质是解决查找问题</h2><p>我们先来看一个普通的链表结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-11b7eebde1779904.png" alt=""></p>
<p>我们需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，通常我们会使用 <strong>二分查找法</strong>，但二分查找是有序数组的，链表没办法进行位置定位，我们除了遍历整个找到第一个比给定数据大的节点为止 <em>（时间复杂度 O(n))</em> 似乎没有更好的办法。</p>
<p>但假如我们每相邻两个节点之间就增加一个指针，让指针指向下一个节点，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-8cae2c261c950b32.png" alt=""></p>
<p>这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半 _（图中的为 3，11）_。</p>
<p>现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，比如，我们想要查找 7，查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-9c0262c7a85c120e.png" alt=""></p>
<p>这是一个略微极端的例子，但我们仍然可以看到，通过新增加的指针查找，我们不再需要与链表上的每一个节点逐一进行比较，这样改进之后需要比较的节点数大概只有原来的一半。</p>
<p>利用同样的方式，我们可以在新产生的链表上，继续为每两个相邻的节点增加一个指针，从而产生第三层链表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-22036e274bedaa5a.png" alt=""></p>
<p>在这个新的三层链表结构中，我们试着 <strong>查找 13</strong>，那么沿着最上层链表首先比较的是 11，发现 11 比 13 小，于是我们就知道只需要到 11 后面继续查找，<strong>从而一下子跳过了 11 前面的所有节点。</strong></p>
<p>可以想象，当链表足够长，这样的多层链表结构可以帮助我们跳过很多下层节点，从而加快查找的效率。</p>
<h2 id="更进一步的跳跃表"><a href="#更进一步的跳跃表" class="headerlink" title="更进一步的跳跃表"></a>更进一步的跳跃表</h2><p><strong>跳跃表 skiplist</strong> 就是受到这种多层链表结构的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 _O(logn)_。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的 2:1 的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点 <em>（也包括新插入的节点）</em> 重新进行调整，这会让时间复杂度重新蜕化成 _O(n)_。删除数据也有同样的问题。</p>
<p><strong>skiplist</strong> 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是 <strong>为每个节点随机出一个层数(level)</strong>。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个 skiplist 的过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-1e0626c013de095e.png" alt=""></p>
<p>从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，<strong>插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整</strong>，这就降低了插入操作的复杂度。</p>
<p>现在我们假设从我们刚才创建的这个结构中查找 23 这个不存在的数，那么查找路径会如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-a8f66d808e8a4d1e.png" alt=""></p>
<h1 id="二、跳跃表的实现"><a href="#二、跳跃表的实现" class="headerlink" title="二、跳跃表的实现"></a>二、跳跃表的实现</h1><p>Redis 中的跳跃表由 <code>server.h/zskiplistNode</code> 和 <code>server.h/zskiplist</code> 两个结构定义，前者为跳跃表节点，后者则保存了跳跃节点的相关信息，同之前的 <code>集合 list</code> 结构类似，其实只有 <code>zskiplistNode</code> 就可以实现了，但是引入后者是为了更加方便的操作：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* ZSETs use a specialized version of Skiplists */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// value</span>
    sds ele<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 分值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 后退指针</span>
    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 层</span>
    <span class="token keyword">struct</span> zskiplistLevel <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 前进指针</span>
        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 跨度</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplist <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 跳跃表头指针</span>
    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 表中节点的数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 表中层数最大的节点的层数</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span></code></pre>
<p>正如文章开头画出来的那张标准的跳跃表那样。</p>
<h2 id="随机层数"><a href="#随机层数" class="headerlink" title="随机层数"></a>随机层数</h2><p>对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数，源码在 <code>t_zset.c/zslRandomLevel(void)</code> 中被定义：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>ZSKIPLIST_P <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        level <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>level<span class="token operator">&lt;</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token punctuation">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>直观上期望的目标是 50% 的概率被分配到 <code>Level 1</code>，25% 的概率被分配到 <code>Level 2</code>，12.5% 的概率被分配到 <code>Level 3</code>，以此类推…有 2<sup>-63</sup> 的概率被分配到最顶层，因为这里每一层的晋升率都是 50%。</p>
<p><strong>Redis 跳跃表默认允许最大的层数是 32</strong>，被源码中 <code>ZSKIPLIST_MAXLEVEL</code> 定义，当 <code>Level[0]</code> 有 2<sup>64</sup> 个元素时，才能达到 32 层，所以定义 32 完全够用了。</p>
<h2 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h2><p>这个过程比较简单，在源码中的 <code>t_zset.c/zslCreate</code> 中被定义：</p>
<pre class=" language-c"><code class="language-c">zskiplist <span class="token operator">*</span><span class="token function">zslCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 申请内存空间</span>
    zsl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zsl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化层数为 1</span>
    zsl<span class="token operator">-></span>level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化长度为 0</span>
    zsl<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 创建一个层数为 32，分数为 0，没有 value 值的跳跃表头节点</span>
    zsl<span class="token operator">-></span>header <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 跳跃表头节点初始化</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将跳跃表头节点的所有前进指针 forward 设置为 NULL</span>
        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将跳跃表头节点的所有跨度 span 设置为 0</span>
        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 跳跃表头节点的后退指针 backward 置为 NULL</span>
    zsl<span class="token operator">-></span>header<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 表头指向跳跃表尾节点的指针置为 NULL</span>
    zsl<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>即执行完之后创建了如下结构的初始化跳跃表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-551660604afd1041.png" alt=""></p>
<h2 id="插入节点实现"><a href="#插入节点实现" class="headerlink" title="插入节点实现"></a>插入节点实现</h2><p>这几乎是最重要的一段代码了，但总体思路也比较清晰简单，如果理解了上面所说的跳跃表的原理，那么很容易理清楚插入节点时发生的几个动作 <em>（几乎跟链表类似）</em>：</p>
<ol>
<li>找到当前我需要插入的位置 <em>（其中包括相同 score 时的处理）</em>；</li>
<li>创建新节点，调整前后的指针指向，完成插入；</li>
</ol>
<p>为了方便阅读，我把源码 <code>t_zset.c/zslInsert</code> 定义的插入函数拆成了几个部分</p>
<h3 id="第一部分：声明需要存储的变量"><a href="#第一部分：声明需要存储的变量" class="headerlink" title="第一部分：声明需要存储的变量"></a>第一部分：声明需要存储的变量</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 存储搜索路径</span>
zskiplistNode <span class="token operator">*</span>update<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 存储经过的节点跨度</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> rank<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token punctuation">,</span> level<span class="token punctuation">;</span></code></pre>
<h3 id="第二部分：搜索当前节点插入位置"><a href="#第二部分：搜索当前节点插入位置" class="headerlink" title="第二部分：搜索当前节点插入位置"></a>第二部分：搜索当前节点插入位置</h3><pre class=" language-c"><code class="language-c"><span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isnan</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 逐步降级寻找目标节点，得到 "搜索路径"</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* store rank that is crossed to reach the insert position */</span>
    rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token punctuation">(</span>zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> rank<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果 score 相等，还需要比较 value 值</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>
                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>
                <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>
        x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 记录 "搜索路径"</span>
    update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>讨论：</strong> 有一种极端的情况，就是跳跃表中的所有 score 值都是一样，zset 的查找性能会不会退化为 O(n) 呢？</p>
<p>从上面的源码中我们可以发现 zset 的排序元素不只是看 score 值，也会比较 value 值 <em>（字符串比较）</em></p>
<h3 id="第三部分：生成插入节点"><a href="#第三部分：生成插入节点" class="headerlink" title="第三部分：生成插入节点"></a>第三部分：生成插入节点</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* we assume the element is not already inside, since we allow duplicated
 * scores, reinserting the same element should never happen since the
 * caller of zslInsert() should test in the hash table if the element is
 * already inside or not. */</span>
level <span class="token operator">=</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 如果随机生成的 level 超过了当前最大 level 需要更新跳跃表的信息</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> zsl<span class="token operator">-></span>level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>
        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> zsl<span class="token operator">-></span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    zsl<span class="token operator">-></span>level <span class="token operator">=</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 创建新节点</span>
x <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span>score<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="第四部分：重排前向指针"><a href="#第四部分：重排前向指针" class="headerlink" title="第四部分：重排前向指针"></a>第四部分：重排前向指针</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
    update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> x<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* update span covered by update[i] as x is inserted here */</span>
    x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* increment span for untouched levels */</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="第五部分：重排后向指针并返回"><a href="#第五部分：重排后向指针并返回" class="headerlink" title="第五部分：重排后向指针并返回"></a>第五部分：重排后向指针并返回</h3><pre class=" language-c"><code class="language-c">x<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> zsl<span class="token operator">-></span>header<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">NULL</span> <span class="token punctuation">:</span> update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">)</span>
    x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>backward <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token keyword">else</span>
    zsl<span class="token operator">-></span>tail <span class="token operator">=</span> x<span class="token punctuation">;</span>
zsl<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> x<span class="token punctuation">;</span></code></pre>
<h2 id="节点删除实现"><a href="#节点删除实现" class="headerlink" title="节点删除实现"></a>节点删除实现</h2><p>删除过程由源码中的 <code>t_zset.c/zslDeleteNode</code> 定义，和插入过程类似，都需要先把这个 <strong>“搜索路径”</strong> 找出来，然后对于每个层的相关节点重排一下前向后向指针，同时还要注意更新一下最高层数 <code>maxLevel</code>，直接放源码 <em>(如果理解了插入这里还是很容易理解的)</em>：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span>
<span class="token keyword">void</span> <span class="token function">zslDeleteNode</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">,</span> zskiplistNode <span class="token operator">*</span><span class="token operator">*</span>update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>backward <span class="token operator">=</span> x<span class="token operator">-></span>backward<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        zsl<span class="token operator">-></span>tail <span class="token operator">=</span> x<span class="token operator">-></span>backward<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>zsl<span class="token operator">-></span>level <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        zsl<span class="token operator">-></span>level<span class="token operator">--</span><span class="token punctuation">;</span>
    zsl<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* Delete an element with matching score/element from the skiplist.
 * The function returns 1 if the node was found and deleted, otherwise
 * 0 is returned.
 *
 * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise
 * it is not freed (but just unlinked) and *node is set to the node pointer,
 * so that it is possible for the caller to reuse the node (including the
 * referenced SDS string at node->ele). */</span>
<span class="token keyword">int</span> <span class="token function">zslDelete</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">,</span> zskiplistNode <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    zskiplistNode <span class="token operator">*</span>update<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>
                    <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>
                     <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. */</span>
    x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> score <span class="token operator">==</span> x<span class="token operator">-></span>score <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">zslDeleteNode</span><span class="token punctuation">(</span>zsl<span class="token punctuation">,</span> x<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>
            <span class="token function">zslFreeNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token operator">*</span>node <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* not found */</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="节点更新实现"><a href="#节点更新实现" class="headerlink" title="节点更新实现"></a>节点更新实现</h2><p>当我们调用 <code>ZADD</code> 方法时，如果对应的 value 不存在，那就是插入过程，如果这个 value 已经存在，只是调整一下 score 的值，那就需要走一个更新流程。</p>
<p>假设这个新的 score 值并不会带来排序上的变化，那么就不需要调整位置，直接修改元素的 score 值就可以了，但是如果排序位置改变了，那就需要调整位置，该如何调整呢？</p>
<p>从源码 <code>t_zset.c/zsetAdd</code> 函数 <code>1350</code> 行左右可以看到，Redis 采用了一个非常简单的策略：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Remove and re-insert when score changed. */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">!=</span> curscore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    zobj<span class="token operator">-></span>ptr <span class="token operator">=</span> <span class="token function">zzlDelete</span><span class="token punctuation">(</span>zobj<span class="token operator">-></span>ptr<span class="token punctuation">,</span>eptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    zobj<span class="token operator">-></span>ptr <span class="token operator">=</span> <span class="token function">zzlInsert</span><span class="token punctuation">(</span>zobj<span class="token operator">-></span>ptr<span class="token punctuation">,</span>ele<span class="token punctuation">,</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>flags <span class="token operator">|</span><span class="token operator">=</span> ZADD_UPDATED<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>把这个元素删除再插入这个</strong>，需要经过两次路径搜索，从这一点上来看，Redis 的 <code>ZADD</code> 代码似乎还有进一步优化的空间。</p>
<h2 id="元素排名的实现"><a href="#元素排名的实现" class="headerlink" title="元素排名的实现"></a>元素排名的实现</h2><p>跳跃表本身是有序的，Redis 在 skiplist 的 forward 指针上进行了优化，给每一个 forward 指针都增加了 <code>span</code> 属性，用来 <strong>表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点中间会跳过多少个节点</strong>。在上面的源码中我们也可以看到 Redis 在插入、删除操作时都会小心翼翼地更新 <code>span</code> 值的大小。</p>
<p>所以，沿着 <strong>“搜索路径”</strong>，把所有经过节点的跨度 <code>span</code> 值进行累加就可以算出当前元素的最终 rank 值了：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Find the rank for an element by both score and key.
 * Returns 0 when the element cannot be found, rank otherwise.
 * Note that the rank is 1-based due to the span of zsl->header to the
 * first element. */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">zslGetRank</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> rank <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>
                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>
                <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// span 累加</span>
            rank <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>
            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/* x might be equal to zsl->header, so test if obj is non-NULL */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>ele <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> rank<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li>跳跃表 Skip List 的原理和实现（Java） - <a href="https://blog.csdn.net/DERRANTCM/article/details/79063312" target="_blank" rel="noopener">https://blog.csdn.net/DERRANTCM/article/details/79063312</a></li>
<li>【算法导论33】跳跃表（Skip list）原理与java实现 - <a href="https://blog.csdn.net/brillianteagle/article/details/52206261" target="_blank" rel="noopener">https://blog.csdn.net/brillianteagle/article/details/52206261</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 设计与实现》 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></li>
<li>【官方文档】Redis 数据类型介绍 - <a href="http://www.redis.cn/topics/data-types-intro.html" target="_blank" rel="noopener">http://www.redis.cn/topics/data-types-intro.html</a></li>
<li>《Redis 深度历险》 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>Redis 源码 - <a href="https://github.com/antirez/redis" target="_blank" rel="noopener">https://github.com/antirez/redis</a></li>
<li>Redis 快速入门 - 易百教程 - <a href="https://www.yiibai.com/redis/redis_quick_guide.html" target="_blank" rel="noopener">https://www.yiibai.com/redis/redis_quick_guide.html</a></li>
<li>Redis【入门】就这一篇! - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/</a></li>
<li>Redis为什么用跳表而不用平衡树？ - <a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261425&idx=1&sn=d840079ea35875a8c8e02d9b3e44cf95&scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261425&amp;idx=1&amp;sn=d840079ea35875a8c8e02d9b3e44cf95&amp;scene=21#wechat_redirect</a></li>
<li>为啥 redis 使用跳表(skiplist)而不是使用 red-black？ - 知乎@于康 - <a href="https://www.zhihu.com/question/20202931" target="_blank" rel="noopener">https://www.zhihu.com/question/20202931</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">
      Redis(1)——5种基本数据结构
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb进阶/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年2月28日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-2899175817bb0069.png" alt=""></p>
<h1 id="一、Redis-简介"><a href="#一、Redis-简介" class="headerlink" title="一、Redis 简介"></a>一、Redis 简介</h1><blockquote>
<p><strong>“Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.”</strong> —— Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。 <em>(摘自官网)</em></p>
</blockquote>
<p><strong>Redis</strong> 是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的 Web 应用程序。<strong>Redis</strong> 也被作者戏称为 <em>数据结构服务器</em> ，这意味着使用者可以通过一些命令，基于带有 TCP 套接字的简单 <em>服务器-客户端</em> 协议来访问一组 <strong>可变数据结构</strong> 。<em>(在 Redis 中都采用键值对的方式，只不过对应的数据结构不一样罢了)</em></p>
<h2 id="Redis-的优点"><a href="#Redis-的优点" class="headerlink" title="Redis 的优点"></a>Redis 的优点</h2><p>以下是 Redis 的一些优点：</p>
<ul>
<li><strong>异常快</strong> - Redis 非常快，每秒可执行大约 110000 次的设置(SET)操作，每秒大约可执行 81000 次的读取/获取(GET)操作。</li>
<li><strong>支持丰富的数据类型</strong> - Redis 支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得 Redis 很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。</li>
<li><strong>操作具有原子性</strong> - 所有 Redis 操作都是原子操作，这确保如果两个客户端并发访问，Redis 服务器能接收更新的值。</li>
<li><strong>多实用工具</strong> - Redis 是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis 本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。</li>
</ul>
<h2 id="Redis-的安装"><a href="#Redis-的安装" class="headerlink" title="Redis 的安装"></a>Redis 的安装</h2><p>这一步比较简单，你可以在网上搜到许多满意的教程，这里就不再赘述。</p>
<p>给一个菜鸟教程的安装教程用作参考：<a href="https://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-install.html</a></p>
<h2 id="测试本地-Redis-性能"><a href="#测试本地-Redis-性能" class="headerlink" title="测试本地 Redis 性能"></a>测试本地 Redis 性能</h2><p>当你安装完成之后，你可以先执行 <code>redis-server</code> 让 Redis 启动起来，然后运行命令 <code>redis-benchmark -n 100000 -q</code> 来检测本地同时执行 10 万个请求时的性能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-7aea279e8fcdafe5.png" alt=""></p>
<p>当然不同电脑之间由于各方面的原因会存在性能差距，这个测试您可以权当是一种 <strong>「乐趣」</strong> 就好。</p>
<h1 id="二、Redis-五种基本数据结构"><a href="#二、Redis-五种基本数据结构" class="headerlink" title="二、Redis 五种基本数据结构"></a>二、Redis 五种基本数据结构</h1><p><strong>Redis</strong> 有 5 种基础数据结构，它们分别是：<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>。这 5 种是 Redis 相关知识中最基础、最重要的部分，下面我们结合源码以及一些实践来给大家分别讲解一下。</p>
<h2 id="1）字符串-string"><a href="#1）字符串-string" class="headerlink" title="1）字符串 string"></a>1）字符串 string</h2><p>Redis 中的字符串是一种 <strong>动态字符串</strong>，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 <strong>ArrayList</strong>，有一个字符数组，从源码的 <strong>sds.h/sdshdr 文件</strong> 中可以看到 Redis 底层对于字符串的定义 <strong>SDS</strong>，即 <em>Simple Dynamic String</em> 结构：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr5 <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr8 <span class="token punctuation">{</span>
    uint8_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint8_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr16 <span class="token punctuation">{</span>
    uint16_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint16_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr32 <span class="token punctuation">{</span>
    uint32_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint32_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> sdshdr64 <span class="token punctuation">{</span>
    uint64_t len<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* used */</span>
    uint64_t alloc<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>你会发现同样一组结构 Redis 使用泛型定义了好多次，<strong>为什么不直接使用 int 类型呢？</strong></p>
<p>因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，<strong>Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。</strong></p>
<h3 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h3><p>为什么不考虑直接使用 C 语言的字符串呢？因为 C 语言这种简单的字符串表示方式 <strong>不符合 Redis 对字符串在安全性、效率以及功能方面的要求</strong>。我们知道，C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 <code>&#39;\0&#39;</code>。<em>(下图就展示了 C 语言中值为 “Redis” 的一个字符数组)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-3a7d503c81b6e6e4.png" alt=""></p>
<p>这样简单的数据结构可能会造成以下一些问题：</p>
<ul>
<li><strong>获取字符串长度为 O(N) 级别的操作</strong> → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</li>
<li>不能很好的杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；</li>
<li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li>
</ul>
<p>我们以追加字符串的操作举例，Redis 源码如下：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
 * end of the specified sds string 's'.
 *
 * After the call, the passed sds string is no longer valid and all the
 * references must be substituted with the new pointer returned by the call. */</span>
sds <span class="token function">sdscatlen</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取原字符串的长度</span>
    size_t curlen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 按需调整空间，如果容量不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中</span>
    s <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 内存不足</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token operator">+</span>curlen<span class="token punctuation">,</span> t<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 追加目标字符串到字节数组中</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> curlen<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 设置追加后的长度</span>
    s<span class="token punctuation">[</span>curlen<span class="token operator">+</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 让字符串以 \0 结尾，便于调试打印</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li><strong>注：Redis 规定了字符串的长度不得超过 512 MB。</strong></li>
</ul>
<h3 id="对字符串的基本操作"><a href="#对字符串的基本操作" class="headerlink" title="对字符串的基本操作"></a>对字符串的基本操作</h3><p>安装好 Redis，我们可以使用 <code>redis-cli</code> 来对 Redis 进行命令行的操作，当然 Redis 官方也提供了在线的调试器，你也可以在里面敲入命令进行操作：<a href="http://try.redis.io/#run" target="_blank" rel="noopener">http://try.redis.io/#run</a></p>
<h4 id="设置和获取键值对"><a href="#设置和获取键值对" class="headerlink" title="设置和获取键值对"></a>设置和获取键值对</h4><pre class=" language-console"><code class="language-console">> SET key value
OK
> GET key
"value"</code></pre>
<p>正如你看到的，我们通常使用 <code>SET</code> 和 <code>GET</code> 来设置和获取字符串值。</p>
<p>值可以是任何种类的字符串（包括二进制数据），例如你可以在一个键下保存一张 <code>.jpeg</code> 图片，只需要注意不要超过 512 MB 的最大限度就好了。</p>
<p>当 key 存在时，<code>SET</code> 命令会覆盖掉你上一次设置的值：</p>
<pre class=" language-console"><code class="language-console">> SET key newValue
OK
> GET key
"newValue"</code></pre>
<p>另外你还可以使用 <code>EXISTS</code> 和 <code>DEL</code> 关键字来查询是否存在和删除键值对：</p>
<pre class=" language-console"><code class="language-console">> EXISTS key
(integer) 1
> DEL key
(integer) 1
> GET key
(nil)</code></pre>
<h4 id="批量设置键值对"><a href="#批量设置键值对" class="headerlink" title="批量设置键值对"></a>批量设置键值对</h4><pre class=" language-console"><code class="language-console">> SET key1 value1
OK
> SET key2 value2
OK
> MGET key1 key2 key3    # 返回一个列表
1) "value1"
2) "value2"
3) (nil)
> MSET key1 value1 key2 value2
> MGET key1 key2
1) "value1"
2) "value2"</code></pre>
<h4 id="过期和-SET-命令扩展"><a href="#过期和-SET-命令扩展" class="headerlink" title="过期和 SET 命令扩展"></a>过期和 SET 命令扩展</h4><p>可以对 key 设置过期时间，到时间会被自动删除，这个功能常用来控制缓存的失效时间。<em>(过期可以是任意数据结构)</em></p>
<pre class=" language-console"><code class="language-console">> SET key value1
> GET key
"value1"
> EXPIRE name 5    # 5s 后过期
...                # 等待 5s
> GET key
(nil)</code></pre>
<p>等价于 <code>SET</code> + <code>EXPIRE</code> 的 <code>SETNX</code> 命令：</p>
<pre class=" language-console"><code class="language-console">> SETNX key value1
...                # 等待 5s 后获取
> GET key
(nil)

> SETNX key value1  # 如果 key 不存在则 SET 成功
(integer) 1
> SETNX key value1  # 如果 key 存在则 SET 失败
(integer) 0
> GET key
"value"             # 没有改变 </code></pre>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>如果 value 是一个整数，还可以对它使用 <code>INCR</code> 命令进行 <strong>原子性</strong> 的自增操作，这意味着及时多个客户端对同一个 key 进行操作，也决不会导致竞争的情况：</p>
<pre class=" language-console"><code class="language-console">> SET counter 100
> INCR count
(interger) 101
> INCRBY counter 50
(integer) 151</code></pre>
<h4 id="返回原值的-GETSET-命令"><a href="#返回原值的-GETSET-命令" class="headerlink" title="返回原值的 GETSET 命令"></a>返回原值的 GETSET 命令</h4><p>对字符串，还有一个 <code>GETSET</code> 比较让人觉得有意思，它的功能跟它名字一样：为 key 设置一个值并返回原值：</p>
<pre class=" language-console"><code class="language-console">> SET key value
> GETSET key value1
"value"</code></pre>
<p>这可以对于某一些需要隔一段时间就统计的 key 很方便的设置和查看，例如：系统每当由用户进入的时候你就是用 <code>INCR</code> 命令操作一个 key，当需要统计时候你就把这个 key 使用 <code>GETSET</code> 命令重新赋值为 0，这样就达到了统计的目的。</p>
<h2 id="2）列表-list"><a href="#2）列表-list" class="headerlink" title="2）列表 list"></a>2）列表 list</h2><p>Redis 的列表相当于 Java 语言中的 <strong>LinkedList</strong>，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。</p>
<p>我们可以从源码的 <code>adlist.h/listNode</code> 来看到对其的定义：</p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Node, List, and Iterator are the only data structures used currently. */</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> listNode <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> listNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> listNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> listIter <span class="token punctuation">{</span>
    listNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">int</span> direction<span class="token punctuation">;</span>
<span class="token punctuation">}</span> listIter<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> list <span class="token punctuation">{</span>
    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>
<span class="token punctuation">}</span> list<span class="token punctuation">;</span></code></pre>
<p>可以看到，多个 listNode 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双向链表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-8f569f06506845c1.png" alt=""></p>
<p>虽然仅仅使用多个 listNode 结构就可以组成链表，但是使用 <code>adlist.h/list</code> 结构来持有链表的话，操作起来会更加方便：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-c6fb10cdbb32f517.png" alt=""></p>
<h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><ul>
<li><code>LPUSH</code> 和 <code>RPUSH</code> 分别可以向 list 的左边（头部）和右边（尾部）添加一个新元素；</li>
<li><code>LRANGE</code> 命令可以从 list 中取出一定范围的元素；</li>
<li><code>LINDEX</code> 命令可以从 list 中取出指定下表的元素，相当于 Java 链表操作中的 <code>get(int index)</code> 操作；</li>
</ul>
<p>示范：</p>
<pre class=" language-console"><code class="language-console">> rpush mylist A
(integer) 1
> rpush mylist B
(integer) 2
> lpush mylist first
(integer) 3
> lrange mylist 0 -1    # -1 表示倒数第一个元素, 这里表示从第一个元素到最后一个元素，即所有
1) "first"
2) "A"
3) "B"</code></pre>
<h4 id="list-实现队列"><a href="#list-实现队列" class="headerlink" title="list 实现队列"></a>list 实现队列</h4><p>队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序：</p>
<pre class=" language-console"><code class="language-console">> RPUSH books python java golang
(integer) 3
> LPOP books
"python"
> LPOP books
"java"
> LPOP books
"golang"
> LPOP books
(nil)</code></pre>
<h4 id="list-实现栈"><a href="#list-实现栈" class="headerlink" title="list 实现栈"></a>list 实现栈</h4><p>栈是先进后出的数据结构，跟队列正好相反：</p>
<pre class=" language-console"><code class="language-console">> RPUSH books python java golang
> RPOP books
"golang"
> RPOP books
"java"
> RPOP books
"python"
> RPOP books
(nil)</code></pre>
<h2 id="3）字典-hash"><a href="#3）字典-hash" class="headerlink" title="3）字典 hash"></a>3）字典 hash</h2><p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。源码定义如 <code>dict.h/dictht</code> 定义：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 哈希表数组</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 哈希表大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 该哈希表已有节点的数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 内部有两个 dictht 结构</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* number of iterators currently running */</span>
<span class="token punctuation">}</span> dict<span class="token punctuation">;</span></code></pre>
<p><code>table</code> 属性是一个数组，数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针，而每个 <code>dictEntry</code> 结构保存着一个键值对：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 键</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 值</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        uint64_t u64<span class="token punctuation">;</span>
        int64_t s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 指向下个哈希表节点，形成链表</span>
    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span></code></pre>
<p>可以从上面的源码中看到，<strong>实际上字典结构的内部包含两个 hashtable</strong>，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 <strong>渐进式搬迁</strong> <em>(下面说原因)</em>。</p>
<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>大字典的扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 <strong>渐进式 rehash</strong> 小步搬迁：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-325d968300c47100.png" alt=""></p>
<p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。</p>
<h3 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h3><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p>
<h3 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h3><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，所以到底该使用 hash 还是字符串，需要根据实际情况再三权衡：</p>
<pre class=" language-console"><code class="language-console">> HSET books java "think in java"    # 命令行的字符串如果包含空格则需要使用引号包裹
(integer) 1
> HSET books python "python cookbook"
(integer) 1
> HGETALL books    # key 和 value 间隔出现
1) "java"
2) "think in java"
3) "python"
4) "python cookbook"
> HGET books java
"think in java"
> HSET books java "head first java"  
(integer) 0        # 因为是更新操作，所以返回 0
> HMSET books java "effetive  java" python "learning python"    # 批量操作
OK</code></pre>
<h2 id="4）集合-set"><a href="#4）集合-set" class="headerlink" title="4）集合 set"></a>4）集合 set</h2><p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。</p>
<h3 id="集合-set-的基本使用"><a href="#集合-set-的基本使用" class="headerlink" title="集合 set 的基本使用"></a>集合 set 的基本使用</h3><p>由于该结构比较简单，我们直接来看看是如何使用的：</p>
<pre class=" language-console"><code class="language-console">> SADD books java
(integer) 1
> SADD books java    # 重复
(integer) 0
> SADD books python golang
(integer) 2
> SMEMBERS books    # 注意顺序，set 是无序的 
1) "java"
2) "python"
3) "golang"
> SISMEMBER books java    # 查询某个 value 是否存在，相当于 contains
(integer) 1
> SCARD books    # 获取长度
(integer) 3
> SPOP books     # 弹出一个
"java"</code></pre>
<h2 id="5）有序列表-zset"><a href="#5）有序列表-zset" class="headerlink" title="5）有序列表 zset"></a>5）有序列表 zset</h2><p>这可能使 Redis 最具特色的一个数据结构了，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p>
<p>它的内部实现用的是一种叫做 <strong>「跳跃表」</strong> 的数据结构，由于比较复杂，所以在这里简单提一下原理就好了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-efd5114939a651ed.png" alt=""></p>
<p>想象你是一家创业公司的老板，刚开始只有几个人，大家都平起平坐。后来随着公司的发展，人数越来越多，团队沟通成本逐渐增加，渐渐地引入了组长制，对团队进行划分，于是有一些人<strong>又是员工又有组长的身份</strong>。</p>
<p>再后来，公司规模进一步扩大，公司需要再进入一个层级：部门。于是每个部门又会从组长中推举一位选出部长。</p>
<p>跳跃表就类似于这样的机制，最下面一层所有的元素都会串起来，都是员工，然后每隔几个元素就会挑选出一个代表，再把这几个代表使用另外一级指针串起来。然后再在这些代表里面挑出二级代表，再串起来。<strong>最终形成了一个金字塔的结构。</strong></p>
<p>想一下你目前所在的地理位置：亚洲 &gt; 中国 &gt; 某省 &gt; 某市 &gt; ….，<strong>就是这样一个结构！</strong></p>
<h3 id="有序列表-zset-基础操作"><a href="#有序列表-zset-基础操作" class="headerlink" title="有序列表 zset 基础操作"></a>有序列表 zset 基础操作</h3><pre class=" language-console"><code class="language-console">> ZADD books 9.0 "think in java"
> ZADD books 8.9 "java concurrency"
> ZADD books 8.6 "java cookbook"

> ZRANGE books 0 -1     # 按 score 排序列出，参数区间为排名范围
1) "java cookbook"
2) "java concurrency"
3) "think in java"

> ZREVRANGE books 0 -1  # 按 score 逆序列出，参数区间为排名范围
1) "think in java"
2) "java concurrency"
3) "java cookbook"

> ZCARD books           # 相当于 count()
(integer) 3

> ZSCORE books "java concurrency"   # 获取指定 value 的 score
"8.9000000000000004"                # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题

> ZRANK books "java concurrency"    # 排名
(integer) 1

> ZRANGEBYSCORE books 0 8.91        # 根据分值区间遍历 zset
1) "java cookbook"
2) "java concurrency"

> ZRANGEBYSCORE books -inf 8.91 withscores  # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。
1) "java cookbook"
2) "8.5999999999999996"
3) "java concurrency"
4) "8.9000000000000004"

> ZREM books "java concurrency"             # 删除 value
(integer) 1
> ZRANGE books 0 -1
1) "java cookbook"
2) "think in java"</code></pre>
<h1 id="扩展-相关阅读"><a href="#扩展-相关阅读" class="headerlink" title="扩展/相关阅读"></a>扩展/相关阅读</h1><ol>
<li>阿里云 Redis 开发规范 - <a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener">https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px</a></li>
<li>为什么要防止 bigkey？ - <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&mid=2247483677&idx=1&sn=5c320b46f0e06ce9369a29909d62b401&chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;mid=2247483677&amp;idx=1&amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;scene=21#wechat_redirect</a></li>
<li>Redis【入门】就这一篇！ - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 设计与实现》 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></li>
<li>【官方文档】Redis 数据类型介绍 - <a href="http://www.redis.cn/topics/data-types-intro.html" target="_blank" rel="noopener">http://www.redis.cn/topics/data-types-intro.html</a></li>
<li>《Redis 深度历险》 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>阿里云 Redis 开发规范 - <a href="https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px" target="_blank" rel="noopener">https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px</a></li>
<li>Redis 快速入门 - 易百教程 - <a href="https://www.yiibai.com/redis/redis_quick_guide.html" target="_blank" rel="noopener">https://www.yiibai.com/redis/redis_quick_guide.html</a></li>
<li>Redis【入门】就这一篇! - <a href="https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/">https://www.wmyskxz.com/2018/05/31/redis-ru-men-jiu-zhe-yi-pian/</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%881%EF%BC%89%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2019/11/27/gao-bing-fa-bian-cheng-xue-xi-2-xian-cheng-tong-xin-xiang-jie/">
      高并发编程学习(2)——线程通信详解
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              

            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2019年11月27日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142243.png" alt=""></p>
<blockquote>
<p>前序文章</p>
<ul>
<li>高并发编程学习(1)——并发基础 - <a href="https://www.wmyskxz.com/2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/">https://www.wmyskxz.com/2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/</a></li>
</ul>
</blockquote>
<h1 id="一、经典的生产者消费者案例"><a href="#一、经典的生产者消费者案例" class="headerlink" title="一、经典的生产者消费者案例"></a>一、经典的生产者消费者案例</h1><hr>
<p>上一篇文章我们提到一个应用可以创建多个线程去执行不同的任务，如果这些任务之间有着某种关系，那么线程之间<strong>必须能够通信</strong>来协调完成工作。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142251.png" alt=""></p>
<p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem）就是典型的多线程同步案例，它也被称为<strong>有限缓冲问题</strong>（英语：Bounded-buffer problem）。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA" target="_blank" rel="noopener" title="缓冲区">缓冲区</a>的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong>(摘自维基百科：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者消费者问题</a>)</p>
<ul>
<li><strong>注意</strong>： 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差；</li>
</ul>
<h2 id="准备基础代码：无通信的生产者消费者"><a href="#准备基础代码：无通信的生产者消费者" class="headerlink" title="准备基础代码：无通信的生产者消费者"></a>准备基础代码：无通信的生产者消费者</h2><p>我们来自己编写一个例子：一个生产者，一个消费者，并且让他们让他们使用同一个共享资源，并且我们期望的是生产者生产一条放到共享资源中，消费者就会对应地消费一条。</p>
<p>我们先来模拟一个简单的共享资源对象：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareResource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String gender<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟生产者向共享资源对象中存储数据
     *
     * @param name
     * @param gender
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟消费者从共享资源中取出数据
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>然后来编写我们的生产者，使用循环来交替地向共享资源中添加不同的数据：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> ShareResource shareResource<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>ShareResource shareResource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>shareResource <span class="token operator">=</span> shareResource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                shareResource<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"凤姐"</span><span class="token punctuation">,</span> <span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                shareResource<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>接着让我们的消费者不停地消费生产者产生的数据：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> ShareResource shareResource<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>ShareResource shareResource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>shareResource <span class="token operator">=</span> shareResource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            shareResource<span class="token punctuation">.</span><span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>然后我们写一段测试代码，来看看效果：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建生产者和消费者的共享资源对象</span>
    ShareResource shareResource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动生产者线程</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>shareResource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动消费者线程</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>shareResource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们运行发现出现了诡异的现象，所有的生产者都似乎消费到了同一条数据：</p>
<pre><code>张三-男
张三-男
....以下全是张三-男....</code></pre><p>为什么会出现这样的情况呢？照理说，我的生产者在交替地向共享资源中生产数据，消费者也应该交替消费才对呀..我们大胆猜测一下，会不会是因为消费者是直接循环了 30 次打印共享资源中的数据，而此时生产者还没有来得及更新共享资源中的数据，消费者就已经连续打印了 30 次了，所以我们让消费者消费的时候以及生产者生产的时候都小睡个 10 ms 来缓解消费太快 or 生产太快带来的影响，也让现象更明显一些：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 模拟生产者向共享资源对象中存储数据
 *
 * @param name
 * @param gender
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 模拟消费者从共享资源中取出数据
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>再次运行代码，发现了出现了以下的几种情况：</p>
<ul>
<li><strong>重复消费</strong>：消费者连续地出现两次相同的消费情况（张三-男/ 张三-男）；</li>
<li><strong>性别紊乱</strong>：消费者消费到了脏数据（张三-女/ 凤姐-男）；</li>
</ul>
<h2 id="分析出现问题的原因"><a href="#分析出现问题的原因" class="headerlink" title="分析出现问题的原因"></a>分析出现问题的原因</h2><ul>
<li><strong>重复消费</strong>：我们先来看看<strong>重复消费</strong>的问题，当生产者生产出一条数据的时候，消费者正确地消费了一条，但是当消费者再来共享资源中消费的时候，生产者还没有准备好新的一条数据，所以消费者就又消费到老数据了，<strong>这其中的根本原因是生产者和消费者的速率不一致</strong>。</li>
<li><strong>性别紊乱</strong>：再来分析第二种情况。不同于上面的情况，消费者在消费第二条数据时，生产者也正在生产新的数据，但是尴尬的是，生产者只生产了一半儿（也就是该执行完 <code>this.name = name</code>），也就是还没有来得及给 <code>gender</code> 赋值就被消费者给取走消费了.. 造成这样情况的<strong>根本原因是没有保证生产者生产数据的原子性</strong>。</li>
</ul>
<h2 id="解决出现的问题"><a href="#解决出现的问题" class="headerlink" title="解决出现的问题"></a>解决出现的问题</h2><h3 id="加锁解决性别紊乱"><a href="#加锁解决性别紊乱" class="headerlink" title="加锁解决性别紊乱"></a>加锁解决性别紊乱</h3><p>我们先来解决<strong>性别紊乱</strong>，也就是<strong>原子性</strong>的问题吧，上一篇文章里我们也提到了，对于这样的原子性操作，解决方法也很简单：<strong>加锁</strong>。稍微改造一下就好了：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 模拟生产者向共享资源对象中存储数据
 *
 * @param name
 * @param gender
 */</span>
<span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 模拟消费者从共享资源中取出数据
 */</span>
<span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>我们在方法前面都加上了 <code>synchronized</code> 关键字，来保证每一次读取和修改都只能是一个线程，这是因为当 <code>synchronized</code> 修饰在普通同步方法上时，它会自动锁住当前实例对象，也就是说这样改造之后读/ 写操作同时只能进行其一；</li>
<li>我把 <code>push</code> 方法小睡的代码改在了赋值 <code>name</code> 和 <code>gender</code> 的中间，以强化验证原子性操作是否成功，因为如果不是原子性的话，就很可能出现赋值 <code>name</code> 还没赋值给 <code>gender</code> 就被取走的情况，小睡一会儿是为了加强这种情况的出现概率（可以试着把 <code>synchronized</code> 去掉看看效果）；</li>
</ul>
<p>运行代码后发现，并没有出现性别紊乱的现象了，但是重复消费仍然存在。</p>
<h3 id="等待唤醒机制解决重复消费"><a href="#等待唤醒机制解决重复消费" class="headerlink" title="等待唤醒机制解决重复消费"></a>等待唤醒机制解决重复消费</h3><p>我们期望的是 <code>张三-男</code> 和 <code>凤姐-女</code> 交替出现，而不是有重复消费的情况，所以我们的生产者和消费者之间需要一点沟通，最容易想到的解决方法是，我们新增加一个标志位，然后在消费者中使用 <code>while</code> 循环判断，不满足条件则不消费，条件满足则退出 <code>while</code> 循环，从而完成消费者的工作。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> desire<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这样做的目的就是为了防止「过快的无效尝试」，这种方法看似能够实现所需的功能，但是却存在如下的问题：</p>
<ul>
<li><strong>1）难以确保及时性</strong>。在睡眠时，基本不消耗处理器的资源，但是如果睡得过久，就不能及时发现条件已经变化，也就是及时性难以保证；</li>
<li><strong>2）难以降低开销</strong>。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能够更加迅速地发现条件变化，但是却可能消耗更多的处理资源，造成了无端的浪费。</li>
</ul>
<p>以上两个问题吗，看似矛盾难以调和，但是 Java 通过内置的等待/ 通知机制能够很好地解决这个矛盾并实现所需的功能。</p>
<p><strong>等待/ 通知机制</strong>，是指一个线程 A 调用了对象 O 的 <code>wait()</code> 方法进入等待状态，而另一个线程 B 调用了对象 O 的 <code>notifyAll()</code> 方法，线程 A 收到通知后从对象 O 的 <code>wait()</code> 方法返回，进而执行后续操作。上述两个线程都是通过对象 O 来完成交互的，而对象上的 <code>wait</code> 和 <code>notify/ notifyAll</code> 的关系就如同<strong>开关信号</strong>一样，用来完成等待方和通知方之间的交互工作。</p>
<blockquote>
<p>这里有一个比较奇怪的点是，为什么看起来像是线程之间操作的 <code>wait</code> 和 <code>notify/ notifyAll</code> 方法会是 <code>Object</code> 类中的方法，而不是 <code>Thread</code> 类中的方法呢？</p>
<ul>
<li><strong>简单来说</strong>：因为 <code>synchronized</code> 中的这把锁可以是任意对象，因为要满足任意对象都能够调用，所以属于 <code>Object</code> 类；</li>
<li><strong>专业点说</strong>：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的 <code>notify</code> 唤醒，不可以对不同锁中的线程进行唤醒。<strong>也就是说，等待和唤醒必须是同一个锁</strong>。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在 <code>Object</code> 类中。</li>
</ul>
</blockquote>
<p>好，简单介绍完等待/ 通知机制，我们开始改造吧：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareResource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String gender<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新增加一个标志位，表示共享资源是否为空，默认为 true</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟生产者向共享资源对象中存储数据
     *
     * @param name
     * @param gender
     */</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 当前共享资源不为空的时，则等待消费者来消费</span>
                <span class="token comment" spellcheck="true">// 使用同步锁对象来调用，表示当前线程释放同步锁，进入等待池，只能被其他线程所唤醒</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 开始生产</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束唤醒一个消费者来消费</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟消费者从共享资源中取出数据
     */</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 为空则等着生产者进行生产</span>
                <span class="token comment" spellcheck="true">// 使用同步锁对象来调用，表示当前线程释放同步锁，进入等待池，只能被其他线程所唤醒</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 消费开始</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束唤醒一个生产者去生产</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>我们期望生产者生产一条，然后就去通知消费者消费一条，那么在生产和消费之前，都需要考虑当前是否需要生产 or 消费，所以我们新增了一个标志位来判断，如果不满足则等待；</li>
<li>被通知后仍然要检查条件，条件满足，则执行我们相应的生产 or 消费的逻辑，然后改变条件（这里是 <code>isEmpty</code>），并且通知所有等待在对象上的线程；</li>
<li><strong>注意</strong>：上面的代码中通知使用的 <code>notify()</code> 方法，这是因为例子中写死了只有一个消费者和生产者，在实际情况中建议还是使用 <code>notifyAll()</code> 方法，这样多个消费和生产者逻辑也能够保证（可以自己试一下）；</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过初始版本一步步地分析问题和解决问题，我们就差不多写出了我们经典生产者消费者的经典代码，但通常消费和生产的逻辑是写在各自的消费者和生产者代码里的，这里我为了方便阅读，把他们都抽离到了共享资源上，我们可以简单地再来回顾一下这个消费生产和等待通知的整个过程：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142305.png" alt=""></p>
<p>以上就是关于生产者生产一条数据，消费者消费一次的过程了，涉及的一些具体细节我们下面来说。</p>
<h1 id="二、线程间的通信方式"><a href="#二、线程间的通信方式" class="headerlink" title="二、线程间的通信方式"></a>二、线程间的通信方式</h1><hr>
<h2 id="等待唤醒机制的替代：Lock-和-Condition"><a href="#等待唤醒机制的替代：Lock-和-Condition" class="headerlink" title="等待唤醒机制的替代：Lock 和 Condition"></a>等待唤醒机制的替代：Lock 和 Condition</h2><p>我们从上面的中看到了 <code>wait()</code> 和 <code>notify()</code> 方法，只能被同步监听锁对象来调用，否则就会报出 <code>IllegalMonitorZStateException</code> 的异常，那么现在问题来了，我们在上一篇提到的 <code>Lock</code> 机制根本就没有同步锁了，也就是没有自动获取锁和自动释放锁的概念，因为没有同步锁，也就意味着 <code>Lock</code> 机制不能调用 <code>wait</code> 和 <code>notify</code> 方法，我们怎么办呢？</p>
<p>好在 Java 5 中提供了 Lock 机制的同时也提供了用于 Lock 机制控制通信的 Condition 接口，如果大家理解了上面说到的 <code>Object.wait()</code> 和 <code>Object.notify()</code> 方法的话，那么就能很容易地理解 Condition 对象了。</p>
<p>它和 <code>wait()</code> 和 <code>notify()</code> 方法的作用是大致相同的，只不过后者是配合 <code>synchronized</code> 关键字使用的，而 Condition 是与重入锁相关联的。通过 Lock 接口（重入锁就实现了这一接口）的 <code>newCondition()</code> 方法可以生成一个与当前重入锁绑定的 Condition 实例。利用 Condition 对象，我们就可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。</p>
<p>我们拿上面的生产者消费者来举例，修改成 Lock 和 Condition 代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareResource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String gender<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新增加一个标志位，表示共享资源是否为空，默认为 true</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟生产者向共享资源对象中存储数据
     *
     * @param name
     * @param gender
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 当前共享资源不为空的时，则等待消费者来消费</span>
                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 开始生产</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束唤醒消费者来消费</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟消费者从共享资源中取出数据
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 为空则等着生产者进行生产</span>
                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 消费开始</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束唤醒生产者去生产</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在 JDK 内部，重入锁和 Condition 对象被广泛地使用，以 ArrayBlockingQueue 为例，它的 <code>put()</code> 方法实现如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Main lock guarding all access */</span>
<span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** Condition for waiting takes */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** Condition for waiting puts */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 构造函数，初始化锁以及对应的 Condition 对象</span>
<span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>
    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 等待队列有足够的空间</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>
    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>
    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 通知需要 take() 的线程，队列已有数据</span>
    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>同理，对应的 <code>take()</code> 方法实现如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 如果队列为空，则消费者队列要等待一个非空的信号</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="允许多个线程同时访问：信号量-Semaphore"><a href="#允许多个线程同时访问：信号量-Semaphore" class="headerlink" title="允许多个线程同时访问：信号量(Semaphore)"></a>允许多个线程同时访问：信号量(Semaphore)</h2><blockquote>
<p>以下内容摘录 or 改编自 《实战 Java 高并发程序设计》 3.1.3 节的内容</p>
</blockquote>
<p>信号量为多线程协作提供了更为强大的控制方法。广义上说，信号量是对锁的扩展，无论是内部锁 synchronized 还是重入锁 ReentrantLock，一次都只允许一个线程访问一个资源，而<strong>信号量却可以指定多个线程，同时访问某一个资源</strong>。信号量主要提供了以下构造函数：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 第二个参数可以指定是否公平</span></code></pre>
<p>在构造信号量对象时，必须要指定信号量的准入数，即同时能申请多少个许可。当每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。信号量的主要逻辑如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquireUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<ul>
<li><code>acquire()</code> 方法尝试获得一个准入的许可。若无法获得，则线程会等待，直到有线程释放一个许可或者当前线程被中断。</li>
<li><code>acquireUninterruptibly()</code> 方法和 <code>acquire()</code> 方法类似，但是不响应中断。</li>
<li><code>tryAcquire()</code> 尝试获得一个许可，如果成功则返回 true，失败则返回 false，它不会进行等待，立即返回。</li>
<li><code>release()</code> 用于在线程访问资源结束后，释放一个许可，以使其他等待许可的线程可以进行资源访问。</li>
</ul>
<p>在 JDK 的官方 Javadoc 中，就有一个有关信号量使用的简单实例，有兴趣的读者可以自行去翻阅一下，这里给出一个更傻瓜化的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemapDemo</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">final</span> Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 模拟耗时操作</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":done!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> SemapDemo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SemapDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>执行程序，就会发现系统以 5 个线程为单位，依次输出带有线程 ID 的提示文本。</p>
<p><strong>在实现上，Semaphore 借助了线程同步框架 AQS（AbstractQueuedSynchornizer）</strong>，同样借助了 AQS 来实现的是 Java 中可重入锁的实现。AQS 的强大之处在于，你仅仅需要继承它，然后使用它提供的 api 就可以实现任意复杂的线程同步方案，AQS 为我们做了大部分的同步工作，所以这里不细说，之后再来详细探究一下…</p>
<h2 id="我等着你：Thread-join"><a href="#我等着你：Thread-join" class="headerlink" title="我等着你：Thread.join()"></a>我等着你：Thread.join()</h2><p>如果一个线程 A 执行了 <code>thread.join()</code> 方法，其含义是：<strong>当前线程 A 等待 thread 线程终止之后才从 <code>thread.join()</code> 返回</strong>。线程 Thread 除了提供 <code>join()</code> 方法之外，还提供了 <code>join(long millis)</code> 和 <code>join(long millis, int nanos)</code> 两个具备超时特性的方法。这两个超时方法表示，如果线程 Thread 在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<p>在下面的代码中，我们创建了 10 个线程，编号 0 ~ 9，每个线程调用前一个线程的 <code>join()</code> 方法，也就是线程 0 结束了，线程 1 才能从 <code>join()</code> 方法中返回，而线程 0 需要等待 main 线程结束。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Join</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread previous <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span>
            Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Domino</span><span class="token punctuation">(</span>previous<span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            previous <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" terminate. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Domino</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> Thread thread<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Domino</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" terminate. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行程序，可以看到下列输出：</p>
<pre><code>main terminate. 
0 terminate. 
1 terminate. 
2 terminate. 
3 terminate. 
4 terminate. 
5 terminate. 
6 terminate. 
7 terminate. 
8 terminate. 
9 terminate. </code></pre><p>说明每个线程终止的前提都是前驱线程的终止，每个线程等待前驱线程结束后，才从 <code>join()</code> 方法中返回，这里涉及了等待/ 通知机制，在 JDK 的源码中，我们可以看到 <code>join()</code> 的方法如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">long</span> base <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"timeout value is negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 条件不满足则继续等待</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 条件符合则返回</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> delay <span class="token operator">=</span> millis <span class="token operator">-</span> now<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
            now <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> base<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>当线程终止时，会调用线程自身的 <code>notifyAll()</code> 方法，会通知所有等待在该线程对象上的线程</strong>。可以看到 <code>join()</code> 方法的逻辑结构跟我们上面写的生产者消费者类似，即加锁、循环和处理逻辑三个步骤。</p>
<h1 id="三、线程之间的数据交互"><a href="#三、线程之间的数据交互" class="headerlink" title="三、线程之间的数据交互"></a>三、线程之间的数据交互</h1><hr>
<h2 id="保证可见性：volatile-关键字"><a href="#保证可见性：volatile-关键字" class="headerlink" title="保证可见性：volatile 关键字"></a>保证可见性：volatile 关键字</h2><p>我们先从一个有趣的例子入手：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> isOver <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isOver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程已感知到 isOver 置为 true，线程正常返回!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    isOver <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"isOver 已置为 true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们开启了一个主线程和一个子线程，我们期望子线程能够感知到 <code>isOver</code> 变量的变化以结束掉死循环正常返回，但是运行程序却发现并不是像我们期望的那样发生，子线程一直处在了死循环的状态！</p>
<p><strong>为什么会这样呢？</strong></p>
<h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>关于这一点，我们有几点需要说明，首先需要搞懂 Java 的内存模型：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142324.png" alt=""></p>
<p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p><strong>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中</strong>。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。<strong>不同的线程之间也无法直接访问对方工作内存中的变量</strong>，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p>
<p><strong>那么不同的线程之间是如何通信的呢？</strong></p>
<p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142335.png" alt=""></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 更新过的共享变量刷新到主内存中去</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</li>
</ol>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142342.png" alt=""></p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 <code>wait()</code> 和 <code>notify()</code>。</p>
<p>说回刚才出现的问题，就很容易理解了：每个线程都有独占的内存区域，如操作栈、本地变量表等。<strong>线程本地保存了引用变量在堆内存中的副本，线程对变量的所有操作都在本地内存区域中进行，执行结束后再同步到堆内存中去</strong>。也就是说，我们在主线程中修改的 <code>isOver</code> 的值并没有被子线程读取到（没有被刷入主内存），也就造成了子线程对于 <code>isOver</code> 变量不可见。</p>
<p>解决方法也很简单，只需要在 <code>isOver</code> 变量前加入 <code>volatile</code> 关键字就可以了，这是<strong>因为加入了 <code>volatile</code> 修饰的变量允许直接与主内存交互，进行读写操作</strong>，保证可见性。</p>
<h2 id="指令重排-happen-before-原则"><a href="#指令重排-happen-before-原则" class="headerlink" title="指令重排/ happen-before 原则"></a>指令重排/ happen-before 原则</h2><p>再从另一个有趣的例子中入手，这是在高并发场景下会存在的问题：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LazyInitDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> TransationService service <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> TransationService <span class="token function">getTransationService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>service <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>service <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransationService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这是一个典型的双重检查锁定思想，这段代码也是一个典型的双重检查锁定（Double-checked Locking）问题。<strong>在高并发的情况下，该对象引用在没有同步的情况下进行读写操作，导致用户可能会获取未构造完成的对象</strong>。</p>
<p>这是因为<strong>指令优化</strong>的结果。<strong>计算机不会根据代码顺序按部就班地执行相关指令</strong>，我们来举一个借书的例子：假如你要去还书并且想要借一个《高并发编程学习》系列丛书，而你的室友恰好也要还书，并且还想让你帮忙借一本《Java 从入门到放弃》。</p>
<p>这件事乍一看有两件事：你的事和你室友的事。先办完你的事，再开始处理你室友的事情是属于单线程的死板行为，此时你会潜意识地进行<strong>「优化」</strong>，例如你可以把你要还的书和你室友需要还的书一起还了，再一起把想要借的书借出来，这其实就相当于合并数据进行存取的操作过程了。</p>
<p>我们知道一条指令的执行是可以分成很多步骤的，简单地说，可以分为：</p>
<ul>
<li>取值 IF</li>
<li>译码和去寄存器操作数 ID</li>
<li>执行或者有效地址计算 EX</li>
<li>存储器访问 MEM</li>
<li>写回 WB</li>
</ul>
<p>由于每一个步骤可能使用不同的硬件完成，因此，聪明的工程师就发明了流水线技术来执行指令，如下图所示：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142349.png" alt=""></p>
<p>可以看到，当第 2 条指令执行时，第 1 条执行其实并没有执行完，确切地说第一条指令还没有开始执行，只是刚刚完成了取值操作而已。这样的好处非常明显，假如这里每一个步骤都需要花费 1 毫秒，那么指令 2 等待指令 1 完全执行后再执行，则需要等待 5 毫秒，而使用流水线指令，指令 2 只需要等待 1 毫秒就可以执行了。如此大的性能提升，当然让人眼红。</p>
<p>回到最初的问题，我们分析一下：<strong>对于 Java 编译器来说，初始化 TransactionService 实例和将对象地址写到 <code>service</code> 字段并非原子操作，且这两个阶段的执行顺序是未定义的</strong>。加入某个线程执行 <code>new TransactionService()</code> 时，构造方法还未被调用，编译器仅仅为该对象分配了内存空间并设为默认值，此时若另一个线程调用 <code>getTransactionService()</code> 方法，由于 <code>service != null</code>，但是此时 <code>service</code> 对象还没有被赋予真正的有效值，从而无法取到正确的 <code>service</code> 单例对象。</p>
<p>对于此问题，一种较为简单的解决方案就是用 <code>volatile</code> 关键字修饰目标属性（适用于 JDK5 及以上版本），这样 <code>service</code> 就限制了编译器对它的相关读写操作，对它的读写操作进行指令重排，确定对象实例化之后才返回引用。</p>
<p>另外<strong>指令重排也有自己的规则</strong>，并非所有的指令都可以随意改变执行位置，下面列举一下基本的原则：</p>
<ul>
<li><strong>程序次序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li><strong>锁定规则</strong>：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；</li>
<li><strong>volatile 变量规则</strong>：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li><strong>传递规则</strong>：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C；</li>
<li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作；</li>
<li><strong>线程中断规则</strong>：对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li><strong>线程终结规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行；</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的 <code>finalize()</code> 方法的开始；</li>
</ul>
<h3 id="volatile-不保证原子性"><a href="#volatile-不保证原子性" class="headerlink" title="volatile 不保证原子性"></a>volatile 不保证原子性</h3><p>volatile 解决的是多线程共享变量的可见性问题，类似于 synchronized，但不具备 synchronized 的互斥性。所以对 volatile 变量的操作并非都具有原子性，例如我们用下面的例子来说明：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileNotAtomic</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> count <span class="token operator">=</span> 0L<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread subtractThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubstractThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        subtractThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUMBER<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 等待减法线程结束</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>subtractThread<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count 最后的值为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SubstractThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUMBER<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>多次执行后，发现结果基本都不为 0。只有在 <code>count++</code> 和 <code>count--</code> 两处都进行加锁时，才能正确的返回 0，了解 Java 的童鞋都应该知道这 <code>count++</code> 和 <code>count--</code> 都不是一个原子操作，这里就不作说明了。</p>
<h3 id="volatile-的使用优化"><a href="#volatile-的使用优化" class="headerlink" title="volatile 的使用优化"></a>volatile 的使用优化</h3><p>在了解一点吧，注明的并发编程大师 Doug lea 在 JDK 7 的并发包里新增一个队列集合类 LinkedTransferQueue，它在使用 volatile 变量时，用一种<strong>追加字节的方式来优化对列出队和入队的性能</strong>，具体的可以看一下下列的链接，这里就不具体说明了。</p>
<ul>
<li>追加字节方式来优化队列性能？ - <a href="https://my.oschina.net/u/3694754/blog/2990652" target="_blank" rel="noopener">https://my.oschina.net/u/3694754/blog/2990652</a></li>
</ul>
<h2 id="保证原子性：synchronized"><a href="#保证原子性：synchronized" class="headerlink" title="保证原子性：synchronized"></a>保证原子性：synchronized</h2><p>Java 中任何一个对象都有一个唯一与之关联的锁，这样的锁作为该对象的一系列标志位存储在对象信息的头部。Java 对象头里的 Mark Word 里默认的存放的对象的 Hashcode/ 分代年龄和锁标记位。32 为JVM Mark Word 默认存储结构如下：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142400.png" alt=""></p>
<p>Java SE 1.6中，锁一共有 4 种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li><p><strong>偏向锁的获取</strong>：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
</li>
<li><p><strong>偏向锁的撤销</strong>：偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
</li>
</ul>
<p>下图线程 1 展示了偏向锁获取的过程，线程 2 展示了偏向锁撤销的过程。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142411.png" alt=""></p>
<h3 id="轻量级锁和自旋锁"><a href="#轻量级锁和自旋锁" class="headerlink" title="轻量级锁和自旋锁"></a>轻量级锁和自旋锁</h3><p>如果偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。</p>
<p>线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 <strong>Displaced Mark Word</strong>。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>（自己执行几个空循环再进行尝试）来获取锁。</p>
<p>轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。<strong>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</strong>。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142421.png" alt=""></p>
<h3 id="几种锁的比较"><a href="#几种锁的比较" class="headerlink" title="几种锁的比较"></a>几种锁的比较</h3><p>下图就简单概括了一下几种锁的比较：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142427.png" alt=""></p>
<h2 id="每人一支笔：ThreadLocal"><a href="#每人一支笔：ThreadLocal" class="headerlink" title="每人一支笔：ThreadLocal"></a>每人一支笔：ThreadLocal</h2><p>除了控制资源的访问外，我们还可以通过增加资源来保证所有对象的线程安全。比如，让 100 个人填写个人信息表，如果只有一支笔，那么大家就得挨个写，对于管理人员来说，必须保证大家不会去哄抢这仅存的一支笔，否则，谁也填不完。从另外一个角度出发，我们可以干脆就准备 100 支笔，那么所有人都可以各自为营，很快就能完成表格的填写工作。</p>
<p>如果说锁是使用第一种思路，那么 ThreadLocal 就是使用第二种思路了。</p>
<p>当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p>
<p><strong>ThreadLocal 内部实现机制</strong>：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142433.png" alt=""></p>
<ol>
<li><p>每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；</p>
</li>
<li><p>Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；</p>
</li>
<li><p>Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。</p>
</li>
</ol>
<h3 id="ThreadLodal-的副作用"><a href="#ThreadLodal-的副作用" class="headerlink" title="ThreadLodal 的副作用"></a>ThreadLodal 的副作用</h3><p>为了让线程安全地共享某个变量，JDK 开出了 ThreadLocal 这副药方，但「是药三分毒」，ThreadLocal 也有一定的副作用。<strong>主要问题是「产生脏数据」和「内存泄漏」</strong>。这两个问题通常是在线程池中使用 ThreadLocal 引发的，因为线程池有 <strong>「线程复用」</strong> 和 <strong>「内存常驻」</strong> 两个特点。</p>
<h3 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h3><p>线程复用会产生脏数据。<strong>由于线程池会重用 Thread 对象，那么与 Thread 绑定的类的静态属性 ThreadLocal 变量也会被重用</strong>。如果在实现的线程 <code>run()</code> 方法中不显式地 <code>remove()</code> 清理与线程相关的 ThreadLocal 信息，那么倘若下一个线程不调用 <code>set()</code> 设置初始值，就可能 <code>get()</code> 到重用的线程信息，包括 ThreadLocal 所关联的线程对象的 value 值。</p>
<p>为了方便理解，用一段简要代码来模拟，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirtyDataInThreadLocal</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 使用固定大小为 1 的线程池，说明上一个的线程属性会被下一个线程属性复用</span>
        ExecutorService pool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Mythread mythread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Mythread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 第 1 个线程 set 后，并没有进行 remove</span>
                <span class="token comment" spellcheck="true">// 而第二个线程由于某种原因没有进行 set 操作</span>
                threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", session info."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 线程是 "</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>执行结果：</p>
<pre><code>Thread-0 线程是 Thread-0, session info.
Thread-1 线程是 Thread-0, session info.</code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>在源码注释中提示使用 static 关键字来修饰 ThreadLocal。在此场景下，寄希望于 ThreadLocal 对象失去引用后，触发<strong>弱引用</strong>机制来回收 Entry 的 Value 就变得不现实了。在上面的例子中，如果不进行 <code>remove()</code> 操作，那么这个线程执行完成后，通过 ThreadLocal 对象持有的 String 对象是不会被释放的。</p>
<p>以上两个问题的解决办法很简单，就是在每次使用完 ThreadLocal 时，必须要及时调用 <code>remove()</code> 方法清理。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<ol>
<li>《Java 零基础入门教程》 - <a href="http://study.163.com/course/courseMain.htm?courseId=1003108028" target="_blank" rel="noopener" title="http://study.163.com/course/courseMain.htm?courseId=1003108028">http://study.163.com/course/courseMain.htm?courseId=1003108028</a></li>
<li>《Java 并发编程的艺术》</li>
<li>《码出高效 Java 开发手册》 - 杨冠宝（孤尽） 高海慧（鸣莎）著</li>
<li>Java面试知识点解析(二)——高并发编程篇 - <a href="https://www.wmyskxz.com/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/">https://www.wmyskxz.com/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/</a></li>
<li>让你彻底理解Synchronized - <a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">https://www.jianshu.com/p/d53bf830fa09</a></li>
<li>《Offer来了 - Java面试核心知识点精讲》 - 王磊 编著</li>
<li>《实战Java高并发程序设计》 - 葛一鸣 郭超 编著</li>
</ol>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/tags/%E5%8E%9F%E5%88%9B/page/4/">
            <section class="post prev white-box shadow" >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          5 / 20
        </p>
        
          <a class="next" rel="next" href="/tags/%E5%8E%9F%E5%88%9B/page/6/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" href="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"
            id="categoriesE78988E69CACE789B9E680A7"
            ><div class='name'>版本特性</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" href="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/"
            id="categoriesE79FA5E4B98EE997AEE7AD94"
            ><div class='name'>知乎问答</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.86px; color: #868686">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.29px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.57px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.86px; color: #646464">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.43px; color: #6d6d6d">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.43px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 19.71px; color: #727272">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.71px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.86px; color: #868686">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.57px; color: #818181">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.57px; color: #818181">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.14px; color: #686868">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.71px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.43px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.14px; color: #8a8a8a">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.71px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.43px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.57px; color: #818181">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.71px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.29px; color: #7c7c7c">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.71px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.14px; color: #8a8a8a">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" style="font-size: 14.71px; color: #949494">版本特性</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" style="font-size: 14px; color: #999">知乎问答</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.86px; color: #868686">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.14px; color: #686868">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19px; color: #777">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
