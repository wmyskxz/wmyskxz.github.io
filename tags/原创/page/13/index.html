<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>标签：原创 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/28/javaweb-zhong-shi-yong-json/">
      JavaWeb中使用JSON
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/JavaWeb%E5%9F%BA%E7%A1%80/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>JavaWeb基础</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月28日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/JavaWeb%E4%B8%AD%E4%BD%BF%E7%94%A8JSON/7896890-5194fe343100d42b.png" alt=""></p>
<blockquote>
<p><strong>前言：</strong> 最近也是期末了，有好多好多文档和实验报告要交，所以都没啥时间写文，这段时间清闲了，来补一下之前学习时遗漏的一些知识树，话说就没人吐槽这个JSON图标好丑吗？</p>
</blockquote>
<h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><ul>
<li>JSON 指的是 JavaScript 对象表示法（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）</li>
<li>JSON 是轻量级的文本数据交换格式</li>
<li>JSON 独立于语言 <code>*</code></li>
<li>JSON 具有自我描述性，更易理解</li>
</ul>
<p>JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。</p>
<p>这里有意思的是，JSON本来是用来表示 JavaScript 对象的一种数据文本格式，但由于它轻量级、易于解析/操作（JavaScript原生支持）的一些特点，渐渐的被很多语言支持也就成了一种标准</p>
<hr>
<h2 id="为什么使用JSON"><a href="#为什么使用JSON" class="headerlink" title="为什么使用JSON"></a>为什么使用JSON</h2><p>在JSON之前，我们通常在网络传输中使用的格式是XML，在我们的印象之中，XML具有很好的可读性，并且格式统一，解析起来也相对比较简单，为什么摒弃掉XML而逐渐的使用起JSON呢？</p>
<p>主要原因在于：<strong>JSON比XML更小、更快、更易解析。</strong></p>
<ul>
<li>JavaScript原生支持JSON，解析速度相较XML会更快；</li>
<li>XML解析成DOM对象的时候，浏览器之间会产生差异【例如IE和FireFox】；</li>
<li>JSON有很多强大的库能够帮助我们更快更简单的完成工作</li>
</ul>
<h4 id="XML与JSON实例比较"><a href="#XML与JSON实例比较" class="headerlink" title="XML与JSON实例比较"></a>XML与JSON实例比较</h4><p>接下来我们通过一个实例的比较来真实的说明一下XML与JSON的区别：</p>
<ol>
<li>使用<code>XML</code>表示中国部分省市的数据如下：</li>
</ol>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>country</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>中国<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>province</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>黑龙江<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>citys</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>哈尔滨<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>大庆<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>citys</span><span class="token punctuation">></span></span>  　　
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>province</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>province</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>广东<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>citys</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>广州<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>深圳<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>珠海<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>citys</span><span class="token punctuation">></span></span> 　　
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>province</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>province</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>台湾<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>citys</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>台北<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>高雄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>citys</span><span class="token punctuation">></span></span>　
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>province</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>province</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>新疆<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>citys</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>city</span><span class="token punctuation">></span></span>乌鲁木齐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>city</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>citys</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>province</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>country</span><span class="token punctuation">></span></span></code></pre>
<ol start="2">
<li>使用<code>JSON</code>中国部分省市数据如下：</li>
</ol>
<pre class=" language-JSON"><code class="language-JSON">var country =
    {
        name: "中国",
        provinces: [
            { name: "黑龙江", citys: { city: ["哈尔滨", "大庆"]} },
            { name: "广东", citys: { city: ["广州", "深圳", "珠海"]} },
            { name: "台湾", citys: { city: ["台北", "高雄"]} },
            { name: "新疆", citys: { city: ["乌鲁木齐"]} }
        ]
    }</code></pre>
<ul>
<li><p><strong>从编码的可读性来说</strong>，<code>XML</code>有明显的优势，毕竟人类的语言更贴近这样的说明结构。而<code>JSON</code>读起来更像是一个数据块，读起来比较费解，不过我们读起来费解的语言，恰恰是适合机器于都的，所以通过<code>JSON</code>是的索引<code>contry.provinces[0].name</code>就可以读取到“黑龙江”这个值</p>
</li>
<li><p><strong>从编码的手写难度来说</strong>，<code>XML</code>还是更简单一些，好读也就意味着好写；不过<code>JSON</code>写出来的字符明显就少很多；去掉空白制表以及换行的话，<code>JSON</code>就是密密麻麻的有用数据，而<code>XML</code>却包含很多重复的标记字符。</p>
</li>
</ul>
<h4 id="JSON相比XML的不同之处"><a href="#JSON相比XML的不同之处" class="headerlink" title="JSON相比XML的不同之处"></a>JSON相比XML的不同之处</h4><ul>
<li>没有结束标签</li>
<li>更短</li>
<li>读写的速度更快</li>
<li>能够使用内建的 JavaScript eval() 方法进行解析</li>
<li>使用数组</li>
<li>不使用保留字</li>
</ul>
<h5 id="对于AJAX应用程序员来说，JSON比XML更快更易使用："><a href="#对于AJAX应用程序员来说，JSON比XML更快更易使用：" class="headerlink" title="对于AJAX应用程序员来说，JSON比XML更快更易使用："></a>对于AJAX应用程序员来说，JSON比XML更快更易使用：</h5><p><strong>使用XML：</strong></p>
<ul>
<li>读取XML文档</li>
<li>使用XML DOM来循环遍历文档</li>
<li>读取值并存储在变量中</li>
</ul>
<p><strong>使用JSON：</strong></p>
<ul>
<li>读取JSON字符串</li>
<li>用 eval() 处理JSON字符串</li>
</ul>
<hr>
<h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><p><strong>客户端与服务器交换的数据无非就是两种：</strong> <strong>数组</strong>或者是<strong>对象</strong>，JSON所表示的数据也就是这两种了</p>
<p>JSON语法是JavaScript语法的子集，<strong>在JavaScript中用<code>[]</code>中括号来表示数组，用<code>{}</code>大括号来表示对象，JSON也是这样</strong></p>
<h4 id="JSON数组："><a href="#JSON数组：" class="headerlink" title="JSON数组："></a>JSON数组：</h4><p><code>[]</code>中括号里面的内容有些像ArrayList，是一个列表一样的东西</p>
<pre class=" language-JSON"><code class="language-JSON">var employees = [
    { "firstName":"Bill" , "lastName":"Gates" },
    { "firstName":"George" , "lastName":"Bush" },
    { "firstName":"Thomas" , "lastName": "Carter" }
];</code></pre>
<h4 id="JSON对象："><a href="#JSON对象：" class="headerlink" title="JSON对象："></a>JSON对象：</h4><p><code>{}</code>大括号里面的东西有些像Map，是一对一对的键值对</p>
<pre class=" language-JSON"><code class="language-JSON">var obj = {

    age:20,
    str:"wmyskxz",
    method:function() {
        alert("我爱学习");
    }

};</code></pre>
<ul>
<li><strong>注意：</strong><code>[]</code>中括号和<code>{}</code>大括号之间是可以相互嵌套的</li>
</ul>
<hr>
<h2 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h2><p>在解析JSON对象之前，我们需要首先地来创造一个JSON对象：</p>
<pre class=" language-JavaScript"><code class="language-JavaScript"><script>
    var JASONObject = {"name": "我没有三颗心脏", "age": 21};
</script></code></pre>
<h4 id="使用HTML解析"><a href="#使用HTML解析" class="headerlink" title="使用HTML解析"></a>使用HTML解析</h4><p>在HTML中我们可以直接使用<code>.</code>点号来直接访问JSON对象的属性：</p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>JSON学习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
    Name:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>
    Age:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">var</span> JASONObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"我没有三颗心脏"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> JASONObject<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> JASONObject<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>打开网页我们能正确看到如下效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/JavaWeb%E4%B8%AD%E4%BD%BF%E7%94%A8JSON/7896890-05b73c58e34507ec.png" alt=""></p>
<p>但通常情况中，我们拿到和上传的并不是一个真正的JSON对象，而是一串由JSON转换得来的字符串，我们同样在HTML中模拟解析一下：</p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>JSON学习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
    Name:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>
    Age:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">var</span> txt <span class="token operator">=</span> <span class="token string">'{"students":['</span> <span class="token operator">+</span>
        <span class="token string">'{"name":"我没有三颗心脏0","age":21},'</span> <span class="token operator">+</span>
        <span class="token string">'{"name":"我没有三颗心脏1","age":21 }]}'</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"("</span> <span class="token operator">+</span> txt <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> obj<span class="token punctuation">.</span>students<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> obj<span class="token punctuation">.</span>students<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>打开网页即可看到如下正确效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/JavaWeb%E4%B8%AD%E4%BD%BF%E7%94%A8JSON/7896890-7e3bece979f4e3e7.png" alt=""></p>
<h4 id="从前端发送JSON数据到后台"><a href="#从前端发送JSON数据到后台" class="headerlink" title="从前端发送JSON数据到后台"></a>从前端发送JSON数据到后台</h4><p>我们这里演示使用AJAX请求的方式来提交JSON数据到后台：</p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>JSON学习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- 因为不想手动引感觉挺麻烦，引了个菜鸟教程的 --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>
    id：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>123<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>
    名称：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>category xxx<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>messageDiv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#sender'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> id <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token keyword">var</span> name <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token keyword">var</span> category <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> name<span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">:</span> id<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> jsonData <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> page <span class="token operator">=</span> <span class="token string">"category"</span><span class="token punctuation">;</span>

        $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            type<span class="token punctuation">:</span> <span class="token string">"put"</span><span class="token punctuation">,</span>
            url<span class="token punctuation">:</span> page<span class="token punctuation">,</span>
            data<span class="token punctuation">:</span> jsonData<span class="token punctuation">,</span>
            dataType<span class="token punctuation">:</span> <span class="token string">"json"</span><span class="token punctuation">,</span>
            contentType<span class="token punctuation">:</span> <span class="token string">"application/json;charset=UTF-8"</span><span class="token punctuation">,</span>
            success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"提交成功，请在springboot控制台查看服务端接收到的数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<ul>
<li><strong>注意：</strong> 在上面的例子中，我们使用了 <code>JSON.stringify()</code> 来将一个JSON对象转换成了一串字符串，并且在AJAX中，我们设置了 <code>dataType</code> 和 <code>contentType</code> 来告知后台我们传输的是一个JSON数据</li>
</ul>
<p>简单写一个Controller来验证一下吧：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"/category"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCategory</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> Category category<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"springboot接受到浏览器以JSON格式提交的数据："</span> <span class="token operator">+</span> category<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> category<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>控制台打印信息：<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
springboot接受到浏览器以JSON格式提交的数据：<span class="token number">123</span> category xxx</code></pre>
<ul>
<li>@RequestBody 注解后面讲到，这里只做简单演示</li>
</ul>
<hr>
<h4 id="JSON库介绍"><a href="#JSON库介绍" class="headerlink" title="JSON库介绍"></a>JSON库介绍</h4><blockquote>
<p>引用自：<a href="http://vickyqi.com/2015/10/19/几种常用JSON库性能比较/" target="_blank" rel="noopener">几种常用JSON库性能比较 </a></p>
</blockquote>
<p>在后台有许多支持解析JSON的库，目前对于Java开源的JSON类库有许多，下面我们介绍三种比较常用的JSON库，并进行比对说明，它们分别是：</p>
<ul>
<li><p><strong>Gson（项目地址：<a href="https://github.com/google/gson" target="_blank" rel="noopener">https://github.com/google/gson</a>)</strong></p>
<ul>
<li>Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。</li>
</ul>
</li>
<li><p><strong>FastJson（项目地址：<a href="https://github.com/alibaba/fastjson）" target="_blank" rel="noopener">https://github.com/alibaba/fastjson）</a></strong></p>
<ul>
<li>Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。</li>
</ul>
</li>
<li><p><strong>Jackson（项目地址：<a href="https://github.com/FasterXML/jackson）" target="_blank" rel="noopener">https://github.com/FasterXML/jackson）</a></strong></p>
<ul>
<li>相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式。</li>
</ul>
</li>
</ul>
<h4 id="到底使用哪一个JSON库呢？"><a href="#到底使用哪一个JSON库呢？" class="headerlink" title="到底使用哪一个JSON库呢？"></a>到底使用哪一个JSON库呢？</h4><p>我看了一些资料，比较印象深刻的是：FastJson在复杂类型的Bean转换Json上会出现一些问题，但是在解析JSON时却是最快的（具体参考：<a href="https://www.zhihu.com/question/44199956" target="_blank" rel="noopener">知乎：fastjson这么快老外为啥还是热衷 jackson?</a>）</p>
<p><strong>总结如下：</strong></p>
<ul>
<li>FastJson的API设计的最简单，最方便使用，直接使用JSON的两个静态方法即可完成四种操作；而Gson和Jackson都需要new一个对象；</li>
<li>数据量大时，使用Jackson;</li>
<li>如果有性能要求可以使用Gson/Jackson将bean转换json确保数据的正确性，使用FastJson将Json转换成Bean</li>
</ul>
<hr>
<h2 id="三种JSON库简要使用说明"><a href="#三种JSON库简要使用说明" class="headerlink" title="三种JSON库简要使用说明"></a>三种JSON库简要使用说明</h2><blockquote>
<p>为了导库简单，我在这里都使用Maven搭建的SpringBoot项目来演示，Maven库的地址在这里：<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></p>
</blockquote>
<p>在使用之前，我们先来建设一些基础类，用于支持JSON库的使用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* getter and setter */</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"名字为"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">",年龄"</span> <span class="token operator">+</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h4 id="Gson库使用简要说明"><a href="#Gson库使用简要说明" class="headerlink" title="Gson库使用简要说明"></a>Gson库使用简要说明</h4><p><strong>（1）Maven依赖：</strong></p>
<pre class=" language-XML"><code class="language-XML"><!-- Gson库 -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.5</version>
</dependency></code></pre>
<p><strong>（2）使用示例：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 准备测试数据 —————————————————— */</span>

    Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person1<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Person person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person2<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Person person3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person3<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 简单的Bean转为JSON —————————————————— */</span>
    String jsonString <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"简单的Bean转为JSON："</span> <span class="token operator">+</span> jsonString<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— JSON转为简单Bean —————————————————— */</span>
    Person personFromJson <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"JSON转为简单Bean："</span> <span class="token operator">+</span> personFromJson<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 带泛型的List转JSON —————————————————— */</span>
    String jsonStringFromList <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"带泛型的List转JSON："</span> <span class="token operator">+</span> jsonStringFromList<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— JSONz转为带泛型的List —————————————————— */</span>
    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> retList <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonStringFromList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Person<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Person tempPerson <span class="token operator">:</span> retList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tempPerson<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>结果如下<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
简单的Bean转为JSON：<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span>
JSON转为简单Bean：名字为我没有三颗心脏<span class="token number">1</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
带泛型的List转JSON：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏2"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏3"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
名字为我没有三颗心脏<span class="token number">1</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
名字为我没有三颗心脏<span class="token number">2</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
名字为我没有三颗心脏<span class="token number">3</span><span class="token punctuation">,</span>年龄<span class="token number">21</span></code></pre>
<blockquote>
<p>好文推荐及扩展阅读：<a href="https://www.jianshu.com/p/e740196225a4" target="_blank" rel="noopener">你真的会用Gson吗?Gson使用指南（一）</a></p>
</blockquote>
<hr>
<h4 id="FastJson库简要使用说明"><a href="#FastJson库简要使用说明" class="headerlink" title="FastJson库简要使用说明"></a>FastJson库简要使用说明</h4><p><strong>（1）Maven依赖：</strong></p>
<pre class=" language-XML"><code class="language-XML"><!-- FastJson库 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.47</version>
</dependency></code></pre>
<p><strong>（2）使用示例：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 准备测试数据 —————————————————— */</span>

    Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person1<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Person person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person2<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Person person3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person3<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 简单的Bean转为JSON —————————————————— */</span>
    String jsonString <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"简单的Bean转为JSON："</span> <span class="token operator">+</span> jsonString<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— JSON转为简单Bean —————————————————— */</span>
    Person personFromJson <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"JSON转为简单Bean："</span> <span class="token operator">+</span> personFromJson<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 带泛型的List转JSON —————————————————— */</span>
    String jsonStringFromList <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"带泛型的List转JSON："</span> <span class="token operator">+</span> jsonStringFromList<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— JSONz转为带泛型的List —————————————————— */</span>
    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> retList <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>jsonStringFromList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeReference</span><span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Person<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Person tempPerson <span class="token operator">:</span> retList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tempPerson<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>结果如下<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
简单的Bean转为JSON：<span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">}</span>
JSON转为简单Bean：名字为我没有三颗心脏<span class="token number">1</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
带泛型的List转JSON：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏2"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏3"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
名字为我没有三颗心脏<span class="token number">1</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
名字为我没有三颗心脏<span class="token number">2</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
名字为我没有三颗心脏<span class="token number">3</span><span class="token punctuation">,</span>年龄<span class="token number">21</span></code></pre>
<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/fastjson/wiki/常见问题" target="_blank" rel="noopener">戳这里</a>，据官方说法，FastJson比Gson要快上6倍哦！</p>
</blockquote>
<hr>
<h4 id="Jackson库使用简要说明"><a href="#Jackson库使用简要说明" class="headerlink" title="Jackson库使用简要说明"></a>Jackson库使用简要说明</h4><p><strong>（1）Maven依赖：</strong></p>
<p>稍微麻烦一点的是Jackson需要依赖三个包</p>
<pre class=" language-XML"><code class="language-XML"><!-- jackson库 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.5</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.5</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.5</version>
</dependency></code></pre>
<p><strong>（2）使用示例：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tester</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 准备测试数据 —————————————————— */</span>

    Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person1<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Person person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person2<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Person person3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person3<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    person3<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    List<span class="token operator">&lt;</span>Person<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现的 */</span>
    ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 简单的Bean转为JSON —————————————————— */</span>
    String jsonString <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"简单的Bean转为JSON："</span> <span class="token operator">+</span> jsonString<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— JSON转为简单Bean —————————————————— */</span>
    Person personFromJson <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"JSON转为简单Bean："</span> <span class="token operator">+</span> personFromJson<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— 带泛型的List转JSON —————————————————— */</span>
    String jsonStringFromList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"带泛型的List转JSON："</span> <span class="token operator">+</span> jsonStringFromList<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* —————————————————— JSONz转为带泛型的List —————————————————— */</span>
<span class="token comment" spellcheck="true">//        List&lt;LinkedHashMap&lt;String, Person>> retList = mapper.readValue(jsonStringFromList, List.class);</span>
<span class="token comment" spellcheck="true">//        for (int i = 0; i &lt; retList.size(); i++) {</span>
<span class="token comment" spellcheck="true">//            Map&lt;String, Person> map = retList.get(i);</span>
<span class="token comment" spellcheck="true">//            Set&lt;String> set = map.keySet();</span>
<span class="token comment" spellcheck="true">//            for (Iterator&lt;String> it = set.iterator(); it.hasNext();) {</span>
<span class="token comment" spellcheck="true">//                String key = it.next();</span>
<span class="token comment" spellcheck="true">//                System.out.println(key + ":" + map.get(key));</span>
<span class="token comment" spellcheck="true">//            }</span>
<span class="token comment" spellcheck="true">//        }</span>
    <span class="token comment" spellcheck="true">/* —————————————————— JSONz转为Array数组 —————————————————— */</span>
    Person<span class="token punctuation">[</span><span class="token punctuation">]</span> retList <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonStringFromList<span class="token punctuation">,</span> Person<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> retList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>retList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>结果如下<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
简单的Bean转为JSON：<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span>
JSON转为简单Bean：名字为我没有三颗心脏<span class="token number">1</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
带泛型的List转JSON：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏1"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏2"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"我没有三颗心脏3"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
名字为我没有三颗心脏<span class="token number">1</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
名字为我没有三颗心脏<span class="token number">2</span><span class="token punctuation">,</span>年龄<span class="token number">21</span>
名字为我没有三颗心脏<span class="token number">3</span><span class="token punctuation">,</span>年龄<span class="token number">21</span></code></pre>
<ul>
<li><strong>几点注意：</strong></li>
</ul>
<p>1.由于Jackson底层代码抛出了IOEception，所以我们在调用的时候也需要抛出；<br>2.Jackson所有的操作都是基于ObjectMapper</p>
<hr>
<h2 id="在框架中使用JSON"><a href="#在框架中使用JSON" class="headerlink" title="在框架中使用JSON"></a>在框架中使用JSON</h2><p>SpingMVC和SpringBoot一样，都能通过注解的方式获取并返回一串JSON格式的数据，我们使用SpringBoot的一段实例程序来实际说明一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/jsonCategory"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ResponseBody</span>    <span class="token comment" spellcheck="true">// 该注解表示我们的请求不再交给springmvc处理，而是结合JSON包，将对象解析成JSON字符串</span>
<span class="token keyword">public</span> Category <span class="token function">jsonCategory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Category</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">"我没有三颗心脏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们在浏览器中访问地址：<code>localhost:8080/jsonCategory</code>，会得到以下JSON数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/JavaWeb%E4%B8%AD%E4%BD%BF%E7%94%A8JSON/7896890-710163cc6ad9ef68.png" alt=""></p>
<p>我们也可以使用 <code>@RequestBody</code> 来获取一串JSON数据：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"/category"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCategory</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> Category category<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"springboot接受到浏览器以JSON格式提交的数据："</span> <span class="token operator">+</span> category<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> category<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们在前台使用的是上面用过的用于提交JSON数据的页面，运行能够成功得到结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/JavaWeb%E4%B8%AD%E4%BD%BF%E7%94%A8JSON/7896890-3bfba7d38db8eea3.png" alt=""></p>
<ul>
<li><strong>注意：</strong> Spring4 之后新加入了 <code>@RestController</code> 注解，是@ResponseBody和@Controller的组合注解，用于返回JSON数据。</li>
</ul>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/22/java-mian-shi-zhi-shi-dian-jie-xi-qi-web-pian/">
      Java面试知识点解析(七)——Web篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月22日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<p><a href="https://www.jianshu.com/p/9c50729464b5" target="_blank" rel="noopener">Java 面试知识点解析(四)——版本特性篇</a></p>
<p><a href="https://www.jianshu.com/p/210f85108c52" target="_blank" rel="noopener">Java 面试知识点解析(五)——网络协议篇</a></p>
<p><a href="https://www.jianshu.com/p/71927a377dc6" target="_blank" rel="noopener">Java 面试知识点解析(六)——数据库篇</a></p>
<hr>
<h2 id="（一）J2EE-相关知识点"><a href="#（一）J2EE-相关知识点" class="headerlink" title="（一）J2EE 相关知识点"></a>（一）J2EE 相关知识点</h2><blockquote>
<p>不涉及任何框架，对 J2EE 相关知识点的解析</p>
</blockquote>
<h3 id="1）Servlet-的生命周期？"><a href="#1）Servlet-的生命周期？" class="headerlink" title="1）Servlet 的生命周期？"></a>1）Servlet 的生命周期？</h3><p>在 Web 容器中，Servlet 主要经历 4 个阶段，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-3504a9d7d5d7ddf1.png" alt=""></p>
<p><strong>1. 加载 Servlet</strong>：当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例。</p>
<p><strong>2. 初始化 Servlet</strong>：当 Servlet 被实例化之后，Tomcat 会调用 init() 方法来初始化这个对象。</p>
<p><strong>3. 处理服务</strong>：当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求。</p>
<p><strong>4. 销毁</strong>：当 Tomcat 关闭或者检测到 Servlet 要从 Tomcat 删除的时候，会自动调用 destroy() 方法，让该实例所占用的资源释放掉。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁。</p>
<ul>
<li><strong>简单总结</strong>：只要访问 Servlet ，就会调用其对应的 service() 方法，init() 方法只会在第一次访问 Serlvet 的时候才会被调用。</li>
</ul>
<hr>
<h3 id="2）Servlet-的请求流程？"><a href="#2）Servlet-的请求流程？" class="headerlink" title="2）Servlet 的请求流程？"></a>2）Servlet 的请求流程？</h3><ol>
<li><p><strong>浏览器发出请求：</strong> <code>http://localhost:80/xxx1/xxx2</code> （80端口可以默认不写，因为这是http协议默认的端口，平时我们访问<code>https://www.baidu.com/</code> 时其实访问的是<code>https://www.baidu.com:80/</code>）</p>
</li>
<li><p><strong>服务器解析请求信息：</strong></p>
<ul>
<li><strong>http:</strong>协议名称</li>
<li><strong>localhost:</strong>访问的是互联网中的<strong>哪一台计算机</strong></li>
<li><strong>80:</strong>从主机当中找到<strong>对应 80 端口的程序 **（</strong>这里即为 Tomcat 服务器**）</li>
<li><strong>/xxx1:</strong>当前项目的<strong>上下文路径</strong> （即在 server.xml 中配置主机时配置的 <strong>path属性</strong>）</li>
<li><strong>/xxx2:</strong>当前<strong>请求的资源名</strong></li>
</ul>
</li>
<li><p><strong>解析</strong> Tomcat 服务器根目录下的 <strong>/config/server.xml</strong> 文件：<br><code>&lt;Context docBase=&quot;D:\javaPros\test\webapp&quot; path=&quot;xxx1&quot; /&gt;</code><br>判断哪一个<code>&lt;Context /&gt;</code>元素的 <strong>path属性</strong> 属性为 <code>xxx1</code></p>
<ul>
<li>若找不到，则返回 <strong>404错误</strong></li>
<li>若找到了，则解析该<code>&lt;Context /&gt;</code>元素，得到<code>docBase</code>属性，获取当前访问 Web 项目的跟的绝对路径：<code>D:\javaPros\test\webapp</code></li>
</ul>
</li>
<li><p>从<code>D:\javaPros\test\webapp</code>下的 <strong>WEB-INF</strong> 下找到 <strong>web.xml</strong> 文件<br>判断 <strong>web.xml</strong> 文件中是否有 <code>&lt;url-pattern&gt;</code> 的文本内容为 <strong>/xxx2</strong></p>
<ul>
<li>若找不到，则返回 <strong>404错误</strong></li>
<li>若找到了，则继续<strong>获取该资源对应 Servlet 类的全限名称：</strong> xxx.xxx</li>
</ul>
</li>
<li><p>判断 <strong>Servlet 实例缓存池</strong> 中是否有 xxx.xxx 的对象</p>
</li>
</ol>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Servlet<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>Tomcat提供的<span class="token punctuation">)</span><span class="token punctuation">;</span>
    key<span class="token operator">:</span>存Servlet类的全限定名称
    value<span class="token operator">:</span>该Servlet类的对象<span class="token punctuation">.</span>
Servlet obj <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"xxx.xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//Servlet实例缓存中没有该类的对象,第一次.</span>
        GOTO <span class="token number">6</span><span class="token operator">:</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//有对象,非第一次.</span>
        GOTO <span class="token number">8</span><span class="token operator">:</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ol start="6">
<li><p><strong>使用反射</strong>调用构造器，<strong>创建对应的对象</strong><br><code>obj = Class.forName(&quot;xxx.xxx&quot;).newInstance();</code><br>把当前创建的 <strong>Servlet 对象</strong>，存放在缓存之中，<strong>供给下一次的使用.</strong><br><code>cache.put(&quot;xxx.xxx&quot;,obj);</code></p>
</li>
<li><p>创建 <strong>ServletConfig 对象</strong>，并调用 <strong>init()</strong> 方法<br><code>obj.init(config);</code></p>
</li>
<li><p>创建 <strong>ServletRequest 对象和 ServletResponse 对象</strong>，并调用 <strong>service()</strong>方法<br><code>obj.service(req,resp);</code></p>
</li>
<li><p>在 <strong>service()</strong> 方法中对浏览器作出响应操作。</p>
</li>
</ol>
<hr>
<h3 id="3）Servlet-是单例的吗？为什么？"><a href="#3）Servlet-是单例的吗？为什么？" class="headerlink" title="3）Servlet 是单例的吗？为什么？"></a>3）Servlet 是单例的吗？为什么？</h3><p>Servlet 是单例的，<strong>浏览器多次对Servlet的请求</strong>，一般情况下，<strong>服务器只创建一个Servlet对象</strong>，也就是说，Servlet对象<strong>一旦创建了</strong>，就会驻留在内存中，<strong>为后续的请求做服务，直到服务器关闭。</strong></p>
<hr>
<h3 id="4）GET-和-POST-的区别"><a href="#4）GET-和-POST-的区别" class="headerlink" title="4）GET 和 POST 的区别"></a>4）GET 和 POST 的区别</h3><p>要知道，GET 和 POST 都是请求方式</p>
<h4 id="1-GET："><a href="#1-GET：" class="headerlink" title="1. GET："></a>1. GET：</h4><p>浏览器器地址栏：<code>http://localhost/test.html?name=wmyskxz&amp;sex=male</code></p>
<p>这里提交了两个参数，一个是<code>name</code>属性值为<code>wmyskxz</code>，另一个是<code>sex</code>属性值为<code>male</code>，这是一种直接的请求方式，在请求资源后面跟上 <strong>?</strong> 符号与参数连接，其他的参数使用 <strong>&amp;</strong> 符号连接。</p>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<p>1.暴露请求信息，<strong>不安全</strong><br>2.请求信息不能超过<strong>1kb</strong>，可传输的信息有限，不能上传图片</p>
<h4 id="2-POST："><a href="#2-POST：" class="headerlink" title="2. POST："></a>2. POST：</h4><p>浏览器地址栏：<code>http://localhost/test.html#</code></p>
<ul>
<li><strong>优点：</strong></li>
</ul>
<p>1.隐藏了请求信息，<strong>较安全</strong>（但仍可以通过相关工具访问到数据）<br>2.POST 方式<strong>没有限制</strong>请求的数据大小，可以做图片的上传</p>
<hr>
<h3 id="5）Tomcat-中如何解决中文乱码问题？"><a href="#5）Tomcat-中如何解决中文乱码问题？" class="headerlink" title="5）Tomcat 中如何解决中文乱码问题？"></a>5）Tomcat 中如何解决中文乱码问题？</h3><p>在 <strong>Tomcat 服务器</strong>中，接受请求的时候，<strong>默认的编码方式为 ISO-8859-1</strong>，而该编码方式只占一个字节，不支持中文（两个字节），所以当我们做请求的时候，会出现乱码的问题</p>
<p><strong>解决方案：</strong></p>
<p>1.对乱码使用 <strong>ISO-8859-1</strong> 解码，转换成<strong>byte数组</strong>，恢复为二进制<br><code>byte[] data = name.getBytes(&quot;ISO-8859-1&quot;);</code></p>
<p>2.对byte数组重新进行 UTF-8 编码：<br><code>name = new String(data,&quot;UTF-8&quot;);</code><br>但是这样会出现一个问题，那就是当表单数据太多的时候，这样反复解码-编码，会很繁琐。</p>
<p><strong>终极解决方案：</strong></p>
<p><strong>1.对于 POST 请求：</strong><br>设置请求的编码方式：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code><br><strong>注意：</strong>必须在获取<strong>第一个参数之前设置</strong>，并且该方式<strong>只对 POST 方式有效。</strong></p>
<p><strong>2.对于 GET 请求：</strong><br>重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:<br><code>Tomcat根目录/conf/server.xml(修改端口的那一行)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-cd366b295c8ed531.png" alt=""></p>
<hr>
<h3 id="6）forward-与-redirect-的区别"><a href="#6）forward-与-redirect-的区别" class="headerlink" title="6）forward 与 redirect 的区别"></a>6）forward 与 redirect 的区别</h3><h4 id="1-请求转发（forward）"><a href="#1-请求转发（forward）" class="headerlink" title="1.请求转发（forward）"></a>1.请求转发（forward）</h4><p>又叫做<strong>直接转发方式，</strong>客户端和浏览器<strong>只发出一次请求，</strong>Servlet、HTML、JSP或其它信息资源，由<strong>第二个信息资源响应该请求，</strong>在请求对象request中，保存的对象对于<strong>每个信息资源是共享的。</strong></p>
<p>比如：从 AServlet 请求转发到 BServlet</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-881fc9bb05d46ac8.png" alt=""></p>
<ul>
<li><strong>语法：</strong></li>
</ul>
<pre class=" language-java"><code class="language-java">request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><em>参数：</em> <code>path</code>，要跳转到的资源路径：<strong>上下文路径 / 资源路径</strong></p>
<p><strong>特点：</strong></p>
<p><strong>1.地址栏中的地址【不会】改变</strong>，通常看作是服务端的跳转</p>
<p><strong>2.只有一个请求</strong></p>
<p><strong>3.资源是共享的</strong></p>
<p>也就是说在两个 Servlet 中可以共享请求的资源，可以通过<code>request.setAttribute(String var1,Object var2)</code><strong>设置要共享的数据资源</strong>，并通过<code>request.getAttribute(String var1);</code>来<strong>获取传递的资源</strong></p>
<p><strong>4.【可以】访问 WEB-INF 中的资源</strong></p>
<p><strong>WEB-INF</strong> 文件夹是 Java Web 应用的<strong>默认安全目录，</strong>即客户端无法直接访问，只有服务端可以访问的目录。如果想在页面中<strong>直接访问</strong>其中的文件，<strong>必须通过web.xml文件</strong>对要访问的文件进行<strong>相应映射</strong>才能访问。</p>
<p><strong>注意：</strong>在实际的开发中，可以把不希望用户直接访问到（通过浏览器输入地址栏）的网页放在文件夹中<strong>通过此方式访问。</strong></p>
<p><strong>5.请求转发【不能】跨域访问</strong></p>
<p>所谓的同域，是指<strong>域名，协议，端口均相同</strong></p>
<h4 id="2-URl-重定向（redirect）"><a href="#2-URl-重定向（redirect）" class="headerlink" title="2.URl 重定向（redirect）"></a>2.URl 重定向（redirect）</h4><p>又叫做<strong>间接转发方式（Redirect）</strong>实际是<strong>两次HTTP请求，</strong>服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>
<p>比如:从AServlet重定向到BServlet</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-c49539085575bc26.png" alt=""></p>
<ul>
<li><strong>语法：</strong></li>
</ul>
<pre class=" language-java"><code class="language-java">response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span>String location<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><em>参数：</em><code>location</code>，转发到的资源路径</p>
<p><strong>特点：</strong></p>
<p><strong>1.地址栏中的地址【会】发生改变</strong>，通常看作是客户端跳转</p>
<p><strong>2.有两个请求</strong></p>
<p><strong>3.在两个 Servlet 中不可以共享请求中的数据</strong></p>
<p><strong>4.最终的响应由 BServlet 来决定，和 AServlet 没有关系</strong></p>
<p><strong>5.【不可以】访问 WEB-INF 中的资源</strong></p>
<p><strong>6.请求转发【能】跨域访问</strong></p>
<p>就像是在网页中点开了新的链接一样</p>
<ul>
<li><strong>总结：</strong>URL 重定向相当于是将重定向的资源路径，重新复制到浏览器地址栏中按下回车一样，<strong>重新发送一次新的请求。</strong></li>
</ul>
<hr>
<h3 id="7）JSP-的执行原理？"><a href="#7）JSP-的执行原理？" class="headerlink" title="7）JSP 的执行原理？"></a>7）JSP 的执行原理？</h3><p>当访问一个 JSP 页面时，该页面请求将会讲给服务器中的 <strong>JSP 引擎</strong>去处理，它<strong>负责解释和执行 JSP 页面，</strong>每个 JSP 页面在<strong>第一次被访问时</strong>，JSP 引擎就会将它翻译成一个继承自 <code>org.apache.jasper.runtime.HttpJspBase</code>类的 <strong>Servlet 源程序，接着再编译成 class 类文件</strong>，再由 Web 容器<strong>像调用普通 Servlet 程序一样</strong>的方式来装载和解释执行这个由 JSP 页面翻译成的 Servlet 程序。</p>
<hr>
<h3 id="8）request-getAttribute-和-request-getParameter-有何区别？"><a href="#8）request-getAttribute-和-request-getParameter-有何区别？" class="headerlink" title="8）request.getAttribute() 和 request.getParameter() 有何区别？"></a>8）request.getAttribute() 和 request.getParameter() 有何区别？</h3><ol>
<li><p>request.getParameter() 通常用来接收接收表单的get或者post提交过来的参数；而request.getAttribute()一般和setAttribute()搭配使用，只有先set之后才能通过get方法获取到Object类型的数据</p>
</li>
<li><p>getAttribute 返回的是对象，而getParameter 返回的是字符串</p>
</li>
<li><p>getAttribute 和 setAttribute 只是在 web 容器内流转，仅仅是请求处理阶段；而 getParameter 取到的数据是通过容器来获取的。</p>
</li>
</ol>
<hr>
<h3 id="9）JSP-与-Servlet-的区别？"><a href="#9）JSP-与-Servlet-的区别？" class="headerlink" title="9）JSP 与 Servlet 的区别？"></a>9）JSP 与 Servlet 的区别？</h3><ol>
<li><strong>JSP 实质上就是一个 Servlet。</strong>可以理解为，JSP 是编译后的 “Servlet 类”；</li>
<li>JSP 由 HTML 代码和 JSP 标签组成，更擅长页面显示；而 Servlet 更擅长流程控制；</li>
<li>JSP 感觉像是 HTML 中嵌入 Java 代码，而 Servlet 有些像 Java 中嵌入 HTML 代码的意思。</li>
</ol>
<hr>
<h3 id="10）JSP-静态包含和动态包含的区别？"><a href="#10）JSP-静态包含和动态包含的区别？" class="headerlink" title="10）JSP 静态包含和动态包含的区别？"></a>10）JSP 静态包含和动态包含的区别？</h3><h4 id="（1）静态包含：编译指令包含"><a href="#（1）静态包含：编译指令包含" class="headerlink" title="（1）静态包含：编译指令包含"></a>（1）静态包含：编译指令包含</h4><p><code>&lt;%@include file=&quot;被包含的页面的路径&quot;%&gt;</code></p>
<p><strong>包含的时机：在 JSP 文件被翻译的时候合并在一起，最终翻译得到一个 class文件</strong></p>
<h4 id="（2）动态包含：动作指令包含"><a href="#（2）动态包含：动作指令包含" class="headerlink" title="（2）动态包含：动作指令包含"></a>（2）动态包含：动作指令包含</h4><p><code>&lt;jsp:include page=&quot;被包含页面的路径&quot;&gt;&lt;/jsp:include&gt;</code></p>
<p><strong>包含的时机：在运行阶段合并代码，最终得到两个 class 文件</strong></p>
<h4 id="（3）动态包含和静态包含的选择"><a href="#（3）动态包含和静态包含的选择" class="headerlink" title="（3）动态包含和静态包含的选择:"></a>（3）动态包含和静态包含的选择:</h4><ul>
<li>如果被包含的页面如果是静态页面,那么使用静态包含；</li>
<li>如果被包含的如果是动态页面,那么使用动态包含。</li>
</ul>
<hr>
<h3 id="11）JSP-有哪些内置对象？作用分别是什么？"><a href="#11）JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="11）JSP 有哪些内置对象？作用分别是什么？"></a>11）JSP 有哪些内置对象？作用分别是什么？</h3><p>JSP 共有以下 9 个内置的对象：</p>
<ol>
<li>request：用户端请求，此请求会包含来自 GET/POST 请求的参数；</li>
<li>response：表示一次响应对象；</li>
<li>pageContext：表示当前的 JSP 对象；</li>
<li>session：表示一次会话对象；</li>
<li>application：表示当前应用对象；</li>
<li>out：表示一个输出流对象；</li>
<li>config：表示当前 JSP 的配置对象；</li>
<li>page：表示当前页面；</li>
<li>exception：表示异常对象。</li>
</ol>
<hr>
<h3 id="12）JSTL-是什么？优点有哪些？"><a href="#12）JSTL-是什么？优点有哪些？" class="headerlink" title="12）JSTL 是什么？优点有哪些？"></a>12）JSTL 是什么？优点有哪些？</h3><p>JSTL（JSP StandardTagLibrary，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，由四个定制标记库（core、format、xml和sql）和一对通用标记库验证器（ScriptFreeTLV和PermittedTaglibsTLV）组成。优点有：</p>
<ol>
<li><p>在应用程序服务器之间提供了一致的接口，最大程序地提高了WEB应用在各应用服务器之间的移植。</p>
</li>
<li><p>简化了JSP和WEB应用程序的开发。</p>
</li>
<li><p>以一种统一的方式减少了JSP中的scriptlet代码数量，可以达到没有任何scriptlet代码的程序。在我们公司的项目中是不允许有任何的scriptlet代码出现在JSP中。</p>
</li>
<li><p>允许JSP设计工具与WEB应用程序开发的进一步集成。相信不久就会有支持JSTL的IDE开发工具出现。</p>
</li>
</ol>
<hr>
<h3 id="13）什么是-Cookie？Session-和-Cookie-有什么区别？"><a href="#13）什么是-Cookie？Session-和-Cookie-有什么区别？" class="headerlink" title="13）什么是 Cookie？Session 和 Cookie 有什么区别？"></a>13）什么是 Cookie？Session 和 Cookie 有什么区别？</h3><h4 id="Cookie-技术"><a href="#Cookie-技术" class="headerlink" title="Cookie 技术"></a>Cookie 技术</h4><p>Cookie 是一种会话技术，用于将用户的信息保存在客户端上。Cookie 英文直接翻译过来就是小甜品，Cookie 的作用呢，通俗的说就是当一个用户通过 HTTP 访问一个服务器时，这个服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据又被完整地带回给服务器。</p>
<p>这个作用就像是你去超市购物时，第一次给你办了一张购物卡，在这个购物卡里存放了一些你的个人信息，下次你再来这个超市的时候，你就只需要带上你的购物卡，直接购物就好了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-4f73ec86ccc9910c.png" alt=""></p>
<h4 id="Session-技术"><a href="#Session-技术" class="headerlink" title="Session 技术"></a>Session 技术</h4><p>Session：会话，从浏览器打开开始，直到浏览器关闭结束，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。Session 也可以称为会话 Cookie</p>
<ul>
<li>特点：服务端技术，将数据保存在服务器</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-2221c73d7af7149f.png" alt=""></p>
<h4 id="Cookie-与-Session-的区别"><a href="#Cookie-与-Session-的区别" class="headerlink" title="Cookie 与 Session 的区别"></a>Cookie 与 Session 的区别</h4><ul>
<li>Cookie 的数据是存放在客户的浏览器上，Session 数据放在服务器上；</li>
<li>Cookie 不是很安全，别人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗，如果考虑安全问题则应当使用 Session；</li>
<li>Session 会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的资源，所以如果考虑性能问题，则应当使用 Cookie；</li>
<li>单个 Cookie 在客户端的限制是 3k ，就是说一个站点在客户端存放的 Cookie 不能超过 3k。</li>
</ul>
<p><strong>总结：</strong> 将登录信息等重要信息存放为 Session；其他信息如果需要保留，可以存放在 Cookie 中。</p>
<hr>
<h3 id="14）什么是过滤器？"><a href="#14）什么是过滤器？" class="headerlink" title="14）什么是过滤器？"></a>14）什么是过滤器？</h3><p><strong>过滤器就是 Servlet 的高级特性之一，</strong>就是一个具有<strong>拦截/过滤</strong>功能的一个东西，在生活中过滤器可以是香烟滤嘴，滤纸，净水器，空气净化器等，在 Web 中仅仅是一个<strong>实现了 Filter 接口的 Java 类</strong>而已。</p>
<ul>
<li><strong>特点：双向，拦截请求，拦截响应</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-12efda55c17213ff" alt=""></p>
<ul>
<li><strong>作用：</strong><br>过滤器可以对<strong>所有的请求或者响应做拦截操作</strong></li>
</ul>
<hr>
<h3 id="15）为什么在-Web-开发中需要用到过滤器？"><a href="#15）为什么在-Web-开发中需要用到过滤器？" class="headerlink" title="15）为什么在 Web 开发中需要用到过滤器？"></a>15）为什么在 Web 开发中需要用到过滤器？</h3><ul>
<li><strong>问题：</strong>为什么非得使用过滤器，我直接在 Servlet 中作判断不行吗？</li>
<li><strong>开发遵循的原则：</strong><br><strong>1.DRY原则（Don’t Reeat Yourself，不要重复你自己）</strong>：重复，意味着维护的成本很高。<br><strong>2.责任分离原则：</strong>谁擅长什么功能就做什么功能，Servlet 擅长的是逻辑而不是处理请求</li>
</ul>
<p>举一个实际的例子：（处理 POST 请求中文编码的问题）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-c377345013378d2f" alt=""></p>
<ul>
<li><strong>Web 中过滤器的作用：</strong><br><strong>1.可以在请求资源之前设置请求的编码</strong><br><strong>2.可以进行登录校验</strong><br><strong>3.可以进行请求参数的内容的过滤</strong><br><strong>4.数据压缩 / 数据加密 / 数据格式的转换</strong><br>5.可以设置浏览器相关的数据</li>
</ul>
<hr>
<h3 id="16）MVC-模式？"><a href="#16）MVC-模式？" class="headerlink" title="16）MVC 模式？"></a>16）MVC 模式？</h3><p>MVC模式（Model-View-Controller）是<a href="https://link.jianshu.com?t=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fzh.wikipedia.org%2Fwiki%2F%2525E8%2525BD%2525AF%2525E4%2525BB%2525B6%2525E5%2525B7%2525A5%2525E7%2525A8%25258B" target="_blank" rel="noopener">软件工程</a>中的一种<a href="https://link.jianshu.com?t=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fzh.wikipedia.org%2Fwiki%2F%2525E8%2525BD%2525AF%2525E4%2525BB%2525B6%2525E6%25259E%2525B6%2525E6%25259E%252584" target="_blank" rel="noopener">软件架构</a>模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）：</p>
<ul>
<li>Controller——负责转发请求，对请求进行处理</li>
<li>View——负责界面显示</li>
<li>Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现</li>
</ul>
<p>在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-b88fa9a02ba04083" alt=""></p>
<p>1.Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发）<br>2.Controller(Servlet)调用核心业务逻辑——Model部分，获得结果<br>3.Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容<br>4.动态生成的HTML内容返回到浏览器显示</p>
<p>MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</p>
<ul>
<li><em>参考：<a href="https://link.jianshu.com?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F37962386" target="_blank" rel="noopener">知乎@David</a></em></li>
</ul>
<hr>
<h2 id="（二）框架相关知识"><a href="#（二）框架相关知识" class="headerlink" title="（二）框架相关知识"></a>（二）框架相关知识</h2><blockquote>
<p>由于我没有接触和学习过 Hibernate 和 Struts 这两个框架，所以细节方面的东西请读者自行收集…</p>
</blockquote>
<h3 id="1）什么是框架？"><a href="#1）什么是框架？" class="headerlink" title="1）什么是框架？"></a>1）什么是框架？</h3><p>框架是指完成一定功能的半成品。</p>
<p>框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。</p>
<hr>
<h3 id="2）什么是-Spring-？"><a href="#2）什么是-Spring-？" class="headerlink" title="2）什么是 Spring ？"></a>2）什么是 Spring ？</h3><ol>
<li><p><strong>Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架</strong>，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。</p>
</li>
<li><p>Spring 提倡以 <strong>“最少侵入”</strong> 的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring</p>
</li>
</ol>
<ul>
<li><strong>适用范围：任何 Java 应用</strong></li>
<li><strong>Spring 的根本使命：简化 Java 开发</strong></li>
</ul>
<hr>
<h3 id="3）什么是非侵入式设计？"><a href="#3）什么是非侵入式设计？" class="headerlink" title="3）什么是非侵入式设计？"></a>3）什么是非侵入式设计？</h3><p>从框架的角度可以理解为：<strong>无需继承框架提供的任何类</strong><br>这样我们在更换框架时，之前写过的代码几乎可以继续使用。</p>
<hr>
<h3 id="4）Spring-有什么优势？"><a href="#4）Spring-有什么优势？" class="headerlink" title="4）Spring 有什么优势？"></a>4）Spring 有什么优势？</h3><ul>
<li>低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦）</li>
<li>声明式事务管理（基于切面和惯例）</li>
<li>方便集成其他框架（如MyBatis、Hibernate）</li>
<li>降低 Java 开发难度</li>
<li>Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式）</li>
</ul>
<h4 id="Spring-的框架结构"><a href="#Spring-的框架结构" class="headerlink" title="Spring 的框架结构"></a>Spring 的框架结构</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-3b596912f74b3eb5.png" alt=""></p>
<ul>
<li><strong>Data Access/Integration层</strong>包含有JDBC、ORM、OXM、JMS和Transaction模块。</li>
<li><strong>Web层</strong>包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。</li>
<li><strong>AOP模块</strong>提供了一个符合AOP联盟标准的面向切面编程的实现。</li>
<li><strong>Core Container(核心容器)</strong>：包含有Beans、Core、Context和SpEL模块。</li>
<li><strong>Test模块</strong>支持使用JUnit和TestNG对Spring组件进行测试。</li>
</ul>
<hr>
<h3 id="5）Spring-IoC-和-DI-分别是什么？"><a href="#5）Spring-IoC-和-DI-分别是什么？" class="headerlink" title="5）Spring IoC 和 DI 分别是什么？"></a>5）Spring IoC 和 DI 分别是什么？</h3><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><p><strong>IoC：Inverse of Control（控制反转）</strong>，读作 <strong>“反转控制”</strong>，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</p>
<ul>
<li><strong>正控</strong>：若要使用某个对象，需要自己去负责对象的创建</li>
<li><strong>反控</strong>：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架</li>
<li><strong>好莱坞法则</strong>：Don’t call me ,I’ll call you</li>
</ul>
<p><strong>为了便于理解我们这里举一个鲜明的例子：</strong></p>
<p>在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-a1376e28fe8d691d.png" alt=""></p>
<p>然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-3d5876834ed93528.png" alt=""></p>
<p><strong>请注意你并没有“主动”去创造橙汁</strong>，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。</p>
<ul>
<li><strong>总结：</strong> 这就是一种控制反转的理念，上述的例子已经很好的说明了问题，我们再来描述一下控制反转的概念：<strong>控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。</strong></li>
<li><strong>好处：</strong> ① 降低对象之间的耦合；② 我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿）</li>
</ul>
<h4 id="DI：Dependency-Injection（依赖注入）"><a href="#DI：Dependency-Injection（依赖注入）" class="headerlink" title="DI：Dependency Injection（依赖注入）"></a>DI：Dependency Injection（依赖注入）</h4><p>指 Spring 创建对象的过程中，将对象依赖属性（简单值，集合，对象）通过配置设值给该对象</p>
<h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><p>IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，<strong>明确描述了 “被注入对象依赖 IoC 容器配置依赖对象”</strong>。</p>
<p>你也可以简单的理解为：IoC 是目的，是一种思想，而 DI 是手段，是一种设计模式。</p>
<hr>
<h3 id="6）BeanFactory-和-ApplicationContext-的区别"><a href="#6）BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="6）BeanFactory 和 ApplicationContext 的区别"></a>6）BeanFactory 和 ApplicationContext 的区别</h3><p><strong>1.BeanFactory：</strong></p>
<p>是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。在应用中，一般不使用 BeanFactory，而推荐使ApplicationContext（应用上下文），原因如下。</p>
<p><strong>2.ApplicationContext：</strong></p>
<p>⑴. 继承了 BeanFactory，拥有了基本的 IoC 功能；<br>⑵. 除此之外，ApplicationContext 还提供了以下功能：<br>① 支持国际化；② 支持消息机制；③ 支持统一的资源加载；④ 支持AOP功能；</p>
<ul>
<li><strong>注意：</strong> ApplicationContext 和 BeanFactory 相比，最主要的区别在于 BeanFactory 是延迟加载，举个例子：如果 Bean 没有完全注入，BeanFactory 加载后，会在你第一次调用 getBean 方法才会抛出异常；而 ApplicationContext 会在初始化的时候就加载并且检查，这样的好处是可以及时检查依赖是否完全注入；所以通常我们会选择 ApplicationContext。</li>
</ul>
<hr>
<h3 id="7）IoC-是如何实现的"><a href="#7）IoC-是如何实现的" class="headerlink" title="7）IoC 是如何实现的"></a>7）IoC 是如何实现的</h3><p>最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎：</p>
<ol>
<li>读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名</li>
<li>使用反射的API，基于类名实例化对应的对象实例</li>
<li>将对象实例，通过构造函数或者 setter，传递给 JuiceMaker</li>
</ol>
<p>我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！</p>
<blockquote>
<p>引用地址：<a href="https://link.jianshu.com/?t=https%3A%2F%2Fwww.tianmaying.com%2Ftutorial%2Fspring-ioc" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<hr>
<h3 id="8）Spring-配置-Bean-有几种方式？"><a href="#8）Spring-配置-Bean-有几种方式？" class="headerlink" title="8）Spring 配置 Bean 有几种方式？"></a>8）Spring 配置 Bean 有几种方式？</h3><p>在 Spring 中提供了 3 种方法进行配置：</p>
<ul>
<li>在 XML 文件中显式配置</li>
<li>在 Java 的接口和类中实现配置</li>
<li>隐式 Bean 的发现机制和自动装配原则</li>
</ul>
<h4 id="方式选择的原则"><a href="#方式选择的原则" class="headerlink" title="方式选择的原则"></a>方式选择的原则</h4><p>在现实的工作中，这 3 种方式都会被用到，并且在学习和工作之中常常混合使用，所以这里给出一些关于这 3 种优先级的建议：</p>
<p><strong>1.最优先：通过隐式 Bean 的发现机制和自动装配的原则。</strong><br>基于约定由于配置的原则，这种方式应该是最优先的</p>
<ul>
<li>好处：减少程序开发者的决定权，简单又不失灵活。</li>
</ul>
<p><strong>2.其次：Java 接口和类中配置实现配置</strong><br>在没有办法使用自动装配原则的情况下应该优先考虑此类方法</p>
<ul>
<li>好处：避免 XML 配置的泛滥，也更为容易。</li>
<li>典型场景：一个父类有多个子类，比如学生类有两个子类，一个男学生类和女学生类，通过 IoC 容器初始化一个学生类，容器将无法知道使用哪个子类去初始化，这个时候可以使用 Java 的注解配置去指定。</li>
</ul>
<p><strong>3.最后：XML 方式配置</strong><br>在上述方法都无法使用的情况下，那么也只能选择 XML 配置的方式。</p>
<ul>
<li>好处：简单易懂（当然，特别是对于初学者）</li>
<li>典型场景：当使用第三方类的时候，有些类并不是我们开发的，我们无法修改里面的代码，这个时候就通过 XML 的方式配置使用了。</li>
</ul>
<hr>
<h3 id="9）介绍一下-Spring-AOP"><a href="#9）介绍一下-Spring-AOP" class="headerlink" title="9）介绍一下 Spring AOP"></a>9）介绍一下 Spring AOP</h3><p><strong>AOP 即 Aspect Oriented Program 面向切面编程</strong></p>
<p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p>
<ul>
<li><strong>所谓的核心业务</strong>，比如登陆，增加数据，删除数据都叫核心业务</li>
<li><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</li>
</ul>
<p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</p>
<p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫 AOP</p>
<p><strong>还是来举一个鲜明的例子：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-090ef711a0d23033.png" alt=""></p>
<p>在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 AOP 的一个思想：<strong>让关注点代码与业务代码分离！</strong></p>
<hr>
<h3 id="10）Spring-中-Bean-的作用域"><a href="#10）Spring-中-Bean-的作用域" class="headerlink" title="10）Spring 中 Bean 的作用域"></a>10）Spring 中 Bean 的作用域</h3><p><strong>在默认的情况下，Spring IoC 容器只会对一个 Bean 创建一个实例</strong>，但有时候，我们希望能够通过 Spring IoC 容器获取多个实例，我们可以通过 <code>@Scope</code> 注解或者 <code>&lt;bean&gt;</code> 元素中的 <code>scope</code> 属性来设置，例如：</p>
<pre><code>// XML 中设置作用域
&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;prototype&quot; /&gt;
// 使用注解设置作用域
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code></pre><p>Spring 提供了 5 种作用域，它会根据情况来决定是否生成新的对象：</p>
<table>
<thead>
<tr>
<th align="left">作用域类别</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton(单例)</td>
<td align="left">在Spring IoC容器中仅存在一个Bean实例 （默认的scope）</td>
</tr>
<tr>
<td align="left">prototype(多例)</td>
<td align="left">每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean()：不会在容器启动时创建对象</td>
</tr>
<tr>
<td align="left">request(请求)</td>
<td align="left">用于web开发，将Bean放入request范围 ，request.setAttribute(“xxx”) ， 在同一个request 获得同一个Bean</td>
</tr>
<tr>
<td align="left">session(会话)</td>
<td align="left">用于web开发，将Bean 放入Session范围，在同一个Session 获得同一个Bean</td>
</tr>
<tr>
<td align="left">globalSession(全局会话)</td>
<td align="left">一般用于 Porlet 应用环境 , 分布式系统存在全局 session 概念（单点登录），如果不是 porlet 环境，globalSession 等同于 Session</td>
</tr>
</tbody></table>
<p>在开发中主要使用 <code>scope=&quot;singleton&quot;</code>、<code>scope=&quot;prototype&quot;</code>，<strong>对于MVC中的Action使用prototype类型，其他使用singleton</strong>，Spring容器会管理 Action 对象的创建,此时把 Action 的作用域设置为 prototype.</p>
<blockquote>
<p>扩展阅读：<a href="https://blog.csdn.net/u013803262/article/details/62416880" target="_blank" rel="noopener">@Profile 注解</a> 、 <a href="https://blog.csdn.net/tinydolphin/article/details/76253771" target="_blank" rel="noopener">条件化装配 Bean</a></p>
</blockquote>
<hr>
<h3 id="11）Spring-面试问答-Top-25"><a href="#11）Spring-面试问答-Top-25" class="headerlink" title="11）Spring 面试问答 Top 25"></a>11）Spring 面试问答 Top 25</h3><blockquote>
<p>更多戳这里：<a href="http://www.importnew.com/15851.html#beanfactory_vs_applicationcontext" target="_blank" rel="noopener">Spring面试问答Top 25</a></p>
</blockquote>
<hr>
<h3 id="12）Spring-MVC-的请求流程"><a href="#12）Spring-MVC-的请求流程" class="headerlink" title="12）Spring MVC 的请求流程"></a>12）Spring MVC 的请求流程</h3><p>每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-a2efb6ad667d06e0.png" alt=""></p>
<h4 id="第一站：DispatcherServlet"><a href="#第一站：DispatcherServlet" class="headerlink" title="第一站：DispatcherServlet"></a>第一站：DispatcherServlet</h4><p>从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。</p>
<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;!-- 拦截所有的请求 --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre><ul>
<li><strong>DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。</strong></li>
</ul>
<h4 id="第二站：处理器映射（HandlerMapping）"><a href="#第二站：处理器映射（HandlerMapping）" class="headerlink" title="第二站：处理器映射（HandlerMapping）"></a>第二站：处理器映射（HandlerMapping）</h4><ul>
<li><strong>问题：</strong>典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？</li>
</ul>
<p>所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会<strong>根据请求所携带的 URL 信息来进行决策</strong>，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理：</p>
<pre><code>&lt;bean id=&quot;simpleUrlHandlerMapping&quot;
      class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;props&gt;
            &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;
            &lt;prop key=&quot;/hello&quot;&gt;helloController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt;</code></pre><h4 id="第三站：控制器"><a href="#第三站：控制器" class="headerlink" title="第三站：控制器"></a>第三站：控制器</h4><p>一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ModelAndView <span class="token function">handleRequest</span><span class="token punctuation">(</span>javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletRequest httpServletRequest<span class="token punctuation">,</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletResponse httpServletResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 处理逻辑</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="第四站：返回-DispatcherServlet"><a href="#第四站：返回-DispatcherServlet" class="headerlink" title="第四站：返回 DispatcherServlet"></a>第四站：返回 DispatcherServlet</h4><p>当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为<strong>模型（Model）</strong>。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个<strong>视图（view）</strong>，通常会是 JSP。</p>
<p>控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名<strong>（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ModelAndView <span class="token function">handleRequest</span><span class="token punctuation">(</span>javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletRequest httpServletRequest<span class="token punctuation">,</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletResponse httpServletResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 处理逻辑</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">// 返回给 DispatcherServlet</span>
    <span class="token keyword">return</span> mav<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="第五站：视图解析器"><a href="#第五站：视图解析器" class="headerlink" title="第五站：视图解析器"></a>第五站：视图解析器</h4><p>这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，<strong>它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。</strong></p>
<p>DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP</p>
<blockquote>
<p>上面的例子是直接绑定到了 index.jsp 视图</p>
</blockquote>
<h4 id="第六站：视图"><a href="#第六站：视图" class="headerlink" title="第六站：视图"></a>第六站：视图</h4><p>既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。</p>
<p>它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;

&lt;h1&gt;${message}&lt;/h1&gt;</code></pre><blockquote>
<p>更多 Spring-MVC 内容：<a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">Spring MVC【入门】就这一篇
</a></p>
</blockquote>
<hr>
<h3 id="13）什么是-ORM？"><a href="#13）什么是-ORM？" class="headerlink" title="13）什么是 ORM？"></a>13）什么是 ORM？</h3><p>对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；</p>
<p>简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。</p>
<hr>
<h3 id="14）为什么要使用-MyBatis-？"><a href="#14）为什么要使用-MyBatis-？" class="headerlink" title="14）为什么要使用 MyBatis ？"></a>14）为什么要使用 MyBatis ？</h3><p>在我们<strong>传统的 JDBC</strong> 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。</p>
<p>而我们在使用了 <strong>MyBatis</strong> 之后，<strong>只需要提供 SQL 语句就好了</strong>，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，<strong>我们的关注点于是可以就此集中在 SQL 语句上</strong>，关注在增删改查这些操作层面上。</p>
<p>并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<hr>
<h3 id="15）MyBatis-中占位符-和-的区别"><a href="#15）MyBatis-中占位符-和-的区别" class="headerlink" title="15）MyBatis 中占位符 # 和 $ 的区别"></a>15）MyBatis 中占位符 <code>#</code> 和 <code>$</code> 的区别</h3><p>区别如下：</p>
<ol>
<li><code>#</code>符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号</li>
<li><code>$</code>符号将传入的数据直接显示生成SQL中。</li>
<li><code>#</code>符号存在预编译的过程，，对问号赋值，防止SQL注入。</li>
<li><code>$</code>符号是直译的方式，一般用在orderby {列名} 语句中。</li>
<li>能用<code>#</code>号就不要用<code>$</code>符号</li>
</ol>
<hr>
<h3 id="16）MyBatis-缓存结构"><a href="#16）MyBatis-缓存结构" class="headerlink" title="16）MyBatis 缓存结构"></a>16）MyBatis 缓存结构</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-6160d3feb1200ab1.png" alt=""></p>
<p>在 Web 系统中，最重要的操作就是查询数据库中的数据。但是有些时候查询数据的频率非常高，这是很耗费数据库资源的，往往会导致数据库查询效率极低，影响客户的操作体验。于是我们可以将一些变动不大且访问频率高的数据，放置在一个缓存容器中，用户下一次查询时就从缓存容器中获取结果。</p>
<ul>
<li>MyBatis 拥有自己的缓存结构，可以用来缓解数据库压力，加快查询速度。</li>
<li>MyBatis 一级缓存是一个 SqlSession 级别，同一个 SqlSession 只能访问自己的一级缓存的数据</li>
<li>二级缓存是跨sqlSession，是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession是可以共享的。</li>
</ul>
<blockquote>
<p>更多深入MyBatis的内容戳这里：<a href="https://www.jianshu.com/p/76d35d939539" target="_blank" rel="noopener">MyBatis(2)——MyBatis 深入学习</a></p>
</blockquote>
<hr>
<h3 id="17）MyBatis-与-Spring-整合"><a href="#17）MyBatis-与-Spring-整合" class="headerlink" title="17）MyBatis 与 Spring 整合"></a>17）MyBatis 与 Spring 整合</h3><blockquote>
<p>戳这里：<a href="https://www.jianshu.com/p/412051d41d73" target="_blank" rel="noopener">MyBatis 与 Spring 整合</a></p>
</blockquote>
<hr>
<h3 id="18）IDEA-整合-SSM-框架学习"><a href="#18）IDEA-整合-SSM-框架学习" class="headerlink" title="18）IDEA 整合 SSM 框架学习"></a>18）IDEA 整合 SSM 框架学习</h3><blockquote>
<p>戳这里<a href="https://www.jianshu.com/p/3098050b0d14" target="_blank" rel="noopener">IDEA 整合 SSM 框架学习</a></p>
</blockquote>
<hr>
<h3 id="19）MVC-三种模式"><a href="#19）MVC-三种模式" class="headerlink" title="19）MVC 三种模式"></a>19）MVC 三种模式</h3><p>在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 <strong>Model1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-7b3f9cd59394b017.png" alt=""></p>
<ul>
<li><strong>出现的弊端：</strong></li>
<li>JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</li>
<li>要求开发者不仅要掌握 Java ，还要有高超的前端水平</li>
<li>前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</li>
<li>代码难以复用</li>
</ul>
<p>正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型<strong>（Model2）</strong>就像下图这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-403a273b08fec826.png" alt=""></p>
<p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p>
<ul>
<li><strong>M 代表 模型（Model）</strong><br>模型是什么呢？ 模型就是数据，就是 dao,bean</li>
<li><strong>V 代表 视图（View）</strong><br>视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</li>
<li><strong>C 代表 控制器（controller)</strong><br>控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</li>
</ul>
<blockquote>
<p>扩展阅读：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483775&idx=1&sn=c9d7ead744c6e0c3ab2fe55c09bbe61f&chksm=ebd7407edca0c9688f3870d895b760836101271b912899821fb35c5704fe215da2fc5daff2f9#rd" target="_blank" rel="noopener">Web开发模式</a></p>
</blockquote>
<h4 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h4><p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Web%E7%AF%87/7896890-a25782fb05f315de.png" alt=""></p>
<p><strong>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。</strong>在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。</p>
<ul>
<li><strong>特点：</strong><br>结构松散，几乎可以在 Spring MVC 中使用各类视图<br>松耦合，各个模块分离<br>与 Spring 无缝集成</li>
</ul>
<hr>
<h3 id="20）分页？"><a href="#20）分页？" class="headerlink" title="20）分页？"></a>20）分页？</h3><blockquote>
<p>戳这里：<a href="https://www.jianshu.com/p/d108d0cd9acf" target="_blank" rel="noopener">Java Web -【分页功能】详解</a></p>
</blockquote>
<hr>
<h3 id="21）什么是-Spring-Boot-？"><a href="#21）什么是-Spring-Boot-？" class="headerlink" title="21）什么是 Spring Boot ？"></a>21）什么是 Spring Boot ？</h3><ul>
<li>它使用 <strong>“习惯优于配置”</strong> （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。</li>
<li>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.ityouknow.com%2Fspringboot%2F2016%2F01%2F06%2Fspringboot%28%25E4%25B8%2580%29-%25E5%2585%25A5%25E9%2597%25A8%25E7%25AF%2587.html" target="_blank" rel="noopener">springboot(一)：入门篇——纯洁的微笑</a>）</li>
</ul>
<hr>
<h3 id="22）使用-Spring-Boot-有什么好处？"><a href="#22）使用-Spring-Boot-有什么好处？" class="headerlink" title="22）使用 Spring Boot 有什么好处？"></a>22）使用 Spring Boot 有什么好处？</h3><p>回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：</p>
<ul>
<li>1）配置 web.xml，加载 spring 和 spring mvc</li>
<li>2）配置数据库连接、配置日志文件</li>
<li>3）配置家在配置文件的读取，开启注解</li>
<li>4）配置mapper文件</li>
<li>…..</li>
</ul>
<p>而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了…</p>
<ul>
<li>划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。</li>
</ul>
<blockquote>
<p>Spring Boot 由于笔者还没有深入学习..所以细节部分请读者自行收集…</p>
</blockquote>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/21/java-mian-shi-zhi-shi-dian-jie-xi-liu-shu-ju-ku-pian/">
      Java面试知识点解析(六)——数据库篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月21日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<p><a href="https://www.jianshu.com/p/9c50729464b5" target="_blank" rel="noopener">Java 面试知识点解析(四)——版本特性篇</a></p>
<p><a href="https://www.jianshu.com/p/210f85108c52" target="_blank" rel="noopener">Java 面试知识点解析(五)——网络协议篇</a></p>
<hr>
<blockquote>
<p>前排引用说明及好文推荐：<a href="https://blog.csdn.net/justloveyou_/article/details/78308460" target="_blank" rel="noopener">面试/笔试第三弹 —— 数据库面试问题集锦</a>、<a href="https://segmentfault.com/a/1190000013517914" target="_blank" rel="noopener">数据库常见面试题(开发者篇)</a></p>
</blockquote>
<h3 id="1）什么是存储过程？有哪些优缺点？"><a href="#1）什么是存储过程？有哪些优缺点？" class="headerlink" title="1）什么是存储过程？有哪些优缺点？"></a>1）什么是存储过程？有哪些优缺点？</h3><p><strong>存储过程就像是编程语言中的函数一样，封装了我们的代码（PLSQL，T-SQL）</strong></p>
<p>例如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-------------创建名为GetUserAccount的存储过程----------------</span>
<span class="token keyword">create</span> <span class="token keyword">Procedure</span> GetUserAccount
<span class="token keyword">as</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> UserAccount
go

<span class="token comment" spellcheck="true">-------------执行上面的存储过程----------------</span>
<span class="token keyword">exec</span> GetUserAccount</code></pre>
<p>存储过程的优点：</p>
<ul>
<li><strong>能够将代码封装起来</strong></li>
<li><strong>保存在数据库之中</strong></li>
<li><strong>让编程语言进行调用</strong></li>
<li><strong>存储过程是一个预编译的代码块，执行效率比较高</strong></li>
<li><strong>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</strong></li>
</ul>
<p>存储过程的缺点：</p>
<ul>
<li><strong>每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）</strong></li>
<li><strong>业务逻辑放在数据库上，难以迭代</strong></li>
</ul>
<hr>
<h3 id="2）三大范式"><a href="#2）三大范式" class="headerlink" title="2）三大范式"></a>2）三大范式</h3><blockquote>
<ul>
<li>思考这样的一个例子：</li>
</ul>
</blockquote>
<p>我们现在需要建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号（Sno）、所在系（Sdept）、系主任姓名（Mname）、课程号（Cno）和成绩（Grade），假设我们使用单一的关系模式 Student 来表示，那么根据现实世界已知的信息，会描述成以下这个样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-344feccbb3cb1fad.png" alt=""></p>
<p>但是，这个关系模式存在以下问题：</p>
<p><strong>（1） 数据冗余</strong><br>比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，这将浪费大量的存储空间。<br><strong>（2）更新异常（update anomalies）</strong><br>由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。比如，某系更换系主任后，必须修改与该系学生有关的每一个元组。<br><strong>（3）插入异常（insertion anomalies）</strong><br>如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。<br><strong>（4）删除异常（deletion anomalies）</strong><br>如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢失了。</p>
<ul>
<li><strong>总结：</strong> 所以，我们在设计数据库的时候，就需要满足一定的规范要求，而满足不同程度要求的就是不同的范式。</li>
</ul>
<blockquote>
<ul>
<li><strong>第一范式：</strong> 列不可分</li>
</ul>
</blockquote>
<p>1NF（第一范式）是对属性具有<strong>原子性</strong>的要求，不可再分，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-7a54e7d5d8fbf659.png" alt=""></p>
<p>如果认为最后一列还可以再分成出生年，出生月，出生日，则它就不满足第一范式的要求。</p>
<blockquote>
<ul>
<li><strong>第二范式：</strong> 消除非主属性对码的部分函数依赖</li>
</ul>
</blockquote>
<p>2NF（第二范式）是对记录有<strong>唯一性</strong>的要求，即实体的唯一性，不存在部分依赖，每一列与主键都相关，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-a10fdbaf10a7e6b8.png" alt=""></p>
<p>该表明显说明了两个事物：学生信息和课程信息；正常的依赖应该是：学分依赖课程号，姓名依赖学号，但这里存在非主键字段对码的部分依赖，即与主键不相关，不满足第二范式的要求。</p>
<p><strong>可能存在的问题：</strong></p>
<ul>
<li><strong>数据冗余</strong>：每条记录都含有相同信息；</li>
<li><strong>删除异常</strong>：删除所有学生成绩，就把课程信息全删除了；</li>
<li><strong>插入异常</strong>：学生未选课，无法记录进数据库；</li>
<li><strong>更新异常</strong>：调整课程学分，所有行都调整。</li>
</ul>
<p><strong>正确的做法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-fba36ca283ffd5fc.png" alt=""></p>
<blockquote>
<ul>
<li><strong>第三范式：</strong> 消除非主属性对码的传递函数依赖</li>
</ul>
</blockquote>
<p>3NF（第三范式）对字段有<strong>冗余性</strong>的要求，任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在依赖传递，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-8d7548eb839bc8db.png" alt=""></p>
<p>很明显，学院电话是一个冗余字段，因为存在依赖传递：（学号）→（学生）→（学院）→（学院电话）</p>
<p><strong>可能会存在的问题：</strong></p>
<ul>
<li><strong>数据冗余</strong>：有重复值；</li>
<li><strong>更新异常</strong>：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。</li>
</ul>
<p><strong>正确的做法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-83c0288ea9150976.png" alt=""></p>
<hr>
<h3 id="3）数据库索引"><a href="#3）数据库索引" class="headerlink" title="3）数据库索引"></a>3）数据库索引</h3><blockquote>
<ul>
<li>什么是索引？</li>
</ul>
</blockquote>
<p><strong>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。</strong></p>
<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 </p>
<blockquote>
<ul>
<li>底层数据结构是什么，为什么使用这种数据结构？</li>
</ul>
</blockquote>
<p><strong>（1）底层数据结构是B+树：</strong><br>在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。</p>
<p><strong>（2）使用B+树的原因：</strong><br>查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（此时，你应该在白纸上画出什么是B+树）</p>
<blockquote>
<ul>
<li>索引的分类？</li>
</ul>
</blockquote>
<ul>
<li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li>
<li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li>
<li><strong>聚集索引(Clustered)</strong>：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
<li><strong>非聚集索引(Non-clustered)</strong>：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</li>
</ul>
<blockquote>
<ul>
<li>索引的优缺点？</li>
</ul>
</blockquote>
<p><strong>（1）优点：</strong></p>
<ul>
<li><strong>大大加快数据的检索速度</strong>，这也是创建索引的最主要的原因；</li>
<li>加速表和表之间的连接；</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>
</ul>
<p><strong>（2）缺点：</strong></p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<blockquote>
<ul>
<li>什么样的字段适合创建索引？</li>
</ul>
</blockquote>
<ul>
<li>经常作查询选择的字段</li>
<li>经常作表连接的字段</li>
<li>经常出现在order by, group by, distinct 后面的字段</li>
</ul>
<blockquote>
<ul>
<li>创建索引时需要注意什么？</li>
</ul>
</blockquote>
<ul>
<li><p><strong>非空字段</strong>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
</li>
<li><p><strong>取值离散大的字段</strong>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>
</li>
<li><p><strong>索引字段越小越好</strong>：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>
</li>
</ul>
<hr>
<h3 id="4）听说过事务吗？（必考）"><a href="#4）听说过事务吗？（必考）" class="headerlink" title="4）听说过事务吗？（必考）"></a>4）听说过事务吗？（必考）</h3><p><strong>事务简单来说：一个 Session 中所进行所有的操作，要么同时成功，要么同时失败</strong>；作为单个逻辑工作单元执行的一系列操作，满足四大特性：</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行</li>
<li>一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li>持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存</li>
</ol>
<blockquote>
<ul>
<li>实例说明：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
 * 我们来模拟A向B账号转账的场景
 *   A和B账户都有1000块，现在我让A账户向B账号转500块钱
 *
 **/</span>
<span class="token comment" spellcheck="true">//JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题</span>

<span class="token comment" spellcheck="true">//A账户减去500块</span>
String sql <span class="token operator">=</span> <span class="token string">"UPDATE a SET money=money-500 "</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//B账户多了500块</span>
String sql2 <span class="token operator">=</span> <span class="token string">"UPDATE b SET money=money+500"</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>从上面看，我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A账户减去500块</span>
String sql <span class="token operator">=</span> <span class="token string">"UPDATE a SET money=money-500 "</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 这里模拟出现问题</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>

String sql2 <span class="token operator">=</span> <span class="token string">"UPDATE b SET money=money+500"</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>显然，上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。</p>
<p>我们可以通过事务来解决上面出现的问题：</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 开启事务,对数据的操作就不会立即生效。</span>
    connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// A账户减去500块</span>
    String sql <span class="token operator">=</span> <span class="token string">"UPDATE a SET money=money-500 "</span><span class="token punctuation">;</span>
    preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
    preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 在转账过程中出现问题</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// B账户多500块</span>
    String sql2 <span class="token operator">=</span> <span class="token string">"UPDATE b SET money=money+500"</span><span class="token punctuation">;</span>
    preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 如果程序能执行到这里，没有抛出异常，我们就提交数据</span>
    connection<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 关闭事务【自动提交】</span>
    connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>SQLException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】</span>
        connection<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 关闭事务【自动提交】</span>
        connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。</p>
<ul>
<li><strong>注意</strong>：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。</li>
</ul>
<hr>
<h3 id="5）事务的并发问题有哪几种？"><a href="#5）事务的并发问题有哪几种？" class="headerlink" title="5）事务的并发问题有哪几种？"></a>5）事务的并发问题有哪几种？</h3><ol>
<li>丢失更新：一个事务的更新覆盖了另一个事务的更新；</li>
<li>脏读：一个事务读取了另一个事务未提交的数据；</li>
<li>不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；</li>
<li>幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。</li>
</ol>
<hr>
<h3 id="6）事务的隔离级别有哪几种？"><a href="#6）事务的隔离级别有哪几种？" class="headerlink" title="6）事务的隔离级别有哪几种？"></a>6）事务的隔离级别有哪几种？</h3><p>隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是：</p>
<ol>
<li><p>读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题；</p>
</li>
<li><p>读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题；</p>
</li>
<li><p>可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。 </p>
</li>
<li><p>序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。</p>
</li>
</ol>
<p><strong>MySQL默认的隔离级别是可重复读（REPEATABLE READ）</strong></p>
<blockquote>
<ul>
<li>MySql 的事务支持</li>
</ul>
</blockquote>
<p>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：</p>
<ul>
<li>MyISAM：不支持事务，用于只读程序提高性能；</li>
<li>InnoDB：支持ACID事务、行级锁、并发；</li>
<li>Berkeley DB：支持事务。</li>
</ul>
<hr>
<h3 id="7）什么是视图？以及视图的使用场景有哪些？"><a href="#7）什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="7）什么是视图？以及视图的使用场景有哪些？"></a>7）什么是视图？以及视图的使用场景有哪些？</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>如下两种场景一般会使用到视图：</p>
<ol>
<li>不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。</li>
</ol>
<p><strong>注意</strong>：这个视图是在数据库中创建的 而不是用代码创建的。</p>
<hr>
<h3 id="8）drop-delete与truncate的区别？"><a href="#8）drop-delete与truncate的区别？" class="headerlink" title="8）drop,delete与truncate的区别？"></a>8）drop,delete与truncate的区别？</h3><p>drop 直接删除表；truncate 删除表中数据，再插入时自增长id又从1开始 ；delete 删除表中数据，可以加where字句。</p>
<blockquote>
<ul>
<li><strong>drop table：</strong></li>
</ul>
</blockquote>
<ul>
<li>属于DDL（Data Definition Language，数据库定义语言）</li>
<li>不可回滚</li>
<li>不可带 where</li>
<li>表内容和结构删除</li>
<li>删除速度快</li>
</ul>
<blockquote>
<ul>
<li><strong>truncate table：</strong></li>
</ul>
</blockquote>
<ul>
<li>属于DDL（Data Definition Language，数据库定义语言）</li>
<li>不可回滚</li>
<li>不可带 where</li>
<li>表内容删除</li>
<li>删除速度快</li>
</ul>
<blockquote>
<ul>
<li><strong>delete from：</strong></li>
</ul>
</blockquote>
<ul>
<li>属于DML</li>
<li>可回滚</li>
<li>可带where</li>
<li>表结构在，表内容要看where执行的情况</li>
<li>删除速度慢,需要逐行删除</li>
</ul>
<blockquote>
<ul>
<li><strong>使用简要说明：</strong></li>
</ul>
</blockquote>
<ul>
<li>不再需要一张表的时候，用drop</li>
<li>想删除部分数据行时候，用delete，并且带上where子句</li>
<li>保留表而删除所有数据的时候用truncate</li>
</ul>
<hr>
<h3 id="9）触发器的作用？"><a href="#9）触发器的作用？" class="headerlink" title="9）触发器的作用？"></a>9）触发器的作用？</h3><p>触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。</p>
<hr>
<h3 id="10）数据库的乐观锁和悲观锁是什么？"><a href="#10）数据库的乐观锁和悲观锁是什么？" class="headerlink" title="10）数据库的乐观锁和悲观锁是什么？"></a>10）数据库的乐观锁和悲观锁是什么？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 </p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<blockquote>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
</ul>
</blockquote>
<p>悲观锁是一种利用数据库内部机制提供的锁的方式，也就是对更新的数据加锁，这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了，这就是悲观锁的实现方式。</p>
<p><strong>MySQL InnoDB中使用悲观锁：</strong></p>
<p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0; </p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">//0.开始事务</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//1.查询出商品信息</span>
<span class="token keyword">select</span> <span class="token keyword">status</span> <span class="token keyword">from</span> t_goods <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//2.根据商品信息生成订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t_orders <span class="token punctuation">(</span>id<span class="token punctuation">,</span>goods_id<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//3.修改商品status为2</span>
<span class="token keyword">update</span> t_goods <span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//4.提交事务</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">commit</span> <span class="token keyword">work</span><span class="token punctuation">;</span></code></pre>
<p>上面的查询语句中，我们使用了 <code>select…for update</code> 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<p>上面我们提到，使用 <code>select…for update</code> 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>
<p><strong>优点与不足：</strong></p>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
<blockquote>
<ul>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
</ul>
</blockquote>
<p>乐观锁是一种不会阻塞其他线程并发的控制，它不会使用数据库的锁进行实现，它的设计里面由于不阻塞其他线程，所以并不会引起线程频繁挂起和恢复，这样便能够提高并发能力，所以也有人把它称为非阻塞锁。一般的实现乐观锁的方式就是记录数据版本。</p>
<p>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
<p><strong>使用版本号实现乐观锁：</strong></p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">.</span>查询出商品信息
<span class="token keyword">select</span> <span class="token punctuation">(</span><span class="token keyword">status</span><span class="token punctuation">,</span><span class="token keyword">status</span><span class="token punctuation">,</span>version<span class="token punctuation">)</span> <span class="token keyword">from</span> t_goods <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span>
<span class="token number">2</span><span class="token punctuation">.</span>根据商品信息生成订单
<span class="token number">3</span><span class="token punctuation">.</span>修改商品<span class="token keyword">status</span>为<span class="token number">2</span>
<span class="token keyword">update</span> t_goods 
<span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id} and version=#{version};</span></code></pre>
<p><strong>优点与不足：</strong></p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<blockquote>
<p>参考文章：<a href="http://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></p>
</blockquote>
<hr>
<h3 id="11）超键、候选键、主键、外键分别是什么？"><a href="#11）超键、候选键、主键、外键分别是什么？" class="headerlink" title="11）超键、候选键、主键、外键分别是什么？"></a>11）超键、候选键、主键、外键分别是什么？</h3><ul>
<li><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
</li>
<li><p>候选键（候选码）：是最小超键，即没有冗余元素的超键。</p>
</li>
<li><p>主键（主码）：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
</li>
<li><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
</li>
</ul>
<p><strong>候选码和主码：</strong></p>
<p>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）</p>
<ul>
<li><strong>它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}</strong></li>
<li><strong>如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键)</strong></li>
</ul>
<hr>
<h3 id="12）SQL-约束有哪几种？"><a href="#12）SQL-约束有哪几种？" class="headerlink" title="12）SQL 约束有哪几种？"></a>12）SQL 约束有哪几种？</h3><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<hr>
<h3 id="13）MySQL存储引擎中的MyISAM和InnoDB区别详解"><a href="#13）MySQL存储引擎中的MyISAM和InnoDB区别详解" class="headerlink" title="13）MySQL存储引擎中的MyISAM和InnoDB区别详解"></a>13）MySQL存储引擎中的MyISAM和InnoDB区别详解</h3><p>在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，其由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然MyISAM性能极佳，但却有一个显著的缺点： <strong>不支持事务处理</strong>。不过，MySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p>
<p>InnoDB是MySQL的数据库引擎之一，其由Innobase oy公司所开发，2006年五月由甲骨文公司并购。与传统的ISAM、MyISAM相比，<strong>InnoDB的最大特色就是支持ACID兼容的事务功能</strong>，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。具体地，MyISAM与InnoDB作为MySQL的两大存储引擎的差异主要包括：</p>
<ul>
<li><p><strong>存储结构</strong>：每个MyISAM在磁盘上存储成三个文件：第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
</li>
<li><p><strong>存储空间</strong>：MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
</li>
<li><p><strong>可移植性、备份及恢复</strong>：MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
</li>
<li><p><strong>事务支持</strong>：MyISAM强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。</p>
</li>
<li><p><strong>AUTO_INCREMENT</strong>：在MyISAM中，可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引，并且引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p>
</li>
<li><p><strong>表锁差异</strong>：MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
</li>
<li><p><strong>全文索引</strong>：MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p>
</li>
<li><p><strong>表主键</strong>：MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
</li>
<li><p><strong>表的具体行数</strong>：MyISAM保存表的总行数，select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p>
</li>
<li><p><strong>CURD操作</strong>：在MyISAM中，如果执行大量的SELECT，MyISAM是更好的选择。对于InnoDB，如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p>
</li>
<li><p><strong>外键</strong>：MyISAM不支持外键，而InnoDB支持外键。</p>
</li>
</ul>
<p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁、外键等等。尤其在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，必须需要注意的是，任何一种表都不是万能的，合适的才是最好的，才能最大的发挥MySQL的性能优势。如果是不复杂的、非关键的Web应用，还是可以继续考虑MyISAM的，这个具体情况具体考虑。</p>
<hr>
<h3 id="14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"><a href="#14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？" class="headerlink" title="14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"></a>14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？</h3><p>答案:都是B+树!</p>
<p>MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，<strong>只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。</strong></p>
<p>Innodb引擎的索引的数据结构也是B+树，<strong>只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。</strong></p>
<hr>
<h3 id="15）varchar和char的区别"><a href="#15）varchar和char的区别" class="headerlink" title="15）varchar和char的区别"></a>15）varchar和char的区别</h3><p>char是一种固定长度的类型，varchar是一种可变长度的类型，例如：</p>
<p>定义一个char[10]和varchar[10]，如果存进去的是 ‘test’，那么char所占的长度依然为10，除了字符 ‘test’ 外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的</p>
<p>char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储于查找</p>
<p>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。</p>
<p>varchar是以空间效率为首位。</p>
<p>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</p>
<p>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。<br>两者的存储数据都非unicode的字符数据。</p>
<hr>
<h3 id="16）主键、自增主键、主键索引与唯一索引概念区别"><a href="#16）主键、自增主键、主键索引与唯一索引概念区别" class="headerlink" title="16）主键、自增主键、主键索引与唯一索引概念区别"></a>16）主键、自增主键、主键索引与唯一索引概念区别</h3><ol>
<li><p>主键：指字段 <strong>唯一、不为空值</strong> 的列；</p>
</li>
<li><p>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</p>
</li>
<li><p>自增主键：字段类型为数字、自增、并且是主键；</p>
</li>
<li><p>唯一索引：索引列的值必须唯一，但允许有空值。<strong>主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</strong></p>
</li>
</ol>
<hr>
<h3 id="17）主键就是聚集索引吗？主键和索引有什么区别？"><a href="#17）主键就是聚集索引吗？主键和索引有什么区别？" class="headerlink" title="17）主键就是聚集索引吗？主键和索引有什么区别？"></a>17）主键就是聚集索引吗？主键和索引有什么区别？</h3><p><strong>主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。</strong>在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。</p>
<hr>
<h3 id="18）实践中如何优化MySQL"><a href="#18）实践中如何优化MySQL" class="headerlink" title="18）实践中如何优化MySQL"></a>18）实践中如何优化MySQL</h3><p>实践中，MySQL的优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-7a6deca3ebd226e3.png" alt=""></p>
<h4 id="⑴-SQL语句优化："><a href="#⑴-SQL语句优化：" class="headerlink" title="⑴ SQL语句优化："></a>⑴ SQL语句优化：</h4><p>SQL语句的优化主要包括三个问题，即如何发现有问题的SQL、如何分析SQL的执行计划以及如何优化SQL，下面将逐一解释。</p>
<p><strong>① 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）</strong></p>
<p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-79123c126bb94a31.png" alt=""></p>
<p>通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。</p>
<p><strong>② 通过explain查询和分析SQL的执行计划：</strong></p>
<p>使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。</p>
<p><strong>③ SQL语句的优化：</strong></p>
<p><strong>⒈优化insert语句：一次插入多值；</strong></p>
<p><strong>⒉应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描；</strong></p>
<p><strong>⒊应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；</strong></p>
<p><strong>⒋优化嵌套查询：子查询可以被更有效率的连接(Join)替代；</strong></p>
<p><strong>⒌很多时候用 exists 代替 in 是一个好的选择。</strong></p>
<p><strong>⒍选择最有效率的表名顺序：数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p>
<p>在FROM子句中包含多个表的情况下：</p>
<ul>
<li>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</li>
<li>也就是说：选择记录条数最少的表放在最后</li>
</ul>
<p>如果有3个以上的表连接查询：</p>
<ul>
<li>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。</li>
<li>也就是说：被其他表所引用的表放在最后</li>
</ul>
<p><strong>⒎用IN代替OR：</strong></p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">=</span> <span class="token number">1500</span> <span class="token operator">or</span> sal <span class="token operator">=</span> <span class="token number">3000</span> <span class="token operator">or</span> sal <span class="token operator">=</span> <span class="token number">800</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>⒏SELECT子句中避免使用*号：</strong></p>
<p>我们最开始接触 SQL 的时候，“<code>*</code>” 号是可以获取表中全部的字段数据的，<strong>但是它要通过查询数据字典完成，这意味着将消耗更多的时间</strong>，而且使用 “<code>*</code>” 号写出来的 SQL 语句也不够直观。</p>
<hr>
<h4 id="⑵-索引优化："><a href="#⑵-索引优化：" class="headerlink" title="⑵ 索引优化："></a>⑵ 索引优化：</h4><p>建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在 order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形：</p>
<ul>
<li><p>以 “%(表示任意0个或多个字符)” 开头的 LIKE 语句，模糊匹配；</p>
</li>
<li><p>OR语句前后没有同时使用索引；</p>
</li>
<li><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</p>
</li>
<li><p>对于多列索引，必须满足最左匹配原则(eg,多列索引col1、col2和col3，则 索引生效的情形包括col1或col1，col2或col1，col2，col3)。</p>
</li>
</ul>
<hr>
<h4 id="⑶-数据库表结构的优化："><a href="#⑶-数据库表结构的优化：" class="headerlink" title="⑶ 数据库表结构的优化："></a>⑶ 数据库表结构的优化：</h4><p><strong>① 选择合适数据类型：</strong></p>
<ul>
<li>使用较小的数据类型解决问题；</li>
<li>使用简单的数据类型(mysql处理int要比varchar容易)；</li>
<li>尽可能的使用not null 定义字段；</li>
<li>尽量避免使用text类型，非用不可时最好考虑分表；</li>
</ul>
<p><strong>② 表的范式的优化：</strong></p>
<p>一般情况下，表的设计应该遵循三大范式。</p>
<p><strong>③ 表的垂直拆分：</strong></p>
<p>把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：</p>
<ul>
<li>把不常用的字段单独放在同一个表中；</li>
<li>把大字段独立放入一个表中；</li>
<li>把经常使用的字段放在一起； </li>
</ul>
<p>这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单</p>
<p><strong>④ 表的水平拆分：</strong></p>
<p>表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：</p>
<ul>
<li>对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；</li>
<li>针对不同的hashID将数据存入不同的表中；</li>
</ul>
<p>表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处：</p>
<ul>
<li>表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；</li>
<li>表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</li>
<li>需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)。</li>
</ul>
<hr>
<h4 id="⑷-系统配置的优化："><a href="#⑷-系统配置的优化：" class="headerlink" title="⑷ 系统配置的优化："></a>⑷ 系统配置的优化：</h4><ul>
<li><p>操作系统配置的优化：增加TCP支持的队列数</p>
</li>
<li><p>mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances）</p>
</li>
</ul>
<hr>
<h4 id="⑸-硬件的优化："><a href="#⑸-硬件的优化：" class="headerlink" title="⑸ 硬件的优化："></a>⑸ 硬件的优化：</h4><ul>
<li>CPU：核心数多并且主频高的</li>
<li>内存：增大内存</li>
<li>磁盘配置和选择：磁盘性能</li>
</ul>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/18/java-mian-shi-zhi-shi-dian-jie-xi-wu-wang-luo-xie-yi-pian/">
      Java面试知识点解析(五)——网络协议篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月18日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<p><a href="https://www.jianshu.com/p/9c50729464b5" target="_blank" rel="noopener">Java 面试知识点解析(四)——版本特性篇</a></p>
<hr>
<blockquote>
<p>前排引用说明及好文推荐：<a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">面试/笔试第一弹 —— 计算机网络面试问题集锦——书呆子Rico</a></p>
</blockquote>
<h2 id="（一）网络基础知识"><a href="#（一）网络基础知识" class="headerlink" title="（一）网络基础知识"></a>（一）网络基础知识</h2><h3 id="1）Http和Https的区别？"><a href="#1）Http和Https的区别？" class="headerlink" title="1）Http和Https的区别？"></a>1）Http和Https的区别？</h3><p>答：Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<ul>
<li><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>
</li>
<li><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>
</li>
<li><p>开销：Https通信需要证书，而证书一般需要向认证机构购买；</p>
</li>
</ul>
<p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<hr>
<h3 id="2）对称加密与非对称加密"><a href="#2）对称加密与非对称加密" class="headerlink" title="2）对称加密与非对称加密"></a>2）对称加密与非对称加密</h3><p>答：</p>
<p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<hr>
<h3 id="3）三次握手与四次挥手"><a href="#3）三次握手与四次挥手" class="headerlink" title="3）三次握手与四次挥手"></a>3）三次握手与四次挥手</h3><p>答：</p>
<p><strong>(1). 三次握手（我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功）</strong></p>
<ul>
<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-ef0439a102c5432f.png" alt=""></p>
<p><strong>(2). 四次挥手（我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）：</strong></p>
<ul>
<li><p>第一次挥手：Client发送一个FIN，<strong>用来关闭Client到Server的数据传送</strong>，Client进入FIN_WAIT_1状态。</p>
</li>
<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p>
</li>
<li><p>第三次挥手：Server发送一个FIN，<strong>用来关闭Server到Client的数据传送</strong>，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-23ddca6bf4289f92.png" alt=""></p>
<p><strong>(3). 通俗一点的理解就是：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-895124472bd4317b.png" alt=""></p>
<hr>
<h3 id="4）为什么-TCP-链接需要三次握手，两次不可以么？"><a href="#4）为什么-TCP-链接需要三次握手，两次不可以么？" class="headerlink" title="4）为什么 TCP 链接需要三次握手，两次不可以么？"></a>4）为什么 TCP 链接需要三次握手，两次不可以么？</h3><p>答：“三次握手” 的目的是为了防止<strong>已失效的链接请求报文突然又传送到了服务端</strong>，因而产生错误。</p>
<ul>
<li><p>正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。</p>
</li>
<li><p>现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</p>
</li>
</ul>
<p>假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p>
<hr>
<h3 id="5）为什么要四次挥手？"><a href="#5）为什么要四次挥手？" class="headerlink" title="5）为什么要四次挥手？"></a>5）为什么要四次挥手？</h3><p>答：TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p>
<p>所以想要愉快的结束这次对话就需要四次挥手。</p>
<hr>
<h3 id="6）TCP-协议如何来保证传输的可靠性"><a href="#6）TCP-协议如何来保证传输的可靠性" class="headerlink" title="6）TCP 协议如何来保证传输的可靠性"></a>6）TCP 协议如何来保证传输的可靠性</h3><p>答：TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</p>
<p><strong>对于可靠性，TCP通过以下方式进行保证：</strong></p>
<ul>
<li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
</li>
<li><p><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
</li>
<li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</p>
</li>
<li><p><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
</li>
<li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
</li>
<li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
</li>
</ul>
<hr>
<h3 id="7）客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？"><a href="#7）客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？"></a>7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h3><p>答：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>
<p><strong>(1). DDos 攻击：</strong></p>
<ul>
<li>客户端向服务端发送请求链接数据包</li>
<li>服务端向客户端发送确认数据包</li>
<li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>
</ul>
<p><strong>(2). DDos 预防：（没有彻底根治的办法，除非不使用TCP）</strong></p>
<ul>
<li>限制同时打开SYN半链接的数目</li>
<li>缩短SYN半链接的Time out 时间</li>
<li>关闭不必要的服务</li>
</ul>
<hr>
<h3 id="8）GET-与-POST-的区别？"><a href="#8）GET-与-POST-的区别？" class="headerlink" title="8）GET 与 POST 的区别？"></a>8）GET 与 POST 的区别？</h3><p>答：GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面： </p>
<p>(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</p>
<p>(2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</p>
<p>(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</p>
<p>(4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</p>
<p>(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p>
<p><strong>为什么在GET请求中会对URL进行编码？</strong></p>
<p>我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 <strong>避免歧义</strong>。看下面的例子，</p>
<p>针对 “name1=value1&amp;name2=value2” 的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为： </p>
<pre><code>   6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532
   6E616D6531：name1 
   3D：= 
   76616C756531：value1 
   26：&amp;
   6E616D6532：name2 
   3D：= 
   76616C756532：value2 </code></pre><p>服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</p>
<p>现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。</p>
<p>那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</p>
<hr>
<h3 id="9）TCP与UDP的区别"><a href="#9）TCP与UDP的区别" class="headerlink" title="9）TCP与UDP的区别"></a>9）TCP与UDP的区别</h3><p>答：TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p>
<ul>
<li><p>TCP是面向连接的，UDP是无连接的；</p>
</li>
<li><p>TCP是可靠的，UDP是不可靠的；</p>
</li>
<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p>
</li>
<li><p>TCP是面向字节流的，UDP是面向报文的；</p>
</li>
<li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p>
</li>
<li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>
</li>
</ul>
<hr>
<h3 id="10）TCP和UDP分别对应的常见应用层协议"><a href="#10）TCP和UDP分别对应的常见应用层协议" class="headerlink" title="10）TCP和UDP分别对应的常见应用层协议"></a>10）TCP和UDP分别对应的常见应用层协议</h3><p>答：</p>
<p><strong>(1). TCP 对应的应用层协议：</strong></p>
<ul>
<li><p><strong>FTP</strong>：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p>
</li>
<li><p><strong>Telnet</strong>：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p>
</li>
<li><p><strong>SMTP</strong>：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p>
</li>
<li><p><strong>POP3</strong>：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>
</li>
<li><p><strong>HTTP</strong>：从Web服务器传输超文本到本地浏览器的传送协议。</p>
</li>
</ul>
<p><strong>(2). UDP 对应的应用层协议：</strong></p>
<ul>
<li><p><strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p>
</li>
<li><p><strong>SNMP</strong>：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
</li>
<li><p><strong>TFTP(Trival File Transfer Protocal)</strong>：简单文件传输协议，该协议在熟知端口69上使用UDP服务</p>
</li>
</ul>
<p><strong>(3). 图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-54d6f58268936b77.png" alt=""></p>
<hr>
<h3 id="11）TCP-的拥塞避免机制"><a href="#11）TCP-的拥塞避免机制" class="headerlink" title="11）TCP 的拥塞避免机制"></a>11）TCP 的拥塞避免机制</h3><p>答：</p>
<p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p>
<p>拥塞控制的方法：</p>
<p><strong>(1). 慢启动 + 拥塞避免：</strong></p>
<p><strong>慢启动</strong>：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>
<p><strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-15f6b11bb3c818ed.png" alt=""></p>
<p><strong>(2). 快重传 + 快恢复：</strong></p>
<p><strong>快重传</strong>：快重传要求接收方在收到一个 <strong>失序的报文段</strong> 后就立即发出 <strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-6015eb200dacea82.png" alt=""></p>
<p><strong>快恢复</strong>：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-0d52d7832b4a9c2a.png" alt=""></p>
<hr>
<h3 id="12）浏览器中输入：“www-xxx-com”-之后都发生了什么？请详细阐述。"><a href="#12）浏览器中输入：“www-xxx-com”-之后都发生了什么？请详细阐述。" class="headerlink" title="12）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。"></a>12）浏览器中输入：“<code>www.xxx.com</code>” 之后都发生了什么？请详细阐述。</h3><p>解析：经典的网络协议问题。</p>
<p>答：</p>
<ol>
<li>由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。</li>
<li>建立TCP/IP连接（三次握手具体过程）</li>
<li>由浏览器发送一个HTTP请求</li>
<li>经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器</li>
<li>服务器处理该HTTP请求，返回一个HTML文件</li>
<li>浏览器解析该HTML文件，并且显示在浏览器端</li>
<li>这里需要注意：<ul>
<li>HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接</li>
<li>可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li>
<li>两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="13）什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#13）什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h3><p>答：HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。</p>
<p>HTTP 的这种特性有优点也有缺点：</p>
<ul>
<li><strong>优点</strong>：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用</li>
<li><strong>缺点</strong>：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享</li>
</ul>
<p>解决方案：</p>
<ol>
<li>使用参数传递机制：<br>将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：<code>/param/list?username=wmyskxz</code></li>
</ol>
<p><strong>问题</strong>：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb<br>2. 使用 Cookie 技术<br>3. 使用 Session 技术</p>
<hr>
<h3 id="14）Session、Cookie-与-Application"><a href="#14）Session、Cookie-与-Application" class="headerlink" title="14）Session、Cookie 与 Application"></a>14）Session、Cookie 与 Application</h3><p>答：Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p><strong>(1). Cookie 及其相关 API ：</strong></p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-5cba15b5ebdc21fa.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-aa39c7450ebaeb48.png" alt=""></p>
<p><strong>(2). Session 及其相关 API：</strong></p>
<p>同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 <strong>cookie机制</strong> ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 <strong>URL重写机制</strong> 将sessionid传回服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-4045b82e54d98900.png" alt=""></p>
<p><strong>(3). Session 与 Cookie 的对比：</strong></p>
<ul>
<li><p><strong>实现机制</strong>：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>
</li>
<li><p><strong>大小限制</strong>：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
</li>
<li><p><strong>安全性</strong>：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
</li>
<li><p><strong>服务器资源消耗</strong>：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
</li>
</ul>
<p><strong>(4). Application：</strong></p>
<p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p>
<hr>
<h3 id="15）滑动窗口机制"><a href="#15）滑动窗口机制" class="headerlink" title="15）滑动窗口机制"></a>15）滑动窗口机制</h3><p>答：由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。这就实现了流量的控制。</p>
<hr>
<h3 id="16）常用的HTTP方法有哪些？"><a href="#16）常用的HTTP方法有哪些？" class="headerlink" title="16）常用的HTTP方法有哪些？"></a>16）常用的HTTP方法有哪些？</h3><p>答：</p>
<ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<hr>
<h3 id="17）常见HTTP状态码"><a href="#17）常见HTTP状态码" class="headerlink" title="17）常见HTTP状态码"></a>17）常见HTTP状态码</h3><p>答：</p>
<ol>
<li><p>1xx（临时响应）</p>
</li>
<li><p>2xx（成功）</p>
</li>
<li><p>3xx（重定向）：表示要完成请求需要进一步操作</p>
</li>
<li><p>4xx（错误）：表示请求可能出错，妨碍了服务器的处理</p>
</li>
<li><p>5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误</p>
</li>
<li><p>常见状态码：</p>
<ul>
<li>200（成功）</li>
<li>304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li>
<li>401（未授权）：请求要求身份验证</li>
<li>403（禁止）：服务器拒绝请求</li>
<li>404（未找到）：服务器找不到请求的网页</li>
</ul>
</li>
</ol>
<hr>
<h3 id="18）SQL-注入"><a href="#18）SQL-注入" class="headerlink" title="18）SQL 注入"></a>18）SQL 注入</h3><p>答：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p><strong>(1).SQL注入攻击的总体思路：</strong></p>
<ol>
<li>寻找到SQL注入的位置</li>
<li>判断服务器类型和后台数据库类型</li>
<li>针对不通的服务器和数据库特点进行SQL注入攻击</li>
</ol>
<p><strong>(2). SQL注入攻击实例：</strong></p>
<p>比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：</p>
<pre><code>用户名： ‘or 1 = 1 --
密 码：</code></pre><p>用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：</p>
<p><code>String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;</code></p>
<p> 因此，当输入了上面的用户名和密码，上面的SQL语句变成：</p>
<p><code>SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’</code></p>
<p>分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</p>
<p><strong>(3). 应对方法：</strong></p>
<p>1.参数绑定：</p>
<p>使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和$来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。</p>
<p>2.使用正则表达式过滤传入的参数</p>
<hr>
<h3 id="19）XSS-攻击"><a href="#19）XSS-攻击" class="headerlink" title="19）XSS 攻击"></a>19）XSS 攻击</h3><p>答：XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p>
<p><strong>(1). XSS攻击的危害：</strong></p>
<ul>
<li><p>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p>
</li>
<li><p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p>
</li>
<li><p>盗窃企业重要的具有商业价值的资料</p>
</li>
<li><p>非法转账</p>
</li>
<li><p>强制发送电子邮件</p>
</li>
<li><p>网站挂马</p>
</li>
<li><p>控制受害者机器向其它网站发起攻击</p>
</li>
</ul>
<p><strong>(2). 原因解析：</strong></p>
<ul>
<li><strong>主要原因</strong>：过于信任客户端提交的数据！</li>
<li><strong>解决办法</strong>：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。</li>
<li><strong>进一步分析细节</strong>：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！</li>
</ul>
<p><strong>(3). XSS 攻击分类：</strong></p>
<ul>
<li><ol>
<li>反射性 XSS 攻击（非持久性 XSS 攻击）：</li>
</ol>
</li>
</ul>
<p>漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：</p>
<pre><code>http://www.test.com/message.php?send=Hello,World！</code></pre><p>接收者将会接收信息并显示Hello,World；但是，非正常发送消息：</p>
<pre><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！</code></pre><p>接收者接收消息显示的时候将会弹出警告窗口！</p>
<ul>
<li><ol start="2">
<li>持久性XSS攻击 (留言板场景)：</li>
</ol>
</li>
</ul>
<p>XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。</p>
<p>例如，留言板表单中的表单域：</p>
<pre><code>&lt;input type=“text” name=“content” value=“这里是用户填写的数据”&gt;</code></pre><p>正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:</p>
<pre><code>&lt;script&gt;alert(‘foolish!’)；&lt;/script&gt; &lt;!--或者html其他标签（破坏样式）、一段攻击型代码--&gt;</code></pre><p>并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。</p>
<p><strong>(4). 修复漏洞方针：</strong></p>
<p>漏洞产生的根本原因是 <strong>太相信用户提交的数据，对用户所提交的数据过滤不足所导致的</strong>，因此解决方案也应该从这个方面入手，具体方案包括：</p>
<ul>
<li><p>将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；</p>
</li>
<li><p>表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。</p>
</li>
<li><p>对数据进行Html Encode 处理</p>
</li>
<li><p>过滤或移除特殊的Html标签，例如: <script>, <iframe> , < for <, > for>, &quot for</p>
</li>
<li><p>过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。</p>
</li>
</ul>
<p>需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！</p>
<hr>
<h3 id="20）OSI-网络体系结构与-TCP-IP-协议模型"><a href="#20）OSI-网络体系结构与-TCP-IP-协议模型" class="headerlink" title="20）OSI 网络体系结构与 TCP/IP 协议模型"></a>20）OSI 网络体系结构与 TCP/IP 协议模型</h3><p>答：OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对 OSI 七层模型的各层进行简要的介绍：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-345e2a0ad5199201.png" alt=""></p>
<hr>
<p>1). 物理层</p>
<p>参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p>
<hr>
<p>2). 数据链路层（data link layer）</p>
<p>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>
<hr>
<p>3). 网络层</p>
<p>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-e4dc728c4dd77c69.png" alt=""></p>
<hr>
<p>4). 传输层（transport layer）</p>
<p>在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-c6ab5e41ee213bfc.png" alt=""></p>
<p>实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p>
<hr>
<p>5). 会话层（Session Layer）</p>
<p>会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p>
<hr>
<p>6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密</p>
<p>表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p>
<hr>
<p>7). 应用层（Application layer）：为用户的应用进程提供网络通信服务</p>
<hr>
<h3 id="21）网络层的-ARP-协议工作原理？"><a href="#21）网络层的-ARP-协议工作原理？" class="headerlink" title="21）网络层的 ARP 协议工作原理？"></a>21）网络层的 ARP 协议工作原理？</h3><p>答：地址解析协议(ARP) 是通过解析网路层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。</p>
<p><strong>网络层的ARP协议完成了IP地址与物理地址的映射</strong>。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<hr>
<h3 id="22）IP地址的分类"><a href="#22）IP地址的分类" class="headerlink" title="22）IP地址的分类"></a>22）IP地址的分类</h3><p>答：整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位标识符，它是一个逻辑地址，用以屏蔽掉物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p>
<p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p>
<ul>
<li>A类地址：以0开头，第一个字节范围：0~127；</li>
<li>B类地址：以10开头，第一个字节范围：128~191；</li>
<li>C类地址：以110开头，第一个字节范围：192~223；</li>
<li>D类地址：以1110开头，第一个字节范围为224~239；</li>
<li>E类地址：以1111开头，保留地址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-3e9b7e052218c240.png" alt=""></p>
<hr>
<p><strong>1). A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”</strong></p>
<p>一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。</p>
<p>A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。</p>
<hr>
<p><strong>2). B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”</strong></p>
<p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。</p>
<p>B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。</p>
<hr>
<p><strong>3). C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”</strong></p>
<p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p>
<p>C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。</p>
<hr>
<p><strong>4). D类地址:多播地址，用于1对多通信，最高位必须是“1110”</strong></p>
<p>　　D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。</p>
<hr>
<p><strong>5). E类地址:为保留地址，最高位必须是“1111”</strong></p>
<hr>
<h3 id="23）IP地址与物理地址"><a href="#23）IP地址与物理地址" class="headerlink" title="23）IP地址与物理地址"></a>23）IP地址与物理地址</h3><p>答：物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p>
<hr>
<h3 id="24）影响网络传输的因素有哪些？"><a href="#24）影响网络传输的因素有哪些？" class="headerlink" title="24）影响网络传输的因素有哪些？"></a>24）影响网络传输的因素有哪些？</h3><p>答：将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。</p>
<ul>
<li><p>网络带宽：所谓带宽就是一条物理链路在 1s 内能够传输的最大比特数，注意这里是比特（bit）而不是字节数，也就是 b/s 。网络带宽肯定是影响数据传输的一个关键环节，因为在当前的网络环境中，平均网络带宽只有 1.7 MB/s 左右。</p>
</li>
<li><p>传输距离：也就是数据在光纤中要走的距离，虽然光的传播速度很快，但也是有时间的，由于数据在光纤中的移动并不是走直线的，会有一个折射率，所以大概是光的 2/3，这个时间也就是我们通常所说的传输延时。传输延时是一个无法避免的问题，例如，你要给在杭州和青岛的两个机房的一个数据库进行同步数据操作，那么必定会存在约 30ms 的一个延时。</p>
</li>
<li><p>TCP 拥塞控制：我们知道 TCP 传输是一个 “停-等-停-等” 的协议，传输方和接受方的步调要一致，要达到步调一致就要通过拥塞控制来调节。TCP 在传输时会设定一个 “窗口”，这个窗口的大小是由带宽和 RTT（Round-Trip Time，数据在两端的来回时间，也就是响应时间）决定的。计算的公式是带宽（b/s）xRTT（s）。通过这个值就可以得出理论上最优的 TCP 缓冲区的大小。Linux 2.4 已经可以自动地调整发送端的缓冲区的大小，而到 Linux 2.6.7 时接收端也可以自动调整了。</p>
</li>
</ul>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/17/java-mian-shi-zhi-shi-dian-jie-xi-si-ban-ben-te-xing-pian/">
      Java面试知识点解析(四)——版本特性篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月17日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<hr>
<blockquote>
<p>对于 Java 各个版本的特性，特别是 Java 8 的新知识点，我们都应该有所了解。<br>前排申明和好文推荐：<a href="http://blinkfox.com" target="_blank" rel="noopener">闪烁之狐</a> » <a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a> » <a href="http://blinkfox.com/java6xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java6新特性及使用</a> » <a href="http://blinkfox.com/java7xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java7新特性及使用</a> » <a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用(一)</a> » <a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-er/" target="_blank" rel="noopener">Java8新特性及使用(二)</a></p>
</blockquote>
<h2 id="（一）Java-5-相关知识点"><a href="#（一）Java-5-相关知识点" class="headerlink" title="（一）Java 5 相关知识点"></a>（一）Java 5 相关知识点</h2><blockquote>
<p>参考文章：<a href="https://www.kancloud.cn/alex_wsc/java/466883" target="_blank" rel="noopener">jdk 1.5新特性</a></p>
</blockquote>
<h4 id="1）增强型-for-循环："><a href="#1）增强型-for-循环：" class="headerlink" title="1）增强型 for 循环："></a>1）增强型 for 循环：</h4><p>答：增强 for 循环：foreach 语句，foreach 简化了迭代器。</p>
<p>格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span> 元素类型 变量名 <span class="token operator">:</span> Collection集合 <span class="token operator">&amp;</span> 数组 <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
<span class="token punctuation">}</span></code></pre>
<p>语法：<br><code>for ( type 变量名：集合变量名 ) { … }</code></p>
<p>注意事项：</p>
<ul>
<li>迭代变量必须在( )中定义！</li>
<li>集合变量可以是数组或实现了Iterable接口的集合类。</li>
</ul>
<p><strong>高级for循环和传统for循环的区别：</strong></p>
<p>高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。</p>
<p>如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。比起普通的for循环，高级for循环还有性能优势，因为它对数组索引的边界值只计算一次（摘自《Effective Java》第46条）。</p>
<p><strong>高级for循环可以遍历map集合吗？</strong></p>
<p>答：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>Object obj <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token punctuation">.</span>Entry entry <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// obj 依次表示Entry</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>总之，for-each 循环在简洁性和预防 Bug 方面有着传统 for 循环无法比拟的优势，并且没有性能损失。应该尽可能地使用 for-each 循环。遗憾的是，有三种常见的情况是无法使用 for-each 循环的：</strong></p>
<ol>
<li><p>过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式地迭代器，以便可以调用它的 remove 方法。</p>
</li>
<li><p>转换——如果需要遍历列表或者数组，并取代它部分或者全部的元素值（增删、或对元素进行赋值），就需要列表迭代器或者数组索引，以便设定元素的值</p>
</li>
<li><p>平行迭代——如果需要并行地遍历多个集合，就需要显式地控制迭代器或者所因变量以便所有迭代器或者索引变量都可以得到同步前移</p>
</li>
</ol>
<h4 id="2）可变参数："><a href="#2）可变参数：" class="headerlink" title="2）可变参数："></a>2）可变参数：</h4><p>解析：什么意思呢？举个例子：在 JDK 1.5 之前，当我们要为一个传递多个类型相同的参数时，我们有两种方法解决，1.直接传递一个数组过去，2.有多少个参数就传递多少个参数。</p>
<p>例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printColor</span><span class="token punctuation">(</span>String red<span class="token punctuation">,</span>String green<span class="token punctuation">,</span>String yellow<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 或者</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printColor</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> colors<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre>
<p>这样编写方法参数虽然能够实现我们想要的效果，但是，这样是不是有点麻烦呢？再者，如果参数个数不确定，我们怎么办呢？Java JDK1.5为我们提供的可变参数就能够完美的解决这个问题</p>
<p>答：</p>
<p><strong>可变参数（…）：</strong>用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。</p>
<p><strong>和以前接收数组不一样的是：</strong></p>
<p>以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。</p>
<p>如果在参数列表中使用了可变参数，<strong>可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。</strong></p>
<p>如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。</p>
<p><strong>可变参数的特点：</strong></p>
<ul>
<li>① 只能出现在参数列表的最后；</li>
<li>② “…” 位于变量类型和变量名之间，前后有无空格都可以;</li>
<li>③ 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</li>
</ul>
<pre class=" language-java"><code class="language-java">Public <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span>  x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//也可以直接（int..args）就是说传不传都可以</span>
        Int sum <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token function">For</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>args<span class="token punctuation">.</span>lengrth<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                Sum<span class="token operator">+=</span>args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>实例：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableParameter</span> <span class="token punctuation">{</span>
      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="3）枚举"><a href="#3）枚举" class="headerlink" title="3）枚举"></a>3）枚举</h4><p>解析：关键字 enum</p>
<p>答：</p>
<p>问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；</p>
<p>解决办法：</p>
<p>1）在 setGrade 方法中做判断，不符合格式要求就抛出异常；<br>2）直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个 Grade 类，私有构造函数，对外提供 5 个静态的常量表示类的实例；<br>3）jdk5 中新定义了枚举类型，专门用于解决此类问题；<br>4）枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；</p>
<p><strong>为什么要有枚举？</strong></p>
<p>问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。</p>
<p>枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。</p>
<p><strong>用普通类如何实现枚举功能，</strong>定义一个Weekday的类来模拟枚举功能。</p>
<p>1、私有的构造方法。<br>2、每个元素分别用一个公有的静态成员变量表示。</p>
<p>可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句转移成了一个个独立的类</p>
<p>示例：定义一个Weekday的类来模拟枚举功能。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeekDay</span> <span class="token punctuation">{</span>

       <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WeekDay SUN <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WeekDay MON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token keyword">public</span> WeekDay <span class="token function">nextDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> SUN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> MON <span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> SUN <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

       <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> SUN<span class="token operator">?</span> <span class="token string">"SUN"</span><span class="token operator">:</span><span class="token string">"MON"</span> <span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>MON<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">nextDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//结果：SUN</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用枚举类实现</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>FRI<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：FRI</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：FRI</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：5</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>WeekDay<span class="token punctuation">.</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"SUN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：SUN</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>WeekDay<span class="token punctuation">.</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：7</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">enum</span> WeekDay<span class="token punctuation">{</span>
             SUN<span class="token punctuation">,</span>MON <span class="token punctuation">,</span>TUE<span class="token punctuation">,</span>WED<span class="token punctuation">,</span> THI<span class="token punctuation">,</span>FRI <span class="token punctuation">,</span>SAT<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>总结：</strong> 枚举是一种特殊的类，其中的每个元素都是该类的一个实例对象，例如可以调用WeekDay.SUN.getClass().getName 和 WeekDay.class.getName()。</p>
<p><strong>注意：</strong> 最后一个枚举元素后面可以加分号，也可以不加分号。</p>
<p><strong>实现带有构造方法的枚举</strong></p>
<ul>
<li>枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。</li>
<li>枚举元素必须位于枚举体中的最开始部分，枚举元素列表的最后要有分号与其他成员分隔。把枚举中的成员方法或变量等放在枚举元素的前面，编译器会报告错误。</li>
<li>带构造方法的枚举：<br>构造方法必须定义成私有的<br>如果有多个构造方法，将根据枚举元素创建时所带的参数决定选择哪个构造方法创建对象。<br>枚举元素 MON 和 MON() 的效果一样，都是调用默认的构造方法。</li>
</ul>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>FRI<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">enum</span> WeekDay<span class="token punctuation">{</span>
             <span class="token function">SUN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">MON</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span>THI <span class="token punctuation">,</span>FRI<span class="token punctuation">,</span>SAT<span class="token punctuation">;</span>

             <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"first"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

             <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                  System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"second"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
             <span class="token comment" spellcheck="true">//结果：</span>
             <span class="token comment" spellcheck="true">//second</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>实现带有抽象方法的枚举</strong></p>
<p>定义枚举TrafficLamp，实现抽象的nextTrafficLamp方法：每个元素分别是由枚举类的子类来生成的实例对象，这些子类采用类似内部类的方式进行定义。增加上表示时间的构造方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TrafficLamp lamp <span class="token operator">=</span> TrafficLamp<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lamp<span class="token punctuation">.</span><span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//结果：GREEN</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> TrafficLamp <span class="token punctuation">{</span>
        <span class="token function">RED</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> GREEN<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> YELLOW<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">YELLOW</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> RED<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> time<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token function">TrafficLamp</span><span class="token punctuation">(</span><span class="token keyword">int</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">abstract</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong><br>1、枚举只有一个成员时，就可以作为一种单例的实现方式。<br>2、查看生成的class文件，可以看到内部类对应的class文件。</p>
<h4 id="4）自动拆装箱"><a href="#4）自动拆装箱" class="headerlink" title="4）自动拆装箱"></a>4）自动拆装箱</h4><p>答：在 Java 中数据类型分为两种：基本数据类型、引用数据类型(对象)</p>
<p>自动装箱：把基本类型变成包装器类型，本质是调用包装器类型的valueOf（）方法</p>
<p><strong>注意</strong>：基本数据类型的数组与包装器类型数组不能互换</p>
<p>在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：</p>
<hr>
<p>int → Integer<br>byte → Byte<br>short → Short<br>long → Long<br>char → Character<br>double → Double<br>float → Float<br>boolean → Boolean</p>
<hr>
<p>在 jdk 1.5 以前基本数据类型和包装类之间需要相互转换：</p>
<p>基本—引用 <code>Integer x = new Integer(x);</code><br>引用—基本 <code>int num = x.intValue();</code></p>
<p>1）<code>Integer x = 1; x = x + 1;</code> 经历了什么过程？装箱→拆箱→装箱<br>2）为了优化，虚拟机为包装类提供了缓冲池，<strong>Integer池</strong>的大小为 -128~127 一个字节的大小。<strong>String池</strong>：Java 为了优化字符串操作也提供了一个缓冲池；</p>
<p>→ 享元模式（Flyweight Pattern）：享元模式的特点是，复用我们内存中已经存在的对象，降低系统创建对象实例。</p>
<p><strong>自动装箱：</strong></p>
<pre class=" language-java"><code class="language-java">Integer num1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></code></pre>
<p><strong>自动拆箱：</strong></p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>基本数据类型的对象缓存：</p>
<pre class=" language-java"><code class="language-java">Integer num1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
Integer num2 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ture</span></code></pre>
<pre class=" language-java"><code class="language-java">Integer num3 <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>
Integer num4 <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3 <span class="token operator">==</span> num4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre>
<pre class=" language-java"><code class="language-java">Integer num5 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Integer num6 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num5 <span class="token operator">==</span> num6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre>
<p><strong>示例：</strong></p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoBox</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//装箱</span>
            Integer iObj <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

             <span class="token comment" spellcheck="true">//拆箱</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iObj <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：15</span>

            Integer i1 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            Integer i2 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：true</span>

            i1 <span class="token operator">=</span> <span class="token number">137</span><span class="token punctuation">;</span>
            i2 <span class="token operator">=</span> <span class="token number">137</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：false</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong><br>如果有很多很小的对象，并且他们有相同的东西，那就可以把他们作为一个对象。<br>如果还有很多不同的东西，那就可以作为外部的东西，作为参数传入。<br>这就是享元设计模式（flyweight）。</p>
<p>例如示例中的Integer对象，在-128~127范围内的Integer对象，用的频率比较高，就会作为同一个对象，因此结果为true。超出这个范围的就不是同一个对象，因此结果为false。</p>
<h4 id="5）泛型-Generics"><a href="#5）泛型-Generics" class="headerlink" title="5）泛型 Generics"></a>5）泛型 Generics</h4><p>答：引用泛型之后，允许指定集合里元素的类型，免去了强制类型转换，并且能在编译时刻进行类型检查的好处。Parameterized Type作为参数和返回值，Generic是vararg、annotation、enumeration、collection的基石。</p>
<p>泛型可以带来如下的好处总结如下：</p>
<ol>
<li>类型安全：抛弃List、Map，使用List、Map给它们添加元素或者使用Iterator遍历时，编译期就可以给你检查出类型错误</li>
<li>方法参数和返回值加上了Type: 抛弃List、Map，使用List、Map</li>
<li>不需要类型转换：List list = new ArrayList();</li>
<li>类型通配符“?”： 假设一个打印List中元素的方法printList,我们希望任何类型T的List都可以被打印</li>
</ol>
<h4 id="6）静态导入"><a href="#6）静态导入" class="headerlink" title="6）静态导入"></a>6）静态导入</h4><p>答：<strong>静态导入：</strong>导入了类中的所有静态成员，简化静态成员的书写。<br>import语句可以导入一个类或某个包中的所有类<br>import static语句导入一个类中的某个静态方法或所有静态方法</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>*<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//导入了Collections类中的所有静态成员</span></code></pre>
<p>静态导入可以导入静态方法，这样就不必写类名而可以直接调用静态方法了。</p>
<p><strong>例子：</strong></p>
<p>原来的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo12</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用静态导入的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>max <span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>abs <span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo12</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong></p>
<p>1、也可以通过import static java.lang.Math.*;导入Math类下所有的静态方法。<br>2、如果将javac设置为了Java5以下，那么静态导入等jdk1.5的特性都会报告错误。</p>
<h4 id="7）新的线程模型和并发库Thread-Framework-重要"><a href="#7）新的线程模型和并发库Thread-Framework-重要" class="headerlink" title="7）新的线程模型和并发库Thread Framework(重要)"></a>7）新的线程模型和并发库Thread Framework(重要)</h4><p>答： 最主要的就是引入了 java.util.concurrent 包，这个都是需要重点掌握的。</p>
<p>HashMap 的替代者 ConcurrentHashMap 和 ArrayList 的替代者 CopyOnWriteArrayList 在大并发量读取时采用 java.util.concurrent 包里的一些类会让大家满意 BlockingQueue、Callable、Executor、Semaphore </p>
<h4 id="8）内省（Introspector）"><a href="#8）内省（Introspector）" class="headerlink" title="8）内省（Introspector）"></a>8）内省（Introspector）</h4><p>答：是 Java 语言对 Bean 类属性、事件的一种缺省处理方法。例如类 A 中有属性 name , 那我们通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问name属性，这就是默认的规则。Java 中提供了一套 API 用来访问某个属性的 getter /setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中。</p>
<p>一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来 调用这些方法。</p>
<blockquote>
<p>扩展阅读：<a href="https://www.jianshu.com/p/205444f4b1eb" target="_blank" rel="noopener">java Introspector(内省) 的介绍</a></p>
</blockquote>
<h4 id="9）注解（Annotations）"><a href="#9）注解（Annotations）" class="headerlink" title="9）注解（Annotations）"></a>9）注解（Annotations）</h4><p>答：</p>
<p>注解(Annotation)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从Java5开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p>
<p>比如，下面这段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> <span class="token string">"This is String."</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的代码中，我重写了toString()方法并使用了@Override注解。但是，即使我们不使用@Override注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将toString()写成了toStrring(){double r}，而且我也没有使用@Override注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。</p>
<p><strong>为什么要引入注解？</strong></p>
<p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p>
<p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>
<p>另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。</p>
<p>目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p>
<blockquote>
<p>参考文章（更多注解戳这里）:<a href="http://blinkfox.com/javazhu-jie-de-li-jie-he-ying-yong/" target="_blank" rel="noopener">Java注解的理解和应用</a></p>
</blockquote>
<h4 id="10）新增-ProcessBuilder-类"><a href="#10）新增-ProcessBuilder-类" class="headerlink" title="10）新增 ProcessBuilder 类"></a>10）新增 ProcessBuilder 类</h4><p>答：</p>
<p><code>ProcessBuilder</code> 类是 Java5 在 <code>java.lang</code> 包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由 <code>Process</code> 类处来实现进程的控制管理。每个 <code>ProcessBuilder</code> 实例管理一个进程属性集。它的 <code>start()</code> 方法利用这些属性创建一个新的 <code>Process</code> 实例。<code>start()</code> 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p><code>ProcessBuilder</code> 是一个 <code>final</code> 类，有两个带参数的构造方法，你可以通过构造方法来直接创建 <code>ProcessBuilder</code> 的对象。而 <code>Process</code> 是一个抽象类，一般都通过 <code>Runtime.exec()</code> 和 <code>ProcessBuilder.start()</code> 来间接创建其实例。<code>ProcessBuilder</code> 为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而 <code>Process</code> 类的功能相对来说简单的多。<code>ProcessBuilder</code> 类不是同步的。如果多个线程同时访问一个 <code>ProcessBuilder</code>，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。</p>
<p>若要使用 <code>ProcessBuilder</code> 创建一个进程，只需要创建 <code>ProcessBuilder</code> 的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的 <code>start()</code> 即可。下面是一个执行打开 Windows 记事本的例子。注意它将要编辑的文件名指定为一个参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PBDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            ProcessBuilder proc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"notepad.exe"</span><span class="token punctuation">,</span> <span class="token string">"testfile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            proc<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error executing notepad."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="11）新增Formatter格式化器-Formatter"><a href="#11）新增Formatter格式化器-Formatter" class="headerlink" title="11）新增Formatter格式化器(Formatter)"></a>11）新增Formatter格式化器(Formatter)</h4><p><code>Formatter</code> 类是Java5中新增的 <code>printf-style</code> 格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的 Java 类型，如 <code>byte</code>，<code>java.math.BigDecimal</code> 和 <code>java.util.Calendar</code> 都支持。 通过 <code>java.util.Formattable</code> 接口提供了针对任意用户类型的有限格式定制。</p>
<p>更详细的介绍见<a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html" target="_blank" rel="noopener">这里</a>。主要使用方法的代码示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>MessageFormat<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>SimpleDateFormat<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span>  
<span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 格式化测试使用的示例类.
 *
 * @author blinkfox on 2017-11-28.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FormatTester</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>FormatTester<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Formatter formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 可重新排序输出.</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%n%4$2s %3$2s %2$2s %1$2s %n"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> " d  c  b  a"</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>FRANCE<span class="token punctuation">,</span> <span class="token string">"e = %+10.4f"</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> "e =    +2,7183"</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%nAmount gained or lost since last statement: $ %(,.2f"</span><span class="token punctuation">,</span> <span class="token number">6217.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// -> "Amount gained or lost since last statement: $ 6,217.58"</span>

        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"打印出格式化后的字符串:{}"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        formatter<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * printf打印.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String filename <span class="token operator">=</span> <span class="token string">"testfile"</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            String line<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Line %d: %s%n"</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to open file named '%s': %s"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * stringFormat使用.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 格式化日期.</span>
        Calendar c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GregorianCalendar</span><span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MAY<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Duke's Birthday: %1$tm %1$te,%1$tY"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// -> s == "Duke's Birthday: May 23, 1995"</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化消息.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String msg <span class="token operator">=</span> <span class="token string">"欢迎光临，当前（{0}）等待的业务受理的顾客有{1}位，请排号办理业务！"</span><span class="token punctuation">;</span>
        MessageFormat mf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageFormat</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        String fmsg <span class="token operator">=</span> mf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>fmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化日期.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"2010-1-10 17:39:21"</span><span class="token punctuation">;</span>
        SimpleDateFormat format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMddHHmmss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"格式化后的日期:{}"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"日期格式化出错！"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="12）新增-Scanner-类（Scanner）"><a href="#12）新增-Scanner-类（Scanner）" class="headerlink" title="12）新增 Scanner 类（Scanner）"></a>12）新增 Scanner 类（Scanner）</h4><p><code>java.util.Scanner</code> 是 Java5 的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。</p>
<p><strong>(1).Scanner概述</strong></p>
<p>可以从字符串(<code>Readable</code>)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。</p>
<p><code>Scanner</code> 默认使用空格作为分割符来分隔文本，但允许你使用 <code>useDelimiter(Pattern pattern)</code> 或 <code>useDelimiter(String pattern)</code> 方法来指定新的分隔符。</p>
<p>主要API如下：</p>
<ul>
<li><code>delimiter()</code>: 返回此 <code>Scanner</code> 当前正在用于匹配分隔符的 <code>Pattern</code>。</li>
<li><code>hasNext()</code>: 判断扫描器中当前扫描位置后是否还存在下一段。</li>
<li><code>hasNextLine()</code>: 如果在此扫描器的输入中存在另一行，则返回true。</li>
<li><code>next()</code>: 查找并返回来自此扫描器的下一个完整标记。</li>
<li><code>nextLine()</code>: 此扫描器执行当前行，并返回跳过的输入信息。</li>
</ul>
<p><strong>(2).扫描控制台输入</strong></p>
<p>当通过 <code>new Scanner(System.in)</code> 创建了一个 <code>Scanner</code> 实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给 <code>Scanner</code>，作为扫描对象。如果要获取输入的内容，则只需要调用 <code>Scanner</code> 的 <code>nextLine()</code> 方法即可。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
* 扫描控制台输入.
*
* @author blinkfox 2017-11-28
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入字符串："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String line <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">">>>"</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p><strong>(3).其它示例</strong></p>
<p>该示例中会从 <code>myNumbers</code> 文件中读取长整型 <code>long</code> 的数据。</p>
<pre class=" language-java"><code class="language-java">Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"myNumbers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">while</span> <span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">long</span> aLong <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目：</p>
<pre class=" language-java"><code class="language-java">String input <span class="token operator">=</span> <span class="token string">"1 fish 2 fish red fish blue fish"</span><span class="token punctuation">;</span>  
Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">useDelimiter</span><span class="token punctuation">(</span><span class="token string">"\\s*fish\\s*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
s<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>将输出：</p>
<pre class=" language-java"><code class="language-java"><span class="token number">1</span>  
<span class="token number">2</span>  
red  
blue  </code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="13）StringBuilder"><a href="#13）StringBuilder" class="headerlink" title="13）StringBuilder"></a>13）StringBuilder</h4><p><code>StringBuilder</code> 也是 Java5 中新增的类，主要用来代替 <code>+</code> 号和 <code>StringBuffer</code> 来更加高效的拼接字符串。<code>StringBuffer</code> 与 <code>StringBuilder</code> 都是继承于 <code>AbstractStringBuilder</code>，主要的区别就是 <code>StringBuffer</code> 的函数上都有 <code>synchronized</code> 关键字，保证线程安全。</p>
<p>关于 <code>StringBuilder</code> 的使用这里就不再详细介绍了，网上文章也有很多。总之，对于动态字符串的拼接推荐使用 <code>StringBuilder</code>。静态字符串的拼接直接使用 <code>+</code> 号或者字符串的 <code>concat(String str)</code> 方法，甚至也使用 <code>StringBuilder</code> 亦可。</p>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<hr>
<h2 id="（二）Java-6-相关知识点"><a href="#（二）Java-6-相关知识点" class="headerlink" title="（二）Java 6 相关知识点"></a>（二）Java 6 相关知识点</h2><blockquote>
<p>关于 JDK 1.6 的新特性，了解一下就可以了…如果有兴趣深入研究的童鞋，右转这里：<a href="http://blinkfox.com/java6xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java6新特性及使用</a></p>
</blockquote>
<h4 id="1）Desktop-类和-SystemTray-类："><a href="#1）Desktop-类和-SystemTray-类：" class="headerlink" title="1）Desktop 类和 SystemTray 类："></a>1）Desktop 类和 SystemTray 类：</h4><p>答：</p>
<p>在JDK6中 ,AWT新增加了两个类:Desktop 和 SystemTray 。</p>
<p>前者可以用来打开系统默认浏览器浏览指定的 URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;</p>
<p>后者可以用来在系统托盘区创建一个托盘程序.</p>
<h4 id="2）使用-JAXB2-来实现对象与-XML-之间的映射"><a href="#2）使用-JAXB2-来实现对象与-XML-之间的映射" class="headerlink" title="2）使用 JAXB2 来实现对象与 XML 之间的映射"></a>2）使用 JAXB2 来实现对象与 XML 之间的映射</h4><p>答：</p>
<p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。</p>
<p>我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。</p>
<p>JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。</p>
<p>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。</p>
<h4 id="3）理解StAX"><a href="#3）理解StAX" class="headerlink" title="3）理解StAX"></a>3）理解StAX</h4><p>答：</p>
<p>StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。 </p>
<p>StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML). </p>
<p>由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本). JDK6里面JAXP的版本就是1.4. 。 </p>
<p>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件，然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； </p>
<p>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 </p>
<h4 id="4）使用Compiler-API"><a href="#4）使用Compiler-API" class="headerlink" title="4）使用Compiler API"></a>4）使用Compiler API</h4><p>答：</p>
<p>现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 </p>
<p>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。 </p>
<h4 id="5）轻量级Http-Server-API"><a href="#5）轻量级Http-Server-API" class="headerlink" title="5）轻量级Http Server API"></a>5）轻量级Http Server API</h4><p>答：</p>
<p>JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法. </p>
<h4 id="6）插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#6）插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="6）插入式注解处理API(Pluggable Annotation Processing API)"></a>6）插入式注解处理API(Pluggable Annotation Processing API)</h4><p>答：</p>
<p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175) </p>
<p>实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境. </p>
<p>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列. </p>
<p>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。 </p>
<h4 id="7）用Console开发控制台程序"><a href="#7）用Console开发控制台程序" class="headerlink" title="7）用Console开发控制台程序"></a>7）用Console开发控制台程序</h4><p>JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. </p>
<h4 id="8）对脚本语言的支持"><a href="#8）对脚本语言的支持" class="headerlink" title="8）对脚本语言的支持"></a>8）对脚本语言的支持</h4><p>如: ruby, groovy, javascript.</p>
<h4 id="9）Common-annotations"><a href="#9）Common-annotations" class="headerlink" title="9）Common annotations"></a>9）Common annotations</h4><p><code>Common annotations</code> 原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。</p>
<h4 id="10）Java-DB-Derby"><a href="#10）Java-DB-Derby" class="headerlink" title="10）Java DB(Derby)"></a>10）Java DB(Derby)</h4><p>从 JDK6 开始，JDK 目录中新增了一个名为 <code>db</code> 的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目 <code>Derby</code>。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性 <code>JDBC 4.0</code> 规范(JSR 221)。</p>
<h4 id="11）JDBC-4-0"><a href="#11）JDBC-4-0" class="headerlink" title="11）JDBC 4.0"></a>11）JDBC 4.0</h4><p>在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。</p>
<ul>
<li>自动加载 <code>java.sql.Driver</code>，而不需要再调用 <code>class.forName</code>；</li>
<li>添加了 <code>java.sql.RowId</code> 数据类型用来可以访问 <code>sql rowid</code> ；</li>
<li>添加了 <code>National Character Set</code> 的支持；</li>
<li>增强了 <code>BLOB</code> 和 <code>CLOB</code> 的支持功能；</li>
<li><code>SQL/XML</code> 和 <code>XML</code> 支持；</li>
<li><code>Wrapper Pattern</code>；</li>
<li><code>SQLException</code> 增强；</li>
<li><code>Connection</code> 和 <code>Statement</code> 接口增强；</li>
<li><code>New Scalar Funtions</code>；</li>
<li><code>JDBC API changes</code>。</li>
</ul>
<hr>
<h2 id="（三）JAVA-7-相关知识点"><a href="#（三）JAVA-7-相关知识点" class="headerlink" title="（三）JAVA 7 相关知识点"></a>（三）JAVA 7 相关知识点</h2><blockquote>
<p>之前已经写过一篇详细介绍 Java 7 特性的文章了，这里就直接黏了：<a href="https://www.jianshu.com/p/6bc2e4c82f6b" target="_blank" rel="noopener">Java 7新特性</a></p>
</blockquote>
<h4 id="1）Diamond-Operator"><a href="#1）Diamond-Operator" class="headerlink" title="1）Diamond Operator"></a>1）Diamond Operator</h4><p>类型判断是一个人特殊的烦恼，入下面的代码：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> anagrams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>通过类型推断后变成：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> anagrams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>注：这个&lt;&gt;被叫做diamond(钻石)运算符，Java 7后这个运算符从引用的声明中推断类型。</strong></p>
<h4 id="2）在switch语句中使用字符串"><a href="#2）在switch语句中使用字符串" class="headerlink" title="2）在switch语句中使用字符串"></a>2）在switch语句中使用字符串</h4><p>switch语句可以使用原始类型或枚举类型。Java引入了另一种类型，我们可以在switch语句中使用：字符串类型。</p>
<p>说我们有一个根据其地位来处理贸易的要求。直到现在，我们使用if-其他语句来完成这个任务。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token function">voidprocessTrade</span><span class="token punctuation">(</span>Trade t<span class="token punctuation">)</span><span class="token punctuation">{</span>

            String status <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>NEW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">newTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>EXECUTE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">executeTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>PENDING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">pendingTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>这种处理字符串的方法是粗糙的。在Java中，我们可以使用增强的switch语句来改进程序，该语句以String类型作为参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidprocessTrade</span><span class="token punctuation">(</span>Trade t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String status <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        caseNEW<span class="token operator">:</span>
            <span class="token function">newTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        caseEXECUTE<span class="token operator">:</span>
            <span class="token function">executeTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        casePENDING<span class="token operator">:</span>
            <span class="token function">pendingTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在上面的程序中，状态字段总是通过使用 <strong>String.equals()</strong> 与案例标签来进行比较。</p>
<h4 id="3）自动资源管理"><a href="#3）自动资源管理" class="headerlink" title="3）自动资源管理"></a>3）自动资源管理</h4><p>Java中有一些资源需要手动关闭，例如<strong>Connections，Files，Input/OutStreams</strong>等。通常我们使用 <strong>try-finally</strong> 来关闭资源：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidoldTry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        fos<span class="token operator">=</span> <span class="token function">newFileOutputStream</span><span class="token punctuation">(</span><span class="token string">"movies.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        dos<span class="token operator">=</span> <span class="token function">newDataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span>

        dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"Java 7 Block Buster"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>

        <span class="token keyword">try</span><span class="token punctuation">{</span>

            fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            dos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// log the exception</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>然而，在Java 7中引入了另一个很酷的特性，可以自动管理资源。它的操作也很简单，我们所要做的就是在 <strong>try</strong> 块中申明资源如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>resources_to_be_cleant<span class="token punctuation">)</span><span class="token punctuation">{</span>

   <span class="token comment" spellcheck="true">// your code</span>

<span class="token punctuation">}</span></code></pre>
<p>以上方法与旧的 <strong>try-finally</strong> 能最终写成下面的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewTry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">(</span>FileOutputStream fos <span class="token operator">=</span> <span class="token function">newFileOutputStream</span><span class="token punctuation">(</span><span class="token string">"movies.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        DataOutputStream dos <span class="token operator">=</span> <span class="token function">newDataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"Java 7 Block Buster"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log the exception</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>上面的代码也代表了这个特性的另一个方面：处理多个资源。<strong>FileOutputStream</strong> 和 <strong>DataOutputStream</strong> 在try语句中一个接一个地含在语句中，每一个都用分号(;)分隔符分隔开。我们不必手动取消或关闭流，因为当空间存在try块时，它们将自动关闭。</p>
<p>在后台，应该自动关闭的资源必须试验 <strong>java.lang.AutoCloseable</strong> 接口。</p>
<p>任何实现 <strong>AutoCloseable</strong> 接口的资源都可以作为自动资源管理的候选。<strong>AutoCloseable</strong> 是 <strong>java.io.Closeable</strong> 接口的父类，JVM会在程序退出<strong>try</strong>块后调用一个方法 <strong>close()</strong>。</p>
<h4 id="4）带下划线的数字文本"><a href="#4）带下划线的数字文本" class="headerlink" title="4）带下划线的数字文本"></a>4）带下划线的数字文本</h4><p>数字文字绝对是对眼睛的一种考验。我相信，如果你给了一个数字，比如说，十个零，你就会像我一样数零。如果不计算从右到左的位置，识别一个文字的话，就很容易出错，而且很麻烦。Not anymore。Java在识别位置时引入了下划线。例如，您可以声明1000，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> thousand <span class="token operator">=</span>  1_000<span class="token punctuation">;</span></code></pre>
<p>或1000000(一百万)如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> million  <span class="token operator">=</span>  1_000_000</code></pre>
<p><strong>请注意，这个版本中也引入了二进制文字-例如“0b1”-因此开发人员不必再将它们转换为十六进制。</strong></p>
<h4 id="5）改进的异常处理"><a href="#5）改进的异常处理" class="headerlink" title="5）改进的异常处理"></a>5）改进的异常处理</h4><p>在异常处理区域有几处改进。Java引入了多个catch功能，以使用单个抓到块捕获多个异常类型。</p>
<p>假设您有一个方法，它抛出三个异常。在当前状态下，您将分别处理它们，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidoldMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionOne</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionTwo e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionTwo</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionThree</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>在一个catch块中逐个捕获一个连续的异常，看起来很混乱。我还看到了捕获十几个异常的代码。这是非常低效和容易出错的。Java为解决这只丑小鸭带来了新的语言变化。请参阅下面的方法oldMultiCatch方法的改进版本：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne <span class="token operator">|</span> ExceptionTwo <span class="token operator">|</span> ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with all Exceptions</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>多个异常通过使用 <strong>“|”</strong> 操作符在一个catch块中捕获。这样，您不必编写数十个异常捕获。但是，如果您有许多属于不同类型的异常，那么您也可以使用“多个catch块”块。下面的代码片段说明了这一点：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewMultiMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionOne</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionTwo <span class="token operator">|</span> ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionTwo and ExceptionThree</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>在上面的例子中，在和ExceptionThree属于不同的层次结构，因此您希望以不同的方式处理它们，但使用一个抓到块。</p>
<h4 id="6）New-file-system-API-NIO-2-0"><a href="#6）New-file-system-API-NIO-2-0" class="headerlink" title="6）New file system API(NIO 2.0)"></a>6）New file system API(NIO 2.0)</h4><p>那些使用Java的人可能还记得框架引起的头痛。在操作系统或多文件系统之间无缝地工作从来都不是一件容易的事情.。有些方法，例如删除或重命名，在大多数情况下都是出乎意料的。使用符号链接是另一个问题。实质上API需要大修。</p>
<p>为了解决上述问题，Java引入了一个新的API，并在许多情况下引入了新的api。</p>
<p>在NIO2.0提出了许多增强功能。在处理多个文件系统时，它还引入了新的类来简化开发人员的生活。</p>
<p><strong>Working With Path（使用路径）：</strong></p>
<p>新的 <strong>java.nio.file</strong> 由包和接口组成例如：<strong>Path,Paths,FileSystem,FileSystems</strong>等等。</p>
<p>路径只是对文件路径的简单引用。它与java.io.File等价(并具有更多的特性)。下面的代码段显示了如何获取对“临时”文件夹的路径引用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidpathInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    Path path<span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"c:\Temp\temp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of Nodes:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getNameCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Name:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Root:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Parent:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<p>最终控制台的输出将是:</p>
<pre class=" language-java"><code class="language-java">Number of Nodes<span class="token operator">:</span><span class="token number">2</span>

File Name<span class="token operator">:</span>temp<span class="token punctuation">.</span>txt

File Root<span class="token operator">:</span>c<span class="token operator">:</span>

File Parent<span class="token operator">:</span>c<span class="token operator">:</span>Temp</code></pre>
<p>删除文件或目录就像在文件中调用delete方法(注意复数)一样简单。在类公开两个删除方法，一个抛出NoSuchFileException，另一个不抛。</p>
<p>下面的delete方法调用抛出NoSuchFileException，因此您必须处理它：</p>
<pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Where as Files.deleteIfExists(path) does not throw exception (as expected) if the file/directory does not exist.</p>
<blockquote>
<p>使用 <strong>Files.deteleIfExists(path)</strong> 则不会抛出异常。</p>
</blockquote>
<p>您可以使用其他实用程序方法，例如Files.copy(.)和Files.move(.)来有效地对文件系统执行操作。类似地，使用 <strong>createSymbolicLink(..)</strong> 方法使用代码创建符号链接。</p>
<p><strong>文件更改通知：</strong></p>
<p>JDK 7中最好的改善算是File change notifications（文件更改通知）了。这是一个长期等待的特性，它最终被刻在NIO 2.0中。<strong>WatchService</strong> API 允许您在对主题(目录或文件)进行更改时接收通知事件。</p>
<blockquote>
<p>具体的创建步骤就不给了，总之它的功能就跟它的名字一般，当文件发生更改的时候，能及时作出反馈。</p>
</blockquote>
<h4 id="7）Fork-and-Join（Fork-Join框架）"><a href="#7）Fork-and-Join（Fork-Join框架）" class="headerlink" title="7）Fork and Join（Fork/Join框架）"></a>7）Fork and Join（Fork/Join框架）</h4><p>在一个 Java 程序中有效地使用并行内核一直是一个挑战。很少有国内开发的框架将工作分配到多个核心，然后加入它们来返回结果集。Java已经将这个特性作为Fork/Join框架结合了起来。</p>
<p>基本上，在把手头的任务变成了小任务，直到小任务简单到可以不进一步分手的情况下解决。这就像一个分而治之的算法.。在这个框架中需要注意的一个重要概念是，理想情况下，没有工作线程是空闲的。他们实现了一个 work-stealing 算法，在空闲的工人“偷”工作从那些工人谁是忙。</p>
<p>支持Fork-Join机制的核心类是 ForkJoinPool和ForkJoinTask。</p>
<p><strong>什么是Fork/Join框架：</strong></p>
<p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>Fork/Join的运行流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-47e0d9433019fb97.png" alt=""></p>
<p><strong>工作窃取算法：</strong></p>
<p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-53555e4f93e990d9.png" alt=""></p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<p><strong>Fork/Join框架使用示例：</strong></p>
<p>让我们通过一个简单的需求来使用下 <code>Fork／Join</code> 框架，需求是：计算<code>1 + 2 + 3 + 4</code>的结果。</p>
<p>使用 <code>Fork/Join</code> 框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是<code>2</code>，由于是<code>4</code>个数字相加，所以 <code>Fork/Join</code> 框架会把这个任务 <code>fork</code> 成两个子任务，子任务一负责计算<code>1 + 2</code>，子任务二负责计算<code>3 + 4</code>，然后再 <code>join</code> 两个子任务的结果。</p>
<p>因为是有结果的任务，所以必须继承 <code>RecursiveTask</code> ，实现代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * CountTask.
 *
 * @author blinkfox on 2018-01-03.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/** 阈值. */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** 计算的开始值. */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** 计算的结束值. */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 构造方法.
     *
     * @param start 计算的开始值
     * @param end 计算的结束值
     */</span>
    <span class="token keyword">public</span> <span class="token function">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 执行计算的方法.
     *
     * @return int型结果
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果任务足够小就计算任务.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果任务大于阈值，就分裂成两个子任务来计算.</span>
            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            CountTask leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
            CountTask rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 等待子任务执行完，并得到结果，再合并执行结果.</span>
            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * main方法.
     *
     * @param args 数组参数
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
        ForkJoinPool fkPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CountTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> fkPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result:"</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java7xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java7新特性及使用</a><br>这里是Java 7的新特性一览表：<a href="http://www.oschina.net/news/20119/new-features-of-java-7" target="_blank" rel="noopener">http://www.oschina.net/news/20119/new-features-of-java-7</a></p>
</blockquote>
<hr>
<h2 id="（四）Java-8-相关知识点"><a href="#（四）Java-8-相关知识点" class="headerlink" title="（四）Java 8 相关知识点"></a>（四）Java 8 相关知识点</h2><blockquote>
<p>关于 Java 8 中新知识点，面试官会让你说说 Java 8 你了解多少，下面分享一下我收集的 Java 8 新增的知识点的内容，前排申明引用自：<a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用</a></p>
</blockquote>
<h4 id="1）接口默认方法和静态方法"><a href="#1）接口默认方法和静态方法" class="headerlink" title="1）接口默认方法和静态方法"></a>1）接口默认方法和静态方法</h4><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p>
<p><strong>1.接口默认方法</strong></p>
<p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>
    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>
    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><code>Defaulable</code> 接口用关键字 <code>default</code> 声明了一个默认方法 <code>notRequired()</code>，<code>Defaulable</code> 接口的实现者之一 <code>DefaultableImpl</code> 实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code> 接口的另一个实现者 <code>OverridableImpl</code> 用自己的方法覆盖了默认方法。</p>
<p><strong>1.1 多重继承的冲突说明：</strong></p>
<p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p>
<ul>
<li>一个声明在类里面的方法优先于任何默认方法</li>
<li>优先选取最具体的实现</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span> B <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 Hello B</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p><strong>1.2 优缺点：</strong></p>
<ul>
<li><strong>优点</strong>: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li>
<li><strong>缺点</strong>: 使得<strong>接口作为协议，类作为具体实现</strong>的界限开始变得有点模糊。</li>
</ul>
<p><strong>1.3 接口默认方法不能重载Object类的任何方法：</strong></p>
<p><strong>接口不能提供对Object类的任何方法的默认实现。</strong>简单地讲，每一个java类都是Object的子类，也都继承了它类中的 <code>equals()/hashCode()/toString()</code> 方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</p>
<p>在 JVM 中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到 <code>java.util.Collection</code> 接口中去：<code>stream()</code>，<code>parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code> 等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p>
<p><strong>2.接口静态方法</strong></p>
<p>Java 8 带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用 <code>static</code> 关键字，例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>下面的一小段代码是上面静态方法的使用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>Java 支持一个实现类可以实现多个接口，如果多个接口中存在同样的 <code>static</code> 方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p>
<h4 id="2）Lambda-表达式"><a href="#2）Lambda-表达式" class="headerlink" title="2）Lambda 表达式"></a>2）Lambda 表达式</h4><p><code>Lambda</code> 表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong><a href="https://www.jianshu.com/p/eb7721f32a5d" target="_blank" rel="noopener">行为参数化</a></strong>，函数作为参数传递进方法中）。</p>
<p>一个 <code>Lambda</code> 可以由用逗号分隔的参数列表、<code>–&gt;</code> 符号与函数体三部分表示。</p>
<p>首先看看在老版本的Java中是如何排列字符串的：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>只需要给静态方法 <code>Collections.sort</code> 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>看到了吧，代码变得更短且更具有可读性，但是实际上还可以写得更短：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p>
<blockquote>
<p>更多 Lambda 表达式的示例在这里：<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a></p>
</blockquote>
<h4 id="3）函数式接口"><a href="#3）函数式接口" class="headerlink" title="3）函数式接口"></a>3）函数式接口</h4><p><code>Lambda</code> 表达式是如何在 Java 的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而<strong>函数式接口</strong>是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为<strong>默认方法</strong>不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 <code>@FunctionalInterface</code> 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<p>示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>  
    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>  
Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123  </span></code></pre>
<blockquote>
<p><strong>注意：</strong> 如果 <code>@FunctionalInterface</code> 如果没有指定，上面的代码也是对的。<br><strong>更多参考：</strong> <a href="https://www.jianshu.com/p/c204e3721733" target="_blank" rel="noopener">Java 8——Lambda表达式</a>、<a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用</a></p>
</blockquote>
<h4 id="4）方法引用"><a href="#4）方法引用" class="headerlink" title="4）方法引用"></a>4）方法引用</h4><p><strong>1.概述：</strong></p>
<p>在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p>
<pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。</p>
<pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>这种特性就叫做<strong>方法引用</strong>(<code>Method Reference</code>)。</p>
<p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p>
<blockquote>
<p><strong>注意</strong>: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。</p>
</blockquote>
<p><strong>2.分类：</strong></p>
<p>方法引用的标准形式是：<code>类名::方法名</code>。（注意：只需要写方法名，不需要写括号）</p>
<p>有以下四种形式的方法引用：</p>
<ul>
<li>引用静态方法: ContainingClass::staticMethodName</li>
<li>引用某个对象的实例方法: containingObject::instanceMethodName</li>
<li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li>
<li>引用构造方法: ClassName::new</li>
</ul>
<p><strong>3.示例：</strong></p>
<p>使用示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    String name<span class="token punctuation">;</span>

    LocalDate birthday<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 使用匿名类</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//使用lambda表达式</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="5）Steam"><a href="#5）Steam" class="headerlink" title="5）Steam"></a>5）Steam</h4><blockquote>
<p>Java8添加的 <code>Stream API(java.util.stream)</code> 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为 <code>Stream API</code> 可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。使用 Steam 写出来的代码真的能让人兴奋，这里链出之前的一篇文章：<a href="https://www.jianshu.com/p/6fab3047c7e7" target="_blank" rel="noopener">Java 8——函数式数据处理（流）</a></p>
</blockquote>
<p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括<code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>peel</code>、<code>distinct</code>、<code>sorted</code>、<code>limit</code> 和 <code>substream</code>。终止操作包括 <code>forEach</code>、<code>toArray</code>、<code>reduce</code>、<code>collect</code>、<code>min</code>、<code>max</code>、<code>count</code>、<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findFirst</code> 和 <code>findAny</code>。 <code>java.util.stream.Collectors</code> 是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p>
<p><strong>1.一些重要方法说明：</strong></p>
<ul>
<li><code>stream</code>: 返回数据流，集合作为其源</li>
<li><code>parallelStream</code>: 返回并行数据流， 集合作为其源</li>
<li><code>filter</code>: 方法用于过滤出满足条件的元素</li>
<li><code>map</code>: 方法用于映射每个元素对应的结果</li>
<li><code>forEach</code>: 方法遍历该流中的每个元素</li>
<li><code>limit</code>: 方法用于减少流的大小</li>
<li><code>sorted</code>: 方法用来对流中的元素进行排序</li>
<li><code>anyMatch</code>: 是否存在任意一个元素满足条件（返回布尔值）</li>
<li><code>allMatch</code>: 是否所有元素都满足条件（返回布尔值）</li>
<li><code>noneMatch</code>: 是否所有元素都不满足条件（返回布尔值）</li>
<li><code>collect</code>: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li>
</ul>
<p><strong>2.一些使用示例：</strong></p>
<p><strong>2.1 Filter 过滤：</strong></p>
<pre><code>stringCollection  
    .stream()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);</code></pre><p><strong>2.2 Sort 排序：</strong></p>
<pre><code>stringCollection  
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);</code></pre><p><strong>2.3 Map 映射：</strong></p>
<pre><code>stringCollection  
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);</code></pre><p><strong>2.4 Match 匹配：</strong></p>
<pre><code>boolean anyStartsWithA = stringCollection  
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(anyStartsWithA);      // true

boolean allStartsWithA = stringCollection  
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ = stringCollection  
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));
System.out.println(noneStartsWithZ);      // true  </code></pre><p><strong>2.5 Count 计数：</strong></p>
<pre><code>long startsWithB = stringCollection  
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();
System.out.println(startsWithB);    // 3  </code></pre><p><strong>2.6  Reduce 规约：</strong></p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection  
        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<h4 id="6）Optional"><a href="#6）Optional" class="headerlink" title="6）Optional"></a>6）Optional</h4><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，<code>Optional</code>类已经成为Java 8类库的一部分。</p>
<p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回<code>true</code>，否从返回<code>false</code>。为了防止Optional为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。<code>map()</code>函数对当前<code>Optional</code>的值进行转化，然后返回一个新的<code>Optional</code>实例。<code>orElse()</code>方法和<code>orElseGet()</code>方法类似，但是<code>orElse</code>接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p>
<pre class=" language-java"><code class="language-java">Full Name is set<span class="token operator">?</span> <span class="token boolean">false</span>  
Full Name<span class="token operator">:</span> <span class="token punctuation">[</span>none<span class="token punctuation">]</span>  
Hey Stranger<span class="token operator">!</span>  </code></pre>
<p>让我们来看看另一个例子：</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>下面是程序的输出：</p>
<pre class=" language-java"><code class="language-java">First Name is set<span class="token operator">?</span> <span class="token boolean">true</span>  
First Name<span class="token operator">:</span> Tom  
Hey Tom<span class="token operator">!</span> </code></pre>
<h4 id="7）Date-Time-API"><a href="#7）Date-Time-API" class="headerlink" title="7）Date/Time API"></a>7）Date/Time API</h4><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p><strong>1.Clock 时钟：</strong></p>
<p><code>Clock</code>类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用<code>Instant</code>类来表示，<code>Instant</code>类也可以用来创建老的<code>java.util.Date</code>对象。代码如下:</p>
<pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date  </span></code></pre>
<p><strong>2.Timezones 时区：</strong></p>
<p>在新API中时区使用<code>ZoneId</code>来表示。时区可以很方便的使用静态方法<code>of</code>来获取到。时区定义了到UTS时间的时间差，在<code>Instant</code>时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">// prints all available timezone ids</span>
ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span>
<span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre>
<p><strong>3.LocalTime 本地时间：</strong></p>
<p><code>LocalTime</code>定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false  </span>
<span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3  </span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239  </span></code></pre>
<p><code>LocalTime</code>提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59  </span>
DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter  
        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37  </span></code></pre>
<p><strong>4.LocalDate 本地日期：</strong></p>
<p>LocalDate表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY  </span></code></pre>
<p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p>
<pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter  
        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24  </span></code></pre>
<p><strong>5.LocalDateTime 本地日期时间：</strong></p>
<p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY  </span>
Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER  </span>
<span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439  </span></code></pre>
<p>只要附加上时区信息，就可以将其转换为一个时间点<code>Instant</code>对象，<code>Instant</code>时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。代码如下:</p>
<pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester  
        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014  </span></code></pre>
<p>格式化<code>LocalDateTime</code>和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p>
<pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>  
    DateTimeFormatter
        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13  </span></code></pre>
<p>和<code>java.text.NumberFormat</code>不一样的是新版的<code>DateTimeFormatter</code>是不可变的，所以它是线程安全的。</p>
<p>关于Java8中日期API更多的使用示例可以参考<a href="http://blinkfox.com/java-8zhong-guan-yu-ri-qi-he-shi-jian-apide-20ge-shi-yong-shi-li/" target="_blank" rel="noopener">Java 8中关于日期和时间API的20个使用示例</a>。</p>
<h4 id="8）重复注解"><a href="#8）重复注解" class="headerlink" title="8）重复注解"></a>8）重复注解</h4><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p>
<p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>
        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>
        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但Java编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p>
<p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class)</code>经编译器处理后将会返回Filters的实例）。</p>
<h4 id="9）扩展注解的支持"><a href="#9）扩展注解的支持" class="headerlink" title="9）扩展注解的支持"></a>9）扩展注解的支持</h4><p>Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="10）Base-64"><a href="#10）Base-64" class="headerlink" title="10）Base 64"></a>10）Base 64</h4><p>在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>程序在控制台上输出了编码后的字符与解码后的字符：</p>
<pre class=" language-java"><code class="language-java">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ<span class="token operator">==</span>  
Base64 <span class="token keyword">finally</span> in Java <span class="token number">8</span><span class="token operator">!</span>  </code></pre>
<p>Base64类同时还提供了对URL、MIME友好的编码器与解码器（<code>Base64.getUrlEncoder() / Base64.getUrlDecoder()</code>, <code>Base64.getMimeEncoder() / Base64.getMimeDecoder()</code>）。</p>
<h4 id="11）JavaFX"><a href="#11）JavaFX" class="headerlink" title="11）JavaFX"></a>11）JavaFX</h4><p><code>JavaFX</code>是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考<a href="http://www.javafxchina.net/blog/docs/" target="_blank" rel="noopener">JavaFX中文文档</a>。</p>
<h4 id="12）HashMap的底层实现有变化"><a href="#12）HashMap的底层实现有变化" class="headerlink" title="12）HashMap的底层实现有变化"></a>12）HashMap的底层实现有变化</h4><p>Java8中，HashMap内部实现又引入了红黑树（数组+链表+红黑树），使得HashMap的总体性能相较于Java7有比较明显的提升。</p>
<h4 id="13）JVM内存管理方面，由元空间代替了永久代。"><a href="#13）JVM内存管理方面，由元空间代替了永久代。" class="headerlink" title="13）JVM内存管理方面，由元空间代替了永久代。"></a>13）JVM内存管理方面，由元空间代替了永久代。</h4><p>区别：</p>
<ol>
<li>元空间并不在虚拟机中，而是使用本地内存</li>
<li>默认情况下，元空间的大小仅受本地内存限制</li>
<li>也可以通过-XX：MetaspaceSize指定元空间大小</li>
</ol>
<hr>
<h2 id="（五）Java-9-相关知识点"><a href="#（五）Java-9-相关知识点" class="headerlink" title="（五）Java 9 相关知识点"></a>（五）Java 9 相关知识点</h2><blockquote>
<p>引用自文章：<a href="http://www.importnew.com/24528.html" target="_blank" rel="noopener">Java 9 中的 9 个新特性</a>、<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html" target="_blank" rel="noopener">Java 9 新特性概述——IBM</a>、<a href="https://yifeng.studio/2017/03/12/translation-java-9-features-with-examples/" target="_blank" rel="noopener">【译】使用示例带你提前了解 Java 9 中的新特性</a></p>
</blockquote>
<h4 id="1）Java-9-PEPK（JShell）"><a href="#1）Java-9-PEPK（JShell）" class="headerlink" title="1）Java 9 PEPK（JShell）"></a>1）Java 9 PEPK（JShell）</h4><p>Oracle 公司（Java Library 开发者）新引进一个代表 Java Shell 的称之为 “jshell” 或者 REPL（Read Evaluate Print Loop）的新工具。该工具可以被用来执行和测试任何 Java 中的结构，如 class，interface，enum，object，statements 等。使用非常简单。</p>
<p>JDK 9 EA（Early Access）下载地址：<a href="https://jdk9.java.net/download/" target="_blank" rel="noopener">https://jdk9.java.net/download/</a></p>
<pre><code>G:\&gt;jshell
|  Welcome to JShell -- Version 9-ea
|  For an introduction type: /help intro
jshell&gt; int a = 10
a ==&gt; 10
jshell&gt; System.out.println(&quot;a value = &quot; + a )
a value = 10</code></pre><h4 id="2）集合工厂方法"><a href="#2）集合工厂方法" class="headerlink" title="2）集合工厂方法"></a>2）集合工厂方法</h4><p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p>
<pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ints <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p>
<h4 id="3）接口中的私有方法"><a href="#3）接口中的私有方法" class="headerlink" title="3）接口中的私有方法"></a>3）接口中的私有方法</h4><p>在 Java 8 中，我们可以在接口中使用默认或者静态方法提供一些实现方式，但是不能创建私有方法。</p>
<p>为了避免冗余代码和提高重用性，Oracle 公司准备在 Java SE 9 接口中引入私有方法。也就是说从 Java SE 9 开始，我们也能够在接口类中使用 ‘private’ 关键字写私有化方法和私有化静态方法。</p>
<p>接口中的私有方法与 class 类中的私有方法在写法上并无差异，如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Card</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> Long <span class="token function">createCardID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Method implementation goes here.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayCardDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Method implementation goes here.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="4）Java-平台级模块系统"><a href="#4）Java-平台级模块系统" class="headerlink" title="4）Java 平台级模块系统"></a>4）Java 平台级模块系统</h4><blockquote>
<p>这里只给出解决的问题，仅限了解….</p>
</blockquote>
<p>Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。</p>
<h4 id="5）进程-API"><a href="#5）进程-API" class="headerlink" title="5）进程 API"></a>5）进程 API</h4><p>Java SE 9 迎来一些 Process API 的改进，通过添加一些新的类和方法来优化系统级进程的管控。</p>
<p>Process API 中的两个新接口：</p>
<ul>
<li>java.lang.ProcessHandle</li>
<li>java.lang.ProcessHandle.Info</li>
</ul>
<p><strong>Process API 示例</strong></p>
<pre class=" language-java"><code class="language-java">ProcessHandle currentProcess <span class="token operator">=</span> ProcessHandle<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Process Id: = "</span> <span class="token operator">+</span> currentProcess<span class="token punctuation">.</span><span class="token function">getPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="6）Try-With-Resources-Improvement"><a href="#6）Try-With-Resources-Improvement" class="headerlink" title="6）Try With Resources Improvement"></a>6）Try With Resources Improvement</h4><p>我们知道，Java SE 7 引入了一个新的异常处理结构：<code>Try-With-Resources</code>，来自动管理资源。这个新的声明结构主要目的是实现“Automatic Better Resource Management”（“自动资源管理”）。</p>
<p>Java SE 9 将对这个声明作出一些改进来避免一些冗长写法，同时提高可读性。</p>
<p><strong>Java SE 7 示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">testARM_Before_Java9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    BufferedReader reader1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"journaldev.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>BufferedReader reader2 <span class="token operator">=</span> reader1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reader2<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>Java SE 9 示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">testARM_Java9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    BufferedReader reader1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"journaldev.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>reader1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reader1<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="7）CompletableFuture-API-Improvements"><a href="#7）CompletableFuture-API-Improvements" class="headerlink" title="7）CompletableFuture API Improvements"></a>7）CompletableFuture API Improvements</h4><p>在 Java SE 9 中，Oracle 公司将改进 CompletableFuture API 来解决一些 Java SE 8 中出现的问题。这些被添加的 API 将用来支持一些延时和超时操作，实用方法和更好的子类化。</p>
<pre class=" language-java"><code class="language-java">Executor exe <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">delayedExecutor</span><span class="token punctuation">(</span>50L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这里的 delayedExecutor() 是静态实用方法，用来返回一个在指定延时时间提交任务到默认执行器的新 Executor 对象。</p>
<h4 id="8）反应式流-（-Reactive-Streams-）"><a href="#8）反应式流-（-Reactive-Streams-）" class="headerlink" title="8）反应式流 （ Reactive Streams ）"></a>8）反应式流 （ Reactive Streams ）</h4><p> 反应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的反应式 库 RxJava 和 R eactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。</p>
<p>Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 F low.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。 </p>
<h4 id="9）改进的-Stream-API"><a href="#9）改进的-Stream-API" class="headerlink" title="9）改进的 Stream API"></a>9）改进的 Stream API</h4><p>长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p>
<pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。</p>
<p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 <code>stram</code> 将一个 Optional 对象转换为一个(可能是空的) Stream 对象：</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。</p>
<h4 id="10）HTTP-2"><a href="#10）HTTP-2" class="headerlink" title="10）HTTP/2"></a>10）HTTP/2</h4><p>Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 <code>HttpURLConnection</code> API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p>
<pre class=" language-java"><code class="language-java">HttpClient client <span class="token operator">=</span> HttpClient<span class="token punctuation">.</span><span class="token function">newHttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

HttpRequest req <span class="token operator">=</span>
   HttpRequest<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span>URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://www.google.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">,</span><span class="token string">"Java"</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

HttpResponse<span class="token operator">&lt;</span>String<span class="token operator">></span> resp <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> HttpResponse<span class="token punctuation">.</span>BodyHandler<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><code>HttpResponse&lt;String&gt; resp = client.send(req, HttpResponse.BodyHandler.asString());</code></p>
<p>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</p>
<h4 id="11）Optional-Class-Improvements"><a href="#11）Optional-Class-Improvements" class="headerlink" title="11）Optional Class Improvements"></a>11）Optional Class Improvements</h4><p>在 Java SE 9 中，Oracle 公司添加了一些新的实用方法到 <code>java.util.Optional</code> 类里面。这里我将使用一些简单的示例来描述其中的一个：stream 方法。</p>
<p>如果一个值出现在给定 Optional 对象中，stream() 方法可以返回包含该值的一个顺序 Stream 对象。否则，将返回一个空 Stream。</p>
<p><code>stream()</code> 方法已经被添加，并用来在 Optional 对象中使用，如：</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>Optional<span class="token operator">></span> emp <span class="token operator">=</span> <span class="token function">getEmployee</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
Stream empStream <span class="token operator">=</span> emp<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Optional<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span></code></pre>
<p>这里的 <code>Optional.stream()</code> 方法被用来转化 Employee 可选流对象 到 Employee 流中，如此我们便可以在后续代码中使用这个结果。</p>
<h4 id="12）多版本兼容-JAR"><a href="#12）多版本兼容-JAR" class="headerlink" title="12）多版本兼容 JAR"></a>12）多版本兼容 JAR</h4><p>我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：</p>
<pre class=" language-xml"><code class="language-xml">multirelease.jar
├── META-INF
│   └── versions
│       └── 9
│           └── multirelease
│               └── Helper.class
├── multirelease
    ├── Helper.class
    └── Main.class</code></pre>
<p>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/">
      Java面试知识点解析(三)——JVM篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月16日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<hr>
<h2 id="（一）JVM-基础知识"><a href="#（一）JVM-基础知识" class="headerlink" title="（一）JVM 基础知识"></a>（一）JVM 基础知识</h2><blockquote>
<p>问题和答案都是自行整理的，所以仅供参考！欢迎指正！</p>
</blockquote>
<h4 id="1）Java-是如何实现跨平台的？"><a href="#1）Java-是如何实现跨平台的？" class="headerlink" title="1）Java 是如何实现跨平台的？"></a>1）Java 是如何实现跨平台的？</h4><p><strong>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</strong></p>
<p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p>
<p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-10b94c75252f5e5e.png" alt=""></p>
<h4 id="2）什么是-JVM-？"><a href="#2）什么是-JVM-？" class="headerlink" title="2）什么是 JVM ？"></a>2）什么是 JVM ？</h4><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p>
<p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h4 id="3）JVM-由哪些部分组成？"><a href="#3）JVM-由哪些部分组成？" class="headerlink" title="3）JVM 由哪些部分组成？"></a>3）JVM 由哪些部分组成？</h4><p>解析：这是对 JVM 体系结构的考察</p>
<p>答：JVM 的结构基本上由 4 部分组成：</p>
<ul>
<li><p>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p>
</li>
<li><p>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p>
</li>
<li><p>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p>
</li>
<li><p>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-f42e851debb0a070.png" alt=""></p>
<h4 id="4）类加载器是有了解吗？"><a href="#4）类加载器是有了解吗？" class="headerlink" title="4）类加载器是有了解吗？"></a>4）类加载器是有了解吗？</h4><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p>
<p>答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p>
<p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<p><strong>面试官：Java 虚拟机是如何判定两个 Java 类是相同的？</strong></p>
<p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p>
<h4 id="5）类加载器是如何加载-class-文件的？"><a href="#5）类加载器是如何加载-class-文件的？" class="headerlink" title="5）类加载器是如何加载 class 文件的？"></a>5）类加载器是如何加载 class 文件的？</h4><p>答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-9b726ee9e5ed7e03.png" alt=""></p>
<p>第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中</p>
<p>第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接</p>
<p>第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等</p>
<p><strong>面试官：能详细讲讲吗？</strong></p>
<p>答：</p>
<p><strong>1.加载</strong></p>
<p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p><strong>2.连接</strong></p>
<p><strong>验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证：</strong>验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证：</strong>对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li>
<li><strong>字节码验证：</strong>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证：</strong>确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备：为类的<code>静态变量</code>分配内存，并将其初始化为默认值</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为： <code>public static int value = 3;</code></p>
<p>那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>public static</code>指令是在程序编译后，存放于类构造器 <code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<ul>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</li>
</ul>
<p>假设上面的类变量 value 被定义为： <code>public static final int value = 3;</code></p>
<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中</p>
<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p><strong>3.初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>① 声明类变量是指定初始值</li>
<li>② 使用静态代码块为类变量指定初始值</li>
</ul>
<p>JVM初始化步骤</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li>
</ul>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(一):java类的加载机制 - 纯洁的微笑</a></p>
</blockquote>
<h4 id="7）双亲委派模型（Parent-Delegation-Model）？"><a href="#7）双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="7）双亲委派模型（Parent Delegation Model）？"></a>7）双亲委派模型（Parent Delegation Model）？</h4><p>解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性</p>
<p>答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-b4a569a5cc980a34.png" alt=""></p>
<p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）</p>
<p><strong>面试官：双亲委派模型的工作过程？</strong></p>
<p>答：</p>
<p>1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p>
<blockquote>
<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，<br>等下次加载的时候就可以直接返回了。</p>
</blockquote>
<p>2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p>
<blockquote>
<p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p>
</blockquote>
<p><strong>面试官：为什么这样设计呢？</strong></p>
<p>解析：这是对于使用这种模型来组织累加器的好处</p>
<p>答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException. </p>
<blockquote>
<p>参考文章： <a href="https://segmentfault.com/a/1190000002579346" target="_blank" rel="noopener">JVM 的 工作原理，层次结构 以及 GC工作原理</a></p>
</blockquote>
<hr>
<h2 id="（二）JVM-内存管理"><a href="#（二）JVM-内存管理" class="headerlink" title="（二）JVM 内存管理"></a>（二）JVM 内存管理</h2><h4 id="1）JVM-内存划分："><a href="#1）JVM-内存划分：" class="headerlink" title="1）JVM 内存划分："></a>1）JVM 内存划分：</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-cf626e0e356e89d7.png" alt=""></p>
<p>答：</p>
<ol>
<li><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<ul>
<li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li>
</ul>
</li>
<li><p>堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</p>
</li>
<li><p>程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
</li>
<li><p>虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程；</p>
</li>
<li><p>本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务</p>
</li>
</ol>
<h4 id="2）对象分配规则？"><a href="#2）对象分配规则？" class="headerlink" title="2）对象分配规则？"></a>2）对象分配规则？</h4><p>答：</p>
<ul>
<li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</li>
<li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p>
</li>
<li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
</li>
<li><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 </p>
</li>
</ul>
<h4 id="3）Java-的内存模型："><a href="#3）Java-的内存模型：" class="headerlink" title="3）Java 的内存模型："></a>3）Java 的内存模型：</h4><p>答：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d385883cf2bc0725.png" alt=""></p>
<p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p>
<p><strong>面试官：两个线程之间是如何通信的呢？</strong></p>
<p>答：在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-ef21427c586e224c.png" alt=""></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ul>
<li>1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去</li>
<li>2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-7a3d44fd74ad5da8.png" alt=""></p>
<p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。</p>
<h4 id="5）内存屏障？"><a href="#5）内存屏障？" class="headerlink" title="5）内存屏障？"></a>5）内存屏障？</h4><p>解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></p>
<p>答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p><strong>面试官：内存屏障为何重要？</strong></p>
<p>答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h4 id="5）类似-Xms、-Xmn这些参数的含义："><a href="#5）类似-Xms、-Xmn这些参数的含义：" class="headerlink" title="5）类似-Xms、-Xmn这些参数的含义："></a>5）类似-Xms、-Xmn这些参数的含义：</h4><p>答：</p>
<p>堆内存分配：</p>
<ol>
<li>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64</li>
<li>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4</li>
<li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</li>
<li>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</li>
</ol>
<p>非堆内存分配：</p>
<ol>
<li>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；</li>
<li>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</li>
<li>-Xmn2G：设置年轻代大小为2G。</li>
<li>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</li>
</ol>
<h4 id="6）内存泄漏和内存溢出"><a href="#6）内存泄漏和内存溢出" class="headerlink" title="6）内存泄漏和内存溢出"></a>6）内存泄漏和内存溢出</h4><p>答：</p>
<p>概念：</p>
<ol>
<li>内存溢出指的是内存不够用了。</li>
<li>内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收</li>
<li>内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。</li>
</ol>
<p>内存泄漏的原因分析：</p>
<ol>
<li>长生命周期的对象引用短生命周期的对象</li>
<li>没有将无用对象置为null</li>
</ol>
<blockquote>
<p>小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。</p>
</blockquote>
<h4 id="7）简述一下-Java-中创建一个对象的过程？"><a href="#7）简述一下-Java-中创建一个对象的过程？" class="headerlink" title="7）简述一下 Java 中创建一个对象的过程？"></a>7）简述一下 Java 中创建一个对象的过程？</h4><p>解析：回答这个问题首先就要清楚类的生命周期</p>
<p>答：下图展示的是类的生命周期流向：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-b1d7d32f1eb7e1c5.png" alt=""></p>
<p>Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。</p>
<p>大致过程如下：</p>
<p><strong>1.检测类是否被加载：</strong></p>
<p>当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。</p>
<p><strong>2.为对象分配内存：</strong></p>
<p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p>
<p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<ul>
<li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</li>
<li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</li>
</ul>
<p>分配内存的时候也需要考虑线程安全问题，有两种解决方案：</p>
<ul>
<li>第一种是采用同步的办法，使用CAS来保证操作的原子性。</li>
<li>另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。</li>
</ul>
<p><strong>3.为分配的内存空间初始化零值：</strong></p>
<p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p>
<p><strong>4.对对象进行其他设置：</strong></p>
<p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。</p>
<p><strong>5.执行 init 方法：</strong></p>
<p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。</p>
<p>到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d3f0b79374e52e6b.png" alt=""></p>
<blockquote>
<p>参考文章：<a href="http://cxis.me/2016/12/01/Java创建对象的过程简介/" target="_blank" rel="noopener">Java创建对象的过程简介</a></p>
</blockquote>
<p><strong>面试官：对象的内存布局是怎样的？</strong></p>
<p>答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。</p>
<ul>
<li><p>对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。</p>
</li>
<li><p>实例数据：就是数据啦</p>
</li>
<li><p>对齐填充：不是必然的存在，就是为了对齐的嘛</p>
</li>
</ul>
<p><strong>面试官：对象是如何定位访问的？</strong></p>
<p>答：对象的访问定位有两种：句柄定位和直接指针</p>
<ul>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-24ab9d16017066ac.png" alt=""></p>
<ul>
<li>直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-37413a4771387b81.png" alt=""></p>
<p><strong>比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。</strong></p>
<blockquote>
<p>参考文章：<a href="https://troywu0.gitbooks.io/spark/content/java对象创建的过程.html" target="_blank" rel="noopener">JAVA对象创建的过程</a></p>
</blockquote>
<hr>
<h2 id="（三）GC-相关"><a href="#（三）GC-相关" class="headerlink" title="（三）GC 相关"></a>（三）GC 相关</h2><h4 id="1）如何判断一个对象是否已经死去？"><a href="#1）如何判断一个对象是否已经死去？" class="headerlink" title="1）如何判断一个对象是否已经死去？"></a>1）如何判断一个对象是否已经死去？</h4><p>答：</p>
<ol>
<li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
</li>
<li><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
</li>
</ol>
<h4 id="2）垃圾回收算法有哪些？"><a href="#2）垃圾回收算法有哪些？" class="headerlink" title="2）垃圾回收算法有哪些？"></a>2）垃圾回收算法有哪些？</h4><p>答：</p>
<ol>
<li><p>引用计数：<br>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
</li>
<li><p>标记-清除：<br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-629206f5d8336bc5.png" alt=""></p>
<ol start="3">
<li>复制算法：<br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-45baf8ef2625fba4.png" alt=""></p>
<ol start="4">
<li>标记-整理：<br>此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-4b2c9593a91f5816.png" alt=""></p>
<ol start="5">
<li>分代收集算法：<ul>
<li>分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。</li>
<li>在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</a></p>
</blockquote>
<h4 id="3）GC什么时候开始？"><a href="#3）GC什么时候开始？" class="headerlink" title="3）GC什么时候开始？"></a>3）GC什么时候开始？</h4><p>答：GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。</p>
<ol>
<li><p>对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；</p>
</li>
<li><p>Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；</p>
</li>
<li><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p>
</li>
</ol>
<h4 id="4）引用的分类？"><a href="#4）引用的分类？" class="headerlink" title="4）引用的分类？"></a>4）引用的分类？</h4><p>答：</p>
<ul>
<li><p>强引用：通过new出来的引用，只要强引用还存在，则不会回收。</p>
</li>
<li><p>软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。</p>
</li>
<li><p>弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。</p>
</li>
<li><p>虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。</p>
</li>
</ul>
<blockquote>
<p>扩展阅读：<a href="https://www.jianshu.com/p/39753aad9a38" target="_blank" rel="noopener">重新认识java（一） —- 万物皆对象</a> ，文章中有对这四个引用有详细的描述，还有一些典型的应用，这里就不摘过来啦…</p>
</blockquote>
<h4 id="5）垃圾收集器？"><a href="#5）垃圾收集器？" class="headerlink" title="5）垃圾收集器？"></a>5）垃圾收集器？</h4><p>解析：如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<p>答：</p>
<p><strong>1. Serial 收集器</strong></p>
<p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会 Stop The World（服务暂停）</p>
<p>参数控制： <code>-XX:+UseSerialGC</code> 串行收集器</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-ecea7511ae962fcc.png" alt=""></p>
<p><strong>2.ParNew 收集器</strong></p>
<p>ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：</p>
<p><code>-XX:+UseParNewGC</code> ParNew收集器<br><code>-XX:ParallelGCThreads</code> 限制线程数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-82bf115baf89fdbd.png" alt=""></p>
<p><strong>3.Parallel Scavenge收集器</strong></p>
<p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p>
<p><strong>4.Parallel Old 收集器</strong></p>
<p>Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在 JDK 1.6 中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p>
<p><strong>5.CMS收集器</strong></p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p><strong>优点:</strong> 并发收集、低停顿<br><strong>缺点:</strong> 产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制：</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d691b23585b39e9e.png" alt=""></p>
<p><strong>6.G1收集器</strong></p>
<p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<ol>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ol>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-8e8b4f853fd38684.png" alt=""></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-6fb4792713799689.png" alt=""></p>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-fbf007a6f9e8bc6c.png" alt=""></p>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-8ef492a1c182ae1a.png" alt=""></p>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</a></p>
</blockquote>
<hr>
<h2 id="（四）其他-JVM-相关面试题整理"><a href="#（四）其他-JVM-相关面试题整理" class="headerlink" title="（四）其他 JVM 相关面试题整理"></a>（四）其他 JVM 相关面试题整理</h2><h4 id="1）64-位-JVM-中，int-的长度是多数？"><a href="#1）64-位-JVM-中，int-的长度是多数？" class="headerlink" title="1）64 位 JVM 中，int 的长度是多数？"></a>1）64 位 JVM 中，int 的长度是多数？</h4><p>答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h4 id="2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h4><p>答：Sun有一个Java System属性来确定JVM的位数：32或64：</p>
<pre class=" language-java"><code class="language-java">sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">32</span> <span class="token comment" spellcheck="true">// 32 bit JVM</span>
sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">64</span> <span class="token comment" spellcheck="true">// 64 bit JVM</span></code></pre>
<p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.arch.data.model"</span><span class="token punctuation">)</span> </code></pre>
<h4 id="3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h4><p>答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<h4 id="4）你能保证-GC-执行吗？"><a href="#4）你能保证-GC-执行吗？" class="headerlink" title="4）你能保证 GC 执行吗？"></a>4）你能保证 GC 执行吗？</h4><p>答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。</p>
<h4 id="5）怎么获取-Java-程序使用的内存？堆使用的百分比？"><a href="#5）怎么获取-Java-程序使用的内存？堆使用的百分比？" class="headerlink" title="5）怎么获取 Java 程序使用的内存？堆使用的百分比？"></a>5）怎么获取 Java 程序使用的内存？堆使用的百分比？</h4><p>答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<h4 id="6）Java-中堆和栈有什么区别？"><a href="#6）Java-中堆和栈有什么区别？" class="headerlink" title="6）Java 中堆和栈有什么区别？"></a>6）Java 中堆和栈有什么区别？</h4><p>答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-19ed61ccd60a57df.png" alt=""></p>
<hr>
<blockquote>
<p>小结：JVM 是自己之前没有去了解过得知识，所以这次写这篇文章写了很久，也学到了很多东西；在考虑要不要开微信公众号来着…</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol>
<li>《深入理解 Java 虚拟机》</li>
<li>《深入分析 Java Web技术内幕》</li>
</ol>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/tags/%E5%8E%9F%E5%88%9B/page/12/">
            <section class="post prev white-box shadow" >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          13 / 20
        </p>
        
          <a class="next" rel="next" href="/tags/%E5%8E%9F%E5%88%9B/page/14/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" href="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"
            id="categoriesE78988E69CACE789B9E680A7"
            ><div class='name'>版本特性</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" href="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/"
            id="categoriesE79FA5E4B98EE997AEE7AD94"
            ><div class='name'>知乎问答</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.86px; color: #868686">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.29px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.57px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.86px; color: #646464">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.43px; color: #6d6d6d">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.43px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 19.71px; color: #727272">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.71px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.86px; color: #868686">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.57px; color: #818181">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.57px; color: #818181">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.14px; color: #686868">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.71px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.43px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.14px; color: #8a8a8a">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.71px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.43px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.57px; color: #818181">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.71px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.29px; color: #7c7c7c">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.71px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.14px; color: #8a8a8a">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" style="font-size: 15.43px; color: #8f8f8f">版本特性</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" style="font-size: 14px; color: #999">知乎问答</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.86px; color: #868686">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.14px; color: #686868">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19px; color: #777">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
