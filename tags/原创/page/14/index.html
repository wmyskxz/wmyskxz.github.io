<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>标签：原创 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/21/java-mian-shi-zhi-shi-dian-jie-xi-liu-shu-ju-ku-pian/">
      Java面试知识点解析(六)——数据库篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月21日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<p><a href="https://www.jianshu.com/p/9c50729464b5" target="_blank" rel="noopener">Java 面试知识点解析(四)——版本特性篇</a></p>
<p><a href="https://www.jianshu.com/p/210f85108c52" target="_blank" rel="noopener">Java 面试知识点解析(五)——网络协议篇</a></p>
<hr>
<blockquote>
<p>前排引用说明及好文推荐：<a href="https://blog.csdn.net/justloveyou_/article/details/78308460" target="_blank" rel="noopener">面试/笔试第三弹 —— 数据库面试问题集锦</a>、<a href="https://segmentfault.com/a/1190000013517914" target="_blank" rel="noopener">数据库常见面试题(开发者篇)</a></p>
</blockquote>
<h3 id="1）什么是存储过程？有哪些优缺点？"><a href="#1）什么是存储过程？有哪些优缺点？" class="headerlink" title="1）什么是存储过程？有哪些优缺点？"></a>1）什么是存储过程？有哪些优缺点？</h3><p><strong>存储过程就像是编程语言中的函数一样，封装了我们的代码（PLSQL，T-SQL）</strong></p>
<p>例如：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-------------创建名为GetUserAccount的存储过程----------------</span>
<span class="token keyword">create</span> <span class="token keyword">Procedure</span> GetUserAccount
<span class="token keyword">as</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> UserAccount
go

<span class="token comment" spellcheck="true">-------------执行上面的存储过程----------------</span>
<span class="token keyword">exec</span> GetUserAccount</code></pre>
<p>存储过程的优点：</p>
<ul>
<li><strong>能够将代码封装起来</strong></li>
<li><strong>保存在数据库之中</strong></li>
<li><strong>让编程语言进行调用</strong></li>
<li><strong>存储过程是一个预编译的代码块，执行效率比较高</strong></li>
<li><strong>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</strong></li>
</ul>
<p>存储过程的缺点：</p>
<ul>
<li><strong>每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）</strong></li>
<li><strong>业务逻辑放在数据库上，难以迭代</strong></li>
</ul>
<hr>
<h3 id="2）三大范式"><a href="#2）三大范式" class="headerlink" title="2）三大范式"></a>2）三大范式</h3><blockquote>
<ul>
<li>思考这样的一个例子：</li>
</ul>
</blockquote>
<p>我们现在需要建立一个描述学校教务的数据库，该数据库涉及的对象包括学生的学号（Sno）、所在系（Sdept）、系主任姓名（Mname）、课程号（Cno）和成绩（Grade），假设我们使用单一的关系模式 Student 来表示，那么根据现实世界已知的信息，会描述成以下这个样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-344feccbb3cb1fad.png" alt=""></p>
<p>但是，这个关系模式存在以下问题：</p>
<p><strong>（1） 数据冗余</strong><br>比如，每一个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同，这将浪费大量的存储空间。<br><strong>（2）更新异常（update anomalies）</strong><br>由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。比如，某系更换系主任后，必须修改与该系学生有关的每一个元组。<br><strong>（3）插入异常（insertion anomalies）</strong><br>如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。<br><strong>（4）删除异常（deletion anomalies）</strong><br>如果某个系的学生全部毕业了，则在删除该系学生信息的同时，这个系及其系主任的信息也丢失了。</p>
<ul>
<li><strong>总结：</strong> 所以，我们在设计数据库的时候，就需要满足一定的规范要求，而满足不同程度要求的就是不同的范式。</li>
</ul>
<blockquote>
<ul>
<li><strong>第一范式：</strong> 列不可分</li>
</ul>
</blockquote>
<p>1NF（第一范式）是对属性具有<strong>原子性</strong>的要求，不可再分，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-7a54e7d5d8fbf659.png" alt=""></p>
<p>如果认为最后一列还可以再分成出生年，出生月，出生日，则它就不满足第一范式的要求。</p>
<blockquote>
<ul>
<li><strong>第二范式：</strong> 消除非主属性对码的部分函数依赖</li>
</ul>
</blockquote>
<p>2NF（第二范式）是对记录有<strong>唯一性</strong>的要求，即实体的唯一性，不存在部分依赖，每一列与主键都相关，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-a10fdbaf10a7e6b8.png" alt=""></p>
<p>该表明显说明了两个事物：学生信息和课程信息；正常的依赖应该是：学分依赖课程号，姓名依赖学号，但这里存在非主键字段对码的部分依赖，即与主键不相关，不满足第二范式的要求。</p>
<p><strong>可能存在的问题：</strong></p>
<ul>
<li><strong>数据冗余</strong>：每条记录都含有相同信息；</li>
<li><strong>删除异常</strong>：删除所有学生成绩，就把课程信息全删除了；</li>
<li><strong>插入异常</strong>：学生未选课，无法记录进数据库；</li>
<li><strong>更新异常</strong>：调整课程学分，所有行都调整。</li>
</ul>
<p><strong>正确的做法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-fba36ca283ffd5fc.png" alt=""></p>
<blockquote>
<ul>
<li><strong>第三范式：</strong> 消除非主属性对码的传递函数依赖</li>
</ul>
</blockquote>
<p>3NF（第三范式）对字段有<strong>冗余性</strong>的要求，任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在依赖传递，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-8d7548eb839bc8db.png" alt=""></p>
<p>很明显，学院电话是一个冗余字段，因为存在依赖传递：（学号）→（学生）→（学院）→（学院电话）</p>
<p><strong>可能会存在的问题：</strong></p>
<ul>
<li><strong>数据冗余</strong>：有重复值；</li>
<li><strong>更新异常</strong>：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况 。</li>
</ul>
<p><strong>正确的做法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-83c0288ea9150976.png" alt=""></p>
<hr>
<h3 id="3）数据库索引"><a href="#3）数据库索引" class="headerlink" title="3）数据库索引"></a>3）数据库索引</h3><blockquote>
<ul>
<li>什么是索引？</li>
</ul>
</blockquote>
<p><strong>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。</strong></p>
<p>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 </p>
<blockquote>
<ul>
<li>底层数据结构是什么，为什么使用这种数据结构？</li>
</ul>
</blockquote>
<p><strong>（1）底层数据结构是B+树：</strong><br>在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。</p>
<p><strong>（2）使用B+树的原因：</strong><br>查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（此时，你应该在白纸上画出什么是B+树）</p>
<blockquote>
<ul>
<li>索引的分类？</li>
</ul>
</blockquote>
<ul>
<li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li>
<li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li>
<li><strong>聚集索引(Clustered)</strong>：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
<li><strong>非聚集索引(Non-clustered)</strong>：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个</li>
</ul>
<blockquote>
<ul>
<li>索引的优缺点？</li>
</ul>
</blockquote>
<p><strong>（1）优点：</strong></p>
<ul>
<li><strong>大大加快数据的检索速度</strong>，这也是创建索引的最主要的原因；</li>
<li>加速表和表之间的连接；</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>
</ul>
<p><strong>（2）缺点：</strong></p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<blockquote>
<ul>
<li>什么样的字段适合创建索引？</li>
</ul>
</blockquote>
<ul>
<li>经常作查询选择的字段</li>
<li>经常作表连接的字段</li>
<li>经常出现在order by, group by, distinct 后面的字段</li>
</ul>
<blockquote>
<ul>
<li>创建索引时需要注意什么？</li>
</ul>
</blockquote>
<ul>
<li><p><strong>非空字段</strong>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
</li>
<li><p><strong>取值离散大的字段</strong>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>
</li>
<li><p><strong>索引字段越小越好</strong>：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>
</li>
</ul>
<hr>
<h3 id="4）听说过事务吗？（必考）"><a href="#4）听说过事务吗？（必考）" class="headerlink" title="4）听说过事务吗？（必考）"></a>4）听说过事务吗？（必考）</h3><p><strong>事务简单来说：一个 Session 中所进行所有的操作，要么同时成功，要么同时失败</strong>；作为单个逻辑工作单元执行的一系列操作，满足四大特性：</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行</li>
<li>一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li>持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存</li>
</ol>
<blockquote>
<ul>
<li>实例说明：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
 * 我们来模拟A向B账号转账的场景
 *   A和B账户都有1000块，现在我让A账户向B账号转500块钱
 *
 **/</span>
<span class="token comment" spellcheck="true">//JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题</span>

<span class="token comment" spellcheck="true">//A账户减去500块</span>
String sql <span class="token operator">=</span> <span class="token string">"UPDATE a SET money=money-500 "</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//B账户多了500块</span>
String sql2 <span class="token operator">=</span> <span class="token string">"UPDATE b SET money=money+500"</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>从上面看，我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// A账户减去500块</span>
String sql <span class="token operator">=</span> <span class="token string">"UPDATE a SET money=money-500 "</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 这里模拟出现问题</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>

String sql2 <span class="token operator">=</span> <span class="token string">"UPDATE b SET money=money+500"</span><span class="token punctuation">;</span>
preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>
preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>显然，上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。</p>
<p>我们可以通过事务来解决上面出现的问题：</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 开启事务,对数据的操作就不会立即生效。</span>
    connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// A账户减去500块</span>
    String sql <span class="token operator">=</span> <span class="token string">"UPDATE a SET money=money-500 "</span><span class="token punctuation">;</span>
    preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>
    preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 在转账过程中出现问题</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// B账户多500块</span>
    String sql2 <span class="token operator">=</span> <span class="token string">"UPDATE b SET money=money+500"</span><span class="token punctuation">;</span>
    preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    preparedStatement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 如果程序能执行到这里，没有抛出异常，我们就提交数据</span>
    connection<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 关闭事务【自动提交】</span>
    connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>SQLException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】</span>
        connection<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 关闭事务【自动提交】</span>
        connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。</p>
<ul>
<li><strong>注意</strong>：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。</li>
</ul>
<hr>
<h3 id="5）事务的并发问题有哪几种？"><a href="#5）事务的并发问题有哪几种？" class="headerlink" title="5）事务的并发问题有哪几种？"></a>5）事务的并发问题有哪几种？</h3><ol>
<li>丢失更新：一个事务的更新覆盖了另一个事务的更新；</li>
<li>脏读：一个事务读取了另一个事务未提交的数据；</li>
<li>不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；</li>
<li>幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。</li>
</ol>
<hr>
<h3 id="6）事务的隔离级别有哪几种？"><a href="#6）事务的隔离级别有哪几种？" class="headerlink" title="6）事务的隔离级别有哪几种？"></a>6）事务的隔离级别有哪几种？</h3><p>隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是：</p>
<ol>
<li><p>读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题；</p>
</li>
<li><p>读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题；</p>
</li>
<li><p>可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。 </p>
</li>
<li><p>序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。</p>
</li>
</ol>
<p><strong>MySQL默认的隔离级别是可重复读（REPEATABLE READ）</strong></p>
<blockquote>
<ul>
<li>MySql 的事务支持</li>
</ul>
</blockquote>
<p>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：</p>
<ul>
<li>MyISAM：不支持事务，用于只读程序提高性能；</li>
<li>InnoDB：支持ACID事务、行级锁、并发；</li>
<li>Berkeley DB：支持事务。</li>
</ul>
<hr>
<h3 id="7）什么是视图？以及视图的使用场景有哪些？"><a href="#7）什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="7）什么是视图？以及视图的使用场景有哪些？"></a>7）什么是视图？以及视图的使用场景有哪些？</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>如下两种场景一般会使用到视图：</p>
<ol>
<li>不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。</li>
</ol>
<p><strong>注意</strong>：这个视图是在数据库中创建的 而不是用代码创建的。</p>
<hr>
<h3 id="8）drop-delete与truncate的区别？"><a href="#8）drop-delete与truncate的区别？" class="headerlink" title="8）drop,delete与truncate的区别？"></a>8）drop,delete与truncate的区别？</h3><p>drop 直接删除表；truncate 删除表中数据，再插入时自增长id又从1开始 ；delete 删除表中数据，可以加where字句。</p>
<blockquote>
<ul>
<li><strong>drop table：</strong></li>
</ul>
</blockquote>
<ul>
<li>属于DDL（Data Definition Language，数据库定义语言）</li>
<li>不可回滚</li>
<li>不可带 where</li>
<li>表内容和结构删除</li>
<li>删除速度快</li>
</ul>
<blockquote>
<ul>
<li><strong>truncate table：</strong></li>
</ul>
</blockquote>
<ul>
<li>属于DDL（Data Definition Language，数据库定义语言）</li>
<li>不可回滚</li>
<li>不可带 where</li>
<li>表内容删除</li>
<li>删除速度快</li>
</ul>
<blockquote>
<ul>
<li><strong>delete from：</strong></li>
</ul>
</blockquote>
<ul>
<li>属于DML</li>
<li>可回滚</li>
<li>可带where</li>
<li>表结构在，表内容要看where执行的情况</li>
<li>删除速度慢,需要逐行删除</li>
</ul>
<blockquote>
<ul>
<li><strong>使用简要说明：</strong></li>
</ul>
</blockquote>
<ul>
<li>不再需要一张表的时候，用drop</li>
<li>想删除部分数据行时候，用delete，并且带上where子句</li>
<li>保留表而删除所有数据的时候用truncate</li>
</ul>
<hr>
<h3 id="9）触发器的作用？"><a href="#9）触发器的作用？" class="headerlink" title="9）触发器的作用？"></a>9）触发器的作用？</h3><p>触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。</p>
<hr>
<h3 id="10）数据库的乐观锁和悲观锁是什么？"><a href="#10）数据库的乐观锁和悲观锁是什么？" class="headerlink" title="10）数据库的乐观锁和悲观锁是什么？"></a>10）数据库的乐观锁和悲观锁是什么？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 </p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<blockquote>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
</ul>
</blockquote>
<p>悲观锁是一种利用数据库内部机制提供的锁的方式，也就是对更新的数据加锁，这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了，这就是悲观锁的实现方式。</p>
<p><strong>MySQL InnoDB中使用悲观锁：</strong></p>
<p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0; </p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">//0.开始事务</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">begin</span> <span class="token keyword">work</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>三者选一就可以<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//1.查询出商品信息</span>
<span class="token keyword">select</span> <span class="token keyword">status</span> <span class="token keyword">from</span> t_goods <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//2.根据商品信息生成订单</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t_orders <span class="token punctuation">(</span>id<span class="token punctuation">,</span>goods_id<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//3.修改商品status为2</span>
<span class="token keyword">update</span> t_goods <span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//4.提交事务</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token keyword">commit</span> <span class="token keyword">work</span><span class="token punctuation">;</span></code></pre>
<p>上面的查询语句中，我们使用了 <code>select…for update</code> 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<p>上面我们提到，使用 <code>select…for update</code> 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>
<p><strong>优点与不足：</strong></p>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
<blockquote>
<ul>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
</ul>
</blockquote>
<p>乐观锁是一种不会阻塞其他线程并发的控制，它不会使用数据库的锁进行实现，它的设计里面由于不阻塞其他线程，所以并不会引起线程频繁挂起和恢复，这样便能够提高并发能力，所以也有人把它称为非阻塞锁。一般的实现乐观锁的方式就是记录数据版本。</p>
<p>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
<p><strong>使用版本号实现乐观锁：</strong></p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">.</span>查询出商品信息
<span class="token keyword">select</span> <span class="token punctuation">(</span><span class="token keyword">status</span><span class="token punctuation">,</span><span class="token keyword">status</span><span class="token punctuation">,</span>version<span class="token punctuation">)</span> <span class="token keyword">from</span> t_goods <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id}</span>
<span class="token number">2</span><span class="token punctuation">.</span>根据商品信息生成订单
<span class="token number">3</span><span class="token punctuation">.</span>修改商品<span class="token keyword">status</span>为<span class="token number">2</span>
<span class="token keyword">update</span> t_goods 
<span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment" spellcheck="true">#{id} and version=#{version};</span></code></pre>
<p><strong>优点与不足：</strong></p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<blockquote>
<p>参考文章：<a href="http://www.open-open.com/lib/view/open1452046967245.html" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></p>
</blockquote>
<hr>
<h3 id="11）超键、候选键、主键、外键分别是什么？"><a href="#11）超键、候选键、主键、外键分别是什么？" class="headerlink" title="11）超键、候选键、主键、外键分别是什么？"></a>11）超键、候选键、主键、外键分别是什么？</h3><ul>
<li><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
</li>
<li><p>候选键（候选码）：是最小超键，即没有冗余元素的超键。</p>
</li>
<li><p>主键（主码）：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p>
</li>
<li><p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
</li>
</ul>
<p><strong>候选码和主码：</strong></p>
<p>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）</p>
<ul>
<li><strong>它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}</strong></li>
<li><strong>如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键)</strong></li>
</ul>
<hr>
<h3 id="12）SQL-约束有哪几种？"><a href="#12）SQL-约束有哪几种？" class="headerlink" title="12）SQL 约束有哪几种？"></a>12）SQL 约束有哪几种？</h3><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<hr>
<h3 id="13）MySQL存储引擎中的MyISAM和InnoDB区别详解"><a href="#13）MySQL存储引擎中的MyISAM和InnoDB区别详解" class="headerlink" title="13）MySQL存储引擎中的MyISAM和InnoDB区别详解"></a>13）MySQL存储引擎中的MyISAM和InnoDB区别详解</h3><p>在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，其由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然MyISAM性能极佳，但却有一个显著的缺点： <strong>不支持事务处理</strong>。不过，MySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p>
<p>InnoDB是MySQL的数据库引擎之一，其由Innobase oy公司所开发，2006年五月由甲骨文公司并购。与传统的ISAM、MyISAM相比，<strong>InnoDB的最大特色就是支持ACID兼容的事务功能</strong>，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。具体地，MyISAM与InnoDB作为MySQL的两大存储引擎的差异主要包括：</p>
<ul>
<li><p><strong>存储结构</strong>：每个MyISAM在磁盘上存储成三个文件：第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
</li>
<li><p><strong>存储空间</strong>：MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
</li>
<li><p><strong>可移植性、备份及恢复</strong>：MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
</li>
<li><p><strong>事务支持</strong>：MyISAM强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。</p>
</li>
<li><p><strong>AUTO_INCREMENT</strong>：在MyISAM中，可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引，并且引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p>
</li>
<li><p><strong>表锁差异</strong>：MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
</li>
<li><p><strong>全文索引</strong>：MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p>
</li>
<li><p><strong>表主键</strong>：MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p>
</li>
<li><p><strong>表的具体行数</strong>：MyISAM保存表的总行数，select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p>
</li>
<li><p><strong>CURD操作</strong>：在MyISAM中，如果执行大量的SELECT，MyISAM是更好的选择。对于InnoDB，如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p>
</li>
<li><p><strong>外键</strong>：MyISAM不支持外键，而InnoDB支持外键。</p>
</li>
</ul>
<p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁、外键等等。尤其在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，必须需要注意的是，任何一种表都不是万能的，合适的才是最好的，才能最大的发挥MySQL的性能优势。如果是不复杂的、非关键的Web应用，还是可以继续考虑MyISAM的，这个具体情况具体考虑。</p>
<hr>
<h3 id="14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"><a href="#14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？" class="headerlink" title="14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？"></a>14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？</h3><p>答案:都是B+树!</p>
<p>MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，<strong>只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。</strong></p>
<p>Innodb引擎的索引的数据结构也是B+树，<strong>只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。</strong></p>
<hr>
<h3 id="15）varchar和char的区别"><a href="#15）varchar和char的区别" class="headerlink" title="15）varchar和char的区别"></a>15）varchar和char的区别</h3><p>char是一种固定长度的类型，varchar是一种可变长度的类型，例如：</p>
<p>定义一个char[10]和varchar[10]，如果存进去的是 ‘test’，那么char所占的长度依然为10，除了字符 ‘test’ 外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的</p>
<p>char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储于查找</p>
<p>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。</p>
<p>varchar是以空间效率为首位。</p>
<p>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</p>
<p>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。<br>两者的存储数据都非unicode的字符数据。</p>
<hr>
<h3 id="16）主键、自增主键、主键索引与唯一索引概念区别"><a href="#16）主键、自增主键、主键索引与唯一索引概念区别" class="headerlink" title="16）主键、自增主键、主键索引与唯一索引概念区别"></a>16）主键、自增主键、主键索引与唯一索引概念区别</h3><ol>
<li><p>主键：指字段 <strong>唯一、不为空值</strong> 的列；</p>
</li>
<li><p>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</p>
</li>
<li><p>自增主键：字段类型为数字、自增、并且是主键；</p>
</li>
<li><p>唯一索引：索引列的值必须唯一，但允许有空值。<strong>主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</strong></p>
</li>
</ol>
<hr>
<h3 id="17）主键就是聚集索引吗？主键和索引有什么区别？"><a href="#17）主键就是聚集索引吗？主键和索引有什么区别？" class="headerlink" title="17）主键就是聚集索引吗？主键和索引有什么区别？"></a>17）主键就是聚集索引吗？主键和索引有什么区别？</h3><p><strong>主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。</strong>在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。</p>
<hr>
<h3 id="18）实践中如何优化MySQL"><a href="#18）实践中如何优化MySQL" class="headerlink" title="18）实践中如何优化MySQL"></a>18）实践中如何优化MySQL</h3><p>实践中，MySQL的优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-7a6deca3ebd226e3.png" alt=""></p>
<h4 id="⑴-SQL语句优化："><a href="#⑴-SQL语句优化：" class="headerlink" title="⑴ SQL语句优化："></a>⑴ SQL语句优化：</h4><p>SQL语句的优化主要包括三个问题，即如何发现有问题的SQL、如何分析SQL的执行计划以及如何优化SQL，下面将逐一解释。</p>
<p><strong>① 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）</strong></p>
<p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/7896890-79123c126bb94a31.png" alt=""></p>
<p>通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。</p>
<p><strong>② 通过explain查询和分析SQL的执行计划：</strong></p>
<p>使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。</p>
<p><strong>③ SQL语句的优化：</strong></p>
<p><strong>⒈优化insert语句：一次插入多值；</strong></p>
<p><strong>⒉应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描；</strong></p>
<p><strong>⒊应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；</strong></p>
<p><strong>⒋优化嵌套查询：子查询可以被更有效率的连接(Join)替代；</strong></p>
<p><strong>⒌很多时候用 exists 代替 in 是一个好的选择。</strong></p>
<p><strong>⒍选择最有效率的表名顺序：数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p>
<p>在FROM子句中包含多个表的情况下：</p>
<ul>
<li>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</li>
<li>也就是说：选择记录条数最少的表放在最后</li>
</ul>
<p>如果有3个以上的表连接查询：</p>
<ul>
<li>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。</li>
<li>也就是说：被其他表所引用的表放在最后</li>
</ul>
<p><strong>⒎用IN代替OR：</strong></p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">=</span> <span class="token number">1500</span> <span class="token operator">or</span> sal <span class="token operator">=</span> <span class="token number">3000</span> <span class="token operator">or</span> sal <span class="token operator">=</span> <span class="token number">800</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>⒏SELECT子句中避免使用*号：</strong></p>
<p>我们最开始接触 SQL 的时候，“<code>*</code>” 号是可以获取表中全部的字段数据的，<strong>但是它要通过查询数据字典完成，这意味着将消耗更多的时间</strong>，而且使用 “<code>*</code>” 号写出来的 SQL 语句也不够直观。</p>
<hr>
<h4 id="⑵-索引优化："><a href="#⑵-索引优化：" class="headerlink" title="⑵ 索引优化："></a>⑵ 索引优化：</h4><p>建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在 order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形：</p>
<ul>
<li><p>以 “%(表示任意0个或多个字符)” 开头的 LIKE 语句，模糊匹配；</p>
</li>
<li><p>OR语句前后没有同时使用索引；</p>
</li>
<li><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</p>
</li>
<li><p>对于多列索引，必须满足最左匹配原则(eg,多列索引col1、col2和col3，则 索引生效的情形包括col1或col1，col2或col1，col2，col3)。</p>
</li>
</ul>
<hr>
<h4 id="⑶-数据库表结构的优化："><a href="#⑶-数据库表结构的优化：" class="headerlink" title="⑶ 数据库表结构的优化："></a>⑶ 数据库表结构的优化：</h4><p><strong>① 选择合适数据类型：</strong></p>
<ul>
<li>使用较小的数据类型解决问题；</li>
<li>使用简单的数据类型(mysql处理int要比varchar容易)；</li>
<li>尽可能的使用not null 定义字段；</li>
<li>尽量避免使用text类型，非用不可时最好考虑分表；</li>
</ul>
<p><strong>② 表的范式的优化：</strong></p>
<p>一般情况下，表的设计应该遵循三大范式。</p>
<p><strong>③ 表的垂直拆分：</strong></p>
<p>把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：</p>
<ul>
<li>把不常用的字段单独放在同一个表中；</li>
<li>把大字段独立放入一个表中；</li>
<li>把经常使用的字段放在一起； </li>
</ul>
<p>这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单</p>
<p><strong>④ 表的水平拆分：</strong></p>
<p>表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：</p>
<ul>
<li>对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；</li>
<li>针对不同的hashID将数据存入不同的表中；</li>
</ul>
<p>表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处：</p>
<ul>
<li>表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；</li>
<li>表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</li>
<li>需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)。</li>
</ul>
<hr>
<h4 id="⑷-系统配置的优化："><a href="#⑷-系统配置的优化：" class="headerlink" title="⑷ 系统配置的优化："></a>⑷ 系统配置的优化：</h4><ul>
<li><p>操作系统配置的优化：增加TCP支持的队列数</p>
</li>
<li><p>mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances）</p>
</li>
</ul>
<hr>
<h4 id="⑸-硬件的优化："><a href="#⑸-硬件的优化：" class="headerlink" title="⑸ 硬件的优化："></a>⑸ 硬件的优化：</h4><ul>
<li>CPU：核心数多并且主频高的</li>
<li>内存：增大内存</li>
<li>磁盘配置和选择：磁盘性能</li>
</ul>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/18/java-mian-shi-zhi-shi-dian-jie-xi-wu-wang-luo-xie-yi-pian/">
      Java面试知识点解析(五)——网络协议篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月18日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<p><a href="https://www.jianshu.com/p/9c50729464b5" target="_blank" rel="noopener">Java 面试知识点解析(四)——版本特性篇</a></p>
<hr>
<blockquote>
<p>前排引用说明及好文推荐：<a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">面试/笔试第一弹 —— 计算机网络面试问题集锦——书呆子Rico</a></p>
</blockquote>
<h2 id="（一）网络基础知识"><a href="#（一）网络基础知识" class="headerlink" title="（一）网络基础知识"></a>（一）网络基础知识</h2><h3 id="1）Http和Https的区别？"><a href="#1）Http和Https的区别？" class="headerlink" title="1）Http和Https的区别？"></a>1）Http和Https的区别？</h3><p>答：Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<ul>
<li><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>
</li>
<li><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>
</li>
<li><p>开销：Https通信需要证书，而证书一般需要向认证机构购买；</p>
</li>
</ul>
<p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<hr>
<h3 id="2）对称加密与非对称加密"><a href="#2）对称加密与非对称加密" class="headerlink" title="2）对称加密与非对称加密"></a>2）对称加密与非对称加密</h3><p>答：</p>
<p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<hr>
<h3 id="3）三次握手与四次挥手"><a href="#3）三次握手与四次挥手" class="headerlink" title="3）三次握手与四次挥手"></a>3）三次握手与四次挥手</h3><p>答：</p>
<p><strong>(1). 三次握手（我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功）</strong></p>
<ul>
<li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
</li>
<li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-ef0439a102c5432f.png" alt=""></p>
<p><strong>(2). 四次挥手（我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）：</strong></p>
<ul>
<li><p>第一次挥手：Client发送一个FIN，<strong>用来关闭Client到Server的数据传送</strong>，Client进入FIN_WAIT_1状态。</p>
</li>
<li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p>
</li>
<li><p>第三次挥手：Server发送一个FIN，<strong>用来关闭Server到Client的数据传送</strong>，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-23ddca6bf4289f92.png" alt=""></p>
<p><strong>(3). 通俗一点的理解就是：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-895124472bd4317b.png" alt=""></p>
<hr>
<h3 id="4）为什么-TCP-链接需要三次握手，两次不可以么？"><a href="#4）为什么-TCP-链接需要三次握手，两次不可以么？" class="headerlink" title="4）为什么 TCP 链接需要三次握手，两次不可以么？"></a>4）为什么 TCP 链接需要三次握手，两次不可以么？</h3><p>答：“三次握手” 的目的是为了防止<strong>已失效的链接请求报文突然又传送到了服务端</strong>，因而产生错误。</p>
<ul>
<li><p>正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。</p>
</li>
<li><p>现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</p>
</li>
</ul>
<p>假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p>
<hr>
<h3 id="5）为什么要四次挥手？"><a href="#5）为什么要四次挥手？" class="headerlink" title="5）为什么要四次挥手？"></a>5）为什么要四次挥手？</h3><p>答：TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p>
<p>所以想要愉快的结束这次对话就需要四次挥手。</p>
<hr>
<h3 id="6）TCP-协议如何来保证传输的可靠性"><a href="#6）TCP-协议如何来保证传输的可靠性" class="headerlink" title="6）TCP 协议如何来保证传输的可靠性"></a>6）TCP 协议如何来保证传输的可靠性</h3><p>答：TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</p>
<p><strong>对于可靠性，TCP通过以下方式进行保证：</strong></p>
<ul>
<li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
</li>
<li><p><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
</li>
<li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</p>
</li>
<li><p><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
</li>
<li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
</li>
<li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
</li>
</ul>
<hr>
<h3 id="7）客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？"><a href="#7）客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？" class="headerlink" title="7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？"></a>7）客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h3><p>答：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>
<p><strong>(1). DDos 攻击：</strong></p>
<ul>
<li>客户端向服务端发送请求链接数据包</li>
<li>服务端向客户端发送确认数据包</li>
<li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>
</ul>
<p><strong>(2). DDos 预防：（没有彻底根治的办法，除非不使用TCP）</strong></p>
<ul>
<li>限制同时打开SYN半链接的数目</li>
<li>缩短SYN半链接的Time out 时间</li>
<li>关闭不必要的服务</li>
</ul>
<hr>
<h3 id="8）GET-与-POST-的区别？"><a href="#8）GET-与-POST-的区别？" class="headerlink" title="8）GET 与 POST 的区别？"></a>8）GET 与 POST 的区别？</h3><p>答：GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面： </p>
<p>(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</p>
<p>(2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</p>
<p>(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</p>
<p>(4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</p>
<p>(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p>
<p><strong>为什么在GET请求中会对URL进行编码？</strong></p>
<p>我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 <strong>避免歧义</strong>。看下面的例子，</p>
<p>针对 “name1=value1&amp;name2=value2” 的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为： </p>
<pre><code>   6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532
   6E616D6531：name1 
   3D：= 
   76616C756531：value1 
   26：&amp;
   6E616D6532：name2 
   3D：= 
   76616C756532：value2 </code></pre><p>服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</p>
<p>现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。</p>
<p>那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</p>
<hr>
<h3 id="9）TCP与UDP的区别"><a href="#9）TCP与UDP的区别" class="headerlink" title="9）TCP与UDP的区别"></a>9）TCP与UDP的区别</h3><p>答：TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p>
<ul>
<li><p>TCP是面向连接的，UDP是无连接的；</p>
</li>
<li><p>TCP是可靠的，UDP是不可靠的；</p>
</li>
<li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p>
</li>
<li><p>TCP是面向字节流的，UDP是面向报文的；</p>
</li>
<li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p>
</li>
<li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>
</li>
</ul>
<hr>
<h3 id="10）TCP和UDP分别对应的常见应用层协议"><a href="#10）TCP和UDP分别对应的常见应用层协议" class="headerlink" title="10）TCP和UDP分别对应的常见应用层协议"></a>10）TCP和UDP分别对应的常见应用层协议</h3><p>答：</p>
<p><strong>(1). TCP 对应的应用层协议：</strong></p>
<ul>
<li><p><strong>FTP</strong>：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p>
</li>
<li><p><strong>Telnet</strong>：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p>
</li>
<li><p><strong>SMTP</strong>：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p>
</li>
<li><p><strong>POP3</strong>：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>
</li>
<li><p><strong>HTTP</strong>：从Web服务器传输超文本到本地浏览器的传送协议。</p>
</li>
</ul>
<p><strong>(2). UDP 对应的应用层协议：</strong></p>
<ul>
<li><p><strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p>
</li>
<li><p><strong>SNMP</strong>：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
</li>
<li><p><strong>TFTP(Trival File Transfer Protocal)</strong>：简单文件传输协议，该协议在熟知端口69上使用UDP服务</p>
</li>
</ul>
<p><strong>(3). 图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-54d6f58268936b77.png" alt=""></p>
<hr>
<h3 id="11）TCP-的拥塞避免机制"><a href="#11）TCP-的拥塞避免机制" class="headerlink" title="11）TCP 的拥塞避免机制"></a>11）TCP 的拥塞避免机制</h3><p>答：</p>
<p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p>
<p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p>
<p>拥塞控制的方法：</p>
<p><strong>(1). 慢启动 + 拥塞避免：</strong></p>
<p><strong>慢启动</strong>：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>
<p><strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-15f6b11bb3c818ed.png" alt=""></p>
<p><strong>(2). 快重传 + 快恢复：</strong></p>
<p><strong>快重传</strong>：快重传要求接收方在收到一个 <strong>失序的报文段</strong> 后就立即发出 <strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-6015eb200dacea82.png" alt=""></p>
<p><strong>快恢复</strong>：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-0d52d7832b4a9c2a.png" alt=""></p>
<hr>
<h3 id="12）浏览器中输入：“www-xxx-com”-之后都发生了什么？请详细阐述。"><a href="#12）浏览器中输入：“www-xxx-com”-之后都发生了什么？请详细阐述。" class="headerlink" title="12）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。"></a>12）浏览器中输入：“<code>www.xxx.com</code>” 之后都发生了什么？请详细阐述。</h3><p>解析：经典的网络协议问题。</p>
<p>答：</p>
<ol>
<li>由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。</li>
<li>建立TCP/IP连接（三次握手具体过程）</li>
<li>由浏览器发送一个HTTP请求</li>
<li>经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器</li>
<li>服务器处理该HTTP请求，返回一个HTML文件</li>
<li>浏览器解析该HTML文件，并且显示在浏览器端</li>
<li>这里需要注意：<ul>
<li>HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接</li>
<li>可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</li>
<li>两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="13）什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#13）什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>13）什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h3><p>答：HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。</p>
<p>HTTP 的这种特性有优点也有缺点：</p>
<ul>
<li><strong>优点</strong>：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用</li>
<li><strong>缺点</strong>：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享</li>
</ul>
<p>解决方案：</p>
<ol>
<li>使用参数传递机制：<br>将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：<code>/param/list?username=wmyskxz</code></li>
</ol>
<p><strong>问题</strong>：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb<br>2. 使用 Cookie 技术<br>3. 使用 Session 技术</p>
<hr>
<h3 id="14）Session、Cookie-与-Application"><a href="#14）Session、Cookie-与-Application" class="headerlink" title="14）Session、Cookie 与 Application"></a>14）Session、Cookie 与 Application</h3><p>答：Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p><strong>(1). Cookie 及其相关 API ：</strong></p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-5cba15b5ebdc21fa.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-aa39c7450ebaeb48.png" alt=""></p>
<p><strong>(2). Session 及其相关 API：</strong></p>
<p>同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 <strong>cookie机制</strong> ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 <strong>URL重写机制</strong> 将sessionid传回服务器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-4045b82e54d98900.png" alt=""></p>
<p><strong>(3). Session 与 Cookie 的对比：</strong></p>
<ul>
<li><p><strong>实现机制</strong>：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p>
</li>
<li><p><strong>大小限制</strong>：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
</li>
<li><p><strong>安全性</strong>：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
</li>
<li><p><strong>服务器资源消耗</strong>：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
</li>
</ul>
<p><strong>(4). Application：</strong></p>
<p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p>
<hr>
<h3 id="15）滑动窗口机制"><a href="#15）滑动窗口机制" class="headerlink" title="15）滑动窗口机制"></a>15）滑动窗口机制</h3><p>答：由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。这就实现了流量的控制。</p>
<hr>
<h3 id="16）常用的HTTP方法有哪些？"><a href="#16）常用的HTTP方法有哪些？" class="headerlink" title="16）常用的HTTP方法有哪些？"></a>16）常用的HTTP方法有哪些？</h3><p>答：</p>
<ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<hr>
<h3 id="17）常见HTTP状态码"><a href="#17）常见HTTP状态码" class="headerlink" title="17）常见HTTP状态码"></a>17）常见HTTP状态码</h3><p>答：</p>
<ol>
<li><p>1xx（临时响应）</p>
</li>
<li><p>2xx（成功）</p>
</li>
<li><p>3xx（重定向）：表示要完成请求需要进一步操作</p>
</li>
<li><p>4xx（错误）：表示请求可能出错，妨碍了服务器的处理</p>
</li>
<li><p>5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误</p>
</li>
<li><p>常见状态码：</p>
<ul>
<li>200（成功）</li>
<li>304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li>
<li>401（未授权）：请求要求身份验证</li>
<li>403（禁止）：服务器拒绝请求</li>
<li>404（未找到）：服务器找不到请求的网页</li>
</ul>
</li>
</ol>
<hr>
<h3 id="18）SQL-注入"><a href="#18）SQL-注入" class="headerlink" title="18）SQL 注入"></a>18）SQL 注入</h3><p>答：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p><strong>(1).SQL注入攻击的总体思路：</strong></p>
<ol>
<li>寻找到SQL注入的位置</li>
<li>判断服务器类型和后台数据库类型</li>
<li>针对不通的服务器和数据库特点进行SQL注入攻击</li>
</ol>
<p><strong>(2). SQL注入攻击实例：</strong></p>
<p>比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：</p>
<pre><code>用户名： ‘or 1 = 1 --
密 码：</code></pre><p>用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：</p>
<p><code>String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;</code></p>
<p> 因此，当输入了上面的用户名和密码，上面的SQL语句变成：</p>
<p><code>SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’</code></p>
<p>分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</p>
<p><strong>(3). 应对方法：</strong></p>
<p>1.参数绑定：</p>
<p>使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和$来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。</p>
<p>2.使用正则表达式过滤传入的参数</p>
<hr>
<h3 id="19）XSS-攻击"><a href="#19）XSS-攻击" class="headerlink" title="19）XSS 攻击"></a>19）XSS 攻击</h3><p>答：XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p>
<p><strong>(1). XSS攻击的危害：</strong></p>
<ul>
<li><p>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p>
</li>
<li><p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p>
</li>
<li><p>盗窃企业重要的具有商业价值的资料</p>
</li>
<li><p>非法转账</p>
</li>
<li><p>强制发送电子邮件</p>
</li>
<li><p>网站挂马</p>
</li>
<li><p>控制受害者机器向其它网站发起攻击</p>
</li>
</ul>
<p><strong>(2). 原因解析：</strong></p>
<ul>
<li><strong>主要原因</strong>：过于信任客户端提交的数据！</li>
<li><strong>解决办法</strong>：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。</li>
<li><strong>进一步分析细节</strong>：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！</li>
</ul>
<p><strong>(3). XSS 攻击分类：</strong></p>
<ul>
<li><ol>
<li>反射性 XSS 攻击（非持久性 XSS 攻击）：</li>
</ol>
</li>
</ul>
<p>漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：</p>
<pre><code>http://www.test.com/message.php?send=Hello,World！</code></pre><p>接收者将会接收信息并显示Hello,World；但是，非正常发送消息：</p>
<pre><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！</code></pre><p>接收者接收消息显示的时候将会弹出警告窗口！</p>
<ul>
<li><ol start="2">
<li>持久性XSS攻击 (留言板场景)：</li>
</ol>
</li>
</ul>
<p>XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。</p>
<p>例如，留言板表单中的表单域：</p>
<pre><code>&lt;input type=“text” name=“content” value=“这里是用户填写的数据”&gt;</code></pre><p>正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:</p>
<pre><code>&lt;script&gt;alert(‘foolish!’)；&lt;/script&gt; &lt;!--或者html其他标签（破坏样式）、一段攻击型代码--&gt;</code></pre><p>并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。</p>
<p><strong>(4). 修复漏洞方针：</strong></p>
<p>漏洞产生的根本原因是 <strong>太相信用户提交的数据，对用户所提交的数据过滤不足所导致的</strong>，因此解决方案也应该从这个方面入手，具体方案包括：</p>
<ul>
<li><p>将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；</p>
</li>
<li><p>表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。</p>
</li>
<li><p>对数据进行Html Encode 处理</p>
</li>
<li><p>过滤或移除特殊的Html标签，例如: <script>, <iframe> , < for <, > for>, &quot for</p>
</li>
<li><p>过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。</p>
</li>
</ul>
<p>需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！</p>
<hr>
<h3 id="20）OSI-网络体系结构与-TCP-IP-协议模型"><a href="#20）OSI-网络体系结构与-TCP-IP-协议模型" class="headerlink" title="20）OSI 网络体系结构与 TCP/IP 协议模型"></a>20）OSI 网络体系结构与 TCP/IP 协议模型</h3><p>答：OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对 OSI 七层模型的各层进行简要的介绍：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-345e2a0ad5199201.png" alt=""></p>
<hr>
<p>1). 物理层</p>
<p>参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p>
<hr>
<p>2). 数据链路层（data link layer）</p>
<p>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p>
<hr>
<p>3). 网络层</p>
<p>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-e4dc728c4dd77c69.png" alt=""></p>
<hr>
<p>4). 传输层（transport layer）</p>
<p>在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-c6ab5e41ee213bfc.png" alt=""></p>
<p>实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p>
<hr>
<p>5). 会话层（Session Layer）</p>
<p>会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p>
<hr>
<p>6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密</p>
<p>表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p>
<hr>
<p>7). 应用层（Application layer）：为用户的应用进程提供网络通信服务</p>
<hr>
<h3 id="21）网络层的-ARP-协议工作原理？"><a href="#21）网络层的-ARP-协议工作原理？" class="headerlink" title="21）网络层的 ARP 协议工作原理？"></a>21）网络层的 ARP 协议工作原理？</h3><p>答：地址解析协议(ARP) 是通过解析网路层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。</p>
<p><strong>网络层的ARP协议完成了IP地址与物理地址的映射</strong>。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<hr>
<h3 id="22）IP地址的分类"><a href="#22）IP地址的分类" class="headerlink" title="22）IP地址的分类"></a>22）IP地址的分类</h3><p>答：整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位标识符，它是一个逻辑地址，用以屏蔽掉物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p>
<p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p>
<ul>
<li>A类地址：以0开头，第一个字节范围：0~127；</li>
<li>B类地址：以10开头，第一个字节范围：128~191；</li>
<li>C类地址：以110开头，第一个字节范围：192~223；</li>
<li>D类地址：以1110开头，第一个字节范围为224~239；</li>
<li>E类地址：以1111开头，保留地址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AF%87/7896890-3e9b7e052218c240.png" alt=""></p>
<hr>
<p><strong>1). A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”</strong></p>
<p>一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。</p>
<p>A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。</p>
<hr>
<p><strong>2). B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”</strong></p>
<p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。</p>
<p>B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。</p>
<hr>
<p><strong>3). C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”</strong></p>
<p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p>
<p>C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。</p>
<hr>
<p><strong>4). D类地址:多播地址，用于1对多通信，最高位必须是“1110”</strong></p>
<p>　　D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。</p>
<hr>
<p><strong>5). E类地址:为保留地址，最高位必须是“1111”</strong></p>
<hr>
<h3 id="23）IP地址与物理地址"><a href="#23）IP地址与物理地址" class="headerlink" title="23）IP地址与物理地址"></a>23）IP地址与物理地址</h3><p>答：物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p>
<hr>
<h3 id="24）影响网络传输的因素有哪些？"><a href="#24）影响网络传输的因素有哪些？" class="headerlink" title="24）影响网络传输的因素有哪些？"></a>24）影响网络传输的因素有哪些？</h3><p>答：将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。</p>
<ul>
<li><p>网络带宽：所谓带宽就是一条物理链路在 1s 内能够传输的最大比特数，注意这里是比特（bit）而不是字节数，也就是 b/s 。网络带宽肯定是影响数据传输的一个关键环节，因为在当前的网络环境中，平均网络带宽只有 1.7 MB/s 左右。</p>
</li>
<li><p>传输距离：也就是数据在光纤中要走的距离，虽然光的传播速度很快，但也是有时间的，由于数据在光纤中的移动并不是走直线的，会有一个折射率，所以大概是光的 2/3，这个时间也就是我们通常所说的传输延时。传输延时是一个无法避免的问题，例如，你要给在杭州和青岛的两个机房的一个数据库进行同步数据操作，那么必定会存在约 30ms 的一个延时。</p>
</li>
<li><p>TCP 拥塞控制：我们知道 TCP 传输是一个 “停-等-停-等” 的协议，传输方和接受方的步调要一致，要达到步调一致就要通过拥塞控制来调节。TCP 在传输时会设定一个 “窗口”，这个窗口的大小是由带宽和 RTT（Round-Trip Time，数据在两端的来回时间，也就是响应时间）决定的。计算的公式是带宽（b/s）xRTT（s）。通过这个值就可以得出理论上最优的 TCP 缓冲区的大小。Linux 2.4 已经可以自动地调整发送端的缓冲区的大小，而到 Linux 2.6.7 时接收端也可以自动调整了。</p>
</li>
</ul>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/17/java-mian-shi-zhi-shi-dian-jie-xi-si-ban-ben-te-xing-pian/">
      Java面试知识点解析(四)——版本特性篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月17日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<p><a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">Java 面试知识点解析(三)——JVM篇</a></p>
<hr>
<blockquote>
<p>对于 Java 各个版本的特性，特别是 Java 8 的新知识点，我们都应该有所了解。<br>前排申明和好文推荐：<a href="http://blinkfox.com" target="_blank" rel="noopener">闪烁之狐</a> » <a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a> » <a href="http://blinkfox.com/java6xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java6新特性及使用</a> » <a href="http://blinkfox.com/java7xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java7新特性及使用</a> » <a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用(一)</a> » <a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-er/" target="_blank" rel="noopener">Java8新特性及使用(二)</a></p>
</blockquote>
<h2 id="（一）Java-5-相关知识点"><a href="#（一）Java-5-相关知识点" class="headerlink" title="（一）Java 5 相关知识点"></a>（一）Java 5 相关知识点</h2><blockquote>
<p>参考文章：<a href="https://www.kancloud.cn/alex_wsc/java/466883" target="_blank" rel="noopener">jdk 1.5新特性</a></p>
</blockquote>
<h4 id="1）增强型-for-循环："><a href="#1）增强型-for-循环：" class="headerlink" title="1）增强型 for 循环："></a>1）增强型 for 循环：</h4><p>答：增强 for 循环：foreach 语句，foreach 简化了迭代器。</p>
<p>格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span> 元素类型 变量名 <span class="token operator">:</span> Collection集合 <span class="token operator">&amp;</span> 数组 <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
<span class="token punctuation">}</span></code></pre>
<p>语法：<br><code>for ( type 变量名：集合变量名 ) { … }</code></p>
<p>注意事项：</p>
<ul>
<li>迭代变量必须在( )中定义！</li>
<li>集合变量可以是数组或实现了Iterable接口的集合类。</li>
</ul>
<p><strong>高级for循环和传统for循环的区别：</strong></p>
<p>高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是Collection集合或者数组，如果遍历Collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。</p>
<p>如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。比起普通的for循环，高级for循环还有性能优势，因为它对数组索引的边界值只计算一次（摘自《Effective Java》第46条）。</p>
<p><strong>高级for循环可以遍历map集合吗？</strong></p>
<p>答：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了Iterable接口的集合进行迭代；Iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了Iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>Object obj <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token punctuation">.</span>Entry entry <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// obj 依次表示Entry</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>总之，for-each 循环在简洁性和预防 Bug 方面有着传统 for 循环无法比拟的优势，并且没有性能损失。应该尽可能地使用 for-each 循环。遗憾的是，有三种常见的情况是无法使用 for-each 循环的：</strong></p>
<ol>
<li><p>过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式地迭代器，以便可以调用它的 remove 方法。</p>
</li>
<li><p>转换——如果需要遍历列表或者数组，并取代它部分或者全部的元素值（增删、或对元素进行赋值），就需要列表迭代器或者数组索引，以便设定元素的值</p>
</li>
<li><p>平行迭代——如果需要并行地遍历多个集合，就需要显式地控制迭代器或者所因变量以便所有迭代器或者索引变量都可以得到同步前移</p>
</li>
</ol>
<h4 id="2）可变参数："><a href="#2）可变参数：" class="headerlink" title="2）可变参数："></a>2）可变参数：</h4><p>解析：什么意思呢？举个例子：在 JDK 1.5 之前，当我们要为一个传递多个类型相同的参数时，我们有两种方法解决，1.直接传递一个数组过去，2.有多少个参数就传递多少个参数。</p>
<p>例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printColor</span><span class="token punctuation">(</span>String red<span class="token punctuation">,</span>String green<span class="token punctuation">,</span>String yellow<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 或者</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printColor</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> colors<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre>
<p>这样编写方法参数虽然能够实现我们想要的效果，但是，这样是不是有点麻烦呢？再者，如果参数个数不确定，我们怎么办呢？Java JDK1.5为我们提供的可变参数就能够完美的解决这个问题</p>
<p>答：</p>
<p><strong>可变参数（…）：</strong>用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。</p>
<p><strong>和以前接收数组不一样的是：</strong></p>
<p>以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。</p>
<p>如果在参数列表中使用了可变参数，<strong>可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。</strong></p>
<p>如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。</p>
<p><strong>可变参数的特点：</strong></p>
<ul>
<li>① 只能出现在参数列表的最后；</li>
<li>② “…” 位于变量类型和变量名之间，前后有无空格都可以;</li>
<li>③ 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数。</li>
</ul>
<pre class=" language-java"><code class="language-java">Public <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span>  x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//也可以直接（int..args）就是说传不传都可以</span>
        Int sum <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token function">For</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>args<span class="token punctuation">.</span>lengrth<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                Sum<span class="token operator">+=</span>args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>实例：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableParameter</span> <span class="token punctuation">{</span>
      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="3）枚举"><a href="#3）枚举" class="headerlink" title="3）枚举"></a>3）枚举</h4><p>解析：关键字 enum</p>
<p>答：</p>
<p>问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；</p>
<p>解决办法：</p>
<p>1）在 setGrade 方法中做判断，不符合格式要求就抛出异常；<br>2）直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个 Grade 类，私有构造函数，对外提供 5 个静态的常量表示类的实例；<br>3）jdk5 中新定义了枚举类型，专门用于解决此类问题；<br>4）枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；</p>
<p><strong>为什么要有枚举？</strong></p>
<p>问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。</p>
<p>枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。枚举可以让编译器在编译时就可以控制源程序中填写的非法值，普通变量的方式在开发阶段无法实现这一目标。</p>
<p><strong>用普通类如何实现枚举功能，</strong>定义一个Weekday的类来模拟枚举功能。</p>
<p>1、私有的构造方法。<br>2、每个元素分别用一个公有的静态成员变量表示。</p>
<p>可以有若干公有方法或抽象方法。采用抽象方法定义nextDay就将大量的if.else语句转移成了一个个独立的类</p>
<p>示例：定义一个Weekday的类来模拟枚举功能。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeekDay</span> <span class="token punctuation">{</span>

       <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WeekDay SUN <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WeekDay MON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token keyword">public</span> WeekDay <span class="token function">nextDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> SUN<span class="token punctuation">)</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> MON <span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
                   <span class="token keyword">return</span> SUN <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

       <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> SUN<span class="token operator">?</span> <span class="token string">"SUN"</span><span class="token operator">:</span><span class="token string">"MON"</span> <span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>MON<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">nextDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//结果：SUN</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用枚举类实现</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>FRI<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：FRI</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：FRI</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>day<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：5</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>WeekDay<span class="token punctuation">.</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"SUN"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：SUN</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>WeekDay<span class="token punctuation">.</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：7</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">enum</span> WeekDay<span class="token punctuation">{</span>
             SUN<span class="token punctuation">,</span>MON <span class="token punctuation">,</span>TUE<span class="token punctuation">,</span>WED<span class="token punctuation">,</span> THI<span class="token punctuation">,</span>FRI <span class="token punctuation">,</span>SAT<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>总结：</strong> 枚举是一种特殊的类，其中的每个元素都是该类的一个实例对象，例如可以调用WeekDay.SUN.getClass().getName 和 WeekDay.class.getName()。</p>
<p><strong>注意：</strong> 最后一个枚举元素后面可以加分号，也可以不加分号。</p>
<p><strong>实现带有构造方法的枚举</strong></p>
<ul>
<li>枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。</li>
<li>枚举元素必须位于枚举体中的最开始部分，枚举元素列表的最后要有分号与其他成员分隔。把枚举中的成员方法或变量等放在枚举元素的前面，编译器会报告错误。</li>
<li>带构造方法的枚举：<br>构造方法必须定义成私有的<br>如果有多个构造方法，将根据枚举元素创建时所带的参数决定选择哪个构造方法创建对象。<br>枚举元素 MON 和 MON() 的效果一样，都是调用默认的构造方法。</li>
</ul>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            WeekDay day <span class="token operator">=</span> WeekDay<span class="token punctuation">.</span>FRI<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">public</span> <span class="token keyword">enum</span> WeekDay<span class="token punctuation">{</span>
             <span class="token function">SUN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">MON</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>TUE<span class="token punctuation">,</span> WED<span class="token punctuation">,</span>THI <span class="token punctuation">,</span>FRI<span class="token punctuation">,</span>SAT<span class="token punctuation">;</span>

             <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                  System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"first"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

             <span class="token keyword">private</span> <span class="token function">WeekDay</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                  System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"second"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
             <span class="token comment" spellcheck="true">//结果：</span>
             <span class="token comment" spellcheck="true">//second</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
             <span class="token comment" spellcheck="true">//first</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>实现带有抽象方法的枚举</strong></p>
<p>定义枚举TrafficLamp，实现抽象的nextTrafficLamp方法：每个元素分别是由枚举类的子类来生成的实例对象，这些子类采用类似内部类的方式进行定义。增加上表示时间的构造方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TrafficLamp lamp <span class="token operator">=</span> TrafficLamp<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lamp<span class="token punctuation">.</span><span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//结果：GREEN</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> TrafficLamp <span class="token punctuation">{</span>
        <span class="token function">RED</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> GREEN<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">GREEN</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> YELLOW<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">YELLOW</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> RED<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> time<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token function">TrafficLamp</span><span class="token punctuation">(</span><span class="token keyword">int</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">abstract</span> TrafficLamp <span class="token function">nextLamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong><br>1、枚举只有一个成员时，就可以作为一种单例的实现方式。<br>2、查看生成的class文件，可以看到内部类对应的class文件。</p>
<h4 id="4）自动拆装箱"><a href="#4）自动拆装箱" class="headerlink" title="4）自动拆装箱"></a>4）自动拆装箱</h4><p>答：在 Java 中数据类型分为两种：基本数据类型、引用数据类型(对象)</p>
<p>自动装箱：把基本类型变成包装器类型，本质是调用包装器类型的valueOf（）方法</p>
<p><strong>注意</strong>：基本数据类型的数组与包装器类型数组不能互换</p>
<p>在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：</p>
<hr>
<p>int → Integer<br>byte → Byte<br>short → Short<br>long → Long<br>char → Character<br>double → Double<br>float → Float<br>boolean → Boolean</p>
<hr>
<p>在 jdk 1.5 以前基本数据类型和包装类之间需要相互转换：</p>
<p>基本—引用 <code>Integer x = new Integer(x);</code><br>引用—基本 <code>int num = x.intValue();</code></p>
<p>1）<code>Integer x = 1; x = x + 1;</code> 经历了什么过程？装箱→拆箱→装箱<br>2）为了优化，虚拟机为包装类提供了缓冲池，<strong>Integer池</strong>的大小为 -128~127 一个字节的大小。<strong>String池</strong>：Java 为了优化字符串操作也提供了一个缓冲池；</p>
<p>→ 享元模式（Flyweight Pattern）：享元模式的特点是，复用我们内存中已经存在的对象，降低系统创建对象实例。</p>
<p><strong>自动装箱：</strong></p>
<pre class=" language-java"><code class="language-java">Integer num1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></code></pre>
<p><strong>自动拆箱：</strong></p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>基本数据类型的对象缓存：</p>
<pre class=" language-java"><code class="language-java">Integer num1 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
Integer num2 <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ture</span></code></pre>
<pre class=" language-java"><code class="language-java">Integer num3 <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>
Integer num4 <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3 <span class="token operator">==</span> num4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span></code></pre>
<pre class=" language-java"><code class="language-java">Integer num5 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Integer num6 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num5 <span class="token operator">==</span> num6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre>
<p><strong>示例：</strong></p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoBox</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//装箱</span>
            Integer iObj <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

             <span class="token comment" spellcheck="true">//拆箱</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iObj <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：15</span>

            Integer i1 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            Integer i2 <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：true</span>

            i1 <span class="token operator">=</span> <span class="token number">137</span><span class="token punctuation">;</span>
            i2 <span class="token operator">=</span> <span class="token number">137</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">//结果：false</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong><br>如果有很多很小的对象，并且他们有相同的东西，那就可以把他们作为一个对象。<br>如果还有很多不同的东西，那就可以作为外部的东西，作为参数传入。<br>这就是享元设计模式（flyweight）。</p>
<p>例如示例中的Integer对象，在-128~127范围内的Integer对象，用的频率比较高，就会作为同一个对象，因此结果为true。超出这个范围的就不是同一个对象，因此结果为false。</p>
<h4 id="5）泛型-Generics"><a href="#5）泛型-Generics" class="headerlink" title="5）泛型 Generics"></a>5）泛型 Generics</h4><p>答：引用泛型之后，允许指定集合里元素的类型，免去了强制类型转换，并且能在编译时刻进行类型检查的好处。Parameterized Type作为参数和返回值，Generic是vararg、annotation、enumeration、collection的基石。</p>
<p>泛型可以带来如下的好处总结如下：</p>
<ol>
<li>类型安全：抛弃List、Map，使用List、Map给它们添加元素或者使用Iterator遍历时，编译期就可以给你检查出类型错误</li>
<li>方法参数和返回值加上了Type: 抛弃List、Map，使用List、Map</li>
<li>不需要类型转换：List list = new ArrayList();</li>
<li>类型通配符“?”： 假设一个打印List中元素的方法printList,我们希望任何类型T的List都可以被打印</li>
</ol>
<h4 id="6）静态导入"><a href="#6）静态导入" class="headerlink" title="6）静态导入"></a>6）静态导入</h4><p>答：<strong>静态导入：</strong>导入了类中的所有静态成员，简化静态成员的书写。<br>import语句可以导入一个类或某个包中的所有类<br>import static语句导入一个类中的某个静态方法或所有静态方法</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>*<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//导入了Collections类中的所有静态成员</span></code></pre>
<p>静态导入可以导入静态方法，这样就不必写类名而可以直接调用静态方法了。</p>
<p><strong>例子：</strong></p>
<p>原来的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo12</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用静态导入的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>max <span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>abs <span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo12</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span> out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong></p>
<p>1、也可以通过import static java.lang.Math.*;导入Math类下所有的静态方法。<br>2、如果将javac设置为了Java5以下，那么静态导入等jdk1.5的特性都会报告错误。</p>
<h4 id="7）新的线程模型和并发库Thread-Framework-重要"><a href="#7）新的线程模型和并发库Thread-Framework-重要" class="headerlink" title="7）新的线程模型和并发库Thread Framework(重要)"></a>7）新的线程模型和并发库Thread Framework(重要)</h4><p>答： 最主要的就是引入了 java.util.concurrent 包，这个都是需要重点掌握的。</p>
<p>HashMap 的替代者 ConcurrentHashMap 和 ArrayList 的替代者 CopyOnWriteArrayList 在大并发量读取时采用 java.util.concurrent 包里的一些类会让大家满意 BlockingQueue、Callable、Executor、Semaphore </p>
<h4 id="8）内省（Introspector）"><a href="#8）内省（Introspector）" class="headerlink" title="8）内省（Introspector）"></a>8）内省（Introspector）</h4><p>答：是 Java 语言对 Bean 类属性、事件的一种缺省处理方法。例如类 A 中有属性 name , 那我们通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问name属性，这就是默认的规则。Java 中提供了一套 API 用来访问某个属性的 getter /setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中。</p>
<p>一般的做法是通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来 调用这些方法。</p>
<blockquote>
<p>扩展阅读：<a href="https://www.jianshu.com/p/205444f4b1eb" target="_blank" rel="noopener">java Introspector(内省) 的介绍</a></p>
</blockquote>
<h4 id="9）注解（Annotations）"><a href="#9）注解（Annotations）" class="headerlink" title="9）注解（Annotations）"></a>9）注解（Annotations）</h4><p>答：</p>
<p>注解(Annotation)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从Java5开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p>
<p>比如，下面这段代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> <span class="token string">"This is String."</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的代码中，我重写了toString()方法并使用了@Override注解。但是，即使我们不使用@Override注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将toString()写成了toStrring(){double r}，而且我也没有使用@Override注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。</p>
<p><strong>为什么要引入注解？</strong></p>
<p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p>
<p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p>
<p>另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。</p>
<p>目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p>
<blockquote>
<p>参考文章（更多注解戳这里）:<a href="http://blinkfox.com/javazhu-jie-de-li-jie-he-ying-yong/" target="_blank" rel="noopener">Java注解的理解和应用</a></p>
</blockquote>
<h4 id="10）新增-ProcessBuilder-类"><a href="#10）新增-ProcessBuilder-类" class="headerlink" title="10）新增 ProcessBuilder 类"></a>10）新增 ProcessBuilder 类</h4><p>答：</p>
<p><code>ProcessBuilder</code> 类是 Java5 在 <code>java.lang</code> 包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由 <code>Process</code> 类处来实现进程的控制管理。每个 <code>ProcessBuilder</code> 实例管理一个进程属性集。它的 <code>start()</code> 方法利用这些属性创建一个新的 <code>Process</code> 实例。<code>start()</code> 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p><code>ProcessBuilder</code> 是一个 <code>final</code> 类，有两个带参数的构造方法，你可以通过构造方法来直接创建 <code>ProcessBuilder</code> 的对象。而 <code>Process</code> 是一个抽象类，一般都通过 <code>Runtime.exec()</code> 和 <code>ProcessBuilder.start()</code> 来间接创建其实例。<code>ProcessBuilder</code> 为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而 <code>Process</code> 类的功能相对来说简单的多。<code>ProcessBuilder</code> 类不是同步的。如果多个线程同时访问一个 <code>ProcessBuilder</code>，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。</p>
<p>若要使用 <code>ProcessBuilder</code> 创建一个进程，只需要创建 <code>ProcessBuilder</code> 的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的 <code>start()</code> 即可。下面是一个执行打开 Windows 记事本的例子。注意它将要编辑的文件名指定为一个参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PBDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            ProcessBuilder proc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"notepad.exe"</span><span class="token punctuation">,</span> <span class="token string">"testfile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            proc<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Error executing notepad."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="11）新增Formatter格式化器-Formatter"><a href="#11）新增Formatter格式化器-Formatter" class="headerlink" title="11）新增Formatter格式化器(Formatter)"></a>11）新增Formatter格式化器(Formatter)</h4><p><code>Formatter</code> 类是Java5中新增的 <code>printf-style</code> 格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的 Java 类型，如 <code>byte</code>，<code>java.math.BigDecimal</code> 和 <code>java.util.Calendar</code> 都支持。 通过 <code>java.util.Formattable</code> 接口提供了针对任意用户类型的有限格式定制。</p>
<p>更详细的介绍见<a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html" target="_blank" rel="noopener">这里</a>。主要使用方法的代码示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileReader<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>MessageFormat<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>text<span class="token punctuation">.</span>SimpleDateFormat<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span>  
<span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 格式化测试使用的示例类.
 *
 * @author blinkfox on 2017-11-28.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FormatTester</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>FormatTester<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Formatter formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 可重新排序输出.</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%n%4$2s %3$2s %2$2s %1$2s %n"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> " d  c  b  a"</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>FRANCE<span class="token punctuation">,</span> <span class="token string">"e = %+10.4f"</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>E<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> "e =    +2,7183"</span>
        formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%nAmount gained or lost since last statement: $ %(,.2f"</span><span class="token punctuation">,</span> <span class="token number">6217.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// -> "Amount gained or lost since last statement: $ 6,217.58"</span>

        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"打印出格式化后的字符串:{}"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        formatter<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * printf打印.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String filename <span class="token operator">=</span> <span class="token string">"testfile"</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>FileReader fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            BufferedReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            String line<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Line %d: %s%n"</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to open file named '%s': %s"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * stringFormat使用.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 格式化日期.</span>
        Calendar c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GregorianCalendar</span><span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>MAY<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Duke's Birthday: %1$tm %1$te,%1$tY"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// -> s == "Duke's Birthday: May 23, 1995"</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化消息.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String msg <span class="token operator">=</span> <span class="token string">"欢迎光临，当前（{0}）等待的业务受理的顾客有{1}位，请排号办理业务！"</span><span class="token punctuation">;</span>
        MessageFormat mf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageFormat</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        String fmsg <span class="token operator">=</span> mf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>fmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 格式化日期.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"2010-1-10 17:39:21"</span><span class="token punctuation">;</span>
        SimpleDateFormat format <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMddHHmmss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"格式化后的日期:{}"</span><span class="token punctuation">,</span> format<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"日期格式化出错！"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">stringFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">messageFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="12）新增-Scanner-类（Scanner）"><a href="#12）新增-Scanner-类（Scanner）" class="headerlink" title="12）新增 Scanner 类（Scanner）"></a>12）新增 Scanner 类（Scanner）</h4><p><code>java.util.Scanner</code> 是 Java5 的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。</p>
<p><strong>(1).Scanner概述</strong></p>
<p>可以从字符串(<code>Readable</code>)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。</p>
<p><code>Scanner</code> 默认使用空格作为分割符来分隔文本，但允许你使用 <code>useDelimiter(Pattern pattern)</code> 或 <code>useDelimiter(String pattern)</code> 方法来指定新的分隔符。</p>
<p>主要API如下：</p>
<ul>
<li><code>delimiter()</code>: 返回此 <code>Scanner</code> 当前正在用于匹配分隔符的 <code>Pattern</code>。</li>
<li><code>hasNext()</code>: 判断扫描器中当前扫描位置后是否还存在下一段。</li>
<li><code>hasNextLine()</code>: 如果在此扫描器的输入中存在另一行，则返回true。</li>
<li><code>next()</code>: 查找并返回来自此扫描器的下一个完整标记。</li>
<li><code>nextLine()</code>: 此扫描器执行当前行，并返回跳过的输入信息。</li>
</ul>
<p><strong>(2).扫描控制台输入</strong></p>
<p>当通过 <code>new Scanner(System.in)</code> 创建了一个 <code>Scanner</code> 实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给 <code>Scanner</code>，作为扫描对象。如果要获取输入的内容，则只需要调用 <code>Scanner</code> 的 <code>nextLine()</code> 方法即可。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
* 扫描控制台输入.
*
* @author blinkfox 2017-11-28
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入字符串："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String line <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">">>>"</span> <span class="token operator">+</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p><strong>(3).其它示例</strong></p>
<p>该示例中会从 <code>myNumbers</code> 文件中读取长整型 <code>long</code> 的数据。</p>
<pre class=" language-java"><code class="language-java">Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"myNumbers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">while</span> <span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">hasNextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">long</span> aLong <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目：</p>
<pre class=" language-java"><code class="language-java">String input <span class="token operator">=</span> <span class="token string">"1 fish 2 fish red fish blue fish"</span><span class="token punctuation">;</span>  
Scanner s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">useDelimiter</span><span class="token punctuation">(</span><span class="token string">"\\s*fish\\s*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
s<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>将输出：</p>
<pre class=" language-java"><code class="language-java"><span class="token number">1</span>  
<span class="token number">2</span>  
red  
blue  </code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<h4 id="13）StringBuilder"><a href="#13）StringBuilder" class="headerlink" title="13）StringBuilder"></a>13）StringBuilder</h4><p><code>StringBuilder</code> 也是 Java5 中新增的类，主要用来代替 <code>+</code> 号和 <code>StringBuffer</code> 来更加高效的拼接字符串。<code>StringBuffer</code> 与 <code>StringBuilder</code> 都是继承于 <code>AbstractStringBuilder</code>，主要的区别就是 <code>StringBuffer</code> 的函数上都有 <code>synchronized</code> 关键字，保证线程安全。</p>
<p>关于 <code>StringBuilder</code> 的使用这里就不再详细介绍了，网上文章也有很多。总之，对于动态字符串的拼接推荐使用 <code>StringBuilder</code>。静态字符串的拼接直接使用 <code>+</code> 号或者字符串的 <code>concat(String str)</code> 方法，甚至也使用 <code>StringBuilder</code> 亦可。</p>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java5xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java5新特性及使用</a></p>
</blockquote>
<hr>
<h2 id="（二）Java-6-相关知识点"><a href="#（二）Java-6-相关知识点" class="headerlink" title="（二）Java 6 相关知识点"></a>（二）Java 6 相关知识点</h2><blockquote>
<p>关于 JDK 1.6 的新特性，了解一下就可以了…如果有兴趣深入研究的童鞋，右转这里：<a href="http://blinkfox.com/java6xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java6新特性及使用</a></p>
</blockquote>
<h4 id="1）Desktop-类和-SystemTray-类："><a href="#1）Desktop-类和-SystemTray-类：" class="headerlink" title="1）Desktop 类和 SystemTray 类："></a>1）Desktop 类和 SystemTray 类：</h4><p>答：</p>
<p>在JDK6中 ,AWT新增加了两个类:Desktop 和 SystemTray 。</p>
<p>前者可以用来打开系统默认浏览器浏览指定的 URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;</p>
<p>后者可以用来在系统托盘区创建一个托盘程序.</p>
<h4 id="2）使用-JAXB2-来实现对象与-XML-之间的映射"><a href="#2）使用-JAXB2-来实现对象与-XML-之间的映射" class="headerlink" title="2）使用 JAXB2 来实现对象与 XML 之间的映射"></a>2）使用 JAXB2 来实现对象与 XML 之间的映射</h4><p>答：</p>
<p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。</p>
<p>我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。</p>
<p>JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。</p>
<p>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。</p>
<h4 id="3）理解StAX"><a href="#3）理解StAX" class="headerlink" title="3）理解StAX"></a>3）理解StAX</h4><p>答：</p>
<p>StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。 </p>
<p>StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML). </p>
<p>由 于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX，所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本). JDK6里面JAXP的版本就是1.4. 。 </p>
<p>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件，然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符； </p>
<p>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。 </p>
<h4 id="4）使用Compiler-API"><a href="#4）使用Compiler-API" class="headerlink" title="4）使用Compiler API"></a>4）使用Compiler API</h4><p>答：</p>
<p>现在我们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 </p>
<p>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。 </p>
<h4 id="5）轻量级Http-Server-API"><a href="#5）轻量级Http-Server-API" class="headerlink" title="5）轻量级Http Server API"></a>5）轻量级Http Server API</h4><p>答：</p>
<p>JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法. </p>
<h4 id="6）插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#6）插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="6）插入式注解处理API(Pluggable Annotation Processing API)"></a>6）插入式注解处理API(Pluggable Annotation Processing API)</h4><p>答：</p>
<p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175) </p>
<p>实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境. </p>
<p>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列. </p>
<p>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。 </p>
<h4 id="7）用Console开发控制台程序"><a href="#7）用Console开发控制台程序" class="headerlink" title="7）用Console开发控制台程序"></a>7）用Console开发控制台程序</h4><p>JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实例. </p>
<h4 id="8）对脚本语言的支持"><a href="#8）对脚本语言的支持" class="headerlink" title="8）对脚本语言的支持"></a>8）对脚本语言的支持</h4><p>如: ruby, groovy, javascript.</p>
<h4 id="9）Common-annotations"><a href="#9）Common-annotations" class="headerlink" title="9）Common annotations"></a>9）Common annotations</h4><p><code>Common annotations</code> 原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。</p>
<h4 id="10）Java-DB-Derby"><a href="#10）Java-DB-Derby" class="headerlink" title="10）Java DB(Derby)"></a>10）Java DB(Derby)</h4><p>从 JDK6 开始，JDK 目录中新增了一个名为 <code>db</code> 的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目 <code>Derby</code>。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性 <code>JDBC 4.0</code> 规范(JSR 221)。</p>
<h4 id="11）JDBC-4-0"><a href="#11）JDBC-4-0" class="headerlink" title="11）JDBC 4.0"></a>11）JDBC 4.0</h4><p>在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。</p>
<ul>
<li>自动加载 <code>java.sql.Driver</code>，而不需要再调用 <code>class.forName</code>；</li>
<li>添加了 <code>java.sql.RowId</code> 数据类型用来可以访问 <code>sql rowid</code> ；</li>
<li>添加了 <code>National Character Set</code> 的支持；</li>
<li>增强了 <code>BLOB</code> 和 <code>CLOB</code> 的支持功能；</li>
<li><code>SQL/XML</code> 和 <code>XML</code> 支持；</li>
<li><code>Wrapper Pattern</code>；</li>
<li><code>SQLException</code> 增强；</li>
<li><code>Connection</code> 和 <code>Statement</code> 接口增强；</li>
<li><code>New Scalar Funtions</code>；</li>
<li><code>JDBC API changes</code>。</li>
</ul>
<hr>
<h2 id="（三）JAVA-7-相关知识点"><a href="#（三）JAVA-7-相关知识点" class="headerlink" title="（三）JAVA 7 相关知识点"></a>（三）JAVA 7 相关知识点</h2><blockquote>
<p>之前已经写过一篇详细介绍 Java 7 特性的文章了，这里就直接黏了：<a href="https://www.jianshu.com/p/6bc2e4c82f6b" target="_blank" rel="noopener">Java 7新特性</a></p>
</blockquote>
<h4 id="1）Diamond-Operator"><a href="#1）Diamond-Operator" class="headerlink" title="1）Diamond Operator"></a>1）Diamond Operator</h4><p>类型判断是一个人特殊的烦恼，入下面的代码：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> anagrams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>通过类型推断后变成：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> anagrams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>注：这个&lt;&gt;被叫做diamond(钻石)运算符，Java 7后这个运算符从引用的声明中推断类型。</strong></p>
<h4 id="2）在switch语句中使用字符串"><a href="#2）在switch语句中使用字符串" class="headerlink" title="2）在switch语句中使用字符串"></a>2）在switch语句中使用字符串</h4><p>switch语句可以使用原始类型或枚举类型。Java引入了另一种类型，我们可以在switch语句中使用：字符串类型。</p>
<p>说我们有一个根据其地位来处理贸易的要求。直到现在，我们使用if-其他语句来完成这个任务。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token function">voidprocessTrade</span><span class="token punctuation">(</span>Trade t<span class="token punctuation">)</span><span class="token punctuation">{</span>

            String status <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>NEW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">newTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>EXECUTE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">executeTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>PENDING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                  <span class="token function">pendingTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>这种处理字符串的方法是粗糙的。在Java中，我们可以使用增强的switch语句来改进程序，该语句以String类型作为参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidprocessTrade</span><span class="token punctuation">(</span>Trade t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String status <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        caseNEW<span class="token operator">:</span>
            <span class="token function">newTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        caseEXECUTE<span class="token operator">:</span>
            <span class="token function">executeTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        casePENDING<span class="token operator">:</span>
            <span class="token function">pendingTrade</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在上面的程序中，状态字段总是通过使用 <strong>String.equals()</strong> 与案例标签来进行比较。</p>
<h4 id="3）自动资源管理"><a href="#3）自动资源管理" class="headerlink" title="3）自动资源管理"></a>3）自动资源管理</h4><p>Java中有一些资源需要手动关闭，例如<strong>Connections，Files，Input/OutStreams</strong>等。通常我们使用 <strong>try-finally</strong> 来关闭资源：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidoldTry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        fos<span class="token operator">=</span> <span class="token function">newFileOutputStream</span><span class="token punctuation">(</span><span class="token string">"movies.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        dos<span class="token operator">=</span> <span class="token function">newDataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span>

        dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"Java 7 Block Buster"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>

        <span class="token keyword">try</span><span class="token punctuation">{</span>

            fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            dos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token comment" spellcheck="true">// log the exception</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>然而，在Java 7中引入了另一个很酷的特性，可以自动管理资源。它的操作也很简单，我们所要做的就是在 <strong>try</strong> 块中申明资源如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>resources_to_be_cleant<span class="token punctuation">)</span><span class="token punctuation">{</span>

   <span class="token comment" spellcheck="true">// your code</span>

<span class="token punctuation">}</span></code></pre>
<p>以上方法与旧的 <strong>try-finally</strong> 能最终写成下面的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewTry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">(</span>FileOutputStream fos <span class="token operator">=</span> <span class="token function">newFileOutputStream</span><span class="token punctuation">(</span><span class="token string">"movies.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        DataOutputStream dos <span class="token operator">=</span> <span class="token function">newDataOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"Java 7 Block Buster"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log the exception</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>上面的代码也代表了这个特性的另一个方面：处理多个资源。<strong>FileOutputStream</strong> 和 <strong>DataOutputStream</strong> 在try语句中一个接一个地含在语句中，每一个都用分号(;)分隔符分隔开。我们不必手动取消或关闭流，因为当空间存在try块时，它们将自动关闭。</p>
<p>在后台，应该自动关闭的资源必须试验 <strong>java.lang.AutoCloseable</strong> 接口。</p>
<p>任何实现 <strong>AutoCloseable</strong> 接口的资源都可以作为自动资源管理的候选。<strong>AutoCloseable</strong> 是 <strong>java.io.Closeable</strong> 接口的父类，JVM会在程序退出<strong>try</strong>块后调用一个方法 <strong>close()</strong>。</p>
<h4 id="4）带下划线的数字文本"><a href="#4）带下划线的数字文本" class="headerlink" title="4）带下划线的数字文本"></a>4）带下划线的数字文本</h4><p>数字文字绝对是对眼睛的一种考验。我相信，如果你给了一个数字，比如说，十个零，你就会像我一样数零。如果不计算从右到左的位置，识别一个文字的话，就很容易出错，而且很麻烦。Not anymore。Java在识别位置时引入了下划线。例如，您可以声明1000，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> thousand <span class="token operator">=</span>  1_000<span class="token punctuation">;</span></code></pre>
<p>或1000000(一百万)如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> million  <span class="token operator">=</span>  1_000_000</code></pre>
<p><strong>请注意，这个版本中也引入了二进制文字-例如“0b1”-因此开发人员不必再将它们转换为十六进制。</strong></p>
<h4 id="5）改进的异常处理"><a href="#5）改进的异常处理" class="headerlink" title="5）改进的异常处理"></a>5）改进的异常处理</h4><p>在异常处理区域有几处改进。Java引入了多个catch功能，以使用单个抓到块捕获多个异常类型。</p>
<p>假设您有一个方法，它抛出三个异常。在当前状态下，您将分别处理它们，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidoldMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionOne</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionTwo e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionTwo</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionThree</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>在一个catch块中逐个捕获一个连续的异常，看起来很混乱。我还看到了捕获十几个异常的代码。这是非常低效和容易出错的。Java为解决这只丑小鸭带来了新的语言变化。请参阅下面的方法oldMultiCatch方法的改进版本：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne <span class="token operator">|</span> ExceptionTwo <span class="token operator">|</span> ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with all Exceptions</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>多个异常通过使用 <strong>“|”</strong> 操作符在一个catch块中捕获。这样，您不必编写数十个异常捕获。但是，如果您有许多属于不同类型的异常，那么您也可以使用“多个catch块”块。下面的代码片段说明了这一点：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidnewMultiMultiCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>

        <span class="token function">methodThatThrowsThreeExceptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionOne e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionOne</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionTwo <span class="token operator">|</span> ExceptionThree e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// log and deal with ExceptionTwo and ExceptionThree</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>在上面的例子中，在和ExceptionThree属于不同的层次结构，因此您希望以不同的方式处理它们，但使用一个抓到块。</p>
<h4 id="6）New-file-system-API-NIO-2-0"><a href="#6）New-file-system-API-NIO-2-0" class="headerlink" title="6）New file system API(NIO 2.0)"></a>6）New file system API(NIO 2.0)</h4><p>那些使用Java的人可能还记得框架引起的头痛。在操作系统或多文件系统之间无缝地工作从来都不是一件容易的事情.。有些方法，例如删除或重命名，在大多数情况下都是出乎意料的。使用符号链接是另一个问题。实质上API需要大修。</p>
<p>为了解决上述问题，Java引入了一个新的API，并在许多情况下引入了新的api。</p>
<p>在NIO2.0提出了许多增强功能。在处理多个文件系统时，它还引入了新的类来简化开发人员的生活。</p>
<p><strong>Working With Path（使用路径）：</strong></p>
<p>新的 <strong>java.nio.file</strong> 由包和接口组成例如：<strong>Path,Paths,FileSystem,FileSystems</strong>等等。</p>
<p>路径只是对文件路径的简单引用。它与java.io.File等价(并具有更多的特性)。下面的代码段显示了如何获取对“临时”文件夹的路径引用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">voidpathInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    Path path<span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"c:\Temp\temp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Number of Nodes:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getNameCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Name:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Root:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"File Parent:"</span><span class="token operator">+</span> path<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<p>最终控制台的输出将是:</p>
<pre class=" language-java"><code class="language-java">Number of Nodes<span class="token operator">:</span><span class="token number">2</span>

File Name<span class="token operator">:</span>temp<span class="token punctuation">.</span>txt

File Root<span class="token operator">:</span>c<span class="token operator">:</span>

File Parent<span class="token operator">:</span>c<span class="token operator">:</span>Temp</code></pre>
<p>删除文件或目录就像在文件中调用delete方法(注意复数)一样简单。在类公开两个删除方法，一个抛出NoSuchFileException，另一个不抛。</p>
<p>下面的delete方法调用抛出NoSuchFileException，因此您必须处理它：</p>
<pre class=" language-java"><code class="language-java">Files<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Where as Files.deleteIfExists(path) does not throw exception (as expected) if the file/directory does not exist.</p>
<blockquote>
<p>使用 <strong>Files.deteleIfExists(path)</strong> 则不会抛出异常。</p>
</blockquote>
<p>您可以使用其他实用程序方法，例如Files.copy(.)和Files.move(.)来有效地对文件系统执行操作。类似地，使用 <strong>createSymbolicLink(..)</strong> 方法使用代码创建符号链接。</p>
<p><strong>文件更改通知：</strong></p>
<p>JDK 7中最好的改善算是File change notifications（文件更改通知）了。这是一个长期等待的特性，它最终被刻在NIO 2.0中。<strong>WatchService</strong> API 允许您在对主题(目录或文件)进行更改时接收通知事件。</p>
<blockquote>
<p>具体的创建步骤就不给了，总之它的功能就跟它的名字一般，当文件发生更改的时候，能及时作出反馈。</p>
</blockquote>
<h4 id="7）Fork-and-Join（Fork-Join框架）"><a href="#7）Fork-and-Join（Fork-Join框架）" class="headerlink" title="7）Fork and Join（Fork/Join框架）"></a>7）Fork and Join（Fork/Join框架）</h4><p>在一个 Java 程序中有效地使用并行内核一直是一个挑战。很少有国内开发的框架将工作分配到多个核心，然后加入它们来返回结果集。Java已经将这个特性作为Fork/Join框架结合了起来。</p>
<p>基本上，在把手头的任务变成了小任务，直到小任务简单到可以不进一步分手的情况下解决。这就像一个分而治之的算法.。在这个框架中需要注意的一个重要概念是，理想情况下，没有工作线程是空闲的。他们实现了一个 work-stealing 算法，在空闲的工人“偷”工作从那些工人谁是忙。</p>
<p>支持Fork-Join机制的核心类是 ForkJoinPool和ForkJoinTask。</p>
<p><strong>什么是Fork/Join框架：</strong></p>
<p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>Fork/Join的运行流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-47e0d9433019fb97.png" alt=""></p>
<p><strong>工作窃取算法：</strong></p>
<p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%AF%87/7896890-53555e4f93e990d9.png" alt=""></p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<p><strong>Fork/Join框架使用示例：</strong></p>
<p>让我们通过一个简单的需求来使用下 <code>Fork／Join</code> 框架，需求是：计算<code>1 + 2 + 3 + 4</code>的结果。</p>
<p>使用 <code>Fork/Join</code> 框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是<code>2</code>，由于是<code>4</code>个数字相加，所以 <code>Fork/Join</code> 框架会把这个任务 <code>fork</code> 成两个子任务，子任务一负责计算<code>1 + 2</code>，子任务二负责计算<code>3 + 4</code>，然后再 <code>join</code> 两个子任务的结果。</p>
<p>因为是有结果的任务，所以必须继承 <code>RecursiveTask</code> ，实现代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * CountTask.
 *
 * @author blinkfox on 2018-01-03.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/** 阈值. */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** 计算的开始值. */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/** 计算的结束值. */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 构造方法.
     *
     * @param start 计算的开始值
     * @param end 计算的结束值
     */</span>
    <span class="token keyword">public</span> <span class="token function">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 执行计算的方法.
     *
     * @return int型结果
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果任务足够小就计算任务.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果任务大于阈值，就分裂成两个子任务来计算.</span>
            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            CountTask leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
            CountTask rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 等待子任务执行完，并得到结果，再合并执行结果.</span>
            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * main方法.
     *
     * @param args 数组参数
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>
        ForkJoinPool fkPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CountTask task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> fkPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result:"</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>参考文章：<a href="http://blinkfox.com/java7xin-te-xing-ji-shi-yong/" target="_blank" rel="noopener">Java7新特性及使用</a><br>这里是Java 7的新特性一览表：<a href="http://www.oschina.net/news/20119/new-features-of-java-7" target="_blank" rel="noopener">http://www.oschina.net/news/20119/new-features-of-java-7</a></p>
</blockquote>
<hr>
<h2 id="（四）Java-8-相关知识点"><a href="#（四）Java-8-相关知识点" class="headerlink" title="（四）Java 8 相关知识点"></a>（四）Java 8 相关知识点</h2><blockquote>
<p>关于 Java 8 中新知识点，面试官会让你说说 Java 8 你了解多少，下面分享一下我收集的 Java 8 新增的知识点的内容，前排申明引用自：<a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用</a></p>
</blockquote>
<h4 id="1）接口默认方法和静态方法"><a href="#1）接口默认方法和静态方法" class="headerlink" title="1）接口默认方法和静态方法"></a>1）接口默认方法和静态方法</h4><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p>
<p><strong>1.接口默认方法</strong></p>
<p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>
    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>
    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>  
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><code>Defaulable</code> 接口用关键字 <code>default</code> 声明了一个默认方法 <code>notRequired()</code>，<code>Defaulable</code> 接口的实现者之一 <code>DefaultableImpl</code> 实现了这个接口，并且让默认方法保持原样。<code>Defaulable</code> 接口的另一个实现者 <code>OverridableImpl</code> 用自己的方法覆盖了默认方法。</p>
<p><strong>1.1 多重继承的冲突说明：</strong></p>
<p>由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：</p>
<ul>
<li>一个声明在类里面的方法优先于任何默认方法</li>
<li>优先选取最具体的实现</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span> B <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 Hello B</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p><strong>1.2 优缺点：</strong></p>
<ul>
<li><strong>优点</strong>: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</li>
<li><strong>缺点</strong>: 使得<strong>接口作为协议，类作为具体实现</strong>的界限开始变得有点模糊。</li>
</ul>
<p><strong>1.3 接口默认方法不能重载Object类的任何方法：</strong></p>
<p><strong>接口不能提供对Object类的任何方法的默认实现。</strong>简单地讲，每一个java类都是Object的子类，也都继承了它类中的 <code>equals()/hashCode()/toString()</code> 方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。</p>
<p>在 JVM 中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到 <code>java.util.Collection</code> 接口中去：<code>stream()</code>，<code>parallelStream()</code>，<code>forEach()</code>，<code>removeIf()</code> 等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。</p>
<p><strong>2.接口静态方法</strong></p>
<p>Java 8 带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用 <code>static</code> 关键字，例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StaticInterface</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是Java8接口中的静态方法!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>下面的一小段代码是上面静态方法的使用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StaticInterface<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 这是Java8接口中的静态方法!</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>Java 支持一个实现类可以实现多个接口，如果多个接口中存在同样的 <code>static</code> 方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。</p>
<h4 id="2）Lambda-表达式"><a href="#2）Lambda-表达式" class="headerlink" title="2）Lambda 表达式"></a>2）Lambda 表达式</h4><p><code>Lambda</code> 表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong><a href="https://www.jianshu.com/p/eb7721f32a5d" target="_blank" rel="noopener">行为参数化</a></strong>，函数作为参数传递进方法中）。</p>
<p>一个 <code>Lambda</code> 可以由用逗号分隔的参数列表、<code>–&gt;</code> 符号与函数体三部分表示。</p>
<p>首先看看在老版本的Java中是如何排列字符串的：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"peter"</span><span class="token punctuation">,</span> <span class="token string">"anna"</span><span class="token punctuation">,</span> <span class="token string">"mike"</span><span class="token punctuation">,</span> <span class="token string">"xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>只需要给静态方法 <code>Collections.sort</code> 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>看到了吧，代码变得更短且更具有可读性，但是实际上还可以写得更短：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<pre class=" language-java"><code class="language-java">Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p>
<blockquote>
<p>更多 Lambda 表达式的示例在这里：<a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a></p>
</blockquote>
<h4 id="3）函数式接口"><a href="#3）函数式接口" class="headerlink" title="3）函数式接口"></a>3）函数式接口</h4><p><code>Lambda</code> 表达式是如何在 Java 的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而<strong>函数式接口</strong>是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为<strong>默认方法</strong>不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 <code>@FunctionalInterface</code> 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<p>示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>F<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>  
    T <span class="token function">convert</span><span class="token punctuation">(</span>F from<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Converter<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> converter <span class="token operator">=</span> <span class="token punctuation">(</span>from<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>  
Integer converted <span class="token operator">=</span> converter<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>converted<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123  </span></code></pre>
<blockquote>
<p><strong>注意：</strong> 如果 <code>@FunctionalInterface</code> 如果没有指定，上面的代码也是对的。<br><strong>更多参考：</strong> <a href="https://www.jianshu.com/p/c204e3721733" target="_blank" rel="noopener">Java 8——Lambda表达式</a>、<a href="http://blinkfox.com/java8xin-te-xing-ji-shi-yong-2/" target="_blank" rel="noopener">Java8新特性及使用</a></p>
</blockquote>
<h4 id="4）方法引用"><a href="#4）方法引用" class="headerlink" title="4）方法引用"></a>4）方法引用</h4><p><strong>1.概述：</strong></p>
<p>在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：</p>
<pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。</p>
<pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strArray<span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>这种特性就叫做<strong>方法引用</strong>(<code>Method Reference</code>)。</p>
<p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p>
<blockquote>
<p><strong>注意</strong>: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号::。</p>
</blockquote>
<p><strong>2.分类：</strong></p>
<p>方法引用的标准形式是：<code>类名::方法名</code>。（注意：只需要写方法名，不需要写括号）</p>
<p>有以下四种形式的方法引用：</p>
<ul>
<li>引用静态方法: ContainingClass::staticMethodName</li>
<li>引用某个对象的实例方法: containingObject::instanceMethodName</li>
<li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li>
<li>引用构造方法: ClassName::new</li>
</ul>
<p><strong>3.示例：</strong></p>
<p>使用示例如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    String name<span class="token punctuation">;</span>

    LocalDate birthday<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> LocalDate birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> LocalDate <span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> birthday<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodReferenceTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Person<span class="token punctuation">[</span><span class="token punctuation">]</span> pArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"003"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"001"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"002"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"004"</span><span class="token punctuation">,</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 使用匿名类</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//使用lambda表达式</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> <span class="token punctuation">(</span>Person a<span class="token punctuation">,</span> Person b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getBirthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//使用方法引用，引用的是类的静态方法</span>
        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>pArr<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>compareByAge<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="5）Steam"><a href="#5）Steam" class="headerlink" title="5）Steam"></a>5）Steam</h4><blockquote>
<p>Java8添加的 <code>Stream API(java.util.stream)</code> 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为 <code>Stream API</code> 可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。使用 Steam 写出来的代码真的能让人兴奋，这里链出之前的一篇文章：<a href="https://www.jianshu.com/p/6fab3047c7e7" target="_blank" rel="noopener">Java 8——函数式数据处理（流）</a></p>
</blockquote>
<p>流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括<code>filter</code>、<code>map</code>、<code>flatMap</code>、<code>peel</code>、<code>distinct</code>、<code>sorted</code>、<code>limit</code> 和 <code>substream</code>。终止操作包括 <code>forEach</code>、<code>toArray</code>、<code>reduce</code>、<code>collect</code>、<code>min</code>、<code>max</code>、<code>count</code>、<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findFirst</code> 和 <code>findAny</code>。 <code>java.util.stream.Collectors</code> 是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。</p>
<p><strong>1.一些重要方法说明：</strong></p>
<ul>
<li><code>stream</code>: 返回数据流，集合作为其源</li>
<li><code>parallelStream</code>: 返回并行数据流， 集合作为其源</li>
<li><code>filter</code>: 方法用于过滤出满足条件的元素</li>
<li><code>map</code>: 方法用于映射每个元素对应的结果</li>
<li><code>forEach</code>: 方法遍历该流中的每个元素</li>
<li><code>limit</code>: 方法用于减少流的大小</li>
<li><code>sorted</code>: 方法用来对流中的元素进行排序</li>
<li><code>anyMatch</code>: 是否存在任意一个元素满足条件（返回布尔值）</li>
<li><code>allMatch</code>: 是否所有元素都满足条件（返回布尔值）</li>
<li><code>noneMatch</code>: 是否所有元素都不满足条件（返回布尔值）</li>
<li><code>collect</code>: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li>
</ul>
<p><strong>2.一些使用示例：</strong></p>
<p><strong>2.1 Filter 过滤：</strong></p>
<pre><code>stringCollection  
    .stream()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);</code></pre><p><strong>2.2 Sort 排序：</strong></p>
<pre><code>stringCollection  
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);</code></pre><p><strong>2.3 Map 映射：</strong></p>
<pre><code>stringCollection  
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);</code></pre><p><strong>2.4 Match 匹配：</strong></p>
<pre><code>boolean anyStartsWithA = stringCollection  
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(anyStartsWithA);      // true

boolean allStartsWithA = stringCollection  
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ = stringCollection  
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));
System.out.println(noneStartsWithZ);      // true  </code></pre><p><strong>2.5 Count 计数：</strong></p>
<pre><code>long startsWithB = stringCollection  
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();
System.out.println(startsWithB);    // 3  </code></pre><p><strong>2.6  Reduce 规约：</strong></p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> reduced <span class="token operator">=</span> stringCollection  
        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
reduced<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre>
<h4 id="6）Optional"><a href="#6）Optional" class="headerlink" title="6）Optional"></a>6）Optional</h4><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的<code>Guava</code>项目引入了<code>Optional</code>类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，<code>Optional</code>类已经成为Java 8类库的一部分。</p>
<p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>如果<code>Optional</code>类的实例为非空值的话，<code>isPresent()</code>返回<code>true</code>，否从返回<code>false</code>。为了防止Optional为空值，<code>orElseGet()</code>方法通过回调函数来产生一个默认值。<code>map()</code>函数对当前<code>Optional</code>的值进行转化，然后返回一个新的<code>Optional</code>实例。<code>orElse()</code>方法和<code>orElseGet()</code>方法类似，但是<code>orElse</code>接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p>
<pre class=" language-java"><code class="language-java">Full Name is set<span class="token operator">?</span> <span class="token boolean">false</span>  
Full Name<span class="token operator">:</span> <span class="token punctuation">[</span>none<span class="token punctuation">]</span>  
Hey Stranger<span class="token operator">!</span>  </code></pre>
<p>让我们来看看另一个例子：</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p>下面是程序的输出：</p>
<pre class=" language-java"><code class="language-java">First Name is set<span class="token operator">?</span> <span class="token boolean">true</span>  
First Name<span class="token operator">:</span> Tom  
Hey Tom<span class="token operator">!</span> </code></pre>
<h4 id="7）Date-Time-API"><a href="#7）Date-Time-API" class="headerlink" title="7）Date/Time API"></a>7）Date/Time API</h4><p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p><strong>1.Clock 时钟：</strong></p>
<p><code>Clock</code>类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代<code>System.currentTimeMillis()</code>来获取当前的微秒数。某一个特定的时间点也可以使用<code>Instant</code>类来表示，<code>Instant</code>类也可以用来创建老的<code>java.util.Date</code>对象。代码如下:</p>
<pre class=" language-java"><code class="language-java">Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">long</span> millis <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Instant instant <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// legacy java.util.Date  </span></code></pre>
<p><strong>2.Timezones 时区：</strong></p>
<p>在新API中时区使用<code>ZoneId</code>来表示。时区可以很方便的使用静态方法<code>of</code>来获取到。时区定义了到UTS时间的时间差，在<code>Instant</code>时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">getAvailableZoneIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">// prints all available timezone ids</span>
ZoneId zone1 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
ZoneId zone2 <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Brazil/East"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone1<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone2<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=+01:00]</span>
<span class="token comment" spellcheck="true">// ZoneRules[currentStandardOffset=-03:00]</span></code></pre>
<p><strong>3.LocalTime 本地时间：</strong></p>
<p><code>LocalTime</code>定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalTime now1 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone1<span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalTime now2 <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>zone2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now1<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>now2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false  </span>
<span class="token keyword">long</span> hoursBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">long</span> minutesBetween <span class="token operator">=</span> ChronoUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>now1<span class="token punctuation">,</span> now2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hoursBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// -3  </span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minutesBetween<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// -239  </span></code></pre>
<p><code>LocalTime</code>提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalTime late <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>late<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 23:59:59  </span>
DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter  
        <span class="token punctuation">.</span><span class="token function">ofLocalizedTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalTime leetTime <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"13:37"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leetTime<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 13:37  </span></code></pre>
<p><strong>4.LocalDate 本地日期：</strong></p>
<p>LocalDate表示了一个确切的日期，比如2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate tomorrow <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate yesterday <span class="token operator">=</span> tomorrow<span class="token punctuation">.</span><span class="token function">minusDays</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
LocalDate independenceDay <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JULY<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
DayOfWeek dayOfWeek <span class="token operator">=</span> independenceDay<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// FRIDAY  </span></code></pre>
<p>从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:</p>
<pre class=" language-java"><code class="language-java">DateTimeFormatter germanFormatter <span class="token operator">=</span> DateTimeFormatter  
        <span class="token punctuation">.</span><span class="token function">ofLocalizedDate</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">withLocale</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>GERMAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalDate xmas <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"24.12.2014"</span><span class="token punctuation">,</span> germanFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>xmas<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2014-12-24  </span></code></pre>
<p><strong>5.LocalDateTime 本地日期时间：</strong></p>
<p><code>LocalDateTime</code>同时表示了时间和日期，相当于前两节内容合并到一个对象上了。<code>LocalDateTime</code>和<code>LocalTime</code>还有<code>LocalDate</code>一样，都是不可变的。<code>LocalDateTime</code>提供了一些能访问具体字段的方法。代码如下:</p>
<pre class=" language-java"><code class="language-java">LocalDateTime sylvester <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
DayOfWeek dayOfWeek <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// WEDNESDAY  </span>
Month month <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// DECEMBER  </span>
<span class="token keyword">long</span> minuteOfDay <span class="token operator">=</span> sylvester<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>ChronoField<span class="token punctuation">.</span>MINUTE_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minuteOfDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1439  </span></code></pre>
<p>只要附加上时区信息，就可以将其转换为一个时间点<code>Instant</code>对象，<code>Instant</code>时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。代码如下:</p>
<pre class=" language-java"><code class="language-java">Instant instant <span class="token operator">=</span> sylvester  
        <span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Date legacyDate <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>instant<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>legacyDate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Wed Dec 31 23:59:59 CET 2014  </span></code></pre>
<p>格式化<code>LocalDateTime</code>和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:</p>
<pre class=" language-java"><code class="language-java">DateTimeFormatter formatter <span class="token operator">=</span>  
    DateTimeFormatter
        <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd, yyyy - HH:mm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LocalDateTime parsed <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"Nov 03, 2014 - 07:13"</span><span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>  
String string <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parsed<span class="token punctuation">)</span><span class="token punctuation">;</span>  
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Nov 03, 2014 - 07:13  </span></code></pre>
<p>和<code>java.text.NumberFormat</code>不一样的是新版的<code>DateTimeFormatter</code>是不可变的，所以它是线程安全的。</p>
<p>关于Java8中日期API更多的使用示例可以参考<a href="http://blinkfox.com/java-8zhong-guan-yu-ri-qi-he-shi-jian-apide-20ge-shi-yong-shi-li/" target="_blank" rel="noopener">Java 8中关于日期和时间API的20个使用示例</a>。</p>
<h4 id="8）重复注解"><a href="#8）重复注解" class="headerlink" title="8）重复注解"></a>8）重复注解</h4><p>自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p>
<p>重复注解机制本身必须用<code>@Repeatable</code>注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>
        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>
        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>Filter filter<span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>正如我们看到的，这里有个使用<code>@Repeatable(Filters.class)</code>注解的注解类<code>Filter</code>，<code>Filters</code>仅仅是<code>Filter</code>注解的数组，但Java编译器并不想让程序员意识到<code>Filters</code>的存在。这样，接口<code>Filterable</code>就拥有了两次<code>Filter</code>（并没有提到<code>Filter</code>）注解。</p>
<p>同时，反射相关的API提供了新的函数<code>getAnnotationsByType()</code>来返回重复注解的类型（请注意<code>Filterable.class.getAnnotation(Filters.class)</code>经编译器处理后将会返回Filters的实例）。</p>
<h4 id="9）扩展注解的支持"><a href="#9）扩展注解的支持" class="headerlink" title="9）扩展注解的支持"></a>9）扩展注解的支持</h4><p>Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="10）Base-64"><a href="#10）Base-64" class="headerlink" title="10）Base 64"></a>10）Base 64</h4><p>在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span>  
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>程序在控制台上输出了编码后的字符与解码后的字符：</p>
<pre class=" language-java"><code class="language-java">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ<span class="token operator">==</span>  
Base64 <span class="token keyword">finally</span> in Java <span class="token number">8</span><span class="token operator">!</span>  </code></pre>
<p>Base64类同时还提供了对URL、MIME友好的编码器与解码器（<code>Base64.getUrlEncoder() / Base64.getUrlDecoder()</code>, <code>Base64.getMimeEncoder() / Base64.getMimeDecoder()</code>）。</p>
<h4 id="11）JavaFX"><a href="#11）JavaFX" class="headerlink" title="11）JavaFX"></a>11）JavaFX</h4><p><code>JavaFX</code>是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考<a href="http://www.javafxchina.net/blog/docs/" target="_blank" rel="noopener">JavaFX中文文档</a>。</p>
<h4 id="12）HashMap的底层实现有变化"><a href="#12）HashMap的底层实现有变化" class="headerlink" title="12）HashMap的底层实现有变化"></a>12）HashMap的底层实现有变化</h4><p>Java8中，HashMap内部实现又引入了红黑树（数组+链表+红黑树），使得HashMap的总体性能相较于Java7有比较明显的提升。</p>
<h4 id="13）JVM内存管理方面，由元空间代替了永久代。"><a href="#13）JVM内存管理方面，由元空间代替了永久代。" class="headerlink" title="13）JVM内存管理方面，由元空间代替了永久代。"></a>13）JVM内存管理方面，由元空间代替了永久代。</h4><p>区别：</p>
<ol>
<li>元空间并不在虚拟机中，而是使用本地内存</li>
<li>默认情况下，元空间的大小仅受本地内存限制</li>
<li>也可以通过-XX：MetaspaceSize指定元空间大小</li>
</ol>
<hr>
<h2 id="（五）Java-9-相关知识点"><a href="#（五）Java-9-相关知识点" class="headerlink" title="（五）Java 9 相关知识点"></a>（五）Java 9 相关知识点</h2><blockquote>
<p>引用自文章：<a href="http://www.importnew.com/24528.html" target="_blank" rel="noopener">Java 9 中的 9 个新特性</a>、<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html" target="_blank" rel="noopener">Java 9 新特性概述——IBM</a>、<a href="https://yifeng.studio/2017/03/12/translation-java-9-features-with-examples/" target="_blank" rel="noopener">【译】使用示例带你提前了解 Java 9 中的新特性</a></p>
</blockquote>
<h4 id="1）Java-9-PEPK（JShell）"><a href="#1）Java-9-PEPK（JShell）" class="headerlink" title="1）Java 9 PEPK（JShell）"></a>1）Java 9 PEPK（JShell）</h4><p>Oracle 公司（Java Library 开发者）新引进一个代表 Java Shell 的称之为 “jshell” 或者 REPL（Read Evaluate Print Loop）的新工具。该工具可以被用来执行和测试任何 Java 中的结构，如 class，interface，enum，object，statements 等。使用非常简单。</p>
<p>JDK 9 EA（Early Access）下载地址：<a href="https://jdk9.java.net/download/" target="_blank" rel="noopener">https://jdk9.java.net/download/</a></p>
<pre><code>G:\&gt;jshell
|  Welcome to JShell -- Version 9-ea
|  For an introduction type: /help intro
jshell&gt; int a = 10
a ==&gt; 10
jshell&gt; System.out.println(&quot;a value = &quot; + a )
a value = 10</code></pre><h4 id="2）集合工厂方法"><a href="#2）集合工厂方法" class="headerlink" title="2）集合工厂方法"></a>2）集合工厂方法</h4><p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p>
<pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ints <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">,</span> <span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p>
<h4 id="3）接口中的私有方法"><a href="#3）接口中的私有方法" class="headerlink" title="3）接口中的私有方法"></a>3）接口中的私有方法</h4><p>在 Java 8 中，我们可以在接口中使用默认或者静态方法提供一些实现方式，但是不能创建私有方法。</p>
<p>为了避免冗余代码和提高重用性，Oracle 公司准备在 Java SE 9 接口中引入私有方法。也就是说从 Java SE 9 开始，我们也能够在接口类中使用 ‘private’ 关键字写私有化方法和私有化静态方法。</p>
<p>接口中的私有方法与 class 类中的私有方法在写法上并无差异，如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Card</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> Long <span class="token function">createCardID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Method implementation goes here.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">displayCardDetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Method implementation goes here.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="4）Java-平台级模块系统"><a href="#4）Java-平台级模块系统" class="headerlink" title="4）Java 平台级模块系统"></a>4）Java 平台级模块系统</h4><blockquote>
<p>这里只给出解决的问题，仅限了解….</p>
</blockquote>
<p>Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。</p>
<h4 id="5）进程-API"><a href="#5）进程-API" class="headerlink" title="5）进程 API"></a>5）进程 API</h4><p>Java SE 9 迎来一些 Process API 的改进，通过添加一些新的类和方法来优化系统级进程的管控。</p>
<p>Process API 中的两个新接口：</p>
<ul>
<li>java.lang.ProcessHandle</li>
<li>java.lang.ProcessHandle.Info</li>
</ul>
<p><strong>Process API 示例</strong></p>
<pre class=" language-java"><code class="language-java">ProcessHandle currentProcess <span class="token operator">=</span> ProcessHandle<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Process Id: = "</span> <span class="token operator">+</span> currentProcess<span class="token punctuation">.</span><span class="token function">getPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4 id="6）Try-With-Resources-Improvement"><a href="#6）Try-With-Resources-Improvement" class="headerlink" title="6）Try With Resources Improvement"></a>6）Try With Resources Improvement</h4><p>我们知道，Java SE 7 引入了一个新的异常处理结构：<code>Try-With-Resources</code>，来自动管理资源。这个新的声明结构主要目的是实现“Automatic Better Resource Management”（“自动资源管理”）。</p>
<p>Java SE 9 将对这个声明作出一些改进来避免一些冗长写法，同时提高可读性。</p>
<p><strong>Java SE 7 示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">testARM_Before_Java9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    BufferedReader reader1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"journaldev.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>BufferedReader reader2 <span class="token operator">=</span> reader1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reader2<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>Java SE 9 示例</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">testARM_Java9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
    BufferedReader reader1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"journaldev.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span>reader1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reader1<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="7）CompletableFuture-API-Improvements"><a href="#7）CompletableFuture-API-Improvements" class="headerlink" title="7）CompletableFuture API Improvements"></a>7）CompletableFuture API Improvements</h4><p>在 Java SE 9 中，Oracle 公司将改进 CompletableFuture API 来解决一些 Java SE 8 中出现的问题。这些被添加的 API 将用来支持一些延时和超时操作，实用方法和更好的子类化。</p>
<pre class=" language-java"><code class="language-java">Executor exe <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">delayedExecutor</span><span class="token punctuation">(</span>50L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这里的 delayedExecutor() 是静态实用方法，用来返回一个在指定延时时间提交任务到默认执行器的新 Executor 对象。</p>
<h4 id="8）反应式流-（-Reactive-Streams-）"><a href="#8）反应式流-（-Reactive-Streams-）" class="headerlink" title="8）反应式流 （ Reactive Streams ）"></a>8）反应式流 （ Reactive Streams ）</h4><p> 反应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的反应式 库 RxJava 和 R eactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。</p>
<p>Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 F low.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。 </p>
<h4 id="9）改进的-Stream-API"><a href="#9）改进的-Stream-API" class="headerlink" title="9）改进的 Stream API"></a>9）改进的 Stream API</h4><p>长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p>
<pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。</p>
<p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 <code>stram</code> 将一个 Optional 对象转换为一个(可能是空的) Stream 对象：</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。</p>
<h4 id="10）HTTP-2"><a href="#10）HTTP-2" class="headerlink" title="10）HTTP/2"></a>10）HTTP/2</h4><p>Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 <code>HttpURLConnection</code> API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p>
<pre class=" language-java"><code class="language-java">HttpClient client <span class="token operator">=</span> HttpClient<span class="token punctuation">.</span><span class="token function">newHttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

HttpRequest req <span class="token operator">=</span>
   HttpRequest<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span>URI<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://www.google.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">,</span><span class="token string">"Java"</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

HttpResponse<span class="token operator">&lt;</span>String<span class="token operator">></span> resp <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> HttpResponse<span class="token punctuation">.</span>BodyHandler<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><code>HttpResponse&lt;String&gt; resp = client.send(req, HttpResponse.BodyHandler.asString());</code></p>
<p>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</p>
<h4 id="11）Optional-Class-Improvements"><a href="#11）Optional-Class-Improvements" class="headerlink" title="11）Optional Class Improvements"></a>11）Optional Class Improvements</h4><p>在 Java SE 9 中，Oracle 公司添加了一些新的实用方法到 <code>java.util.Optional</code> 类里面。这里我将使用一些简单的示例来描述其中的一个：stream 方法。</p>
<p>如果一个值出现在给定 Optional 对象中，stream() 方法可以返回包含该值的一个顺序 Stream 对象。否则，将返回一个空 Stream。</p>
<p><code>stream()</code> 方法已经被添加，并用来在 Optional 对象中使用，如：</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>Optional<span class="token operator">></span> emp <span class="token operator">=</span> <span class="token function">getEmployee</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
Stream empStream <span class="token operator">=</span> emp<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Optional<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span></code></pre>
<p>这里的 <code>Optional.stream()</code> 方法被用来转化 Employee 可选流对象 到 Employee 流中，如此我们便可以在后续代码中使用这个结果。</p>
<h4 id="12）多版本兼容-JAR"><a href="#12）多版本兼容-JAR" class="headerlink" title="12）多版本兼容 JAR"></a>12）多版本兼容 JAR</h4><p>我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：</p>
<pre class=" language-xml"><code class="language-xml">multirelease.jar
├── META-INF
│   └── versions
│       └── 9
│           └── multirelease
│               └── Helper.class
├── multirelease
    ├── Helper.class
    └── Main.class</code></pre>
<p>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/">
      Java面试知识点解析(三)——JVM篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月16日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<p><a href="https://www.jianshu.com/p/7382c0a843ff" target="_blank" rel="noopener">Java 面试知识点解析(二)——高并发编程篇</a></p>
<hr>
<h2 id="（一）JVM-基础知识"><a href="#（一）JVM-基础知识" class="headerlink" title="（一）JVM 基础知识"></a>（一）JVM 基础知识</h2><blockquote>
<p>问题和答案都是自行整理的，所以仅供参考！欢迎指正！</p>
</blockquote>
<h4 id="1）Java-是如何实现跨平台的？"><a href="#1）Java-是如何实现跨平台的？" class="headerlink" title="1）Java 是如何实现跨平台的？"></a>1）Java 是如何实现跨平台的？</h4><p><strong>注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</strong></p>
<p>答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p>
<p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-10b94c75252f5e5e.png" alt=""></p>
<h4 id="2）什么是-JVM-？"><a href="#2）什么是-JVM-？" class="headerlink" title="2）什么是 JVM ？"></a>2）什么是 JVM ？</h4><p>解析：不仅仅是基本概念，还有 JVM 的作用。</p>
<p>答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h4 id="3）JVM-由哪些部分组成？"><a href="#3）JVM-由哪些部分组成？" class="headerlink" title="3）JVM 由哪些部分组成？"></a>3）JVM 由哪些部分组成？</h4><p>解析：这是对 JVM 体系结构的考察</p>
<p>答：JVM 的结构基本上由 4 部分组成：</p>
<ul>
<li><p>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p>
</li>
<li><p>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p>
</li>
<li><p>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p>
</li>
<li><p>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-f42e851debb0a070.png" alt=""></p>
<h4 id="4）类加载器是有了解吗？"><a href="#4）类加载器是有了解吗？" class="headerlink" title="4）类加载器是有了解吗？"></a>4）类加载器是有了解吗？</h4><p>解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。</p>
<p>答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p>
<p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<p><strong>面试官：Java 虚拟机是如何判定两个 Java 类是相同的？</strong></p>
<p>答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p>
<h4 id="5）类加载器是如何加载-class-文件的？"><a href="#5）类加载器是如何加载-class-文件的？" class="headerlink" title="5）类加载器是如何加载 class 文件的？"></a>5）类加载器是如何加载 class 文件的？</h4><p>答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-9b726ee9e5ed7e03.png" alt=""></p>
<p>第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中</p>
<p>第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接</p>
<p>第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等</p>
<p><strong>面试官：能详细讲讲吗？</strong></p>
<p>答：</p>
<p><strong>1.加载</strong></p>
<p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p><strong>2.连接</strong></p>
<p><strong>验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证：</strong>验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证：</strong>对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li>
<li><strong>字节码验证：</strong>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证：</strong>确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备：为类的<code>静态变量</code>分配内存，并将其初始化为默认值</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为： <code>public static int value = 3;</code></p>
<p>那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的<code>public static</code>指令是在程序编译后，存放于类构造器 <code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<ul>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</li>
</ul>
<p>假设上面的类变量 value 被定义为： <code>public static final int value = 3;</code></p>
<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中</p>
<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p><strong>3.初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>① 声明类变量是指定初始值</li>
<li>② 使用静态代码块为类变量指定初始值</li>
</ul>
<p>JVM初始化步骤</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li>
</ul>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(一):java类的加载机制 - 纯洁的微笑</a></p>
</blockquote>
<h4 id="7）双亲委派模型（Parent-Delegation-Model）？"><a href="#7）双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="7）双亲委派模型（Parent Delegation Model）？"></a>7）双亲委派模型（Parent Delegation Model）？</h4><p>解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性</p>
<p>答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-b4a569a5cc980a34.png" alt=""></p>
<p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）</p>
<p><strong>面试官：双亲委派模型的工作过程？</strong></p>
<p>答：</p>
<p>1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p>
<blockquote>
<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，<br>等下次加载的时候就可以直接返回了。</p>
</blockquote>
<p>2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p>
<blockquote>
<p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p>
</blockquote>
<p><strong>面试官：为什么这样设计呢？</strong></p>
<p>解析：这是对于使用这种模型来组织累加器的好处</p>
<p>答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException. </p>
<blockquote>
<p>参考文章： <a href="https://segmentfault.com/a/1190000002579346" target="_blank" rel="noopener">JVM 的 工作原理，层次结构 以及 GC工作原理</a></p>
</blockquote>
<hr>
<h2 id="（二）JVM-内存管理"><a href="#（二）JVM-内存管理" class="headerlink" title="（二）JVM 内存管理"></a>（二）JVM 内存管理</h2><h4 id="1）JVM-内存划分："><a href="#1）JVM-内存划分：" class="headerlink" title="1）JVM 内存划分："></a>1）JVM 内存划分：</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-cf626e0e356e89d7.png" alt=""></p>
<p>答：</p>
<ol>
<li><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<ul>
<li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li>
</ul>
</li>
<li><p>堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</p>
</li>
<li><p>程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
</li>
<li><p>虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程；</p>
</li>
<li><p>本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务</p>
</li>
</ol>
<h4 id="2）对象分配规则？"><a href="#2）对象分配规则？" class="headerlink" title="2）对象分配规则？"></a>2）对象分配规则？</h4><p>答：</p>
<ul>
<li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</li>
<li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p>
</li>
<li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
</li>
<li><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 </p>
</li>
</ul>
<h4 id="3）Java-的内存模型："><a href="#3）Java-的内存模型：" class="headerlink" title="3）Java 的内存模型："></a>3）Java 的内存模型：</h4><p>答：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d385883cf2bc0725.png" alt=""></p>
<p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p>
<p><strong>面试官：两个线程之间是如何通信的呢？</strong></p>
<p>答：在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-ef21427c586e224c.png" alt=""></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ul>
<li>1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去</li>
<li>2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-7a3d44fd74ad5da8.png" alt=""></p>
<p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。</p>
<h4 id="5）内存屏障？"><a href="#5）内存屏障？" class="headerlink" title="5）内存屏障？"></a>5）内存屏障？</h4><p>解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></p>
<p>答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p><strong>面试官：内存屏障为何重要？</strong></p>
<p>答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h4 id="5）类似-Xms、-Xmn这些参数的含义："><a href="#5）类似-Xms、-Xmn这些参数的含义：" class="headerlink" title="5）类似-Xms、-Xmn这些参数的含义："></a>5）类似-Xms、-Xmn这些参数的含义：</h4><p>答：</p>
<p>堆内存分配：</p>
<ol>
<li>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64</li>
<li>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4</li>
<li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。</li>
<li>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。</li>
</ol>
<p>非堆内存分配：</p>
<ol>
<li>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；</li>
<li>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</li>
<li>-Xmn2G：设置年轻代大小为2G。</li>
<li>-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。</li>
</ol>
<h4 id="6）内存泄漏和内存溢出"><a href="#6）内存泄漏和内存溢出" class="headerlink" title="6）内存泄漏和内存溢出"></a>6）内存泄漏和内存溢出</h4><p>答：</p>
<p>概念：</p>
<ol>
<li>内存溢出指的是内存不够用了。</li>
<li>内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收</li>
<li>内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。</li>
</ol>
<p>内存泄漏的原因分析：</p>
<ol>
<li>长生命周期的对象引用短生命周期的对象</li>
<li>没有将无用对象置为null</li>
</ol>
<blockquote>
<p>小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。</p>
</blockquote>
<h4 id="7）简述一下-Java-中创建一个对象的过程？"><a href="#7）简述一下-Java-中创建一个对象的过程？" class="headerlink" title="7）简述一下 Java 中创建一个对象的过程？"></a>7）简述一下 Java 中创建一个对象的过程？</h4><p>解析：回答这个问题首先就要清楚类的生命周期</p>
<p>答：下图展示的是类的生命周期流向：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-b1d7d32f1eb7e1c5.png" alt=""></p>
<p>Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。</p>
<p>大致过程如下：</p>
<p><strong>1.检测类是否被加载：</strong></p>
<p>当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。</p>
<p><strong>2.为对象分配内存：</strong></p>
<p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p>
<p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<ul>
<li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。</li>
<li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。</li>
</ul>
<p>分配内存的时候也需要考虑线程安全问题，有两种解决方案：</p>
<ul>
<li>第一种是采用同步的办法，使用CAS来保证操作的原子性。</li>
<li>另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。</li>
</ul>
<p><strong>3.为分配的内存空间初始化零值：</strong></p>
<p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p>
<p><strong>4.对对象进行其他设置：</strong></p>
<p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。</p>
<p><strong>5.执行 init 方法：</strong></p>
<p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。</p>
<p>到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d3f0b79374e52e6b.png" alt=""></p>
<blockquote>
<p>参考文章：<a href="http://cxis.me/2016/12/01/Java创建对象的过程简介/" target="_blank" rel="noopener">Java创建对象的过程简介</a></p>
</blockquote>
<p><strong>面试官：对象的内存布局是怎样的？</strong></p>
<p>答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。</p>
<ul>
<li><p>对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。</p>
</li>
<li><p>实例数据：就是数据啦</p>
</li>
<li><p>对齐填充：不是必然的存在，就是为了对齐的嘛</p>
</li>
</ul>
<p><strong>面试官：对象是如何定位访问的？</strong></p>
<p>答：对象的访问定位有两种：句柄定位和直接指针</p>
<ul>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-24ab9d16017066ac.png" alt=""></p>
<ul>
<li>直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-37413a4771387b81.png" alt=""></p>
<p><strong>比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。</strong></p>
<blockquote>
<p>参考文章：<a href="https://troywu0.gitbooks.io/spark/content/java对象创建的过程.html" target="_blank" rel="noopener">JAVA对象创建的过程</a></p>
</blockquote>
<hr>
<h2 id="（三）GC-相关"><a href="#（三）GC-相关" class="headerlink" title="（三）GC 相关"></a>（三）GC 相关</h2><h4 id="1）如何判断一个对象是否已经死去？"><a href="#1）如何判断一个对象是否已经死去？" class="headerlink" title="1）如何判断一个对象是否已经死去？"></a>1）如何判断一个对象是否已经死去？</h4><p>答：</p>
<ol>
<li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
</li>
<li><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
</li>
</ol>
<h4 id="2）垃圾回收算法有哪些？"><a href="#2）垃圾回收算法有哪些？" class="headerlink" title="2）垃圾回收算法有哪些？"></a>2）垃圾回收算法有哪些？</h4><p>答：</p>
<ol>
<li><p>引用计数：<br>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
</li>
<li><p>标记-清除：<br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-629206f5d8336bc5.png" alt=""></p>
<ol start="3">
<li>复制算法：<br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-45baf8ef2625fba4.png" alt=""></p>
<ol start="4">
<li>标记-整理：<br>此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-4b2c9593a91f5816.png" alt=""></p>
<ol start="5">
<li>分代收集算法：<ul>
<li>分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。</li>
<li>在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</a></p>
</blockquote>
<h4 id="3）GC什么时候开始？"><a href="#3）GC什么时候开始？" class="headerlink" title="3）GC什么时候开始？"></a>3）GC什么时候开始？</h4><p>答：GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。</p>
<ol>
<li><p>对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；</p>
</li>
<li><p>Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；</p>
</li>
<li><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p>
</li>
</ol>
<h4 id="4）引用的分类？"><a href="#4）引用的分类？" class="headerlink" title="4）引用的分类？"></a>4）引用的分类？</h4><p>答：</p>
<ul>
<li><p>强引用：通过new出来的引用，只要强引用还存在，则不会回收。</p>
</li>
<li><p>软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。</p>
</li>
<li><p>弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。</p>
</li>
<li><p>虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。</p>
</li>
</ul>
<blockquote>
<p>扩展阅读：<a href="https://www.jianshu.com/p/39753aad9a38" target="_blank" rel="noopener">重新认识java（一） —- 万物皆对象</a> ，文章中有对这四个引用有详细的描述，还有一些典型的应用，这里就不摘过来啦…</p>
</blockquote>
<h4 id="5）垃圾收集器？"><a href="#5）垃圾收集器？" class="headerlink" title="5）垃圾收集器？"></a>5）垃圾收集器？</h4><p>解析：如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<p>答：</p>
<p><strong>1. Serial 收集器</strong></p>
<p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会 Stop The World（服务暂停）</p>
<p>参数控制： <code>-XX:+UseSerialGC</code> 串行收集器</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-ecea7511ae962fcc.png" alt=""></p>
<p><strong>2.ParNew 收集器</strong></p>
<p>ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：</p>
<p><code>-XX:+UseParNewGC</code> ParNew收集器<br><code>-XX:ParallelGCThreads</code> 限制线程数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-82bf115baf89fdbd.png" alt=""></p>
<p><strong>3.Parallel Scavenge收集器</strong></p>
<p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p>
<p><strong>4.Parallel Old 收集器</strong></p>
<p>Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在 JDK 1.6 中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p>
<p><strong>5.CMS收集器</strong></p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p><strong>优点:</strong> 并发收集、低停顿<br><strong>缺点:</strong> 产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制：</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-d691b23585b39e9e.png" alt=""></p>
<p><strong>6.G1收集器</strong></p>
<p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<ol>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ol>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-8e8b4f853fd38684.png" alt=""></p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-6fb4792713799689.png" alt=""></p>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-fbf007a6f9e8bc6c.png" alt=""></p>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-8ef492a1c182ae1a.png" alt=""></p>
<blockquote>
<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483952&idx=1&sn=ea12792a9b7c67baddfaf425d8272d33&chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&scene=21#wechat_redirect" target="_blank" rel="noopener">jvm系列(三):GC算法 垃圾收集器——纯洁的微笑</a></p>
</blockquote>
<hr>
<h2 id="（四）其他-JVM-相关面试题整理"><a href="#（四）其他-JVM-相关面试题整理" class="headerlink" title="（四）其他 JVM 相关面试题整理"></a>（四）其他 JVM 相关面试题整理</h2><h4 id="1）64-位-JVM-中，int-的长度是多数？"><a href="#1）64-位-JVM-中，int-的长度是多数？" class="headerlink" title="1）64 位 JVM 中，int 的长度是多数？"></a>1）64 位 JVM 中，int 的长度是多数？</h4><p>答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h4 id="2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#2）怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h4><p>答：Sun有一个Java System属性来确定JVM的位数：32或64：</p>
<pre class=" language-java"><code class="language-java">sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">32</span> <span class="token comment" spellcheck="true">// 32 bit JVM</span>
sun<span class="token punctuation">.</span>arch<span class="token punctuation">.</span>data<span class="token punctuation">.</span>model<span class="token operator">=</span><span class="token number">64</span> <span class="token comment" spellcheck="true">// 64 bit JVM</span></code></pre>
<p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"sun.arch.data.model"</span><span class="token punctuation">)</span> </code></pre>
<h4 id="3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#3）32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h4><p>答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<h4 id="4）你能保证-GC-执行吗？"><a href="#4）你能保证-GC-执行吗？" class="headerlink" title="4）你能保证 GC 执行吗？"></a>4）你能保证 GC 执行吗？</h4><p>答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。</p>
<h4 id="5）怎么获取-Java-程序使用的内存？堆使用的百分比？"><a href="#5）怎么获取-Java-程序使用的内存？堆使用的百分比？" class="headerlink" title="5）怎么获取 Java 程序使用的内存？堆使用的百分比？"></a>5）怎么获取 Java 程序使用的内存？堆使用的百分比？</h4><p>答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<h4 id="6）Java-中堆和栈有什么区别？"><a href="#6）Java-中堆和栈有什么区别？" class="headerlink" title="6）Java 中堆和栈有什么区别？"></a>6）Java 中堆和栈有什么区别？</h4><p>答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94JVM%E7%AF%87/7896890-19ed61ccd60a57df.png" alt=""></p>
<hr>
<blockquote>
<p>小结：JVM 是自己之前没有去了解过得知识，所以这次写这篇文章写了很久，也学到了很多东西；在考虑要不要开微信公众号来着…</p>
</blockquote>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ol>
<li>《深入理解 Java 虚拟机》</li>
<li>《深入分析 Java Web技术内幕》</li>
</ol>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/">
      Java面试知识点解析(二)——高并发编程篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月10日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<p>前序文章链接：</p>
<p><a href="https://www.jianshu.com/p/883260941da8" target="_blank" rel="noopener">Java 面试知识点解析(一)——基础知识篇</a></p>
<hr>
<h2 id="（一）高并发编程基础知识"><a href="#（一）高并发编程基础知识" class="headerlink" title="（一）高并发编程基础知识"></a>（一）高并发编程基础知识</h2><blockquote>
<p>这里涉及到一些基础的概念，我重新捧起了一下《实战 Java 高并发程序设计》这一本书，感觉到心潮澎湃，这或许就是笔者叙述功底扎实的魅力吧，喜欢。对于并发的基础可以参照一下我之前写过的一篇博文：<a href="https://www.jianshu.com/p/cd9d0927be35" target="_blank" rel="noopener">Java学习笔记（4）——并发基础</a></p>
</blockquote>
<h4 id="1）多线程和单线程的区别和联系？"><a href="#1）多线程和单线程的区别和联系？" class="headerlink" title="1）多线程和单线程的区别和联系？"></a>1）多线程和单线程的区别和联系？</h4><p>答：</p>
<ol>
<li><p>在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。</p>
</li>
<li><p>多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。</p>
</li>
</ol>
<p>结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。</p>
<p><strong>面试官：那使用多线程有什么优势？</strong></p>
<p>解析：尽管面临很多挑战，多线程有一些优点仍然使得它一直被使用，而这些优点我们应该了解。</p>
<p>答：</p>
<p>（1）资源利用率更好</p>
<p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p>
<pre><code>1| 5秒读取文件A
2| 2秒处理文件A
3| 5秒读取文件B
4| 2秒处理文件B
5| ---------------------
6| 总共需要14秒</code></pre><p>从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</p>
<pre><code>1| 5秒读取文件A
2| 5秒读取文件B + 2秒处理文件A
3| 2秒处理文件B
4| ---------------------
5| 总共需要12秒</code></pre><p>CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。</p>
<p>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。</p>
<p>（2）程序设计在某些情况下更简单</p>
<p>在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</p>
<p>（3）程序响应更快</p>
<p>有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单赶快找、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？</p>
<p>在上面的场景中，可以使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。</p>
<blockquote>
<p><strong>多线程还有一些优势也显而易见：</strong><br>① 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。<br>② 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.<br>③ Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程.</p>
</blockquote>
<h4 id="2）多线程一定快吗？"><a href="#2）多线程一定快吗？" class="headerlink" title="2）多线程一定快吗？"></a>2）多线程一定快吗？</h4><p>答：不一定。</p>
<p>比如，我们尝试使用并行和串行来分别执行累加的操作观察是否并行执行一定比串行执行更快：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-a698017d4c0dbf79.png" alt=""></p>
<p>以下是我测试的结果，可以看出，当不超过1百万的时候，并行是明显比串行要慢的，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-e515dc406651240b.png" alt=""></p>
<h4 id="3）什么是同步？什么又是异步？"><a href="#3）什么是同步？什么又是异步？" class="headerlink" title="3）什么是同步？什么又是异步？"></a>3）什么是同步？什么又是异步？</h4><p>解析：这是对多线程基础知识的考察</p>
<p>答：同步和异步通常用来形容一次方法调用。</p>
<p>同步方法调用一旦开始，调用者必须等到方法返回后，才能继续后续的行为。这就好像是我们去商城买一台空调，你看中了一台空调，于是就跟售货员下了单，然后售货员就去仓库帮你调配物品，这天你热的实在不行，就催着商家赶紧发货，于是你就在商店里等着，知道商家把你和空调都送回家，一次愉快的购物才结束，这就是同步调用。</p>
<p>而异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。回到刚才买空调的例子，我们可以坐在里打开电脑，在网上订购一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。这就是异步调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-a8d7703b4874703a.png" alt=""></p>
<p><strong>面试官：那并发（Concurrency）和并行（Parallelism）的区别呢？</strong></p>
<p>解析：并行性和并发性是既相似又有区别的两个概念。</p>
<p><strong>答：并行性是指两个或多个事件在同一时刻发生。而并发性是指连个或多个事件在同一时间间隔内发生。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-672dfca5db6de845.png" alt=""></p>
<p>在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机环境下（一个处理器），每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。例如，在1秒钟时间内，0-15ms程序A运行；15-30ms程序B运行；30-45ms程序C运行；45-60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。</p>
<p>如果在计算机系统中有多个处理机，这些可以并发执行的程序就可以被分配到多个处理机上，实现并发执行，即利用每个处理机处理一个可并发执行的程序。这样，多个程序便可以同时执行。以此就能提高系统中的资源利用率，增加系统的吞吐量。</p>
<h4 id="4）线程和进程的区别：（必考）"><a href="#4）线程和进程的区别：（必考）" class="headerlink" title="4）线程和进程的区别：（必考）"></a>4）线程和进程的区别：（必考）</h4><p>答：</p>
<ol>
<li><p>进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位；</p>
</li>
<li><p>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）；</p>
</li>
<li><p>线程上下文的切换比进程上下文切换要快很多。</p>
<ul>
<li><p>（1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。</p>
</li>
<li><p>（2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</p>
</li>
</ul>
</li>
</ol>
<p><strong>面试官：进程间如何通讯？线程间如何通讯？</strong></p>
<p>答：进程间通讯依靠 IPC 资源，例如管道（pipes）、套接字（sockets）等；</p>
<p>线程间通讯依靠 JVM 提供的 API，例如 wait()、notify()、notifyAll() 等方法，线程间还可以通过共享的主内存来进行值的传递。</p>
<blockquote>
<p>关于线程和进程有一篇写得非常不错的文章，不过是英文的，我进行了翻译，相信阅读之后会对进程和线程有不一样的理解：<a href="https://www.jianshu.com/p/11e6cb1c3d38" target="_blank" rel="noopener">线程和进程基础——翻译文</a></p>
</blockquote>
<h4 id="5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？"><a href="#5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？" class="headerlink" title="5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？"></a>5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？</h4><p>答：阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个而资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。</p>
<p>非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。</p>
<p><strong>面试官：临界区是什么？</strong></p>
<p>答：临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。</p>
<p>比如，在一个办公室里有一台打印机，打印机一次只能执行一个任务。如果小王和小明同时需要打印文件，很显然，如果小王先下发了打印任务，打印机就开始打印小王的文件了，小明的任务就只能等待小王打印结束后才能打印，这里的打印机就是一个临界区的例子。</p>
<p>在并行程序中，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务，那么最可能的结果就是打印出来的文件就会是损坏的文件，它既不是小王想要的，也不是小明想要的。</p>
<h4 id="6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？"><a href="#6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？" class="headerlink" title="6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？"></a>6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？</h4><p>答：死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-a6041256aed650a5.png" alt=""></p>
<ol>
<li><p>死锁应该是最糟糕的一种情况了，它表示两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 </p>
</li>
<li><p>饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：<br>1）它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。在自然界中，母鸡喂食雏鸟时，很容易出现这种情况，由于雏鸟很多，食物有限，雏鸟之间的食物竞争可能非常厉害，小雏鸟因为经常抢不到食物，有可能会被饿死。线程的饥饿也非常类似这种情况。<br>2）另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。<br>与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行）</p>
</li>
<li><p>活锁是一种非常有趣的情况。不知道大家是不是有遇到过这样一种情况，当你要坐电梯下楼，电梯到了，门开了，这时你正准备出去，但不巧的是，门外一个人挡着你的去路，他想进来。于是你很绅士的靠左走，避让对方，但同时对方也很绅士，但他靠右走希望避让你。结果，你们又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右走，他也立即向左走，结果又撞上了！不过介于人类的只能，我相信这个动作重复 2、 3 次后，你应该可以顺利解决这个问题，因为这个时候，大家都会本能的对视，进行交流，保证这种情况不再发生。<br>但如果这种情况发生在两个线程间可能就不会那么幸运了，如果线程的智力不够，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有的资源而正常执行。这种情况就是活锁。</p>
</li>
</ol>
<h4 id="7）多线程产生死锁的-4-个必要条件？"><a href="#7）多线程产生死锁的-4-个必要条件？" class="headerlink" title="7）多线程产生死锁的 4 个必要条件？"></a>7）多线程产生死锁的 4 个必要条件？</h4><p>答：</p>
<ol>
<li><p>互斥条件：一个资源每次只能被一个线程使用；</p>
</li>
<li><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</p>
</li>
<li><p>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；</p>
</li>
<li><p>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ol>
<p><strong>面试官：如何避免死锁？（经常接着问这个问题哦~）</strong></p>
<p>答：指定获取锁的顺序，举例如下：</p>
<ol>
<li><p>比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</p>
</li>
<li><p>获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！</p>
</li>
</ol>
<h4 id="8）如何指定多个线程的执行顺序？"><a href="#8）如何指定多个线程的执行顺序？" class="headerlink" title="8）如何指定多个线程的执行顺序？"></a>8）如何指定多个线程的执行顺序？</h4><p>解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现）</p>
<p>答：</p>
<ol>
<li><p>设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。</p>
</li>
<li><p>在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。</p>
</li>
</ol>
<h4 id="9）Java-中线程有几种状态？"><a href="#9）Java-中线程有几种状态？" class="headerlink" title="9）Java 中线程有几种状态？"></a>9）Java 中线程有几种状态？</h4><p>答：六种（查看 Java 源码也可以看到是 6 种），并且某个时刻 Java 线程只能处于其中的一个状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-7b69db5925631d29.png" alt=""></p>
<ol>
<li><p>新建（NEW）状态：表示新创建了一个线程对象，而此时线程并没有开始执行。</p>
</li>
<li><p>可运行（RUNNABLE）状态：线程对象创建后，其它线程（比如 main 线程）调用了该对象的 start() 方法，才表示线程开始执行。当线程执行时，处于 RUNNBALE 状态，表示线程所需的一切资源都已经准备好了。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。</p>
</li>
<li><p>阻塞（BLOCKED）状态：如果线程在执行过程终于到了 synchronized 同步块，就会进入 BLOCKED 阻塞状态，这时线程就会暂停执行，直到获得请求的锁。</p>
</li>
<li><p>等待（WAITING）状态：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况；</p>
</li>
<li><p>计时等待（TIMED_WAITING）状态：Object.wait、Thread.join、Lock.tryLock和Condition.await 等方法有超时参数，还有 Thread.sleep 方法、LockSupport.parkNanos 方法和 LockSupport.parkUntil 方法，这些方法会导致线程进入计时等待状态，如果超时或者出现通知，都会切换会可运行状态；</p>
</li>
<li><p>终止（TERMINATED）状态：当线程执行完毕，则进入该状态，表示结束。</p>
</li>
</ol>
<p>注意：从 NEW 状态出发后，线程不能再回到 NEW 状态，同理，处于 TERMINATED 状态的线程也不能再回到 RUNNABLE 状态。</p>
<hr>
<h2 id="（二）高并发编程-JUC-包"><a href="#（二）高并发编程-JUC-包" class="headerlink" title="（二）高并发编程-JUC 包"></a>（二）高并发编程-JUC 包</h2><blockquote>
<p>在 Java 5.0 提供了 java.util.concurrent（简称 JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。</p>
</blockquote>
<h4 id="1）sleep-和-wait-n-、wait-的区别："><a href="#1）sleep-和-wait-n-、wait-的区别：" class="headerlink" title="1）sleep( ) 和 wait( n)、wait( ) 的区别："></a>1）sleep( ) 和 wait( n)、wait( ) 的区别：</h4><p>答：</p>
<ol>
<li><p>sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；</p>
</li>
<li><p>wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。</p>
</li>
</ol>
<h4 id="2）synchronized-关键字："><a href="#2）synchronized-关键字：" class="headerlink" title="2）synchronized 关键字："></a>2）synchronized 关键字：</h4><p>答：底层实现：</p>
<ol>
<li><p>进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；</p>
</li>
<li><p>当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。</p>
</li>
</ol>
<p>含义：（monitor 机制）</p>
<p>Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。</p>
<p>该关键字是一个几种锁的封装。</p>
<h4 id="3）volatile-关键字："><a href="#3）volatile-关键字：" class="headerlink" title="3）volatile 关键字："></a>3）volatile 关键字：</h4><p>答：该关键字可以保证可见性不保证原子性。</p>
<p>功能：</p>
<ol>
<li><p>主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；</p>
</li>
<li><p>禁止 JVM 进行的指令重排序。</p>
</li>
</ol>
<p>解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。</p>
<h4 id="4）volatile-能使得一个非原子操作变成原子操作吗？"><a href="#4）volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="4）volatile 能使得一个非原子操作变成原子操作吗？"></a>4）volatile 能使得一个非原子操作变成原子操作吗？</h4><p>答：能。</p>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p><strong>面试官：volatile 修饰符的有过什么实践？</strong></p>
<p>答：</p>
<ol>
<li><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。</p>
</li>
<li><p>volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
</li>
</ol>
<h4 id="5）ThreadLocal（线程局部变量）关键字："><a href="#5）ThreadLocal（线程局部变量）关键字：" class="headerlink" title="5）ThreadLocal（线程局部变量）关键字："></a>5）ThreadLocal（线程局部变量）关键字：</h4><p>答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p>
<p>ThreadLocal 内部实现机制：</p>
<ol>
<li><p>每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；</p>
</li>
<li><p>Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；</p>
</li>
<li><p>Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-219b164cba63247a.png" alt=""></p>
<h4 id="6）线程池有了解吗？（必考）"><a href="#6）线程池有了解吗？（必考）" class="headerlink" title="6）线程池有了解吗？（必考）"></a>6）线程池有了解吗？（必考）</h4><p>答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：</p>
<blockquote>
<ul>
<li>当前线程池大小 ：表示线程池中实际工作者线程的数量；</li>
<li>最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；</li>
<li>核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。</li>
</ul>
</blockquote>
<ol>
<li><p>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；</p>
</li>
<li><p>如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；</p>
</li>
<li><p>如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。</p>
</li>
</ol>
<p><strong>面试官：我们为什么要使用线程池？</strong></p>
<p>答：</p>
<ol>
<li><p>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
</li>
<li><p>可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机）</p>
</li>
</ol>
<p><strong>面试官：核心线程池内部实现了解吗？</strong></p>
<p>答：对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。</p>
<p>为何 ThreadPoolExecutor 有如此强大的功能呢？我们可以来看一下 ThreadPoolExecutor 最重要的构造函数：</p>
<pre><code>    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)</code></pre><p>函数的参数含义如下：</p>
<ul>
<li>corePoolSize：指定了线程池中的线程数量</li>
<li>maximumPoolSize：指定了线程池中的最大线程数量</li>
<li>keepAliveTime：当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过了 corePoolSize 的空闲线程，在多长时间内，会被销毁。</li>
<li>unit: keepAliveTime 的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</li>
</ul>
<h4 id="7）Atomic关键字："><a href="#7）Atomic关键字：" class="headerlink" title="7）Atomic关键字："></a>7）Atomic关键字：</h4><p><strong>答：可以使基本数据类型以原子的方式实现自增自减等操作。参考博客：<a href="http://blog.csdn.net/qq_25827845/article/details/70225658" target="_blank" rel="noopener">concurrent.atomic包下的类AtomicInteger的使用</a></strong></p>
<h4 id="8）创建线程有哪几种方式？"><a href="#8）创建线程有哪几种方式？" class="headerlink" title="8）创建线程有哪几种方式？"></a>8）创建线程有哪几种方式？</h4><p>答：有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象;二是直接继承Thread类。</p>
<p><strong>面试官：两种方式有什么区别呢？</strong></p>
<ol>
<li>继承方式:<ul>
<li>（1）Java中类是单继承的,如果继承了Thread了,该类就不能再有其他的直接父类了.</li>
<li>（2）从操作上分析,继承方式更简单,获取线程名字也简单.(操作上,更简单)</li>
<li>（3）从多线程共享同一个资源上分析,继承方式不能做到.</li>
</ul>
</li>
<li>实现方式:<ul>
<li>（1）Java中类可以多实现接口,此时该类还可以继承其他类,并且还可以实现其他接口(设计上,更优雅).<ul>
<li>（2）从操作上分析,实现方式稍微复杂点,获取线程名字也比较复杂,得使用Thread.currentThread()来获取当前线程的引用.</li>
<li>（3）从多线程共享同一个资源上分析,实现方式可以做到(是否共享同一个资源).</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="9）run-方法和-start-方法有什么区别？"><a href="#9）run-方法和-start-方法有什么区别？" class="headerlink" title="9）run() 方法和 start() 方法有什么区别？"></a>9）run() 方法和 start() 方法有什么区别？</h4><p>答：start() 方法会新建一个线程并让这个线程执行 run() 方法；而直接调用 run() 方法知识作为一个普通的方法调用而已，它只会在当前线程中，串行执行 run() 中的代码。</p>
<h4 id="10）你怎么理解线程优先级？"><a href="#10）你怎么理解线程优先级？" class="headerlink" title="10）你怎么理解线程优先级？"></a>10）你怎么理解线程优先级？</h4><p>答：Java 中的线程可以有自己的优先级。优先极高的线程在竞争资源时会更有优势，更可能抢占资源，当然，这只是一个概率问题。如果运行不好，高优先级线程可能也会抢占失败。</p>
<p>由于线程的优先级调度和底层操作系统有密切的关系，在各个平台上表现不一，并且这种优先级产生的后果也可能不容易预测，无法精准控制，比如一个低优先级的线程可能一直抢占不到资源，从而始终无法运行，而产生饥饿（虽然优先级低，但是也不能饿死它啊）。因此，在要求严格的场合，还是需要自己在应用层解决线程调度的问题。</p>
<p>在 Java 中，使用 1 到 10 表示线程优先级，一般可以使用内置的三个静态标量表示：</p>
<pre><code>public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;</code></pre><p>数字越大则优先级越高，但有效范围在 1 到 10 之间，默认的优先级为 5 。</p>
<h4 id="11）在-Java-中如何停止一个线程？"><a href="#11）在-Java-中如何停止一个线程？" class="headerlink" title="11）在 Java 中如何停止一个线程？"></a>11）在 Java 中如何停止一个线程？</h4><p>答：Java 提供了很丰富的 API 但没有为停止线程提供 API 。</p>
<p>JDK 1.0 本来有一些像 stop()，suspend() 和 resume() 的控制方法但是由于潜在的死锁威胁因此在后续的 JDK 版本中他们被弃用了，之后 Java API 的设计者就没有提供一个兼容且线程安全的方法来停止任何一个线程。</p>
<p>当 run() 或者 call() 方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run() 方法的循环或者是取消任务来中断线程。</p>
<h4 id="12）多线程中的忙循环是什么？"><a href="#12）多线程中的忙循环是什么？" class="headerlink" title="12）多线程中的忙循环是什么？"></a>12）多线程中的忙循环是什么？</h4><p>答：忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(),sleep() 或yield() 它们都放弃了 CPU 控制权，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。</p>
<p>在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存，为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<h4 id="13）10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#13）10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="13）10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>13）10 个线程和 2 个线程的同步代码，哪个更容易写？</h4><p>答：从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<h4 id="14）你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？"><a href="#14）你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？" class="headerlink" title="14）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？"></a>14）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</h4><p>答：wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<pre><code>// The standard idiom for using the wait method
synchronized (obj) {
while (condition does not hold)
obj.wait(); // (Releases lock, and reacquires on wakeup)
... // Perform action appropriate to condition
}</code></pre><p>参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。</p>
<h4 id="15）什么是多线程环境下的伪共享（false-sharing）？"><a href="#15）什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="15）什么是多线程环境下的伪共享（false sharing）？"></a>15）什么是多线程环境下的伪共享（false sharing）？</h4><p>答：伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87/7896890-3cbee585a5f68f02.png" alt=""></p>
<p>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。</p>
<h4 id="16）用-wait-notify-写一段代码来解决生产者-消费者问题？"><a href="#16）用-wait-notify-写一段代码来解决生产者-消费者问题？" class="headerlink" title="16）用 wait-notify 写一段代码来解决生产者-消费者问题？"></a>16）用 wait-notify 写一段代码来解决生产者-消费者问题？</h4><p>解析：这是常考的基础类型的题，只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。</p>
<p>答：</p>
<pre><code>import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Java program to solve Producer Consumer problem using wait and notify
 * method in Java. Producer Consumer is also a popular concurrency design pattern.
 *
 * @author Javin Paul
 */
public class ProducerConsumerSolution {

    public static void main(String args[]) {
        Vector sharedQueue = new Vector();
        int size = 4;
        Thread prodThread = new Thread(new Producer(sharedQueue, size), &quot;Producer&quot;);
        Thread consThread = new Thread(new Consumer(sharedQueue, size), &quot;Consumer&quot;);
        prodThread.start();
        consThread.start();
    }
}

class Producer implements Runnable {

    private final Vector sharedQueue;
    private final int SIZE;

    public Producer(Vector sharedQueue, int size) {
        this.sharedQueue = sharedQueue;
        this.SIZE = size;
    }

    @Override
    public void run() {
        for (int i = 0; i &lt; 7; i++) {
            System.out.println(&quot;Produced: &quot; + i);
            try {
                produce(i);
            } catch (InterruptedException ex) {
                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
    }

    private void produce(int i) throws InterruptedException {

        // wait if queue is full
        while (sharedQueue.size() == SIZE) {
            synchronized (sharedQueue) {
                System.out.println(&quot;Queue is full &quot; + Thread.currentThread().getName()
                                    + &quot; is waiting , size: &quot; + sharedQueue.size());

                sharedQueue.wait();
            }
        }

        // producing element and notify consumers
        synchronized (sharedQueue) {
            sharedQueue.add(i);
            sharedQueue.notifyAll();
        }
    }
}

class Consumer implements Runnable {

    private final Vector sharedQueue;
    private final int SIZE;

    public Consumer(Vector sharedQueue, int size) {
        this.sharedQueue = sharedQueue;
        this.SIZE = size;
    }

    @Override
    public void run() {
        while (true) {
            try {
                System.out.println(&quot;Consumed: &quot; + consume());
                Thread.sleep(50);
            } catch (InterruptedException ex) {
                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
    }

    private int consume() throws InterruptedException {
        // wait if queue is empty
        while (sharedQueue.isEmpty()) {
            synchronized (sharedQueue) {
                System.out.println(&quot;Queue is empty &quot; + Thread.currentThread().getName()
                                    + &quot; is waiting , size: &quot; + sharedQueue.size());

                sharedQueue.wait();
            }
        }

        // Otherwise consume element and notify waiting producer
        synchronized (sharedQueue) {
            sharedQueue.notifyAll();
            return (Integer) sharedQueue.remove(0);
        }
    }
}

Output:
Produced: 0
Queue is empty Consumer is waiting , size: 0
Produced: 1
Consumed: 0
Produced: 2
Produced: 3
Produced: 4
Produced: 5
Queue is full Producer is waiting , size: 4
Consumed: 1
Produced: 6
Queue is full Producer is waiting , size: 4
Consumed: 2
Consumed: 3
Consumed: 4
Consumed: 5
Consumed: 6
Queue is empty Consumer is waiting , size: 0</code></pre><h4 id="17）用-Java-写一个线程安全的单例模式（Singleton）？"><a href="#17）用-Java-写一个线程安全的单例模式（Singleton）？" class="headerlink" title="17）用 Java 写一个线程安全的单例模式（Singleton）？"></a>17）用 Java 写一个线程安全的单例模式（Singleton）？</h4><p>解析：有多种方法，但重点掌握的是双重校验锁。</p>
<p>答：</p>
<p>1.饿汉式单例</p>
<p>饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：</p>
<pre><code>public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton (){}

    public static Singleton getInstance() {
        return instance;
    }
}</code></pre><p>2.加入 synchronized 的懒汉式单例</p>
<p>所谓懒汉式单例模式就是在调用的时候才去创建这个实例，我们在对外的创建实例方法上加如 synchronized 关键字保证其在多线程中很好的工作：</p>
<pre><code>public class Singleton {    

    private static Singleton instance;    

    private Singleton (){}    

    public static synchronized Singleton getInstance() {    
        if (instance == null) {    
            instance = new Singleton();    
    }    
    return instance;    
    }    
}  </code></pre><p>3.使用静态内部类的方式创建单例</p>
<p>这种方式利用了 classloder 的机制来保证初始化 instance 时只有一个线程，它跟饿汉式的区别是：饿汉式只要 Singleton 类被加载了，那么 instance 就会被实例化（没有达到 lazy loading 的效果），而这种方式是 Singleton 类被加载了，instance 不一定被初始化。只有显式通过调用 getInstance() 方法时才会显式装载 SingletonHoder 类，从而实例化 singleton</p>
<pre><code>public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {// 静态内部类  
        private static Singleton singleton = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.singleton;
    }
}</code></pre><p>4.双重校验锁</p>
<p>为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：</p>
<pre><code>public class Singleton {  

    private static Singleton singleton;  

    private Singleton() {  
    }  

    public static Singleton getInstance(){  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
} </code></pre><p>这种是用双重判断来创建一个单例的方法，那么我们为什么要使用两个if判断这个对象当前是不是空的呢 ？因为当有多个线程同时要创建对象的时候，多个线程有可能都停止在第一个if判断的地方，等待锁的释放，然后多个线程就都创建了对象，这样就不是单例模式了，所以我们要用两个if来进行这个对象是否存在的判断。</p>
<p>5.使用 static 代码块实现单例</p>
<p>静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。</p>
<pre><code>public class Singleton{  

    private static Singleton instance = null;  

    private Singleton(){}  

    static{  
        instance = new Singleton();  
    }  

    public static Singleton getInstance() {   
        return instance;  
    }   
}  </code></pre><p>6.使用枚举数据类型实现单例模式</p>
<p>枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：</p>
<pre><code>public class ClassFactory{   

    private enum MyEnumSingleton{  
        singletonFactory;  

        private MySingleton instance;  

        private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化  
            instance = new MySingleton();  
        }  

        public MySingleton getInstance(){  
            return instance;  
        }  
    }   

    public static MySingleton getInstance(){  
        return MyEnumSingleton.singletonFactory.getInstance();  
    }  
}  </code></pre><blockquote>
<p>小结：关于 Java 中多线程编程，线程安全等知识一直都是面试中的重点和难点，还需要熟练掌握。</p>
</blockquote>
<hr>
<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">① 知名互联网公司校招 Java 开发岗面试知识点解析</a><br><a href="https://zhuanlan.zhihu.com/p/23533393" target="_blank" rel="noopener">② 最近5年133个Java面试问题列表</a><br>③ 《实战 Java 高并发程序设计 —— 葛一鸣 郭超 编著》</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/05/09/java-mian-shi-zhi-shi-dian-jie-xi-yi-ji-chu-zhi-shi-pian/">
      Java面试知识点解析(一)——基础知识篇
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年5月9日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-958b6a30c60032e8.png" alt=""></p>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<hr>
<h2 id="（一）Java-基础知识点"><a href="#（一）Java-基础知识点" class="headerlink" title="（一）Java 基础知识点"></a>（一）Java 基础知识点</h2><h4 id="1）面向对象的特性有哪些？"><a href="#1）面向对象的特性有哪些？" class="headerlink" title="1）面向对象的特性有哪些？"></a>1）面向对象的特性有哪些？</h4><p>答：封装、继承和多态<em>（应要多算一个那就是抽象）</em></p>
<ul>
<li><p><strong>封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。</strong><br>但封装不仅仅是 private + getter/setter ，使用封装可以对 setter 进行更深层次的定制，例如你可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。<strong>使用封装不仅仅安全，更可以简化操作。</strong>（封装扩展阅读：<a href="https://zhuanlan.zhihu.com/p/20174473" target="_blank" rel="noopener">oc面向对象三大特性之一 &lt;封装&gt;</a>）</p>
</li>
<li><p><strong>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。</strong><br>继承的缺点：<strong>1）</strong>继承是一种强耦合关系，父类变子类也必须变；<strong>2）</strong>继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。</p>
</li>
<li><p><strong>多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。</strong><br>比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。</p>
</li>
</ul>
<p><strong>多态的条件</strong>：<strong>1）</strong>继承；<strong>2）</strong>重写；<strong>3）</strong>向上转型。<br><strong>多态的好处</strong>：当把不同的子类对象都当作父类类型来看，<strong>可以屏蔽不同子类对象之间的实现差异，</strong>从而写出通用的代码达到通用编程，以适应需求的不断变化。（多态扩展阅读：<a href="https://www.jianshu.com/p/5771df145452" target="_blank" rel="noopener">重新认识java（五） —- 面向对象之多态（向上转型与向下转型）</a>）</p>
<ul>
<li><strong>抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。</strong></li>
</ul>
<h4 id="2）面向对象和面向过程的区别？"><a href="#2）面向对象和面向过程的区别？" class="headerlink" title="2）面向对象和面向过程的区别？"></a>2）面向对象和面向过程的区别？</h4><p>答：面向过程是<strong>一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程</strong>，即先干啥，后干啥。</p>
<p>面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-e6027912a8d8c7b6.png" alt=""></p>
<ul>
<li><strong>面向过程的缺陷：</strong><br>向过程的设计,是<strong>采用置顶而下的设计方式</strong>，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</li>
<li><strong>问题：</strong>1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。</li>
</ul>
<p>面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出<strong>面向对象</strong>思想。</p>
<p>面向对象是一种基于面向过程的新的编程思想，是<strong>一种站在对象的角度思考问题</strong>的思想，我们把多个功能合理的放到不同对象里，<strong>强调的是具备某些功能的对象。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-521c9e98caea7217.png" alt=""></p>
<ul>
<li>面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</li>
<li><strong>注意：</strong> 不要粗浅的认为面向对象一定就优于面向过程的设计</li>
</ul>
<blockquote>
<p>看到知乎上有一句有意思的话：</p>
<p>你的程序要完成一个任务，相当于讲一个故事。</p>
<p>面向过程：编年体；<br>面向对象：纪传体。</p>
<p>而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。</p>
</blockquote>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/28427324" target="_blank" rel="noopener">面向过程 VS 面向对象</a></p>
<h4 id="3）JDK-和-JRE-的区别是什么？"><a href="#3）JDK-和-JRE-的区别是什么？" class="headerlink" title="3）JDK 和 JRE 的区别是什么？"></a>3）JDK 和 JRE 的区别是什么？</h4><p>解析：这是考察一些基本的概念</p>
<p>答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 </p>
<p>Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。</p>
<blockquote>
<ul>
<li>还有其他的一些名词也可以再看一下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-8672d90bb496f196.png" alt=""></p>
</blockquote>
<h4 id="4）Java-中覆盖和重载是什么意思？"><a href="#4）Java-中覆盖和重载是什么意思？" class="headerlink" title="4）Java 中覆盖和重载是什么意思？"></a>4）Java 中覆盖和重载是什么意思？</h4><p>解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。</p>
<p>答：<strong>覆盖（Override）是指子类对父类方法的一种重写，</strong>只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。</p>
<p><strong>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</strong></p>
<p>面试官： 那么构成重载的条件有哪些？</p>
<p>答：参数类型不同、参数个数不同、参数顺序不同。</p>
<p>面试官： 函数的返回值不同可以构成重载吗？为什么？</p>
<p>答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下：</p>
<p>如下两个方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>
<p>只要编译器可以根据语境明确判断出语义，比如在 <code>int x = f();</code> 中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用” ），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用：</p>
<pre class=" language-java"><code class="language-java"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>此时 Java 如何才能判断调用的是哪一个 <code>f()</code> 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。</p>
<h4 id="5）抽象类和接口的区别有哪些？"><a href="#5）抽象类和接口的区别有哪些？" class="headerlink" title="5）抽象类和接口的区别有哪些？"></a>5）抽象类和接口的区别有哪些？</h4><p>答：</p>
<ol>
<li>抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；</li>
<li>抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。</li>
<li>抽象类只能单继承，接口可以继承多个父接口；</li>
<li>Java 8 中接口中会有 default 方法，即方法可以被实现。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-dc431887834333f7.png" alt=""></p>
<p><strong>面试官：抽象类和接口如何选择？</strong></p>
<p>答：</p>
<ol>
<li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p>
</li>
<li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p>
</li>
</ol>
<h4 id="6）Java-和-C-的区别："><a href="#6）Java-和-C-的区别：" class="headerlink" title="6）Java 和 C++ 的区别："></a>6）Java 和 C++ 的区别：</h4><p>解析：虽然我们不太懂C++，但是就是会这么问，尤其是三面（总监级别）面试中。</p>
<p>答：</p>
<ol>
<li><p>都是面向对象的语言，都支持封装、继承和多态</p>
</li>
<li><p>指针：Java不提供指针来直接访问内存，程序更加安全</p>
</li>
<li><p>继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承</p>
</li>
<li><p>内存： Java有自动内存管理机制，不需要程序员手动释放无用内存</p>
</li>
</ol>
<h4 id="7）“static”-关键字是什么意思？"><a href="#7）“static”-关键字是什么意思？" class="headerlink" title="7）“static” 关键字是什么意思？"></a>7）“static” 关键字是什么意思？</h4><p>答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p>
<p>面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？</p>
<p>答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 </p>
<p>Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</p>
<p>扩展阅读：<a href="https://www.jianshu.com/p/3eb769986bd3" target="_blank" rel="noopener">重新认识java（六） —- java中的另类：static关键字（附代码块知识）</a></p>
<h4 id="8）Java-是值传递还是引用传递？"><a href="#8）Java-是值传递还是引用传递？" class="headerlink" title="8）Java 是值传递还是引用传递？"></a>8）Java 是值传递还是引用传递？</h4><p>解析：这类题目，面试官会手写一个例子，让你说出函数执行结果。</p>
<p>答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 </p>
<p>一般认为，Java 内的传递都是值传递.，Java 中实例对象的传递是引用传递，Java 是值传递的！</p>
<blockquote>
<ul>
<li>我们先来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-89340c032fb5b240.png" alt=""></p>
<p>这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？</p>
<p>这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。</p>
<blockquote>
<ul>
<li>再来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-75c3162752d36403.png" alt=""></p>
<p>我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？</p>
<p>你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！</p>
<h4 id="9）JDK-中常用的包有哪些？"><a href="#9）JDK-中常用的包有哪些？" class="headerlink" title="9）JDK 中常用的包有哪些？"></a>9）JDK 中常用的包有哪些？</h4><p>答：java.lang、java.util、java.io、java.net、java.sql。</p>
<h4 id="10）JDK，JRE-和-JVM-的联系和区别？"><a href="#10）JDK，JRE-和-JVM-的联系和区别？" class="headerlink" title="10）JDK，JRE 和 JVM 的联系和区别？"></a>10）JDK，JRE 和 JVM 的联系和区别？</h4><p>答：JDK 是 Java 开发工具包，是 Java 开发环境的核心组件，并提供编译、调试和运行一个 Java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。</p>
<p>JRE 是 Java 运行时环境，是 JVM 的实施实现，提供了运行 Java 程序的平台。JRE 包含了 JVM，但是不包含 Java 编译器 / 调试器之类的开发工具。</p>
<p>JVM 是 Java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。</p>
<p>这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因。</p>
<p>区别：</p>
<p>&emsp;&emsp;1. JDK 用于开发，JRE 用于运行 Java 程序；<br>&emsp;&emsp;2. JDK 和 JRE 中都包含 JVM；<br>&emsp;&emsp;3. JVM 是 Java 编程语言的核心并且具有平台独立性。</p>
<h4 id="11）Integer-的缓存机制"><a href="#11）Integer-的缓存机制" class="headerlink" title="11）Integer 的缓存机制"></a>11）Integer 的缓存机制</h4><p>解析：考察的是对源码的熟悉程度</p>
<blockquote>
<ul>
<li>看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-90331ba04ebe13fc.png" alt=""></p>
<blockquote>
<p>第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。</p>
<p>第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。</p>
<p>第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。</p>
</blockquote>
<p>我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-bd248da68e02bb2e.png" alt=""></p>
<p>跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的，了解就行了，不必去深究。）</p>
<h4 id="12）下述两种方法分别创建了几个-Sring-对象？"><a href="#12）下述两种方法分别创建了几个-Sring-对象？" class="headerlink" title="12）下述两种方法分别创建了几个 Sring 对象？"></a>12）下述两种方法分别创建了几个 Sring 对象？</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一种：直接赋一个字面量</span>
String str1 <span class="token operator">=</span> <span class="token string">"ABCD"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 第二种：通过构造器创建</span>
String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>解析：考察的是对 String 对象和 JVM 内存划分的知识。</p>
<p>答：<code>String str1 = &quot;ABCD&quot;;</code>最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用.</p>
<p><code>String str2 = new String(&quot;ABCD&quot;);</code>最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。</p>
<blockquote>
<p>我们来看图理解一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-70af9f49c51c9902.png" alt=""></p>
</blockquote>
<ul>
<li>当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD</li>
<li>当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。</li>
</ul>
<p>String 对象是一个特殊的存在，需要注意的知识点也比较多，这里给一个之前写的 String 详解的文章链接：<a href="https://www.jianshu.com/p/e494552f2cf0" target="_blank" rel="noopener">传送门</a> 其中包含的问题大概有：<strong>1）“+” 怎么连接字符串；2）字符串的比较；3）StringBuilder/StringBuffer/String 的区别；</strong></p>
<h4 id="13）i-与-i-到底有什么不同？"><a href="#13）i-与-i-到底有什么不同？" class="headerlink" title="13）i++ 与 ++i 到底有什么不同？"></a>13）i++ 与 ++i 到底有什么不同？</h4><p>解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，<strong>前置++和后置++一样，在参与运算之前都会将变量的值加 1</strong></p>
<p>答：实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。<strong>二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-4c68b98e2d0f4d2a.png" alt=""></p>
<h4 id="14）交换变量的三种方式"><a href="#14）交换变量的三种方式" class="headerlink" title="14）交换变量的三种方式"></a>14）交换变量的三种方式</h4><p>答：</p>
<blockquote>
<ul>
<li>第一种：通过第三个变量</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Value v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 无效的交换：形参的改变无法反作用于实参</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> y<span class="token punctuation">;</span>
        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有效的交换：通过引用（变量指向一个对象）来修改成员变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> value<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>x <span class="token operator">=</span> value<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Value</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>5<br>10<br>10<br>5</p>
</blockquote>
<p>这有点类似于C/C++语言中的指针，不过相对来说更加安全。</p>
<p>事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。</p>
<blockquote>
<p>第二种：通过通过相加的方式（相同的 Value 类不再重复展示）</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1的交换结果：<br>10<br>5</p>
</blockquote>
<p>核心的算法就是swap方法:</p>
<pre class=" language-java"><code class="language-java">v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在v.x中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y本来的值即为v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y的值也就是以前x.y的值</span></code></pre>
<p>这样就可以不通过临时变量，来达到交换两个变量的目的，如果觉得上面的方法不太容易理解，我们也可以用另一个参数z来表示上述过程：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> z <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在z中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉以前的v.y就等于v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉现在的v.y即以前的v.x，即为v.y</span></code></pre>
<p>但并<strong>不推荐这种做法</strong>，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。</p>
<blockquote>
<ul>
<li>第三种：通过异或的方式：</li>
</ul>
</blockquote>
<p>位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：<br><code>（x ^ y ^ y） == x</code>这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1交换之后的结果为：<br>10<br>5</p>
</blockquote>
<p>跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。<strong>异或的方法比相加更加可取的地方在于，异或不存在数据溢出。</strong></p>
<h4 id="15）Java-对象初始化顺序？"><a href="#15）Java-对象初始化顺序？" class="headerlink" title="15）Java 对象初始化顺序？"></a>15）Java 对象初始化顺序？</h4><p>答：不考虑静态成员的初始化，调用一个对象的构造函数时，程序<strong>先调用父类的构造函数</strong>（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），<strong>之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行</strong>，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；<strong>最后调用自身构造函数。</strong></p>
<blockquote>
<ul>
<li>我们可以写一段程序来对初始化顺序进行一个简单的验证：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> Member m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Initial Block()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Derive()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Member m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getInt()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Member</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Member</span><span class="token punctuation">(</span>String m<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Member() "</span><span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>程序的输出结果是：<br>Base()<br>Member() Member 1<br>Initial Block()<br>Member() Member 2<br>getInt()<br>Derive()</p>
</blockquote>
<h4 id="16）true、false-与-null-是关键字吗？"><a href="#16）true、false-与-null-是关键字吗？" class="headerlink" title="16）true、false 与 null 是关键字吗？"></a>16）true、false 与 null 是关键字吗？</h4><p>答：不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。</p>
<p>面试官：那 goto 与 const 呢？</p>
<p>答：是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。</p>
<h4 id="17）exception-和-error-有什么区别？"><a href="#17）exception-和-error-有什么区别？" class="headerlink" title="17）exception 和 error 有什么区别？"></a>17）exception 和 error 有什么区别？</h4><p>答：exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。</p>
<p>exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 </p>
<h4 id="18）throw-和-throws-有什么区别？"><a href="#18）throw-和-throws-有什么区别？" class="headerlink" title="18）throw 和 throws 有什么区别？"></a>18）throw 和 throws 有什么区别？</h4><p>答：throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p>
<blockquote>
<p>小结：本节主要阐述了 Java 基础知识，并没有涉及到一些高级的特性，这些问题一般难度不大，适当复习下，应该没问题。</p>
</blockquote>
<hr>
<h2 id="（二）Java-中常见集合"><a href="#（二）Java-中常见集合" class="headerlink" title="（二）Java 中常见集合"></a>（二）Java 中常见集合</h2><p>集合这方面的考察相当多，这部分是面试中必考的知识点。</p>
<h4 id="1）说说常见的集合有哪些吧？"><a href="#1）说说常见的集合有哪些吧？" class="headerlink" title="1）说说常见的集合有哪些吧？"></a>1）说说常见的集合有哪些吧？</h4><p>答：Map接口和Collection接口是所有集合框架的父接口：</p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<h4 id="2）HashMap和Hashtable的区别有哪些？（必问）"><a href="#2）HashMap和Hashtable的区别有哪些？（必问）" class="headerlink" title="2）HashMap和Hashtable的区别有哪些？（必问）"></a>2）HashMap和Hashtable的区别有哪些？（必问）</h4><p>答：</p>
<ol>
<li><p>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</p>
</li>
<li><p>前者允许null作为Key；后者不允许null作为Key</p>
</li>
</ol>
<h4 id="3）HashMap的底层实现你知道吗？"><a href="#3）HashMap的底层实现你知道吗？" class="headerlink" title="3）HashMap的底层实现你知道吗？"></a>3）HashMap的底层实现你知道吗？</h4><p>答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-47e48966bd6fec65.png" alt=""></p>
<h4 id="4）ConcurrentHashMap-和-Hashtable-的区别？（必问）"><a href="#4）ConcurrentHashMap-和-Hashtable-的区别？（必问）" class="headerlink" title="4）ConcurrentHashMap 和 Hashtable 的区别？（必问）"></a>4）ConcurrentHashMap 和 Hashtable 的区别？（必问）</h4><p> <strong>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶。</strong></p>
<p><strong>面试官：ConcurrentHashMap的具体实现知道吗？</strong></p>
<p><strong>答：</strong></p>
<p><strong>1.  该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</strong></p>
<p><strong>2.  Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</strong></p>
<h4 id="5）HashMap-的长度为什么是2的幂次方？"><a href="#5）HashMap-的长度为什么是2的幂次方？" class="headerlink" title="5）HashMap 的长度为什么是2的幂次方？"></a>5）HashMap 的长度为什么是2的幂次方？</h4><p><strong>答：</strong></p>
<p><strong>1.  通过将 Key 的 hash 值与 length - 1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率</strong></p>
<p><strong>2.  如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</strong></p>
<h4 id="6）List和Set的区别是啥？"><a href="#6）List和Set的区别是啥？" class="headerlink" title="6）List和Set的区别是啥？"></a>6）List和Set的区别是啥？</h4><p><strong>答：List元素是有序的，可以重复；Set元素是无序的，不可以重复。</strong></p>
<h4 id="7）List、Set和Map的初始容量和加载因子："><a href="#7）List、Set和Map的初始容量和加载因子：" class="headerlink" title="7）List、Set和Map的初始容量和加载因子："></a>7）List、Set和Map的初始容量和加载因子：</h4><p><strong>答：</strong></p>
<p><strong>1. List</strong></p>
<ul>
<li><p><strong>ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。</strong></p>
</li>
<li><p><strong>Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。</strong></p>
</li>
</ul>
<p><strong>2. Set</strong></p>
<p><strong>HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32</strong></p>
<p><strong>3. Map</strong></p>
<p><strong>HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32</strong></p>
<h4 id="8）Comparable接口和Comparator接口有什么区别？"><a href="#8）Comparable接口和Comparator接口有什么区别？" class="headerlink" title="8）Comparable接口和Comparator接口有什么区别？"></a>8）Comparable接口和Comparator接口有什么区别？</h4><p><strong>答：</strong></p>
<p><strong>1.  前者简单，但是如果需要重新定义比较类型时，需要修改源代码。</strong></p>
<p><strong>2.  后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 具体解析参考博客：<a href="http://blog.csdn.net/qq_25827845/article/details/51287142" target="_blank" rel="noopener">Java集合框架—Set</a></strong></p>
<h4 id="9）Java集合的快速失败机制-“fail-fast”"><a href="#9）Java集合的快速失败机制-“fail-fast”" class="headerlink" title="9）Java集合的快速失败机制 “fail-fast”"></a>9）Java集合的快速失败机制 “fail-fast”</h4><p><strong>答：</strong></p>
<p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p>
<p><strong>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</strong></p>
<p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1.  在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p>
<p><strong>2.  使用CopyOnWriteArrayList来替换ArrayList</strong></p>
<h4 id="10）ArrayList-和-Vector-的区别"><a href="#10）ArrayList-和-Vector-的区别" class="headerlink" title="10）ArrayList 和 Vector 的区别"></a>10）ArrayList 和 Vector 的区别</h4><p>答：</p>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList 与 Vector 的区别主要包括两个方面：</p>
<ol>
<li><p>同步性：<br>Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
</li>
<li><p>数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。</p>
</li>
</ol>
<p><strong>面试官：那 ArrayList 和 LinkedList 的区别呢？</strong></p>
<p>答：</p>
<ol>
<li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；</li>
<li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li>
<li>LinkedList 比 ArrayList 需要更多的内存；</li>
</ol>
<p><strong>面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</strong></p>
<p>答：它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 </li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。 </li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 </li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h4 id="11）如何去掉一个-Vector-集合中重复的元素？"><a href="#11）如何去掉一个-Vector-集合中重复的元素？" class="headerlink" title="11）如何去掉一个 Vector 集合中重复的元素？"></a>11）如何去掉一个 Vector 集合中重复的元素？</h4><p>答：</p>
<pre class=" language-java"><code class="language-java">Vector newVector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object obj <span class="token operator">=</span> vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newVector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newVector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>还有一种简单的方式，利用了 Set 不允许重复元素的特性：</p>
<pre class=" language-java"><code class="language-java">HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。</p>
</blockquote>
<h4 id="12）如何权衡是使用无序的数组还是有序的数组？"><a href="#12）如何权衡是使用无序的数组还是有序的数组？" class="headerlink" title="12）如何权衡是使用无序的数组还是有序的数组？"></a>12）如何权衡是使用无序的数组还是有序的数组？</h4><p>答：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>oh…..复习下来还真是酸爽….前路漫漫啊….</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>
<blockquote>
<ul>
<li>前言： </li>
</ul>
</blockquote>
<p>在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650692240&idx=1&sn=dc39f07097656042344e7fee8a17259e&chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&mpshare=1&scene=23&srcid=1225zdAW9iFdJ86OiBQSr8mP#rd" target="_blank" rel="noopener">知名互联网公司校招 Java 开发岗面试知识点解析</a> ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。</p>
<hr>
<h2 id="（一）Java-基础知识点-1"><a href="#（一）Java-基础知识点-1" class="headerlink" title="（一）Java 基础知识点"></a>（一）Java 基础知识点</h2><h4 id="1）面向对象的特性有哪些？-1"><a href="#1）面向对象的特性有哪些？-1" class="headerlink" title="1）面向对象的特性有哪些？"></a>1）面向对象的特性有哪些？</h4><p>答：封装、继承和多态<em>（应要多算一个那就是抽象）</em></p>
<ul>
<li><p><strong>封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。</strong><br>但封装不仅仅是 private + getter/setter ，使用封装可以对 setter 进行更深层次的定制，例如你可以对执行方法的对象做规定，也可以对数据做一定的要求，还可以做类型转换等等。<strong>使用封装不仅仅安全，更可以简化操作。</strong>（封装扩展阅读：<a href="https://zhuanlan.zhihu.com/p/20174473" target="_blank" rel="noopener">oc面向对象三大特性之一 &lt;封装&gt;</a>）</p>
</li>
<li><p><strong>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。</strong><br>继承的缺点：<strong>1）</strong>继承是一种强耦合关系，父类变子类也必须变；<strong>2）</strong>继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。</p>
</li>
<li><p><strong>多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。</strong><br>比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。</p>
</li>
</ul>
<p><strong>多态的条件</strong>：<strong>1）</strong>继承；<strong>2）</strong>重写；<strong>3）</strong>向上转型。<br><strong>多态的好处</strong>：当把不同的子类对象都当作父类类型来看，<strong>可以屏蔽不同子类对象之间的实现差异，</strong>从而写出通用的代码达到通用编程，以适应需求的不断变化。（多态扩展阅读：<a href="https://www.jianshu.com/p/5771df145452" target="_blank" rel="noopener">重新认识java（五） —- 面向对象之多态（向上转型与向下转型）</a>）</p>
<ul>
<li><strong>抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。</strong></li>
</ul>
<h4 id="2）面向对象和面向过程的区别？-1"><a href="#2）面向对象和面向过程的区别？-1" class="headerlink" title="2）面向对象和面向过程的区别？"></a>2）面向对象和面向过程的区别？</h4><p>答：面向过程是<strong>一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程</strong>，即先干啥，后干啥。</p>
<p>面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-e6027912a8d8c7b6.png" alt=""></p>
<ul>
<li><strong>面向过程的缺陷：</strong><br>向过程的设计,是<strong>采用置顶而下的设计方式</strong>，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</li>
<li><strong>问题：</strong>1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。</li>
</ul>
<p>面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出<strong>面向对象</strong>思想。</p>
<p>面向对象是一种基于面向过程的新的编程思想，是<strong>一种站在对象的角度思考问题</strong>的思想，我们把多个功能合理的放到不同对象里，<strong>强调的是具备某些功能的对象。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-521c9e98caea7217.png" alt=""></p>
<ul>
<li>面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</li>
<li><strong>注意：</strong> 不要粗浅的认为面向对象一定就优于面向过程的设计</li>
</ul>
<blockquote>
<p>看到知乎上有一句有意思的话：</p>
<p>你的程序要完成一个任务，相当于讲一个故事。</p>
<p>面向过程：编年体；<br>面向对象：纪传体。</p>
<p>而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。</p>
</blockquote>
<p>扩展阅读：<a href="https://zhuanlan.zhihu.com/p/28427324" target="_blank" rel="noopener">面向过程 VS 面向对象</a></p>
<h4 id="3）JDK-和-JRE-的区别是什么？-1"><a href="#3）JDK-和-JRE-的区别是什么？-1" class="headerlink" title="3）JDK 和 JRE 的区别是什么？"></a>3）JDK 和 JRE 的区别是什么？</h4><p>解析：这是考察一些基本的概念</p>
<p>答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 </p>
<p>Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。</p>
<blockquote>
<ul>
<li>还有其他的一些名词也可以再看一下：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-8672d90bb496f196.png" alt=""></p>
</blockquote>
<h4 id="4）Java-中覆盖和重载是什么意思？-1"><a href="#4）Java-中覆盖和重载是什么意思？-1" class="headerlink" title="4）Java 中覆盖和重载是什么意思？"></a>4）Java 中覆盖和重载是什么意思？</h4><p>解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。</p>
<p>答：<strong>覆盖（Override）是指子类对父类方法的一种重写，</strong>只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。</p>
<p><strong>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</strong></p>
<p>面试官： 那么构成重载的条件有哪些？</p>
<p>答：参数类型不同、参数个数不同、参数顺序不同。</p>
<p>面试官： 函数的返回值不同可以构成重载吗？为什么？</p>
<p>答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下：</p>
<p>如下两个方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>
<p>只要编译器可以根据语境明确判断出语义，比如在 <code>int x = f();</code> 中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用” ），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用：</p>
<pre class=" language-java"><code class="language-java"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>此时 Java 如何才能判断调用的是哪一个 <code>f()</code> 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。</p>
<h4 id="5）抽象类和接口的区别有哪些？-1"><a href="#5）抽象类和接口的区别有哪些？-1" class="headerlink" title="5）抽象类和接口的区别有哪些？"></a>5）抽象类和接口的区别有哪些？</h4><p>答：</p>
<ol>
<li>抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；</li>
<li>抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。</li>
<li>抽象类只能单继承，接口可以继承多个父接口；</li>
<li>Java 8 中接口中会有 default 方法，即方法可以被实现。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-dc431887834333f7.png" alt=""></p>
<p><strong>面试官：抽象类和接口如何选择？</strong></p>
<p>答：</p>
<ol>
<li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p>
</li>
<li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p>
</li>
</ol>
<h4 id="6）Java-和-C-的区别：-1"><a href="#6）Java-和-C-的区别：-1" class="headerlink" title="6）Java 和 C++ 的区别："></a>6）Java 和 C++ 的区别：</h4><p>解析：虽然我们不太懂C++，但是就是会这么问，尤其是三面（总监级别）面试中。</p>
<p>答：</p>
<ol>
<li><p>都是面向对象的语言，都支持封装、继承和多态</p>
</li>
<li><p>指针：Java不提供指针来直接访问内存，程序更加安全</p>
</li>
<li><p>继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承</p>
</li>
<li><p>内存： Java有自动内存管理机制，不需要程序员手动释放无用内存</p>
</li>
</ol>
<h4 id="7）“static”-关键字是什么意思？-1"><a href="#7）“static”-关键字是什么意思？-1" class="headerlink" title="7）“static” 关键字是什么意思？"></a>7）“static” 关键字是什么意思？</h4><p>答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p>
<p>面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？</p>
<p>答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 </p>
<p>Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</p>
<p>扩展阅读：<a href="https://www.jianshu.com/p/3eb769986bd3" target="_blank" rel="noopener">重新认识java（六） —- java中的另类：static关键字（附代码块知识）</a></p>
<h4 id="8）Java-是值传递还是引用传递？-1"><a href="#8）Java-是值传递还是引用传递？-1" class="headerlink" title="8）Java 是值传递还是引用传递？"></a>8）Java 是值传递还是引用传递？</h4><p>解析：这类题目，面试官会手写一个例子，让你说出函数执行结果。</p>
<p>答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 </p>
<p>一般认为，Java 内的传递都是值传递.，Java 中实例对象的传递是引用传递，Java 是值传递的！</p>
<blockquote>
<ul>
<li>我们先来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-89340c032fb5b240.png" alt=""></p>
<p>这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？</p>
<p>这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。</p>
<blockquote>
<ul>
<li>再来看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-75c3162752d36403.png" alt=""></p>
<p>我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？</p>
<p>你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！</p>
<h4 id="9）JDK-中常用的包有哪些？-1"><a href="#9）JDK-中常用的包有哪些？-1" class="headerlink" title="9）JDK 中常用的包有哪些？"></a>9）JDK 中常用的包有哪些？</h4><p>答：java.lang、java.util、java.io、java.net、java.sql。</p>
<h4 id="10）JDK，JRE-和-JVM-的联系和区别？-1"><a href="#10）JDK，JRE-和-JVM-的联系和区别？-1" class="headerlink" title="10）JDK，JRE 和 JVM 的联系和区别？"></a>10）JDK，JRE 和 JVM 的联系和区别？</h4><p>答：JDK 是 Java 开发工具包，是 Java 开发环境的核心组件，并提供编译、调试和运行一个 Java 程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。</p>
<p>JRE 是 Java 运行时环境，是 JVM 的实施实现，提供了运行 Java 程序的平台。JRE 包含了 JVM，但是不包含 Java 编译器 / 调试器之类的开发工具。</p>
<p>JVM 是 Java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。</p>
<p>这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因。</p>
<p>区别：</p>
<p>&emsp;&emsp;1. JDK 用于开发，JRE 用于运行 Java 程序；<br>&emsp;&emsp;2. JDK 和 JRE 中都包含 JVM；<br>&emsp;&emsp;3. JVM 是 Java 编程语言的核心并且具有平台独立性。</p>
<h4 id="11）Integer-的缓存机制-1"><a href="#11）Integer-的缓存机制-1" class="headerlink" title="11）Integer 的缓存机制"></a>11）Integer 的缓存机制</h4><p>解析：考察的是对源码的熟悉程度</p>
<blockquote>
<ul>
<li>看一个例子：</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-90331ba04ebe13fc.png" alt=""></p>
<blockquote>
<p>第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。</p>
<p>第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。</p>
<p>第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。</p>
</blockquote>
<p>我们可以跟踪一下Integer的源码，看看到底怎么回事。在IDEA中，你只需要按住Ctrl然后点击Integer，就会自动进入jar包中对应的类文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-bd248da68e02bb2e.png" alt=""></p>
<p>跟踪到文件的700多行，你会看到这么一段，感兴趣可以仔细读一下，不用去读也没有关系，因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。（事实上，Integer类的缓存上限是可以通过修改系统来更改的，了解就行了，不必去深究。）</p>
<h4 id="12）下述两种方法分别创建了几个-Sring-对象？-1"><a href="#12）下述两种方法分别创建了几个-Sring-对象？-1" class="headerlink" title="12）下述两种方法分别创建了几个 Sring 对象？"></a>12）下述两种方法分别创建了几个 Sring 对象？</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第一种：直接赋一个字面量</span>
String str1 <span class="token operator">=</span> <span class="token string">"ABCD"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 第二种：通过构造器创建</span>
String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ABCD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>解析：考察的是对 String 对象和 JVM 内存划分的知识。</p>
<p>答：<code>String str1 = &quot;ABCD&quot;;</code>最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用.</p>
<p><code>String str2 = new String(&quot;ABCD&quot;);</code>最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。</p>
<blockquote>
<p>我们来看图理解一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-70af9f49c51c9902.png" alt=""></p>
</blockquote>
<ul>
<li>当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD</li>
<li>当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。</li>
</ul>
<p>String 对象是一个特殊的存在，需要注意的知识点也比较多，这里给一个之前写的 String 详解的文章链接：<a href="https://www.jianshu.com/p/e494552f2cf0" target="_blank" rel="noopener">传送门</a> 其中包含的问题大概有：<strong>1）“+” 怎么连接字符串；2）字符串的比较；3）StringBuilder/StringBuffer/String 的区别；</strong></p>
<h4 id="13）i-与-i-到底有什么不同？-1"><a href="#13）i-与-i-到底有什么不同？-1" class="headerlink" title="13）i++ 与 ++i 到底有什么不同？"></a>13）i++ 与 ++i 到底有什么不同？</h4><p>解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，<strong>前置++和后置++一样，在参与运算之前都会将变量的值加 1</strong></p>
<p>答：实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。<strong>二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-4c68b98e2d0f4d2a.png" alt=""></p>
<h4 id="14）交换变量的三种方式-1"><a href="#14）交换变量的三种方式-1" class="headerlink" title="14）交换变量的三种方式"></a>14）交换变量的三种方式</h4><p>答：</p>
<blockquote>
<ul>
<li>第一种：通过第三个变量</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Value v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 无效的交换：形参的改变无法反作用于实参</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>
        x <span class="token operator">=</span> y<span class="token punctuation">;</span>
        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 有效的交换：通过引用（变量指向一个对象）来修改成员变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> value<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>x <span class="token operator">=</span> value<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        value<span class="token punctuation">.</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Value</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>5<br>10<br>10<br>5</p>
</blockquote>
<p>这有点类似于C/C++语言中的指针，不过相对来说更加安全。</p>
<p>事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。</p>
<blockquote>
<p>第二种：通过通过相加的方式（相同的 Value 类不再重复展示）</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1的交换结果：<br>10<br>5</p>
</blockquote>
<p>核心的算法就是swap方法:</p>
<pre class=" language-java"><code class="language-java">v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在v.x中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y本来的值即为v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// v.x减掉v.y的值也就是以前x.y的值</span></code></pre>
<p>这样就可以不通过临时变量，来达到交换两个变量的目的，如果觉得上面的方法不太容易理解，我们也可以用另一个参数z来表示上述过程：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> z <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">+</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把v.x与v.y的和存储在z中</span>
v<span class="token punctuation">.</span>y <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉以前的v.y就等于v.x</span>
v<span class="token punctuation">.</span>x <span class="token operator">=</span> z <span class="token operator">-</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// z减掉现在的v.y即以前的v.x，即为v.y</span></code></pre>
<p>但并<strong>不推荐这种做法</strong>，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。</p>
<blockquote>
<ul>
<li>第三种：通过异或的方式：</li>
</ul>
</blockquote>
<p>位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：<br><code>（x ^ y ^ y） == x</code>这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Value v1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v1交换之后的结果为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Value v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>y <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span>x <span class="token operator">=</span> v<span class="token punctuation">.</span>x <span class="token operator">^</span> v<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>输出的结果：<br>v1交换之后的结果为：<br>10<br>5</p>
</blockquote>
<p>跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。<strong>异或的方法比相加更加可取的地方在于，异或不存在数据溢出。</strong></p>
<h4 id="15）Java-对象初始化顺序？-1"><a href="#15）Java-对象初始化顺序？-1" class="headerlink" title="15）Java 对象初始化顺序？"></a>15）Java 对象初始化顺序？</h4><p>答：不考虑静态成员的初始化，调用一个对象的构造函数时，程序<strong>先调用父类的构造函数</strong>（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），<strong>之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行</strong>，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；<strong>最后调用自身构造函数。</strong></p>
<blockquote>
<ul>
<li>我们可以写一段程序来对初始化顺序进行一个简单的验证：</li>
</ul>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> Member m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Initial Block()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Derive()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> Member m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Member</span><span class="token punctuation">(</span><span class="token string">"Member 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getInt()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Base()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Member</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Member</span><span class="token punctuation">(</span>String m<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Member() "</span><span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>程序的输出结果是：<br>Base()<br>Member() Member 1<br>Initial Block()<br>Member() Member 2<br>getInt()<br>Derive()</p>
</blockquote>
<h4 id="16）true、false-与-null-是关键字吗？-1"><a href="#16）true、false-与-null-是关键字吗？-1" class="headerlink" title="16）true、false 与 null 是关键字吗？"></a>16）true、false 与 null 是关键字吗？</h4><p>答：不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。</p>
<p>面试官：那 goto 与 const 呢？</p>
<p>答：是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。</p>
<h4 id="17）exception-和-error-有什么区别？-1"><a href="#17）exception-和-error-有什么区别？-1" class="headerlink" title="17）exception 和 error 有什么区别？"></a>17）exception 和 error 有什么区别？</h4><p>答：exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。</p>
<p>exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 </p>
<h4 id="18）throw-和-throws-有什么区别？-1"><a href="#18）throw-和-throws-有什么区别？-1" class="headerlink" title="18）throw 和 throws 有什么区别？"></a>18）throw 和 throws 有什么区别？</h4><p>答：throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p>
<blockquote>
<p>小结：本节主要阐述了 Java 基础知识，并没有涉及到一些高级的特性，这些问题一般难度不大，适当复习下，应该没问题。</p>
</blockquote>
<hr>
<h2 id="（二）Java-中常见集合-1"><a href="#（二）Java-中常见集合-1" class="headerlink" title="（二）Java 中常见集合"></a>（二）Java 中常见集合</h2><p>集合这方面的考察相当多，这部分是面试中必考的知识点。</p>
<h4 id="1）说说常见的集合有哪些吧？-1"><a href="#1）说说常见的集合有哪些吧？-1" class="headerlink" title="1）说说常见的集合有哪些吧？"></a>1）说说常见的集合有哪些吧？</h4><p>答：Map接口和Collection接口是所有集合框架的父接口：</p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<h4 id="2）HashMap和Hashtable的区别有哪些？（必问）-1"><a href="#2）HashMap和Hashtable的区别有哪些？（必问）-1" class="headerlink" title="2）HashMap和Hashtable的区别有哪些？（必问）"></a>2）HashMap和Hashtable的区别有哪些？（必问）</h4><p>答：</p>
<ol>
<li><p>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</p>
</li>
<li><p>前者允许null作为Key；后者不允许null作为Key</p>
</li>
</ol>
<h4 id="3）HashMap的底层实现你知道吗？-1"><a href="#3）HashMap的底层实现你知道吗？-1" class="headerlink" title="3）HashMap的底层实现你知道吗？"></a>3）HashMap的底层实现你知道吗？</h4><p>答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/7896890-47e48966bd6fec65.png" alt=""></p>
<h4 id="4）ConcurrentHashMap-和-Hashtable-的区别？（必问）-1"><a href="#4）ConcurrentHashMap-和-Hashtable-的区别？（必问）-1" class="headerlink" title="4）ConcurrentHashMap 和 Hashtable 的区别？（必问）"></a>4）ConcurrentHashMap 和 Hashtable 的区别？（必问）</h4><p> <strong>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶。</strong></p>
<p><strong>面试官：ConcurrentHashMap的具体实现知道吗？</strong></p>
<p><strong>答：</strong></p>
<p><strong>1.  该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</strong></p>
<p><strong>2.  Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</strong></p>
<h4 id="5）HashMap-的长度为什么是2的幂次方？-1"><a href="#5）HashMap-的长度为什么是2的幂次方？-1" class="headerlink" title="5）HashMap 的长度为什么是2的幂次方？"></a>5）HashMap 的长度为什么是2的幂次方？</h4><p><strong>答：</strong></p>
<p><strong>1.  通过将 Key 的 hash 值与 length - 1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率</strong></p>
<p><strong>2.  如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</strong></p>
<h4 id="6）List和Set的区别是啥？-1"><a href="#6）List和Set的区别是啥？-1" class="headerlink" title="6）List和Set的区别是啥？"></a>6）List和Set的区别是啥？</h4><p><strong>答：List元素是有序的，可以重复；Set元素是无序的，不可以重复。</strong></p>
<h4 id="7）List、Set和Map的初始容量和加载因子：-1"><a href="#7）List、Set和Map的初始容量和加载因子：-1" class="headerlink" title="7）List、Set和Map的初始容量和加载因子："></a>7）List、Set和Map的初始容量和加载因子：</h4><p><strong>答：</strong></p>
<p><strong>1. List</strong></p>
<ul>
<li><p><strong>ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。</strong></p>
</li>
<li><p><strong>Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。</strong></p>
</li>
</ul>
<p><strong>2. Set</strong></p>
<p><strong>HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32</strong></p>
<p><strong>3. Map</strong></p>
<p><strong>HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32</strong></p>
<h4 id="8）Comparable接口和Comparator接口有什么区别？-1"><a href="#8）Comparable接口和Comparator接口有什么区别？-1" class="headerlink" title="8）Comparable接口和Comparator接口有什么区别？"></a>8）Comparable接口和Comparator接口有什么区别？</h4><p><strong>答：</strong></p>
<p><strong>1.  前者简单，但是如果需要重新定义比较类型时，需要修改源代码。</strong></p>
<p><strong>2.  后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。 具体解析参考博客：<a href="http://blog.csdn.net/qq_25827845/article/details/51287142" target="_blank" rel="noopener">Java集合框架—Set</a></strong></p>
<h4 id="9）Java集合的快速失败机制-“fail-fast”-1"><a href="#9）Java集合的快速失败机制-“fail-fast”-1" class="headerlink" title="9）Java集合的快速失败机制 “fail-fast”"></a>9）Java集合的快速失败机制 “fail-fast”</h4><p><strong>答：</strong></p>
<p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p>
<p><strong>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</strong></p>
<p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1.  在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p>
<p><strong>2.  使用CopyOnWriteArrayList来替换ArrayList</strong></p>
<h4 id="10）ArrayList-和-Vector-的区别-1"><a href="#10）ArrayList-和-Vector-的区别-1" class="headerlink" title="10）ArrayList 和 Vector 的区别"></a>10）ArrayList 和 Vector 的区别</h4><p>答：</p>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList 与 Vector 的区别主要包括两个方面：</p>
<ol>
<li><p>同步性：<br>Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
</li>
<li><p>数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。</p>
</li>
</ol>
<p><strong>面试官：那 ArrayList 和 LinkedList 的区别呢？</strong></p>
<p>答：</p>
<ol>
<li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；</li>
<li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li>
<li>LinkedList 比 ArrayList 需要更多的内存；</li>
</ol>
<p><strong>面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</strong></p>
<p>答：它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 </li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。 </li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 </li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h4 id="11）如何去掉一个-Vector-集合中重复的元素？-1"><a href="#11）如何去掉一个-Vector-集合中重复的元素？-1" class="headerlink" title="11）如何去掉一个 Vector 集合中重复的元素？"></a>11）如何去掉一个 Vector 集合中重复的元素？</h4><p>答：</p>
<pre class=" language-java"><code class="language-java">Vector newVector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object obj <span class="token operator">=</span> vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newVector<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newVector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>还有一种简单的方式，利用了 Set 不允许重复元素的特性：</p>
<pre class=" language-java"><code class="language-java">HashSet set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>小结：本小节是 Java 中关于集合的考察，是 Java 岗位面试中必考的知识点，除了应该掌握以上的问题，包括各个集合的底层实现也建议各位同学阅读，加深理解。</p>
</blockquote>
<h4 id="12）如何权衡是使用无序的数组还是有序的数组？-1"><a href="#12）如何权衡是使用无序的数组还是有序的数组？-1" class="headerlink" title="12）如何权衡是使用无序的数组还是有序的数组？"></a>12）如何权衡是使用无序的数组还是有序的数组？</h4><p>答：有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p>
<hr>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>oh…..复习下来还真是酸爽….前路漫漫啊….</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/tags/%E5%8E%9F%E5%88%9B/page/13/">
            <section class="post prev white-box shadow" >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          14 / 21
        </p>
        
          <a class="next" rel="next" href="/tags/%E5%8E%9F%E5%88%9B/page/15/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" href="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"
            id="categoriesE78988E69CACE789B9E680A7"
            ><div class='name'>版本特性</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" href="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/"
            id="categoriesE79FA5E4B98EE997AEE7AD94"
            ><div class='name'>知乎问答</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.67px; color: #878787">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.33px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.67px; color: #5e5e5e">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 22px; color: #636363">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.67px; color: #6c6c6c">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.33px; color: #909090">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 20px; color: #707070">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.67px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.67px; color: #878787">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.33px; color: #828282">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.33px; color: #676767">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.67px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.33px; color: #909090">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16px; color: #8b8b8b">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.67px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.33px; color: #909090">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.33px; color: #828282">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.67px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.67px; color: #797979">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.67px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16px; color: #8b8b8b">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" style="font-size: 18px; color: #7e7e7e">版本特性</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" style="font-size: 14px; color: #999">知乎问答</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.67px; color: #878787">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.33px; color: #676767">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19.33px; color: #757575">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
