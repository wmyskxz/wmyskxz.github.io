<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>标签：Java基础 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/08/07/morethanjava-day-5-mian-xiang-dui-xiang-jin-jie-ji-cheng-xiang-jie/">
      「MoreThanJava」Day 5：面向对象进阶——继承详解
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年8月7日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/e973d387-618a-46bd-abe5-bce322f54a72.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="Part-1-继承概述"><a href="#Part-1-继承概述" class="headerlink" title="Part 1. 继承概述"></a>Part 1. 继承概述</h1><p><a href="https://www.wmyskxz.com/2020/08/04/morethanjava-day-4-mian-xiang-dui-xiang-ji-chu/">上一篇文章</a> 中我们简单介绍了继承的作用，它允许创建 <strong>具有逻辑等级结构的类体系</strong>，形成一个继承树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/35b85013-1566-4442-a093-67dc71ec7774.png" alt="Animal 继承树"></p>
<p>继承使您可以基于现有类定义新类。 新类与现有类相似，但是可能具有其他实例变量和方法。这使编程更加容易，因为您可以 <strong>在现有的类上构建</strong>，而不必从头开始。</p>
<p>继承是现代软件取得巨大成功的部分原因。 程序员能够在先前的工作基础上继续发展并不断改进和升级现有软件。</p>
<h2 id="面向对象之前，写代码的一些问题"><a href="#面向对象之前，写代码的一些问题" class="headerlink" title="面向对象之前，写代码的一些问题"></a>面向对象之前，写代码的一些问题</h2><p>如果你有一个类的源代码，你可以复制代码并改变它变成你想要的样子。在面向对象编程之前，就是这样子做的。但至少有两个问题：</p>
<p><strong>❶ 很难保持仅仅有条。</strong></p>
<p>假设您已经有了几十个需要的类，并且需要基于原始类创造新的一些类，再基于新的类创造出更新的类，最终您将获得数十个源文件，这些源文件都是通过其他已更改的源文件的另外版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/a7feeb86-9d37-406f-8aba-b9f395b437f7.png" alt=""></p>
<p>假设现在在一个源文件中发现了错误，一些基于它的源文件需要进行修复，但是对于其他源文件来说，并不需要！没有细致的写代码的计划，您最终会陷入混乱….</p>
<p><strong>❷ 需要学习原始代码。</strong></p>
<p>假设您有一个复杂的类，基本上可以完成所需的工作，但是您需要进行一些小的修改。如果您修改了源代码，即使是进行了很小的更改，也可能会破坏某些内容。因此，您必须研究原始代码以确保所做的更改正确，这可能并不容易。</p>
<p><strong>Java 的自动继承机制极大地缓解了这两个问题。</strong></p>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>用于作为新类模板的类称为 <strong>父类</strong> <em>(或超类或基类)</em>，基于父类创建的类称为 <strong>子类</strong> <em>(或派生类)</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/1744fdbf-cae1-4460-b4d9-0e48f00034eb.png" alt=""></p>
<p>就像上图中演示的那样，箭头从子类指向父类。<em>(在上图中，云表示类，而矩形表示对象，这样的表示的方法来自于 Grady Booch 写的《面向对象的分析和设计》一书。而在官方的 UML-统一建模语言 中，类和对象都用矩形表示，请注意这一点)</em></p>
<p>在 Java 中，<strong>子类仅从一个父类继承特征</strong>，这被称为 <strong>单继承</strong> <em>(与人类不同)</em>。</p>
<p>有些语言允许”孩子”从多个”父母”那里继承，这被称为 <strong>多继承</strong>。但由于具有多重继承，有时很难说出哪个父母为孩子贡献了哪些特征 <em>(跟人类一样..)</em>。</p>
<p>Java 通过使用单继承避免了这些问题。<em>(意思 Java 只允许单继承)</em></p>
<h2 id="is-a-关系"><a href="#is-a-关系" class="headerlink" title="is-a 关系"></a>is-a 关系</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/2fed3fa5-88ee-460c-b839-e6bc9be6c551.png" alt=""></p>
<p>上图显示了一个父类 <em>(Video 视频类)</em>，一个子类 <em>(Movie 电影类)</em>。它们之间的实线表示 <strong>“is-a”</strong> 的关系：电影是视频。 </p>
<p><strong>注意，继承是在类之间，而不是在对象之间。</strong> <em>(上图两朵云都代表类)</em></p>
<p>父类是构造对象时使用的蓝图，子类用于构造看起来像父对象的对象，但具有附加功能的对象。</p>
<h3 id="类之间的关系简述"><a href="#类之间的关系简述" class="headerlink" title="类之间的关系简述"></a>类之间的关系简述</h3><p>简单地说，类和类之间的关系有三种：<code>is-a</code>、<code>has-a</code> 和 <code>use-a</code>。</p>
<ul>
<li><strong><code>is-a</code> 关系也叫继承或泛化</strong>，比如学生和人的关系、手机和电子产品的关系都属于继承关系；</li>
<li><strong><code>has-a</code> 关系通常称之为关联</strong>，比如部门和员工的关系、汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为 <strong>聚合关系</strong>；如果整体进一步负责了部分的生命周期 <em>(整体和部分是不可分割的，同时同在也同时消亡)</em>，那么这种就是最强的关联关系，我们称之为 <strong>合成</strong> 关系。</li>
<li><strong><code>use-a</code> 关系通常称之为依赖</strong>，比如司机有一个驾驶的行为 <em>(方法)*，其中 *(的参数)</em> 使用到了汽车，那么司机和汽车的关系就是依赖关系。</li>
</ul>
<p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p>
<h2 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/5f02652b-1840-4faf-a18b-ba3b5455663d.png" alt=""></p>
<p>上图显示了一个父类和一个子类的 <strong>层次结构</strong>，以及从每个类构造的一些对象。这些对象用矩形表示，以表达它们比设计的类更真实。</p>
<p>在层次结构中，每个类最多有一个父类，但可能有几个子类。 层次结构顶部的类没有父级。此类称为层次结构的 <strong>根</strong>。</p>
<p>另外，一个类可以是另一个子类的父类，也可以是父类的子类。就像人类一样，一个人是某些人类的孩子，也是其他人类的父母。<em>(但在 Java 中，一个孩子只有一个父母)</em></p>
<h1 id="Part-2-继承的实现"><a href="#Part-2-继承的实现" class="headerlink" title="Part 2. 继承的实现"></a>Part 2. 继承的实现</h1><p>从父类派生子类的语法是使用 <code>extend</code> 关键字：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ChildClass</span> extend ParentClass <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 子类的新成员和构造函数....</span>
<span class="token punctuation">}</span></code></pre>
<p>父类的成员 <em>(变量和方法</em>) 通过继承包含在子类中。其他成员将在其类定义中添加到子类。</p>
<h2 id="视频观影-App-示例"><a href="#视频观影-App-示例" class="headerlink" title="视频观影 App 示例"></a>视频观影 App 示例</h2><p>Java 编程是通过创建类层次结构并从中实例化对象来完成的。您可以扩展自己的类或扩展已经存在的类。Java 开发工具包 <em>(JDK)</em> 为您提供了丰富的基类集合，您可以根据需要扩展这些基类。</p>
<p><em>(如果某些类已经使用 <code>final</code> 修饰，则无法继承)</em></p>
<p>下面演示了一个使用 <code>Video</code> 类作为基类的视频观影 App 的程序设计：</p>
<p><strong>Video 基类：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// name of video</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// number of minutes</span>

    <span class="token comment" spellcheck="true">// constructor</span>
    <span class="token keyword">public</span> <span class="token function">Video</span><span class="token punctuation">(</span>String title<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"title="</span> <span class="token operator">+</span> title <span class="token operator">+</span> <span class="token string">", length="</span> <span class="token operator">+</span> length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> title<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTitle</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLength</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>Movie 电影类继承 Video：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token keyword">extends</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String director<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// name of the director</span>
    <span class="token keyword">private</span> String rating<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// num of rating</span>

    <span class="token comment" spellcheck="true">// constructor</span>
    <span class="token keyword">public</span> <span class="token function">Movie</span><span class="token punctuation">(</span>String title<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> String director<span class="token punctuation">,</span> String rating<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>director <span class="token operator">=</span> director<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>rating <span class="token operator">=</span> rating<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getDirector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> director<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> String <span class="token function">getRating</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rating<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这两个类均已定义：Video 类可用于构造视频类型的对象，现在 Movie 类可用于构造电影类型的对象。</p>
<p>Movie 类具有在 Video 中定义的成员变量和公共方法。</p>
<h2 id="使用父类的构造函数"><a href="#使用父类的构造函数" class="headerlink" title="使用父类的构造函数"></a>使用父类的构造函数</h2><p>查看上方的示例，在 Movie 类的初始化构造函数中有一条 <code>super(title, length);</code> 的语句，是 <strong>“调用父类 Video 中带有 title、length 参数的构造器”</strong> 的简写形式。</p>
<p>由于 Movie 类的构造器不能访问 Video 类的私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的 <code>super</code> 语法调用这个构造器。</p>
<p><strong>重要说明：<code>super()</code> 必须是子类构造函数中的第一条语句。</strong> <em>(这意味子类构造器总是会先调用父类的构造器)</em> 这件事经常被忽略，导致的结果就是一些神秘的编译器错误消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/f19c167d-a96e-43b4-abc1-15106fe6cdf2.png" alt=""></p>
<p>如果子类的构造器没有显式地调用父类的构造器，将自动地调用父类的无参构造器。如果父类没有无参数的构造器，并且在子类的构造器中又没有显式地调用父类的其他构造器，Java 编译器就会报告一个错误。<em>(在我们的例子中 Video 缺少无参数的构造函数，故👆上面图片代码会报错)</em></p>
<h2 id="创建一个无参构造函数"><a href="#创建一个无参构造函数" class="headerlink" title="创建一个无参构造函数"></a>创建一个无参构造函数</h2><p>关于构造函数的一些细节：</p>
<ol>
<li>您可以显式为类编写无参数的构造函数。</li>
<li>如果您没有为类编写任何构造函数，那么将自动提供无参数构造函数 <em>（称为默认构造函数）</em>。</li>
<li>如果为一个类编写了一个构造函数，则不会自动提供默认的构造函数。</li>
<li>因此：如果您为类编写了额外的构造函数，那么，则还必须编写一个无参数构造函数 <em>(供子类调用)</em>。</li>
</ol>
<p>在示例程序中，类 Video 包含构造函数，因此不会自动提供默认构造函数。 所以，Movie 类 <code>super()</code> 函数建议默认使用的构造函数 <em>(会自动调用无参数构造函数)</em> 会导致语法错误。</p>
<p>解决方法是将无参数构造函数显式放在类中 Video ，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// name of video</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// number of minutes</span>

    <span class="token comment" spellcheck="true">// no-argument constructor</span>
    <span class="token keyword">public</span> <span class="token function">Video</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// constructor</span>
    <span class="token keyword">public</span> <span class="token function">Video</span><span class="token punctuation">(</span>String title<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>让我们来实例化 Movie 对象：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tester</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Video video <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Video</span><span class="token punctuation">(</span><span class="token string">"视频1"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Movie movie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Movie</span><span class="token punctuation">(</span><span class="token string">"悟空传"</span><span class="token punctuation">,</span> <span class="token number">139</span><span class="token punctuation">,</span> <span class="token string">"郭子健"</span><span class="token punctuation">,</span> <span class="token string">"5.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>video<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>movie<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>程序输出：</strong></p>
<pre class=" language-text"><code class="language-text">title=视频1, length=90
title=悟空传, length=139</code></pre>
<p><code>movie.toString()</code> 是 Movie 类直接继承自 Video 类，它并没有使用 Movie 对象具有的新变量，因此并不会打印导演和评分。</p>
<p>我们需要给 Movie 类添加新的 <code>toString()</code> 的使用方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 添加到 Movie 类中</span>
<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"title:"</span> <span class="token operator">+</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", length:"</span> <span class="token operator">+</span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", director:"</span> <span class="token operator">+</span> <span class="token function">getDirector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">+</span> <span class="token string">", rating:"</span> <span class="token operator">+</span> <span class="token function">getRating</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>现在，Movie 拥有了自己的 <code>toString()</code> 方法，该方法使用了继承自 Video 的变量和自己定义的变量。</p>
<p>即使父类有一个 <code>toString()</code> 方法，子类中新定义的 <code>toString()</code> 也会 <strong>覆盖</strong> 父类的版本。当子类方法的 <strong>签名</strong> <em>(就是返回值 + 方法名称 + 参数列表)</em> 与父类相同时，子类的方法就会 <strong>覆盖</strong> 父类的方法。</p>
<p>现在运行程序，Movie 打印出了我们期望的完整信息：</p>
<pre class=" language-text"><code class="language-text">title=视频1, length=90
title:悟空传, length:139, director:郭子健, rating:5.9</code></pre>
<blockquote>
<p>有些人认为 <code>super</code> 与 <code>this</code> 引用是类似的概念，实际上，这样比较并不太恰当。这是因为 <code>super</code> 不是一个对象的引用，例如，不能将值 <code>super</code> 赋给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。</p>
</blockquote>
<p>正像前面所看到的那样，在子类中可以增加字段、增加方法或覆盖父类的方法，不过，继承绝对不会删除任何字段或方法。</p>
<h1 id="Part-3-更多细节"><a href="#Part-3-更多细节" class="headerlink" title="Part 3. 更多细节"></a>Part 3. 更多细节</h1><h2 id="protected-关键字"><a href="#protected-关键字" class="headerlink" title="protected 关键字"></a>protected 关键字</h2><p>如果类中创建的变量或者方法使用 <code>protected</code> 描述，则指明了 “就类用户而言，这是 <code>private</code> 的，但对于任何继承于此类的导出类或者任何位于同一个 <strong>包</strong> 内的类来说，它是可以访问的”。下面我们就上面的例子来演示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> String title<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// name of video</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> length<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// number of minutes</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token keyword">extends</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"title:"</span> <span class="token operator">+</span> title <span class="token operator">+</span> <span class="token string">", length:"</span> <span class="token operator">+</span> length <span class="token operator">+</span> <span class="token string">", director:"</span> <span class="token operator">+</span> director
            <span class="token operator">+</span> <span class="token string">", rating:"</span> <span class="token operator">+</span> rating<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>在 <code>protected</code> 修饰之前，如果子类 Movie 要访问父类 Video 的 <code>title</code> 私有变量只能通过父类暴露出来的 <code>getTitle()</code> 公共方法，现在则可以直接使用。</p>
<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>“为新的类提供方法” 并不是继承技术中最重要的方面，<strong>其最重要的方面是用来表现新类和基类之间的关系</strong>。这种关系可以用 <strong>“新类是现有类的一种类型”</strong> 这句话加以概括。</p>
<p>由于继承可以确保基类中所有的方法在子类中也同样有效，所以能够向基类发送的所有信息也同样可以向子类发送。例如，如果 Video 类具有一个 <code>play()</code> 方法， 那么 Movie 类也将同样具备。这意味着我们可以准确地说 <strong>Movie 对象也是一种类型的 Video</strong>。<em>(体现 <code>is-a</code> 关系)</em></p>
<p>这一概念的体现用下面的例子来说明：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>Video video<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...</span>
        video<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 测试类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tester</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Movie movie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Movie</span><span class="token punctuation">(</span><span class="token string">"悟空传"</span><span class="token punctuation">,</span> <span class="token number">139</span><span class="token punctuation">,</span> <span class="token string">"郭子健"</span><span class="token punctuation">,</span> <span class="token string">"5.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Video<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>movie<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在示例中，<code>start()</code> 方法可以接受 Video 类型的引用，这是在太有趣了！</p>
<p>在测试类中，传递给 <code>start()</code> 方法的是一个 Movie 引用。鉴于 Java 是一个对类型检查十分严格的语言，接受某种类型 <em>(上例是 <code>Video</code> 类型)</em> 的方法同样可以接受另外一种类型 <em>(上例是 <code>Movie</code> 类型)</em> 就会显得很奇怪！</p>
<p><strong>除非你认识到 Movei 对象也是一种 Video 对象</strong>。</p>
<p>在 <code>start()</code> 方法中，程序代码可以对 Video 和它所有子类起作用，<strong>这种将 Movie 引用转换为 Video 引用的动作</strong>，我们称之为 <strong>向上转型</strong> <em>(这样称呼是因为在继承树的画法上，基类在子类的上方…)</em>。</p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p>所有的类均具有父类，除了 <code>Object</code> 类。Java 类层次结构的最顶部就是 <code>Object</code> 类。</p>
<p>如果类没有显式地指明继承哪一个父类，那么它会自动地继承自 <code>Object</code> 类。如果一个子类继承了一个父类，那么父类要么继承它的父类，要么自动继承 <code>Object</code>。<strong>最终，所有的类都将 <code>Object</code> 作为祖先。</strong></p>
<p>这意味着 Java 中的所有类都具有一些共同的特征。这些特征在被定义在 <code>Object</code> 中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/925a4b38-d2b2-4508-9011-988e2f5cfb49.png" alt="Object 类拥有的方法"></p>
<p><em>(其中 <code>finalize()</code> 方法在 Java 9 之后弃用了，原因是因为它本身存在一些问题，可能导致性能问题：死锁、挂起和其他问题…)</em></p>
<p><em>(想看源码可以打一个 <code>Object</code>，然后按住 <code>Ctrl</code> 不放，然后点击 <code>Object</code> 就可以进入 JDK 源码查看了，源码有十分规范的注释和结构，你有时甚至会发现一些有趣的东西…)</em></p>
<p>Java 之父 Gosling 设计的 Object 类，是对万事万物的抽象，是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知道哲学的三大经典问题：我是谁？我从哪里来？我到哪里去？在 Object 类中，这些问题都可以得到隐约的解答：</p>
<ol>
<li><strong>我是谁？</strong> <code>getClass()</code> 说明本质上是谁，而 <code>toString()</code> 是当前的名片；</li>
<li><strong>我从哪里来？</strong> <code>Object()</code> 构造方法是生产对象的基本方式，<code>clone()</code> 是繁殖对象的另一种方式；</li>
<li><strong>我到哪里去？</strong> <code>finalize()</code> 是在对象销毁时触发的方法；<em>(Java 9 之后已移除)</em></li>
</ol>
<p>另外，Object 还映射了社会科学领域的一些问题：</p>
<ol>
<li><strong>世界是否因你而不同？</strong> <code>hashCode()</code> 和 <code>equals()</code> 就是判断与其他元素是否相同的一组方法；</li>
<li><strong>与他人如何协调？</strong> <code>wait()</code> 和 <code>notify()</code> 就是对象间通信与协作的一组方法；</li>
</ol>
<h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>准确地理解如何在对象上应用方法调用非常重要。下面假设我们要调用 <code>x.f(args)</code>，<code>x</code> 是声明为 <code>C</code> 的一个对象。下面是调用过程的详细描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/59297eb2-70b4-455b-adff-bb104e2bac70.png" alt=""></p>
<ol>
<li>编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为 <code>f</code> 但参数类型不一样的方法。例如，可能存在 <code>f(int)</code> 和 <code>f(String)</code>。编译器将会一一列举 <code>C</code> 类中所有名为 <code>f</code> 的方法和其父类中所有名为 <code>f</code> 而且可以访问的方法 <em>(父类中的私有方法不可访问)</em>。<strong>至此，编译器一直到所有可能被调用的候选方法。</strong></li>
<li>接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为 <code>f</code> 的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为 <strong>重载解析</strong> <em>(overloading resolution)</em>。例如，对于调用 <code>x.f(&quot;Hello&quot;)</code>，编译期将会挑选 <code>f(String)</code>，而不是 <code>f(int)</code>。由于允许类型转换 <em>(例如，<code>int</code> 可以转换成 <code>double</code>)</em>，所以情况可能会变得很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报错。<strong>至此，编译器已经知道需要调用的方法的名字和参数类型。</strong></li>
<li>如果是 <code>private</code> 方法、<code>static</code> 方法、<code>final</code> 方法 <em>(有关 <code>final</code> 修饰符会在下面讲到)</em> 或者构造器，那么编译器将可以明确地知道应该调用哪个方法。这称为 <strong>静态绑定</strong> <em>(static binding)</em>。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时 <strong>动态绑定</strong>。在我们的实例中，编译器会利用动态绑定生成一个调用 <code>f(String)</code> 的指令。</li>
<li>程序运行并且采用动态绑定调用方法时，虚拟机必须调用与 <code>x</code> 所引用对象的实际类型对应的那个方法。假设 <code>x</code> 的实际类型是 <code>D</code>，它是 <code>C</code> 类的子类。如果 <code>D</code> 类定义了方法 <code>f(String)</code>，就会调用这个方法；否则，将在 <code>D</code> 类的父类中寻找 <code>f(String)</code>，以此类推。</li>
</ol>
<p><strong>每次调用方法都要完成这样的搜索，时间开销相当大</strong>。因此，虚拟机预先为每个类计算了一个 <strong>方法表</strong> <em>(method table)<em>， 其中列出了所有方法的签名和要调用的实际方法 *(存着各个方法的实际入口地址)</em>。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。</em>(以下是 Video-父类 和 Movie-子类 的方法表结构演示图)*</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/b969be72-d055-4cb6-b680-12e8f57c4254.png" alt=""></p>
<p>例如我们调用上述例子 Movie 类的 <code>play()</code> 方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>由于 <code>play()</code> 方法没有参数，因此不必担心 <strong>重载解析</strong> 的问题。又不是 <code>private/ static/ final</code> 方法，所以将采用 <strong>动态绑定</strong> 的方式。</p>
<p>在运行时，调用 <code>object.play()</code> 的解析过程为：</p>
<ol>
<li>首先，虚拟机获取 <code>object</code> 的实际类型的方法表。这可能是 Video、Movie 的方法表，也可能是 Video 类的其他子类的方法表；</li>
<li>接下来，虚拟机查找定义了 <code>play()</code> 签名的类。此时，虚拟机已经知道应该调用哪个方法了；<em>(这里如果 <code>object</code> 实际类型为 Movie 则调用 Movie.play()，为 Video 则调用 Video.play()，如果没找到才往父类去找..)</em></li>
<li>最后，虚拟机调用这个方法。</li>
</ol>
<p><strong>动态绑定有一个非常重要的特性：无须对现有的代码进行修改就可以对程序进行扩展。</strong></p>
<p>假设现在新增一个类 <code>ShortVideo</code>，并且变量 <code>object</code> 有可能引用这个类的对象，我们不需要对包含调用 <code>object.play()</code> 的代码重新进行编译。如果 <code>object</code> 恰好引用一个 <code>ShortVideo</code> 类的对象，就会自动地调用 <code>object.play()</code> 方法。</p>
<blockquote>
<p><strong>警告</strong>：在覆盖一个方法时，子类的方法 <strong>不能低于</strong> 父类方法的 <strong>可见性</strong> <em>(public &gt; protected &gt; private)</em>。特别是，如果父类方法是 <code>public</code>，子类方法必须也要声明为 <code>public</code>。</p>
</blockquote>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>有时候，我们可能希望组织人们利用某个类定义子类。<strong>不允许扩展</strong> <em>(被继承)</em> 的类被称为 <strong>final 类</strong>。如果在定义类的时候使用了 <code>final</code> 修饰符就表明这个类是 <code>final</code> 类了：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ShortVideo</span> <span class="token keyword">extends</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre>
<p>类中的某个特定方法也可以被声明为 <code>final</code>。如果这样做，子类就不能覆盖这个方法 <em>(<code>final</code> 类中的所有方法自动地称为 <code>final</code> 方法)</em>。例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Video</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<p>如果一个 <strong>字段</strong> 被声明为了 <code>final</code> 类型，那么对于 <code>final</code> 字段来说，<strong>构造对象之后就不允许改变它们的值了</strong>。不过，如果将一个类声明为 <code>final</code>，只有其中的方法自动地称为 <code>final</code>，而不包括字段，这一点需要注意。</p>
<p><strong>将方法或类声明为 <code>final</code> 的主要原因是：确保它们不会在子类中改变语义。</strong></p>
<h3 id="JDK-中的例子"><a href="#JDK-中的例子" class="headerlink" title="JDK 中的例子"></a>JDK 中的例子</h3><ul>
<li><strong>Calendar</strong> 类 <em>(JDK 实现的日历类)</em> 中的 <code>getTime</code> 和 <code>setTime</code> 方法都声明为了 <code>final</code>，这就表明 <strong>Calendar</strong> 类的设计者负责实现 <strong>Data</strong> 类与日历状态之间的转换，而不允许子类来添乱。</li>
<li>同样的，<strong>String</strong> 类也是 <code>final</code> 类 <em>(甚至面试中也经常出现)</em>，这意味着不允许任何人定义 <strong>String</strong> 的子类，换而言之，如果有一个 <strong>String</strong> 引用，它引用的一定是一个 <strong>String</strong> 对象，而不可能是其他类的对象。</li>
</ul>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>在早起的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 <code>final</code> 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为 <strong>内联</strong> <em>(inlining)</em>。</p>
<p>例如，内联调用 <code>e.getName()</code> 会被替换为访问字段 <code>e.name</code>。</p>
<p>这是一项很有意义的改进，CPU 在处理当前指令时，<strong>分支会扰乱预取指令的策略</strong>，所以，CPU 不喜欢分支。然而，如果 <code>getName</code> 在另外一个类中 <strong>被覆盖</strong>，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p>
<p>幸运的是，虚拟机中的 <strong>即时编译器</strong> <em>(JIT)</em> 比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出是否有类确实覆盖了给定的方法。</p>
<p>如果方法很短、被频繁调用而且确实没有被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而这个子类覆盖了一个内联方法，那么优化器将取消对这个方法的内联。这个过程很慢，不过很少会发生这种情况。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在类的自下而上的继承层次结构中，位于上层的类更具有一般性，也更加抽象。从某种角度看，祖先类更具有一般性，人们通常只是将它作为派生其他类的基类，而不是用来构造你想使用的特定的实例。</p>
<p>考虑一个 Person 类的继承结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/00ddd596-2c2c-4f94-a08b-37765be0ddfe.png" alt=""></p>
<p>每个人都有一些属性，如名字。学生与员工都有名字。</p>
<p>现在，假设需要增加一个 <code>getDescription()</code> 的方法，它返回对一个人简短的描述，学生类可以返回：<code>一个计算机在读的学生</code>，员工可以返回 <code>一个在阿里就职的后端工程师</code> 之类的。这在 Student 和 Employee 类中实现很容易，但是在 Person 类中应该提供什么内容呢？ 除了姓名，Person 类对这个人一无所知。</p>
<p>有一个更好的方法，就是使用 <code>abstract</code> 关键字，把该方法定义为一个 <strong>抽象方法</strong>，这意味着你并不需要实现这个方法，只需要定义出来就好了：<em>(以下代码为 Person 类中的抽象定义)</em></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>《阿里Java开发规范》<strong>强制规定抽象类命名</strong> 使用 <code>Abstract</code> 或 <code>Base</code> 开头，这里只是做演示所以就简单用 <code>Person</code> 代替啦~</p>
</blockquote>
<p>抽象方法充当着占位方法的角色，它们在子类中被继承并实现。</p>
<p>扩展抽象类可以由两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未实现，这样就必须将子类标记为抽象类 <em>(因为还有抽象方法)</em>；另一种做法就是实现全部方法，这样一来，子类就不是抽象的了。</p>
<p><em>(即使不包含抽象方法，也可以将类声明为抽象类)</em></p>
<p>抽象类不能实例化，也就是说，如果将一个类声明为 <code>abstract</code>，就不能创建这个类的实例，例如：<code>new Person();</code> 就是错误的，但可以创建具体子类的对象：<code>Person p = new Student(args);</code>，这里的 <code>p</code> 是一个抽象类型 <code>Person</code> 的变量，它引用了一个非抽象子类 <code>Student</code> 的实例。</p>
<h1 id="Part-4-为什么不推荐使用继承？"><a href="#Part-4-为什么不推荐使用继承？" class="headerlink" title="Part 4. 为什么不推荐使用继承？"></a>Part 4. 为什么不推荐使用继承？</h1><p>先别急着奇怪和愤懑，刚学习完继承之后，就告诉说不推荐使用，这是 <strong>有原因的！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/e29e8ed5-7853-4e7b-a89f-7ce7ab7b3fa2.png" alt=""></p>
<p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承</strong>。使用继承有什么问题？组合相比继承有哪些优势？如何判断该用组合还是继承？下面我们就围绕这三个问题，来详细讲解一下。</p>
<blockquote>
<p>以下内容大部分引用自：<a href="https://time.geekbang.org/column/article/169593" target="_blank" rel="noopener">https://time.geekbang.org/column/article/169593</a></p>
</blockquote>
<h2 id="使用继承有什么问题？"><a href="#使用继承有什么问题？" class="headerlink" title="使用继承有什么问题？"></a>使用继承有什么问题？</h2><p>上面说到，继承是面向对象的四大特性之一，用来表示类之间的 <code>is-a</code> 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。我们通过一个例子来说明一下。</p>
<p>假设我们要设计一个关于鸟的类，我们将 “鸟类” 这样一个抽象的事物概念，定义为一个抽象类 <code>AbstractBird</code>。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/8afe27e4-35d6-4fa8-b90b-be2e05644eeb.png" alt=""></p>
<p>我们知道，大部分鸟都会飞，那我们可不可以在 <code>AbstractBird</code> 抽象类中，定义一个 <code>fly()</code> 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 <code>fly()</code> 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写 <em>(override)</em> <code>fly()</code> 方法，让它抛出 <code>UnSupportedMethodException</code> 异常不就可以了吗？具体的代码实现如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractBird</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//...省略其他属性和方法...</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBird</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//鸵鸟</span>
  <span class="token comment" spellcheck="true">//...省略其他属性和方法...</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnSupportedMethodException</span><span class="token punctuation">(</span><span class="token string">"I can't fly.'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 <code>fly()</code> 方法，抛出异常。</p>
<p>这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则 <em>(Least Knowledge Principle，也叫最少知识原则或者迪米特法则)</em>，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p>
<p>你可能又会说，那我们再通过 <code>AbstractBird</code> 类派生出两个更加细分的抽象类：会飞的鸟类 <code>AbstractFlyableBird</code> 和不会飞的鸟类 <code>AbstractUnFlyableBird</code>，让麻雀、乌鸦这些会飞的鸟都继承 <code>AbstractFlyableBird</code>，让鸵鸟、企鹅这些不会飞的鸟，都继承 <code>AbstractUnFlyableBird</code> 类，不就可以了吗？具体的继承关系如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay5%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/f77b3726-9183-42a2-bf29-6cc701d228f8.png" alt=""></p>
<p>从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注“鸟会不会飞”，但如果我们关注更多的问题，例如 “鸟会不会叫”、”鸟会不会下单“ 等… 那这个时候，我们又该如何设计类之间的继承关系呢？</p>
<p>总之，继承最大的问题就在于：<strong>继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性</strong>。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？</p>
<h2 id="组合相比继承有哪些优势？"><a href="#组合相比继承有哪些优势？" class="headerlink" title="组合相比继承有哪些优势？"></a>组合相比继承有哪些优势？</h2><p>实际上，我们可以利用组合 <em>(composition)*、接口、委托 *(delegation)</em> 三个技术手段，一块儿来解决刚刚继承存在的问题。</p>
<p>我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对“会飞”这样一个行为特性，我们可以定义一个 <code>Flyable</code> 接口 <em>(相当于定义某一种行为，下方会有代码说明)</em>，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 <code>Tweetable</code> 接口、<code>EggLayable</code> 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Tweetable</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EggLayable</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">implements</span> <span class="token class-name">Tweetable</span><span class="token punctuation">,</span> EggLayable <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//鸵鸟</span>
  <span class="token comment" spellcheck="true">//... 省略其他属性和方法...</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sparrow</span> impelents Flayable<span class="token punctuation">,</span> Tweetable<span class="token punctuation">,</span> EggLayable <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//麻雀</span>
  <span class="token comment" spellcheck="true">//... 省略其他属性和方法...</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
<span class="token punctuation">}</span></code></pre>
<p>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 <code>layEgg()</code> 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？</p>
<p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 <code>fly()</code> 方法的 <code>FlyAbility</code> 类、实现了 <code>tweet()</code> 方法的 <code>TweetAbility</code> 类、实现了 <code>layEgg()</code> 方法的 <code>EggLayAbility</code> 类。然后，通过 <strong>组合和委托</strong> 技术来消除代码重复。具体的代码实现如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyAbility</span> <span class="token keyword">implements</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//省略Tweetable/TweetAbility/EggLayable/EggLayAbility</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ostrich</span> <span class="token keyword">implements</span> <span class="token class-name">Tweetable</span><span class="token punctuation">,</span> EggLayable <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//鸵鸟</span>
  <span class="token keyword">private</span> TweetAbility tweetAbility <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TweetAbility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//组合</span>
  <span class="token keyword">private</span> EggLayAbility eggLayAbility <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EggLayAbility</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//组合</span>
  <span class="token comment" spellcheck="true">//... 省略其他属性和方法...</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tweetAbility<span class="token punctuation">.</span><span class="token function">tweet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 委托</span>
  <span class="token punctuation">}</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eggLayAbility<span class="token punctuation">.</span><span class="token function">layEgg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 委托</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>当然啦，也可以使用 <code>JDK 1.8</code> 之后支持的接口默认方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// fly的 的默认实现</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>我们知道继承主要有三个作用：表示 <code>is-a</code> 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如：</p>
<ul>
<li><code>is-a</code> 关系，我们可以通过组合和接口的 <code>has-a</code> 关系来替代；</li>
<li>多态特性我们可以利用接口来实现；</li>
<li>代码复用我们可以通过组合和委托来实现；</li>
</ul>
<p>所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。</p>
<h2 id="如何判断该用组合还是继承？"><a href="#如何判断该用组合还是继承？" class="headerlink" title="如何判断该用组合还是继承？"></a>如何判断该用组合还是继承？</h2><p>尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。</p>
<p>如果类之间的继承结构稳定 <em>(不会轻易改变)</em>，继承层次比较浅 *(比如，最多有两层继承关系)，继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。</p>
<p>除此之外，还有一些 <strong>设计模式</strong> 会固定使用继承或者组合。比如，<strong>装饰者模式</strong>（decorator pattern）、<strong>策略模式</strong>（strategy pattern）、<strong>组合模式</strong>（composite pattern）等都使用了 <strong>组合关系</strong>，而 <strong>模板模式</strong>（template pattern）使用了 <strong>继承关系</strong>。</p>
<p>前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。<strong>但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系</strong>。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系 <em>(既不是父子关系，也不是兄弟关系)</em>。<strong>仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性</strong>。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，<strong>使用组合就更加合理、更加灵活</strong>。具体的代码实现如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Url</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//...省略属性和方法</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Crawler</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> Url url<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 组合</span>
  <span class="token keyword">public</span> <span class="token function">Crawler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Url</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PageAnalyzer</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> Url url<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 组合</span>
  <span class="token keyword">public</span> <span class="token function">PageAnalyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Url</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">//..</span>
<span class="token punctuation">}</span></code></pre>
<p>还有一些特殊的场景要求我们必须使用继承。<strong>如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现</strong>。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 <code>encode()</code> 函数。这个时候，我们只能采用继承来实现了。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignClient</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Feign Client框架代码</span>
  <span class="token comment" spellcheck="true">//...省略其他代码...</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">encode</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//... }</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demofunction</span><span class="token punctuation">(</span>FeignClient feignClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//...</span>
  feignClient<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomizedFeignClient</span> <span class="token keyword">extends</span> <span class="token class-name">FeignClient</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">encode</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//...重写encode的实现...}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 调用</span>
FeignClient client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomizedFeignClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">demofunction</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>尽管有些人说，要杜绝继承，<code>100%</code> 用组合代替继承，但是我的观点没那么极端！之所以 “多用组合少用继承” 这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。</p>
<h1 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h1><ol>
<li>继承概述 / 单继承 / <code>is-a</code> 关系 / 类之间的关系 / 层级结构；</li>
<li>继承的实现 / 覆盖方法 / <code>protedcted</code> / 向上转型；</li>
<li>Object 类 / 方法调用 / <code>final</code> / 内联 / 为什么不推荐使用继承；</li>
</ol>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>暂无；</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Java 核心技术 卷 I》</li>
<li>《Java 编程思想》</li>
<li>《码出高效 Java 开发手册》</li>
<li>设计模式之美 - 为何说要多用组合少用继承？如何决定该用组合还是继承？ - <a href="https://time.geekbang.org/column/article/169593" target="_blank" rel="noopener">https://time.geekbang.org/column/article/169593</a></li>
<li>Introduction to Computer Science using Java - <a href="http://programmedlessons.org/Java9/index.html#part02" target="_blank" rel="noopener">http://programmedlessons.org/Java9/index.html#part02</a> </li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/qrcode.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/08/04/morethanjava-day-4-mian-xiang-dui-xiang-ji-chu/">
      「MoreThanJava」Day 4：面向对象基础
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年8月4日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/7f300125-846f-4440-95f4-3fb397d7478e.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="Part-1-面向对象设计概述"><a href="#Part-1-面向对象设计概述" class="headerlink" title="Part 1. 面向对象设计概述"></a>Part 1. 面向对象设计概述</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/5b68f16b-c095-4300-8bb4-4180760f9695.png" alt=""></p>
<p>面向对象程序设计 <em>(Object-Oriented Programming, OOP)</em> 是当今主流的程序设计范型，它取代了 <code>20</code> 世纪 <code>70</code> 年代的 “结构化” 或过程式编程技术。由于 Java 是面向对象的，所以必须熟悉 OOP 才能够很好地使用 Java。</p>
<h2 id="了解抽象"><a href="#了解抽象" class="headerlink" title="了解抽象"></a>了解抽象</h2><p><strong>抽象的作用是将复杂的机制隐藏在一个对象中，仅保留我们与之交互所必须的信息</strong>。</p>
<p>为了说明这一点，我们可以想象平时使用 <strong>「电梯」</strong> 的场景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/bd4d9df6-9894-48cb-8db5-c6193bab8df8.png" alt="熟悉的早晨等电梯！"></p>
<p>如果您在办公楼工作，这可能是您日常工作的一部分。你按下向上或向下按钮，然后等待门滑开。完成操作后，您进入一个 “盒子”，该 “盒子” 的一面墙上有一个按钮面板，然后按下所需的按钮。当电梯到达您要去到的楼层后，您会挤过其他人然后走出去。</p>
<p><strong>要使用电梯，您只需要了解如何按下正确的按钮就可以达到目的。</strong></p>
<p>而隐藏在电梯背后的支持它工作的一系列东西 —— 滑轮系统、机械、电线、减震器、安全系统等等… 您可以完全不知道也完全不必操心…</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/3d83e081-0ad5-4d2a-a569-48c441a78dbc.png" alt="我完全不知道他们在做什么..."></p>
<p>电梯这个 “铁盒子” 以及相应的按钮面板，就是对整个「运输系统」成功的抽象 <em>(事实上电梯背后还包含检修、维护等一系列事情…)</em>，它隐藏了足够多的细节，也极大地方便了我们的生活。</p>
<h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p><strong>简单来说，对象是对现实世界的抽象。</strong> <em>(例如上方对整个运输系统抽象之后，就得到了「电梯」这个对象…)</em></p>
<p>什么东西是对象？什么东西不是对象？这是一个困扰哲学家数千年的问题。勒内·笛卡尔 <em>(17世纪的哲学家)</em> 观察到，人类是用面向对象的方式看待世界的 <em>(例如与电梯的交互)</em>。人类的大脑会从对象的角度认识世界 <em>(例如鸟类、鱼类)</em>，我们的思想和记忆也被组织成物体和它们之间的关系 <em>(例如，鸟吃虫)</em>。</p>
<h3 id="对象像是一种模板"><a href="#对象像是一种模板" class="headerlink" title="对象像是一种模板"></a>对象像是一种模板</h3><p>亚里士多德大概是第一个深入研究 <strong>类型</strong> <em>(type)</em> 的哲学家，它曾经提出过 <strong>鱼类</strong> 和 <strong>鸟类</strong> 这样的概念。<strong>所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。</strong></p>
<p>这就好像我们拿着一个模具，我们可以使用该模具制作出各种各样东西，每个东西都有自己的 “个性”，但它们又都遵循一些相同的基本模式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/e03748fe-fd54-4200-9e79-b81f4b2df0b9.png" alt=""></p>
<h3 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h3><p>我们可以把你的「银行账户」抽象成一个对象，但它不是由物质构成的。<em>(虽然您和银行可以使用纸张和其他材料来记录您的账户，但您的账户独立于这些材料而存在。)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/4dceb90b-0dfc-4548-9d07-8fce72749155.png" alt=""></p>
<p>虽然它不是物质的，但你的账户是有 <strong>属性</strong> 的 <em>(余额、利率、持有者等..)</em>，<strong>你可以对它做一些事情</strong> <em>(存款、取款、查看余额等..,)</em>，<strong>它自己也可以做一些事情</strong> <em>(交易收费、积累利息等…)</em>。</p>
<p>这足够清楚吧。事实上，这些特征它们都有名字：</p>
<ul>
<li>对象具有 <strong>标识 identity</strong>；<em>(每个对象都是独立的个体)</em></li>
<li>对象具有 <strong>状态 state</strong>；<em>(它具有各种可能会改变的属性)</em></li>
<li>对象具有 <strong>行为 behavior</strong>；<em>(它可以做事情，也可以让别人对它做事情)</em></li>
</ul>
<p>这就是对一个物体的一般描述。<em>(上面的列表来自于 <code>1994</code> 年 <code>Grady Booch</code>/<code>Addison-Wesley</code> 出版的《面向对象分析与设计》一书。)</em> 当你开始编写面向对象的软件时，你会发现这个列表将帮助你决定你的对象应该是什么样。</p>
<h2 id="编程语言中的抽象过程"><a href="#编程语言中的抽象过程" class="headerlink" title="编程语言中的抽象过程"></a>编程语言中的抽象过程</h2><p>所有编程语言都提供抽象机制。<strong>可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量</strong>。</p>
<p>所谓的 “类型” 是指 “所抽象的是什么？”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/efecfb0e-7614-4233-95e1-dbefa942f05f.png" alt=""></p>
<p>汇编语言是对底层机器语言的轻微抽象，接着出现的许多 “命令式” 语言 <em>(如 FORTRAN、BASIC、C 等..)</em> 都是对汇编语言的进一步抽象。</p>
<p>这些语言在汇编语言基础上有了很大幅度的改进，但是它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决的问题的结构来考虑。</p>
<blockquote>
<p>传统的结构化程序设计通过设计一系列的过程 <em>(即算法)</em> 来求解问题。一旦确定了这些过程，就要开始考虑存储数据的适当方式。</p>
<p>这就是 <code>Pascal</code> 语言的设计者 <code>Niklaus Wirth</code> 将其著作命名为《算法 + 数据结构 = 程序》<em>(Algorithms + Data Structures = Programs, Prentice Hall, <code>1975</code>)</em> 的原因。</p>
<p>需要注意的是，在 <code>Wirth</code> 的这个书名中，算法是第一位的，数据结构是第二位的，这就明确的表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据的结构，以便于操作数据。</p>
<p>而 OOP 却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。<em>(在 OOP 中，也有说法是：程序 = 对象 + 交互)</em></p>
</blockquote>
<p>这使得程序员必须建立起在 <strong>机器模型</strong> <em>(位于 “解空间” 内，这是你对问题建模的地方，例如计算机)</em> 和 <strong>实际需要解决问题的模型</strong> <em>(位于 “问题空间” 内，这是问题存在的地方，例如一项业务)</em> 之间的 <strong>关联</strong>。</p>
<p>建立这种映射是费力的，而且这不属于编程语言固有的功能，这使得程序难以编写，并且维护代价高昂，同时也产生了作为副产物的整个 “编程方法” 行业。</p>
<h2 id="面向对象思想的突破"><a href="#面向对象思想的突破" class="headerlink" title="面向对象思想的突破"></a>面向对象思想的突破</h2><p>另一种对机器建模的方式就是针对待解问题建模。</p>
<p>早期的编程语言，例如 <code>LISP</code> 和 <code>APL</code>，都是选择一些特定的视角来 “解释世界” <em>(分别敌营 “所有问题最终都是列表” 或者 “所有问题都是算法形式的”)</em>。<code>PROLOG</code> 则将所有问题都转换成决策链。此外还产生了基于约束条件编程的语言和专门通过对图形符号操作来实现编程的语言 <em>(后来被证明限制性过强)</em>。</p>
<p>这些方式对于它们本身所要解决的 <strong>特定类型的问题</strong> 都是不错的解决方案，但是一旦 <strong>超出</strong> 其特定领域，它们就力不从心了。</p>
<p><strong>面向对象的方式通过向程序员提供表示问题空间中的元素的工具而更近了一步。</strong></p>
<p>这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。我们把问题空间中的一些基本元素进一步抽象成解空间中的 “对象”。<strong>这种思想的实质是：程序可以通过添加新类型的对象使其自身适用于某个特定的问题</strong>。</p>
<p>因此，当你在阅读描述解决方案的代码的同时，也是在阅读问题的表述。相比之前的语言，这是一种更灵活和更强力的语言抽象。所以，OOP 允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。</p>
<p>面向对象软件的最重要的突破之一就是允许我们按照 <strong>自然的面向对象的大脑思维方式相匹配的方式组织软件</strong>。我们希望使用具有属性并能够与其他对象进行交互的对象，而不是直接使用更改主存储器中的 bit 数据的机器指令。当然，在机器层面上什么也没有改变——bit 数据仍是由机器指令操作的，但至少我们不用再考虑机器指令了！</p>
<blockquote>
<p>对于一些规模较小的问题，将其分解为过程的开发方式比较理想。面向对象更加适合解决规模较大的问题。要想实现一个简单的 Web 浏览器可能需要大约 <code>2000</code> 个过程，这些过程可能需要对一组全局数据进行操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/26f7288b-2df2-41f1-a410-482a3867c548.png" alt=""></p>
<p>采用面向对象的设计风格，可能只需要大约 <code>100</code> 个类，每个类平均包含 <code>20</code> 个方法。这明显易于程序员掌握，也容易找到 BUG。<em>(假设给定对象的数据出错了，在访问这个数据项的 <code>20</code> 个方法中查找错误要比在 <code>2000</code> 个过程中查找要容易多了)</em></p>
</blockquote>
<h2 id="OOP-的起源"><a href="#OOP-的起源" class="headerlink" title="OOP 的起源"></a>OOP 的起源</h2><p>正如我们上面描述的那样，面向对象的编程是当今不可回避的。让我们来看看它是如何变成现实的。</p>
<p>时间回到上世纪 <code>60</code> 年代，那个时候计算机图形还不存在。当时，美国计算机科学家 <code>Ivan Edward Sutherland</code> 实现了能够绘图的应用程序，名叫：<strong>SketchPad</strong>。</p>
<p>它是专门为设计人员开发的，它允许设计人员使用手写笔通过计算机绘制简单的几何形状，例如三角形、正方形、圆形等。该项目也是 <strong>计算机辅助设计 CAD</strong> 的起点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/c83e1ee3-dc92-4076-a30f-466d8e689fbb.png" alt="SketchPad"></p>
<p>这成为了面向对象编程的 <strong>奠基典范</strong> 之一。</p>
<p>因为在 Ivan 的程序设计中，使用了我们现在称为 “对象” 的表现形式来描述现实生活中的几何图形，这些图形对于设计人员来说是完全可以理解的！</p>
<p>这其中没有无穷无尽的变量和函数，而是通过具体的几何图形 <em>(对象形式)</em> 来描述 <em>(包括上下文数据，都存储在变量中)</em> 和操作 <em>(函数实现)</em> 进行分组，并以一种关系进行管理这些特定的元素。</p>
<p>这些东西在现在都有确切的名称。<em>(分别对应 “属性” 和 “方法”)</em></p>
<h2 id="OOP-的规范化"><a href="#OOP-的规范化" class="headerlink" title="OOP 的规范化"></a>OOP 的规范化</h2><p>Ivan 的项目和其他一些项目在 <code>1967</code> 年影响了 <strong>Simula</strong> 编程语言。该语言第一次直接将面向对象的思想引入到了 编程语言中 <em>(重大更新之后被称为 <code>Simula-67</code>)</em>。 </p>
<p><code>1970</code> 年代，<strong>Xerox</strong> <em>(负责鼠标和图形界面的发明)</em> 在个人电脑上工作。他们希望通过操纵 GUI 和鼠标来创建任何人都可以轻松使用的计算机。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/ebee7ece-d2db-48fc-bc92-d40ff6620a6a.png" alt="最早的个人计算机之一"></p>
<p>为了表示屏幕上的所有元素并支持其显示和操作的逻辑，由艾伦·凯 <em>(Alan Kay)</em> 领导的团队创建了 <strong>SmallTalk</strong> 语言，该语言的灵感来自 <strong>Simula</strong>。根据许多资料显示，这标志着我们今天使用的面向对象编程概念的正式确立！ </p>
<h2 id="OOP-的普及化"><a href="#OOP-的普及化" class="headerlink" title="OOP 的普及化"></a>OOP 的普及化</h2><p>上述这些方法在 <code>1981</code> 年开始流行，并成为了伟大的面向对象语言的起点，例如：</p>
<ul>
<li><strong>Objective-C</strong> 是 iOS 本机开发的原始语言。从那以后，Apple 对其进行了改进和增强，它仍然是 iOS 开发人员的常见选择。</li>
<li><strong>C ++</strong> 是 C 编程语言的面向对象版本。C 和 C++ 仍被广泛使用，尤其是在非常专业的行业中。 </li>
</ul>
<p>如我们所见，在编程方面取得了令人难以置信的进步，这是对以下问题的解决方案：<strong>简化软件开发！</strong></p>
<blockquote>
<p><strong>面向对象设计的特殊效率从何而来？</strong></p>
<ul>
<li>部分影响来自于更清晰的表达复杂系统的方式；</li>
<li>也许最重要的原因 <em>（也是从操作系统体系结构派生而来的）</em> 是，当您给某人一个结构时，您很少希望他们拥有无限的特权。仅仅进行类型匹配甚至还不能满足需求。保护某些对象而不保护某些对象也不是非常合理有用。</li>
</ul>
<p>正确执行封装不仅是对状态抽象的承诺，而且是消除编程中面向状态的隐喻的一种承诺。</p>
</blockquote>
<h1 id="Part-2-类与对象概述"><a href="#Part-2-类与对象概述" class="headerlink" title="Part 2. 类与对象概述"></a>Part 2. 类与对象概述</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/19a4aac1-863c-4786-adf5-8350b166ed7f.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://javatutorial.net/java-oop" target="_blank" rel="noopener">https://javatutorial.net/java-oop</a></li>
</ul>
<p><strong>简单的说，类是对象的蓝图或模板，而对象是类的实例。</strong></p>
<p>这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，<strong>类是抽象的概念，而对象是具体的东西</strong>。</p>
<p>在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类 <em>(型)*。当我们把一大堆拥有共同特征的对象的静态特征 *(属性)</em> 和动态特征 <em>(行为)</em> 都抽取出来后，就可以定义出一个叫做 <strong>“类”</strong> 的东西。</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>使用类几乎可以模拟任何东西。假设我们要编写一个表示小狗 Dog 的简单类 —— 它表示的不是特定的小狗，而是任何小狗。</p>
<p>对于大多数宠物狗，我们都知道些什么呢？—— 它们都有名字和年龄，还会叫、会吃东西。由于大多数的小狗都具备上述两项信息 <em>(名字和年龄)</em> 和两种行为 <em>(叫和吃东西)</em>，所以我们的 Dog 类将包含它们，这个类看上去会是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/a1b36ab3-0c58-451d-be4a-d280bc338f44.png" alt=""></p>
<p>代码实现起来大概会像这样：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 参数</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 字段访问器</span>
    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 字段访问器</span>
    <span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 方法 - 叫</span>
    <span class="token keyword">void</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"汪汪汪！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 方法 - 吃东西</span>
    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一只"</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">"岁大的名叫 "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" 的狗正在吃东西！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="剖析-Dog-类"><a href="#剖析-Dog-类" class="headerlink" title="剖析 Dog 类"></a>剖析 Dog 类</h3><p>下面各个部分我们将对上面描述的 Dog 类进行剖析。首先从这个类的方法开始吧，上述源码我们看到，这个类包含一个构造器和四个方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>这个类的所有方法都被标记为 <code>public</code>。关键字 <code>public</code> 意味着任何类的任何方法都可以调用这些方法 <em>(共有四种访问级别，将在之后介绍到)</em></p>
<p>接下来，还需要注意 Dog 类实例中有 <code>2</code> 个实例字段用来存放将要操作的数据：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> String name<span class="token punctuation">;</span>
<span class="token keyword">private</span> Integer age<span class="token punctuation">;</span></code></pre>
<p>关键字 <code>private</code> 确保只有 Dog 类自身的方法能够访问到这些实例字段，而其他类的方法不能够读写这些字段。<em>(这也是 Private 私有本身的含义)</em></p>
<blockquote>
<p><strong>注意</strong>：虽然可以用 <code>public</code> 标记实例字段，但这是一种很不好的做法。<code>public</code> 修饰数据字段后，程序中的任何方法都可以对其进行读取和修改，这就完全破坏了 <strong>封装</strong>。<em>(这会使程序非常不可控)</em> 强烈建议将实力字段标记为 <code>private</code></p>
</blockquote>
<p>最后，请注意，<strong>这两个实例字段本身也是对象</strong>：<code>name</code> 字段是 <code>String</code> 类型的对象，<code>age</code> 是 <code>Integer</code> 类型的对象。这种情况十分常见：类包含的实例字段通常属于某个类类型。</p>
<h3 id="从构造器开始"><a href="#从构造器开始" class="headerlink" title="从构造器开始"></a>从构造器开始</h3><p>这个与类名相同且权限为 <code>public</code> 的方法 <code>Dog()</code> 我们把它称为 <strong>构造器</strong>，让我们来看看它：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>在构造 Dog 类对象的时候，构造器会运行，从而将实例字段初始化为所希望的初始状态。</p>
<p>例如，当时用下面这条代码创建 Dog 类时：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"大黄"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>将会把数据设置为：</p>
<pre class=" language-text"><code class="language-text">name = "大黄"
age = 1</code></pre>
<p>构造器与其他方法有一个重要的不同。构造器总是结合 <code>new</code> 关键字来调用。不能对一个已经存在的对象调用构造器来达到重新设置属性的目的。例如 <em>(下方代码将产生编译错误)</em>：</p>
<pre class=" language-java"><code class="language-java">dogInstance<span class="token punctuation">.</span><span class="token function">Dog</span><span class="token punctuation">(</span><span class="token string">"小黄"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ERROR</span></code></pre>
<p>有关构造器还有很多可以说的地方，现在只需要记住：</p>
<ul>
<li>构造器与类同名；</li>
<li>每个类可以有一个以上的构造器；</li>
<li>构造器可以有 <code>0</code> 个、<code>1</code> 个或多个参数；</li>
<li>构造器没有返回值；</li>
<li>构造器总是伴随着 <code>new</code> 操作符一起调用。</li>
</ul>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p>最后仔细看一下非常简单的 <code>getName</code>/<code>getAge</code> 方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这些都是典型的访问器方法。由于它们只返回实例字段值，因此又称为 <strong>字段访问器</strong>。</p>
<p>如果将 <code>name</code>、<code>age</code> 字段标记为 <code>public</code>，允许任意方法访问，而不是编写单独的访问其方法，难道不是更容易一些嘛？</p>
<p>上面的例子似乎并不明显 <em>(而且 <code>name</code> 还是一个只读字段)</em>，所以为了说明这一点，我们来举一个更加有趣的例子。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/c0dcc95b-b595-4c3e-803b-f4771eb1b1c0.png" alt=""></p>
<p>假设我们有两个类，男人正在辛苦挣钱并时不时地查看余额，而此时来了一个小偷，专门偷男人的钱，<strong>逮着一个偷一个</strong>，而被偷了之后男人抓到了小偷，此时由于小偷的钱是私有的，<strong>男人抓着小偷咬牙切齿却没有丝毫办法可以把钱拿回来！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/5dcf13d6-6dff-4432-8da5-33788c151311.gif" alt=""></p>
<p>封装不仅仅帮助我们提高安全性，更可以简化操作和提高 <strong>内聚性</strong>。</p>
<p>假设你写了一个很庞大的系统，一开始你的定义是这样的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span></code></pre>
<p>你的程序里大概有 <code>100</code> 条类似于这样的语句：</p>
<pre class=" language-java"><code class="language-java">instance<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>此时突然要求你把数据类型变一下或者对这个字段其他一些什么统一的处理，需要修改 <code>100</code> 处的你，是不是傻了？</p>
<p><strong>封装的另一个好处是模块化</strong>。这方便我们把散落在各处的代码收拢并做统一的处理。</p>
<blockquote>
<p>设计模式器大原则之一的 <strong>迪米特法则</strong> 就是对于封装的具体要求，即 A 模块使用 B 模块的某个接口行为，对 B 模块中除此行为之外的其他信息知道得尽可能少。</p>
<p>比如：耳塞的插孔就是提供声音输出的行为接口，只需要关心这个插孔是否有相应的耳塞标记，是否是圆形，有没有声音即可，至于内部 CPU 如何运算音频信息，以及各个电容如何协同工作，根本不需要关注，这使得模块之间的协作只需忠于接口、忠于功能实现即可。</p>
</blockquote>
<h2 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h2><p>定义了 <code>class</code> 只是定义了对象模板，而要根据模板创建出真正的对象实例，必须使用 <code>new</code> 关键字，并调用对象的构造函数才行：</p>
<pre class=" language-java"><code class="language-java">Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"大黄"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>上述代码创建了一个 <code>Dog</code> 类型的实例，并通过变量 <code>dog</code> 指向它。<em>(下面我们将详细说明是怎么 “指向” 它的…)</em></p>
<p>第一个 <code>Dog</code> 表明了 <code>dog</code> 变量的类型，第二个 <code>Dog</code> 则是调用了 <code>Dog</code> 类的构造函数。在 <strong>Java 10</strong> 中，如果可以从变量的初始值推导出它们的类型，那么可以用 <code>var</code> 关键字来声明局部变量，而无须指定类型。例如：</p>
<pre class=" language-java"><code class="language-java">var dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">"大黄"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这一点很好，因为可以避免重复写类型名 <code>Dog</code>。但是参数和字段的类型还是必须显式地声明，该用法仅能用于方法中的局部变量。</p>
<p>要想使用类中公用方法，我们可以直接使用 <code>.</code> <em>(英文句号)</em> 来连接类中的方法并调用：</p>
<pre class=" language-java"><code class="language-java">dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用该实例的 eat() 方法</span></code></pre>
<h2 id="Java-使用引用来操纵对象"><a href="#Java-使用引用来操纵对象" class="headerlink" title="Java 使用引用来操纵对象"></a>Java 使用引用来操纵对象</h2><p>每种编程语言都有自己的操纵内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示 <em>(例如 C 和 C++ 里的指针)</em> 来操纵对象？</p>
<p><strong>在 Java 中一切都被视为对象</strong>，这使得我们可以使用固定的语法。尽管这一切都看作对象，但操纵的标识符 <em>(例如上面的 <code>dog</code> 变量)</em> 实际上是 <strong>对象的一个 “引用”</strong> <em>(reference)</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/d319dcdb-166a-4804-b16c-785721d07b06.png" alt=""></p>
<p>只要握住这个遥控器，就能保持与电视机的连接。当有人想改变频道或减小音量时，实际操纵的是遥控器 <em>(引用)</em>，再由控制器来调控电视机 <em>(对象)</em>。</p>
<p>如果想在房间里四处走走，同时仍能调控电视机，那么只需要携带遥控器就可以了，而不是背着电视机…</p>
<p><strong>此外，即使没有电视机，遥控器也可以独立存在</strong>。</p>
<p>也就是说，你拥有一个引用，并不一定需要有一个对象与它关联。因此，如果你想操纵一个词或者一个句子，则可以创建一个 <strong>String</strong> 对象：</p>
<pre class=" language-java"><code class="language-java">String s<span class="token punctuation">;</span></code></pre>
<p>但是这里创建的只是引用，并不是对象。如果此时向 <code>s</code> 发送一个消息，就会返回一个运行时错误。这是因为此时 <code>s</code> 实际上没有与任何事物相关联 <em>(即没有电视机)</em>。</p>
<p><strong>因此，一种安全的做法是：创建一个引用的同时便进行初始化。</strong></p>
<pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span></code></pre>
<p>这里运用到了 Java 语言的一个特性：字符串可以直接使用带引号的文本进行初始化 <em>(其他对象需要使用 <code>new</code>)</em>。</p>
<h3 id="null-引用"><a href="#null-引用" class="headerlink" title="null 引用"></a>null 引用</h3><p>上面我们已经了解到，一个对象变量包含一个对象的引用。当引用没有关联对象时，实际上指向了一个特殊的值 <code>null</code>，这表示它没有引用任何对象。<em>(可以理解为 <code>String s;</code> 等同于 <code>String s = null;</code>)</em></p>
<p>听上去这是一种处理特殊情况的便捷机制，如未知的名字。但使用 <code>null</code> 值需要非常小心！如果对 <code>null</code> 值应用一个方法，那么就会产生一个 <code>NullPointException</code> 异常。</p>
<pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> null<span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// NullPointException</span></code></pre>
<p>这是一个很严重的错误！如果你的程序没有 “捕获” <em>(理解为手动检测和处理)</em> 异常，程序就会终止！正常情况下，程序并不会捕获这些异常，而是依赖于程序员从一开始就不要带来异常。<em>(这显然很难..)</em></p>
<p>定义一个类时，最好清楚的知道哪些字段可能为 <code>null</code>。在我们的例子中 <em>(Dog 类)</em>，我们不希望 <code>name</code> 和 <code>age</code> 字段为 <code>null</code>。</p>
<p>对此我们有两种解决方法。</p>
<p><strong>“宽容型” 方法</strong> 是把 <code>null</code> 参数转换为一个适当的非 <code>null</code> 值：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">"unknow"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> n<span class="token punctuation">;</span> 
<span class="token punctuation">}</span></code></pre>
<p>在 <strong>Java 9</strong> 中，<code>Objects</code> 类 <em>(JDK 自带的工具类)</em> 对此提供了一个便利方法：</p>
<pre class=" language-java"><code class="language-java">name <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNullElse</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">"unknow"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 效果与上面代码等同</span></code></pre>
<p><strong>“严格型” 方法</strong> 则是干脆拒绝 <code>null</code> 参数：</p>
<pre class=" language-java"><code class="language-java">name <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">"The name cannot be null!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>如果把上述代码添加进 <code>Dog</code> 类的构造函数，并且有人用 <code>null</code> 名字构造了一个 <code>Dog</code> 类，就会产生一个 <code>NullPointerException</code> 异常。乍看上去，这种做法似乎不太好，但有以下几个好处：</p>
<ol>
<li>异常报告会提供这个问题的描述；<em>(也就是 <code>The name cannot be null!</code>)</em></li>
<li>异常报告会准确地支出问题所在的位置，否则异常可能在其他地方出现，而很难追踪到真正导致问题的这个构造器参数；</li>
</ol>
<h1 id="Part-3-面向对象的四大特性"><a href="#Part-3-面向对象的四大特性" class="headerlink" title="Part 3. 面向对象的四大特性"></a>Part 3. 面向对象的四大特性</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/cfeaa75b-ab0f-493d-8173-20e49cbcac1b.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://flashgene.com/archives/51547.html" target="_blank" rel="noopener">https://flashgene.com/archives/51547.html</a></li>
</ul>
<p>面向对象有三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。有的地方支持把 <strong>“抽象”</strong> 也归纳进来，合并称为面向对象的四大特性。我觉得也无可厚非。</p>
<p><em>(关于继承和多态会在后续章节里面详细说明, 这里只作简单描述用于简单理解..)</em></p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是面相对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装、继承、多态的基础，是软件大厦的基石。<em>(上面有专门的一节描述，这里不再展开)</em></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>正如我们上面 <strong>男人与小偷</strong> 的例子，封装不仅能提高我们的安全性、帮助我们把实现细节隐藏起来，还是一种对象功能内聚的表现形式，这有助于让模块之间的耦合度变低，也更具有维护性。<em>(封装的优点上方有介绍，这里也不再展开)</em></p>
<p>封装使面向对象的世界变得单纯，对象之间的关系变得简单，”自扫门前雪” 就行了。特别是当今智能化的时代，对封装的要求越来越高了，例如 <strong>小爱同学</strong> 好了，对外的唯一接口就是语音输入，隐藏了指令内部的细节实现和相关数据，这大大降低了使用成本，也有效地保护了内部数据安全。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/5edae3e9-dbd8-4562-8fab-945b36eb68d4.png" alt=""></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承允许创建 <strong>具有逻辑等级结构的类体系</strong>，形成一个继承树。就拿我们上面创建的 <strong>Dog</strong> 类来说明吧，不是只有狗拥有那些属性和方法，猫也有！<em>(可能猫叫不能用 <code>bark</code> 表示，但本质都是叫)</em> 自然界中，有许多动物 <em>(动物是对这些生物的自然抽象)</em> 都有这样的行为，那么好了，我们往上再抽象一个 <code>Animal</code> 对象：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/f4970969-e654-4bed-957b-fe5a3881cbc4.png" alt=""></p>
<p>只要继承自 <code>Animal</code> 类，那么就会拥有 <code>Animal</code> 这个父类所描述的属性和方法 <em>(子类当然可以有自己的实现，这一点我们在后续章节中详细描述)</em>。这让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用。</p>
<p><strong>继承把枯燥的代码世界变得更有层次感，更具有扩展性，为多态打下了语法基础。</strong></p>
<p>不过继承也有几个 <strong>缺点</strong>：</p>
<ol>
<li>继承是一种 <strong>强耦合</strong> 的关系，父类如果做出一定改变，那么子类也必然会改变；</li>
<li>继承 <strong>破坏了封装</strong>，对于子类而言，它的实现对子类来说都是透明的；</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态是以上述的三个面向对象特征为基础</strong>，根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式。</p>
<p>太学术化了一点，举个例子可能明白点。比如，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作 <em>(方法)</em>，对于不同温度的水 <em>(运行时不同的对象类型)</em>，就会得到不同的结果，这就是多态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8DDay4%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/ae55c7cc-ea6e-45f6-8014-307eb774bb38.png" alt=""></p>
<p>自然界中最典型的例子就是碳家族。如果你告诉你的女朋友将在她的生日晚会上送她一块碳，女朋友当然不高兴了，可事实上却是 5 克拉的钻石。钻石就是碳元素在不断进化过程中的一种多态表现。</p>
<p>严格意义来说，多态并不是面向对象的一种特质，而是一种由继承行为衍生而来的进化能力而已。</p>
<p>(完)</p>
<h1 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h1><ol>
<li>类和对象 - 什么是类 / 什么是对象 / OOP 起源和发展 / 面向对象其他相关概念</li>
<li>定义类 - 基本结构 / 属性和方法 / 构造器</li>
<li>使用对象 - 创建对象 / 给对象发消息</li>
<li>面向对象的四大支柱 - 抽象 / 封装 / 继承 / 多态的简单介绍</li>
<li>基础练习 - 定义 Dog 类 / 定义时钟类 / 定义图形类 <em>(下方)</em></li>
</ol>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="练习-1：定义一个类描述数字时钟"><a href="#练习-1：定义一个类描述数字时钟" class="headerlink" title="练习 1：定义一个类描述数字时钟"></a>练习 1：定义一个类描述数字时钟</h2><p>参考答案：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Integer hour<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Integer minute<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Integer second<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Clock</span><span class="token punctuation">(</span>Integer hour<span class="token punctuation">,</span> Integer minute<span class="token punctuation">,</span> Integer second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>hour <span class="token operator">=</span> hour<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>minute <span class="token operator">=</span> minute<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 时钟走字(走1s)
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        second <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>second<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            second <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            minute <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minute<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                minute <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                hour <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>hour<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    hour <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 显示当前时间
     * @return
     */</span>
    <span class="token keyword">public</span> String <span class="token function">showCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"当前时间是：%d时:%d分:%d秒"</span><span class="token punctuation">,</span> hour<span class="token punctuation">,</span> minute<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 内部测试
     * @throws InterruptedException - 使用 Thread.sleep() 需要手动检测该异常, 这里节约篇幅直接抛出
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Clock clock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Clock</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            clock<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span><span class="token function">showCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 让当前线程睡 1s</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="练习-2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法"><a href="#练习-2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法" class="headerlink" title="练习 2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法"></a>练习 2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法</h2><p>参考答案：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Integer x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> Integer y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span>Integer x<span class="token punctuation">,</span> Integer y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 移动到指定位置
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveTo</span><span class="token punctuation">(</span>Integer x<span class="token punctuation">,</span> Integer y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 移动指定的距离
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveBy</span><span class="token punctuation">(</span>Integer dx<span class="token punctuation">,</span> Integer dy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> dx<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> dy<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 计算并返回与另一个点的距离
     */</span>
    <span class="token keyword">public</span> Double <span class="token function">distanceTo</span><span class="token punctuation">(</span>Point other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> dx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">-</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        <span class="token keyword">int</span> dy <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">-</span> other<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>dx <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">+</span> dy <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 当前的坐标信息
     */</span>
    <span class="token keyword">public</span> String <span class="token function">currentLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"当前点横坐标：%d，纵坐标：%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 内部测试
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Point point1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Point point2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point1<span class="token punctuation">.</span><span class="token function">currentLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point2<span class="token punctuation">.</span><span class="token function">currentLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        point2<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point2<span class="token punctuation">.</span><span class="token function">currentLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>point1<span class="token punctuation">.</span><span class="token function">distanceTo</span><span class="token punctuation">(</span>point2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Java 核心技术 卷 I》</li>
<li>《Java 编程思想》</li>
<li>《码出高效 Java 开发手册》</li>
<li>Deepen your knowledge by learning Object Oriented Programming (OOP) with Swift - <a href="https://openclassrooms.com/en/courses/4542221-deepen-your-knowledge-by-learning-object-oriented-programming-oop-with-swift" target="_blank" rel="noopener">https://openclassrooms.com/en/courses/4542221-deepen-your-knowledge-by-learning-object-oriented-programming-oop-with-swift</a></li>
<li>Think like a computer: the logic of programming - <a href="https://openclassrooms.com/en/courses/5261196-think-like-a-computer-the-logic-of-programming" target="_blank" rel="noopener">https://openclassrooms.com/en/courses/5261196-think-like-a-computer-the-logic-of-programming</a></li>
<li>Introduction to Computer Science using Java - <a href="http://programmedlessons.org/Java9/index.html#part02" target="_blank" rel="noopener">http://programmedlessons.org/Java9/index.html#part02</a></li>
<li>Python 100 天从新手到大师 - <a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/qrcode.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2019/11/27/gao-bing-fa-bian-cheng-xue-xi-2-xian-cheng-tong-xin-xiang-jie/">
      高并发编程学习(2)——线程通信详解
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              

            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2019年11月27日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142243.png" alt=""></p>
<blockquote>
<p>前序文章</p>
<ul>
<li>高并发编程学习(1)——并发基础 - <a href="https://www.wmyskxz.com/2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/">https://www.wmyskxz.com/2019/11/26/gao-bing-fa-bian-cheng-xue-xi-1-bing-fa-ji-chu/</a></li>
</ul>
</blockquote>
<h1 id="一、经典的生产者消费者案例"><a href="#一、经典的生产者消费者案例" class="headerlink" title="一、经典的生产者消费者案例"></a>一、经典的生产者消费者案例</h1><hr>
<p>上一篇文章我们提到一个应用可以创建多个线程去执行不同的任务，如果这些任务之间有着某种关系，那么线程之间<strong>必须能够通信</strong>来协调完成工作。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142251.png" alt=""></p>
<p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem）就是典型的多线程同步案例，它也被称为<strong>有限缓冲问题</strong>（英语：Bounded-buffer problem）。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA" target="_blank" rel="noopener" title="缓冲区">缓冲区</a>的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong>(摘自维基百科：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者消费者问题</a>)</p>
<ul>
<li><strong>注意</strong>： 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差；</li>
</ul>
<h2 id="准备基础代码：无通信的生产者消费者"><a href="#准备基础代码：无通信的生产者消费者" class="headerlink" title="准备基础代码：无通信的生产者消费者"></a>准备基础代码：无通信的生产者消费者</h2><p>我们来自己编写一个例子：一个生产者，一个消费者，并且让他们让他们使用同一个共享资源，并且我们期望的是生产者生产一条放到共享资源中，消费者就会对应地消费一条。</p>
<p>我们先来模拟一个简单的共享资源对象：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareResource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String gender<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟生产者向共享资源对象中存储数据
     *
     * @param name
     * @param gender
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟消费者从共享资源中取出数据
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>然后来编写我们的生产者，使用循环来交替地向共享资源中添加不同的数据：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> ShareResource shareResource<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>ShareResource shareResource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>shareResource <span class="token operator">=</span> shareResource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                shareResource<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"凤姐"</span><span class="token punctuation">,</span> <span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                shareResource<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>接着让我们的消费者不停地消费生产者产生的数据：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> ShareResource shareResource<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>ShareResource shareResource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>shareResource <span class="token operator">=</span> shareResource<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            shareResource<span class="token punctuation">.</span><span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>然后我们写一段测试代码，来看看效果：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建生产者和消费者的共享资源对象</span>
    ShareResource shareResource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动生产者线程</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>shareResource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 启动消费者线程</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>shareResource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们运行发现出现了诡异的现象，所有的生产者都似乎消费到了同一条数据：</p>
<pre><code>张三-男
张三-男
....以下全是张三-男....</code></pre><p>为什么会出现这样的情况呢？照理说，我的生产者在交替地向共享资源中生产数据，消费者也应该交替消费才对呀..我们大胆猜测一下，会不会是因为消费者是直接循环了 30 次打印共享资源中的数据，而此时生产者还没有来得及更新共享资源中的数据，消费者就已经连续打印了 30 次了，所以我们让消费者消费的时候以及生产者生产的时候都小睡个 10 ms 来缓解消费太快 or 生产太快带来的影响，也让现象更明显一些：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 模拟生产者向共享资源对象中存储数据
 *
 * @param name
 * @param gender
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 模拟消费者从共享资源中取出数据
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>再次运行代码，发现了出现了以下的几种情况：</p>
<ul>
<li><strong>重复消费</strong>：消费者连续地出现两次相同的消费情况（张三-男/ 张三-男）；</li>
<li><strong>性别紊乱</strong>：消费者消费到了脏数据（张三-女/ 凤姐-男）；</li>
</ul>
<h2 id="分析出现问题的原因"><a href="#分析出现问题的原因" class="headerlink" title="分析出现问题的原因"></a>分析出现问题的原因</h2><ul>
<li><strong>重复消费</strong>：我们先来看看<strong>重复消费</strong>的问题，当生产者生产出一条数据的时候，消费者正确地消费了一条，但是当消费者再来共享资源中消费的时候，生产者还没有准备好新的一条数据，所以消费者就又消费到老数据了，<strong>这其中的根本原因是生产者和消费者的速率不一致</strong>。</li>
<li><strong>性别紊乱</strong>：再来分析第二种情况。不同于上面的情况，消费者在消费第二条数据时，生产者也正在生产新的数据，但是尴尬的是，生产者只生产了一半儿（也就是该执行完 <code>this.name = name</code>），也就是还没有来得及给 <code>gender</code> 赋值就被消费者给取走消费了.. 造成这样情况的<strong>根本原因是没有保证生产者生产数据的原子性</strong>。</li>
</ul>
<h2 id="解决出现的问题"><a href="#解决出现的问题" class="headerlink" title="解决出现的问题"></a>解决出现的问题</h2><h3 id="加锁解决性别紊乱"><a href="#加锁解决性别紊乱" class="headerlink" title="加锁解决性别紊乱"></a>加锁解决性别紊乱</h3><p>我们先来解决<strong>性别紊乱</strong>，也就是<strong>原子性</strong>的问题吧，上一篇文章里我们也提到了，对于这样的原子性操作，解决方法也很简单：<strong>加锁</strong>。稍微改造一下就好了：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 模拟生产者向共享资源对象中存储数据
 *
 * @param name
 * @param gender
 */</span>
<span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 模拟消费者从共享资源中取出数据
 */</span>
<span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>我们在方法前面都加上了 <code>synchronized</code> 关键字，来保证每一次读取和修改都只能是一个线程，这是因为当 <code>synchronized</code> 修饰在普通同步方法上时，它会自动锁住当前实例对象，也就是说这样改造之后读/ 写操作同时只能进行其一；</li>
<li>我把 <code>push</code> 方法小睡的代码改在了赋值 <code>name</code> 和 <code>gender</code> 的中间，以强化验证原子性操作是否成功，因为如果不是原子性的话，就很可能出现赋值 <code>name</code> 还没赋值给 <code>gender</code> 就被取走的情况，小睡一会儿是为了加强这种情况的出现概率（可以试着把 <code>synchronized</code> 去掉看看效果）；</li>
</ul>
<p>运行代码后发现，并没有出现性别紊乱的现象了，但是重复消费仍然存在。</p>
<h3 id="等待唤醒机制解决重复消费"><a href="#等待唤醒机制解决重复消费" class="headerlink" title="等待唤醒机制解决重复消费"></a>等待唤醒机制解决重复消费</h3><p>我们期望的是 <code>张三-男</code> 和 <code>凤姐-女</code> 交替出现，而不是有重复消费的情况，所以我们的生产者和消费者之间需要一点沟通，最容易想到的解决方法是，我们新增加一个标志位，然后在消费者中使用 <code>while</code> 循环判断，不满足条件则不消费，条件满足则退出 <code>while</code> 循环，从而完成消费者的工作。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> desire<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这样做的目的就是为了防止「过快的无效尝试」，这种方法看似能够实现所需的功能，但是却存在如下的问题：</p>
<ul>
<li><strong>1）难以确保及时性</strong>。在睡眠时，基本不消耗处理器的资源，但是如果睡得过久，就不能及时发现条件已经变化，也就是及时性难以保证；</li>
<li><strong>2）难以降低开销</strong>。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能够更加迅速地发现条件变化，但是却可能消耗更多的处理资源，造成了无端的浪费。</li>
</ul>
<p>以上两个问题吗，看似矛盾难以调和，但是 Java 通过内置的等待/ 通知机制能够很好地解决这个矛盾并实现所需的功能。</p>
<p><strong>等待/ 通知机制</strong>，是指一个线程 A 调用了对象 O 的 <code>wait()</code> 方法进入等待状态，而另一个线程 B 调用了对象 O 的 <code>notifyAll()</code> 方法，线程 A 收到通知后从对象 O 的 <code>wait()</code> 方法返回，进而执行后续操作。上述两个线程都是通过对象 O 来完成交互的，而对象上的 <code>wait</code> 和 <code>notify/ notifyAll</code> 的关系就如同<strong>开关信号</strong>一样，用来完成等待方和通知方之间的交互工作。</p>
<blockquote>
<p>这里有一个比较奇怪的点是，为什么看起来像是线程之间操作的 <code>wait</code> 和 <code>notify/ notifyAll</code> 方法会是 <code>Object</code> 类中的方法，而不是 <code>Thread</code> 类中的方法呢？</p>
<ul>
<li><strong>简单来说</strong>：因为 <code>synchronized</code> 中的这把锁可以是任意对象，因为要满足任意对象都能够调用，所以属于 <code>Object</code> 类；</li>
<li><strong>专业点说</strong>：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的 <code>notify</code> 唤醒，不可以对不同锁中的线程进行唤醒。<strong>也就是说，等待和唤醒必须是同一个锁</strong>。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在 <code>Object</code> 类中。</li>
</ul>
</blockquote>
<p>好，简单介绍完等待/ 通知机制，我们开始改造吧：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareResource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String gender<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新增加一个标志位，表示共享资源是否为空，默认为 true</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟生产者向共享资源对象中存储数据
     *
     * @param name
     * @param gender
     */</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 当前共享资源不为空的时，则等待消费者来消费</span>
                <span class="token comment" spellcheck="true">// 使用同步锁对象来调用，表示当前线程释放同步锁，进入等待池，只能被其他线程所唤醒</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 开始生产</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束唤醒一个消费者来消费</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟消费者从共享资源中取出数据
     */</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 为空则等着生产者进行生产</span>
                <span class="token comment" spellcheck="true">// 使用同步锁对象来调用，表示当前线程释放同步锁，进入等待池，只能被其他线程所唤醒</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 消费开始</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束唤醒一个生产者去生产</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>我们期望生产者生产一条，然后就去通知消费者消费一条，那么在生产和消费之前，都需要考虑当前是否需要生产 or 消费，所以我们新增了一个标志位来判断，如果不满足则等待；</li>
<li>被通知后仍然要检查条件，条件满足，则执行我们相应的生产 or 消费的逻辑，然后改变条件（这里是 <code>isEmpty</code>），并且通知所有等待在对象上的线程；</li>
<li><strong>注意</strong>：上面的代码中通知使用的 <code>notify()</code> 方法，这是因为例子中写死了只有一个消费者和生产者，在实际情况中建议还是使用 <code>notifyAll()</code> 方法，这样多个消费和生产者逻辑也能够保证（可以自己试一下）；</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过初始版本一步步地分析问题和解决问题，我们就差不多写出了我们经典生产者消费者的经典代码，但通常消费和生产的逻辑是写在各自的消费者和生产者代码里的，这里我为了方便阅读，把他们都抽离到了共享资源上，我们可以简单地再来回顾一下这个消费生产和等待通知的整个过程：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142305.png" alt=""></p>
<p>以上就是关于生产者生产一条数据，消费者消费一次的过程了，涉及的一些具体细节我们下面来说。</p>
<h1 id="二、线程间的通信方式"><a href="#二、线程间的通信方式" class="headerlink" title="二、线程间的通信方式"></a>二、线程间的通信方式</h1><hr>
<h2 id="等待唤醒机制的替代：Lock-和-Condition"><a href="#等待唤醒机制的替代：Lock-和-Condition" class="headerlink" title="等待唤醒机制的替代：Lock 和 Condition"></a>等待唤醒机制的替代：Lock 和 Condition</h2><p>我们从上面的中看到了 <code>wait()</code> 和 <code>notify()</code> 方法，只能被同步监听锁对象来调用，否则就会报出 <code>IllegalMonitorZStateException</code> 的异常，那么现在问题来了，我们在上一篇提到的 <code>Lock</code> 机制根本就没有同步锁了，也就是没有自动获取锁和自动释放锁的概念，因为没有同步锁，也就意味着 <code>Lock</code> 机制不能调用 <code>wait</code> 和 <code>notify</code> 方法，我们怎么办呢？</p>
<p>好在 Java 5 中提供了 Lock 机制的同时也提供了用于 Lock 机制控制通信的 Condition 接口，如果大家理解了上面说到的 <code>Object.wait()</code> 和 <code>Object.notify()</code> 方法的话，那么就能很容易地理解 Condition 对象了。</p>
<p>它和 <code>wait()</code> 和 <code>notify()</code> 方法的作用是大致相同的，只不过后者是配合 <code>synchronized</code> 关键字使用的，而 Condition 是与重入锁相关联的。通过 Lock 接口（重入锁就实现了这一接口）的 <code>newCondition()</code> 方法可以生成一个与当前重入锁绑定的 Condition 实例。利用 Condition 对象，我们就可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。</p>
<p>我们拿上面的生产者消费者来举例，修改成 Lock 和 Condition 代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareResource</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String gender<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新增加一个标志位，表示共享资源是否为空，默认为 true</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Condition condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟生产者向共享资源对象中存储数据
     *
     * @param name
     * @param gender
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 当前共享资源不为空的时，则等待消费者来消费</span>
                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 开始生产</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 生产结束唤醒消费者来消费</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 模拟消费者从共享资源中取出数据
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 为空则等着生产者进行生产</span>
                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 消费开始</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束</span>
            isEmpty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 消费结束唤醒生产者去生产</span>
            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在 JDK 内部，重入锁和 Condition 对象被广泛地使用，以 ArrayBlockingQueue 为例，它的 <code>put()</code> 方法实现如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Main lock guarding all access */</span>
<span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** Condition for waiting takes */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** Condition for waiting puts */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 构造函数，初始化锁以及对应的 Condition 对象</span>
<span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>
    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 等待队列有足够的空间</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1;</span>
    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>
    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 通知需要 take() 的线程，队列已有数据</span>
    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>同理，对应的 <code>take()</code> 方法实现如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 如果队列为空，则消费者队列要等待一个非空的信号</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="允许多个线程同时访问：信号量-Semaphore"><a href="#允许多个线程同时访问：信号量-Semaphore" class="headerlink" title="允许多个线程同时访问：信号量(Semaphore)"></a>允许多个线程同时访问：信号量(Semaphore)</h2><blockquote>
<p>以下内容摘录 or 改编自 《实战 Java 高并发程序设计》 3.1.3 节的内容</p>
</blockquote>
<p>信号量为多线程协作提供了更为强大的控制方法。广义上说，信号量是对锁的扩展，无论是内部锁 synchronized 还是重入锁 ReentrantLock，一次都只允许一个线程访问一个资源，而<strong>信号量却可以指定多个线程，同时访问某一个资源</strong>。信号量主要提供了以下构造函数：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 第二个参数可以指定是否公平</span></code></pre>
<p>在构造信号量对象时，必须要指定信号量的准入数，即同时能申请多少个许可。当每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。信号量的主要逻辑如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquireUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<ul>
<li><code>acquire()</code> 方法尝试获得一个准入的许可。若无法获得，则线程会等待，直到有线程释放一个许可或者当前线程被中断。</li>
<li><code>acquireUninterruptibly()</code> 方法和 <code>acquire()</code> 方法类似，但是不响应中断。</li>
<li><code>tryAcquire()</code> 尝试获得一个许可，如果成功则返回 true，失败则返回 false，它不会进行等待，立即返回。</li>
<li><code>release()</code> 用于在线程访问资源结束后，释放一个许可，以使其他等待许可的线程可以进行资源访问。</li>
</ul>
<p>在 JDK 的官方 Javadoc 中，就有一个有关信号量使用的简单实例，有兴趣的读者可以自行去翻阅一下，这里给出一个更傻瓜化的例子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemapDemo</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">final</span> Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 模拟耗时操作</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":done!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> SemapDemo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SemapDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>执行程序，就会发现系统以 5 个线程为单位，依次输出带有线程 ID 的提示文本。</p>
<p><strong>在实现上，Semaphore 借助了线程同步框架 AQS（AbstractQueuedSynchornizer）</strong>，同样借助了 AQS 来实现的是 Java 中可重入锁的实现。AQS 的强大之处在于，你仅仅需要继承它，然后使用它提供的 api 就可以实现任意复杂的线程同步方案，AQS 为我们做了大部分的同步工作，所以这里不细说，之后再来详细探究一下…</p>
<h2 id="我等着你：Thread-join"><a href="#我等着你：Thread-join" class="headerlink" title="我等着你：Thread.join()"></a>我等着你：Thread.join()</h2><p>如果一个线程 A 执行了 <code>thread.join()</code> 方法，其含义是：<strong>当前线程 A 等待 thread 线程终止之后才从 <code>thread.join()</code> 返回</strong>。线程 Thread 除了提供 <code>join()</code> 方法之外，还提供了 <code>join(long millis)</code> 和 <code>join(long millis, int nanos)</code> 两个具备超时特性的方法。这两个超时方法表示，如果线程 Thread 在给定的超时时间里没有终止，那么将会从该超时方法中返回。</p>
<p>在下面的代码中，我们创建了 10 个线程，编号 0 ~ 9，每个线程调用前一个线程的 <code>join()</code> 方法，也就是线程 0 结束了，线程 1 才能从 <code>join()</code> 方法中返回，而线程 0 需要等待 main 线程结束。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Join</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread previous <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span>
            Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Domino</span><span class="token punctuation">(</span>previous<span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            previous <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" terminate. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Domino</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> Thread thread<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Domino</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" terminate. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>运行程序，可以看到下列输出：</p>
<pre><code>main terminate. 
0 terminate. 
1 terminate. 
2 terminate. 
3 terminate. 
4 terminate. 
5 terminate. 
6 terminate. 
7 terminate. 
8 terminate. 
9 terminate. </code></pre><p>说明每个线程终止的前提都是前驱线程的终止，每个线程等待前驱线程结束后，才从 <code>join()</code> 方法中返回，这里涉及了等待/ 通知机制，在 JDK 的源码中，我们可以看到 <code>join()</code> 的方法如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">long</span> base <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"timeout value is negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 条件不满足则继续等待</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 条件符合则返回</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> delay <span class="token operator">=</span> millis <span class="token operator">-</span> now<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
            now <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> base<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>当线程终止时，会调用线程自身的 <code>notifyAll()</code> 方法，会通知所有等待在该线程对象上的线程</strong>。可以看到 <code>join()</code> 方法的逻辑结构跟我们上面写的生产者消费者类似，即加锁、循环和处理逻辑三个步骤。</p>
<h1 id="三、线程之间的数据交互"><a href="#三、线程之间的数据交互" class="headerlink" title="三、线程之间的数据交互"></a>三、线程之间的数据交互</h1><hr>
<h2 id="保证可见性：volatile-关键字"><a href="#保证可见性：volatile-关键字" class="headerlink" title="保证可见性：volatile 关键字"></a>保证可见性：volatile 关键字</h2><p>我们先从一个有趣的例子入手：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> isOver <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>isOver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程已感知到 isOver 置为 true，线程正常返回!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    isOver <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"isOver 已置为 true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们开启了一个主线程和一个子线程，我们期望子线程能够感知到 <code>isOver</code> 变量的变化以结束掉死循环正常返回，但是运行程序却发现并不是像我们期望的那样发生，子线程一直处在了死循环的状态！</p>
<p><strong>为什么会这样呢？</strong></p>
<h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>关于这一点，我们有几点需要说明，首先需要搞懂 Java 的内存模型：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142324.png" alt=""></p>
<p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p><strong>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中</strong>。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。<strong>不同的线程之间也无法直接访问对方工作内存中的变量</strong>，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。</p>
<p><strong>那么不同的线程之间是如何通信的呢？</strong></p>
<p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142335.png" alt=""></p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 更新过的共享变量刷新到主内存中去</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量</li>
</ol>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142342.png" alt=""></p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 <code>wait()</code> 和 <code>notify()</code>。</p>
<p>说回刚才出现的问题，就很容易理解了：每个线程都有独占的内存区域，如操作栈、本地变量表等。<strong>线程本地保存了引用变量在堆内存中的副本，线程对变量的所有操作都在本地内存区域中进行，执行结束后再同步到堆内存中去</strong>。也就是说，我们在主线程中修改的 <code>isOver</code> 的值并没有被子线程读取到（没有被刷入主内存），也就造成了子线程对于 <code>isOver</code> 变量不可见。</p>
<p>解决方法也很简单，只需要在 <code>isOver</code> 变量前加入 <code>volatile</code> 关键字就可以了，这是<strong>因为加入了 <code>volatile</code> 修饰的变量允许直接与主内存交互，进行读写操作</strong>，保证可见性。</p>
<h2 id="指令重排-happen-before-原则"><a href="#指令重排-happen-before-原则" class="headerlink" title="指令重排/ happen-before 原则"></a>指令重排/ happen-before 原则</h2><p>再从另一个有趣的例子中入手，这是在高并发场景下会存在的问题：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LazyInitDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> TransationService service <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> TransationService <span class="token function">getTransationService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>service <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>service <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransationService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这是一个典型的双重检查锁定思想，这段代码也是一个典型的双重检查锁定（Double-checked Locking）问题。<strong>在高并发的情况下，该对象引用在没有同步的情况下进行读写操作，导致用户可能会获取未构造完成的对象</strong>。</p>
<p>这是因为<strong>指令优化</strong>的结果。<strong>计算机不会根据代码顺序按部就班地执行相关指令</strong>，我们来举一个借书的例子：假如你要去还书并且想要借一个《高并发编程学习》系列丛书，而你的室友恰好也要还书，并且还想让你帮忙借一本《Java 从入门到放弃》。</p>
<p>这件事乍一看有两件事：你的事和你室友的事。先办完你的事，再开始处理你室友的事情是属于单线程的死板行为，此时你会潜意识地进行<strong>「优化」</strong>，例如你可以把你要还的书和你室友需要还的书一起还了，再一起把想要借的书借出来，这其实就相当于合并数据进行存取的操作过程了。</p>
<p>我们知道一条指令的执行是可以分成很多步骤的，简单地说，可以分为：</p>
<ul>
<li>取值 IF</li>
<li>译码和去寄存器操作数 ID</li>
<li>执行或者有效地址计算 EX</li>
<li>存储器访问 MEM</li>
<li>写回 WB</li>
</ul>
<p>由于每一个步骤可能使用不同的硬件完成，因此，聪明的工程师就发明了流水线技术来执行指令，如下图所示：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142349.png" alt=""></p>
<p>可以看到，当第 2 条指令执行时，第 1 条执行其实并没有执行完，确切地说第一条指令还没有开始执行，只是刚刚完成了取值操作而已。这样的好处非常明显，假如这里每一个步骤都需要花费 1 毫秒，那么指令 2 等待指令 1 完全执行后再执行，则需要等待 5 毫秒，而使用流水线指令，指令 2 只需要等待 1 毫秒就可以执行了。如此大的性能提升，当然让人眼红。</p>
<p>回到最初的问题，我们分析一下：<strong>对于 Java 编译器来说，初始化 TransactionService 实例和将对象地址写到 <code>service</code> 字段并非原子操作，且这两个阶段的执行顺序是未定义的</strong>。加入某个线程执行 <code>new TransactionService()</code> 时，构造方法还未被调用，编译器仅仅为该对象分配了内存空间并设为默认值，此时若另一个线程调用 <code>getTransactionService()</code> 方法，由于 <code>service != null</code>，但是此时 <code>service</code> 对象还没有被赋予真正的有效值，从而无法取到正确的 <code>service</code> 单例对象。</p>
<p>对于此问题，一种较为简单的解决方案就是用 <code>volatile</code> 关键字修饰目标属性（适用于 JDK5 及以上版本），这样 <code>service</code> 就限制了编译器对它的相关读写操作，对它的读写操作进行指令重排，确定对象实例化之后才返回引用。</p>
<p>另外<strong>指令重排也有自己的规则</strong>，并非所有的指令都可以随意改变执行位置，下面列举一下基本的原则：</p>
<ul>
<li><strong>程序次序规则</strong>：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li><strong>锁定规则</strong>：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；</li>
<li><strong>volatile 变量规则</strong>：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li><strong>传递规则</strong>：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C；</li>
<li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code> 方法先行发生于此线程的每个一个动作；</li>
<li><strong>线程中断规则</strong>：对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li><strong>线程终结规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值手段检测到线程已经终止执行；</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的 <code>finalize()</code> 方法的开始；</li>
</ul>
<h3 id="volatile-不保证原子性"><a href="#volatile-不保证原子性" class="headerlink" title="volatile 不保证原子性"></a>volatile 不保证原子性</h3><p>volatile 解决的是多线程共享变量的可见性问题，类似于 synchronized，但不具备 synchronized 的互斥性。所以对 volatile 变量的操作并非都具有原子性，例如我们用下面的例子来说明：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileNotAtomic</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> count <span class="token operator">=</span> 0L<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread subtractThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubstractThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        subtractThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUMBER<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 等待减法线程结束</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>subtractThread<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count 最后的值为: "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SubstractThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUMBER<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>多次执行后，发现结果基本都不为 0。只有在 <code>count++</code> 和 <code>count--</code> 两处都进行加锁时，才能正确的返回 0，了解 Java 的童鞋都应该知道这 <code>count++</code> 和 <code>count--</code> 都不是一个原子操作，这里就不作说明了。</p>
<h3 id="volatile-的使用优化"><a href="#volatile-的使用优化" class="headerlink" title="volatile 的使用优化"></a>volatile 的使用优化</h3><p>在了解一点吧，注明的并发编程大师 Doug lea 在 JDK 7 的并发包里新增一个队列集合类 LinkedTransferQueue，它在使用 volatile 变量时，用一种<strong>追加字节的方式来优化对列出队和入队的性能</strong>，具体的可以看一下下列的链接，这里就不具体说明了。</p>
<ul>
<li>追加字节方式来优化队列性能？ - <a href="https://my.oschina.net/u/3694754/blog/2990652" target="_blank" rel="noopener">https://my.oschina.net/u/3694754/blog/2990652</a></li>
</ul>
<h2 id="保证原子性：synchronized"><a href="#保证原子性：synchronized" class="headerlink" title="保证原子性：synchronized"></a>保证原子性：synchronized</h2><p>Java 中任何一个对象都有一个唯一与之关联的锁，这样的锁作为该对象的一系列标志位存储在对象信息的头部。Java 对象头里的 Mark Word 里默认的存放的对象的 Hashcode/ 分代年龄和锁标记位。32 为JVM Mark Word 默认存储结构如下：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142400.png" alt=""></p>
<p>Java SE 1.6中，锁一共有 4 种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<ul>
<li><p><strong>偏向锁的获取</strong>：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
</li>
<li><p><strong>偏向锁的撤销</strong>：偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
</li>
</ul>
<p>下图线程 1 展示了偏向锁获取的过程，线程 2 展示了偏向锁撤销的过程。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142411.png" alt=""></p>
<h3 id="轻量级锁和自旋锁"><a href="#轻量级锁和自旋锁" class="headerlink" title="轻量级锁和自旋锁"></a>轻量级锁和自旋锁</h3><p>如果偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。</p>
<p>线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 <strong>Displaced Mark Word</strong>。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用<strong>自旋</strong>（自己执行几个空循环再进行尝试）来获取锁。</p>
<p>轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。<strong>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁</strong>。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142421.png" alt=""></p>
<h3 id="几种锁的比较"><a href="#几种锁的比较" class="headerlink" title="几种锁的比较"></a>几种锁的比较</h3><p>下图就简单概括了一下几种锁的比较：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142427.png" alt=""></p>
<h2 id="每人一支笔：ThreadLocal"><a href="#每人一支笔：ThreadLocal" class="headerlink" title="每人一支笔：ThreadLocal"></a>每人一支笔：ThreadLocal</h2><p>除了控制资源的访问外，我们还可以通过增加资源来保证所有对象的线程安全。比如，让 100 个人填写个人信息表，如果只有一支笔，那么大家就得挨个写，对于管理人员来说，必须保证大家不会去哄抢这仅存的一支笔，否则，谁也填不完。从另外一个角度出发，我们可以干脆就准备 100 支笔，那么所有人都可以各自为营，很快就能完成表格的填写工作。</p>
<p>如果说锁是使用第一种思路，那么 ThreadLocal 就是使用第二种思路了。</p>
<p>当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p>
<p><strong>ThreadLocal 内部实现机制</strong>：</p>
<p><img src="https://blog-1259634016.cos.ap-chengdu.myqcloud.com/img/20191202142433.png" alt=""></p>
<ol>
<li><p>每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；</p>
</li>
<li><p>Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；</p>
</li>
<li><p>Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。</p>
</li>
</ol>
<h3 id="ThreadLodal-的副作用"><a href="#ThreadLodal-的副作用" class="headerlink" title="ThreadLodal 的副作用"></a>ThreadLodal 的副作用</h3><p>为了让线程安全地共享某个变量，JDK 开出了 ThreadLocal 这副药方，但「是药三分毒」，ThreadLocal 也有一定的副作用。<strong>主要问题是「产生脏数据」和「内存泄漏」</strong>。这两个问题通常是在线程池中使用 ThreadLocal 引发的，因为线程池有 <strong>「线程复用」</strong> 和 <strong>「内存常驻」</strong> 两个特点。</p>
<h3 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h3><p>线程复用会产生脏数据。<strong>由于线程池会重用 Thread 对象，那么与 Thread 绑定的类的静态属性 ThreadLocal 变量也会被重用</strong>。如果在实现的线程 <code>run()</code> 方法中不显式地 <code>remove()</code> 清理与线程相关的 ThreadLocal 信息，那么倘若下一个线程不调用 <code>set()</code> 设置初始值，就可能 <code>get()</code> 到重用的线程信息，包括 ThreadLocal 所关联的线程对象的 value 值。</p>
<p>为了方便理解，用一段简要代码来模拟，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirtyDataInThreadLocal</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 使用固定大小为 1 的线程池，说明上一个的线程属性会被下一个线程属性复用</span>
        ExecutorService pool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Mythread mythread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Mythread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 第 1 个线程 set 后，并没有进行 remove</span>
                <span class="token comment" spellcheck="true">// 而第二个线程由于某种原因没有进行 set 操作</span>
                threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", session info."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 线程是 "</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>执行结果：</p>
<pre><code>Thread-0 线程是 Thread-0, session info.
Thread-1 线程是 Thread-0, session info.</code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>在源码注释中提示使用 static 关键字来修饰 ThreadLocal。在此场景下，寄希望于 ThreadLocal 对象失去引用后，触发<strong>弱引用</strong>机制来回收 Entry 的 Value 就变得不现实了。在上面的例子中，如果不进行 <code>remove()</code> 操作，那么这个线程执行完成后，通过 ThreadLocal 对象持有的 String 对象是不会被释放的。</p>
<p>以上两个问题的解决办法很简单，就是在每次使用完 ThreadLocal 时，必须要及时调用 <code>remove()</code> 方法清理。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<ol>
<li>《Java 零基础入门教程》 - <a href="http://study.163.com/course/courseMain.htm?courseId=1003108028" target="_blank" rel="noopener" title="http://study.163.com/course/courseMain.htm?courseId=1003108028">http://study.163.com/course/courseMain.htm?courseId=1003108028</a></li>
<li>《Java 并发编程的艺术》</li>
<li>《码出高效 Java 开发手册》 - 杨冠宝（孤尽） 高海慧（鸣莎）著</li>
<li>Java面试知识点解析(二)——高并发编程篇 - <a href="https://www.wmyskxz.com/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/">https://www.wmyskxz.com/2018/05/10/java-mian-shi-zhi-shi-dian-jie-xi-er-gao-bing-fa-bian-cheng-pian/</a></li>
<li>让你彻底理解Synchronized - <a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">https://www.jianshu.com/p/d53bf830fa09</a></li>
<li>《Offer来了 - Java面试核心知识点精讲》 - 王磊 编著</li>
<li>《实战Java高并发程序设计》 - 葛一鸣 郭超 编著</li>
</ol>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2019/11/18/tan-yi-tan-yi-lai-dao-zhi-yuan-ze/">
      谈一谈依赖倒置原则
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E5%9F%BA%E7%A1%80/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java基础</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2019年11月18日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>为获得良好的阅读体验，请访问原文：<a href="https://www.wmyskxz.com/2019/11/18/tan-yi-tan-yi-lai-dao-zhi-yuan-ze/">传送门</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/7896890-992a571faa26088f.png" alt=""></p>
<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><hr>
<p><strong>依赖倒置原则（Dependence Inversion Principle，DIP）是指设计代码结构时，高层模块不应该依赖低层模块，二者都应该依赖其抽象。</strong></p>
<p>抽象不应该依赖细节，细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并且能够降低修改程序所造成的风险。</p>
<h1 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a>二、为什么</h1><hr>
<h2 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子"></a>先来看一个例子</h2><p>可是依赖倒置原则是怎么做到的呢？我们先来看一个例子：一个爱学习的「我没有三颗心脏」同学现在正在学习「设计模式」和「Java」的课程，伪代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wmyskxz</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">studyJavaCourse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"「我没有三颗心脏」同学正在学习「Java」课程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">studyDesignPatternCourse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"「我没有三颗心脏」同学正在学习「设计模式」课程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>我们来模拟上层调用一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Wmyskxz wmyskxz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wmyskxz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wmyskxz<span class="token punctuation">.</span><span class="token function">studyJavaCourse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wmyskxz<span class="token punctuation">.</span><span class="token function">studyDesignPatternCourse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="原因一：有效控制影响范围"><a href="#原因一：有效控制影响范围" class="headerlink" title="原因一：有效控制影响范围"></a>原因一：有效控制影响范围</h2><p>由于「我没有三颗心脏」同学热爱学习，随着学习兴趣的 “暴增”，可能会继续学习 AI（人工智能）的课程。这个时候，<strong>因为「业务的扩展」，要从底层实现到高层调用依次地修改代码。</strong></p>
<p>我们需要在 Wmyskxz 类中新增 <code>studyAICourse()</code> 方法，也需要在高层调用中增加调用，这样一来，系统发布后，其实是非常不稳定的。显然在这个简单的例子中，我们还可以自信地认为，我们能 Hold 住这一次的修改带来的影响，因为<strong>都是新增的代码</strong>，我们回归的时候也可以很好地 cover 住，但实际的情况和实际的软件环境要复杂得多。</p>
<p><strong>最理想的情况就是，我们已经编写好的代码可以 “万年不变”</strong>，这就意味着已经覆盖的单元测试可以不用修改，已经存在的行为可以保证保持不变，这就意味着「稳定」。<strong>任何代码上的修改带来的影响都是有未知风险的，不论看上去多么简单。</strong></p>
<h2 id="原因二：增强代码可读性和可维护性"><a href="#原因二：增强代码可读性和可维护性" class="headerlink" title="原因二：增强代码可读性和可维护性"></a>原因二：增强代码可读性和可维护性</h2><p>另外一点，你有没有发现其实加上新增的 AI 课程的学习，他们三节课本质上行为都是一样的，如果我们任由这样行为近乎一样的代码在我们的类里面肆意扩展的话，很快我们的类就会变得臃肿不堪，等到我们意识到不得不重构这个类以缓解这样的情况的时候，或许成本已经变得高得可怕了。</p>
<h2 id="原因三：降低耦合"><a href="#原因三：降低耦合" class="headerlink" title="原因三：降低耦合"></a>原因三：降低耦合</h2><p>《资本论》中有这样一段描述：</p>
<blockquote>
<p>在商品经济的萌芽时期，出现了物物交换。假设你要买一个 iPhone，卖 iPhone 的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的 APP 来换他一头猪，他说换猪可以，但是得用一条金项链来换…</p>
</blockquote>
<p>所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象——也就是货币——来进行交换，这样一来耦合度就大为降低了。</p>
<h1 id="三、怎么做"><a href="#三、怎么做" class="headerlink" title="三、怎么做"></a>三、怎么做</h1><hr>
<p>我们现在的代码是上层直接依赖低层实现，现在我们需要定义一个抽象的 ICourse 接口，来对这种强依赖进行解耦（就像上面《资本论》中的例子那样）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/7896890-39fbf69d60dc4111.png" alt=""></p>
<p>接下来我们可以参考一下伪代码，先定一个课程的抽象 ICourse 接口：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICourse</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>然后编写分别为 <code>JavaCourse</code> 和 <code>DesignPatternCourse</code> 编写一个类：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaCourse</span> <span class="token keyword">implements</span> <span class="token class-name">ICourse</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"「我没有三颗心脏」同学正在学习「Java」课程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DesignPatternCourse</span> <span class="token keyword">implements</span> <span class="token class-name">ICourse</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"「我没有三颗心脏」同学正在学习「设计模式」课程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>然后把 Wmyskxz 类改造成如下的样子：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wmyskxz</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span>ICourse course<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        course<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>再来是我们的调用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Wmyskxz wmyskxz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Wmyskxz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wmyskxz<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JavaCourse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    wmyskxz<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DesignPatternCourse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这时候我们再来看代码，无论「我没有三颗心脏」的兴趣怎么暴涨，对于新的课程，都只需要新建一个类，通过参数传递的方式告诉它，<strong>而不需要修改底层的代码。</strong>实际上这有点像大家熟悉的<strong>依赖注入</strong>的方式了。</p>
<p>总之，切记：<strong>以抽象为基准比以细节为基准搭建起来的架构要稳定得多</strong>，因此在拿到需求后，要面相接口编程，先顶层设计再细节地设计代码结构。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<ol>
<li><a href="https://www.cnblogs.com/aoyeyuyan/p/5495219.html" target="_blank" rel="noopener">https://www.cnblogs.com/aoyeyuyan/p/5495219.html</a> - 那些年搞不懂的高深术语——依赖倒置•控制反转•依赖注入•面向接口编程</li>
<li>《Spring 5 核心原理 与 30 个类手写实战》 - 谭勇德 著</li>
</ol>
<hr>
<p>按照惯例黏一个尾巴：</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>独立域名博客：wmyskxz.com<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz<br>分享自己的学习 &amp; 学习资料 &amp; 生活<br>想要交流的朋友也可以加qq群：3382693<br>钱</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2019/08/03/java8-liu-cao-zuo-ji-ben-shi-yong-xing-neng-ce-shi/">
      Java8流操作-基本使用&性能测试
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E5%9F%BA%E7%A1%80/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java基础</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2019年8月3日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>为获得更好的阅读体验，请访问原文：<a href="https://www.wmyskxz.com/2019/08/03/java8-liu-cao-zuo-ji-ben-shi-yong-xing-neng-ce-shi/">传送门</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-a7d61498c60e469f.png" alt=""></p>
<h1 id="一、流-Stream-简介"><a href="#一、流-Stream-简介" class="headerlink" title="一、流(Stream)简介"></a>一、流(Stream)简介</h1><hr>
<p>流是 Java8 中 API 的新成员，它允许你以<strong>声明式</strong>的方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。这有点儿像是我们操作数据库一样，例如我想要查询出热量较低的菜品名字我就可以像下面这样：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> dishes <span class="token keyword">WHERE</span> calorie <span class="token operator">&lt;</span> <span class="token number">400</span><span class="token punctuation">;</span></code></pre>
<p>您看，我们并没有对菜品的什么属性进行筛选（比如像之前使用迭代器一样每个做判断），我们只是表达了我们想要什么。那么为什么到了 Java 的集合中，这样做就不行了呢？</p>
<p>另外一点，如果我们想要处理大量的数据又该怎么办？是否是考虑使用多线程进行并发处理呢？如果是，那么可能编写的关于并发的代码比使用迭代器本身更加的复杂，而且调试起来也会变得麻烦。</p>
<p>基于以上的几点考虑，Java 设计者在 Java 8 版本中，引入了流的概念，来帮助您节约时间！并且有了 lambda 的参与，流操作的使用将更加顺畅！</p>
<h2 id="特点一：内部迭代"><a href="#特点一：内部迭代" class="headerlink" title="特点一：内部迭代"></a>特点一：内部迭代</h2><p>就现在来说，您可以把它简单的当成一种高级的迭代器（Iterator），或者是高级的 for 循环，区别在于，前面两者都是属于外部迭代，而<strong>流采用内部迭代。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-75e654c79727b555.png" alt=""></p>
<p>上图简要说明了内部迭代与外部迭代的差异，我们再举一个生活中实际的例子（引自《Java 8 实战》），比如您想让您两岁的孩子索菲亚把她的玩具都收到盒子里面去，你们之间可能会产生如下的对话：</p>
<ul>
<li>你：“索菲亚，我们把玩具收起来吧，地上还有玩具吗？”</li>
<li>索菲亚：“有，球。”</li>
<li>你：“好，把球放进盒子里面吧，还有吗？”</li>
<li>索菲亚：“有，那是我的娃娃。”</li>
<li>你：“好，把娃娃也放进去吧，还有吗？”</li>
<li>索菲亚：“有，有我的书。”</li>
<li>你：“好，把书也放进去，还有吗？”</li>
<li>索菲亚：“没有了。”</li>
<li>你：“好，我们收好啦。”</li>
</ul>
<p>这正是你每天都要对 Java 集合做的事情。你外部迭代了一个集合，显式地取出每个项目再加以处理，但是如果你只是跟索菲亚说：“把地上所有玩具都放进盒子里”，那么索菲亚就可以选择一手拿娃娃一手拿球，或是选择先拿离盒子最近的那个东西，再拿其他的东西。</p>
<p><strong>采用内部迭代，项目可以透明地并行处理，或者用优化的顺序进行处理，要是使用 Java 过去的外部迭代方法，这些优化都是很困难的。</strong></p>
<p>这或许有点鸡蛋里挑骨头，但这差不多就是 Java 8 引入流的原因了——Streams 库的内部迭代可以自动选择一种是和你硬件的数据表示和并行实现。</p>
<h2 id="特点二：只能遍历一次"><a href="#特点二：只能遍历一次" class="headerlink" title="特点二：只能遍历一次"></a>特点二：只能遍历一次</h2><p>请注意，和迭代器一样，流只能遍历一次。当流遍历完之后，我们就说这个流已经被消费掉了，你可以从原始数据那里重新获得一条新的流，但是却不允许消费已消费掉的流。例如下面代码就会抛出一个异常，说流已被消费掉了：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> title <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Wmyskxz"</span><span class="token punctuation">,</span> <span class="token string">"Is"</span><span class="token punctuation">,</span> <span class="token string">"Learning"</span><span class="token punctuation">,</span> <span class="token string">"Java8"</span><span class="token punctuation">,</span> <span class="token string">"In"</span><span class="token punctuation">,</span> <span class="token string">"Action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> s <span class="token operator">=</span> title<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 运行上面程序会报以下错误</span>
<span class="token comment" spellcheck="true">/*
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
    at java.util.stream.AbstractPipeline.sourceStageSpliterator(AbstractPipeline.java:279)
    at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)
    at Test1.main(Tester.java:17)
*/</span></code></pre>
<h2 id="特点三：方便的并行处理"><a href="#特点三：方便的并行处理" class="headerlink" title="特点三：方便的并行处理"></a>特点三：方便的并行处理</h2><p>Java 8 中不仅提供了方便的一些流操作（比如过滤、排序之类的），更重要的是对于并行处理有很好的支持，只需要加上 <code>.parallel()</code> 就行了！例如我们使用下面程序来说明一下多线程流操作的方便和快捷，并且与单线程做了一下对比：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StreamParallelDemo</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/** 总数 */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> total <span class="token operator">=</span> 100_000_000<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"本计算机的核数：%d"</span><span class="token punctuation">,</span> Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 产生1000w个随机数(1 ~ 100)，组成列表</span>
        Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">long</span> prevTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"单线程计算耗时：%d"</span><span class="token punctuation">,</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> prevTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        prevTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 只需要加上 .parallel() 就行了</span>
        list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"多线程计算耗时：%d"</span><span class="token punctuation">,</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> prevTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>以上程序分别使用了单线程流和多线程流计算了一千万个随机数的和，输出如下：</p>
<blockquote>
<p>本计算机的核数：8<br>655028378<br>单线程计算耗时：4159<br>655028378<br>多线程计算耗时：540</p>
</blockquote>
<p>并行流的内部使用了默认的 ForkJoinPool 分支/合并框架，它的默认线程数量就是你的处理器数量，这个值是由 <code>Runtime.getRuntime().availableProcessors()</code> 得到的（当然我们也可以全局设置这个值）。我们也不再去过度的操心加锁线程安全等一系列问题。</p>
<h2 id="二、流基本操作"><a href="#二、流基本操作" class="headerlink" title="二、流基本操作"></a>二、流基本操作</h2><hr>
<p>至少我们从上面了解到了，流操作似乎是一种很强大的工具，能够帮助我们节约我们时间的同时让我们程序可读性更高，下面我们就具体的来了解一下 Java 8 带来的新 API Stream，能给我们带来哪些操作。</p>
<h2 id="1、筛选和切片"><a href="#1、筛选和切片" class="headerlink" title="1、筛选和切片"></a>1、筛选和切片</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Stream 接口支持 <strong>filter</strong> 方法，该操作会接受一个返回 boolean 的函数作为参数，并返回一个包含所有符合该条件的流。例如，你可以这样选出所有以字母 w 开头的单词并打印：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> words <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"wmyskxz"</span><span class="token punctuation">,</span> <span class="token string">"say"</span><span class="token punctuation">,</span> <span class="token string">"wow"</span><span class="token punctuation">,</span> <span class="token string">"to"</span><span class="token punctuation">,</span> <span class="token string">"everybody"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>word <span class="token operator">-</span><span class="token operator">></span> word<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// wmyskxz</span>
<span class="token comment" spellcheck="true">// wow</span></code></pre>
<p>这个过程类似下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-f2fb24e64fc76686.png" alt=""></p>
<p>当然如果您不是想要输出而是想要返回一个集合，那么可以使用 <code>.collect(toList())</code>，就像下面这样：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> words <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"wmyskxz"</span><span class="token punctuation">,</span> <span class="token string">"say"</span><span class="token punctuation">,</span> <span class="token string">"wow"</span><span class="token punctuation">,</span> <span class="token string">"to"</span><span class="token punctuation">,</span> <span class="token string">"everybody"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> filteredWords <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                  <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>word <span class="token operator">-</span><span class="token operator">></span> word<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                                  <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>流还支持一个叫做 <strong>distinct</strong> 的方法，它会返回一个元素各异（根据流所生成的元素的 hashCode 和 equals 方法实现）的流。例如，以下代码会筛选出列表中所有的偶数，并确保没有重复：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> integer <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 2</span>
<span class="token comment" spellcheck="true">// 4</span></code></pre>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>流支持 <strong>limit(n)</strong> 方法，该方法会返回一个不超过给定长度的流，所需长度需要作为参数传递给 limit。如果流是有序的，则最多会返回前 n 个元素。比如，你可以建立一个 List，选出前 3 个元素：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> integer <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 2</span>
<span class="token comment" spellcheck="true">// 4</span>
<span class="token comment" spellcheck="true">// 6</span></code></pre>
<p>请注意虽然上述的集合是有序的，但 limit 本身并不会做任何排序的操作。</p>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>流还支持 <strong>skip(n)</strong> 方法，返回一个扔掉了前 n 个元素的流。如果流中元素不足 n 个，则返回一个空流。请注意 litmit 和 skip 是互补的！例如，下面这段程序，选出了所有的偶数并跳过了前两个输出：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>integer <span class="token operator">-</span><span class="token operator">></span> integer <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 6</span>
<span class="token comment" spellcheck="true">// 8</span></code></pre>
<h2 id="2、映射"><a href="#2、映射" class="headerlink" title="2、映射"></a>2、映射</h2><p>一个非常常见的数据处理套路就是从某些对象中选择信息。比如在 SQL 里，你可以从表中选择一列，Stream API 也通过 map 和 flatMap 方法提供了类似的工具。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>流支持 map 方法，他会接受一个函数作为参数。这个函数会被应用到每个元素身上吗，并将其映射成一个新的函数。例如，下面的代码把方法引用 <code>Words::getContent</code> 传给了 map 方法，来提取流中 Words 的具体内容：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Words<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Words</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Words</span><span class="token punctuation">(</span><span class="token string">"公众号"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Words</span><span class="token punctuation">(</span><span class="token string">"wmyskxz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
           <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Words<span class="token operator">:</span><span class="token operator">:</span>getContent<span class="token punctuation">)</span>
           <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Words</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String content<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 我没有三颗心脏</span>
<span class="token comment" spellcheck="true">// 公众号</span>
<span class="token comment" spellcheck="true">// wmyskxz</span></code></pre>
<p>但是如果你现在只想要找出每个 Words 具体内容的长度又该怎么办呢？我们可以再进行一次映射：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Words<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Words</span><span class="token punctuation">(</span><span class="token string">"我没有三颗心脏"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token keyword">new</span> <span class="token class-name">Words</span><span class="token punctuation">(</span><span class="token string">"公众号"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Words</span><span class="token punctuation">(</span><span class="token string">"wmyskxz"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
           <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Words<span class="token operator">:</span><span class="token operator">:</span>getWords<span class="token punctuation">)</span>
           <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>length<span class="token punctuation">)</span>
           <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Words</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String words<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 7</span>
<span class="token comment" spellcheck="true">// 3</span>
<span class="token comment" spellcheck="true">// 7</span></code></pre>
<h3 id="flatMap：流的扁平化"><a href="#flatMap：流的扁平化" class="headerlink" title="flatMap：流的扁平化"></a>flatMap：流的扁平化</h3><p>你已经看到我们是如何使用 map 方法来返回每个 Words 的具体长度了，现在让我们来扩展一下：对于一个 Words 集合，我需要知道这个集合里一共有多少个不相同的字符呢？例如，给定单词列表为：[“Hello”, “World”]，则需要返回的列表是：[“H”, “e”, “l”, “o”, “W”, “r”, “d”]。</p>
<p>您可能会觉得简单，而后写下下列<strong>错误</strong>的第一版本：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> words <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// [Ljava.lang.String;@238e0d81</span>
<span class="token comment" spellcheck="true">// [Ljava.lang.String;@31221be2</span></code></pre>
<p>为什么会这样呢？这个方法的问题自傲与，传递给 map 方法的 lambda 表达式为每个单词返回了一个 <code>String[]</code>，所以经过 map 方法之后返回的流就不是我们预想的 <code>Stream&lt;String&gt;</code>，而是 <code>Stream&lt;String[]&gt;</code>，下图就说明了这个问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-55e2df9d377af8e2.png" alt=""></p>
<p>幸好我们可以使用 <strong>flatMap</strong> 来解决这个问题：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> words <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Arrays<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// H</span>
<span class="token comment" spellcheck="true">// e</span>
<span class="token comment" spellcheck="true">// l</span>
<span class="token comment" spellcheck="true">// o</span>
<span class="token comment" spellcheck="true">// W</span>
<span class="token comment" spellcheck="true">// r</span>
<span class="token comment" spellcheck="true">// d</span></code></pre>
<p>使用 flatMap 方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。一言蔽之就是 flatMap 让你一个流中的每个值都转换成另一个六，然后把所有的流连接起来成为一个流，具体过程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-daa99ee5fc4ba797.png" alt=""></p>
<h2 id="3、查找和匹配"><a href="#3、查找和匹配" class="headerlink" title="3、查找和匹配"></a>3、查找和匹配</h2><p>另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性，Stream API 通过 <strong>allMatch</strong>、<strong>anyMatch</strong>、<strong>noneMatch</strong>、<strong>findFirst</strong> 和 <strong>findAny</strong> 方法提供了这样的工具(<em>其实到这里看名字就会大概能够知道怎么使用了</em>)。</p>
<p>我们简单的举两个例子就好。</p>
<p>比如，你可以用它来看看集合里面是否有偶数：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"集合里有偶数!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>再比如，你可以用来它来检验是否集合里都为偶数：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"集合里全是偶数!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>再或者，给定一个数字列表，找出第一个平方能被 3 整除的数：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> firstSquareDivisibledByThree <span class="token operator">=</span>
        numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
               <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">*</span> x<span class="token punctuation">)</span>
               <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> x <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
               <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstSquareDivisibledByThree<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 9</span></code></pre>
<blockquote>
<p><strong>Optional 简介：</strong><br><code>Optional&lt;T&gt;</code> 类是 <code>java.util.Optional</code> 包里的一个容器类，代表一个值存在或者不存在。在上面的代码中，<code>findFirst()</code> 可能什么元素都找不到，Java 8 的设计人员引入了 <code>Optional&lt;T&gt;</code>，这样就不用返回众所周知容易出问题的 null 了。我们在这里不对 <code>Optional</code> 做细致的讨论。</p>
</blockquote>
<h2 id="4、归约：reduce"><a href="#4、归约：reduce" class="headerlink" title="4、归约：reduce"></a>4、归约：reduce</h2><p>到目前为止，你见到过的终端操作(下面我们会说到这些操作其实分为中间操作和终端操作)都是返回一个 boolean（<code>allMatch</code> 之类的）、void（<code>forEach</code>）或 Optional 对象（<code>findFirst</code> 等）。你也见到过了使用 <code>collect</code> 来将流中的所有元素合并成一个 List。</p>
<p>接下来我们来接触更加复杂的一些操作，比如 “挑出单词中长度最长的的单词” 或是 “计算所有单词的总长度”。此类查询需要将流中的元素反复结合起来，得到一个值。这样的查询可以被归类为<strong>归约操作</strong>（将流归约成一个值）。</p>
<h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><p>在研究 reduce 之前，我们先来回顾一下我们在之前是如何对一个数字数组进行求和的：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 15</span></code></pre>
<p>numbers 中的每个元素都用加法运算符反复迭代来得到结果。通过反复使用加法，我们最终把一个数字列表<strong>归约</strong>成了一个数字。在这段代码中，我们一共使用了两个参数：</p>
<ul>
<li>sum：总和变量的初始值，在这里是 0；</li>
<li>x：用于接受 numbers 中的每一个元素，并与 sum 做加法操作不断迭代；</li>
</ul>
<p>要是还能把所有的数字相乘，而不用复制粘贴这段代码，岂不是很好？这正是 reduce 操作的用武之地，它对这种重复应用的模式做了抽象。你可以像下面这样对流中所有的元素求和：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// 15</span></code></pre>
<p>其中 reduce 接受了两个参数：</p>
<ul>
<li>一个初始值，这里是 0；</li>
<li>一个是 <code>BinaryOperator&lt;T&gt;</code> 来将两个元素结合起来产生一个新值，这里我们用的是 <code>lambda (a, b) -&gt; a + b</code>；</li>
</ul>
<p>你也可以很容易改造成所有元素相乘的形式，只需要将另一个 Lambda：<code>(a, b) -&gt; a * b</code> 传递给 reduce 就可以了：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> product <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>我们先来深入研究一下 reduce 是如何对一个数字流进行求和的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-29feabe9de67c576.png" alt=""></p>
<p>如上图所示一样的，reduce 每一次都把结果返回并与下一次的元素进行操作，比如第一次当遍历到元素 1 时，此时返回初始值 0 + 1 = 1，然后再用此时的返回值 1 与第二个元素进行叠加操作，如此往复，便完成了对数字列表的求和运算。</p>
<p>当然你也可以使用方法引用让这段代码更加简洁：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>无初始值</strong></p>
<p>reduce 还有一个重载的变体，它不接受初始值，但是会返回一个 Optional 对象(考虑到流中没有任何元素的情况)：</p>
<pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><p>有点类似于上面的操作，我们可以使用下面这样的 reduce 来计算流中的最大值or最小值：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 最大值</span>
Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> max <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Integer<span class="token operator">:</span><span class="token operator">:</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 最小值</span>
Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> max <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Integer<span class="token operator">:</span><span class="token operator">:</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="5、中间操作和结束操作（终端操作）"><a href="#5、中间操作和结束操作（终端操作）" class="headerlink" title="5、中间操作和结束操作（终端操作）"></a>5、中间操作和结束操作（终端操作）</h2><p><strong>Stream API 上的所有操作分为两类：中间操作和结束操作</strong>。中间操作只是一种标记，只有结束操作才会触发实际计算。</p>
<p><strong>中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)</strong>，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；</p>
<p><strong>结束操作又可以分为短路操作和非短路操作</strong>，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。 为了更好的理解流的中间操作和终端操作，可以通过下面的两段代码来看他们的执行过程：</p>
<pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\nA"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"C"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// A1B1C1</span>
<span class="token comment" spellcheck="true">// A2B2C2</span>
<span class="token comment" spellcheck="true">// A3B3C3</span></code></pre>
<p>中间操作是懒惰的，也就是不会对数据做任何操作，直到遇到了结束操作。而结束操作都是比较热情的，他们会回溯之前所有的中间操作。</p>
<p>拿上面的例子来说，当执行到 <code>forEach()</code> 的时候，它会回溯到上一步中间操作，再到上一步中间操作，再上一步..直到第一步，也就是这里的 <code>.peek(x -&gt; System.out.println(&quot;\nA&quot; + x)</code>，然后开始自上而下的依次执行，输出第一行的 <code>A1B1C1</code>，然而第二次执行 <code>forEach()</code> 操作的时候等同，以此类推..</p>
<p>我们再来看第二段代码：</p>
<pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\nA"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"C"</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ==============输出：===============</span>
<span class="token comment" spellcheck="true">// A1</span>
<span class="token comment" spellcheck="true">// A2</span>
<span class="token comment" spellcheck="true">// A3</span>
<span class="token comment" spellcheck="true">// A4</span>
<span class="token comment" spellcheck="true">// A5</span>
<span class="token comment" spellcheck="true">// A6</span>
<span class="token comment" spellcheck="true">// A7B7C7</span>
<span class="token comment" spellcheck="true">// A8B8C8</span>
<span class="token comment" spellcheck="true">// A9B9C9</span></code></pre>
<p>根据上面介绍的规则，同样的当第一次执行 <code>.forEach()</code> 的时候，会回溯到第一个 <code>peek</code> 操作，打印出 <code>A1</code>，然后执行 <code>skip</code>，这个操作的意思就是跳过，也就是相当于 for 循环里面的 continue，所以前六次的 <code>forEach()</code> 操作都只会打印 A。</p>
<p>而第七次开始，<code>skip</code> 失效之后，就会开始分别执行 <code>.peek()</code> 和 <code>forEach()</code> 里面的打印语句了，就会看到输出的是：<code>A7B7C7</code>。</p>
<p>OK，到这里也算是对 Stream API 有了一定的认识，下面我们对中间操作和结束操作做一个总结：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-68bb112ff24d36db.png" alt=""></p>
<ul>
<li>图片截自：<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md</a></li>
</ul>
<h1 id="三、Stream-性能测试"><a href="#三、Stream-性能测试" class="headerlink" title="三、Stream 性能测试"></a>三、Stream 性能测试</h1><hr>
<blockquote>
<p>引用自：下方参考文档第 4 条。</p>
</blockquote>
<p>已经对 Stream API 的用法鼓吹够多了，用起简洁直观，但性能到底怎么样呢？会不会有很高的性能损失？本节我们对 Stream API 的性能一探究竟。</p>
<p>为保证测试结果真实可信，我们将 JVM 运行在 <code>-server</code> 模式下，测试数据在 GB 量级，测试机器采用常见的商用服务器，配置如下：</p>
<table>
<thead>
<tr>
<th align="left">指标</th>
<th align="left">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OS</td>
<td align="left">CentOS 6.7 x86_64</td>
</tr>
<tr>
<td align="left">CPU</td>
<td align="left">Intel Xeon X5675, 12M Cache 3.06 GHz, 6 Cores 12 Threads</td>
</tr>
<tr>
<td align="left">内存</td>
<td align="left">96GB</td>
</tr>
<tr>
<td align="left">JDK</td>
<td align="left">java version 1.8.0_91, Java HotSpot(TM) 64-Bit Server VM</td>
</tr>
</tbody></table>
<p>测试<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/perf/StreamBenchmark/src/lee" target="_blank" rel="noopener">所用代码在这里</a>，测试<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/perf/Stream_performance.xlsx" target="_blank" rel="noopener">结果汇总</a>.</p>
<h2 id="测试方法和测试数据"><a href="#测试方法和测试数据" class="headerlink" title="测试方法和测试数据"></a>测试方法和测试数据</h2><p>性能测试并不是容易的事，Java性能测试更费劲，因为虚拟机对性能的影响很大，JVM对性能的影响有两方面：</p>
<ol>
<li>GC的影响。GC的行为是Java中很不好控制的一块，为增加确定性，我们手动指定使用CMS收集器，并使用10GB固定大小的堆内存。具体到JVM参数就是<code>-XX:+UseConcMarkSweepGC -Xms10G -Xmx10G</code></li>
<li>JIT(Just-In-Time)即时编译技术。即时编译技术会将热点代码在JVM运行的过程中编译成本地代码，测试时我们会先对程序预热，触发对测试函数的即时编译。相关的JVM参数是<code>-XX:CompileThreshold=10000</code>。</li>
</ol>
<p>Stream并行执行时用到<code>ForkJoinPool.commonPool()</code>得到的线程池，为控制并行度我们使用Linux的<code>taskset</code>命令指定JVM可用的核数。</p>
<p>测试数据由程序随机生成。为防止一次测试带来的抖动，测试4次求出平均时间作为运行时间。</p>
<h2 id="实验一-基本类型迭代"><a href="#实验一-基本类型迭代" class="headerlink" title="实验一 基本类型迭代"></a>实验一 基本类型迭代</h2><p>测试内容：找出整型数组中的最小值。对比for循环外部迭代和Stream API内部迭代性能。</p>
<p>测试程序<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/perf/StreamBenchmark/src/lee/IntTest.java" target="_blank" rel="noopener">IntTest</a>，测试结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-831f1148734ba757.png" alt=""></p>
<p>图中展示的是for循环外部迭代耗时为基准的时间比值。分析如下：</p>
<p>对于基本类型Stream串行迭代的性能开销明显高于外部迭代开销（两倍）；<br>Stream并行迭代的性能比串行迭代和外部迭代都好。</p>
<p>并行迭代性能跟可利用的核数有关，上图中的并行迭代使用了全部 12 个核，为考察使用核数对性能的影响，我们专门测试了不同核数下的Stream并行迭代效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-4f96578cebc68c1a.png" alt=""></p>
<p>分析，对于基本类型：</p>
<ol>
<li>使用Stream并行API在单核情况下性能很差，比Stream串行API的性能还差；</li>
<li>随着使用核数的增加，Stream并行效果逐渐变好，比使用for循环外部迭代的性能还好。</li>
</ol>
<p>以上两个测试说明，对于基本类型的简单迭代，Stream串行迭代性能更差，但多核情况下Stream迭代时性能较好。</p>
<h2 id="实验二-对象迭代"><a href="#实验二-对象迭代" class="headerlink" title="实验二 对象迭代"></a>实验二 对象迭代</h2><p>再来看对象的迭代效果。</p>
<p>测试内容：找出字符串列表中最小的元素（自然顺序），对比for循环外部迭代和Stream API内部迭代性能。</p>
<p>测试程序<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/perf/StreamBenchmark/src/lee/StringTest.java" target="_blank" rel="noopener">StringTest</a>，测试结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-caf02e4d9a85b2f1.png" alt=""></p>
<p>结果分析如下：</p>
<ol>
<li>对于对象类型Stream串行迭代的性能开销仍然高于外部迭代开销（1.5倍），但差距没有基本类型那么大。</li>
<li>Stream并行迭代的性能比串行迭代和外部迭代都好。</li>
</ol>
<p>再来单独考察Stream并行迭代效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-a460de6916c20d9d.png" alt=""></p>
<p>分析，对于对象类型：</p>
<ol>
<li>使用Stream并行API在单核情况下性能比for循环外部迭代差；</li>
<li>随着使用核数的增加，Stream并行效果逐渐变好，多核带来的效果明显。</li>
</ol>
<p>以上两个测试说明，对于对象类型的简单迭代，Stream串行迭代性能更差，但多核情况下Stream迭代时性能较好。</p>
<h2 id="实验三-复杂对象归约"><a href="#实验三-复杂对象归约" class="headerlink" title="实验三 复杂对象归约"></a>实验三 复杂对象归约</h2><p>从实验一、二的结果来看，Stream串行执行的效果都比外部迭代差（很多），是不是说明Stream真的不行了？先别下结论，我们再来考察一下更复杂的操作。</p>
<p>测试内容：给定订单列表，统计每个用户的总交易额。对比使用外部迭代手动实现和Stream API之间的性能。</p>
<p>我们将订单简化为<code>&lt;userName, price, timeStamp&gt;</code>构成的元组，并用<code>Order</code>对象来表示。测试程序<a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/perf/StreamBenchmark/src/lee/ReductionTest.java" target="_blank" rel="noopener">ReductionTest</a>，测试结果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-7a1368e732c7ccc9.png" alt=""></p>
<p>分析，对于复杂的归约操作：</p>
<ol>
<li>Stream API的性能普遍好于外部手动迭代，并行Stream效果更佳；</li>
</ol>
<p>再来考察并行度对并行效果的影响，测试结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java8%E4%B8%AD%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8&%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/7896890-5ef8bfda3d545415.png" alt=""></p>
<p>分析，对于复杂的归约操作：</p>
<ol>
<li>使用Stream并行归约在单核情况下性能比串行归约以及手动归约都要差，简单说就是最差的；</li>
<li>随着使用核数的增加，Stream并行效果逐渐变好，多核带来的效果明显。</li>
</ol>
<p>以上两个实验说明，对于复杂的归约操作，Stream串行归约效果好于手动归约，在多核情况下，并行归约效果更佳。我们有理由相信，对于其他复杂的操作，Stream API也能表现出相似的性能表现。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>上述三个实验的结果可以总结如下：</p>
<ol>
<li>对于简单操作，比如最简单的遍历，Stream串行API性能明显差于显示迭代，但并行的Stream API能够发挥多核特性。</li>
<li>对于复杂操作，Stream串行API性能可以和手动实现的效果匹敌，在并行执行时Stream API效果远超手动实现。</li>
</ol>
<p>所以，如果<strong>出于性能考虑</strong>，1. 对于简单操作推荐使用外部迭代手动实现，2. 对于复杂操作，推荐使用Stream API， 3. 在多核情况下，推荐使用并行Stream API来发挥多核优势，4.单核情况下不建议使用并行Stream API。</p>
<p>如果<strong>出于代码简洁性考虑</strong>，使用Stream API能够写出更短的代码。即使是从性能方面说，尽可能的使用Stream API也另外一个优势，那就是只要Java Stream类库做了升级优化，代码不用做任何修改就能享受到升级带来的好处。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<ol>
<li><a href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/19" target="_blank" rel="noopener">https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/19</a> - Java 8 Stream并行计算原理</li>
<li><a href="http://hack.xingren.com/index.php/2018/10/17/java-stream/" target="_blank" rel="noopener">http://hack.xingren.com/index.php/2018/10/17/java-stream/</a> - 原来你是这样的 Stream —— 浅析 Java Stream 实现原理</li>
<li><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md</a> - Stream Pipelines</li>
<li><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/8-Stream%20Performance.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/8-Stream%20Performance.md</a> - Stream Performance</li>
<li>《Java 8 实战》</li>
</ol>
<hr>
<p>按照惯例黏一个尾巴：</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>独立域名博客：wmyskxz.com<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz<br>分享自己的学习 &amp; 学习资料 &amp; 生活<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/08/26/mian-shi-bi-bei-shou-si-dai-ma-ni-pa-bu-pa/">
      【面试必备】手撕代码，你怕不怕？
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java基础/面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年8月26日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%90%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%80%95%E4%B8%8D%E6%80%95%EF%BC%9F/7896890-2d09aea119299075.png" alt=""></p>
<blockquote>
<p><strong>前言</strong>：不管是远程的视频面试，还是现场的面试，都有可能会有手撕代码的环节，这也是很多童鞋包括我(虽然还没遇到过..)都很头疼的东西，可能是因为 IDE 自动提示功能用惯了或是其他一些原因，总之让我手写代码就是感觉很奇怪..但是我想的话，这应该侧重考察的是一些细节或者是习惯方面的一些东西，所以还是防患于未然吧，把一些可能手撕的代码给准备准备，分享分享，<strong>希望可以得到各位的指正，然后能有一些讨论</strong>，由于我字太丑就不上传自己默写的代码了，但还是希望各位潦草写一遍加深一下印象吧，以上；</p>
</blockquote>
<hr>
<h1 id="Part-1-生产者-消费者问题"><a href="#Part-1-生产者-消费者问题" class="headerlink" title="Part 1.生产者-消费者问题"></a>Part 1.生产者-消费者问题</h1><p>这绝对是属于重点了，不管是考察对于该重要模型的理解还是考察代码能力，这都是一道很好的考题，所以很有必要的，我们先来回顾一下什么是生产者-消费者问题；</p>
<h2 id="问题简单回顾"><a href="#问题简单回顾" class="headerlink" title="问题简单回顾"></a>问题简单回顾</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%90%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%80%95%E4%B8%8D%E6%80%95%EF%BC%9F/7896890-f3b7afe4955ca3bc.png" alt=""></p>
<p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem），也称<strong>有限缓冲问题</strong>（英语：Bounded-buffer problem），是一个<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener" title="多线程">多线程</a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5" target="_blank" rel="noopener" title="同步">同步</a>问题的经典案例。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA" target="_blank" rel="noopener" title="缓冲区">缓冲区</a>的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong>(摘自维基百科：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者消费者问题</a>)</p>
<ul>
<li><strong>注意：</strong> 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差；</li>
</ul>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><p>上面说到该问题的关键是：<strong>如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据；</strong>解决思路可以简单概括为：</p>
<ul>
<li>生产者持续生产，直到缓冲区满，<strong>满时阻塞</strong>；缓冲区不满后，继续生产；</li>
<li>消费者持续消费，直到缓冲区空，<strong>空时阻塞</strong>；缓冲区不空后，继续消费；</li>
<li>生产者和消费者都可以有多个；</li>
</ul>
<p>那么在 Java 语言中，能达到上述要求的，自然而然的就会有如下的几种写法，但是问题的核心都是能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用：</p>
<ul>
<li><code>wait()</code>/<code>notify()</code>方式；</li>
<li><code>await()</code>/<code>signal()</code>方式；</li>
<li><code>BlockingQueue</code>阻塞队列方式；</li>
<li><code>PipedInputStream</code>/<code>PipedOutputStream</code>方式；</li>
</ul>
<p>手写代码，我们着重掌握上面对应的第一种和第三种写法就足够了；</p>
<h3 id="wait-notify-方式实现"><a href="#wait-notify-方式实现" class="headerlink" title="wait()/notify()方式实现"></a>wait()/notify()方式实现</h3><p>在手写代码之前，我们需要现在 IDE 上实现一遍，理解其中的过程并且找到一些重点/细节，我们先来代码走一遍，然后我把我理解的重点给圈儿出来：</p>
<h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> Vector sharedQueue<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 缓冲区大小</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总数，原子操作</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>Vector sharedQueue<span class="token punctuation">,</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sharedQueue <span class="token operator">=</span> sharedQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>SIZE <span class="token operator">=</span> SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start producer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 当队列满时阻塞等待</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Queue is full, producer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                <span class="token operator">+</span> <span class="token string">" is waiting, size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        sharedQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 队列不满时持续创造新元素</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    data <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 构造任务数据</span>
                    sharedQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"producer create data:"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sharedQueue<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>有了上面的提到的解决思路，应该很容易实现，但是这里主要提一下一些细节和重点：</p>
<ul>
<li><strong>创造数据</strong>：生产者-消费者解决的问题就是数据在多线程间的共享，所以我们首要关心的问题就应该是数据，我们这里采用的是使用一个<code>AtomicInteger</code>类来为我们创造数据，使用它的好处是该类是一个保证原子操作的类，我们使用其中的<code>incrementAndGet()</code>方法不仅能够保证线程安全，还可以达到一个计数的效果，所以是一个既简单又实用的选择，当然也可以使用其他的数据来代替，<strong>这里注意的是要保证该类在内存中只存在一份，使用<code>static</code>修饰</strong>；</li>
<li><strong>内存缓冲区</strong>：要保证在多线程环境下内存缓冲区的安全，所以我们考虑使用简单的<code>Vector</code>类来作为我们的内存缓冲区，并且使用<code>final</code>修饰保证内存缓冲区的唯一，然后的话我们需要判断队列是否满，需要手动添加一个标识缓冲区大小的变量<code>SIZE</code>，注意也是<code>final</code>修饰；</li>
<li><strong>模拟延迟</strong>：这里主要模拟的是一个网络延迟，我们首先定义了一个<code>SLEEPTIME</code>的延迟范围，<strong>注意使用的是<code>static final</code>修饰</strong>，然后使用<code>Random()</code>类的<code>nextInt()</code>方法来随机选取一个该范围内的值来模拟网络环境中的延迟；</li>
<li><strong>停止方法</strong>：首先需要知道在<code>Thread</code>类中有一个弃用的<code>stop()</code>方法，我们自己增加一个标志位<code>isRunning</code>来完成我们自己的<code>stop()</code>功能，<strong>需要注意的是使用<code>volatile</code>来修饰</strong>，保证该标志位的可见性；</li>
<li><strong>错误处理</strong>：当捕获到错误时，我们应该使用<code>Thread</code>类中的<code>interrupted()</code>方法来终止当前的进程；</li>
<li><strong>消息提示</strong>：我们主要是要在控制台输出该生产者的信息，包括当前队列的状态，大小，当前线程的生产者信息等，<strong>注意的是信息格式的统一(后面的消费者同样的)</strong>；</li>
</ul>
<h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> Vector sharedQueue<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 缓冲区大小</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>Vector sharedQueue<span class="token punctuation">,</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sharedQueue <span class="token operator">=</span> sharedQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>SIZE <span class="token operator">=</span> SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start consumer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 当队列空时阻塞等待</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Queue is empty, consumer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                <span class="token operator">+</span> <span class="token string">" is waiting, size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        sharedQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 队列不空时持续消费元素</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumer consume data："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sharedQueue<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>跟生产者相同的，你需要注意<strong>内存缓冲区</strong>/ <strong>模拟延迟</strong>/ <strong>错误处理</strong>/ <strong>消息提示</strong>这些方面的细节问题，总体来说消费者就是持续不断的消费，也比较容易实现；</p>
<h4 id="主线程代码"><a href="#主线程代码" class="headerlink" title="主线程代码"></a>主线程代码</h4><p>有了我们的消费者和生产者代码，我们需要来验证一下它们的正确性，照常理来说我们直接创建一些消费者和生产者的线程让它们执行就可以了啊，但是为了“加分”考虑呢，我们还是使用线程池吧..也不是特别复杂：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.构建内存缓冲区</span>
    Vector sharedQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 2.建立线程池和线程</span>
    ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 3.睡一会儿然后尝试停止生产者</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread1<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread2<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread3<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 4.再睡一会儿关闭线程池</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>大家可以自行去看看运行的结果，是没有问题的，不会出现多生产或者多消费之类的多线程问题，运行一段时间等生产者都停止之后，我们可以观察到控制台三个消费者都在等待数据的情况：</p>
<pre class=" language-java"><code class="language-java">Queue is empty<span class="token punctuation">,</span> consumer <span class="token number">17</span> is waiting<span class="token punctuation">,</span> size：<span class="token number">0</span>
Queue is empty<span class="token punctuation">,</span> consumer <span class="token number">15</span> is waiting<span class="token punctuation">,</span> size：<span class="token number">0</span>
Queue is empty<span class="token punctuation">,</span> consumer <span class="token number">16</span> is waiting<span class="token punctuation">,</span> size：<span class="token number">0</span></code></pre>
<h3 id="BlockingQueue阻塞队列方式实现"><a href="#BlockingQueue阻塞队列方式实现" class="headerlink" title="BlockingQueue阻塞队列方式实现"></a>BlockingQueue阻塞队列方式实现</h3><p>该方式对比起上面一种方式实现起来要简单一些，因为不需要手动的去通知其他线程了，生产者直接往队列中放数据直到队列满，消费者直接从队列中获取数据直到队列空，BlockingQueue会自动帮我们完成阻塞这个动作，还是先来看看代码</p>
<h4 id="生产者代码-1"><a href="#生产者代码-1" class="headerlink" title="生产者代码"></a>生产者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总数，原子操作</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start producer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 往阻塞队列中添加数据</span>
                data <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 构造任务数据</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"producer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" create data："</span> <span class="token operator">+</span> data
                        <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"failed to put data："</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>跟上面一种方式没有很大的差别，倒是代码更加简单通透，不过需要注意的是对<strong>阻塞队列添加失败的错误处理</strong>；</p>
<h4 id="消费者代码-1"><a href="#消费者代码-1" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start consumer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 从阻塞队列中获取数据</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    data <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" consume data："</span> <span class="token operator">+</span> data
                            <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Queue is empty, consumer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">" is waiting, size："</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="主线程代码-1"><a href="#主线程代码-1" class="headerlink" title="主线程代码"></a>主线程代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.构建内存缓冲区</span>
    BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 2.建立线程池和线程</span>
    ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 3.睡一会儿然后尝试停止生产者</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread1<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread2<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread3<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 4.再睡一会儿关闭线程池</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>因为队列中添加和删除的操作比较频繁，所以这里使用<code>LinkedBlockingQueue</code>来作为阻塞队列，所以这里除了内存缓冲区有所不同以外，其他的都差不多…当然你也可以指定一个队列的大小；</p>
<h3 id="总结以及改进"><a href="#总结以及改进" class="headerlink" title="总结以及改进"></a>总结以及改进</h3><p>生产者-消费者模式很好地对生产者线程和消费者线程进行解耦，优化了系统整体的结构，同时由于缓冲区的作用，允许生产者线程和消费者线程存在执行上的性能差异，从一定程度上缓解了性能瓶颈对系统性能的影响；上面两种写法都是非常常规的写法，只能说能起码能在及格的基础上加个那么点儿分数，如果想要得高分可以去搜索搜搜 Disruptor 来实现一个无锁的生产者-消费者模型….这里就不提及了..</p>
<p><strong>改进：</strong>上面的线程输出可能会有点儿不友好（不直观），因为我们这里是直接使用的线程的 ID 来作为输出，我们也可以给线程弄一个名字来作为输出，以上；</p>
<hr>
<h1 id="Part-2-排序算法"><a href="#Part-2-排序算法" class="headerlink" title="Part 2.排序算法"></a>Part 2.排序算法</h1><p>排序算法当然也算是重点考察的对象之一了，毕竟基础且偏算法，当然我们有必要去了解常见的排序算法以及它们采取了怎样的思想又是如何实现的还有复杂度的问题，但是这里的话，主要就提及两种考的比较常见的排序算法：<strong>冒泡</strong>和<strong>快排</strong>，以及分别对它们进行的一些优化；</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡应该是比较基础的一种算法，我们以从小到大排序为例，它的基础思想是：<strong>从第一个数开始直到数组倒数第二个数，每一轮都去比较数组中剩下的数，如果后面的数据更小则两数交换</strong>，这样一轮一轮的比较交换下来，最大的那个数也就“沉到”了数组的最后，最小的“冒”到了数组的最前面，这样就完成了排序工作；</p>
<h3 id="基础算法代码（未优化）"><a href="#基础算法代码（未优化）" class="headerlink" title="基础算法代码（未优化）"></a>基础算法代码（未优化）</h3><p>很简单，直接上代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 冒泡排序
 *
 * @param nums 待排序的数组
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 从小到大排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里需要注意：<strong>加上正确性判断</strong>；（讨论：其实我看大多数地方都是没有这个的，不知道有没有加上的必要…求讨论）</p>
<p>另外光写完实现冒泡排序的算法是不算完的，还要养成良好的习惯去写测试单元用例，而且尽可能要考虑到多的点，例如这里的负数、多个相同的数之类的特殊情况，我就大概写一个吧，也欢迎指正：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSortTester</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 测试用例1：验证负数是否满足要求</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 输出测试结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 测试用例2：验证多个相同的数是否满足要求</span>
    nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 输出测试结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>想象一个这样的场景：如果该数组基本有序，或者在数组的后半段基本有序，上面的算法就会浪费许多的时间开销，所以我们不再使用双重嵌套去比较每两个元素的值，而只是不断比较数组每前后两个数值，让大的那个数不断“冒”到数组的最后，然后缩小尾边界的范围，并且增加一个标志位，表示这一趟是否发生了交换，如果没有那么证明该数组已经有序则完成了排序了：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 改进的冒泡排序
 *
 * @param nums 待排序的数组
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 使用一个数来记录尾边界</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 每次开始排序前，都设置flag为未排序过</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 前面的数字大于后面的数字就交换</span>
                <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
                temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 表示交换过数据;</span>
                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 减小一次排序的尾边界</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>同样的记得写单元测试函数；</p>
<h3 id="冒泡排序进一步优化"><a href="#冒泡排序进一步优化" class="headerlink" title="冒泡排序进一步优化"></a>冒泡排序进一步优化</h3><p>顺着这个思路，我们进一步想象一个场景：现在有一个包含 1000 个数的数组，仅有前面 100 个数无序，后面的 900 个数都比前面的 100 个数更大并且已经排好序，那么上面优化的方法又会造成一定的时间浪费，所以我们进一步增加一个变量记录最后发生交换的元素的位置，也就是排序的尾边界了：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 冒泡算法最优解
 *
 * @param nums 待排序的数组
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// flag来记录最后交换的位置，也就是排序的尾边界</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 排序未结束标志</span>
        k <span class="token operator">=</span> flag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// k 来记录遍历的尾边界</span>
        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 前面的数字大于后面的数字就交换</span>
                <span class="token comment" spellcheck="true">// 交换a[j-1]和a[j]</span>
                <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
                temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 表示交换过数据;</span>
                flag <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 记录最新的尾边界.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这应该是最优的冒泡排序了，同时也别忘记了最后要写测试单元用例代码；</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排也是一种很经典的算法，它使用了一种分治的思想，基本思想是：<strong>通过一趟排序将待排序的数组分成两个部分，其中一部分记录的是比关键字更小的，另一部分是比关键字更大的，然后再分别对着两部分继续进行排序，直到整个序列有序；</strong></p>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>非常经典的代码，直接上吧：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将数组分为两部分</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 递归排序左子数组</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 递归排序右子数组</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 枢轴记录</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 交换比枢轴小的记录到左端</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 交换比枢轴小的记录到右端</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 扫描完成，枢轴到位</span>
    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 返回的是枢轴的位置</span>
    <span class="token keyword">return</span> low<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>当然，在手撕的时候需要注意函数上的 Java Doc 格式的注释，这里省略掉是为了节省篇幅，另外<strong>别忘了测试单元用例代码</strong>；</p>
<p>上面的代码也很容易理解，<strong>其实就是一个“填坑”的过程</strong>，第一个“坑”挖在每次排序的第一个位置<code>arr[low]</code>，从序列后面往前找第一个比<code>pivot</code>小的数来把这个“坑”填上，这时候的“坑”就变成了当前的<code>arr[high]</code>，然后再从序列前面往后用第一个比<code>pivot</code>大的数把刚才的“坑”填上，如此往复，始终有一个“坑”需要我们填上，直到最后一个“坑”出现，这个“坑”使用一开始的<code>pivot</code>填上就可以了，而这个“坑”的位置也就是<code>pivot</code>该填上的正确位置，我们再把这个位置返回，就可以把当前序列分成两个部分再依次这样操作最终就达到排序的目的了，不得不说这样的思想挺神奇的；</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是O(n㏒n)，而是O(n^2)了。</p>
<p>究其根源，在于我们的代码实现中，每次只从数组第一个开始取。如果我们采用“三者取中”，即 arr[low], arr[high], arr[(low+high)/2] 三者的中值作为枢轴记录，则可以大大提高快速排序在最坏情况下的性能。但是，我们仍然无法将它在数组有序情形下的性能提高到O(n)。还有一些方法可以不同程度地提高快速排序在最坏情况下的时间性能。</p>
<p>此外，快速排序需要一个递归栈，通常情况下这个栈不会很深，为log(n)级别。但是，如果每次划分的两个数组长度严重失衡，则为最坏情况，栈的深度将增加到O(n)。此时，由栈空间带来的空间复杂度不可忽略。如果加上额外变量的开销，这里甚至可能达到恐怖的O(n^2)空间复杂度。所以，快速排序的最差空间复杂度不是一个定值，甚至可能不在一个级别。</p>
<p>为了解决这个问题，我们可以在每次划分后比较两端的长度，并先对短的序列进行排序（目的是先结束这些栈以释放空间），可以将最大深度降回到O(㏒n)级别。</p>
<p>关于优化的话，了解一个大概的思路就可以了，那在这里稍微总结一下：</p>
<ul>
<li>①三数取中作为枢轴记录；</li>
<li>②当待排序序列的长度分割到一定大小之后，使用插入排序；</li>
<li>③在一次分割结束后，可以把与<code>pivot</code>相等的元素聚在一起，继续下次分割时，不用再对与<code>pivot</code>相等的元素分割；</li>
<li>④优化递归操作；</li>
</ul>
<blockquote>
<p>参考文章：<a href="http://blog.51cto.com/flyingcat2013/1281614" target="_blank" rel="noopener">http://blog.51cto.com/flyingcat2013/1281614</a><br>想要了解的更多的童鞋可以戳这里：<a href="https://blog.csdn.net/insistGoGo/article/details/7785038" target="_blank" rel="noopener">https://blog.csdn.net/insistGoGo/article/details/7785038</a></p>
</blockquote>
<hr>
<h1 id="Part-3-二叉树相关算法"><a href="#Part-3-二叉树相关算法" class="headerlink" title="Part 3.二叉树相关算法"></a>Part 3.二叉树相关算法</h1><p>二叉树也是一个容易提及的概念和写算法的问题，特别是它的几种递归遍历和非递归遍历，都是基础且常考的点，那在这里就稍微整理整理吧…</p>
<h2 id="二叉树的几种递归遍历"><a href="#二叉树的几种递归遍历" class="headerlink" title="二叉树的几种递归遍历"></a>二叉树的几种递归遍历</h2><p>前序、中序、后序遍历都是非常基础且容易的遍历方法，重点还是在后面的中序和后续的非递归遍历上，当然还有层序遍历，所以这里不多说，直接给代码；</p>
<h3 id="前序遍历递归实现"><a href="#前序遍历递归实现" class="headerlink" title="前序遍历递归实现"></a>前序遍历递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="中序遍历递归实现"><a href="#中序遍历递归实现" class="headerlink" title="中序遍历递归实现"></a>中序遍历递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrderTraverse1</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="后序遍历递归实现"><a href="#后序遍历递归实现" class="headerlink" title="后序遍历递归实现"></a>后序遍历递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrderTraverse1</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>前面三种遍历，也就是输出结点数据的位置不同而已，所以很容易，但是如果手写，建议问清楚面试官要求，是在遍历时直接输出还是需要函数返回一个List集合，然后<strong>注意写测试用例代码！</strong></p>
<h2 id="二叉树的几种非递归遍历"><a href="#二叉树的几种非递归遍历" class="headerlink" title="二叉树的几种非递归遍历"></a>二叉树的几种非递归遍历</h2><h3 id="★★层序遍历★★"><a href="#★★层序遍历★★" class="headerlink" title="★★层序遍历★★"></a>★★层序遍历★★</h3><p>层序遍历我们只需要增加使用一个队列即可，看代码很容易理解：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelTraverse</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="前序遍历非递归实现"><a href="#前序遍历非递归实现" class="headerlink" title="前序遍历非递归实现"></a>前序遍历非递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderTraverse2</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TreeNode pNode <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pNode <span class="token operator">=</span> pNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//pNode == null &amp;&amp; !stack.isEmpty()</span>
            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="★★中序遍历非递归实现★★"><a href="#★★中序遍历非递归实现★★" class="headerlink" title="★★中序遍历非递归实现★★"></a>★★中序遍历非递归实现★★</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 非递归中序遍历二叉树
 *
 * @param root 二叉树根节点
 * @return 中序遍历结果集
 */</span>
<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ArrayDeque<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="★★后续遍历非递归实现★★"><a href="#★★后续遍历非递归实现★★" class="headerlink" title="★★后续遍历非递归实现★★"></a>★★后续遍历非递归实现★★</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 二叉树的后序遍历
 *
 * @param root 二叉树根节点
 * @return 后序遍历结果集
 */</span>
<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Deque<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TreeNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// i ：判断如果右子树不为空且不为</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pre <span class="token operator">=</span> root<span class="token punctuation">;</span>
            root <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>如果比较难以理解的话，可以自己尝试着跟跟 Debug 然后看看过程；</p>
<h2 id="二叉树相关其他算法题"><a href="#二叉树相关其他算法题" class="headerlink" title="二叉树相关其他算法题"></a>二叉树相关其他算法题</h2><p>另外的话还有一些比较常见的关于树的算法，在文章的末尾，这里就不再赘述了：</p>
<p>链接：<a href="https://www.jianshu.com/p/4ef1f50d45b5" target="_blank" rel="noopener">https://www.jianshu.com/p/4ef1f50d45b5</a></p>
<hr>
<h1 id="Part-4-其他重要算法"><a href="#Part-4-其他重要算法" class="headerlink" title="Part 4.其他重要算法"></a>Part 4.其他重要算法</h1><p>除了上面 3 Part 比较重要的点之外，还有一些其他的算法也是经常考到的，下面我们来说；</p>
<h2 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1.反转链表"></a>1.反转链表</h2><p>这是一道很经典的题，不仅考你对链表的理解，而且还有一些<strong>细节（例如正确性判断/ 测试用例）</strong>需要你从代码层面去展现，下面我们给出两段代码，读者可以自行去比较，我只是提供一个思路；</p>
<h3 id="思路一：使用一个-Node-不断链接"><a href="#思路一：使用一个-Node-不断链接" class="headerlink" title="思路一：使用一个 Node 不断链接"></a>思路一：使用一个 Node 不断链接</h3><p>这是最经典的算法，也是需要我们牢牢掌握的方法，最重要的还是理解 <code>while()</code> 循环中的过程：</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> head <span class="token operator">||</span> null <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode temp <span class="token operator">=</span> head<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        temp<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="思路二：反转元素值然后重新赋给-Node"><a href="#思路二：反转元素值然后重新赋给-Node" class="headerlink" title="思路二：反转元素值然后重新赋给 Node"></a>思路二：反转元素值然后重新赋给 Node</h3><p>这是一个很简单的思路，比上个思路要多遍历一遍链表，但是好处是简单，思路清晰，实现起来容易，emm，像这一类问题我觉得另一个比较重要的就是<strong>举一反三</strong>的能力吧，在这里我只提供两个思路，其实还有很多种实现方法，当然也别忘了<strong>细节</strong>的东西~</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> head <span class="token operator">||</span> null <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2.遍历链表head并将结果保存在List集合中</span>
    List<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> tempNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// end while：遍历完了链表并将结果保存在了List集合中</span>

    <span class="token comment" spellcheck="true">// 3.反转集合，并将值依次复制给链表</span>
    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> tempNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tempNode<span class="token punctuation">.</span>val <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2.合并两个有序链表"></a>2.合并两个有序链表</h2><p>问题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的；</p>
<p>同样的经典算法，需要掌握：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> l1<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> l2<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这道题也是 LeetCode 上的一道题，我当时的做法是下面这样的，虽然看起来代码量多了不少而且看起来蠢蠢的..但是经过 LeetCode 测试，甚至比上面的实现要快上那么 2ms，<strong>特别提醒：下面的代码只是用作一个思路的参考，着重掌握上面的代码</strong> ：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 定义一个虚拟头结点方便遍历</span>
    ListNode dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
    ListNode pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 遍历l1链表</span>
    <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        len1<span class="token operator">++</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 保存l1链表的数据</span>
    pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 遍历l2链表</span>
    <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
    pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        len2<span class="token operator">++</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 保存l2链表的数据</span>
    pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1 <span class="token operator">+</span> len2<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将两个链表的数据整合并排序</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 拼接一个链表</span>
    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="3-两个链表的第一个公共结点"><a href="#3-两个链表的第一个公共结点" class="headerlink" title="3.两个链表的第一个公共结点"></a>3.两个链表的第一个公共结点</h2><p>题目描述：找出两个链表的第一个公共结点；</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 求两个链表中第一个公共结点
 *
 * @param pHead1 链表1头结点
 * @param pHead2 链表2头结点
 * @return 链表第一个公共结点
 */</span>
<span class="token keyword">public</span> ListNode <span class="token function">FindFirstCommonNode</span><span class="token punctuation">(</span>ListNode pHead1<span class="token punctuation">,</span> ListNode pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> pHead1 <span class="token operator">||</span> null <span class="token operator">==</span> pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2.遍历链表1把所有结点保存在列表中中</span>
    Vector<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> nodeList1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pHead1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nodeList1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pHead1 <span class="token operator">=</span> pHead1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 判断是否成环，成环则退出循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeList1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// end while：链表1中的所有结点都存入了nodeList1中</span>

    <span class="token comment" spellcheck="true">// 3.遍历链表2比较列表中的数据</span>
    Vector<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> nodeList2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 先判断nodeList1中是否存在相同结点，存在则返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeList1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> pHead2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果不存在则继续遍历，并判断是否成环</span>
        nodeList2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pHead2 <span class="token operator">=</span> pHead2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeList2<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// end while：遍历完了链表2并将所有结点保存在了nodeList2中</span>

    <span class="token comment" spellcheck="true">// 如果遍历完链表2则返回null</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>需要注意的细节是：①正确性判断；②判断链表是否自己成环；③注释；<strong>④注意要自己写测试用例啊</strong>…</p>
<p>另外还有一些类似的题目像是：①链表入环结点；②链表倒数第k个结点；之类的都是需要掌握的…</p>
<h2 id="4-二分查找算法"><a href="#4-二分查找算法" class="headerlink" title="4.二分查找算法"></a>4.二分查找算法</h2><p>二分查找也是一类比较常考的题目，其实代码也比较容易理解，直接上吧，再再再提醒一下：<strong>注意正确性判断还有测试用例…</strong></p>
<h3 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 二分查找普通实现。
 *
 * @param srcArray 有序数组
 * @param key      查找元素
 * @return 不存在返回-1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> end <span class="token operator">=</span> srcArray<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> start<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 二分查找递归实现。
 *
 * @param srcArray 有序数组
 * @param start    数组低地址下标
 * @param end      数组高地址下标
 * @param key      查找元素
 * @return 查找元素不存在返回-1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> start<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>srcArray<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>srcArray<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="5-斐波那契数列"><a href="#5-斐波那契数列" class="headerlink" title="5.斐波那契数列"></a>5.斐波那契数列</h2><p>这也是一道很经典的题，通常是要要求 N 值的范围的，常规写法应该很简单，所以需要掌握的是优化之后的算法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> n <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> nums1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res <span class="token operator">=</span> nums1 <span class="token operator">+</span> nums2<span class="token punctuation">;</span>
        nums1 <span class="token operator">=</span> nums2<span class="token punctuation">;</span>
        nums2 <span class="token operator">=</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>还是注意正确性判断然后写测试用例…</p>
<hr>
<h1 id="手撕代码总结"><a href="#手撕代码总结" class="headerlink" title="手撕代码总结"></a>手撕代码总结</h1><p>如果用手写代码的话，确实是个挺麻烦的事儿，首先需要对代码有相当的熟悉程度，然后其次的话考察的都是一些细节的东西，例如：</p>
<ul>
<li><strong>编码规范</strong>：包括一些命名的规范/ 注释的规范等等；</li>
<li><strong>缩进</strong>：这个我自己倒是挺在意的..关于这个可以去参考参考阿里出的那个规范手册；</li>
<li><strong>注释</strong>：如果命名规范做得好的话其实是可以达到代码即注释的，但是仍然有一些需要标注的地方例如函数头之类的，最好还是做好注释；</li>
<li><strong>代码的完整性</strong>：我觉得这个包括对于<strong>错误的处理/ 正确性判断</strong>这样一类的东西；</li>
<li><strong>测试用例</strong>：每个函数都需要一定的测试来保证其正确性，所以这个还是挺有必要的，特别是一些边界情况，null 值判断之类的；</li>
<li><strong>想好再下笔</strong>：这一点其实也蛮重要的，不管是在纸上还是在我们平时的编程中，思路永远都是更重要的；</li>
</ul>
<p>说来说去还是关于代码的事，我觉得还是<strong>理清思路</strong>最重要，所以我们需要在一遍一遍熟悉代码的过程中，熟知这些代码的思路，只有搞清楚这些代码背后的原理了，我们才能正确且快速的写出我们心中想要的代码，而不是简单的去背诵，这样是没有很大效果的，以上…</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
        <p class="current">
          1 / 3
        </p>
        
          <a class="next" rel="next" href="/tags/Java%E5%9F%BA%E7%A1%80/page/2/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(13)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.86px; color: #868686">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.29px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.57px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.86px; color: #646464">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.43px; color: #6d6d6d">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.43px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 19.71px; color: #727272">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.71px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.86px; color: #868686">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.57px; color: #818181">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.57px; color: #818181">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.14px; color: #686868">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.71px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.43px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.14px; color: #8a8a8a">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.71px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.43px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.57px; color: #818181">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.71px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.29px; color: #7c7c7c">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.71px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.14px; color: #8a8a8a">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.86px; color: #868686">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.14px; color: #686868">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19px; color: #777">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
