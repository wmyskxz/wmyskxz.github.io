<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>标签：面试 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/25/dong-yi-dian-python-xi-lie-kuai-su-ru-men-1/">
      妈妈再也不担心我面试被Redis问得脸都绿了
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月25日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-36f1278b896ced09.png" alt=""></p>
<blockquote>
<p>长文前排提醒，收藏向前排提醒，素质三连 <strong>(转发 + 在看 + 留言)</strong> 前排提醒！</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fbe27d1657e593c3.png" alt=""></p>
<p><strong>Redis</strong> 作为一个开源的，高级的键值存储和一个适用的解决方案，已经越来越在构建 <strong>「高性能」</strong>、<strong>「可扩展」</strong> 的 Web 应用上发挥着举足轻重的作用。</p>
<p>当今互联网技术架构中 <strong>Redis</strong> 已然成为了应用得最广泛的中间件之一，它也是中高级后端工程 <strong>技术面试</strong> 中面试官最喜欢问的工程技能之一，不仅仅要求着我们对 <strong>基本的使用</strong> 进行掌握，更要深层次地理解 Redis <strong>内部实现</strong> 的细节原理。</p>
<p>熟练掌握 Redis，甚至可以毫不夸张地说已经半只脚踏入心仪的公司了。下面我们一起来盘点回顾一下 Redis 的面试经典问题，就不要再被面试官问得 <strong>脸都绿了</strong> 呀！</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-62a9826a061d71dc.png" alt=""></p>
<ul>
<li><strong>Ps</strong>： 我把 <strong>重要的知识点</strong> 都做成了 <strong>图片</strong>，希望各位 <strong>“用餐愉快”</strong>。<em>(不错记得付餐费.. 点个赞留个言..)</em></li>
</ul>
<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4e434da31115b92d.png" alt=""></p>
<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><h4 id="先解释-Redis-基本概念"><a href="#先解释-Redis-基本概念" class="headerlink" title="先解释 Redis 基本概念"></a>先解释 Redis 基本概念</h4><p><strong>Redis</strong> (<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver) 是一个使用 <strong>C 语言</strong> 编写的，开源的 <em>(BSD许可)</em> 高性能 <strong>非关系型</strong> <em>(NoSQL)</em> 的 <strong>键值对数据库</strong>。</p>
<h4 id="简单提一下-Redis-数据结构"><a href="#简单提一下-Redis-数据结构" class="headerlink" title="简单提一下 Redis 数据结构"></a>简单提一下 Redis 数据结构</h4><p><strong>Redis</strong> 可以存储 <strong>键</strong> 和 <strong>不同类型数据结构值</strong> 之间的映射关系。键的类型只能是字符串，而值除了支持最 <strong>基础的五种数据类型</strong> 外，还支持一些 <strong>高级数据类型</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-ea1e1248cb5d8f88.png" alt=""></p>
<blockquote>
<p>一定要说出一些高级数据结构 <em>(当然你自己也要了解.. 下面会说到的别担心)</em>，这样面试官的眼睛才会亮。</p>
</blockquote>
<h4 id="Redis-小总结"><a href="#Redis-小总结" class="headerlink" title="Redis 小总结"></a>Redis 小总结</h4><p>与传统数据库不同的是 <strong>Redis</strong> 的数据是 <strong>存在内存</strong> 中的，所以 <strong>读写速度</strong> 非常 <strong>快</strong>，因此 Redis 被广泛应用于 <strong>缓存</strong> 方向，每秒可以处理超过 <code>10</code> 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做 <strong>分布式锁</strong>。</p>
<p>除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h2 id="Redis-优缺点"><a href="#Redis-优缺点" class="headerlink" title="Redis 优缺点"></a>Redis 优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>读写性能优异</strong>， Redis能读的速度是 <code>110000</code> 次/s，写的速度是 <code>81000</code> 次/s。</li>
<li><strong>支持数据持久化</strong>，支持 AOF 和 RDB 两种持久化方式。</li>
<li><strong>支持事务</strong>，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li><strong>数据结构丰富</strong>，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li><strong>支持主从复制</strong>，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>数据库 <strong>容量受到物理内存的限制</strong>，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis <strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 <strong>系统的可用性</strong>。</li>
<li><strong>Redis 较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="为什么要用缓存？为什么使用-Redis？"><a href="#为什么要用缓存？为什么使用-Redis？" class="headerlink" title="为什么要用缓存？为什么使用 Redis？"></a>为什么要用缓存？为什么使用 Redis？</h2><h4 id="提一下现在-Web-应用的现状"><a href="#提一下现在-Web-应用的现状" class="headerlink" title="提一下现在 Web 应用的现状"></a>提一下现在 Web 应用的现状</h4><p>在日常的 Web 应用对数据库的访问中，<strong>读操作的次数远超写操作</strong>，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用 SQL 语句去数据库进行读写操作时，数据库就会 <strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p>
<h4 id="使用-Redis-or-使用缓存带来的优势"><a href="#使用-Redis-or-使用缓存带来的优势" class="headerlink" title="使用 Redis or 使用缓存带来的优势"></a>使用 Redis or 使用缓存带来的优势</h4><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样 <strong>速度</strong> 明显就会快上不少 <em>(高性能)</em>，并且会 <strong>极大减小数据库的压力</strong> <em>(特别是在高并发情况下)</em>。</p>
<blockquote>
<p>记得是 <strong>两个角度</strong> 啊.. <strong>高性能</strong> 和 <strong>高并发</strong>..</p>
</blockquote>
<h4 id="也要提一下使用缓存的考虑"><a href="#也要提一下使用缓存的考虑" class="headerlink" title="也要提一下使用缓存的考虑"></a>也要提一下使用缓存的考虑</h4><p>但是使用内存进行数据存储开销也是比较大的，<strong>限于成本</strong> 的原因，一般我们只是使用 Redis 存储一些 <strong>常用和主要的数据</strong>，比如用户登录的信息等。</p>
<p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p>
<ul>
<li><strong>业务数据常用吗？命中率如何？</strong> 如果命中率很低，就没有必要写入缓存；</li>
<li><strong>该业务数据是读操作多，还是写操作多？</strong> 如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li>
<li><strong>业务数据大小如何？</strong> 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li>
</ul>
<p>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！</p>
<h2 id="使用缓存会出现什么问题？"><a href="#使用缓存会出现什么问题？" class="headerlink" title="使用缓存会出现什么问题？"></a>使用缓存会出现什么问题？</h2><p>一般来说有如下几个问题，回答思路遵照 <strong>是什么</strong> → <strong>为什么</strong> → <strong>怎么解决</strong>：</p>
<ol>
<li>缓存雪崩问题；</li>
<li>缓存穿透问题；</li>
<li>缓存和数据库双写一致性问题；</li>
</ol>
<h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-891c01ada1be7099.png" alt=""></p>
<p>另外对于 <strong>“Redis 挂掉了，请求全部走数据库”</strong> 这样的情况，我们还可以有如下的思路：</p>
<ul>
<li><strong>事发前</strong>：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。</li>
<li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li>
<li><strong>事发后</strong>：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-aa9398e52cf83891.png" alt=""></p>
<h4 id="缓存与数据库双写一致问题"><a href="#缓存与数据库双写一致问题" class="headerlink" title="缓存与数据库双写一致问题"></a>缓存与数据库双写一致问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-1c3e67935d7763d4.png" alt=""></p>
<p>双写一致性上图还是稍微粗糙了些，你还需要知道两种方案 <em>(先操作数据库和先操作缓存)</em> 分别都有什么优势和对应的问题，这里不作赘述，可以参考一下下方的文章，写得非常详细。</p>
<blockquote>
<ul>
<li>面试前必须要知道的Redis面试题 | Java3y - <a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么早期版本选择单线程？"><a href="#Redis-为什么早期版本选择单线程？" class="headerlink" title="Redis 为什么早期版本选择单线程？"></a>Redis 为什么早期版本选择单线程？</h2><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p>因为 Redis 是基于内存的操作，<strong>CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是 <strong>机器内存的大小</strong> 或者 <strong>网络带宽</strong>。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h4 id="简单总结一下"><a href="#简单总结一下" class="headerlink" title="简单总结一下"></a>简单总结一下</h4><ol>
<li>使用单线程模型能带来更好的 <strong>可维护性</strong>，方便开发和调试；</li>
<li>使用单线程模型也能 <strong>并发</strong> 的处理客户端的请求；<em>(I/O 多路复用机制)</em></li>
<li>Redis 服务中运行的绝大多数操作的 <strong>性能瓶颈都不是 CPU</strong>；</li>
</ol>
<blockquote>
<p><strong>强烈推荐</strong> 各位亲看一下这篇文章：</p>
<ul>
<li>为什么 Redis 选择单线程模型 · Why’s THE Design? - <a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">https://draveness.me/whys-the-design-redis-single-thread</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><p>简单总结：</p>
<ol>
<li><strong>纯内存操作</strong>：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；<em>(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)</em></li>
<li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li>
<li><strong>多路 I/O 复用模型，非阻塞 I/O</strong>：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li>
<li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li>
</ol>
<h1 id="二、数据结构篇"><a href="#二、数据结构篇" class="headerlink" title="二、数据结构篇"></a>二、数据结构篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-68ecbdc6cf4c5588.png" alt=""></p>
<h2 id="简述一下-Redis-常用数据结构及实现？"><a href="#简述一下-Redis-常用数据结构及实现？" class="headerlink" title="简述一下 Redis 常用数据结构及实现？"></a>简述一下 Redis 常用数据结构及实现？</h2><p>首先在 Redis 内部会使用一个 <strong>RedisObject</strong> 对象来表示所有的 <code>key</code> 和 <code>value</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-16511ec4f7f30569.png" alt=""></p>
<p>其次 Redis 为了 <strong>平衡空间和时间效率</strong>，针对 <code>value</code> 的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系：<em>(好像乱糟糟的，但至少能看清楚..)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-0801fee369ecca97.png" alt=""></p>
<h2 id="Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>Redis 的 SDS 和 C 中字符串相比有什么优势？</h2><h4 id="先简单总结一下"><a href="#先简单总结一下" class="headerlink" title="先简单总结一下"></a>先简单总结一下</h4><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 <strong>不符合 Redis 对字符串在安全性、效率以及功能方面的要求</strong>。</p>
<h4 id="再来说-C-语言字符串的问题"><a href="#再来说-C-语言字符串的问题" class="headerlink" title="再来说 C 语言字符串的问题"></a>再来说 C 语言字符串的问题</h4><p>这样简单的数据结构可能会造成以下一些问题：</p>
<ul>
<li><strong>获取字符串长度为 O(N) 级别的操作</strong> → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</li>
<li>不能很好的杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；</li>
<li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li>
</ul>
<h4 id="Redis-如何解决的-SDS-的优势"><a href="#Redis-如何解决的-SDS-的优势" class="headerlink" title="Redis 如何解决的 | SDS 的优势"></a>Redis 如何解决的 | SDS 的优势</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9570ea52d515e1cb.png" alt=""></p>
<p>如果去看 Redis 的源码 <code>sds.h/sdshdr</code> 文件，你会看到 SDS 完整的实现细节，这里简单来说一下 Redis 如何解决的：</p>
<ol>
<li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li>
<li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</li>
<li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li>
<li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li>
</ol>
<h2 id="字典是如何实现的？Rehash-了解吗？"><a href="#字典是如何实现的？Rehash-了解吗？" class="headerlink" title="字典是如何实现的？Rehash 了解吗？"></a>字典是如何实现的？Rehash 了解吗？</h2><h4 id="先总体聊一下-Redis-中的字典"><a href="#先总体聊一下-Redis-中的字典" class="headerlink" title="先总体聊一下 Redis 中的字典"></a>先总体聊一下 Redis 中的字典</h4><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p>
<h4 id="说明字典内部结构和-rehash"><a href="#说明字典内部结构和-rehash" class="headerlink" title="说明字典内部结构和 rehash"></a>说明字典内部结构和 rehash</h4><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的 <strong>链地址法</strong> 来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p>
<p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个 <code>hashtable</code> 有值，但是在字典扩容缩容时，需要分配新的 <code>hashtable</code>，然后进行 <strong>渐进式搬迁</strong> <em>(rehash)</em>，这时候两个 <code>hashtable</code> 分别存储旧的和新的 <code>hashtable</code>，待搬迁结束后，旧的将被删除，新的 <code>hashtable</code> 取而代之。</p>
<h4 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h4><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p>
<h2 id="跳跃表是如何实现的？原理？"><a href="#跳跃表是如何实现的？原理？" class="headerlink" title="跳跃表是如何实现的？原理？"></a>跳跃表是如何实现的？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9e9cbfe4fc061f3.png" alt=""></p>
<blockquote>
<p>这是 Redis 中比较重要的一个数据结构，<strong>建议阅读</strong> 之前写过的文章，里面详细介绍了原理和一些细节：</p>
<ul>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
</ul>
</blockquote>
<h2 id="HyperLogLog-有了解吗？"><a href="#HyperLogLog-有了解吗？" class="headerlink" title="HyperLogLog 有了解吗？"></a>HyperLogLog 有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
</ul>
</blockquote>
<h2 id="布隆过滤器有了解吗？"><a href="#布隆过滤器有了解吗？" class="headerlink" title="布隆过滤器有了解吗？"></a>布隆过滤器有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
</ul>
</blockquote>
<h2 id="GeoHash-了解吗？"><a href="#GeoHash-了解吗？" class="headerlink" title="GeoHash 了解吗？"></a>GeoHash 了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(6)——GeoHash查找附近的人 - <a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
</ul>
</blockquote>
<h2 id="压缩列表了解吗？"><a href="#压缩列表了解吗？" class="headerlink" title="压缩列表了解吗？"></a>压缩列表了解吗？</h2><p>这是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，<strong>zset</strong> 和 <strong>hash</strong> 容器对象会在元素个数较少的时候，采用压缩列表（ziplist）进行存储。压缩列表是 <strong>一块连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。</p>
<blockquote>
<p>因为之前自己也没有学习过，所以找了一篇比较好比较容易理解的文章：</p>
<ul>
<li>图解Redis之数据结构篇——压缩列表 - <a href="https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg</a></li>
<li>这一篇稍微底层稍微硬核一点：<a href="http://www.web-lovers.com/redis-source-ziplist.html" target="_blank" rel="noopener">http://www.web-lovers.com/redis-source-ziplist.html</a></li>
</ul>
</blockquote>
<h2 id="快速列表-quicklist-了解吗？"><a href="#快速列表-quicklist-了解吗？" class="headerlink" title="快速列表 quicklist 了解吗？"></a>快速列表 quicklist 了解吗？</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p>
<p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>。</p>
<blockquote>
<p>同上..建议阅读一下以下的文章：</p>
<ul>
<li>Redis列表list 底层原理 - <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li>
</ul>
</blockquote>
<h2 id="Stream-结构有了解吗？"><a href="#Stream-结构有了解吗？" class="headerlink" title="Stream 结构有了解吗？"></a>Stream 结构有了解吗？</h2><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9d8afde068a165f.png" alt=""></p>
<p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p>
<ul>
<li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li>
<li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li>
<li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li>
</ul>
<h4 id="Stream-消息太多怎么办？"><a href="#Stream-消息太多怎么办？" class="headerlink" title="Stream 消息太多怎么办？"></a>Stream 消息太多怎么办？</h4><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p>
<p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> XADD mystream MAXLEN 2 * value 1
1526654998691-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 2
1526654999635-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 3
1526655000369-0
<span class="token operator">></span> XLEN mystream
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token operator">></span> XRANGE mystream - +
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526654999635-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526655000369-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p>
<p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p>
<pre class=" language-bash"><code class="language-bash">XADD mystream MAXLEN ~ 1000 * <span class="token punctuation">..</span>. entry fields here <span class="token punctuation">..</span>.</code></pre>
<p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p>
<h4 id="PEL-是如何避免消息丢失的？"><a href="#PEL-是如何避免消息丢失的？" class="headerlink" title="PEL 是如何避免消息丢失的？"></a>PEL 是如何避免消息丢失的？</h4><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p>
<h4 id="和-Kafka-对比起来呢？"><a href="#和-Kafka-对比起来呢？" class="headerlink" title="和 Kafka 对比起来呢？"></a>和 Kafka 对比起来呢？</h4><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p>
<p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p>
<blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章，里面 <strong>也对 Pub/ Sub 做了详细的描述</strong>：</p>
<ul>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ul>
</blockquote>
<h1 id="三、持久化篇"><a href="#三、持久化篇" class="headerlink" title="三、持久化篇"></a>三、持久化篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-54bd130bf8e635e0.png" alt=""></p>
<h2 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h2><h4 id="先简单谈一谈是什么"><a href="#先简单谈一谈是什么" class="headerlink" title="先简单谈一谈是什么"></a>先简单谈一谈是什么</h4><p><strong>Redis</strong> 的数据 <strong>全部存储</strong> 在 <strong>内存</strong> 中，如果 <strong>突然宕机</strong>，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 <strong>持久化机制</strong>，它会将内存中的数据库状态 <strong>保存到磁盘</strong> 中。</p>
<h4 id="解释一下持久化发生了什么"><a href="#解释一下持久化发生了什么" class="headerlink" title="解释一下持久化发生了什么"></a>解释一下持久化发生了什么</h4><p>我们来稍微考虑一下 <strong>Redis</strong> 作为一个 <strong>“内存数据库”</strong> 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-5c209bc08da11abb.png" alt=""></p>
<p><strong>详细版</strong> 的文字描述大概就是下面这样：</p>
<ol>
<li>客户端向数据库 <strong>发送写命令</strong> <em>(数据在客户端的内存中)</em></li>
<li>数据库 <strong>接收</strong> 到客户端的 <strong>写请求</strong> <em>(数据在服务器的内存中)</em></li>
<li>数据库 <strong>调用系统 API</strong> 将数据写入磁盘 <em>(数据在内核缓冲区中)</em></li>
<li>操作系统将 <strong>写缓冲区</strong> 传输到 <strong>磁盘控控制器</strong> <em>(数据在磁盘缓存中)</em></li>
<li>操作系统的磁盘控制器将数据 <strong>写入实际的物理媒介</strong> 中 <em>(数据在磁盘中)</em></li>
</ol>
<h4 id="分析如何保证持久化安全"><a href="#分析如何保证持久化安全" class="headerlink" title="分析如何保证持久化安全"></a>分析如何保证持久化安全</h4><p>如果我们故障仅仅涉及到 <strong>软件层面</strong> <em>(该进程被管理员终止或程序崩溃)</em> 并且没有接触到内核，那么在 <em>上述步骤 3</em> 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。</p>
<p>如果我们考虑 <strong>停电/ 火灾</strong> 等 <strong>更具灾难性</strong> 的事情，那么只有在完成了第 <strong>5</strong> 步之后，才是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-de083f477fe1bce4.png" alt="机房”火了“"></p>
<p>所以我们可以总结得出数据安全最重要的阶段是：<strong>步骤三、四、五</strong>，即：</p>
<ul>
<li>数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？</li>
<li>内核多久从缓冲区取数据刷新到磁盘控制器？</li>
<li>磁盘控制器多久把数据写入物理媒介一次？</li>
<li><strong>注意：</strong> 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 <strong>尽可能地保证</strong> 数据的安全，这对于所有数据库来说都是一样的。</li>
</ul>
<p>我们从 <strong>第三步</strong> 开始。Linux 系统提供了清晰、易用的用于操作文件的 <code>POSIX file API</code>，<code>20</code> 多年过去，仍然还有很多人对于这一套 <code>API</code> 的设计津津乐道，我想其中一个原因就是因为你光从 <code>API</code> 的命名就能够很清晰地知道这一套 API 的用途：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">/*,mode_t mode */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">close</span> <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fname <span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>参考自：API 设计最佳实践的思考 - <a href="https://www.cnblogs.com/yuanjiangw/p/10846560.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanjiangw/p/10846560.html</a></li>
</ul>
<p>所以，我们有很好的可用的 <code>API</code> 来完成 <strong>第三步</strong>，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。</p>
<p>然后我们来说说 <strong>第四步</strong>。我们知道，除了早期对电脑特别了解那帮人 <em>(操作系统就这帮人搞的)</em>，实际的物理硬件都不是我们能够 <strong>直接操作</strong> 的，都是通过 <strong>操作系统调用</strong> 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 <strong>上述第四步</strong> 提到的 <strong>写缓冲区</strong>，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 <strong>30 秒</strong> 后实际提交写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c08b7572ef02d67b.jpg" alt=""></p>
<p>但是很明显，<strong>30 秒</strong> 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 <code>PROSIX API</code> 提供了另一个解决方案：<code>fsync</code>，该命令会 <strong>强制</strong> 内核将 <strong>缓冲区</strong> 写入 <strong>磁盘</strong>，但这是一个非常消耗性能的操作，每次调用都会 <strong>阻塞等待</strong> 直到设备报告 IO 完成，所以一般在生产环境的服务器中，<strong>Redis</strong> 通常是每隔 1s 左右执行一次 <code>fsync</code> 操作。</p>
<p>到目前为止，我们了解到了如何控制 <code>第三步</code> 和 <code>第四步</code>，但是对于 <strong>第五步</strong>，我们 <strong>完全无法控制</strong>。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。</p>
<blockquote>
<p>普通人简单说一下第一条就过了，如果你详细地对后面两方面 <strong>侃侃而谈</strong>，那面试官就会对你另眼相看了。</p>
</blockquote>
<h2 id="Redis-中的两种持久化方式？"><a href="#Redis-中的两种持久化方式？" class="headerlink" title="Redis 中的两种持久化方式？"></a>Redis 中的两种持久化方式？</h2><h4 id="方式一：快照"><a href="#方式一：快照" class="headerlink" title="方式一：快照"></a>方式一：快照</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9a4d234c53120b33.gif" alt=""></p>
<p><strong>Redis 快照</strong> 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 <code>100</code> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>
<h4 id="方式二：AOF"><a href="#方式二：AOF" class="headerlink" title="方式二：AOF"></a>方式二：AOF</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-e4e08ebef2cf0144.gif" alt=""></p>
<p><strong>快照不是很持久</strong>。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 <code>kill -9</code> 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。</p>
<p><strong>AOF(Append Only File - 仅追加文件)</strong> 它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>
<h4 id="Redis-4-0-的混合持久化"><a href="#Redis-4-0-的混合持久化" class="headerlink" title="Redis 4.0 的混合持久化"></a>Redis 4.0 的混合持久化</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-7de9f7706be6216c.gif" alt=""></p>
<p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-2f7887f84eaa34d9.png" alt=""></p>
<p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<blockquote>
<p>关于两种持久化方式的更多细节 <em>(原理)</em> 可以参考：</p>
<ul>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
</ul>
</blockquote>
<h2 id="RDB-和-AOF-各自有什么优缺点？"><a href="#RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="RDB 和 AOF 各自有什么优缺点？"></a>RDB 和 AOF 各自有什么优缺点？</h2><h4 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB | 优点"></a>RDB | 优点</h4><ol>
<li>只有一个文件 <code>dump.rdb</code>，<strong>方便持久化</strong>。</li>
<li><strong>容灾性好</strong>，一个文件可以保存到安全的磁盘。</li>
<li><strong>性能最大化</strong>，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能</li>
<li>相对于数据集大时，比 AOF 的 <strong>启动效率</strong> 更高。</li>
</ol>
<h4 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB | 缺点"></a>RDB | 缺点</h4><ol>
<li><strong>数据安全性低</strong>。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</li>
</ol>
<h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF | 优点"></a>AOF | 优点</h4><ol>
<li><strong>数据安全</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li>
</ol>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF | 缺点"></a>AOF | 缺点</h4><ol>
<li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li>
<li><strong>数据集大</strong> 的时候，比 rdb <strong>启动效率低</strong>。</li>
</ol>
<h2 id="两种方式如何选择？"><a href="#两种方式如何选择？" class="headerlink" title="两种方式如何选择？"></a>两种方式如何选择？</h2><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的 <strong>数据安全性</strong>，你应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然 <strong>可以承受数分钟以内的数据丢失</strong>，那么你可以 <strong>只使用 RDB 持久化</strong>。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h2 id="Redis-的数据恢复"><a href="#Redis-的数据恢复" class="headerlink" title="Redis 的数据恢复"></a>Redis 的数据恢复</h2><p><strong>Redis</strong> 的数据恢复有着如下的优先级：</p>
<ol>
<li>如果只配置 AOF ，重启时加载 AOF 文件恢复数据；</li>
<li>如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；</li>
<li>如果只配置 RDB，启动将加载 dump 文件恢复数据。</li>
</ol>
<p>拷贝 <strong>AOF</strong> 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程：Redis 虚拟一个客户端，读取 AOF 文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在 <code>loadAppendOnlyFile()</code> 中实现。</p>
<p>拷贝 <strong>RDB</strong> 文件到 Redis 的数据目录，启动 redis-server 即可，因为 RDB 文件和重启前保存的是真实数据而不是命令状态和参数。</p>
<h1 id="四、集群篇"><a href="#四、集群篇" class="headerlink" title="四、集群篇"></a>四、集群篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-83a0181f29cccb73.png" alt=""></p>
<h2 id="主从同步了解吗？"><a href="#主从同步了解吗？" class="headerlink" title="主从同步了解吗？"></a>主从同步了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。</p>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="哨兵模式了解吗？"><a href="#哨兵模式了解吗？" class="headerlink" title="哨兵模式了解吗？"></a>哨兵模式了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h4><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="Redis-集群使用过吗？原理？"><a href="#Redis-集群使用过吗？原理？" class="headerlink" title="Redis 集群使用过吗？原理？"></a>Redis 集群使用过吗？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="集群中数据如何分区？"><a href="#集群中数据如何分区？" class="headerlink" title="集群中数据如何分区？"></a>集群中数据如何分区？</h2><p>Redis 采用方案三。</p>
<h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点之间的通信机制了解吗？"><a href="#节点之间的通信机制了解吗？" class="headerlink" title="节点之间的通信机制了解吗？"></a>节点之间的通信机制了解吗？</h2><p>集群的建立离不开节点之间的通信，例如我们在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="集群数据如何存储的有了解吗？"><a href="#集群数据如何存储的有了解吗？" class="headerlink" title="集群数据如何存储的有了解吗？"></a>集群数据如何存储的有了解吗？</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<h1 id="五、其他问题"><a href="#五、其他问题" class="headerlink" title="五、其他问题"></a>五、其他问题</h1><h2 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h2><blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章：<br>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></p>
</blockquote>
<h2 id="Redis-过期键的删除策略？"><a href="#Redis-过期键的删除策略？" class="headerlink" title="Redis 过期键的删除策略？"></a>Redis 过期键的删除策略？</h2><h4 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h4><p>先抛开 Redis 想一下几种可能的删除策略：</p>
<ol>
<li><strong>定时删除</strong>:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</li>
<li><strong>定期删除</strong>:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ol>
<p>在上述的三种策略中定时删除和定期删除属于不同时间粒度的 <strong>主动删除</strong>，惰性删除属于 <strong>被动删除</strong>。</p>
<h4 id="三种策略都有各自的优缺点"><a href="#三种策略都有各自的优缺点" class="headerlink" title="三种策略都有各自的优缺点"></a>三种策略都有各自的优缺点</h4><ol>
<li>定时删除对内存使用率有优势，但是对 CPU 不友好；</li>
<li>惰性删除对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费；</li>
<li>定期删除是定时删除和惰性删除的折中。</li>
</ol>
<h4 id="Redis-中的实现"><a href="#Redis-中的实现" class="headerlink" title="Redis 中的实现"></a>Redis 中的实现</h4><p>Reids 采用的是 <strong>惰性删除和定时删除</strong> 的结合，一般来说可以借助最小堆来实现定时器，不过 Redis 的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，这样如果在此基础上实现定时删除，就意味着 <code>O(N)</code> 遍历获取最近需要删除的数据。</p>
<h2 id="Redis-的淘汰策略有哪些？"><a href="#Redis-的淘汰策略有哪些？" class="headerlink" title="Redis 的淘汰策略有哪些？"></a>Redis 的淘汰策略有哪些？</h2><h4 id="Redis-有六种淘汰策略"><a href="#Redis-有六种淘汰策略" class="headerlink" title="Redis 有六种淘汰策略"></a>Redis 有六种淘汰策略</h4><table>
<thead>
<tr>
<th align="left">策略</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">volatile-lru</td>
<td align="left">从已设置过期时间的 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-ttl</td>
<td align="left">从已设置过期时间的 KV 集中优先对剩余时间短(time to live)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-random</td>
<td align="left">从已设置过期时间的 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">allkeys-lru</td>
<td align="left">从所有 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">allKeys-random</td>
<td align="left">从所有 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">noeviction</td>
<td align="left">不淘汰策略，若超过最大内存，返回错误信息</td>
</tr>
</tbody></table>
<h4 id="4-0-版本后增加以下两种"><a href="#4-0-版本后增加以下两种" class="headerlink" title="4.0 版本后增加以下两种"></a>4.0 版本后增加以下两种</h4><ul>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<h2 id="More"><a href="#More" class="headerlink" title="More.."></a>More..</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了 - <a href="https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w</a></li>
<li>大厂面试！我和面试官之间关于Redis的一场对弈！ - <a href="https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g</a></li>
<li>Redis面试题（2020最新版） - <a href="https://blog.csdn.net/ThinkWon/article/details/103522351" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/103522351</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/08/26/mian-shi-bi-bei-shou-si-dai-ma-ni-pa-bu-pa/">
      【面试必备】手撕代码，你怕不怕？
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java基础/面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年8月26日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%90%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%80%95%E4%B8%8D%E6%80%95%EF%BC%9F/7896890-2d09aea119299075.png" alt=""></p>
<blockquote>
<p><strong>前言</strong>：不管是远程的视频面试，还是现场的面试，都有可能会有手撕代码的环节，这也是很多童鞋包括我(虽然还没遇到过..)都很头疼的东西，可能是因为 IDE 自动提示功能用惯了或是其他一些原因，总之让我手写代码就是感觉很奇怪..但是我想的话，这应该侧重考察的是一些细节或者是习惯方面的一些东西，所以还是防患于未然吧，把一些可能手撕的代码给准备准备，分享分享，<strong>希望可以得到各位的指正，然后能有一些讨论</strong>，由于我字太丑就不上传自己默写的代码了，但还是希望各位潦草写一遍加深一下印象吧，以上；</p>
</blockquote>
<hr>
<h1 id="Part-1-生产者-消费者问题"><a href="#Part-1-生产者-消费者问题" class="headerlink" title="Part 1.生产者-消费者问题"></a>Part 1.生产者-消费者问题</h1><p>这绝对是属于重点了，不管是考察对于该重要模型的理解还是考察代码能力，这都是一道很好的考题，所以很有必要的，我们先来回顾一下什么是生产者-消费者问题；</p>
<h2 id="问题简单回顾"><a href="#问题简单回顾" class="headerlink" title="问题简单回顾"></a>问题简单回顾</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%90%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%80%95%E4%B8%8D%E6%80%95%EF%BC%9F/7896890-f3b7afe4955ca3bc.png" alt=""></p>
<p><strong>生产者消费者问题</strong>（英语：Producer-consumer problem），也称<strong>有限缓冲问题</strong>（英语：Bounded-buffer problem），是一个<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener" title="多线程">多线程</a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5" target="_blank" rel="noopener" title="同步">同步</a>问题的经典案例。该问题描述了共享固定大小<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA" target="_blank" rel="noopener" title="缓冲区">缓冲区</a>的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong>(摘自维基百科：<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">生产者消费者问题</a>)</p>
<ul>
<li><strong>注意：</strong> 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差；</li>
</ul>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><p>上面说到该问题的关键是：<strong>如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据；</strong>解决思路可以简单概括为：</p>
<ul>
<li>生产者持续生产，直到缓冲区满，<strong>满时阻塞</strong>；缓冲区不满后，继续生产；</li>
<li>消费者持续消费，直到缓冲区空，<strong>空时阻塞</strong>；缓冲区不空后，继续消费；</li>
<li>生产者和消费者都可以有多个；</li>
</ul>
<p>那么在 Java 语言中，能达到上述要求的，自然而然的就会有如下的几种写法，但是问题的核心都是能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用：</p>
<ul>
<li><code>wait()</code>/<code>notify()</code>方式；</li>
<li><code>await()</code>/<code>signal()</code>方式；</li>
<li><code>BlockingQueue</code>阻塞队列方式；</li>
<li><code>PipedInputStream</code>/<code>PipedOutputStream</code>方式；</li>
</ul>
<p>手写代码，我们着重掌握上面对应的第一种和第三种写法就足够了；</p>
<h3 id="wait-notify-方式实现"><a href="#wait-notify-方式实现" class="headerlink" title="wait()/notify()方式实现"></a>wait()/notify()方式实现</h3><p>在手写代码之前，我们需要现在 IDE 上实现一遍，理解其中的过程并且找到一些重点/细节，我们先来代码走一遍，然后我把我理解的重点给圈儿出来：</p>
<h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> Vector sharedQueue<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 缓冲区大小</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总数，原子操作</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>Vector sharedQueue<span class="token punctuation">,</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sharedQueue <span class="token operator">=</span> sharedQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>SIZE <span class="token operator">=</span> SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start producer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 当队列满时阻塞等待</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Queue is full, producer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                <span class="token operator">+</span> <span class="token string">" is waiting, size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        sharedQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 队列不满时持续创造新元素</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    data <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 构造任务数据</span>
                    sharedQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"producer create data:"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sharedQueue<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>有了上面的提到的解决思路，应该很容易实现，但是这里主要提一下一些细节和重点：</p>
<ul>
<li><strong>创造数据</strong>：生产者-消费者解决的问题就是数据在多线程间的共享，所以我们首要关心的问题就应该是数据，我们这里采用的是使用一个<code>AtomicInteger</code>类来为我们创造数据，使用它的好处是该类是一个保证原子操作的类，我们使用其中的<code>incrementAndGet()</code>方法不仅能够保证线程安全，还可以达到一个计数的效果，所以是一个既简单又实用的选择，当然也可以使用其他的数据来代替，<strong>这里注意的是要保证该类在内存中只存在一份，使用<code>static</code>修饰</strong>；</li>
<li><strong>内存缓冲区</strong>：要保证在多线程环境下内存缓冲区的安全，所以我们考虑使用简单的<code>Vector</code>类来作为我们的内存缓冲区，并且使用<code>final</code>修饰保证内存缓冲区的唯一，然后的话我们需要判断队列是否满，需要手动添加一个标识缓冲区大小的变量<code>SIZE</code>，注意也是<code>final</code>修饰；</li>
<li><strong>模拟延迟</strong>：这里主要模拟的是一个网络延迟，我们首先定义了一个<code>SLEEPTIME</code>的延迟范围，<strong>注意使用的是<code>static final</code>修饰</strong>，然后使用<code>Random()</code>类的<code>nextInt()</code>方法来随机选取一个该范围内的值来模拟网络环境中的延迟；</li>
<li><strong>停止方法</strong>：首先需要知道在<code>Thread</code>类中有一个弃用的<code>stop()</code>方法，我们自己增加一个标志位<code>isRunning</code>来完成我们自己的<code>stop()</code>功能，<strong>需要注意的是使用<code>volatile</code>来修饰</strong>，保证该标志位的可见性；</li>
<li><strong>错误处理</strong>：当捕获到错误时，我们应该使用<code>Thread</code>类中的<code>interrupted()</code>方法来终止当前的进程；</li>
<li><strong>消息提示</strong>：我们主要是要在控制台输出该生产者的信息，包括当前队列的状态，大小，当前线程的生产者信息等，<strong>注意的是信息格式的统一(后面的消费者同样的)</strong>；</li>
</ul>
<h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> Vector sharedQueue<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">// 缓冲区大小</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>Vector sharedQueue<span class="token punctuation">,</span> <span class="token keyword">int</span> SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sharedQueue <span class="token operator">=</span> sharedQueue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>SIZE <span class="token operator">=</span> SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start consumer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 当队列空时阻塞等待</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Queue is empty, consumer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                <span class="token operator">+</span> <span class="token string">" is waiting, size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        sharedQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 队列不空时持续消费元素</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumer consume data："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sharedQueue<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>跟生产者相同的，你需要注意<strong>内存缓冲区</strong>/ <strong>模拟延迟</strong>/ <strong>错误处理</strong>/ <strong>消息提示</strong>这些方面的细节问题，总体来说消费者就是持续不断的消费，也比较容易实现；</p>
<h4 id="主线程代码"><a href="#主线程代码" class="headerlink" title="主线程代码"></a>主线程代码</h4><p>有了我们的消费者和生产者代码，我们需要来验证一下它们的正确性，照常理来说我们直接创建一些消费者和生产者的线程让它们执行就可以了啊，但是为了“加分”考虑呢，我们还是使用线程池吧..也不是特别复杂：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.构建内存缓冲区</span>
    Vector sharedQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 2.建立线程池和线程</span>
    ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 3.睡一会儿然后尝试停止生产者</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread1<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread2<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread3<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 4.再睡一会儿关闭线程池</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>大家可以自行去看看运行的结果，是没有问题的，不会出现多生产或者多消费之类的多线程问题，运行一段时间等生产者都停止之后，我们可以观察到控制台三个消费者都在等待数据的情况：</p>
<pre class=" language-java"><code class="language-java">Queue is empty<span class="token punctuation">,</span> consumer <span class="token number">17</span> is waiting<span class="token punctuation">,</span> size：<span class="token number">0</span>
Queue is empty<span class="token punctuation">,</span> consumer <span class="token number">15</span> is waiting<span class="token punctuation">,</span> size：<span class="token number">0</span>
Queue is empty<span class="token punctuation">,</span> consumer <span class="token number">16</span> is waiting<span class="token punctuation">,</span> size：<span class="token number">0</span></code></pre>
<h3 id="BlockingQueue阻塞队列方式实现"><a href="#BlockingQueue阻塞队列方式实现" class="headerlink" title="BlockingQueue阻塞队列方式实现"></a>BlockingQueue阻塞队列方式实现</h3><p>该方式对比起上面一种方式实现起来要简单一些，因为不需要手动的去通知其他线程了，生产者直接往队列中放数据直到队列满，消费者直接从队列中获取数据直到队列空，BlockingQueue会自动帮我们完成阻塞这个动作，还是先来看看代码</p>
<h4 id="生产者代码-1"><a href="#生产者代码-1" class="headerlink" title="生产者代码"></a>生产者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> isRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 总数，原子操作</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start producer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>isRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 往阻塞队列中添加数据</span>
                data <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 构造任务数据</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"producer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" create data："</span> <span class="token operator">+</span> data
                        <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"failed to put data："</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>跟上面一种方式没有很大的差别，倒是代码更加简单通透，不过需要注意的是对<strong>阻塞队列添加失败的错误处理</strong>；</p>
<h4 id="消费者代码-1"><a href="#消费者代码-1" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 内存缓冲区</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SLEEPTIME <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start consumer id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 模拟延迟</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>SLEEPTIME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 从阻塞队列中获取数据</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    data <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"consumer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" consume data："</span> <span class="token operator">+</span> data
                            <span class="token operator">+</span> <span class="token string">", size："</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Queue is empty, consumer "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                            <span class="token operator">+</span> <span class="token string">" is waiting, size："</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="主线程代码-1"><a href="#主线程代码-1" class="headerlink" title="主线程代码"></a>主线程代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.构建内存缓冲区</span>
    BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 2.建立线程池和线程</span>
    ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Producer prodThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Consumer consThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>prodThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>consThread3<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 3.睡一会儿然后尝试停止生产者</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread1<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread2<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    prodThread3<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 4.再睡一会儿关闭线程池</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>因为队列中添加和删除的操作比较频繁，所以这里使用<code>LinkedBlockingQueue</code>来作为阻塞队列，所以这里除了内存缓冲区有所不同以外，其他的都差不多…当然你也可以指定一个队列的大小；</p>
<h3 id="总结以及改进"><a href="#总结以及改进" class="headerlink" title="总结以及改进"></a>总结以及改进</h3><p>生产者-消费者模式很好地对生产者线程和消费者线程进行解耦，优化了系统整体的结构，同时由于缓冲区的作用，允许生产者线程和消费者线程存在执行上的性能差异，从一定程度上缓解了性能瓶颈对系统性能的影响；上面两种写法都是非常常规的写法，只能说能起码能在及格的基础上加个那么点儿分数，如果想要得高分可以去搜索搜搜 Disruptor 来实现一个无锁的生产者-消费者模型….这里就不提及了..</p>
<p><strong>改进：</strong>上面的线程输出可能会有点儿不友好（不直观），因为我们这里是直接使用的线程的 ID 来作为输出，我们也可以给线程弄一个名字来作为输出，以上；</p>
<hr>
<h1 id="Part-2-排序算法"><a href="#Part-2-排序算法" class="headerlink" title="Part 2.排序算法"></a>Part 2.排序算法</h1><p>排序算法当然也算是重点考察的对象之一了，毕竟基础且偏算法，当然我们有必要去了解常见的排序算法以及它们采取了怎样的思想又是如何实现的还有复杂度的问题，但是这里的话，主要就提及两种考的比较常见的排序算法：<strong>冒泡</strong>和<strong>快排</strong>，以及分别对它们进行的一些优化；</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡应该是比较基础的一种算法，我们以从小到大排序为例，它的基础思想是：<strong>从第一个数开始直到数组倒数第二个数，每一轮都去比较数组中剩下的数，如果后面的数据更小则两数交换</strong>，这样一轮一轮的比较交换下来，最大的那个数也就“沉到”了数组的最后，最小的“冒”到了数组的最前面，这样就完成了排序工作；</p>
<h3 id="基础算法代码（未优化）"><a href="#基础算法代码（未优化）" class="headerlink" title="基础算法代码（未优化）"></a>基础算法代码（未优化）</h3><p>很简单，直接上代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 冒泡排序
 *
 * @param nums 待排序的数组
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 从小到大排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里需要注意：<strong>加上正确性判断</strong>；（讨论：其实我看大多数地方都是没有这个的，不知道有没有加上的必要…求讨论）</p>
<p>另外光写完实现冒泡排序的算法是不算完的，还要养成良好的习惯去写测试单元用例，而且尽可能要考虑到多的点，例如这里的负数、多个相同的数之类的特殊情况，我就大概写一个吧，也欢迎指正：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSortTester</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 测试用例1：验证负数是否满足要求</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 输出测试结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 测试用例2：验证多个相同的数是否满足要求</span>
    nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 输出测试结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>想象一个这样的场景：如果该数组基本有序，或者在数组的后半段基本有序，上面的算法就会浪费许多的时间开销，所以我们不再使用双重嵌套去比较每两个元素的值，而只是不断比较数组每前后两个数值，让大的那个数不断“冒”到数组的最后，然后缩小尾边界的范围，并且增加一个标志位，表示这一趟是否发生了交换，如果没有那么证明该数组已经有序则完成了排序了：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 改进的冒泡排序
 *
 * @param nums 待排序的数组
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 使用一个数来记录尾边界</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 每次开始排序前，都设置flag为未排序过</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 前面的数字大于后面的数字就交换</span>
                <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
                temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 表示交换过数据;</span>
                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 减小一次排序的尾边界</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>同样的记得写单元测试函数；</p>
<h3 id="冒泡排序进一步优化"><a href="#冒泡排序进一步优化" class="headerlink" title="冒泡排序进一步优化"></a>冒泡排序进一步优化</h3><p>顺着这个思路，我们进一步想象一个场景：现在有一个包含 1000 个数的数组，仅有前面 100 个数无序，后面的 900 个数都比前面的 100 个数更大并且已经排好序，那么上面优化的方法又会造成一定的时间浪费，所以我们进一步增加一个变量记录最后发生交换的元素的位置，也就是排序的尾边界了：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 冒泡算法最优解
 *
 * @param nums 待排序的数组
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// flag来记录最后交换的位置，也就是排序的尾边界</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 排序未结束标志</span>
        k <span class="token operator">=</span> flag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// k 来记录遍历的尾边界</span>
        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 前面的数字大于后面的数字就交换</span>
                <span class="token comment" spellcheck="true">// 交换a[j-1]和a[j]</span>
                <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
                temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>

                <span class="token comment" spellcheck="true">// 表示交换过数据;</span>
                flag <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 记录最新的尾边界.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这应该是最优的冒泡排序了，同时也别忘记了最后要写测试单元用例代码；</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排也是一种很经典的算法，它使用了一种分治的思想，基本思想是：<strong>通过一趟排序将待排序的数组分成两个部分，其中一部分记录的是比关键字更小的，另一部分是比关键字更大的，然后再分别对着两部分继续进行排序，直到整个序列有序；</strong></p>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>非常经典的代码，直接上吧：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将数组分为两部分</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 递归排序左子数组</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 递归排序右子数组</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 枢轴记录</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 交换比枢轴小的记录到左端</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 交换比枢轴小的记录到右端</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 扫描完成，枢轴到位</span>
    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 返回的是枢轴的位置</span>
    <span class="token keyword">return</span> low<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>当然，在手撕的时候需要注意函数上的 Java Doc 格式的注释，这里省略掉是为了节省篇幅，另外<strong>别忘了测试单元用例代码</strong>；</p>
<p>上面的代码也很容易理解，<strong>其实就是一个“填坑”的过程</strong>，第一个“坑”挖在每次排序的第一个位置<code>arr[low]</code>，从序列后面往前找第一个比<code>pivot</code>小的数来把这个“坑”填上，这时候的“坑”就变成了当前的<code>arr[high]</code>，然后再从序列前面往后用第一个比<code>pivot</code>大的数把刚才的“坑”填上，如此往复，始终有一个“坑”需要我们填上，直到最后一个“坑”出现，这个“坑”使用一开始的<code>pivot</code>填上就可以了，而这个“坑”的位置也就是<code>pivot</code>该填上的正确位置，我们再把这个位置返回，就可以把当前序列分成两个部分再依次这样操作最终就达到排序的目的了，不得不说这样的思想挺神奇的；</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是O(n㏒n)，而是O(n^2)了。</p>
<p>究其根源，在于我们的代码实现中，每次只从数组第一个开始取。如果我们采用“三者取中”，即 arr[low], arr[high], arr[(low+high)/2] 三者的中值作为枢轴记录，则可以大大提高快速排序在最坏情况下的性能。但是，我们仍然无法将它在数组有序情形下的性能提高到O(n)。还有一些方法可以不同程度地提高快速排序在最坏情况下的时间性能。</p>
<p>此外，快速排序需要一个递归栈，通常情况下这个栈不会很深，为log(n)级别。但是，如果每次划分的两个数组长度严重失衡，则为最坏情况，栈的深度将增加到O(n)。此时，由栈空间带来的空间复杂度不可忽略。如果加上额外变量的开销，这里甚至可能达到恐怖的O(n^2)空间复杂度。所以，快速排序的最差空间复杂度不是一个定值，甚至可能不在一个级别。</p>
<p>为了解决这个问题，我们可以在每次划分后比较两端的长度，并先对短的序列进行排序（目的是先结束这些栈以释放空间），可以将最大深度降回到O(㏒n)级别。</p>
<p>关于优化的话，了解一个大概的思路就可以了，那在这里稍微总结一下：</p>
<ul>
<li>①三数取中作为枢轴记录；</li>
<li>②当待排序序列的长度分割到一定大小之后，使用插入排序；</li>
<li>③在一次分割结束后，可以把与<code>pivot</code>相等的元素聚在一起，继续下次分割时，不用再对与<code>pivot</code>相等的元素分割；</li>
<li>④优化递归操作；</li>
</ul>
<blockquote>
<p>参考文章：<a href="http://blog.51cto.com/flyingcat2013/1281614" target="_blank" rel="noopener">http://blog.51cto.com/flyingcat2013/1281614</a><br>想要了解的更多的童鞋可以戳这里：<a href="https://blog.csdn.net/insistGoGo/article/details/7785038" target="_blank" rel="noopener">https://blog.csdn.net/insistGoGo/article/details/7785038</a></p>
</blockquote>
<hr>
<h1 id="Part-3-二叉树相关算法"><a href="#Part-3-二叉树相关算法" class="headerlink" title="Part 3.二叉树相关算法"></a>Part 3.二叉树相关算法</h1><p>二叉树也是一个容易提及的概念和写算法的问题，特别是它的几种递归遍历和非递归遍历，都是基础且常考的点，那在这里就稍微整理整理吧…</p>
<h2 id="二叉树的几种递归遍历"><a href="#二叉树的几种递归遍历" class="headerlink" title="二叉树的几种递归遍历"></a>二叉树的几种递归遍历</h2><p>前序、中序、后序遍历都是非常基础且容易的遍历方法，重点还是在后面的中序和后续的非递归遍历上，当然还有层序遍历，所以这里不多说，直接给代码；</p>
<h3 id="前序遍历递归实现"><a href="#前序遍历递归实现" class="headerlink" title="前序遍历递归实现"></a>前序遍历递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="中序遍历递归实现"><a href="#中序遍历递归实现" class="headerlink" title="中序遍历递归实现"></a>中序遍历递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrderTraverse1</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="后序遍历递归实现"><a href="#后序遍历递归实现" class="headerlink" title="后序遍历递归实现"></a>后序遍历递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrderTraverse1</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preOrderTraverse1</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>前面三种遍历，也就是输出结点数据的位置不同而已，所以很容易，但是如果手写，建议问清楚面试官要求，是在遍历时直接输出还是需要函数返回一个List集合，然后<strong>注意写测试用例代码！</strong></p>
<h2 id="二叉树的几种非递归遍历"><a href="#二叉树的几种非递归遍历" class="headerlink" title="二叉树的几种非递归遍历"></a>二叉树的几种非递归遍历</h2><h3 id="★★层序遍历★★"><a href="#★★层序遍历★★" class="headerlink" title="★★层序遍历★★"></a>★★层序遍历★★</h3><p>层序遍历我们只需要增加使用一个队列即可，看代码很容易理解：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelTraverse</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="前序遍历非递归实现"><a href="#前序遍历非递归实现" class="headerlink" title="前序遍历非递归实现"></a>前序遍历非递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrderTraverse2</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TreeNode pNode <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pNode <span class="token operator">=</span> pNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//pNode == null &amp;&amp; !stack.isEmpty()</span>
            TreeNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pNode <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="★★中序遍历非递归实现★★"><a href="#★★中序遍历非递归实现★★" class="headerlink" title="★★中序遍历非递归实现★★"></a>★★中序遍历非递归实现★★</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 非递归中序遍历二叉树
 *
 * @param root 二叉树根节点
 * @return 中序遍历结果集
 */</span>
<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ArrayDeque<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="★★后续遍历非递归实现★★"><a href="#★★后续遍历非递归实现★★" class="headerlink" title="★★后续遍历非递归实现★★"></a>★★后续遍历非递归实现★★</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 二叉树的后序遍历
 *
 * @param root 二叉树根节点
 * @return 后序遍历结果集
 */</span>
<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Deque<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TreeNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// i ：判断如果右子树不为空且不为</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pre <span class="token operator">=</span> root<span class="token punctuation">;</span>
            root <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>如果比较难以理解的话，可以自己尝试着跟跟 Debug 然后看看过程；</p>
<h2 id="二叉树相关其他算法题"><a href="#二叉树相关其他算法题" class="headerlink" title="二叉树相关其他算法题"></a>二叉树相关其他算法题</h2><p>另外的话还有一些比较常见的关于树的算法，在文章的末尾，这里就不再赘述了：</p>
<p>链接：<a href="https://www.jianshu.com/p/4ef1f50d45b5" target="_blank" rel="noopener">https://www.jianshu.com/p/4ef1f50d45b5</a></p>
<hr>
<h1 id="Part-4-其他重要算法"><a href="#Part-4-其他重要算法" class="headerlink" title="Part 4.其他重要算法"></a>Part 4.其他重要算法</h1><p>除了上面 3 Part 比较重要的点之外，还有一些其他的算法也是经常考到的，下面我们来说；</p>
<h2 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1.反转链表"></a>1.反转链表</h2><p>这是一道很经典的题，不仅考你对链表的理解，而且还有一些<strong>细节（例如正确性判断/ 测试用例）</strong>需要你从代码层面去展现，下面我们给出两段代码，读者可以自行去比较，我只是提供一个思路；</p>
<h3 id="思路一：使用一个-Node-不断链接"><a href="#思路一：使用一个-Node-不断链接" class="headerlink" title="思路一：使用一个 Node 不断链接"></a>思路一：使用一个 Node 不断链接</h3><p>这是最经典的算法，也是需要我们牢牢掌握的方法，最重要的还是理解 <code>while()</code> 循环中的过程：</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> head <span class="token operator">||</span> null <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode temp <span class="token operator">=</span> head<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        temp<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="思路二：反转元素值然后重新赋给-Node"><a href="#思路二：反转元素值然后重新赋给-Node" class="headerlink" title="思路二：反转元素值然后重新赋给 Node"></a>思路二：反转元素值然后重新赋给 Node</h3><p>这是一个很简单的思路，比上个思路要多遍历一遍链表，但是好处是简单，思路清晰，实现起来容易，emm，像这一类问题我觉得另一个比较重要的就是<strong>举一反三</strong>的能力吧，在这里我只提供两个思路，其实还有很多种实现方法，当然也别忘了<strong>细节</strong>的东西~</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> head <span class="token operator">||</span> null <span class="token operator">==</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2.遍历链表head并将结果保存在List集合中</span>
    List<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> tempNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// end while：遍历完了链表并将结果保存在了List集合中</span>

    <span class="token comment" spellcheck="true">// 3.反转集合，并将值依次复制给链表</span>
    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> tempNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tempNode<span class="token punctuation">.</span>val <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2.合并两个有序链表"></a>2.合并两个有序链表</h2><p>问题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的；</p>
<p>同样的经典算法，需要掌握：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> l1<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        head <span class="token operator">=</span> l2<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这道题也是 LeetCode 上的一道题，我当时的做法是下面这样的，虽然看起来代码量多了不少而且看起来蠢蠢的..但是经过 LeetCode 测试，甚至比上面的实现要快上那么 2ms，<strong>特别提醒：下面的代码只是用作一个思路的参考，着重掌握上面的代码</strong> ：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 定义一个虚拟头结点方便遍历</span>
    ListNode dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
    ListNode pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 遍历l1链表</span>
    <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        len1<span class="token operator">++</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 保存l1链表的数据</span>
    pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 遍历l2链表</span>
    <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
    pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        len2<span class="token operator">++</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 保存l2链表的数据</span>
    pre <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1 <span class="token operator">+</span> len2<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将两个链表的数据整合并排序</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> len1<span class="token punctuation">,</span> len2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 拼接一个链表</span>
    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="3-两个链表的第一个公共结点"><a href="#3-两个链表的第一个公共结点" class="headerlink" title="3.两个链表的第一个公共结点"></a>3.两个链表的第一个公共结点</h2><p>题目描述：找出两个链表的第一个公共结点；</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 求两个链表中第一个公共结点
 *
 * @param pHead1 链表1头结点
 * @param pHead2 链表2头结点
 * @return 链表第一个公共结点
 */</span>
<span class="token keyword">public</span> ListNode <span class="token function">FindFirstCommonNode</span><span class="token punctuation">(</span>ListNode pHead1<span class="token punctuation">,</span> ListNode pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 1.正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> pHead1 <span class="token operator">||</span> null <span class="token operator">==</span> pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 2.遍历链表1把所有结点保存在列表中中</span>
    Vector<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> nodeList1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pHead1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nodeList1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pHead1 <span class="token operator">=</span> pHead1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 判断是否成环，成环则退出循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeList1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// end while：链表1中的所有结点都存入了nodeList1中</span>

    <span class="token comment" spellcheck="true">// 3.遍历链表2比较列表中的数据</span>
    Vector<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> nodeList2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 先判断nodeList1中是否存在相同结点，存在则返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeList1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> pHead2<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果不存在则继续遍历，并判断是否成环</span>
        nodeList2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        pHead2 <span class="token operator">=</span> pHead2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeList2<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// end while：遍历完了链表2并将所有结点保存在了nodeList2中</span>

    <span class="token comment" spellcheck="true">// 如果遍历完链表2则返回null</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>需要注意的细节是：①正确性判断；②判断链表是否自己成环；③注释；<strong>④注意要自己写测试用例啊</strong>…</p>
<p>另外还有一些类似的题目像是：①链表入环结点；②链表倒数第k个结点；之类的都是需要掌握的…</p>
<h2 id="4-二分查找算法"><a href="#4-二分查找算法" class="headerlink" title="4.二分查找算法"></a>4.二分查找算法</h2><p>二分查找也是一类比较常考的题目，其实代码也比较容易理解，直接上吧，再再再提醒一下：<strong>注意正确性判断还有测试用例…</strong></p>
<h3 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 二分查找普通实现。
 *
 * @param srcArray 有序数组
 * @param key      查找元素
 * @return 不存在返回-1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> end <span class="token operator">=</span> srcArray<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> start<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 二分查找递归实现。
 *
 * @param srcArray 有序数组
 * @param start    数组低地址下标
 * @param end      数组高地址下标
 * @param key      查找元素
 * @return 查找元素不存在返回-1
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> srcArray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> start<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>srcArray<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> srcArray<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">binSearch</span><span class="token punctuation">(</span>srcArray<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="5-斐波那契数列"><a href="#5-斐波那契数列" class="headerlink" title="5.斐波那契数列"></a>5.斐波那契数列</h2><p>这也是一道很经典的题，通常是要要求 N 值的范围的，常规写法应该很简单，所以需要掌握的是优化之后的算法：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> n <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> nums1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nums2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res <span class="token operator">=</span> nums1 <span class="token operator">+</span> nums2<span class="token punctuation">;</span>
        nums1 <span class="token operator">=</span> nums2<span class="token punctuation">;</span>
        nums2 <span class="token operator">=</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>还是注意正确性判断然后写测试用例…</p>
<hr>
<h1 id="手撕代码总结"><a href="#手撕代码总结" class="headerlink" title="手撕代码总结"></a>手撕代码总结</h1><p>如果用手写代码的话，确实是个挺麻烦的事儿，首先需要对代码有相当的熟悉程度，然后其次的话考察的都是一些细节的东西，例如：</p>
<ul>
<li><strong>编码规范</strong>：包括一些命名的规范/ 注释的规范等等；</li>
<li><strong>缩进</strong>：这个我自己倒是挺在意的..关于这个可以去参考参考阿里出的那个规范手册；</li>
<li><strong>注释</strong>：如果命名规范做得好的话其实是可以达到代码即注释的，但是仍然有一些需要标注的地方例如函数头之类的，最好还是做好注释；</li>
<li><strong>代码的完整性</strong>：我觉得这个包括对于<strong>错误的处理/ 正确性判断</strong>这样一类的东西；</li>
<li><strong>测试用例</strong>：每个函数都需要一定的测试来保证其正确性，所以这个还是挺有必要的，特别是一些边界情况，null 值判断之类的；</li>
<li><strong>想好再下笔</strong>：这一点其实也蛮重要的，不管是在纸上还是在我们平时的编程中，思路永远都是更重要的；</li>
</ul>
<p>说来说去还是关于代码的事，我觉得还是<strong>理清思路</strong>最重要，所以我们需要在一遍一遍熟悉代码的过程中，熟知这些代码的思路，只有搞清楚这些代码背后的原理了，我们才能正确且快速的写出我们心中想要的代码，而不是简单的去背诵，这样是没有很大效果的，以上…</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/08/15/java-i-o-bu-mi-mang-yi-wen-wei-nin-dao-hang/">
      Java I/O不迷茫，一文为您导航！
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E5%9F%BA%E7%A1%80/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java基础</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年8月15日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-8a974351a7da0e4f.png" alt=""></p>
<blockquote>
<p>前言：在之前的面试中，每每问到关于Java I/O 方面的东西都感觉自己吃了大亏..所以这里抢救一下..来深入的了解一下在Java之中的 I/O 到底是怎么回事..文章可能说明类的文字有点儿多，希望能耐心读完..</p>
</blockquote>
<h1 id="什么是-I-O"><a href="#什么是-I-O" class="headerlink" title="什么是 I/O?"></a>什么是 I/O?</h1><p>学习过计算机相关课程的童鞋应该都知道，I/O 即输入Input/ 输出Output的缩写，最容易让人联想到的就是屏幕这样的输出设备以及键盘鼠标这一类的输入设备，<strong>其广义上的定义就是：数据在内部存储器和外部存储器或其他周边设备之间的输入和输出；</strong></p>
<p>我们可以从定义上看到问题的核心就是：<strong>数据/ 输入/ 输出</strong>，在Java中，主要就是涉及到磁盘 I/O 和网络 I/O 两种了；</p>
<h2 id="简单理解Java-流（Stream）"><a href="#简单理解Java-流（Stream）" class="headerlink" title="简单理解Java 流（Stream）"></a>简单理解Java 流（Stream）</h2><p>通常我们说 I/O 都会涉及到诸如输入流、输出流这样的概念，那么什么是流呢？流是一个抽象但形象的概念，你可以简单理解成<strong>一个数据的序列</strong>，输入流表示从一个源读取数据，输出流则表示向一个目标写数据，在Java程序中，对于数据的输入和输出都是采用 “流” 这样的方式进行的，其设备可以是文件、网络、内存等；</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-5adda921daf3e174.png" alt=""></p>
<p>流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。</p>
<p>可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-799a448bc2fa0be9.png" alt=""></p>
<p><strong>“流”，代表了任何有能力产出数据的数据源对象或有能力接受数据的接收端对象，它屏蔽了实际的 I/O 设备中处理数据的细节——摘自《Think in Java》</strong></p>
<blockquote>
<p>参考资料：<a href="https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html" target="_blank" rel="noopener">深入理解 Java中的 流 (Stream)</a>：<a href="https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html" target="_blank" rel="noopener">https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html</a></p>
</blockquote>
<hr>
<h1 id="Java中的-I-O-类库的基本架构"><a href="#Java中的-I-O-类库的基本架构" class="headerlink" title="Java中的 I/O 类库的基本架构"></a>Java中的 I/O 类库的基本架构</h1><p>I/O 问题是任何编程语言都无法回避的问题，因为 I/O 操作是人机交互的核心，是机器获取和交换信息的主要渠道，所以如何设计 I/O 系统变成了一大难题，特别是在当今大流量大数据的时代，I/O 问题尤其突出，很容易称为一个性能的瓶颈，也正因为如此，在 I/O 库上也一直在做持续的优化，例如JDK1.4引入的 NIO，JDK1.7引入的 NIO 2.0，都一定程度上的提升了 I/O 的性能；</p>
<p>Java的 I/O 操作类在包 java.io下，有将近80个类，这些类大概可以分成如下 4 组：</p>
<ul>
<li>基于字节操作的 I/O 接口：InputStream 和 OutputStream；</li>
<li>基于字符操作的 I/O 接口：Writer 和 Reader；</li>
<li>基于磁盘操作的 I/O 接口：File；</li>
<li>基于网络操作的 I/O 接口：Socket；</li>
</ul>
<p>前两组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket类并不在java.io包下，但这里仍然把它们划分在了一起；<strong>I/O 只是人机交互的一种手段，除了它们能够完成这个交互功能外，我们更多的应该是关注如何提高它的运行效率；</strong></p>
<h2 id="00-基于字节的-I-O-操作接口"><a href="#00-基于字节的-I-O-操作接口" class="headerlink" title="00.基于字节的 I/O 操作接口"></a>00.基于字节的 I/O 操作接口</h2><p>基于字节的 I/O 操作的接口输入和输出分别对应是 InputStream 和 OutputStream，InputStream 的类层次结构如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-164b429e48cc6984.png" alt=""></p>
<p>输入流根据数据类型和操作方式又被划分成若干个子类，每个子类分别处理不同操作类型，OutputStream 输出流的类层次结构也是类似，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-ec198f479602da45.png" alt=""></p>
<p>这里就不详细解释每个子类如何使用了，如果感兴趣可以自己去看一下JDK的源码，而且的话从类名也能大致看出一二该类是在处理怎样的一些东西..这里需要说明两点：</p>
<p><strong>1）操作数据的方式是可以组合使用的：</strong></p>
<p>例如：</p>
<pre class=" language-java"><code class="language-java">OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"fileName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>；</code></pre>
<p><strong>2）必须要指定流最终写到什么地方：</strong></p>
<p>要么是写到磁盘，要么是写到网络中，但重点是你必须说明这一点，而且你会发现其实SocketOutputStream是属于FileOutputStream下的，也就是说写网络实际上也是写文件，只不过写网络还有一步需要处理，就是让底层的操作系统知道我这个数据是需要传送到其他地方而不是本地磁盘上的；</p>
<h2 id="01-基于字符的-I-O-操作接口"><a href="#01-基于字符的-I-O-操作接口" class="headerlink" title="01.基于字符的 I/O 操作接口"></a>01.基于字符的 I/O 操作接口</h2><p><strong>不管是磁盘还是网络传输，最小的存储单元都是字节，</strong>而不是字符，所以 I/O 操作的都是字节而不是字符，但是在我们日常的程序中操作的数据几乎都是字符，所以为了操作方便当然要提供一个可以直接写字符的 I/O 接口。而且从字符到字节必须经过编码转换，而这个编码又非常耗时，还经常出现乱码的问题，所以 I/O 的编码问题经常是让人头疼的问题，关于这个问题有一篇深度好文推荐一下：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">《深入分析 Java 中的中文编码问题》</a></p>
<p>下图是写字符的 I/O 操作接口涉及到的类，Writer 类提供了一个抽象方法 write(char cbuf[], int off, int len) 由子类去实现：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-d4dbe9e38536ca18.png" alt=""></p>
<p>读字符的操作接口也有类似的类结构，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-91acd9a4ba4b72fa.png" alt=""></p>
<p>读字符的操作接口中也是 int read(char cbuf[], int off, int len)，返回读到的 n 个字节数，<strong>不管是 Writer 还是 Reader 类它们都只定义了读取或写入的数据字符的方式</strong>，也就是怎么写或读，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘和网络的工作机制。</p>
<h2 id="01-字节与字符的转化接口"><a href="#01-字节与字符的转化接口" class="headerlink" title="01.字节与字符的转化接口"></a>01.字节与字符的转化接口</h2><p>另外数据持久化或网络传输都是以字节进行的，所以必须要有字符到字节或字节到字符的转化。字符到字节需要转化，其中读的转化过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-2a534e029337dbd8.png" alt=""></p>
<p>InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。StreamDecoder 正是完成字节到字符的解码的实现类。也就是当你用如下方式读取一个文件时：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span> 
       StringBuffer str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
       FileReader f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
       <span class="token keyword">while</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
           str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> 
       <span class="token punctuation">}</span> 
       str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>FileReader 类就是按照上面的工作方式读取文件的，FileReader 是继承了 InputStreamReader 类，实际上是读取文件流，然后通过 StreamDecoder 解码成 char，只不过这里的解码字符集是默认字符集。</p>
<p>写入也是类似的过程如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-fdfcde0c339f8c4c.png" alt=""></p>
<p>通过 OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程。</p>
<hr>
<h1 id="磁盘-I-O-的工作机制"><a href="#磁盘-I-O-的工作机制" class="headerlink" title="磁盘 I/O 的工作机制"></a>磁盘 I/O 的工作机制</h1><p>在介绍 Java 读取和写入磁盘文件之前，先来看看应用程序访问文件有哪几种方式；</p>
<h2 id="几种访问文件的方式"><a href="#几种访问文件的方式" class="headerlink" title="几种访问文件的方式"></a>几种访问文件的方式</h2><p>我们知道，<strong>读取和写入文件 I/O 操作都调用的是操作系统提供给我们的接口</strong>，因为磁盘设备是归操作系统管的，而只要是系统调用都可能存在内核空间地址和用户空间地址切换的问题，这是为了保证用户进程不能直接操作内核，保证内核的安全而设计的，现代的操作系统将虚拟空间划分成了内核空间和用户空间两部分并实现了隔离，但是这样虽然保证了内核程序运行的安全性，但是也必然存在数据可能需要从内核空间向用户用户空间复制的问题；</p>
<p>如果遇到非常耗时的操作，如磁盘 I/O，数据从磁盘复制到内核空间，然后又从内核空间复制到用户空间，将会非常耗时，<strong>这时操作系统为了加速 I/O 访问，在内核空间使用缓存机制，</strong>也就是将从磁盘读取的文件按照一定的组织方式进行缓存，入股用户程序访问的是同一段磁盘地址的空间数据，那么操作系统将从内核缓存中直接取出返回给用户程序，这样就可以减少 I/O 的响应时间；</p>
<h3 id="00-标准访问文件的方式"><a href="#00-标准访问文件的方式" class="headerlink" title="00. 标准访问文件的方式"></a>00. 标准访问文件的方式</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-e1c44aee68f486ea.png" alt=""></p>
<p>读取的方式是，当应用程序调用<code>read()</code>接口时：</p>
<ul>
<li>①操作系统首先检查在<strong>内核的高速缓存中是否存在需要的数据</strong>，如果有，那么直接从缓存中返回；</li>
<li>②如果没有，则<strong>从磁盘中读取，然后缓存在操作系统的缓存中；</strong></li>
</ul>
<p>写入的方式是，当应用程序调用<code>write()</code>接口时：</p>
<ul>
<li><strong>从用户地址空间复制到内核地址空间的缓存中</strong>，这时对用户程序来说写操作就已经完成了，至于什么时候在写到磁盘中由操作系统决定，除非显示地调用了 sync 同步命令；</li>
</ul>
<h3 id="01-直接-I-O-方式"><a href="#01-直接-I-O-方式" class="headerlink" title="01.直接 I/O 方式"></a>01.直接 I/O 方式</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-61e8a59a78b0ffc1.png" alt=""></p>
<p>所谓的直接 I/O 的方式就是应用程序直接访问磁盘数据，而不经过操作系统内核数据缓冲区，<strong>这样做的目的是减少一次从内核缓冲区到用户程序缓存的数据复制；</strong></p>
<p>这种访问文件的方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中，如在数据库管理系统中，系统明确地知道应该缓存哪些数据，应该失效哪些数据，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率，而这些情况如果是交给操作系统进行缓存，那么操作系统将不知道哪些数据是热点数据，哪些是只会访问一次的数据，因为它只是简单的缓存最近一次从磁盘读取的数据而已；</p>
<p>但是直接 I/O 也有负面影响，如果访问的数据不再应用程序缓存之中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢，因此直接 I/O 通常与 异步 I/O 进行结合以达到更好的性能；</p>
<h3 id="10-内存映射的方式"><a href="#10-内存映射的方式" class="headerlink" title="10.内存映射的方式"></a>10.内存映射的方式</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-1aebaca2c0c4b6a4.png" alt=""></p>
<p>内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。<strong>这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。</strong>当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。</p>
<h3 id="同步和异步访问文件的方式"><a href="#同步和异步访问文件的方式" class="headerlink" title="同步和异步访问文件的方式"></a>同步和异步访问文件的方式</h3><p>另外还有两种方式，一种是数据的读取和写入都是同步操作的同步方式，另一种是是当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待的异步访问方式，但从笔者就《深入分析 Java Web技术内幕》一书中的内容来看，这两种方式更像是对标准访问方式的一个具体说明，是标准访问方式对应的两种不同处理方法，知道就好了…</p>
<hr>
<h1 id="Java-访问磁盘文件"><a href="#Java-访问磁盘文件" class="headerlink" title="Java 访问磁盘文件"></a>Java 访问磁盘文件</h1><p>我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。</p>
<p>何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。</p>
<p>下面以上文读取文件的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-7519ebdc353ef6a1.png" alt=""></p>
<p>当传入一个文件路径，将会根据这个路径创建一个 File 对象来标识这个文件，然后将会根据这个 File 对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符 FileDescriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要 StreamDecoder 类将 byte 解码为 char 格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。至于操作系统是如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答，至于文件系统的相关细节可以参考另外的文章。</p>
<blockquote>
<p>参考文章：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">深入分析 Java I/O 的工作机制</a><br>关于这一part，我们只需要了解一下就可以，我也是直接复制就完事儿…</p>
</blockquote>
<h2 id="Java-序列化技术"><a href="#Java-序列化技术" class="headerlink" title="Java 序列化技术"></a>Java 序列化技术</h2><p><strong>Java序列化就是将一个对象转化成一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的。</strong>需要持久化，对象必须继承 <code>java.io.Serializable</code> 接口，或者将其转为字节数组，用于网络传输；</p>
<h3 id="一个实际的序列化例子"><a href="#一个实际的序列化例子" class="headerlink" title="一个实际的序列化例子"></a>一个实际的序列化例子</h3><p><strong>第一步：创建一个用于序列化的对象</strong></p>
<p>为了具体说明序列化在Java中是如何运作的，我们来写一个实际的例子，首先我们来写一个用于序列化的对象，然后实现上述的接口：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 用于演示Java中序列化的工作流程...
 *
 * @author: @我没有三颗心脏
 * @create: 2018-08-15-下午 14:37
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>

    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,My Name is "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>注意：一个类的对象想要序列化成功，必须满足两个条件</p>
<ul>
<li>①实现上述的接口；</li>
<li>②保证该类的所有属性必须都是可序列化的，如果不希望某个属性序列化（例如一些敏感信息），可以加上<code>transient</code>关键字；</li>
</ul>
<p><strong>第二步：序列化对象</strong></p>
<p>如下的代码完成了实例化一个 People 对象并其序列化到D盘的根目录下的一个操作，这里呢按照 Java 的标准约定将文件的后缀写成 .ser 的样子，你也可以写成其他的…</p>
<pre class=" language-java"><code class="language-java">People people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
people<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"我没有三颗心脏"</span><span class="token punctuation">;</span>
people<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
    FileOutputStream fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:/people.ser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ObjectOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fileOutputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
    out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>people<span class="token punctuation">)</span><span class="token punctuation">;</span>
    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fileOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Serialized data is saved in D:/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>第三步：反序列化对象</strong></p>
<p>下面的程序完成了对刚才我们序列化的文件还原成一个People对象的过程，并获取了其中的参数，但是注意，由于我们希望 age 属性是短暂的加入了<code>transient</code>关键字， 所以我们无法获取到序列化时 People 的 age 属性：</p>
<pre class=" language-java"><code class="language-java">People people <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    FileInputStream fileIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/people.ser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ObjectInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>fileIn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    people <span class="token operator">=</span> <span class="token punctuation">(</span>People<span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fileIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"People class not found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Deserialized People..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Name: "</span> <span class="token operator">+</span> people<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Age: "</span> <span class="token operator">+</span> people<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>输出结果如下：</p>
<pre class=" language-java"><code class="language-java">Deserialized People<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Name<span class="token operator">:</span> 我没有三颗心脏
Age<span class="token operator">:</span> <span class="token number">0</span></code></pre>
<h3 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h3><p>上述的例子中我们完成了对一个 People 对象序列化和反序列化的过程，我们现在来做一点简单的修改，例如把age字段的<code>transient</code>关键字去掉：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello,My Name is "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>然后我们再运行我们刚才反序列化的代码，会发现，这个时候程序竟然报错了，说是serialVersionUID不一致：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-7679c131520a584f.png" alt=""></p>
<p>事实上，如果你经常看别人的代码的话，或许会有留意到诸如这样的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 876323262645176354L<span class="token punctuation">;</span></code></pre>
<p>就这一长串的东西也不知道是在干嘛的，但这其实<strong>是为了保证序列化版本的兼容性，即在版本升级后序列化仍保持对象的唯一性；</strong>我们通过上述的修改也感受到了其中的一二，<strong>但是问题是：我们并没有在需要序列化的对象中写任何关于这个UID的代码呀？</strong></p>
<p>这是个有趣的问题，通常情况下，如果我们实现了序列化接口，但是没有自己显式的声明这个UID的话，那么JVM就会根据该类的类名、属性名、方法名等自己计算出一个独一无二的变量值，然后将这个变量值一同序列化到文件之中，而在反序列化的时候同样，会根据该类计算出一个独一无二的变量然后进行比较，不一致就会报错，但是我怀着强烈的好奇心去反编译了一下.class文件，并没有发现编译器写了UDI这一类的东西，我看《深入分析 Java Web 技术内幕》中说，实际上是写到了二进制文件里面了；</p>
<ul>
<li><strong>不显式声明的缺点：</strong>一旦写好了某一个类，那么想要修改就不行了，所以我们最好自己显式的去声明；</li>
<li><strong>显式声明的方式：</strong>①使用默认的1L作用UID；②根据类名、接口名等生成一个64位的哈希字段，现在的编译器如IDEA、Eclipse都有这样的功能，大家感兴趣去了解下；</li>
</ul>
<h3 id="序列化用来干什么？"><a href="#序列化用来干什么？" class="headerlink" title="序列化用来干什么？"></a>序列化用来干什么？</h3><p>虽然我们上面的程序成功将一个对象序列化保存到磁盘，然后从磁盘还原，但是这样的功能到底可以应用在哪些场景？到底可以干一些什么样的事情呢？下面举一些在实际应用中的例子：</p>
<ul>
<li>Web服务器中保存Session对象，如Tomcat会在服务器关闭时把session序列化存储到一个名为session.ser的文件之中，这个过程称为session的钝化；</li>
<li>网络上传输对象，如分布式应用等；</li>
</ul>
<h3 id="关于序列化的一些细节"><a href="#关于序列化的一些细节" class="headerlink" title="关于序列化的一些细节"></a>关于序列化的一些细节</h3><p>1.如果一个类没有实现Serializable接口，但是它的基类实现了，那么这个类也是可以序列化的；</p>
<p>2.相反，如果一个类实现了Serializable接口，但是它的父类没有实现，那么这个类还是可以序列化（Object是所有类的父类），但是序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，会发现该变量数值与序列化时的数值不同（一般为null或者其他默认值），而且这个父类里面必须有无参的构造方法，不然子类反序列化的时候会报错。</p>
<blockquote>
<p>了解到这里就可以了，更多的细节感兴趣的童鞋可以自行去搜索引擎搜索..</p>
</blockquote>
<hr>
<h1 id="网络-I-O-工作机制"><a href="#网络-I-O-工作机制" class="headerlink" title="网络 I/O 工作机制"></a>网络 I/O 工作机制</h1><p>数据从一台主机发送到网络中的另一台主机需要经过很多步骤，首先双方需要有沟通的意向，然后要有能够沟通的物理渠道（物理链路），其次，还要保障双方能够正常的进行交流，例如语言一致的问题、说话顺序的问题等等等；</p>
<h2 id="Java-Socket-的工作机制"><a href="#Java-Socket-的工作机制" class="headerlink" title="Java Socket 的工作机制"></a>Java Socket 的工作机制</h2><p>看到有地方说：<strong>网络 I/O 的实质其实就是对 Socket 的读取；</strong>那Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。</p>
<p>下图是典型的基于 Socket 的通信的场景：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-d0162c101120e3b6.png" alt=""></p>
<p>主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。</p>
<h3 id="建立通信链路"><a href="#建立通信链路" class="headerlink" title="建立通信链路"></a>建立通信链路</h3><p>当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 <strong>TCP 的三次握手协议</strong>，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。</p>
<p>与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。</p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。</p>
<p>当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。</p>
<h2 id="NIO-的工作方式"><a href="#NIO-的工作方式" class="headerlink" title="NIO 的工作方式"></a>NIO 的工作方式</h2><h3 id="BIO-带来的挑战"><a href="#BIO-带来的挑战" class="headerlink" title="BIO 带来的挑战"></a>BIO 带来的挑战</h3><p>BIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。<strong>一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。</strong>虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。<strong>如当前一些需要大量 HTTP 长连接的情况</strong>，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。<strong>即使线程的数量不是问题，仍然有一些问题还是无法避免的。</strong>如这种情况，<strong>我们想给某些客户端更高的服务优先级</strong>，很难通过设计线程的优先级来完成，另外一种情况是，<strong>我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。</strong>以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。</p>
<h3 id="NIO-的工作机制"><a href="#NIO-的工作机制" class="headerlink" title="NIO 的工作机制"></a>NIO 的工作机制</h3><p>很多人都把NIO翻译成New IO，但我更觉得No-Block IO更接近它的本意，也就是非阻塞式IO，它虽然是非阻塞式的，但它是同步的，我们先看一下 NIO 涉及到的关联类图，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-f2e440c85e1401cc.png" alt=""></p>
<p><strong>上图中有两个关键类：Channel 和 Selector</strong>，它们是 NIO 中两个核心概念。我们还用前面的城市交通工具来继续比喻 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态。<strong>这里还有一个 Buffer 类</strong>，它也比 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 是汽车的话就是汽车上的座位，高铁上就是高铁上的座位，它始终是一个具体的概念，与 Stream 不同。Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是你在去上车之前并不知道，这个车上是否还有没有座位了，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了，对你是透明的。</p>
<p><strong>NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们</strong>，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度是需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的。而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制。</p>
<p>理解了这些概念后我们看一下，实际上它们是如何工作的，下面是典型的一段 NIO 代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ServerSocketChannel ssc <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssc<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置为非阻塞方式</span>
        ssc<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssc<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注册监听的事件</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Set selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取得所有key集合</span>
            Iterator it <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                SelectionKey key <span class="token operator">=</span> <span class="token punctuation">(</span>SelectionKey<span class="token punctuation">)</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span> <span class="token operator">==</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    ServerSocketChannel ssChannel <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                 SocketChannel sc <span class="token operator">=</span> ssChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//接受到服务端的请求</span>
                    sc<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    sc<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> 
                <span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span> <span class="token operator">==</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    SocketChannel sc <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">int</span> n <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读取数据</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器。</p>
<p>在上面的这段程序中，是将 Server 端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在实际应用中，我们通常会把它们放在两个线程中，<strong>一个线程专门负责监听客户端的连接请求，而且是阻塞方式执行的；另外一个线程专门来处理请求，这个专门处理请求的线程才会真正采用 NIO 的方式</strong>，像 Web 服务器 Tomcat 和 Jetty 都是这个处理方式，关于 Tomcat 和 Jetty 的 NIO 处理方式可以参考文章《 Jetty 的工作原理和与 Tomcat 的比较》。</p>
<p>下图是描述了基于 NIO 工作方式的 Socket 请求的处理过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-2ebbc00c67778d91.png" alt=""></p>
<p>上图中的 Selector 可以同时监听一组通信信道（Channel）上的 I/O 状态，前提是这个 Selector 要已经注册到这些通信信道中。选择器 Selector 可以调用 select() 方法检查已经注册的通信信道上的是否有 I/O 已经准备好，如果没有至少一个信道 I/O 状态有变化，那么 select 方法会阻塞等待或在超时时间后会返回 0。上图中如果有多个信道有数据，那么将会将这些数据分配到对应的数据 Buffer 中。所以关键的地方是有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连接请求。</p>
<h3 id="Buffer-的工作方式"><a href="#Buffer-的工作方式" class="headerlink" title="Buffer 的工作方式"></a>Buffer 的工作方式</h3><p>上面介绍了 Selector 将检测到有通信信道 I/O 有数据传输时，通过 selelct() 取得 SocketChannel，将数据读取或写入 Buffer 缓冲区。下面讨论一下 Buffer 如何接受和写出数据？</p>
<p>Buffer 可以简单的理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有四个索引。如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">capacity</td>
<td align="left">缓冲区数组的总长度</td>
</tr>
<tr>
<td align="left">position</td>
<td align="left">下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity</td>
</tr>
<tr>
<td align="left">mark</td>
<td align="left">用于记录当前 position 的前一个位置或者默认是 0</td>
</tr>
</tbody></table>
<p>在实际操作数据时它们有如下关系图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-e5a91320976c24f6.png" alt=""></p>
<p>我们通过 ByteBuffer.allocate(11) 方法创建一个 11 个 byte 的数组缓冲区，初始状态如上图所示，position 的位置为 0，capacity 和 limit 默认都是数组长度。当我们写入 5 个字节时位置变化如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java-I-O%E4%B8%8D%E8%BF%B7%E8%8C%AB%EF%BC%8C%E4%B8%80%E6%96%87%E4%B8%BA%E4%BD%A0%E5%AF%BC%E8%88%AA%EF%BC%81/7896890-f6f473827be537e6.png" alt=""></p>
<p>这时底层操作系统就可以从缓冲区中正确读取这 5 个字节数据发送出去了。在下一次写数据之前我们在调一下 clear() 方法。缓冲区的索引状态又回到初始位置。</p>
<p>这里还要说明一下 mark，当我们调用 mark() 时，它将记录当前 position 的前一个位置，当我们调用 reset 时，position 将恢复 mark 记录下来的值。</p>
<p>还有一点需要说明，通过 Channel 获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区再将数据复制到 Buffer 中，这个的操作系统缓冲区就是底层的 TCP 协议关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较耗性能，Buffer 提供了另外一种直接操作操作系统缓冲区的的方式即 ByteBuffer.allocateDirector(size)，这个方法返回的 byteBuffer 就是与底层存储空间关联的缓冲区，它的操作方式与 linux2.4 内核的 sendfile 操作方式类似。</p>
<h3 id="Java-NIO-实例"><a href="#Java-NIO-实例" class="headerlink" title="Java NIO 实例"></a>Java NIO 实例</h3><p>上面从 NIO 中引入了一些概念，下面我们对这些概念再来进行简单的复述和补充：</p>
<ul>
<li><strong>缓冲区Buffer：</strong>缓冲区是一个对象，里面存的是数据，NIO进行通讯，传递的数据，都包装到Buffer中，Buffer是一个抽象类。子类有ByteBuffer、CharBuffer等，常用的是字节缓冲区，也就是ByteBuffer；</li>
<li><strong>通道Channel：</strong>channel是一个通道，通道就是通流某种物质的管道，在这里就是通流数据，他和流的不同之处就在于，流是单向的，只能向一个方向流动，而通道是一个管道，有两端，是双向的，可以进行读操作，也可以写操作，或者两者同时进行；</li>
<li><strong>多路复用器Selector：</strong>多路复用器是一个大管家，他管理着通道，通道把自己注册到Selector上面，Selector会<strong>轮询</strong>注册到自己的管道，通过判断这个管道的不同的状态，来进行相应的操作；</li>
</ul>
<p><strong>NIO 工作机制的核心思想就是：</strong>客户端和服务器端都是使用的通道，通道具有事件，可以将事件注册到多路复选器上，事件有就绪和非就绪两种状态，就绪的状态会放到多路复选器的就绪键的集合中，起一个线程不断地去轮询就绪的状态，根据不同的状态做不同的处理</p>
<blockquote>
<p>参考资料：<a href="https://wangjingxin.top/2017/01/17/io/" target="_blank" rel="noopener">https://wangjingxin.top/2017/01/17/io/</a></p>
</blockquote>
<h3 id="NIO-和-IO-的主要区别"><a href="#NIO-和-IO-的主要区别" class="headerlink" title="NIO 和 IO 的主要区别"></a>NIO 和 IO 的主要区别</h3><ol>
<li><strong>面向流与面向缓冲.</strong><br>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。</li>
<li><strong>阻塞与非阻塞IO</strong><br>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</li>
<li><strong>选择器（Selectors）</strong><br>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</li>
</ol>
<hr>
<h1 id="Java-AIO-简单了解"><a href="#Java-AIO-简单了解" class="headerlink" title="Java AIO 简单了解"></a>Java AIO 简单了解</h1><p>AIO就是异步非阻塞IO，A就是asynchronous的意思，因为NIO1.0虽然面向缓冲，利用多路复选器实现了同步非阻塞IO，可是在NIO1.0中需要使用一个线程不断去轮询就绪集合，开销也是比较大的，所以在jdk1.7中扩展了NIO，称之为NIO2.0，NIO2.0中引入了AIO，此外NIO2.0中还引入了异步文件通道，那么究竟是怎么实现异步的呢？</p>
<p>AIO 有三个特点，它的特点也可以说明它是如何完成异步这样的操作的：</p>
<ul>
<li>①读完了再通知我；</li>
<li>②不会加快 I/O，只是在读完后进行通知；</li>
<li>③使用回调函数，进行业务处理；</li>
</ul>
<p><strong>AIO 的核心原理就是：</strong>对客户端和服务器端的各种操作进行回调函数的注册（通过实现一个CompletionHandler接口，其中定义了一个completed的成功操作方法和一个fail的失败方法）。在完成某个操作之后，就会自己去调用该注册到该操作的回调函数，达到异步的效果。</p>
<h2 id="BIO-NIO-AIO-的简单理解"><a href="#BIO-NIO-AIO-的简单理解" class="headerlink" title="BIO/ NIO/ AIO 的简单理解"></a>BIO/ NIO/ AIO 的简单理解</h2><p>我们在这里假设一个烧了一排开水的场景，<strong>BIO（同步阻塞IO）</strong>的做法就是，叫一个线程停留在一个水壶那，直到这个水壶烧开我再去处理下一个水壶；<strong>NIO（准备好再通知我，同步非阻塞IO）</strong>的做法就是叫一个线程不断地去询问每个水壶的状态，看看是否有水壶的状态发生了变化，变化则再去做相应的处理；<strong>AIO（读完了再通知我，异步非阻塞IO）</strong>的做法是在每个水壶上都安装一个装置，当水壶烧开之后就会自动通知我水壶烧开了让我做相应的处理；</p>
<blockquote>
<p>如果还觉得理解起来有困难的童鞋建议阅读以下这篇文章，相信会有收获：<a href="http://loveshisong.cn/编程技术/2016-06-25-十分钟了解BIO-NIO-AIO.html" target="_blank" rel="noopener"><code>http://loveshisong.cn/编程技术/2016-06-25-十分钟了解BIO-NIO-AIO.html</code></a></p>
</blockquote>
<h2 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h2><ul>
<li><strong>BIO方式适用于连接数目比较小且固定的架构</strong>，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li><strong>NIO方式适用于连接数目多且连接比较短（轻操作）的架构</strong>，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li><strong>AIO方式使用于连接数目多且连接比较长（重操作）的架构</strong>，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<hr>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这篇文章大量复制粘贴到《深入分析 Java Web 技术内幕》第二节“深入分析 Java I/O 的工作机制”的内容，没办法确实很多描述性的概念以及说明，自己的说明也没有达到用简单语言能描述复杂事物的程度..所以可能看起来这篇文章会有那么点儿难以下咽..我自己的话也是为了写着一篇文章查了很多资料，书也是翻了很多很多遍才对Java 中的 I/O 相关的知识有所熟悉，不过耗费的时间也是值得的，同时也希望观看文章的你能够有所收获，也欢迎各位指正！</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/08/15/qiu-zhao-ti-qian-pi-cvte-yi-mian-gua-a-li-san-mian-gua/">
      秋招提前批（CVTE一面挂、阿里三面挂）
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>编程人生/面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年8月15日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="7月27日：CVTE一面-30分钟（挂）"><a href="#7月27日：CVTE一面-30分钟（挂）" class="headerlink" title="7月27日：CVTE一面 30分钟（挂）"></a>7月27日：CVTE一面 30分钟（挂）</h2><ol>
<li>自我介绍</li>
<li>有没有做过JavaWeb相关的项目？你觉得难点在哪里呢？</li>
<li>你这个博客系统有没有加权限系统？如果被拦截封包获取了账号密码怎么办？（没加，凉拌..）</li>
<li>用过事务吗？怎么用的举一个实际的例子？</li>
<li>Spring中的@Transactional放在类级别和方法级别上有什么不同？（不知道..）</li>
<li>你对Java哪一个方面的知识熟悉？</li>
<li>List/ Set/ Map有什么区别？</li>
<li>谈一下HashMap插入元素的过程？</li>
<li>HashMap安全吗？那有安全的Map吗？</li>
<li>多线程并发有什么问题？刚才安全的Map是如何解决这个问题的？</li>
<li>Java中实现多线程有哪些方式？</li>
</ol>
<blockquote>
<p>总体感觉CVTE一面还没开始问就已经结束了…所以面完感觉挺不好的，总觉得自己会凉凉…结果一查结果真凉了…懵逼…</p>
</blockquote>
<h2 id="7月30日：阿里一面-36分钟"><a href="#7月30日：阿里一面-36分钟" class="headerlink" title="7月30日：阿里一面 36分钟"></a>7月30日：阿里一面 36分钟</h2><ol>
<li>自我介绍</li>
<li>面试官开始自己介绍他所属的部门然后平时的一些业务</li>
<li>说一下HashMap的底层结构？</li>
<li>为什么1.8要引入红黑树这种结构呢？</li>
<li>HashMap线程安全吗？那有没有线程安全的Map？（ConcurrentHashMap还有一个Collections类中的静态内部类SynrhonizedMap）</li>
<li>ConcurrentHashMap底层结构？</li>
<li>对JDK1.5的concurrent包了解吗？（不了解…）</li>
<li>Java中有两种错误你能说一下嘛？（想不起具体名字来了..解释了半天..）</li>
<li>说下JVM的内存结构？（本地方法栈打死没想起来…）堆、栈分别存储什么信息？</li>
<li>说一下新生代和永久代有什么关系？</li>
<li>平时学校学什么课？算法和数据结构学过吧？</li>
<li>说一个你印象最深刻的数据结构，用来解决什么典型问题？（堆、TopK问题）</li>
<li>说一个典型的算法解决什么问题？再回答一个（答得不好…）</li>
<li>贪心算法有什么优点缺点？贪心算法可能不是最优解那什么算法能解决呢？（动态规划这个词老想不起来..）</li>
<li>Spring了解吗？说一下装载Bean的过程？</li>
<li>设计模式了解吗？说几个常用的</li>
<li>装饰器模式和代理模式有什么区别？</li>
<li>看你做过这么多项目说一个你刚开始难以解决然后通过什么方式最终解决的？</li>
<li>有没有什么要问我的？</li>
<li>平时都怎么学习的？</li>
</ol>
<blockquote>
<p>正在寝室收拾东西的时候预约了6分钟后面试，那个激动..总的来说感觉答得不好，确实是没啥面试经验，有很多东西自己知道没有表达，不过回答的时候倒是挺有自信的，电话一挂脑子一去回想.药丸…不过面试官还算是比较好的…希望能过吧…</p>
</blockquote>
<h2 id="8月5日：阿里二面-60分钟"><a href="#8月5日：阿里二面-60分钟" class="headerlink" title="8月5日：阿里二面 60分钟"></a>8月5日：阿里二面 60分钟</h2><ol>
<li>面试官开场白：介绍部门、业务，上一轮面试的大概情况，今天准备聊一聊编程能力和项目的一些问题；</li>
<li>面向对象三大特点？你怎么理解多态？Java中是怎么实现多态的？</li>
<li>序列化有了解过吗？</li>
<li>Java网络I/O了解吗？（不是很了解..）HTTP三次握手和四次挥手的详细过程能说下吗？</li>
<li>设计题：一个网络聊天室有思路吗？不要求界面，只说思路（后来想了想回答的很一般..）</li>
<li>ArrayList和LinkedList的区别？ArrayList是怎么扩容的？</li>
<li>Java中有两种异常，你能说说嘛（感觉是看了上一个面试官的评价来看我复习没有的感觉..）？Exception又分为两种你知道吗？举一个RunTimeException你遇到过的？（我说的NullPointer）除了这个你再说一个？再举一个非RunTimeException？</li>
<li>GC什么时候开始？我调用System.gc()能保证GC一定发生吗？</li>
<li>你说一下类加载器是怎么回事？（我说了一下双亲委派模型..但后来想面试官好像问的是怎么加载class？…）怎么实现自己的类加载器？</li>
<li>设计题：现在我的jar包在云上，怎么动态添加进我的项目中？（不知道..后来想了一下自己写ClassLoader应该可以..）</li>
<li>看你简历有前端的东西，那前端盒子模型有了解吗？</li>
<li>可以给margin或者padding这样的属性赋值为负数吗？</li>
<li>我想把border变成一个虚线该怎么写？（忘了具体的dashed，只记得border-style..）</li>
<li>平常都用什么数据库？（MySQL）那MySQL有两种引擎了解吗？有什么区别？（这个说得挺完整的）我要用SQL获得一个表级锁应该怎么写？（不了解..）我给一个表三个ABC列建了一个组合索引，我查询B会用到索引嘛？（不知道..）</li>
<li>事务了解吗？四大基本特性？什么是隔离性？数据库并发有几个隔离级别？（我说我从面临的问题开始说面试官说不用只用说几个级别就可以）MySQL默认级别？你确定？（确定..）</li>
<li>平时有用到什么框架？（Spring/ SpringMVC/ SpringBoot/ MyBatis）</li>
<li>MyBatis问一个问题，在mapper文件中#{}和${}有什么区别？</li>
<li>Spring有两大特性，你是怎么理解IoC控制反转的？AOP实现原理你了解吗？JDK代理为什么非要实现一个接口呢？（这个一时间忘了…）</li>
<li>MVC你是怎么理解的？</li>
<li>什么时候需要重写equals()？什么时候需要重写hashCode()？</li>
<li>项目相关，你博客是从0到有的？为什么要造这个轮子？</li>
<li>JavaWeb安全方面的问题，你这个留言啥的有没有啥问题？（XSS攻击）知道有问题为啥不搞一下？（我…）</li>
<li>我把面试结果报上去，一般两三天后出结果，拜拜；</li>
</ol>
<blockquote>
<p>因为是靠回忆，所以有些问题的顺序有点儿记不太清了，比较基础但是有些宽泛..问了我一些前端的问题..比较遗憾的是网络I/O这一块自己不是特别熟悉，然后那一道设计题自己没有回答得很好..面试官说看得出我基础还行就是深度不够，他说要看总体的面试情况如果靠前就安排下一轮面试，让我自己下去准备等通知，但总觉得他在套路我..早上转发了一只专属锦鲤，希望能带来好运吧..</p>
</blockquote>
<h2 id="8月13日：阿里三面（P9钉钉视频面）-120分钟左右"><a href="#8月13日：阿里三面（P9钉钉视频面）-120分钟左右" class="headerlink" title="8月13日：阿里三面（P9钉钉视频面） 120分钟左右"></a>8月13日：阿里三面（P9钉钉视频面） 120分钟左右</h2><p>1.面试官让进一个链接做六道题，一个小时之后它来看代码，可以搜索资料啥的都可以，大概是这样六道题：①反转一串字符串；②从一串JSON字符串中提取所有的一个属性并输出；③统计一串字符串中的数字、英文字母、空格、其他字符的个数并打印输出；④计算N的阶乘；⑤数组排序算法随便写；⑥创建三个线程ABC，分别打印其线程名十次，并按照ABC的顺序执行；<br>2.最近的项目有没有什么想说的？印象深刻的？<br>3.项目有什么难点？怎么解决的？<br>4.设计模式有了解过哪些？模板模式应用于什么样的场景？<br>5.OSI七层模型知道吗？IP在哪一层？TCP在哪一层？<br>6.对称加密与非对称加密有了解吗？<br>7.谈谈对BIO/ NIO/ AIO的理解？（有点忘了..说的有点问题面试官给解释了一下..）分别用于什么样的场景？<br>8.SpringBoot你觉得对于MVC有什么不一样的地方，有什么优点？<br>9.平时怎么学习的？<br>10.有什么要问的..然后问了一些自己关心的问题，并让面试官给我一些建议，感觉自己凉凉..</p>
<blockquote>
<p>第二天下午更新了状态显示已回绝了..</p>
</blockquote>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>其实自己投了蛮多公司的，但是目前接到电话并且面试的，就只有阿里和CVTE，特别是CVTE感觉还蛮效率的..投递了没过几天就打电话预约面试了，emm..虽然两家公司提前批的面试都挂了..但我已经重新申请了正常的网申流程..嘻嘻..感觉还是<strong>基础至上</strong>吧..而且的话，电话面试的经验也很重要，现在回想CVTE一面的时候确实自己也不知道是个啥状态..问题也没有回答很好..挂的那自然也是理所当然..对于阿里的话就比较可惜吧..特别是三面，问的问题都不是自己不知道的，而差不多都是自己有些遗忘或者不是很熟悉的..决定还是抓紧时间回炉锻造锻造..</p>
<p>不过幸运的是这只是提前批吧..自己还是有一些时间去准备，通过上面的四次面试也是知道了自己的不足，另外想说的一点是：<strong>举一反三</strong>的能力，阿里三面也跟面试官有聊到，就是一个问题，你回答的时候最好能够引申出其他相关的一些东西，换位思考的角度讲，面试官希望这样，而你又能很好的展现自己的能力和基础知识，特别担心那种自己明明知道却说不好的问题，或者是遗漏了一些点的问题，还是下来需要多花时间准备吧..加油..</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/07/28/java-ji-he-bi-hui-14-wen-jing-xuan-mian-shi-ti-zheng-li/">
      Java集合必会14问(精选面试题整理)
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Java基础/面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年7月28日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java%E9%9B%86%E5%90%88%E5%BF%85%E4%BC%9A14%E9%97%AE%EF%BC%88%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89/7896890-02b1d8e34bbd5d03.png" alt=""></p>
<blockquote>
<p>前言：把这段时间复习的关于集合类的东西整理出来，特别是HashMap相关的一些东西，之前都没有很注意1.7 -&gt;&gt; 1.8的变化问题，但后来发现这其实变化挺大的，而且很多整理的面试资料都没有更新（包括我之前整理的…）</p>
</blockquote>
<h2 id="1）说说常见的集合有哪些吧？"><a href="#1）说说常见的集合有哪些吧？" class="headerlink" title="1）说说常见的集合有哪些吧？"></a>1）说说常见的集合有哪些吧？</h2><p>答：Map接口和Collection接口是所有集合框架的父接口：</p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<hr>
<h2 id="2）HashMap与HashTable的区别？"><a href="#2）HashMap与HashTable的区别？" class="headerlink" title="2）HashMap与HashTable的区别？"></a>2）HashMap与HashTable的区别？</h2><p>答：</p>
<ol>
<li><p>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</p>
</li>
<li><p>HashMap允许K/V都为null；后者K/V都不允许为null；</p>
</li>
<li><p>HashMap继承自AbstractMap类；而Hashtable继承自Dictionary类；</p>
</li>
</ol>
<hr>
<h2 id="3）HashMap的put方法的具体流程？"><a href="#3）HashMap的put方法的具体流程？" class="headerlink" title="3）HashMap的put方法的具体流程？"></a>3）HashMap的put方法的具体流程？</h2><blockquote>
<p>图引用自：<a href="https://blog.csdn.net/u011240877/article/details/53358305" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/53358305</a></p>
</blockquote>
<p>答：下面先来分析一下源码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 1.如果table为空或者长度为0，即没有元素，那么使用resize()方法扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 2.计算插入存储的数组索引i，此处计算方法同 1.7 中的indexFor()方法</span>
    <span class="token comment" spellcheck="true">// 如果数组为空，即不存在Hash冲突，则直接插入数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 3.插入时，如果发生Hash冲突，则依次往下判断</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        HashMap<span class="token punctuation">.</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// a.判断table[i]的元素的key是否与需要插入的key一样，若相同则直接用新的value覆盖掉旧的value</span>
        <span class="token comment" spellcheck="true">// 判断原则equals() - 所以需要当key的对象重写该方法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// b.继续判断：需要插入的数据结构是红黑树还是链表</span>
        <span class="token comment" spellcheck="true">// 如果是红黑树，则直接在树中插入 or 更新键值对</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>HashMap<span class="token punctuation">.</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果是链表，则在链表中插入 or 更新键值对</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// i .遍历table[i]，判断key是否已存在：采用equals对比当前遍历结点的key与需要插入数据的key</span>
            <span class="token comment" spellcheck="true">//    如果存在相同的，则直接覆盖</span>
            <span class="token comment" spellcheck="true">// ii.遍历完毕后任务发现上述情况，则直接在链表尾部插入数据</span>
            <span class="token comment" spellcheck="true">//    插入完成后判断链表长度是否 > 8：若是，则把链表转换成红黑树</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 对于i 情况的后续操作：发现key已存在，直接用新value覆盖旧value&amp;返回旧value</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>
            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 插入成功后，判断实际存在的键值对数量size > 最大容量</span>
    <span class="token comment" spellcheck="true">// 如果大于则进行扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 插入成功时会调用的方法（默认实现为空）</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>图片简单总结为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java%E9%9B%86%E5%90%88%E5%BF%85%E4%BC%9A14%E9%97%AE%EF%BC%88%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89/7896890-cf5aa3b08dd9684f.png" alt=""></p>
<hr>
<h2 id="4）HashMap的扩容操作是怎么实现的？"><a href="#4）HashMap的扩容操作是怎么实现的？" class="headerlink" title="4）HashMap的扩容操作是怎么实现的？"></a>4）HashMap的扩容操作是怎么实现的？</h2><p>答：通过分析源码我们知道了HashMap通过<code>resize()</code>方法进行扩容或者初始化的操作，下面是对源码进行的一些简单分析：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 该函数有2中使用情况：1.初始化哈希表；2.当前数组容量过小，需要扩容
 */</span>
<span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 扩容前的数组（当前数组）</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 扩容前的数组容量（数组长度）</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 扩容前数组的阈值</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 针对情况2：若没有超过最大值，就扩容为原来的2倍（左移1位）</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
                oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 针对情况1：初始化哈希表（采用指定或者使用默认值的方式）</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 把每一个bucket都移动到新的bucket中去</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h2 id="5）HashMap是怎么解决哈希冲突的？"><a href="#5）HashMap是怎么解决哈希冲突的？" class="headerlink" title="5）HashMap是怎么解决哈希冲突的？"></a>5）HashMap是怎么解决哈希冲突的？</h2><blockquote>
<p>参考资料：<a href="https://juejin.im/post/5ab99afff265da23a2291dee" target="_blank" rel="noopener">https://juejin.im/post/5ab99afff265da23a2291dee</a></p>
</blockquote>
<p>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p>
<h3 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h3><p><strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；</strong>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</strong></p>
<p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p>
<h3 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h3><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</strong></p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；</strong>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java%E9%9B%86%E5%90%88%E5%BF%85%E4%BC%9A14%E9%97%AE%EF%BC%88%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89/7896890-c66a4bd8907f49f6.png" alt=""></p>
<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，</strong>所以我们还需要对hashCode作一定的优化</p>
<h3 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h3><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 与自己右移16位进行异或运算（高低位异或）</span>
<span class="token punctuation">}</span></code></pre>
<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</strong></p>
<h3 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java%E9%9B%86%E5%90%88%E5%BF%85%E4%BC%9A14%E9%97%AE%EF%BC%88%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89/7896890-798f1387e3f8de9a.png" alt=""></p>
<p>通过上面的<strong>链地址法（使用散列表）</strong>和<strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>
<p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p>
<hr>
<h2 id="6）HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#6）HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="6）HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>6）HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<p><strong>面试官：那怎么解决呢？</strong></p>
<p>答：</p>
<ol>
<li><p>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</p>
</li>
<li><p>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</p>
</li>
</ol>
<p><strong>面试官：为什么数组长度要保证为2的幂次方呢？</strong></p>
<p>答：</p>
<ol>
<li><p>只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；</p>
</li>
<li><p>如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</p>
</li>
</ol>
<p><strong>面试官：那为什么是两次扰动呢？</strong></p>
<p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<hr>
<h2 id="7）HashMap在JDK1-7和JDK1-8中有哪些不同？"><a href="#7）HashMap在JDK1-7和JDK1-8中有哪些不同？" class="headerlink" title="7）HashMap在JDK1.7和JDK1.8中有哪些不同？"></a>7）HashMap在JDK1.7和JDK1.8中有哪些不同？</h2><p>答：</p>
<table>
<thead>
<tr>
<th align="left">不同</th>
<th align="left">JDK 1.7</th>
<th align="left">JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储结构</td>
<td align="left">数组 + 链表</td>
<td align="left">数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td align="left">初始化方式</td>
<td align="left">单独函数：<code>inflateTable()</code></td>
<td align="left">直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td align="left">hash值计算方式</td>
<td align="left">扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td align="left">扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td align="left">存放数据的规则</td>
<td align="left">无冲突时，存放数组；冲突时，存放链表</td>
<td align="left">无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td align="left">插入数据方式</td>
<td align="left">头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td align="left">尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td align="left">扩容后存储位置的计算方式</td>
<td align="left">全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td align="left">按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody></table>
<hr>
<h2 id="8）为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#8）为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="8）为什么HashMap中String、Integer这样的包装类适合作为K？"></a>8）为什么HashMap中String、Integer这样的包装类适合作为K？</h2><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>
</ol>
<p><strong>面试官：如果我想要让自己的Object作为K应该怎么办呢？</strong></p>
<p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p>
<ol>
<li><p><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</p>
</li>
<li><p><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</p>
</li>
</ol>
<hr>
<h2 id="9）ConcurrentHashMap和Hashtable的区别？"><a href="#9）ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="9）ConcurrentHashMap和Hashtable的区别？"></a>9）ConcurrentHashMap和Hashtable的区别？</h2><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 </p>
<p><strong>面试官：ConcurrentHashMap的具体实现知道吗？</strong></p>
<blockquote>
<p>参考资料：<a href="http://www.importnew.com/23610.html" target="_blank" rel="noopener">http://www.importnew.com/23610.html</a></p>
</blockquote>
<p>答：<strong>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现</strong>，结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java%E9%9B%86%E5%90%88%E5%BF%85%E4%BC%9A14%E9%97%AE%EF%BC%88%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89/7896890-645836e722c2a9f9.png" alt=""></p>
<ol>
<li><p>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p>
</li>
<li><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p>
</li>
</ol>
<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Java%E9%9B%86%E5%90%88%E5%BF%85%E4%BC%9A14%E9%97%AE%EF%BC%88%E7%B2%BE%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%89/7896890-ec8560395e25547a.png" alt=""></p>
<p>插入元素过程（建议去看看源码）：</p>
<ol>
<li>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>
<span class="token punctuation">}</span></code></pre>
<ol start="2">
<li>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        K ek<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
             <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ol start="3">
<li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p>
</li>
<li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p>
</li>
</ol>
<hr>
<h2 id="10）Java集合的快速失败机制-“fail-fast”？"><a href="#10）Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="10）Java集合的快速失败机制 “fail-fast”？"></a>10）Java集合的快速失败机制 “fail-fast”？</h2><p>答：</p>
<p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p>
<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1. 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p>
<p><strong>2. 使用CopyOnWriteArrayList来替换ArrayList</strong></p>
<hr>
<h2 id="11）ArrayList-和-Vector-的区别？"><a href="#11）ArrayList-和-Vector-的区别？" class="headerlink" title="11）ArrayList 和 Vector 的区别？"></a>11）ArrayList 和 Vector 的区别？</h2><p>答：</p>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p>
<p>ArrayList 与 Vector 的区别主要包括两个方面：</p>
<ol>
<li><p>同步性：<br>Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
</li>
<li><p>数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 2 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 (0.5 倍 + 1) 个空间。</p>
</li>
</ol>
<hr>
<h2 id="12）ArrayList和LinkedList的区别？"><a href="#12）ArrayList和LinkedList的区别？" class="headerlink" title="12）ArrayList和LinkedList的区别？"></a>12）ArrayList和LinkedList的区别？</h2><p>答：</p>
<ol>
<li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；ArrayList 实现了 List 接口，动态数组；</li>
<li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li>
<li>LinkedList 比 ArrayList 需要更多的内存；</li>
</ol>
<p><strong>面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</strong></p>
<p>答：它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<hr>
<h2 id="13）HashSet是如何保证数据不可重复的？"><a href="#13）HashSet是如何保证数据不可重复的？" class="headerlink" title="13）HashSet是如何保证数据不可重复的？"></a>13）HashSet是如何保证数据不可重复的？</h2><p>答：HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>，我们可以看到源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>
<span class="token punctuation">}</span></code></pre>
<p>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性；</p>
<hr>
<h2 id="14）BlockingQueue是什么？"><a href="#14）BlockingQueue是什么？" class="headerlink" title="14）BlockingQueue是什么？"></a>14）BlockingQueue是什么？</h2><p>答：</p>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<hr>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料<br>想要交流的朋友也可以加qq群：3382693</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2018/07/12/shu-ju-jie-gou-yu-suan-fa-4-you-xian-dui-lie-he-dui/">
      数据结构与算法(4)——优先队列和堆
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>数据结构与算法/面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年7月12日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-bf78bc61f021e9a2.png" alt=""></p>
<blockquote>
<p>前言：题图无关，接下来开始简单学习学习优先队列和堆的相关数据结构的知识；</p>
</blockquote>
<p><strong>前序文章：</strong></p>
<ul>
<li>数据结构与算法(1)——数组与链表（<a href="https://www.jianshu.com/p/7b93b3570875）" target="_blank" rel="noopener">https://www.jianshu.com/p/7b93b3570875）</a></li>
<li>数据结构与算法(2)——栈和队列(<a href="https://www.jianshu.com/p/5087c751cb42" target="_blank" rel="noopener">https://www.jianshu.com/p/5087c751cb42</a>)</li>
<li>数据结构与算法(3)——树（二叉、二叉搜索树）(<a href="https://www.jianshu.com/p/4ef1f50d45b5" target="_blank" rel="noopener">https://www.jianshu.com/p/4ef1f50d45b5</a>)</li>
</ul>
<h1 id="什么是优先队列？"><a href="#什么是优先队列？" class="headerlink" title="什么是优先队列？"></a>什么是优先队列？</h1><p>听这个名字就能知道，优先队列也是一种队列，只不过不同的是，优先队列的出队顺序是按照优先级来的；在有些情况下，可能需要找到元素集合中的最小或者最大元素，可以利用优先队列ADT来完成操作，优先队列ADT是一种数据结构，它支持插入和删除最小值操作（返回并删除最小元素）或删除最大值操作（返回并删除最大元素）；</p>
<p>这些操作等价于队列的<code>enQueue</code>和<code>deQueue</code>操作，区别在于，对于优先队列，元素进入队列的顺序可能与其被操作的顺序不同，作业调度是优先队列的一个应用实例，它根据优先级的高低而不是先到先服务的方式来进行调度；</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-c7a72a722781c0e2.png" alt=""></p>
<p>如果最小键值元素拥有最高的优先级，那么这种优先队列叫作<strong>升序优先队列</strong>（即总是先删除最小的元素），类似的，如果最大键值元素拥有最高的优先级，那么这种优先队列叫作<strong>降序优先队列</strong>（即总是先删除最大的元素）；由于这两种类型时对称的，所以只需要关注其中一种，如升序优先队列；</p>
<h2 id="优先队列ADT"><a href="#优先队列ADT" class="headerlink" title="优先队列ADT"></a>优先队列ADT</h2><p>下面操作组成了优先队列的一个ADT；</p>
<p><strong>1.优先队列的主要操作</strong><br>优先队列是元素的容器，每个元素有一个相关的键值；</p>
<ul>
<li><code>insert(key, data)</code>：插入键值为key的数据到优先队列中，元素以其key进行排序；</li>
<li><code>deleteMin/deleteMax</code>：删除并返回最小/最大键值的元素；</li>
<li><code>getMinimum/getMaximum</code>：返回最小/最大剑指的元素，但不删除它；</li>
</ul>
<p><strong>2.优先队列的辅助操作</strong></p>
<ul>
<li><code>第k最小/第k最大</code>：返回优先队列中键值为第k个最小/最大的元素；</li>
<li><code>大小（size）</code>：返回优先队列中的元素个数；</li>
<li><code>堆排序（Heap Sort）</code>：基于键值的优先级将优先队列中的元素进行排序；</li>
</ul>
<h2 id="优先队列的应用"><a href="#优先队列的应用" class="headerlink" title="优先队列的应用"></a>优先队列的应用</h2><ul>
<li>数据压缩：赫夫曼编码算法；</li>
<li>最短路径算法：Dijkstra算法；</li>
<li>最小生成树算法：Prim算法；</li>
<li>事件驱动仿真：顾客排队算法；</li>
<li>选择问题：查找第k个最小元素；</li>
<li>等等等等….</li>
</ul>
<h2 id="优先队列的实现比较"><a href="#优先队列的实现比较" class="headerlink" title="优先队列的实现比较"></a>优先队列的实现比较</h2><table>
<thead>
<tr>
<th align="left">实现</th>
<th align="left">插入</th>
<th align="left">删除</th>
<th align="left">寻找最小值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无序数组</td>
<td align="left">1</td>
<td align="left">n</td>
<td align="left">n</td>
</tr>
<tr>
<td align="left">无序链表</td>
<td align="left">1</td>
<td align="left">n</td>
<td align="left">n</td>
</tr>
<tr>
<td align="left">有序数组</td>
<td align="left">n</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">有序链表</td>
<td align="left">n</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">二叉搜索树</td>
<td align="left">logn(平均)</td>
<td align="left">logn(平均)</td>
<td align="left">logn(平均)</td>
</tr>
<tr>
<td align="left">平衡二叉搜索树</td>
<td align="left">logn</td>
<td align="left">logn</td>
<td align="left">logn</td>
</tr>
<tr>
<td align="left">二叉堆</td>
<td align="left">logn</td>
<td align="left">logn</td>
<td align="left">1</td>
</tr>
</tbody></table>
<h1 id="堆和二叉堆"><a href="#堆和二叉堆" class="headerlink" title="堆和二叉堆"></a>堆和二叉堆</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><strong>堆是一颗具有特定性质的二叉树</strong>，堆的基本要求就是堆中所有结点的值必须大于或等于（或小于或等于）其孩子结点的值，这也称为堆的性质；堆还有另一个性质，就是当 h &gt; 0 时，所有叶子结点都处于第 h 或 h - 1 层（其中 h 为树的高度，完全二叉树），也就是说，堆应该是一颗完全二叉树；</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-38d8a1a70f849b1f.png" alt=""></p>
<p>在下面的例子中，左边的树为堆（每个元素都大于其孩子结点的值），而右边的树不是堆（因为5大于其孩子结点2）</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-fdb654f7e2cefeb3.png" alt=""></p>
<h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>在二叉堆中，每个结点最多有两个孩子结点，在实际应用中，二叉堆已经足够满足需求，因此接下来主要讨论二叉最小堆和二叉最大堆；</p>
<p><strong>堆的表示：</strong>在描述堆的操作前，首先来看堆是怎样表示的，一种可能的方法就是使用数组，因为堆在形式上是一颗完全二叉树，用数组来存储它不会浪费任何空间，例如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-0bce039cf9634ddf.png" alt=""></p>
<p>用数组来表示堆不仅不会浪费空间还具有一定的优势：</p>
<ul>
<li>每个结点的左孩子为下标i的2倍：<code>left child(i) = i * 2</code>；每个结点的右孩子为下标i的2倍加1：<code>right child(i) = i * 2 + 1</code></li>
<li>每个结点的父亲结点为下标的二分之一：<code>parent(i) = i / 2</code>，注意这里是整数除，2和3除以2都为1，大家可以验证一下；</li>
<li><strong>注意：</strong>这里是把下标为0的地方空出来了的，主要是为了方便理解，如果0不空出来只需要在计算的时候把i值往右偏移一个位置就行了（也就是加1，大家可以试试，下面的演示也采取这样的方式）；</li>
</ul>
<h3 id="二叉堆的相关操作"><a href="#二叉堆的相关操作" class="headerlink" title="二叉堆的相关操作"></a>二叉堆的相关操作</h3><h4 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxHeap</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>E<span class="token operator">>></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Array<span class="token operator">&lt;</span>E<span class="token operator">></span> data<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回堆中的元素个数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回一个布尔值, 表示堆中是否为空</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"index-0 doesn't have parent."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">leftChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">rightChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="向堆中添加元素和Sift-Up"><a href="#向堆中添加元素和Sift-Up" class="headerlink" title="向堆中添加元素和Sift Up"></a>向堆中添加元素和Sift Up</h4><p>当插入一个元素到堆中时，它可能不满足堆的性质，在这种情况下，需要调整堆中元素的位置使之重新变成堆，这个过程称为堆化（heapifying）；在最大堆中，要堆化一个元素，需要找到它的父亲结点，如果不满足堆的基本性质则交换两个元素的位置，重复该过程直到每个结点都满足堆的性质为止，下面我们来模拟一下这个过程：</p>
<p>下面我们在该堆中插入一个新的元素26：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-8b5d6249f0f62e7a.png" alt=""></p>
<p>我们通过索引（上面的公式）可以很容易地找到新插入元素的父亲结点，然后比较它们的大小，如果新元素更大则交换两个元素的位置，这个操作就相当于把该元素上浮了一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-4965871de80dafc7.png" alt=""></p>
<p>重复该操作直到26到了一个满足堆条件的位置，此时就完成了插入的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-16fd4f5a344d152f.png" alt=""></p>
<p>对应的代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 向堆中添加元素</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    data<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">siftUp</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">parent</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        data<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        k <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="取出堆中的最大元素和Sift-Down"><a href="#取出堆中的最大元素和Sift-Down" class="headerlink" title="取出堆中的最大元素和Sift Down"></a>取出堆中的最大元素和Sift Down</h4><p>如果理解了上述的过程，那么取出堆中的最大元素（堆顶元素）将变得容易，不过这里运用到一个小技巧，就是用最后一个元素替换掉栈顶元素，然后把最后一个元素删除掉，这样一来元素的总个数也满足条件，然后只需要把栈顶元素依次往下调整就好了，这个操作就叫做Sift Down（下沉）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-0fa8fb28068d6c91.png" alt=""></p>
<p>用最后元素替换掉栈顶元素，然后删除最后一个元素：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-fda14df231db5714.png" alt=""> </p>
<p>然后比较其孩子结点的大小：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-bf5de8b9e00bbefb.png" alt=""></p>
<p>如果不满足堆的条件，那么就跟孩子结点中较大的一个交换位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-0e9ae028105f1db9.png" alt=""></p>
<p>重复该步骤，直到16到达合适的位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-b01aa0bb1f918d43.png" alt=""></p>
<p>完成取出最大元素的操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-497dfbd2a9ab2628.png" alt=""></p>
<p>对应的代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 看堆中的最大元素</span>
<span class="token keyword">public</span> E <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Can not findMax when heap is empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 取出堆中最大元素</span>
<span class="token keyword">public</span> E <span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    E ret <span class="token operator">=</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    data<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">leftChild</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">leftChild</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在此轮循环中,data[k]和data[j]交换位置</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> data<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>
            j <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// data[j] 是 leftChild 和 rightChild 中的最大值</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

        data<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        k <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="Replace-和-Heapify"><a href="#Replace-和-Heapify" class="headerlink" title="Replace 和 Heapify"></a>Replace 和 Heapify</h4><p><strong>Replace</strong>这个操作其实就是取出堆中最大的元素之后再新插入一个元素，常规的做法是取出最大元素之后，再利用上面的插入新元素的操作对堆进行Sift Up操作，但是这里有一个小技巧就是直接使用新元素替换掉堆顶元素，之后再进行Sift Down操作，这样就把两次O(logn）的操作变成了一次O(logn)：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 取出堆中的最大元素，并且替换成元素e</span>
<span class="token keyword">public</span> E <span class="token function">replace</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">{</span>

    E ret <span class="token operator">=</span> <span class="token function">findMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>Heapify</strong>翻译过来就是堆化的意思，就是将任意数组整理成堆的形状，通常的做法是遍历数组从0开始添加创建一个新的堆，但是这里存在一个小技巧就是把当前数组就看做是一个完全二叉树，然后从最后一个非叶子结点开始进行Sift Down操作就可以了，最后一个非叶子结点也很好找，就是最后一个结点的父亲结点，大家可以验证一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-c1b4a31fa0c2d3d9.png" alt=""></p>
<p>从22这个节点开始，依次开始Sift Down操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-fc8bcfb5d5c3f4c7.png" alt=""></p>
<p>重复该过程直到堆顶元素：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-888351adffccd447.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-5b12380ddeb1ad61.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-1513ebd00b08fdce.png" alt=""></p>
<p>完成堆化操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-7dc7d63d91b1a2e6.png" alt=""></p>
<p>将n个元素逐个插入到一个空堆中，算法复杂度是O(nlogn)，而heapify的过程，算法复杂度为O(n)，这是有一个质的飞跃的，下面是代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token function">siftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="基于堆的优先队列"><a href="#基于堆的优先队列" class="headerlink" title="基于堆的优先队列"></a>基于堆的优先队列</h2><p>首先我们的队列仍然需要继承我们之前将队列时候声明的哪个接口<code>Queue</code>，然后实现这个接口中的方法就可以了，之类简单写一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>E<span class="token operator">>></span> <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> MaxHeap<span class="token operator">&lt;</span>E<span class="token operator">></span> maxHeap<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">PriorityQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> E <span class="token function">getFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">findMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">{</span> maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="Java中的PriorityQueue"><a href="#Java中的PriorityQueue" class="headerlink" title="Java中的PriorityQueue"></a>Java中的PriorityQueue</h2><p>在Java中也实现了自己的优先队列<code>java.util.PriorityQueue</code>，与我们自己写的不同之处在于，Java中内置的为最小堆，然后就是一些函数名不一样，底层还是维护了一个Object类型的数组，大家可以戳戳看有什么不同，另外如果想要把最小堆变成最大堆可以给PriorityQueue传入自己的比较器，例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 默认为最小堆</span>
PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"————————————————————————"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 使用Lambda表达式传入自己的比较器转换成最大堆</span>
PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
pq2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pq2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pq2<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h1 id="LeetCode相关题目整理"><a href="#LeetCode相关题目整理" class="headerlink" title="LeetCode相关题目整理"></a>LeetCode相关题目整理</h1><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-a2fecf661fbbb4da.png" alt=""></p>
<p><strong>参考答案：（85ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">mergeKLists</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">[</span><span class="token punctuation">]</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lists <span class="token operator">==</span> null <span class="token operator">||</span> lists<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>

    PriorityQueue<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>node <span class="token operator">-</span><span class="token operator">></span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lists<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode tail <span class="token operator">=</span> dummy<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-c3bf5d69077f945b.png" alt=""></p>
<p><strong>我的答案：（75ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length <span class="token operator">||</span> null <span class="token operator">==</span> nums <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">></span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 构造优先队列,默认为最小堆,传入自定义的比较器转换成最大堆</span>
    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>参考答案：（5ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        max <span class="token operator">=</span> i <span class="token operator">></span> max <span class="token operator">?</span> i <span class="token operator">:</span> max<span class="token punctuation">;</span>
        min <span class="token operator">=</span> i <span class="token operator">&lt;</span> min <span class="token operator">?</span> i <span class="token operator">:</span> min<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arrs<span class="token punctuation">[</span>max <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pos <span class="token operator">+=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> max <span class="token operator">-</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>还看到一个简单粗暴的，也是服了：（4ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>而且我随机生成了一个100万数据的随机数组，来测试这个简单粗暴的方法的效率，发现当数据量上去之后，排序这个操作变得繁琐，我自己测试的时候，上面三个方法，第三个大概比第一个（我自己写的方法）多花仅4倍的时间；</p>
</blockquote>
<h2 id="239-滑动窗口最大值（类似剑指Offer面试题59）"><a href="#239-滑动窗口最大值（类似剑指Offer面试题59）" class="headerlink" title="239. 滑动窗口最大值（类似剑指Offer面试题59）"></a>239. 滑动窗口最大值（类似剑指Offer面试题59）</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-171dbeff0098e005.png" alt=""></p>
<p><strong>参考答案：（88ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    ArrayDeque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Ensure deque's size doesn't exceed k</span>
            deque<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// Remove numbers smaller than a[i] from right(a[i-1]) to left, to make the first number in the deque the largest one in the window         </span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        deque<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Offer the current index to the deque's tail</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Starts recording when i is big enough to make the window has k elements </span>
            res<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>参考答案2：（9ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">/*
思想：依次遍历数组，有效范围在长度k内寻找当前最大值，在用result数组来依次存储当前长度K内的最大值；
     若在当前轮中出现新增的nums[end]大于curMax,直接替换即可；
     如果当前轮curMax不是新增的nums[end]，在新的范围内重置curMax.
*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> curMax <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> curMax<span class="token punctuation">)</span>
            curMax <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> curMax<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> start <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> start<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">></span> curMax<span class="token punctuation">)</span>
            curMax <span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> curMax<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//新增的不大于curMax，新范围内重置</span>
            curMax <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> curMax<span class="token punctuation">)</span>
                    curMax <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        ans<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> curMax<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="264-丑数-II（剑指Offer面试题49）"><a href="#264-丑数-II（剑指Offer面试题49）" class="headerlink" title="264. 丑数 II（剑指Offer面试题49）"></a>264. 丑数 II（剑指Offer面试题49）</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-6f2e952994489240.png" alt=""></p>
<p><strong>参考答案：（7ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">nthUglyNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 正确性判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">1690</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ugly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    ugly<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> index2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index5 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> factor2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> factor3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> factor5 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>factor2<span class="token punctuation">,</span> factor3<span class="token punctuation">)</span><span class="token punctuation">,</span> factor5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ugly<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>factor2 <span class="token operator">==</span> min<span class="token punctuation">)</span>
            factor2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span><span class="token operator">++</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>factor3 <span class="token operator">==</span> min<span class="token punctuation">)</span>
            factor3 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span><span class="token operator">++</span>index3<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>factor5 <span class="token operator">==</span> min<span class="token punctuation">)</span>
            factor5 <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> ugly<span class="token punctuation">[</span><span class="token operator">++</span>index5<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ugly<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>如果采用逐个判断每个整数是不是丑数的解法，直观但不够高效，所以我们就需要换一种思路，我的第一反应就是这其中一定有什么规律，但是尝试着找了一下，没找到…看了看答案才幡然醒悟，前面提到的算法之所以效率低，很大程度上是因为不管一个数是不是丑数，我们都要对它进行计算，接下来我们试着找到一种只计算丑数的方法，而不在非丑数的整数上花费时间，根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此，我们可以创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的，也就是上面的算法了..</p>
</blockquote>
<h2 id="295-数据流的中位数（剑指Offer面试题41）"><a href="#295-数据流的中位数（剑指Offer面试题41）" class="headerlink" title="295.数据流的中位数（剑指Offer面试题41）"></a>295.数据流的中位数（剑指Offer面试题41）</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-fa507452d5527f0d.png" alt=""></p>
<p><strong>参考答案：（219ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MedianFinder</span> <span class="token punctuation">{</span>

    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxHeap<span class="token punctuation">;</span>
    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minHeap<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * initialize your data structure here.
     */</span>
    <span class="token keyword">public</span> <span class="token function">MedianFinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p><strong>思路：</strong>这道题的实现思路有很多，比如我们可以在插入的时候就将每个元素插入到正确的位置上，这样返回中位数的时候就会是一个O(1)的操作，下面列举一张表来说明不同实现的复杂度具体是多少：<br>数据结构 | 插入的时间复杂度 | 得到中位数的时间复杂度<br>:– | :– | :–<br>没有排序的数组 | O(1) | O(n)<br>排序的数组 | O(n) | O(1)<br>排序的链表 | O(n) | O(1)<br>二叉搜索树 | 平均O(logn)，最差O(n) | 平均O(logn)，最差O(n)<br>AVL树 | O(logn) | O(logn)<br>最大堆和最小堆 | O(logn) | O(logn)</p>
<p>AVL树是一种很高效的数据结构，但是在大多数的语言中都没有现成的实现，所以考虑用最大堆和最小堆，对于一个已经排好序的数据容器，我们可以从中间分开分成两个部分，其中拿P1指向左半部分最大的元素，拿P2指向有半部分最小的元素，如果能够保证数据容器左边的数据都小于右边的数据，那么即使左、右两边内部的数据没有排序，我们仍然可以根据左边最大的数和右边最大的数得到中位数：<br><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-58cbfc45655c8a5c.png" alt=""><br>如何快速从一个数据容器中找出最大数呢？我们可以使用最大堆来实现这个数据容器，因为堆顶的元素就是最大的元素；同样我们可以使用最小堆来快速找出一个数据容器中最小数。因此按照这个思路我们就可以使用一个最大堆实现左边的数据容器，使用一个最小堆实现右边的数据容器，但是需要注意的是这两个容器的大小差值不能超过1；</p>
</blockquote>
<h2 id="347-前K个高频元素（类似剑指Offer面试题40）"><a href="#347-前K个高频元素（类似剑指Offer面试题40）" class="headerlink" title="347. 前K个高频元素（类似剑指Offer面试题40）"></a>347. 前K个高频元素（类似剑指Offer面试题40）</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-c8b5b908847cbf75.png" alt=""></p>
<p><strong>参考答案：（131ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 保存频率</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>map<span class="token operator">:</span><span class="token operator">:</span>get<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">></span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a>692. 前K个高频单词</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/7896890-ab7352ea3090669b.png" alt=""></p>
<p><strong>参考答案：（72ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String word<span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> candidates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> <span class="token punctuation">(</span>w1<span class="token punctuation">,</span> w2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>
            w1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w2<span class="token punctuation">)</span> <span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w2<span class="token punctuation">)</span> <span class="token operator">-</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> candidates<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>这道题类似于上面的第347题，但是问题出在返回的顺序上，需要自己来定义一个比较器来排序..然后也学到一个写法，就是上面的第一个for循环里，<code>getOrDefault()</code>方法，get√..</p>
</blockquote>
<p><strong>参考答案2：（91ms）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String word<span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    PriorityQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span>w1<span class="token punctuation">,</span> w2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                    w2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w1<span class="token punctuation">)</span> <span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w1<span class="token punctuation">)</span> <span class="token operator">-</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w2<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>String word<span class="token operator">:</span> count<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        heap<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    List<span class="token operator">&lt;</span>String<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>heap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>这个解法就有点儿类似于上面的347题，其实是大同小异，就是自己不会灵活使用比较器而已，学习到了学习到了√…</p>
</blockquote>
<hr>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>今天算是很有收获的一天，因为这两种数据结构都是自己特别不熟悉的，特别是在刷了一些LeetCode相关题目之后，对这两种数据有了很不一样的认识，特别是堆的应用，这是一种特别适合用来找第k小/大的特殊的数据结构，并且在Java中居然有直接的实现，这可太棒了，而且今天的效率还算挺高的，满足；</p>
<blockquote>
<p>欢迎转载，转载请注明出处！<br>简书ID：<a href="https://www.jianshu.com/u/a40d61a49221" target="_blank" rel="noopener">@我没有三颗心脏</a><br>github：<a href="https://github.com/wmyskxz/" target="_blank" rel="noopener">wmyskxz</a><br>欢迎关注公众微信号：wmyskxz_javaweb<br>分享自己的Java Web学习之路以及各种Java学习资料</p>
</blockquote>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
        <p class="current">
          1 / 3
        </p>
        
          <a class="next" rel="next" href="/tags/%E9%9D%A2%E8%AF%95/page/2/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(12)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 17.08px; color: #848484">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.23px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.46px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.69px; color: #656565">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.92px; color: #6a6a6a">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.54px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 20.15px; color: #6f6f6f">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.77px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 17.08px; color: #848484">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.85px; color: #7f7f7f">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.85px; color: #7f7f7f">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.69px; color: #656565">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.77px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.54px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.31px; color: #898989">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.77px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.54px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.85px; color: #7f7f7f">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.77px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.62px; color: #7a7a7a">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.77px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.31px; color: #898989">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 17.08px; color: #848484">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.69px; color: #656565">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19.38px; color: #747474">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
