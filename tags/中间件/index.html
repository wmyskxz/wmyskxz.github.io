<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>标签：中间件 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("none" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("none" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("none" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      


<div class='l_main'>
  
    
      
  <section class="post-list ">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/25/dong-yi-dian-python-xi-lie-kuai-su-ru-men-1/">
      妈妈再也不担心我面试被Redis问得脸都绿了
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月25日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-36f1278b896ced09.png" alt=""></p>
<blockquote>
<p>长文前排提醒，收藏向前排提醒，素质三连 <strong>(转发 + 在看 + 留言)</strong> 前排提醒！</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fbe27d1657e593c3.png" alt=""></p>
<p><strong>Redis</strong> 作为一个开源的，高级的键值存储和一个适用的解决方案，已经越来越在构建 <strong>「高性能」</strong>、<strong>「可扩展」</strong> 的 Web 应用上发挥着举足轻重的作用。</p>
<p>当今互联网技术架构中 <strong>Redis</strong> 已然成为了应用得最广泛的中间件之一，它也是中高级后端工程 <strong>技术面试</strong> 中面试官最喜欢问的工程技能之一，不仅仅要求着我们对 <strong>基本的使用</strong> 进行掌握，更要深层次地理解 Redis <strong>内部实现</strong> 的细节原理。</p>
<p>熟练掌握 Redis，甚至可以毫不夸张地说已经半只脚踏入心仪的公司了。下面我们一起来盘点回顾一下 Redis 的面试经典问题，就不要再被面试官问得 <strong>脸都绿了</strong> 呀！</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-62a9826a061d71dc.png" alt=""></p>
<ul>
<li><strong>Ps</strong>： 我把 <strong>重要的知识点</strong> 都做成了 <strong>图片</strong>，希望各位 <strong>“用餐愉快”</strong>。<em>(不错记得付餐费.. 点个赞留个言..)</em></li>
</ul>
<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4e434da31115b92d.png" alt=""></p>
<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><h4 id="先解释-Redis-基本概念"><a href="#先解释-Redis-基本概念" class="headerlink" title="先解释 Redis 基本概念"></a>先解释 Redis 基本概念</h4><p><strong>Redis</strong> (<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver) 是一个使用 <strong>C 语言</strong> 编写的，开源的 <em>(BSD许可)</em> 高性能 <strong>非关系型</strong> <em>(NoSQL)</em> 的 <strong>键值对数据库</strong>。</p>
<h4 id="简单提一下-Redis-数据结构"><a href="#简单提一下-Redis-数据结构" class="headerlink" title="简单提一下 Redis 数据结构"></a>简单提一下 Redis 数据结构</h4><p><strong>Redis</strong> 可以存储 <strong>键</strong> 和 <strong>不同类型数据结构值</strong> 之间的映射关系。键的类型只能是字符串，而值除了支持最 <strong>基础的五种数据类型</strong> 外，还支持一些 <strong>高级数据类型</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-ea1e1248cb5d8f88.png" alt=""></p>
<blockquote>
<p>一定要说出一些高级数据结构 <em>(当然你自己也要了解.. 下面会说到的别担心)</em>，这样面试官的眼睛才会亮。</p>
</blockquote>
<h4 id="Redis-小总结"><a href="#Redis-小总结" class="headerlink" title="Redis 小总结"></a>Redis 小总结</h4><p>与传统数据库不同的是 <strong>Redis</strong> 的数据是 <strong>存在内存</strong> 中的，所以 <strong>读写速度</strong> 非常 <strong>快</strong>，因此 Redis 被广泛应用于 <strong>缓存</strong> 方向，每秒可以处理超过 <code>10</code> 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做 <strong>分布式锁</strong>。</p>
<p>除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h2 id="Redis-优缺点"><a href="#Redis-优缺点" class="headerlink" title="Redis 优缺点"></a>Redis 优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>读写性能优异</strong>， Redis能读的速度是 <code>110000</code> 次/s，写的速度是 <code>81000</code> 次/s。</li>
<li><strong>支持数据持久化</strong>，支持 AOF 和 RDB 两种持久化方式。</li>
<li><strong>支持事务</strong>，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li><strong>数据结构丰富</strong>，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li><strong>支持主从复制</strong>，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>数据库 <strong>容量受到物理内存的限制</strong>，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis <strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 <strong>系统的可用性</strong>。</li>
<li><strong>Redis 较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="为什么要用缓存？为什么使用-Redis？"><a href="#为什么要用缓存？为什么使用-Redis？" class="headerlink" title="为什么要用缓存？为什么使用 Redis？"></a>为什么要用缓存？为什么使用 Redis？</h2><h4 id="提一下现在-Web-应用的现状"><a href="#提一下现在-Web-应用的现状" class="headerlink" title="提一下现在 Web 应用的现状"></a>提一下现在 Web 应用的现状</h4><p>在日常的 Web 应用对数据库的访问中，<strong>读操作的次数远超写操作</strong>，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用 SQL 语句去数据库进行读写操作时，数据库就会 <strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p>
<h4 id="使用-Redis-or-使用缓存带来的优势"><a href="#使用-Redis-or-使用缓存带来的优势" class="headerlink" title="使用 Redis or 使用缓存带来的优势"></a>使用 Redis or 使用缓存带来的优势</h4><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样 <strong>速度</strong> 明显就会快上不少 <em>(高性能)</em>，并且会 <strong>极大减小数据库的压力</strong> <em>(特别是在高并发情况下)</em>。</p>
<blockquote>
<p>记得是 <strong>两个角度</strong> 啊.. <strong>高性能</strong> 和 <strong>高并发</strong>..</p>
</blockquote>
<h4 id="也要提一下使用缓存的考虑"><a href="#也要提一下使用缓存的考虑" class="headerlink" title="也要提一下使用缓存的考虑"></a>也要提一下使用缓存的考虑</h4><p>但是使用内存进行数据存储开销也是比较大的，<strong>限于成本</strong> 的原因，一般我们只是使用 Redis 存储一些 <strong>常用和主要的数据</strong>，比如用户登录的信息等。</p>
<p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p>
<ul>
<li><strong>业务数据常用吗？命中率如何？</strong> 如果命中率很低，就没有必要写入缓存；</li>
<li><strong>该业务数据是读操作多，还是写操作多？</strong> 如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li>
<li><strong>业务数据大小如何？</strong> 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li>
</ul>
<p>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！</p>
<h2 id="使用缓存会出现什么问题？"><a href="#使用缓存会出现什么问题？" class="headerlink" title="使用缓存会出现什么问题？"></a>使用缓存会出现什么问题？</h2><p>一般来说有如下几个问题，回答思路遵照 <strong>是什么</strong> → <strong>为什么</strong> → <strong>怎么解决</strong>：</p>
<ol>
<li>缓存雪崩问题；</li>
<li>缓存穿透问题；</li>
<li>缓存和数据库双写一致性问题；</li>
</ol>
<h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-891c01ada1be7099.png" alt=""></p>
<p>另外对于 <strong>“Redis 挂掉了，请求全部走数据库”</strong> 这样的情况，我们还可以有如下的思路：</p>
<ul>
<li><strong>事发前</strong>：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。</li>
<li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li>
<li><strong>事发后</strong>：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-aa9398e52cf83891.png" alt=""></p>
<h4 id="缓存与数据库双写一致问题"><a href="#缓存与数据库双写一致问题" class="headerlink" title="缓存与数据库双写一致问题"></a>缓存与数据库双写一致问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-1c3e67935d7763d4.png" alt=""></p>
<p>双写一致性上图还是稍微粗糙了些，你还需要知道两种方案 <em>(先操作数据库和先操作缓存)</em> 分别都有什么优势和对应的问题，这里不作赘述，可以参考一下下方的文章，写得非常详细。</p>
<blockquote>
<ul>
<li>面试前必须要知道的Redis面试题 | Java3y - <a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么早期版本选择单线程？"><a href="#Redis-为什么早期版本选择单线程？" class="headerlink" title="Redis 为什么早期版本选择单线程？"></a>Redis 为什么早期版本选择单线程？</h2><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p>因为 Redis 是基于内存的操作，<strong>CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是 <strong>机器内存的大小</strong> 或者 <strong>网络带宽</strong>。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h4 id="简单总结一下"><a href="#简单总结一下" class="headerlink" title="简单总结一下"></a>简单总结一下</h4><ol>
<li>使用单线程模型能带来更好的 <strong>可维护性</strong>，方便开发和调试；</li>
<li>使用单线程模型也能 <strong>并发</strong> 的处理客户端的请求；<em>(I/O 多路复用机制)</em></li>
<li>Redis 服务中运行的绝大多数操作的 <strong>性能瓶颈都不是 CPU</strong>；</li>
</ol>
<blockquote>
<p><strong>强烈推荐</strong> 各位亲看一下这篇文章：</p>
<ul>
<li>为什么 Redis 选择单线程模型 · Why’s THE Design? - <a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">https://draveness.me/whys-the-design-redis-single-thread</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><p>简单总结：</p>
<ol>
<li><strong>纯内存操作</strong>：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；<em>(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)</em></li>
<li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li>
<li><strong>多路 I/O 复用模型，非阻塞 I/O</strong>：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li>
<li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li>
</ol>
<h1 id="二、数据结构篇"><a href="#二、数据结构篇" class="headerlink" title="二、数据结构篇"></a>二、数据结构篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-68ecbdc6cf4c5588.png" alt=""></p>
<h2 id="简述一下-Redis-常用数据结构及实现？"><a href="#简述一下-Redis-常用数据结构及实现？" class="headerlink" title="简述一下 Redis 常用数据结构及实现？"></a>简述一下 Redis 常用数据结构及实现？</h2><p>首先在 Redis 内部会使用一个 <strong>RedisObject</strong> 对象来表示所有的 <code>key</code> 和 <code>value</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-16511ec4f7f30569.png" alt=""></p>
<p>其次 Redis 为了 <strong>平衡空间和时间效率</strong>，针对 <code>value</code> 的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系：<em>(好像乱糟糟的，但至少能看清楚..)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-0801fee369ecca97.png" alt=""></p>
<h2 id="Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>Redis 的 SDS 和 C 中字符串相比有什么优势？</h2><h4 id="先简单总结一下"><a href="#先简单总结一下" class="headerlink" title="先简单总结一下"></a>先简单总结一下</h4><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 <strong>不符合 Redis 对字符串在安全性、效率以及功能方面的要求</strong>。</p>
<h4 id="再来说-C-语言字符串的问题"><a href="#再来说-C-语言字符串的问题" class="headerlink" title="再来说 C 语言字符串的问题"></a>再来说 C 语言字符串的问题</h4><p>这样简单的数据结构可能会造成以下一些问题：</p>
<ul>
<li><strong>获取字符串长度为 O(N) 级别的操作</strong> → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</li>
<li>不能很好的杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；</li>
<li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li>
</ul>
<h4 id="Redis-如何解决的-SDS-的优势"><a href="#Redis-如何解决的-SDS-的优势" class="headerlink" title="Redis 如何解决的 | SDS 的优势"></a>Redis 如何解决的 | SDS 的优势</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9570ea52d515e1cb.png" alt=""></p>
<p>如果去看 Redis 的源码 <code>sds.h/sdshdr</code> 文件，你会看到 SDS 完整的实现细节，这里简单来说一下 Redis 如何解决的：</p>
<ol>
<li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li>
<li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</li>
<li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li>
<li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li>
</ol>
<h2 id="字典是如何实现的？Rehash-了解吗？"><a href="#字典是如何实现的？Rehash-了解吗？" class="headerlink" title="字典是如何实现的？Rehash 了解吗？"></a>字典是如何实现的？Rehash 了解吗？</h2><h4 id="先总体聊一下-Redis-中的字典"><a href="#先总体聊一下-Redis-中的字典" class="headerlink" title="先总体聊一下 Redis 中的字典"></a>先总体聊一下 Redis 中的字典</h4><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p>
<h4 id="说明字典内部结构和-rehash"><a href="#说明字典内部结构和-rehash" class="headerlink" title="说明字典内部结构和 rehash"></a>说明字典内部结构和 rehash</h4><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的 <strong>链地址法</strong> 来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p>
<p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个 <code>hashtable</code> 有值，但是在字典扩容缩容时，需要分配新的 <code>hashtable</code>，然后进行 <strong>渐进式搬迁</strong> <em>(rehash)</em>，这时候两个 <code>hashtable</code> 分别存储旧的和新的 <code>hashtable</code>，待搬迁结束后，旧的将被删除，新的 <code>hashtable</code> 取而代之。</p>
<h4 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h4><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p>
<h2 id="跳跃表是如何实现的？原理？"><a href="#跳跃表是如何实现的？原理？" class="headerlink" title="跳跃表是如何实现的？原理？"></a>跳跃表是如何实现的？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9e9cbfe4fc061f3.png" alt=""></p>
<blockquote>
<p>这是 Redis 中比较重要的一个数据结构，<strong>建议阅读</strong> 之前写过的文章，里面详细介绍了原理和一些细节：</p>
<ul>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
</ul>
</blockquote>
<h2 id="HyperLogLog-有了解吗？"><a href="#HyperLogLog-有了解吗？" class="headerlink" title="HyperLogLog 有了解吗？"></a>HyperLogLog 有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
</ul>
</blockquote>
<h2 id="布隆过滤器有了解吗？"><a href="#布隆过滤器有了解吗？" class="headerlink" title="布隆过滤器有了解吗？"></a>布隆过滤器有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
</ul>
</blockquote>
<h2 id="GeoHash-了解吗？"><a href="#GeoHash-了解吗？" class="headerlink" title="GeoHash 了解吗？"></a>GeoHash 了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(6)——GeoHash查找附近的人 - <a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
</ul>
</blockquote>
<h2 id="压缩列表了解吗？"><a href="#压缩列表了解吗？" class="headerlink" title="压缩列表了解吗？"></a>压缩列表了解吗？</h2><p>这是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，<strong>zset</strong> 和 <strong>hash</strong> 容器对象会在元素个数较少的时候，采用压缩列表（ziplist）进行存储。压缩列表是 <strong>一块连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。</p>
<blockquote>
<p>因为之前自己也没有学习过，所以找了一篇比较好比较容易理解的文章：</p>
<ul>
<li>图解Redis之数据结构篇——压缩列表 - <a href="https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg</a></li>
<li>这一篇稍微底层稍微硬核一点：<a href="http://www.web-lovers.com/redis-source-ziplist.html" target="_blank" rel="noopener">http://www.web-lovers.com/redis-source-ziplist.html</a></li>
</ul>
</blockquote>
<h2 id="快速列表-quicklist-了解吗？"><a href="#快速列表-quicklist-了解吗？" class="headerlink" title="快速列表 quicklist 了解吗？"></a>快速列表 quicklist 了解吗？</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p>
<p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>。</p>
<blockquote>
<p>同上..建议阅读一下以下的文章：</p>
<ul>
<li>Redis列表list 底层原理 - <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li>
</ul>
</blockquote>
<h2 id="Stream-结构有了解吗？"><a href="#Stream-结构有了解吗？" class="headerlink" title="Stream 结构有了解吗？"></a>Stream 结构有了解吗？</h2><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9d8afde068a165f.png" alt=""></p>
<p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p>
<ul>
<li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li>
<li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li>
<li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li>
</ul>
<h4 id="Stream-消息太多怎么办？"><a href="#Stream-消息太多怎么办？" class="headerlink" title="Stream 消息太多怎么办？"></a>Stream 消息太多怎么办？</h4><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p>
<p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> XADD mystream MAXLEN 2 * value 1
1526654998691-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 2
1526654999635-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 3
1526655000369-0
<span class="token operator">></span> XLEN mystream
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token operator">></span> XRANGE mystream - +
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526654999635-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526655000369-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p>
<p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p>
<pre class=" language-bash"><code class="language-bash">XADD mystream MAXLEN ~ 1000 * <span class="token punctuation">..</span>. entry fields here <span class="token punctuation">..</span>.</code></pre>
<p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p>
<h4 id="PEL-是如何避免消息丢失的？"><a href="#PEL-是如何避免消息丢失的？" class="headerlink" title="PEL 是如何避免消息丢失的？"></a>PEL 是如何避免消息丢失的？</h4><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p>
<h4 id="和-Kafka-对比起来呢？"><a href="#和-Kafka-对比起来呢？" class="headerlink" title="和 Kafka 对比起来呢？"></a>和 Kafka 对比起来呢？</h4><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p>
<p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p>
<blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章，里面 <strong>也对 Pub/ Sub 做了详细的描述</strong>：</p>
<ul>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ul>
</blockquote>
<h1 id="三、持久化篇"><a href="#三、持久化篇" class="headerlink" title="三、持久化篇"></a>三、持久化篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-54bd130bf8e635e0.png" alt=""></p>
<h2 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h2><h4 id="先简单谈一谈是什么"><a href="#先简单谈一谈是什么" class="headerlink" title="先简单谈一谈是什么"></a>先简单谈一谈是什么</h4><p><strong>Redis</strong> 的数据 <strong>全部存储</strong> 在 <strong>内存</strong> 中，如果 <strong>突然宕机</strong>，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 <strong>持久化机制</strong>，它会将内存中的数据库状态 <strong>保存到磁盘</strong> 中。</p>
<h4 id="解释一下持久化发生了什么"><a href="#解释一下持久化发生了什么" class="headerlink" title="解释一下持久化发生了什么"></a>解释一下持久化发生了什么</h4><p>我们来稍微考虑一下 <strong>Redis</strong> 作为一个 <strong>“内存数据库”</strong> 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-5c209bc08da11abb.png" alt=""></p>
<p><strong>详细版</strong> 的文字描述大概就是下面这样：</p>
<ol>
<li>客户端向数据库 <strong>发送写命令</strong> <em>(数据在客户端的内存中)</em></li>
<li>数据库 <strong>接收</strong> 到客户端的 <strong>写请求</strong> <em>(数据在服务器的内存中)</em></li>
<li>数据库 <strong>调用系统 API</strong> 将数据写入磁盘 <em>(数据在内核缓冲区中)</em></li>
<li>操作系统将 <strong>写缓冲区</strong> 传输到 <strong>磁盘控控制器</strong> <em>(数据在磁盘缓存中)</em></li>
<li>操作系统的磁盘控制器将数据 <strong>写入实际的物理媒介</strong> 中 <em>(数据在磁盘中)</em></li>
</ol>
<h4 id="分析如何保证持久化安全"><a href="#分析如何保证持久化安全" class="headerlink" title="分析如何保证持久化安全"></a>分析如何保证持久化安全</h4><p>如果我们故障仅仅涉及到 <strong>软件层面</strong> <em>(该进程被管理员终止或程序崩溃)</em> 并且没有接触到内核，那么在 <em>上述步骤 3</em> 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。</p>
<p>如果我们考虑 <strong>停电/ 火灾</strong> 等 <strong>更具灾难性</strong> 的事情，那么只有在完成了第 <strong>5</strong> 步之后，才是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-de083f477fe1bce4.png" alt="机房”火了“"></p>
<p>所以我们可以总结得出数据安全最重要的阶段是：<strong>步骤三、四、五</strong>，即：</p>
<ul>
<li>数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？</li>
<li>内核多久从缓冲区取数据刷新到磁盘控制器？</li>
<li>磁盘控制器多久把数据写入物理媒介一次？</li>
<li><strong>注意：</strong> 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 <strong>尽可能地保证</strong> 数据的安全，这对于所有数据库来说都是一样的。</li>
</ul>
<p>我们从 <strong>第三步</strong> 开始。Linux 系统提供了清晰、易用的用于操作文件的 <code>POSIX file API</code>，<code>20</code> 多年过去，仍然还有很多人对于这一套 <code>API</code> 的设计津津乐道，我想其中一个原因就是因为你光从 <code>API</code> 的命名就能够很清晰地知道这一套 API 的用途：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">/*,mode_t mode */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">close</span> <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fname <span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>参考自：API 设计最佳实践的思考 - <a href="https://www.cnblogs.com/yuanjiangw/p/10846560.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanjiangw/p/10846560.html</a></li>
</ul>
<p>所以，我们有很好的可用的 <code>API</code> 来完成 <strong>第三步</strong>，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。</p>
<p>然后我们来说说 <strong>第四步</strong>。我们知道，除了早期对电脑特别了解那帮人 <em>(操作系统就这帮人搞的)</em>，实际的物理硬件都不是我们能够 <strong>直接操作</strong> 的，都是通过 <strong>操作系统调用</strong> 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 <strong>上述第四步</strong> 提到的 <strong>写缓冲区</strong>，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 <strong>30 秒</strong> 后实际提交写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c08b7572ef02d67b.jpg" alt=""></p>
<p>但是很明显，<strong>30 秒</strong> 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 <code>PROSIX API</code> 提供了另一个解决方案：<code>fsync</code>，该命令会 <strong>强制</strong> 内核将 <strong>缓冲区</strong> 写入 <strong>磁盘</strong>，但这是一个非常消耗性能的操作，每次调用都会 <strong>阻塞等待</strong> 直到设备报告 IO 完成，所以一般在生产环境的服务器中，<strong>Redis</strong> 通常是每隔 1s 左右执行一次 <code>fsync</code> 操作。</p>
<p>到目前为止，我们了解到了如何控制 <code>第三步</code> 和 <code>第四步</code>，但是对于 <strong>第五步</strong>，我们 <strong>完全无法控制</strong>。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。</p>
<blockquote>
<p>普通人简单说一下第一条就过了，如果你详细地对后面两方面 <strong>侃侃而谈</strong>，那面试官就会对你另眼相看了。</p>
</blockquote>
<h2 id="Redis-中的两种持久化方式？"><a href="#Redis-中的两种持久化方式？" class="headerlink" title="Redis 中的两种持久化方式？"></a>Redis 中的两种持久化方式？</h2><h4 id="方式一：快照"><a href="#方式一：快照" class="headerlink" title="方式一：快照"></a>方式一：快照</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9a4d234c53120b33.gif" alt=""></p>
<p><strong>Redis 快照</strong> 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 <code>100</code> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>
<h4 id="方式二：AOF"><a href="#方式二：AOF" class="headerlink" title="方式二：AOF"></a>方式二：AOF</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-e4e08ebef2cf0144.gif" alt=""></p>
<p><strong>快照不是很持久</strong>。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 <code>kill -9</code> 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。</p>
<p><strong>AOF(Append Only File - 仅追加文件)</strong> 它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>
<h4 id="Redis-4-0-的混合持久化"><a href="#Redis-4-0-的混合持久化" class="headerlink" title="Redis 4.0 的混合持久化"></a>Redis 4.0 的混合持久化</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-7de9f7706be6216c.gif" alt=""></p>
<p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-2f7887f84eaa34d9.png" alt=""></p>
<p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<blockquote>
<p>关于两种持久化方式的更多细节 <em>(原理)</em> 可以参考：</p>
<ul>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
</ul>
</blockquote>
<h2 id="RDB-和-AOF-各自有什么优缺点？"><a href="#RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="RDB 和 AOF 各自有什么优缺点？"></a>RDB 和 AOF 各自有什么优缺点？</h2><h4 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB | 优点"></a>RDB | 优点</h4><ol>
<li>只有一个文件 <code>dump.rdb</code>，<strong>方便持久化</strong>。</li>
<li><strong>容灾性好</strong>，一个文件可以保存到安全的磁盘。</li>
<li><strong>性能最大化</strong>，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能</li>
<li>相对于数据集大时，比 AOF 的 <strong>启动效率</strong> 更高。</li>
</ol>
<h4 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB | 缺点"></a>RDB | 缺点</h4><ol>
<li><strong>数据安全性低</strong>。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</li>
</ol>
<h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF | 优点"></a>AOF | 优点</h4><ol>
<li><strong>数据安全</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li>
</ol>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF | 缺点"></a>AOF | 缺点</h4><ol>
<li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li>
<li><strong>数据集大</strong> 的时候，比 rdb <strong>启动效率低</strong>。</li>
</ol>
<h2 id="两种方式如何选择？"><a href="#两种方式如何选择？" class="headerlink" title="两种方式如何选择？"></a>两种方式如何选择？</h2><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的 <strong>数据安全性</strong>，你应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然 <strong>可以承受数分钟以内的数据丢失</strong>，那么你可以 <strong>只使用 RDB 持久化</strong>。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h2 id="Redis-的数据恢复"><a href="#Redis-的数据恢复" class="headerlink" title="Redis 的数据恢复"></a>Redis 的数据恢复</h2><p><strong>Redis</strong> 的数据恢复有着如下的优先级：</p>
<ol>
<li>如果只配置 AOF ，重启时加载 AOF 文件恢复数据；</li>
<li>如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；</li>
<li>如果只配置 RDB，启动将加载 dump 文件恢复数据。</li>
</ol>
<p>拷贝 <strong>AOF</strong> 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程：Redis 虚拟一个客户端，读取 AOF 文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在 <code>loadAppendOnlyFile()</code> 中实现。</p>
<p>拷贝 <strong>RDB</strong> 文件到 Redis 的数据目录，启动 redis-server 即可，因为 RDB 文件和重启前保存的是真实数据而不是命令状态和参数。</p>
<h1 id="四、集群篇"><a href="#四、集群篇" class="headerlink" title="四、集群篇"></a>四、集群篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-83a0181f29cccb73.png" alt=""></p>
<h2 id="主从同步了解吗？"><a href="#主从同步了解吗？" class="headerlink" title="主从同步了解吗？"></a>主从同步了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。</p>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="哨兵模式了解吗？"><a href="#哨兵模式了解吗？" class="headerlink" title="哨兵模式了解吗？"></a>哨兵模式了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h4><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="Redis-集群使用过吗？原理？"><a href="#Redis-集群使用过吗？原理？" class="headerlink" title="Redis 集群使用过吗？原理？"></a>Redis 集群使用过吗？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="集群中数据如何分区？"><a href="#集群中数据如何分区？" class="headerlink" title="集群中数据如何分区？"></a>集群中数据如何分区？</h2><p>Redis 采用方案三。</p>
<h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点之间的通信机制了解吗？"><a href="#节点之间的通信机制了解吗？" class="headerlink" title="节点之间的通信机制了解吗？"></a>节点之间的通信机制了解吗？</h2><p>集群的建立离不开节点之间的通信，例如我们在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="集群数据如何存储的有了解吗？"><a href="#集群数据如何存储的有了解吗？" class="headerlink" title="集群数据如何存储的有了解吗？"></a>集群数据如何存储的有了解吗？</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<h1 id="五、其他问题"><a href="#五、其他问题" class="headerlink" title="五、其他问题"></a>五、其他问题</h1><h2 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h2><blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章：<br>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></p>
</blockquote>
<h2 id="Redis-过期键的删除策略？"><a href="#Redis-过期键的删除策略？" class="headerlink" title="Redis 过期键的删除策略？"></a>Redis 过期键的删除策略？</h2><h4 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h4><p>先抛开 Redis 想一下几种可能的删除策略：</p>
<ol>
<li><strong>定时删除</strong>:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</li>
<li><strong>定期删除</strong>:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ol>
<p>在上述的三种策略中定时删除和定期删除属于不同时间粒度的 <strong>主动删除</strong>，惰性删除属于 <strong>被动删除</strong>。</p>
<h4 id="三种策略都有各自的优缺点"><a href="#三种策略都有各自的优缺点" class="headerlink" title="三种策略都有各自的优缺点"></a>三种策略都有各自的优缺点</h4><ol>
<li>定时删除对内存使用率有优势，但是对 CPU 不友好；</li>
<li>惰性删除对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费；</li>
<li>定期删除是定时删除和惰性删除的折中。</li>
</ol>
<h4 id="Redis-中的实现"><a href="#Redis-中的实现" class="headerlink" title="Redis 中的实现"></a>Redis 中的实现</h4><p>Reids 采用的是 <strong>惰性删除和定时删除</strong> 的结合，一般来说可以借助最小堆来实现定时器，不过 Redis 的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，这样如果在此基础上实现定时删除，就意味着 <code>O(N)</code> 遍历获取最近需要删除的数据。</p>
<h2 id="Redis-的淘汰策略有哪些？"><a href="#Redis-的淘汰策略有哪些？" class="headerlink" title="Redis 的淘汰策略有哪些？"></a>Redis 的淘汰策略有哪些？</h2><h4 id="Redis-有六种淘汰策略"><a href="#Redis-有六种淘汰策略" class="headerlink" title="Redis 有六种淘汰策略"></a>Redis 有六种淘汰策略</h4><table>
<thead>
<tr>
<th align="left">策略</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">volatile-lru</td>
<td align="left">从已设置过期时间的 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-ttl</td>
<td align="left">从已设置过期时间的 KV 集中优先对剩余时间短(time to live)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-random</td>
<td align="left">从已设置过期时间的 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">allkeys-lru</td>
<td align="left">从所有 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">allKeys-random</td>
<td align="left">从所有 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">noeviction</td>
<td align="left">不淘汰策略，若超过最大内存，返回错误信息</td>
</tr>
</tbody></table>
<h4 id="4-0-版本后增加以下两种"><a href="#4-0-版本后增加以下两种" class="headerlink" title="4.0 版本后增加以下两种"></a>4.0 版本后增加以下两种</h4><ul>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<h2 id="More"><a href="#More" class="headerlink" title="More.."></a>More..</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了 - <a href="https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w</a></li>
<li>大厂面试！我和面试官之间关于Redis的一场对弈！ - <a href="https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g</a></li>
<li>Redis面试题（2020最新版） - <a href="https://blog.csdn.net/ThinkWon/article/details/103522351" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/103522351</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">
      Redis(9)——史上最强【集群】入门实践教程
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月17日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-80c61b0ae541a750.png" alt=""></p>
<h1 id="一、Redis-集群概述"><a href="#一、Redis-集群概述" class="headerlink" title="一、Redis 集群概述"></a>一、Redis 集群概述</h1><h4 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h4><p>到 <a href="#相关阅读">目前</a> 为止，我们所学习的 Redis 都是 <strong>单机版</strong> 的，这也就意味着一旦我们所依赖的 Redis 服务宕机了，我们的主流程也会受到一定的影响，这当然是我们不能够接受的。</p>
<p>所以一开始我们的想法是：搞一台备用机。这样我们就可以在一台服务器出现问题的时候切换动态地到另一台去：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c48d255bc0b13672.gif" alt=""></p>
<p>幸运的是，两个节点数据的同步我们可以使用 Redis 的 <strong>主从同步</strong> 功能帮助到我们，这样一来，有个备份，心里就踏实多了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-4a32b9efa3885655.jpg" alt=""></p>
<h4 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h4><p>后来因为某种神秘力量，Redis 老会在莫名其妙的时间点出问题 <em>(比如半夜 2 点)</em>，我总不能 24 小时时刻守在电脑旁边切换节点吧，于是另一个想法又开始了：给所有的节点找一个 <strong>“管家”</strong>，自动帮我监听照顾节点的状态并切换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-de8d9ce9e77bf211.gif" alt=""></p>
<p>这大概就是 <strong>Redis 哨兵</strong> <em>(Sentinel)</em> 的简单理解啦。什么？管家宕机了怎么办？相较于有大量请求的 Redis 服务来说，管家宕机的概率就要小得多啦.. 如果真的宕机了，我们也可以直接切换成当前可用的节点保证可用..</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c7657fb8140d7cc6.jpg" alt=""></p>
<h4 id="Redis-集群化"><a href="#Redis-集群化" class="headerlink" title="Redis 集群化"></a>Redis 集群化</h4><p>好了，通过上面的一些解决方案我们对 Redis 的 <strong>稳定性</strong> 稍微有了一些底气了，但单台节点的计算能力始终有限，所谓人多力量大，如果我们把 <strong>多个节点组合</strong> 成 <strong>一个可用的工作节点</strong>，那就大大增加了 Redis 的  <strong>高可用、可扩展、分布式、容错</strong> 等特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-8957aa6d1484c5de.png" alt=""></p>
<h1 id="二、主从复制"><a href="#二、主从复制" class="headerlink" title="二、主从复制"></a>二、主从复制</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p>在 <strong>Redis</strong> 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 <code>slaveof</code> 选项，让一个服务器去复制另一个服务器，以下三种方式是 <strong>完全等效</strong> 的：</p>
<ul>
<li><strong>配置文件</strong>：在从服务器的配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li><strong>启动命令</strong>：redis-server 启动命令后加入 <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li><strong>客户端命令</strong>：Redis 服务器启动后，直接通过客户端执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，让该 Redis 实例成为从节点。</li>
</ul>
<p>需要注意的是：<strong>主从复制的开启，完全是在从节点发起的，不需要我们在主节点做任何事情。</strong></p>
<h4 id="第一步：本地启动两个节点"><a href="#第一步：本地启动两个节点" class="headerlink" title="第一步：本地启动两个节点"></a>第一步：本地启动两个节点</h4><p>在正确安装好 Redis 之后，我们可以使用 <code>redis-server --port &lt;port&gt;</code> 的方式指定创建两个不同端口的 Redis 实例，例如，下方我分别创建了一个 <code>6379</code> 和 <code>6380</code> 的两个 Redis 实例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个端口为 6379 的 Redis 实例</span>
redis-server --port 6379
<span class="token comment" spellcheck="true"># 创建一个端口为 6380 的 Redis 实例</span>
redis-server --port 6380</code></pre>
<p>此时两个 Redis 节点启动后，都默认为 <strong>主节点</strong>。</p>
<h4 id="第二步：建立复制"><a href="#第二步：建立复制" class="headerlink" title="第二步：建立复制"></a>第二步：建立复制</h4><p>我们在 <code>6380</code> 端口的节点中执行 <code>slaveof</code> 命令，使之变为从节点：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在 6380 端口的 Redis 实例中使用控制台</span>
redis-cli -p 6380
<span class="token comment" spellcheck="true"># 成为本地 6379 端口实例的从节点</span>
127.0.0.1:6380<span class="token operator">></span> SLAVEOF 127.0.0.1ø 6379
OK</code></pre>
<h4 id="第三步：观察效果"><a href="#第三步：观察效果" class="headerlink" title="第三步：观察效果"></a>第三步：观察效果</h4><p>下面我们来验证一下，主节点的数据是否会复制到从节点之中：</p>
<ul>
<li>先在 <strong>从节点</strong> 中查询一个 <strong>不存在</strong> 的 key：<br>```bash</li>
</ul>
<p>127.0.0.1:6380&gt; GET mykey<br>(nil)</p>
<pre><code>- 再在 **主节点** 中添加这个 key：
```bash
127.0.0.1:6379&gt; SET mykey myvalue
OK</code></pre><ul>
<li>此时再从 <strong>从节点</strong> 中查询，会发现已经从 <strong>主节点</strong> 同步到 <strong>从节点</strong>：<br>```bash</li>
</ul>
<p>127.0.0.1:6380&gt; GET mykey<br>“myvalue”</p>
<pre><code>
#### 第四步：断开复制

通过 `slaveof &lt;masterip&gt; &lt;masterport&gt;` 命令建立主从复制关系以后，可以通过 `slaveof no one` 断开。需要注意的是，从节点断开复制后，**不会删除已有的数据**，只是不再接受主节点新的数据变化。

从节点执行 `slaveof no one` 之后，从节点和主节点分别打印日志如下：、

```bash
# 从节点打印日志
61496:M 17 Mar 2020 08:10:22.749 # Connection with master lost.
61496:M 17 Mar 2020 08:10:22.749 * Caching the disconnected master state.
61496:M 17 Mar 2020 08:10:22.749 * Discarding previously cached master state.
61496:M 17 Mar 2020 08:10:22.749 * MASTER MODE enabled (user request from &#39;id=4 addr=127.0.0.1:55096 fd=8 name= age=1664 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof&#39;)

# 主节点打印日志
61467:M 17 Mar 2020 08:10:22.749 # Connection with replica 127.0.0.1:6380 lost.</code></pre><h2 id="实现原理简析"><a href="#实现原理简析" class="headerlink" title="实现原理简析"></a>实现原理简析</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。下面我们来进行一些必要的说明。</p>
<h4 id="身份验证-主从复制安全问题"><a href="#身份验证-主从复制安全问题" class="headerlink" title="身份验证 | 主从复制安全问题"></a>身份验证 | 主从复制安全问题</h4><p>在上面的 <strong>快速体验</strong> 过程中，你会发现 <code>slaveof</code> 这个命令居然不需要验证？这意味着只要知道了 ip 和端口就可以随意拷贝服务器上的数据了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-d0c7a74da972fca3.jpg" alt=""></p>
<p>那当然不能够了，我们可以通过在 <strong>主节点</strong> 配置 <code>requirepass</code> 来设置密码，这样就必须在 <strong>从节点</strong> 中对应配置好 <code>masterauth</code> 参数 <em>(与主节点 <code>requirepass</code> 保持一致)</em> 才能够进行正常复制了。</p>
<h4 id="SYNC-命令是一个非常耗费资源的操作"><a href="#SYNC-命令是一个非常耗费资源的操作" class="headerlink" title="SYNC 命令是一个非常耗费资源的操作"></a>SYNC 命令是一个非常耗费资源的操作</h4><p>每次执行 <code>SYNC</code> 命令，主从服务器需要执行如下动作：</p>
<ol>
<li><strong>主服务器</strong> 需要执行 <code>BGSAVE</code> 命令来生成 RDB 文件，这个生成操作会 <strong>消耗</strong> 主服务器大量的 <strong>CPU、内存和磁盘 I/O 的资源</strong>；</li>
<li><strong>主服务器</strong> 需要将自己生成的 RDB 文件 发送给从服务器，这个发送操作会 <strong>消耗</strong> 主服务器 <strong>大量的网络资源</strong> <em>(带宽和流量)</em>，并对主服务器响应命令请求的时间产生影响；</li>
<li>接收到 RDB 文件的 <strong>从服务器</strong> 需要载入主服务器发来的 RBD 文件，并且在载入期间，从服务器 <strong>会因为阻塞而没办法处理命令请求</strong>；</li>
</ol>
<p>特别是当出现 <strong>断线重复制</strong> 的情况是时，为了让从服务器补足断线时确实的那一小部分数据，却要执行一次如此耗资源的 <code>SYNC</code> 命令，显然是不合理的。</p>
<h4 id="PSYNC-命令的引入"><a href="#PSYNC-命令的引入" class="headerlink" title="PSYNC 命令的引入"></a>PSYNC 命令的引入</h4><p>所以在 <strong>Redis 2.8</strong> 中引入了 <code>PSYNC</code> 命令来代替 <code>SYNC</code>，它具有两种模式：</p>
<ol>
<li><strong>全量复制：</strong> 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作；</li>
<li><strong>部分复制：</strong> 用于网络中断等情况后的复制，只将 <strong>中断期间主节点执行的写命令</strong> 发送给从节点，与全量复制相比更加高效。<strong>需要注意</strong> 的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制；</li>
</ol>
<p>部分复制的原理主要是靠主从节点分别维护一个 <strong>复制偏移量</strong>，有了这个偏移量之后断线重连之后一比较，之后就可以仅仅把从服务器断线之后确实的这部分数据给补回来了。</p>
<blockquote>
<p>更多的详细内容可以参考下方 <em>参考资料 3</em></p>
</blockquote>
<h1 id="三、Redis-Sentinel-哨兵"><a href="#三、Redis-Sentinel-哨兵" class="headerlink" title="三、Redis Sentinel 哨兵"></a>三、Redis Sentinel 哨兵</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h2 id="快速体验-1"><a href="#快速体验-1" class="headerlink" title="快速体验"></a>快速体验</h2><h4 id="第一步：创建主从节点配置文件并启动"><a href="#第一步：创建主从节点配置文件并启动" class="headerlink" title="第一步：创建主从节点配置文件并启动"></a>第一步：创建主从节点配置文件并启动</h4><p>正确安装好 Redis 之后，我们去到 Redis 的安装目录 <em>(mac 默认在 <code>/usr/local/</code>)*，找到 <code>redis.conf</code> 文件复制三份分别命名为 <code>redis-master.conf</code>/<code>redis-slave1.conf</code>/<code>redis-slave2.conf</code>，分别作为 <code>1</code> 个主节点和 <code>2</code> 个从节点的配置文件 *(下图演示了我本机的 <code>redis.conf</code> 文件的位置)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-34de77bfca56d32e.png" alt=""></p>
<p>打开可以看到这个 <code>.conf</code> 后缀的文件里面有很多说明的内容，全部删除然后分别改成下面的样子：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#redis-master.conf</span>
port 6379
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6379.log"</span>
dbfilename <span class="token string">"dump-6379.rdb"</span>

<span class="token comment" spellcheck="true">#redis-slave1.conf</span>
port 6380
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6380.log"</span>
dbfilename <span class="token string">"dump-6380.rdb"</span>
slaveof 127.0.0.1 6379

<span class="token comment" spellcheck="true">#redis-slave2.conf</span>
port 6381
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6381.log"</span>
dbfilename <span class="token string">"dump-6381.rdb"</span>
slaveof 127.0.0.1 6379</code></pre>
<p>然后我们可以执行 <code>redis-server &lt;config file path&gt;</code> 来根据配置文件启动不同的 Redis 实例，依次启动主从节点：</p>
<pre class=" language-bash"><code class="language-bash">redis-server /usr/local/redis-5.0.3/redis-master.conf
redis-server /usr/local/redis-5.0.3/redis-slave1.conf
redis-server /usr/local/redis-5.0.3/redis-slave2.conf</code></pre>
<p>节点启动后，我们执行 <code>redis-cli</code> 默认连接到我们端口为 <code>6379</code> 的主节点执行 <code>info Replication</code> 检查一下主从状态是否正常：<em>(可以看到下方正确地显示了两个从节点)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-a1c935f094240cac.png" alt=""></p>
<h4 id="第二步：创建哨兵节点配置文件并启动"><a href="#第二步：创建哨兵节点配置文件并启动" class="headerlink" title="第二步：创建哨兵节点配置文件并启动"></a>第二步：创建哨兵节点配置文件并启动</h4><p>按照上面同样的方法，我们给哨兵节点也创建三个配置文件。<em>(哨兵节点本质上是特殊的 Redis 节点，所以配置几乎没什么差别，只是在端口上做区分就好)</em></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># redis-sentinel-1.conf</span>
port 26379
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26379.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2

<span class="token comment" spellcheck="true"># redis-sentinel-2.conf</span>
port 26380
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26380.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2

<span class="token comment" spellcheck="true"># redis-sentinel-3.conf</span>
port 26381
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26381.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2</code></pre>
<p>其中，<code>sentinel monitor mymaster 127.0.0.1 6379 2</code> 配置的含义是：该哨兵节点监控 <code>127.0.0.1:6379</code> 这个主节点，该主节点的名称是 <code>mymaster</code>，最后的 <code>2</code> 的含义与主节点的故障判定有关：至少需要 <code>2</code> 个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>
<p>执行下方命令将哨兵节点启动起来：</p>
<pre class=" language-bash"><code class="language-bash">redis-server /usr/local/redis-5.0.3/redis-sentinel-1.conf --sentinel
redis-server /usr/local/redis-5.0.3/redis-sentinel-2.conf --sentinel
redis-server /usr/local/redis-5.0.3/redis-sentinel-3.conf --sentinel</code></pre>
<p>使用 <code>redis-cil</code> 工具连接哨兵节点，并执行 <code>info Sentinel</code> 命令来查看是否已经在监视主节点了：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 连接端口为 26379 的 Redis 节点</span>
➜  ~ redis-cli -p 26379
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>此时你打开刚才写好的哨兵配置文件，你还会发现出现了一些变化：</p>
<h4 id="第三步：演示故障转移"><a href="#第三步：演示故障转移" class="headerlink" title="第三步：演示故障转移"></a>第三步：演示故障转移</h4><p>首先，我们使用 <code>kill -9</code> 命令来杀掉主节点，<strong>同时</strong> 在哨兵节点中执行 <code>info Sentinel</code> 命令来观察故障节点的过程：</p>
<pre class=" language-bash"><code class="language-bash">➜  ~ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> 6379
longtao          74529   0.3  0.0  4346936   2132   ??  Ss   10:30上午   0:03.09 redis-server *:26379 <span class="token punctuation">[</span>sentinel<span class="token punctuation">]</span>
longtao          73541   0.2  0.0  4348072   2292   ??  Ss   10:18上午   0:04.79 redis-server *:6379
longtao          75521   0.0  0.0  4286728    728 s008  S+   10:39上午   0:00.00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto --exclude-dir<span class="token operator">=</span>.bzr --exclude-dir<span class="token operator">=</span>CVS --exclude-dir<span class="token operator">=</span>.git --exclude-dir<span class="token operator">=</span>.hg --exclude-dir<span class="token operator">=</span>.svn 6379
longtao          74836   0.0  0.0  4289844    944 s006  S+   10:32上午   0:00.01 redis-cli -p 26379
➜  ~ <span class="token function">kill</span> -9 73541</code></pre>
<p>如果 <strong>刚杀掉瞬间</strong> 在哨兵节点中执行 <code>info</code> 命令来查看，会发现主节点还没有切换过来，因为哨兵发现主节点故障并转移需要一段时间：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 第一时间查看哨兵节点发现并未转移，还在 6379 端口</span>
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>一段时间之后你再执行 <code>info</code> 命令，查看，你就会发现主节点已经切换成了 <code>6381</code> 端口的从节点：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 过一段时间之后在执行，发现已经切换了 6381 端口</span>
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6381,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>但同时还可以发现，<strong>哨兵节点认为新的主节点仍然有两个从节点</strong> <em>(上方 slaves=2)</em>，这是因为哨兵在将 <code>6381</code> 切换成主节点的同时，将 <code>6379</code> 节点置为其从节点。虽然 <code>6379</code> 从节点已经挂掉，但是由于 <strong>哨兵并不会对从节点进行客观下线</strong>，因此认为该从节点一直存在。当 <code>6379</code> 节点重新启动后，会自动变成 <code>6381</code> 节点的从节点。</p>
<p>另外，在故障转移的阶段，哨兵和主从节点的配置文件都会被改写：</p>
<ul>
<li><strong>对于主从节点：</strong> 主要是 <code>slaveof</code> 配置的变化，新的主节点没有了 <code>slaveof</code> 配置，其从节点则 <code>slaveof</code> 新的主节点。</li>
<li><strong>对于哨兵节点：</strong> 除了主从节点信息的变化，纪元(epoch) <em>(记录当前集群状态的参数)</em> 也会变化，纪元相关的参数都 +1 了。</li>
</ul>
<h2 id="客户端访问哨兵系统代码演示"><a href="#客户端访问哨兵系统代码演示" class="headerlink" title="客户端访问哨兵系统代码演示"></a>客户端访问哨兵系统代码演示</h2><p>上面我们在 <em>快速体验</em> 中主要感受到了服务端自己对于当前主从节点的自动化治理，下面我们以 Java 代码为例，来演示一下客户端如何访问我们的哨兵系统：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSentinel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
         String masterName <span class="token operator">=</span> <span class="token string">"mymaster"</span><span class="token punctuation">;</span>
         Set<span class="token operator">&lt;</span>String<span class="token operator">></span> sentinels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26380"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26381"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">// 初始化过程做了很多工作</span>
         JedisSentinelPool pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span>masterName<span class="token punctuation">,</span> sentinels<span class="token punctuation">)</span><span class="token punctuation">;</span> 
         Jedis jedis <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         pool<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="客户端原理"><a href="#客户端原理" class="headerlink" title="客户端原理"></a>客户端原理</h4><p>Jedis 客户端对哨兵提供了很好的支持。如上述代码所示，我们只需要向 Jedis 提供哨兵节点集合和 <code>masterName</code> ，构造 <code>JedisSentinelPool</code> 对象，然后便可以像使用普通 Redis 连接池一样来使用了：通过 <code>pool.getResource()</code> 获取连接，执行具体的命令。</p>
<p>在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点；代码中对故障转移没有任何体现，就可以在哨兵完成故障转移后自动的切换主节点。之所以可以做到这一点，是因为在 <code>JedisSentinelPool</code> 的构造器中，进行了相关的工作；主要包括以下两点：</p>
<ol>
<li><strong>遍历哨兵节点，获取主节点信息：</strong> 遍历哨兵节点，通过其中一个哨兵节点 + <code>masterName</code> 获得主节点的信息；该功能是通过调用哨兵节点的 <code>sentinel get-master-addr-by-name</code> 命令实现；</li>
<li><strong>增加对哨兵的监听：</strong> 这样当发生故障转移时，客户端便可以收到哨兵的通知，从而完成主节点的切换。具体做法是：利用 Redis 提供的 <strong>发布订阅</strong> 功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的 + switch-master 频道，当收到消息时，重新初始化连接池。</li>
</ol>
<h2 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h2><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<h1 id="四、Redis-集群"><a href="#四、Redis-集群" class="headerlink" title="四、Redis 集群"></a>四、Redis 集群</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="快速体验-2"><a href="#快速体验-2" class="headerlink" title="快速体验"></a>快速体验</h2><h4 id="第一步：创建集群节点配置文件"><a href="#第一步：创建集群节点配置文件" class="headerlink" title="第一步：创建集群节点配置文件"></a>第一步：创建集群节点配置文件</h4><p>首先我们找一个地方创建一个名为 <code>redis-cluster</code> 的目录：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/Desktop/redis-cluster</code></pre>
<p>然后按照上面的方法，创建六个配置文件，分别命名为：<code>redis_7000.conf</code>/<code>redis_7001.conf</code>…..<code>redis_7005.conf</code>，然后根据不同的端口号修改对应的端口值就好了：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 后台执行</span>
daemonize <span class="token function">yes</span>
<span class="token comment" spellcheck="true"># 端口号</span>
port 7000
<span class="token comment" spellcheck="true"># 为每一个集群节点指定一个 pid_file</span>
pidfile ~/Desktop/redis-cluster/redis_7000.pid
<span class="token comment" spellcheck="true"># 启动集群模式</span>
cluster-enabled <span class="token function">yes</span>
<span class="token comment" spellcheck="true"># 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通</span>
cluster-config-file nodes-7000.conf
<span class="token comment" spellcheck="true"># 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败</span>
cluster-node-timeout 5000
<span class="token comment" spellcheck="true"># 最后将 appendonly 改成 yes(AOF 持久化)</span>
appendonly <span class="token function">yes</span></code></pre>
<p>记得把对应上述配置文件中根端口对应的配置都修改掉 <em>(port/ pidfile/ cluster-config-file)</em>。</p>
<h4 id="第二步：分别启动-6-个-Redis-实例"><a href="#第二步：分别启动-6-个-Redis-实例" class="headerlink" title="第二步：分别启动 6 个 Redis 实例"></a>第二步：分别启动 6 个 Redis 实例</h4><pre class=" language-bash"><code class="language-bash">redis-server ~/Desktop/redis-cluster/redis_7000.conf
redis-server ~/Desktop/redis-cluster/redis_7001.conf
redis-server ~/Desktop/redis-cluster/redis_7002.conf
redis-server ~/Desktop/redis-cluster/redis_7003.conf
redis-server ~/Desktop/redis-cluster/redis_7004.conf
redis-server ~/Desktop/redis-cluster/redis_7005.conf</code></pre>
<p>然后执行 <code>ps -ef | grep redis</code> 查看是否启动成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-452c3152054c36f1.png" alt=""></p>
<p>可以看到 <code>6</code> 个 Redis 节点都以集群的方式成功启动了，<strong>但是现在每个节点还处于独立的状态</strong>，也就是说它们每一个都各自成了一个集群，还没有互相联系起来，我们需要手动地把他们之间建立起联系。</p>
<h4 id="第三步：建立集群"><a href="#第三步：建立集群" class="headerlink" title="第三步：建立集群"></a>第三步：建立集群</h4><p>执行下列命令：</p>
<pre class=" language-bash"><code class="language-bash">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></pre>
<ul>
<li>这里稍微解释一下这个 <code>--replicas 1</code> 的意思是：我们希望为集群中的每个主节点创建一个从节点。</li>
</ul>
<p>观察控制台输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-d5ab644e76e9cc87.png" alt=""></p>
<p>看到 <code>[OK]</code> 的信息之后，就表示集群已经搭建成功了，可以看到，这里我们正确地创建了三主三从的集群。</p>
<h4 id="第四步：验证集群"><a href="#第四步：验证集群" class="headerlink" title="第四步：验证集群"></a>第四步：验证集群</h4><p>我们先使用 <code>redic-cli</code> 任意连接一个节点：</p>
<pre class=" language-bash"><code class="language-bash">redis-cli -c -h 127.0.0.1 -p 7000
127.0.0.1:7000<span class="token operator">></span></code></pre>
<ul>
<li><code>-c</code>表示集群模式；<code>-h</code> 指定 ip 地址；<code>-p</code> 指定端口。</li>
</ul>
<p>然后随便 <code>set</code> 一些值观察控制台输入：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:7000<span class="token operator">></span> SET name wmyskxz
-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>5798<span class="token punctuation">]</span> located at 127.0.0.1:7001
OK
127.0.0.1:7001<span class="token operator">></span></code></pre>
<p>可以看到这里 Redis 自动帮我们进行了 <code>Redirected</code> 操作跳转到了 <code>7001</code> 这个实例上。</p>
<p>我们再使用 <code>cluster info</code> <em>(查看集群信息)</em> 和 <code>cluster nodes</code> <em>(查看节点列表)</em> 来分别看看：<em>(任意节点输入均可)</em></p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:7001<span class="token operator">></span> CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:2
cluster_stats_messages_ping_sent:1365
cluster_stats_messages_pong_sent:1358
cluster_stats_messages_meet_sent:4
cluster_stats_messages_sent:2727
cluster_stats_messages_ping_received:1357
cluster_stats_messages_pong_received:1369
cluster_stats_messages_meet_received:1
cluster_stats_messages_received:2727

127.0.0.1:7001<span class="token operator">></span> CLUSTER NODES
56a04742f36c6e84968cae871cd438935081e86f 127.0.0.1:7003@17003 slave 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 0 1584428884000 4 connected
4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 127.0.0.1:7000@17000 master - 0 1584428884000 1 connected 0-5460
e2539c4398b8258d3f9ffa714bd778da107cb2cd 127.0.0.1:7005@17005 slave a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 0 1584428885222 6 connected
d31cd1f423ab1e1849cac01ae927e4b6950f55d9 127.0.0.1:7004@17004 slave 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 0 1584428884209 5 connected
236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 127.0.0.1:7001@17001 myself,master - 0 1584428882000 2 connected 5461-10922
a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 127.0.0.1:7002@17002 master - 0 1584428884000 3 connected 10923-16383
127.0.0.1:7001<span class="token operator">></span></code></pre>
<h2 id="数据分区方案简析"><a href="#数据分区方案简析" class="headerlink" title="数据分区方案简析"></a>数据分区方案简析</h2><h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点通信机制简析"><a href="#节点通信机制简析" class="headerlink" title="节点通信机制简析"></a>节点通信机制简析</h2><p>集群的建立离不开节点之间的通信，例如我们上访在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="数据结构简析"><a href="#数据结构简析" class="headerlink" title="数据结构简析"></a>数据结构简析</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<blockquote>
<p>更多关于集群内容请自行阅读《Redis 设计与实现》，其中有更多细节方面的介绍 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></p>
</blockquote>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
<li>Redis(6)——GeoHash查找附近的人<a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 设计与实现》 | 黄健宏 著 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></li>
<li>《Redis 深度历险》 | 钱文品 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>深入学习Redis（3）：主从复制 - <a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></li>
<li>Redis 主从复制 原理与用法 - <a href="https://blog.csdn.net/Stubborn_Cow/article/details/50442950" target="_blank" rel="noopener">https://blog.csdn.net/Stubborn_Cow/article/details/50442950</a></li>
<li>深入学习Redis（4）：哨兵 - <a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9609938.html</a></li>
<li>Redis 5 之后版本的高可用集群搭建 - <a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">https://www.jianshu.com/p/8045b92fafb2</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">
      Redis(8)——发布/订阅与Stream
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月15日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-31406a824536c54a.png" alt=""></p>
<h1 id="一、Redis-中的发布-订阅功能"><a href="#一、Redis-中的发布-订阅功能" class="headerlink" title="一、Redis 中的发布/订阅功能"></a>一、Redis 中的发布/订阅功能</h1><p><strong>发布/ 订阅系统</strong> 是 Web 系统中比较常用的一个功能。简单点说就是 <strong>发布者发布消息，订阅者接受消息</strong>，这有点类似于我们的报纸/ 杂志社之类的： <em>(借用前边的一张图)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-13aa5cb2668368fe.png" alt=""></p>
<ul>
<li>图片引用自：「消息队列」看过来! - <a href="https://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/">https://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/</a></li>
</ul>
<p>从我们 <em>前面(下方相关阅读)</em> 学习的知识来看，我们虽然可以使用一个 <code>list</code> 列表结构结合 <code>lpush</code> 和 <code>rpop</code> 来实现消息队列的功能，但是似乎很难实现实现 <strong>消息多播</strong> 的功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-526a5b110a7c4ea2.png" alt=""></p>
<p>为了支持消息多播，<strong>Redis</strong> 不能再依赖于那 5 种基础的数据结构了，它单独使用了一个模块来支持消息多播，这个模块就是 <strong>PubSub</strong>，也就是 <strong>PublisherSubscriber</strong> <em>(发布者/ 订阅者模式)</em>。</p>
<h2 id="PubSub-简介"><a href="#PubSub-简介" class="headerlink" title="PubSub 简介"></a>PubSub 简介</h2><p>我们从 <em>上面的图</em> 中可以看到，基于 <code>list</code> 结构的消息队列，是一种 <code>Publisher</code> 与 <code>Consumer</code> 点对点的强关联关系，<strong>Redis</strong> 为了消除这样的强关联，引入了另一种概念：<strong>频道</strong> <em>(channel)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-cc3bb012eeca9fca.png" alt=""></p>
<p>当 <code>Publisher</code> 往 <code>channel</code> 中发布消息时，关注了指定 <code>channel</code> 的 <code>Consumer</code> 就能够同时受到消息。但这里的 <strong>问题</strong> 是，消费者订阅一个频道是必须 <strong>明确指定频道名称</strong> 的，这意味着，如果我们想要 <strong>订阅多个</strong> 频道，那么就必须 <strong>显式地关注多个</strong> 名称。</p>
<p>为了简化订阅的繁琐操作，<strong>Redis</strong> 提供了 <strong>模式订阅</strong> 的功能 <strong>Pattern Subscribe</strong>，这样就可以 <strong>一次性关注多个频道</strong> 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-18ac258e4e9387da.png" alt=""></p>
<p>例如上图中，<strong>所有</strong> 位于图片下方的 <strong><code>Consumer</code> 都能够受到消息</strong>。</p>
<p><code>Publisher</code> 往 <code>wmyskxz.chat</code> 这个 <code>channel</code> 中发送了一条消息，不仅仅关注了这个频道的 <code>Consumer 1</code> 和 <code>Consumer 2</code> 能够受到消息，图片中的两个 <code>channel</code> 都和模式 <code>wmyskxz.*</code> 匹配，所以 <strong>Redis</strong> 此时会同样发送消息给订阅了 <code>wmyskxz.*</code> 这个模式的 <code>Consumer 3</code> 和关注了在这个模式下的另一个频道 <code>wmyskxz.log</code> 下的 <code>Consumer 4</code> 和 <code>Consumer 5</code>。</p>
<p>另一方面，如果接收消息的频道是 <code>wmyskxz.chat</code>，那么 <code>Consumer 3</code> 也会受到消息。  </p>
<h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p>在 <strong>Redis</strong> 中，<strong>PubSub</strong> 模块的使用非常简单，常用的命令也就下面这么几条：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 订阅频道：</span>
SUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 订阅给定的一个或多个频道的信息</span>
PSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 订阅一个或多个符合给定模式的频道</span>
<span class="token comment" spellcheck="true"># 发布频道：</span>
PUBLISH channel message  <span class="token comment" spellcheck="true"># 将消息发送到指定的频道</span>
<span class="token comment" spellcheck="true"># 退订频道：</span>
UNSUBSCRIBE <span class="token punctuation">[</span>channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 退订指定的频道</span>
PUNSUBSCRIBE <span class="token punctuation">[</span>pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#退订所有给定模式的频道</span></code></pre>
<p>我们可以在本地快速地来体验一下 <strong>PubSub</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-518e0d1e93135775.gif" alt=""></p>
<p>具体步骤如下：</p>
<ol>
<li>开启本地 Redis 服务，新建两个控制台窗口；</li>
<li>在其中一个窗口输入 <code>SUBSCRIBE wmyskxz.chat</code> 关注 <code>wmyskxz.chat</code> 频道，让这个窗口成为 <strong>消费者</strong>。</li>
<li>在另一个窗口输入 <code>PUBLISH wmyskxz.chat &#39;message&#39;</code> 往这个频道发送消息，这个时候就会看到 <strong>另一个窗口实时地出现</strong> 了发送的测试消息。</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>可以看到，我们通过很简单的两条命令，几乎就可以简单使用这样的一个 <strong>发布/ 订阅系统</strong> 了，但是具体是怎么样实现的呢？</p>
<p><strong>每个 Redis 服务器进程维持着一个标识服务器状态</strong> 的 <code>redis.h/redisServer</code> 结构，其中就 <strong>保存着有订阅的频道</strong> 以及 <strong>订阅模式</strong> 的信息：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅频道</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅模式</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="订阅频道原理"><a href="#订阅频道原理" class="headerlink" title="订阅频道原理"></a>订阅频道原理</h3><p>当客户端订阅某一个频道之后，Redis 就会往 <code>pubsub_channels</code> 这个字典中新添加一条数据，实际上这个 <code>dict</code> 字典维护的是一张链表，比如，下图展示的 <code>pubsub_channels</code> 示例中，<code>client 1</code>、<code>client 2</code> 就订阅了 <code>channel 1</code>，而其他频道也分别被其他客户端订阅：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-218fc15f7c368eee.png" alt=""></p>
<h4 id="SUBSCRIBE-命令"><a href="#SUBSCRIBE-命令" class="headerlink" title="SUBSCRIBE 命令"></a>SUBSCRIBE 命令</h4><p><code>SUBSCRIBE</code> 命令的行为可以用下列的伪代码表示：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">SUBSCRIBE</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 遍历所有输入频道</span>
    <span class="token keyword">for</span> channel <span class="token keyword">in</span> channels<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 将客户端添加到链表的末尾</span>
        redisServer<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>client<span class="token punctuation">)</span></code></pre>
<p>通过 <code>pubsub_channels</code> 字典，程序只要检查某个频道是否为字典的键，就可以知道该频道是否正在被客户端订阅；只要取出某个键的值，就可以得到所有订阅该频道的客户端的信息。</p>
<h4 id="PUBLISH-命令"><a href="#PUBLISH-命令" class="headerlink" title="PUBLISH 命令"></a>PUBLISH 命令</h4><p>了解 <code>SUBSCRIBE</code>，那么 <code>PUBLISH</code> 命令的实现也变得十分简单了，只需要通过上述字典定位到具体的客户端，再把消息发送给它们就好了：<em>(伪代码实现如下)</em></p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 遍历所有订阅频道 channel 的客户端</span>
    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 将信息发送给它们</span>
        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span></code></pre>
<h4 id="UNSUBSCRIBE-命令"><a href="#UNSUBSCRIBE-命令" class="headerlink" title="UNSUBSCRIBE 命令"></a>UNSUBSCRIBE 命令</h4><p>使用 <code>UNSUBSCRIBE</code> 命令可以退订指定的频道，这个命令执行的是订阅的反操作：它从 <code>pubsub_channels</code> 字典的给定频道（键）中，删除关于当前客户端的信息，这样被退订频道的信息就不会再发送给这个客户端。</p>
<h3 id="订阅模式原理"><a href="#订阅模式原理" class="headerlink" title="订阅模式原理"></a>订阅模式原理</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-18ac258e4e9387da.png" alt=""></p>
<p>正如我们上面说到了，当发送一条消息到 <code>wmyskxz.chat</code> 这个频道时，Redis 不仅仅会发送到当前的频道，还会发送到匹配于当前模式的所有频道，实际上，<code>pubsub_patterns</code> 背后还维护了一个 <code>redis.h/pubsubPattern</code> 结构：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> pubsubPattern <span class="token punctuation">{</span>
    redisClient <span class="token operator">*</span>client<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅模式的客户端</span>
    robj <span class="token operator">*</span>pattern<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 订阅的模式</span>
<span class="token punctuation">}</span> pubsubPattern<span class="token punctuation">;</span></code></pre>
<p>每当调用 <code>PSUBSCRIBE</code> 命令订阅一个模式时，程序就创建一个包含客户端信息和被订阅模式的 <code>pubsubPattern</code> 结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。</p>
<p>我们来看一个 <code>pusub_patterns</code> 链表的示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-d0d3b1849fdb6162.png" alt=""></p>
<p>这个时候客户端 <code>client 3</code> 执行 <code>PSUBSCRIBE wmyskxz.java.*</code>，那么 <code>pubsub_patterns</code> 链表就会被更新成这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-edbf11995590de50.png" alt=""></p>
<p>通过遍历整个 <code>pubsub_patterns</code> 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。</p>
<h4 id="PUBLISH-命令-1"><a href="#PUBLISH-命令-1" class="headerlink" title="PUBLISH 命令"></a>PUBLISH 命令</h4><p>上面给出的伪代码并没有 <strong>完整描述</strong> <code>PUBLISH</code> 命令的行为，因为 <code>PUBLISH</code> 除了将 <code>message</code> 发送到 <strong>所有订阅 <code>channel</code> 的客户端</strong> 之外，它还会将 <code>channel</code> 和 <code>pubsub_patterns</code> 中的 <strong>模式</strong> 进行对比，如果 <code>channel</code> 和某个模式匹配的话，那么也将 <code>message</code> 发送到 <strong>订阅那个模式的客户端</strong>。</p>
<p>完整描述 <code>PUBLISH</code> 功能的伪代码定于如下：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 遍历所有订阅频道 channel 的客户端</span>
    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 将信息发送给它们</span>
        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 取出所有模式，以及订阅模式的客户端</span>
    <span class="token keyword">for</span> pattern<span class="token punctuation">,</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 如果 channel 和模式匹配</span>
        <span class="token keyword">if</span> match<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># 那么也将信息发给订阅这个模式的客户端</span>
            send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span></code></pre>
<h4 id="PUNSUBSCRIBE-命令"><a href="#PUNSUBSCRIBE-命令" class="headerlink" title="PUNSUBSCRIBE 命令"></a>PUNSUBSCRIBE 命令</h4><p>使用 <code>PUNSUBSCRIBE</code> 命令可以退订指定的模式，这个命令执行的是订阅模式的反操作：序会删除 <code>redisServer.pubsub_patterns</code> 链表中，所有和被退订模式相关联的 <code>pubsubPattern</code> 结构，这样客户端就不会再收到和模式相匹配的频道发来的信息。</p>
<h2 id="PubSub-的缺点"><a href="#PubSub-的缺点" class="headerlink" title="PubSub 的缺点"></a>PubSub 的缺点</h2><p>尽管 <strong>Redis</strong> 实现了 <strong>PubSub</strong> 模式来达到了 <strong>多播消息队列</strong> 的目的，但在实际的消息队列的领域，几乎 <strong>找不到特别合适的场景</strong>，因为它的缺点十分明显：</p>
<ul>
<li><strong>没有 Ack 机制，也不保证数据的连续：</strong> PubSub 的生产者传递过来一个消息，Redis 会直接找到相应的消费者传递过去。如果没有一个消费者，那么消息会被直接丢弃。如果开始有三个消费者，其中一个突然挂掉了，过了一会儿等它再重连时，那么重连期间的消息对于这个消费者来说就彻底丢失了。</li>
<li><strong>不持久化消息：</strong> 如果 Redis 停机重启，PubSub 的消息是不会持久化的，毕竟 Redis 宕机就相当于一个消费者都没有，所有的消息都会被直接丢弃。</li>
</ul>
<p>基于上述缺点，Redis 的作者甚至单独开启了一个 Disque 的项目来专门用来做多播消息队列，不过该项目目前好像都没有成熟。不过后来在 2018 年 6 月，<strong>Redis 5.0</strong> 新增了 <code>Stream</code> 数据结构，这个功能给 Redis 带来了 <strong>持久化消息队列</strong>，从此 PubSub 作为消息队列的功能可以说是就消失了..</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-3a144fda1a0dafcb.gif" alt="image"></p>
<h1 id="二、更为强大的-Stream-持久化的发布-订阅系统"><a href="#二、更为强大的-Stream-持久化的发布-订阅系统" class="headerlink" title="二、更为强大的 Stream | 持久化的发布/订阅系统"></a>二、更为强大的 Stream | 持久化的发布/订阅系统</h1><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-b9d8afde068a165f.png" alt=""></p>
<p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p>
<ul>
<li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li>
<li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li>
<li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li>
</ul>
<h2 id="消息-ID-和消息内容"><a href="#消息-ID-和消息内容" class="headerlink" title="消息 ID 和消息内容"></a>消息 ID 和消息内容</h2><h4 id="消息-ID"><a href="#消息-ID" class="headerlink" title="消息 ID"></a>消息 ID</h4><p>消息 ID 如果是由 <code>XADD</code> 命令返回自动创建的话，那么它的格式会像这样：<code>timestampInMillis-sequence</code> <em>(毫秒时间戳-序列号)</em>，例如 <code>1527846880585-5</code>，它表示当前的消息是在毫秒时间戳 <code>1527846880585</code> 时产生的，并且是该毫秒内产生的第 5 条消息。</p>
<p>这些 ID 的格式看起来有一些奇怪，<strong>为什么要使用时间来当做 ID 的一部分呢？</strong> 一方面，我们要 <strong>满足 ID 自增</strong> 的属性，另一方面，也是为了 <strong>支持范围查找</strong> 的功能。由于 ID 和生成消息的时间有关，这样就使得在根据时间范围内查找时基本上是没有额外损耗的。</p>
<p>当然消息 ID 也可以由客户端自定义，但是形式必须是 <strong>“整数-整数”</strong>，而且后面加入的消息的 ID 必须要大于前面的消息 ID。</p>
<h4 id="消息内容"><a href="#消息内容" class="headerlink" title="消息内容"></a>消息内容</h4><p>消息内容就是普通的键值对，形如 hash 结构的键值对。</p>
<h2 id="增删改查示例"><a href="#增删改查示例" class="headerlink" title="增删改查示例"></a>增删改查示例</h2><p>增删改查命令很简单，详情如下：</p>
<ol>
<li><code>xadd</code>：追加消息</li>
<li><code>xdel</code>：删除消息，这里的删除仅仅是设置了标志位，不影响消息总长度</li>
<li><code>xrange</code>：获取消息列表，会自动过滤已经删除的消息</li>
<li><code>xlen</code>：消息长度</li>
<li><code>del</code>：删除Stream</li>
</ol>
<p>使用示例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># *号表示服务器自动生成ID，后面顺序跟着一堆key/value</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name laoqian age 30  <span class="token comment" spellcheck="true">#  名字叫laoqian，年龄30岁</span>
1527849609889-0  <span class="token comment" spellcheck="true"># 生成的消息ID</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name xiaoyu age 29
1527849629172-0
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name xiaoqian age 1
1527849637634-0
127.0.0.1:6379<span class="token operator">></span> xlen codehole
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6379<span class="token operator">></span> xrange codehole - +  <span class="token comment" spellcheck="true"># -表示最小值, +表示最大值</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849609889-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"30"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849637634-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> xrange codehole 1527849629172-0 +  <span class="token comment" spellcheck="true"># 指定最小消息ID的列表</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849637634-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> xrange codehole - 1527849629172-0  <span class="token comment" spellcheck="true"># 指定最大消息ID的列表</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849609889-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"30"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
127.0.0.1:6379<span class="token operator">></span> xdel codehole 1527849609889-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> xlen codehole  <span class="token comment" spellcheck="true"># 长度不受影响</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6379<span class="token operator">></span> xrange codehole - +  <span class="token comment" spellcheck="true"># 被删除的消息没了</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849637634-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> del codehole  <span class="token comment" spellcheck="true"># 删除整个Stream</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<h2 id="独立消费示例"><a href="#独立消费示例" class="headerlink" title="独立消费示例"></a>独立消费示例</h2><p>我们可以在不定义消费组的情况下进行 Stream 消息的 <strong>独立消费</strong>，当 Stream 没有新消息时，甚至可以阻塞等待。Redis 设计了一个单独的消费指令 <code>xread</code>，可以将 Stream 当成普通的消息队列(list)来使用。使用 <code>xread</code> 时，我们可以完全忽略 <strong>消费组(Consumer Group)</strong> 的存在，就好比 Stream 就是一个普通的列表(list)：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 从Stream头部读取两条消息</span>
127.0.0.1:6379<span class="token operator">></span> xread count 2 streams codehole 0-0
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851486781-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"30"</span>
      2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851493405-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"yurui"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"29"</span>
<span class="token comment" spellcheck="true"># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span>
127.0.0.1:6379<span class="token operator">></span> xread count 1 streams codehole $
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span>
127.0.0.1:6379<span class="token operator">></span> xread block 0 count 1 streams codehole $
<span class="token comment" spellcheck="true"># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name youming age 60
1527852774092-0
<span class="token comment" spellcheck="true"># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span>
<span class="token comment" spellcheck="true"># 而且还显示了一个等待时间，这里我们等待了93s</span>
127.0.0.1:6379<span class="token operator">></span> xread block 0 count 1 streams codehole $
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527852774092-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"youming"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token punctuation">(</span>93.11s<span class="token punctuation">)</span></code></pre>
<p>客户端如果想要使用 <code>xread</code> 进行 <strong>顺序消费</strong>，一定要 <strong>记住当前消费</strong> 到哪里了，也就是返回的消息 ID。下次继续调用 <code>xread</code> 时，将上次返回的最后一个消息 ID 作为参数传递进去，就可以继续消费后续的消息。</p>
<p><code>block 0</code> 表示永远阻塞，直到消息到来，<code>block 1000</code> 表示阻塞 <code>1s</code>，如果 <code>1s</code> 内没有任何消息到来，就返回 <code>nil</code>：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> xread block 1000 count 1 streams codehole $
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token punctuation">(</span>1.07s<span class="token punctuation">)</span></code></pre>
<h2 id="创建消费者示例"><a href="#创建消费者示例" class="headerlink" title="创建消费者示例"></a>创建消费者示例</h2><p>Stream 通过 <code>xgroup create</code> 指令创建消费组(Consumer Group)，需要传递起始消息 ID 参数用来初始化 <code>last_delivered_id</code> 变量：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> xgroup create codehole cg1 0-0  <span class="token comment" spellcheck="true">#  表示从头开始消费</span>
OK
<span class="token comment" spellcheck="true"># $表示从尾部开始消费，只接受新消息，当前Stream消息会全部忽略</span>
127.0.0.1:6379<span class="token operator">></span> xgroup create codehole cg2 $
OK
127.0.0.1:6379<span class="token operator">></span> xinfo codehole  <span class="token comment" spellcheck="true"># 获取Stream信息</span>
 1<span class="token punctuation">)</span> length
 2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3  <span class="token comment" spellcheck="true"># 共3个消息</span>
 3<span class="token punctuation">)</span> radix-tree-keys
 4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
 5<span class="token punctuation">)</span> radix-tree-nodes
 6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
 7<span class="token punctuation">)</span> <span class="token function">groups</span>
 8<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2  <span class="token comment" spellcheck="true"># 两个消费组</span>
 9<span class="token punctuation">)</span> first-entry  <span class="token comment" spellcheck="true"># 第一个消息</span>
10<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851486781-0
    2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
       2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
       3<span class="token punctuation">)</span> <span class="token string">"age"</span>
       4<span class="token punctuation">)</span> <span class="token string">"30"</span>
11<span class="token punctuation">)</span> last-entry  <span class="token comment" spellcheck="true"># 最后一个消息</span>
12<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851498956-0
    2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
       2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
       3<span class="token punctuation">)</span> <span class="token string">"age"</span>
       4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> xinfo <span class="token function">groups</span> codehole  <span class="token comment" spellcheck="true"># 获取Stream的消费组信息</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg1"</span>
   3<span class="token punctuation">)</span> consumers
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 该消费组还没有消费者</span>
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 该消费组没有正在处理的消息</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg2"</span>
   3<span class="token punctuation">)</span> consumers  <span class="token comment" spellcheck="true"># 该消费组还没有消费者</span>
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 该消费组没有正在处理的消息</span></code></pre>
<h2 id="组内消费示例"><a href="#组内消费示例" class="headerlink" title="组内消费示例"></a>组内消费示例</h2><p>Stream 提供了 <code>xreadgroup</code> 指令可以进行消费组的组内消费，需要提供 <strong>消费组名称、消费者名称和起始消息 ID</strong>。它同 <code>xread</code> 一样，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 <strong>PEL</strong> <em>(正在处理的消息)</em> 结构里，客户端处理完毕后使用 <code>xack</code> 指令 <strong>通知服务器</strong>，本条消息已经处理完毕，该消息 ID 就会从 <strong>PEL</strong> 中移除，下面是示例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># >号表示从当前消费组的last_delivered_id后面开始读</span>
<span class="token comment" spellcheck="true"># 每当消费者读取一条消息，last_delivered_id变量就会前进</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 1 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851486781-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"30"</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 1 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851493405-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"yurui"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"29"</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 2 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851498956-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"1"</span>
      2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527852774092-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"youming"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token comment" spellcheck="true"># 再继续读取，就没有新消息了</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 1 streams codehole <span class="token operator">></span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 那就阻塞等待吧</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole <span class="token operator">></span>
<span class="token comment" spellcheck="true"># 开启另一个窗口，往里塞消息</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name lanying age 61
1527854062442-0
<span class="token comment" spellcheck="true"># 回到前一个窗口，发现阻塞解除，收到新消息了</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527854062442-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"lanying"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"61"</span>
<span class="token punctuation">(</span>36.54s<span class="token punctuation">)</span>
127.0.0.1:6379<span class="token operator">></span> xinfo <span class="token function">groups</span> codehole  <span class="token comment" spellcheck="true"># 观察消费组信息</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg1"</span>
   3<span class="token punctuation">)</span> consumers
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1  <span class="token comment" spellcheck="true"># 一个消费者</span>
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5  <span class="token comment" spellcheck="true"># 共5条正在处理的信息还有没有ack</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg2"</span>
   3<span class="token punctuation">)</span> consumers
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 消费组cg2没有任何变化，因为前面我们一直在操纵cg1</span>
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
<span class="token comment" spellcheck="true"># 如果同一个消费组有多个消费者，我们可以通过xinfo consumers指令观察每个消费者的状态</span>
127.0.0.1:6379<span class="token operator">></span> xinfo consumers codehole cg1  <span class="token comment" spellcheck="true"># 目前还有1个消费者</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"c1"</span>
   3<span class="token punctuation">)</span> pending
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5  <span class="token comment" spellcheck="true"># 共5条待处理消息</span>
   5<span class="token punctuation">)</span> idle
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 418715  <span class="token comment" spellcheck="true"># 空闲了多长时间ms没有读取消息了</span>
<span class="token comment" spellcheck="true"># 接下来我们ack一条消息</span>
127.0.0.1:6379<span class="token operator">></span> xack codehole cg1 1527851486781-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> xinfo consumers codehole cg1
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"c1"</span>
   3<span class="token punctuation">)</span> pending
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4  <span class="token comment" spellcheck="true"># 变成了5条</span>
   5<span class="token punctuation">)</span> idle
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 668504
<span class="token comment" spellcheck="true"># 下面ack所有消息</span>
127.0.0.1:6379<span class="token operator">></span> xack codehole cg1 1527851493405-0 1527851498956-0 1527852774092-0 1527854062442-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
127.0.0.1:6379<span class="token operator">></span> xinfo consumers codehole cg1
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"c1"</span>
   3<span class="token punctuation">)</span> pending
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># pel空了</span>
   5<span class="token punctuation">)</span> idle
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 745505</code></pre>
<h2 id="QA-1：Stream-消息太多怎么办？-Stream-的上限"><a href="#QA-1：Stream-消息太多怎么办？-Stream-的上限" class="headerlink" title="QA 1：Stream 消息太多怎么办？ | Stream 的上限"></a>QA 1：Stream 消息太多怎么办？ | Stream 的上限</h2><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p>
<p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> XADD mystream MAXLEN 2 * value 1
1526654998691-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 2
1526654999635-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 3
1526655000369-0
<span class="token operator">></span> XLEN mystream
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token operator">></span> XRANGE mystream - +
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526654999635-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526655000369-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p>
<p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p>
<pre class=" language-bash"><code class="language-bash">XADD mystream MAXLEN ~ 1000 * <span class="token punctuation">..</span>. entry fields here <span class="token punctuation">..</span>.</code></pre>
<p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p>
<h2 id="QA-2：PEL-是如何避免消息丢失的？"><a href="#QA-2：PEL-是如何避免消息丢失的？" class="headerlink" title="QA 2：PEL 是如何避免消息丢失的？"></a>QA 2：PEL 是如何避免消息丢失的？</h2><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p>
<h2 id="Redis-Stream-Vs-Kafka"><a href="#Redis-Stream-Vs-Kafka" class="headerlink" title="Redis Stream Vs Kafka"></a>Redis Stream Vs Kafka</h2><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p>
<p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
<li>Redis(6)——GeoHash查找附近的人<a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>订阅与发布——Redis 设计与实现 - <a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/feature/pubsub.html</a></li>
<li>《Redis 深度历险》 - 钱文品/ 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>Introduction to Redis Streams【官方文档】 - <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">https://redis.io/topics/streams-intro</a></li>
<li>Kafka vs. Redis: Log Aggregation Capabilities and Performance - <a href="https://logz.io/blog/kafka-vs-redis/" target="_blank" rel="noopener">https://logz.io/blog/kafka-vs-redis/</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">
      Redis(7)——持久化【一文了解】
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月13日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-7879862264eeea7b.png" alt=""></p>
<h1 id="一、持久化简介"><a href="#一、持久化简介" class="headerlink" title="一、持久化简介"></a>一、持久化简介</h1><p><strong>Redis</strong> 的数据 <strong>全部存储</strong> 在 <strong>内存</strong> 中，如果 <strong>突然宕机</strong>，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 <strong>持久化机制</strong>，它会将内存中的数据库状态 <strong>保存到磁盘</strong> 中。</p>
<h2 id="持久化发生了什么-从内存到磁盘"><a href="#持久化发生了什么-从内存到磁盘" class="headerlink" title="持久化发生了什么 | 从内存到磁盘"></a>持久化发生了什么 | 从内存到磁盘</h2><p>我们来稍微考虑一下 <strong>Redis</strong> 作为一个 <strong>“内存数据库”</strong> 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-5c209bc08da11abb.png" alt=""></p>
<p><strong>详细版</strong> 的文字描述大概就是下面这样：</p>
<ol>
<li>客户端向数据库 <strong>发送写命令</strong> <em>(数据在客户端的内存中)</em></li>
<li>数据库 <strong>接收</strong> 到客户端的 <strong>写请求</strong> <em>(数据在服务器的内存中)</em></li>
<li>数据库 <strong>调用系统 API</strong> 将数据写入磁盘 <em>(数据在内核缓冲区中)</em></li>
<li>操作系统将 <strong>写缓冲区</strong> 传输到 <strong>磁盘控控制器</strong> <em>(数据在磁盘缓存中)</em></li>
<li>操作系统的磁盘控制器将数据 <strong>写入实际的物理媒介</strong> 中 <em>(数据在磁盘中)</em></li>
</ol>
<p><strong>注意:</strong> 上面的过程其实是 <strong>极度精简</strong> 的，在实际的操作系统中，<strong>缓存</strong> 和 <strong>缓冲区</strong> 会比这 <strong>多得多</strong>…</p>
<h2 id="如何尽可能保证持久化的安全"><a href="#如何尽可能保证持久化的安全" class="headerlink" title="如何尽可能保证持久化的安全"></a>如何尽可能保证持久化的安全</h2><p>如果我们故障仅仅涉及到 <strong>软件层面</strong> <em>(该进程被管理员终止或程序崩溃)</em> 并且没有接触到内核，那么在 <em>上述步骤 3</em> 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。</p>
<p>如果我们考虑 <strong>停电/ 火灾</strong> 等 <strong>更具灾难性</strong> 的事情，那么只有在完成了第 <strong>5</strong> 步之后，才是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-de083f477fe1bce4.png" alt="机房”火了“"></p>
<p>所以我们可以总结得出数据安全最重要的阶段是：<strong>步骤三、四、五</strong>，即：</p>
<ul>
<li>数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？</li>
<li>内核多久从缓冲区取数据刷新到磁盘控制器？</li>
<li>磁盘控制器多久把数据写入物理媒介一次？</li>
<li><strong>注意：</strong> 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 <strong>尽可能地保证</strong> 数据的安全，这对于所有数据库来说都是一样的。</li>
</ul>
<p>我们从 <strong>第三步</strong> 开始。Linux 系统提供了清晰、易用的用于操作文件的 <code>POSIX file API</code>，<code>20</code> 多年过去，仍然还有很多人对于这一套 <code>API</code> 的设计津津乐道，我想其中一个原因就是因为你光从 <code>API</code> 的命名就能够很清晰地知道这一套 API 的用途：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">/*,mode_t mode */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">close</span> <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fname <span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>参考自：API 设计最佳实践的思考 - <a href="https://www.cnblogs.com/yuanjiangw/p/10846560.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanjiangw/p/10846560.html</a></li>
</ul>
<p>所以，我们有很好的可用的 <code>API</code> 来完成 <strong>第三步</strong>，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。</p>
<p>然后我们来说说 <strong>第四步</strong>。我们知道，除了早期对电脑特别了解那帮人 <em>(操作系统就这帮人搞的)</em>，实际的物理硬件都不是我们能够 <strong>直接操作</strong> 的，都是通过 <strong>操作系统调用</strong> 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 <strong>上述第四步</strong> 提到的 <strong>写缓冲区</strong>，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 <strong>30 秒</strong> 后实际提交写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-c08b7572ef02d67b.jpg" alt="image"></p>
<p>但是很明显，<strong>30 秒</strong> 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 <code>PROSIX API</code> 提供了另一个解决方案：<code>fsync</code>，该命令会 <strong>强制</strong> 内核将 <strong>缓冲区</strong> 写入 <strong>磁盘</strong>，但这是一个非常消耗性能的操作，每次调用都会 <strong>阻塞等待</strong> 直到设备报告 IO 完成，所以一般在生产环境的服务器中，<strong>Redis</strong> 通常是每隔 1s 左右执行一次 <code>fsync</code> 操作。</p>
<p>到目前为止，我们了解到了如何控制 <code>第三步</code> 和 <code>第四步</code>，但是对于 <strong>第五步</strong>，我们 <strong>完全无法控制</strong>。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。</p>
<h1 id="二、Redis-中的两种持久化方式"><a href="#二、Redis-中的两种持久化方式" class="headerlink" title="二、Redis 中的两种持久化方式"></a>二、Redis 中的两种持久化方式</h1><h2 id="方式一：快照"><a href="#方式一：快照" class="headerlink" title="方式一：快照"></a>方式一：快照</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-9a4d234c53120b33.gif" alt="image"></p>
<p><strong>Redis 快照</strong> 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有 <em>100</em> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>
<p>但我们知道，Redis 是一个 <strong>单线程</strong> 的程序，这意味着，我们不仅仅要响应用户的请求，还需要进行内存快照。而后者要求 Redis 必须进行 IO 操作，这会严重拖累服务器的性能。</p>
<p>还有一个重要的问题是，我们在 <strong>持久化的同时</strong>，<strong>内存数据结构</strong> 还可能在 <strong>变化</strong>，比如一个大型的 hash 字典正在持久化，结果一个请求过来把它删除了，可是这才刚持久化结束，咋办？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-fbfcbd606e95f105.jpg" alt=""></p>
<h3 id="使用系统多进程-COW-Copy-On-Write-机制-fork-函数"><a href="#使用系统多进程-COW-Copy-On-Write-机制-fork-函数" class="headerlink" title="使用系统多进程 COW(Copy On Write) 机制 | fork 函数"></a>使用系统多进程 COW(Copy On Write) 机制 | fork 函数</h3><p>操作系统多进程 <strong>COW(Copy On Write) 机制</strong> 拯救了我们。<strong>Redis</strong> 在持久化时会调用 <code>glibc</code> 的函数 <code>fork</code> 产生一个子进程，简单理解也就是基于当前进程 <strong>复制</strong> 了一个进程，主进程和子进程会共享内存里面的代码块和数据段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-bc264b6a9f0c3404.png" alt=""></p>
<p>这里多说一点，<strong>为什么 fork 成功调用后会有两个返回值呢？</strong> 因为子进程在复制时复制了父进程的堆栈段，所以两个进程都停留在了 <code>fork</code> 函数中 <em>(都在同一个地方往下继续”同时”执行)<em>，等待返回，所以 *</em>一次在父进程中返回子进程的 pid，另一次在子进程中返回零，系统资源不够时返回负数**。 *(伪代码如下)</em></p>
<pre class=" language-python"><code class="language-python">pid <span class="token operator">=</span> os<span class="token punctuation">.</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
  handle_client_request<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 父进程继续处理客户端请求</span>
<span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
  handle_snapshot_write<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 子进程处理快照写磁盘</span>
<span class="token keyword">if</span> pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>  
  <span class="token comment" spellcheck="true"># fork error</span></code></pre>
<p>所以 <strong>快照持久化</strong> 可以完全交给 <strong>子进程</strong> 来处理，<strong>父进程</strong> 则继续 <strong>处理客户端请求</strong>。<strong>子进程</strong> 做数据持久化，它 <strong>不会修改现有的内存数据结构</strong>，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是 <strong>父进程</strong> 不一样，它必须持续服务客户端请求，然后对 <strong>内存数据结构进行不间断的修改</strong>。</p>
<p>这个时候就会使用操作系统的 COW 机制来进行 <strong>数据段页面</strong> 的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复<br>制一份分离出来，然后 <strong>对这个复制的页面进行修改</strong>。这时 <strong>子进程</strong> 相应的页面是 <strong>没有变化的</strong>，还是进程产生时那一瞬间的数据。</p>
<p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么 <strong>Redis</strong> 的持久化 <strong>叫「快照」的原因</strong>。接下来子进程就可以非常安心的遍历数据了进行序列化写磁盘了。</p>
<h2 id="方式二：AOF"><a href="#方式二：AOF" class="headerlink" title="方式二：AOF"></a>方式二：AOF</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-e4e08ebef2cf0144.gif" alt=""></p>
<p><strong>快照不是很持久</strong>。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 <code>kill -9</code> 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。</p>
<p><strong>AOF(Append Only File - 仅追加文件)</strong> 它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>
<p>为了展示 AOF 在实际中的工作方式，我们来做一个简单的实验：</p>
<pre class=" language-bash"><code class="language-bash">./redis-server --appendonly <span class="token function">yes</span>  <span class="token comment" spellcheck="true"># 设置一个新实例为 AOF 模式</span></code></pre>
<p>然后我们执行一些写操作：</p>
<pre class=" language-bash"><code class="language-bash">redis 127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> key1 Hello
OK
redis 127.0.0.1:6379<span class="token operator">></span> append key1 <span class="token string">" World!"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 12
redis 127.0.0.1:6379<span class="token operator">></span> del key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
redis 127.0.0.1:6379<span class="token operator">></span> del non_existing_key
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>前三个操作实际上修改了数据集，第四个操作没有修改，因为没有指定名称的键。这是 AOF 日志保存的文本：</p>
<pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> appendonly.aof 
*2
<span class="token variable">$6</span>
SELECT
<span class="token variable">$1</span>
0
*3
<span class="token variable">$3</span>
<span class="token keyword">set</span>
<span class="token variable">$4</span>
key1
<span class="token variable">$5</span>
Hello
*3
<span class="token variable">$6</span>
append
<span class="token variable">$4</span>
key1
<span class="token variable">$7</span>
 World<span class="token operator">!</span>
*2
<span class="token variable">$3</span>
del
<span class="token variable">$4</span>
key1</code></pre>
<p>如您所见，最后的那一条 <code>DEL</code> 指令不见了，因为它没有对数据集进行任何修改。</p>
<p>就是这么简单。当 Redis 收到客户端修改指令后，会先进行参数校验、逻辑处理，如果没问题，就 <strong>立即</strong> 将该指令文本 <strong>存储</strong> 到 AOF 日志中，也就是说，<strong>先执行指令再将日志存盘</strong>。这一点不同于 <code>MySQL</code>、<code>LevelDB</code>、<code>HBase</code> 等存储引擎，如果我们先存储日志再做逻辑处理，这样就可以保证即使宕机了，我们仍然可以通过之前保存的日志恢复到之前的数据状态，但是 <strong>Redis 为什么没有这么做呢？</strong></p>
<blockquote>
<p>Emmm… 没找到特别满意的答案，引用一条来自知乎上的回答吧：</p>
<ul>
<li><strong>@缘于专注</strong> - 我甚至觉得没有什么特别的原因。仅仅是因为，由于AOF文件会比较大，为了避免写入无效指令（错误指令），必须先做指令检查？如何检查，只能先执行了。因为语法级别检查并不能保证指令的有效性，比如删除一个不存在的key。而MySQL这种是因为它本身就维护了所有的表的信息，所以可以语法检查后过滤掉大部分无效指令直接记录日志，然后再执行。</li>
<li>更多讨论参见：<a href="https://www.zhihu.com/question/342427472" target="_blank" rel="noopener">为什么Redis先执行指令，再记录AOF日志，而不是像其它存储引擎一样反过来呢？ - https://www.zhihu.com/question/342427472</a></li>
</ul>
</blockquote>
<h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-c21e2a37892ee989.jpg" alt=""></p>
<p><strong>Redis</strong> 在长期运行的过程中，AOF 的日志会越变越长。如果实例宕机重启，重放整个 AOF 日志会非常耗时，导致长时间 Redis 无法对外提供服务。所以需要对 <strong>AOF 日志 “瘦身”</strong>。</p>
<p><strong>Redis</strong> 提供了 <code>bgrewriteaof</code> 指令用于对 AOF 日志进行瘦身。其 <strong>原理</strong> 就是 <strong>开辟一个子进程</strong> 对内存进行 <strong>遍历</strong> 转换成一系列 Redis 的操作指令，<strong>序列化到一个新的 AOF 日志文件</strong> 中。序列化完毕后再将操作期间发生的 <strong>增量 AOF 日志</strong> 追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。</p>
<h3 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-384a546b5bf6b86d.gif" alt=""></p>
<p>AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘的。</p>
<p>就像我们 <em>上方第四步</em> 描述的那样，我们需要借助 <code>glibc</code> 提供的 <code>fsync(int fd)</code> 函数来讲指定的文件内容 <strong>强制从内核缓存刷到磁盘</strong>。但 <strong>“强制开车”</strong> 仍然是一个很消耗资源的一个过程，需要 <strong>“节制”</strong>！通常来说，生产环境的服务器，Redis 每隔 1s 左右执行一次 <code>fsync</code> 操作就可以了。</p>
<p>Redis 同样也提供了另外两种策略，一个是 <strong>永不 <code>fsync</code></strong>，来让操作系统来决定合适同步磁盘，很不安全，另一个是 <strong>来一个指令就 <code>fsync</code> 一次</strong>，非常慢。但是在生产环境基本不会使用，了解一下即可。</p>
<h2 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-7de9f7706be6216c.gif" alt=""></p>
<p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-2f7887f84eaa34d9.png" alt=""></p>
<p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
<li>Redis(6)——GeoHash查找附近的人<a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
</ol>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li>Redis 数据备份与恢复 | 菜鸟教程 - <a href="https://www.runoob.com/redis/redis-backup.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-backup.html</a></li>
<li>Java Fork/Join 框架 - <a href="https://www.cnblogs.com/cjsblog/p/9078341.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjsblog/p/9078341.html</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Redis persistence demystified | antirez weblog (作者博客) - <a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a></li>
<li>操作系统 — fork()函数的使用与底层原理 - <a href="https://blog.csdn.net/Dawn_sf/article/details/78709839" target="_blank" rel="noopener">https://blog.csdn.net/Dawn_sf/article/details/78709839</a></li>
<li>磁盘和内存读写简单原理 - <a href="https://blog.csdn.net/zhanghongzheng3213/article/details/54141202" target="_blank" rel="noopener">https://blog.csdn.net/zhanghongzheng3213/article/details/54141202</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E3%80%90%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E3%80%91/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">
      Redis(6)——GeoHash查找附近的人
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月12日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94GeoHash%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA/7896890-8ccb98beab9aff6a.png" alt=""></p>
<p>像微信 <strong>“附近的人”</strong>，美团 <strong>“附近的餐厅”</strong>，支付宝共享单车 <strong>“附近的车”</strong> 是怎么设计实现的呢？</p>
<h1 id="一、使用数据库实现查找附近的人"><a href="#一、使用数据库实现查找附近的人" class="headerlink" title="一、使用数据库实现查找附近的人"></a>一、使用数据库实现查找附近的人</h1><p>我们都知道，地球上的任何一个位置都可以使用二维的 <strong>经纬度</strong> 来表示，经度范围 <em>[-180, 180]<em>，纬度范围 *[-90, 90]</em>，纬度正负以赤道为界，北正南负，经度正负以本初子午线 *(英国格林尼治天文台)</em> 为界，东正西负。比如说，北京人民英雄纪念碑的经纬度坐标就是 <em>(39.904610, 116.397724)</em>，都是正数，因为中国位于东北半球。</p>
<p>所以，当我们使用数据库存储了所有人的 <strong>经纬度</strong> 信息之后，我们就可以基于当前的坐标节点，来划分出一个矩形的范围，来得知附近的人，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94GeoHash%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA/7896890-c5e82d3cab59ad22.png" alt=""></p>
<p>所以，我们很容易写出下列的伪 SQL 语句：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> positions <span class="token keyword">WHERE</span> x0 <span class="token operator">-</span> r <span class="token operator">&lt;</span> x <span class="token operator">&lt;</span> x0 <span class="token operator">+</span> r <span class="token operator">AND</span> y0 <span class="token operator">-</span> r <span class="token operator">&lt;</span> y <span class="token operator">&lt;</span> y0 <span class="token operator">+</span> r</code></pre>
<p>如果我们还想进一步地知道与每个坐标元素的距离并排序的话，就需要一定的计算。</p>
<p>当两个坐标元素的距离不是很远的时候，我们就可以简单利用 <strong>勾股定理</strong> 就能够得出他们之间的 <strong>距离</strong>。不过需要注意的是，地球不是一个标准的球体，<strong>经纬度的密度</strong> 是 <strong>不一样</strong> 的，所以我们使用勾股定理计算平方之后再求和时，需要按照一定的系数 <strong>加权</strong> 再进行求和。当然，如果不准求精确的话，加权也不必了。</p>
<p>参考下方 <em>参考资料 2</em> 我们能够差不多能写出如下优化之后的 SQL 语句来：<em>(仅供参考)</em></p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>
    <span class="token operator">*</span> 
<span class="token keyword">FROM</span>
    users_location 
<span class="token keyword">WHERE</span>
    latitude <span class="token operator">></span> <span class="token string">'.$lat.'</span> <span class="token operator">-</span> <span class="token number">1</span> 
    <span class="token operator">AND</span> latitude <span class="token operator">&lt;</span> <span class="token string">'.$lat.'</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">AND</span> longitude <span class="token operator">></span> <span class="token string">'.$lon.'</span> <span class="token operator">-</span> <span class="token number">1</span> 
    <span class="token operator">AND</span> longitude <span class="token operator">&lt;</span> <span class="token string">'.$lon.'</span> <span class="token operator">+</span> <span class="token number">1</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    ACOS<span class="token punctuation">(</span>
        SIN<span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token string">'.$lat.'</span> <span class="token operator">*</span> <span class="token number">3.1415</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token punctuation">)</span> <span class="token operator">*</span> SIN<span class="token punctuation">(</span> <span class="token punctuation">(</span> latitude <span class="token operator">*</span> <span class="token number">3.1415</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token punctuation">)</span> <span class="token operator">+</span> COS<span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token string">'.$lat.'</span> <span class="token operator">*</span> <span class="token number">3.1415</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token punctuation">)</span> <span class="token operator">*</span> COS<span class="token punctuation">(</span> <span class="token punctuation">(</span> latitude <span class="token operator">*</span> <span class="token number">3.1415</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token punctuation">)</span> <span class="token operator">*</span> COS<span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token string">'.$lon.'</span> <span class="token operator">*</span> <span class="token number">3.1415</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token operator">-</span> <span class="token punctuation">(</span> longitude <span class="token operator">*</span> <span class="token number">3.1415</span> <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">180</span> <span class="token punctuation">)</span> 
    <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6380</span> <span class="token keyword">ASC</span> 
    <span class="token keyword">LIMIT</span> <span class="token number">10</span> '<span class="token punctuation">;</span></code></pre>
<p>为了满足高性能的矩形区域算法，数据表也需要把经纬度坐标加上 <strong>双向复合索引 (x, y)</strong>，这样可以满足最大优化查询性能。</p>
<h1 id="二、GeoHash-算法简述"><a href="#二、GeoHash-算法简述" class="headerlink" title="二、GeoHash 算法简述"></a>二、GeoHash 算法简述</h1><p>这是业界比较通用的，用于 <strong>地理位置距离排序</strong> 的一个算法，<strong>Redis</strong> 也采用了这样的算法。GeoHash 算法将 <strong>二维的经纬度</strong> 数据映射到 <strong>一维</strong> 的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。当我们想要计算 <strong>「附近的人时」</strong>，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行了。</p>
<p>它的核心思想就是把整个地球看成是一个 <strong>二维的平面</strong>，然后把这个平面不断地等分成一个一个小的方格，<strong>每一个</strong> 坐标元素都位于其中的 <strong>唯一一个方格</strong> 中，等分之后的 <strong>方格越小</strong>，那么坐标也就 <strong>越精确</strong>，类似下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94GeoHash%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA/7896890-6396ae153a485857.png" alt=""></p>
<p>经过划分的地球，我们需要对其进行编码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94GeoHash%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA/7896890-573525c3f1179bbc.png" alt=""></p>
<p>经过这样顺序的编码之后，如果你仔细观察一会儿，你就会发现一些规律：</p>
<ul>
<li>横着的所有编码中，<strong>第 2 位和第 4 位都是一样的</strong>，例如第一排第一个 <code>0101</code> 和第二个 <code>0111</code>，他们的第 2 位和第 4 位都是 <code>1</code>；</li>
<li>竖着的所有编码中，<strong>第 1 位和第 3 位是递增的</strong>，例如第一排第一个 <code>0101</code>，如果单独把第 1 位和第 3 位拎出来的话，那就是 <code>00</code>，同理看第一排第二个 <code>0111</code>，同样的方法第 1 位和第 3 位拎出来是 <code>01</code>，刚好是 <code>00</code> 递增一个；</li>
</ul>
<p>通过这样的规律我们就把每一个小方块儿进行了一定顺序的编码，这样做的 <strong>好处</strong> 是显而易见的：每一个元素坐标既能够被 <strong>唯一标识</strong> 在这张被编码的地图上，也不至于 <strong>暴露特别的具体的位置</strong>，因为区域是共享的，我可以告诉你我就在公园附近，但是在具体的哪个地方你就无从得知了。</p>
<p>总之，我们通过上面的思想，能够把任意坐标变成一串二进制的编码了，类似于 <code>11010010110001000100</code> 这样 <em>(注意经度和维度是交替出现的哦..)</em>，通过这个整数我们就可以还原出元素的坐标，整数越长，还原出来的坐标值的损失程序就越小。对于 <strong>“附近的人”</strong> 这个功能来说，损失的一点经度可以忽略不计。</p>
<p>最后就是一个 <code>Base32</code> <em>(0<del>9, a</del>z, 去掉 a/i/l/o 四个字母)</em> 的编码操作，让它变成一个字符串，例如上面那一串儿就变成了 <code>wx4g0ec1</code>。</p>
<p>在 <strong>Redis</strong> 中，经纬度使用 <code>52</code> 位的整数进行编码，放进了 zset 里面，zset 的 <code>value</code> 是元素的 <code>key</code>，<code>score</code> 是 <strong>GeoHash</strong> 的 <code>52</code> 位整数值。zset 的 <code>score</code> 虽然是浮点数，但是对于 <code>52</code> 位的整数值来说，它可以无损存储。</p>
<h1 id="三、在-Redis-中使用-Geo"><a href="#三、在-Redis-中使用-Geo" class="headerlink" title="三、在 Redis 中使用 Geo"></a>三、在 Redis 中使用 Geo</h1><blockquote>
<p>下方内容引自 <em>参考资料 1 - 《Redis 深度历险》</em></p>
</blockquote>
<p>在使用 <strong>Redis</strong> 进行 <strong>Geo 查询</strong> 时，我们要时刻想到它的内部结构实际上只是一个 <strong>zset(skiplist)</strong>。通过 zset 的 <code>score</code> 排序就可以得到坐标附近的其他元素 <em>(实际情况要复杂一些，不过这样理解足够了)</em>，通过将 <code>score</code> 还原成坐标值就可以得到元素的原始坐标了。</p>
<p>Redis 提供的 Geo 指令只有 6 个，很容易就可以掌握。</p>
<h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p><code>geoadd</code> 指令携带集合名称以及多个经纬度名称三元组，注意这里可以加入多个三元组。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> geoadd company 116.48105 39.996794 juejin
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> geoadd company 116.514203 39.905409 ireader
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> geoadd company 116.489033 40.007669 meituan
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2</code></pre>
<p>不过很奇怪.. Redis 没有直接提供 Geo 的删除指令，但是我们可以通过 zset 相关的指令来操作 Geo 数据，所以元素删除可以使用 <code>zrem</code> 指令即可。</p>
<h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p><code>geodist</code> 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> geodist company juejin ireader km
<span class="token string">"10.5501"</span>
127.0.0.1:6379<span class="token operator">></span> geodist company juejin meituan km
<span class="token string">"1.3878"</span>
127.0.0.1:6379<span class="token operator">></span> geodist company juejin jd km
<span class="token string">"24.2739"</span>
127.0.0.1:6379<span class="token operator">></span> geodist company juejin xiaomi km
<span class="token string">"12.9606"</span>
127.0.0.1:6379<span class="token operator">></span> geodist company juejin juejin km
<span class="token string">"0.0000"</span></code></pre>
<p>我们可以看到掘金离美团最近，因为它们都在望京。距离单位可以是 <code>m</code>、<code>km</code>、<code>ml</code>、<code>ft</code>，分别代表米、千米、英里和尺。</p>
<h2 id="获取元素位置"><a href="#获取元素位置" class="headerlink" title="获取元素位置"></a>获取元素位置</h2><p><code>geopos</code> 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> geopos company juejin
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.48104995489120483"</span>
 2<span class="token punctuation">)</span> <span class="token string">"39.99679348858259686"</span>
127.0.0.1:6379<span class="token operator">></span> geopos company ireader
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.5142020583152771"</span>
 2<span class="token punctuation">)</span> <span class="token string">"39.90540918662494363"</span>
127.0.0.1:6379<span class="token operator">></span> geopos company juejin ireader
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.48104995489120483"</span>
 2<span class="token punctuation">)</span> <span class="token string">"39.99679348858259686"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.5142020583152771"</span>
 2<span class="token punctuation">)</span> <span class="token string">"39.90540918662494363"</span></code></pre>
<p>我们观察到获取的经纬度坐标和 <code>geoadd</code> 进去的坐标有轻微的误差，原因是 <strong>Geohash</strong> 对二维坐标进行的一维映射是有损的，通过映射再还原回来的值会出现较小的差别。对于 <strong>「附近的人」</strong> 这种功能来说，这点误差根本不是事。</p>
<h2 id="获取元素的-hash-值"><a href="#获取元素的-hash-值" class="headerlink" title="获取元素的 hash 值"></a>获取元素的 hash 值</h2><p><code>geohash</code> 可以获取元素的经纬度编码字符串，上面已经提到，它是 <code>base32</code> 编码。 你可以使用这个编码值去 <code>http://geohash.org/${hash}</code> 中进行直接定位，它是 <strong>Geohash</strong> 的标准编码值。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> geohash company ireader
1<span class="token punctuation">)</span> <span class="token string">"wx4g52e1ce0"</span>
127.0.0.1:6379<span class="token operator">></span> geohash company juejin
1<span class="token punctuation">)</span> <span class="token string">"wx4gd94yjn0"</span></code></pre>
<p>让我们打开地址 <code>http://geohash.org/wx4g52e1ce0</code>，观察地图指向的位置是否正确：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94GeoHash%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA/7896890-b5d4215d6397729c.png" alt=""></p>
<p>很好，就是这个位置，非常准确。</p>
<h2 id="附近的公司"><a href="#附近的公司" class="headerlink" title="附近的公司"></a>附近的公司</h2><p><code>georadiusbymember</code> 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素，它的参数非常复杂。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</span>
127.0.0.1:6379<span class="token operator">></span> georadiusbymember company ireader 20 km count 3 asc
1<span class="token punctuation">)</span> <span class="token string">"ireader"</span>
2<span class="token punctuation">)</span> <span class="token string">"juejin"</span>
3<span class="token punctuation">)</span> <span class="token string">"meituan"</span>
<span class="token comment" spellcheck="true"># 范围 20 公里以内最多 3 个元素按距离倒排</span>
127.0.0.1:6379<span class="token operator">></span> georadiusbymember company ireader 20 km count 3 desc
1<span class="token punctuation">)</span> <span class="token string">"jd"</span>
2<span class="token punctuation">)</span> <span class="token string">"meituan"</span>
3<span class="token punctuation">)</span> <span class="token string">"juejin"</span>
<span class="token comment" spellcheck="true"># 三个可选参数 withcoord withdist withhash 用来携带附加参数</span>
<span class="token comment" spellcheck="true"># withdist 很有用，它可以用来显示距离</span>
127.0.0.1:6379<span class="token operator">></span> georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"ireader"</span>
 2<span class="token punctuation">)</span> <span class="token string">"0.0000"</span>
 3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4069886008361398
 4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.5142020583152771"</span>
 2<span class="token punctuation">)</span> <span class="token string">"39.90540918662494363"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"juejin"</span>
 2<span class="token punctuation">)</span> <span class="token string">"10.5501"</span>
 3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4069887154388167
 4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.48104995489120483"</span>
 2<span class="token punctuation">)</span> <span class="token string">"39.99679348858259686"</span>
3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"meituan"</span>
 2<span class="token punctuation">)</span> <span class="token string">"11.5748"</span>
 3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4069887179083478
 4<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"116.48903220891952515"</span>
 2<span class="token punctuation">)</span> <span class="token string">"40.00766997707732031"</span></code></pre>
<p>除了 <code>georadiusbymember</code> 指令根据元素查询附近的元素，<strong>Redis</strong> 还提供了根据坐标值来查询附近的元素，这个指令更加有用，它可以根据用户的定位来计算「附近的车」，「附近的餐馆」等。它的参数和 <code>georadiusbymember</code> 基本一致，除了将目标元素改成经纬度坐标值：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> georadius company 116.514202 39.905409 20 km withdist count 3 asc
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"ireader"</span>
 2<span class="token punctuation">)</span> <span class="token string">"0.0000"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"juejin"</span>
 2<span class="token punctuation">)</span> <span class="token string">"10.5501"</span>
3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"meituan"</span>
 2<span class="token punctuation">)</span> <span class="token string">"11.5748"</span></code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条，如果使用 <strong>Redis</strong> 的 <strong>Geo</strong> 数据结构，它们将 <strong>全部放在一个</strong> zset 集合中。在 <strong>Redis</strong> 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响，在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。</p>
<p>所以，这里建议 <strong>Geo</strong> 的数据使用 <strong>单独的 Redis 实例部署</strong>，不使用集群环境。</p>
<p>如果数据量过亿甚至更大，就需要对 <strong>Geo</strong> 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。这样就可以显著降低单个 zset 集合的大小。</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 深度历险》 - 钱文品/ 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>mysql经纬度查询并且计算2KM范围内附近用户的sql查询性能优化实例教程 - <a href="https://www.cnblogs.com/mgbert/p/4146538.html" target="_blank" rel="noopener">https://www.cnblogs.com/mgbert/p/4146538.html</a></li>
<li>Geohash算法原理及实现 - <a href="https://www.jianshu.com/p/2fd0cf12e5ba" target="_blank" rel="noopener">https://www.jianshu.com/p/2fd0cf12e5ba</a></li>
<li>GeoHash算法学习讲解、解析及原理分析 - <a href="https://zhuanlan.zhihu.com/p/35940647" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35940647</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94GeoHash%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">
      Redis(5)——亿级数据过滤和布隆过滤器
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月11日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-59d043fad3a66d7f.png" alt=""></p>
<h1 id="一、布隆过滤器简介"><a href="#一、布隆过滤器简介" class="headerlink" title="一、布隆过滤器简介"></a>一、布隆过滤器简介</h1><p><a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">上一次</a> 我们学会了使用 <strong>HyperLogLog</strong> 来对大数据进行一个估算，它非常有价值，可以解决很多精确度不高的统计需求。但是如果我们想知道某一个值是不是已经在 <strong>HyperLogLog</strong> 结构里面了，它就无能为力了，它只提供了 <code>pfadd</code> 和 <code>pfcount</code> 方法，没有提供类似于 <code>contains</code> 的这种方法。</p>
<p>就举一个场景吧，比如你 <strong>刷抖音</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-c7b6b5c8a47caf4a.png" alt=""></p>
<p>你有 <strong>刷到过重复的推荐内容</strong> 吗？这么多的推荐内容要推荐给这么多的用户，它是怎么保证每个用户在看推荐内容时，保证不会出现之前已经看过的推荐视频呢？也就是说，抖音是如何实现 <strong>推送去重</strong> 的呢？</p>
<p>你会想到服务器 <strong>记录</strong> 了用户看过的 <strong>所有历史记录</strong>，当推荐系统推荐短视频时会从每个用户的历史记录里进行 <strong>筛选</strong>，过滤掉那些已经存在的记录。问题是当 <strong>用户量很大</strong>，每个用户看过的短视频又很多的情况下，这种方式，推荐系统的去重工作 <strong>在性能上跟的上么？</strong></p>
<p>实际上，如果历史记录存储在关系数据库里，去重就需要频繁地对数据库进行 <code>exists</code> 查询，当系统并发量很高时，数据库是很难抗住压力的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-099f3600b7022ef6.jpg" alt="image"></p>
<p>你可能又想到了 <strong>缓存</strong>，但是这么多用户这么多的历史记录，如果全部缓存起来，那得需要 <strong>浪费多大的空间</strong> 啊.. <em>(可能老板看一眼账单，看一眼你..)</em> 并且这个存储空间会随着时间呈线性增长，就算你用缓存撑得住一个月，但是又能继续撑多久呢？不缓存性能又跟不上，咋办呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-204e7440395a31b5.png" alt=""></p>
<p>如上图所示，<strong>布隆过滤器(Bloom Filter)</strong> 就是这样一种专门用来解决去重问题的高级数据结构。但是跟 <strong>HyperLogLog</strong> 一样，它也一样有那么一点点不精确，也存在一定的误判概率，但它能在解决去重的同时，在 <strong>空间上能节省 90%</strong> 以上，也是非常值得的。</p>
<h2 id="布隆过滤器是什么"><a href="#布隆过滤器是什么" class="headerlink" title="布隆过滤器是什么"></a>布隆过滤器是什么</h2><p><strong>布隆过滤器（Bloom Filter）</strong> 是 1970 年由布隆提出的。它 <strong>实际上</strong> 是一个很长的二进制向量和一系列随机映射函数 <em>(下面详细说)</em>，实际上你也可以把它 <strong>简单理解</strong> 为一个不怎么精确的 <strong>set</strong> 结构，当你使用它的 <code>contains</code> 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p>
<p>当布隆过滤器说某个值存在时，这个值 <strong>可能不存在</strong>；当它说不存在时，那么 <strong>一定不存在</strong>。打个比方，当它说不认识你时，那就是真的不认识，但是当它说认识你的时候，可能是因为你长得像它认识的另外一个朋友 <em>(脸长得有些相似)</em>，所以误判认识你。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-757891d52045869d.jpg" alt="image"></p>
<h2 id="布隆过滤器的使用场景"><a href="#布隆过滤器的使用场景" class="headerlink" title="布隆过滤器的使用场景"></a>布隆过滤器的使用场景</h2><p>基于上述的功能，我们大致可以把布隆过滤器用于以下的场景之中：</p>
<ul>
<li><strong>大数据判断是否存在</strong>：这就可以实现出上述的去重功能，如果你的服务器内存足够大的话，那么使用 HashMap 可能是一个不错的解决方案，理论上时间复杂度可以达到 O(1 的级别，但是当数据量起来之后，还是只能考虑布隆过滤器。</li>
<li><strong>解决缓存穿透</strong>：我们经常会把一些热点数据放在 Redis 中当作缓存，例如产品详情。 通常一个请求过来之后我们会先查询缓存，而不用直接读取数据库，这是提升性能最简单也是最普遍的做法，但是 <strong>如果一直请求一个不存在的缓存</strong>，那么此时一定不存在缓存，那就会有 <strong>大量请求直接打到数据库</strong> 上，造成 <strong>缓存穿透</strong>，布隆过滤器也可以用来解决此类问题。</li>
<li><strong>爬虫/ 邮箱等系统的过滤</strong>：平时不知道你有没有注意到有一些正常的邮件也会被放进垃圾邮件目录中，这就是使用布隆过滤器 <strong>误判</strong> 导致的。</li>
</ul>
<h1 id="二、布隆过滤器原理解析"><a href="#二、布隆过滤器原理解析" class="headerlink" title="二、布隆过滤器原理解析"></a>二、布隆过滤器原理解析</h1><p>布隆过滤器 <strong>本质上</strong> 是由长度为 <code>m</code> 的位向量或位列表（仅包含 <code>0</code> 或 <code>1</code> 位值的列表）组成，最初所有的值均设置为 <code>0</code>，所以我们先来创建一个稍微长一些的位向量用作展示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-362a693c82af3c8e.png" alt=""></p>
<p>当我们向布隆过滤器中添加数据时，会使用 <strong>多个</strong> <code>hash</code> 函数对 <code>key</code> 进行运算，算得一个证书索引值，然后对位数组长度进行取模运算得到一个位置，每个 <code>hash</code> 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 <code>1</code> 就完成了 <code>add</code> 操作，例如，我们添加一个 <code>wmyskxz</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-fdbf75a56fb03c02.png" alt=""></p>
<p>向布隆过滤器查查询 <code>key</code> 是否存在时，跟 <code>add</code> 操作一样，会把这个 <code>key</code> 通过相同的多个 <code>hash</code> 函数进行运算，查看 <strong>对应的位置</strong> 是否 <strong>都</strong> 为 <code>1</code>，<strong>只要有一个位为 <code>0</code></strong>，那么说明布隆过滤器中这个 <code>key</code> 不存在。如果这几个位置都是 <code>1</code>，并不能说明这个 <code>key</code> 一定存在，只能说极有可能存在，因为这些位置的 <code>1</code> 可能是因为其他的 <code>key</code> 存在导致的。</p>
<p>就比如我们在 <code>add</code> 了一定的数据之后，查询一个 <strong>不存在</strong> 的 <code>key</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-0beb6acc89d5c927.png" alt=""></p>
<p>很明显，<code>1/3/5</code> 这几个位置的 <code>1</code> 是因为上面第一次添加的 <code>wmyskxz</code> 而导致的，所以这里就存在 <strong>误判</strong>。幸运的是，布隆过滤器有一个可以预判误判率的公式，比较复杂，感兴趣的朋友可以自行去阅读，比较烧脑.. 只需要记住以下几点就好了：</p>
<ul>
<li>使用时 <strong>不要让实际元素数量远大于初始化数量</strong>；</li>
<li>当实际元素数量超过初始化数量时，应该对布隆过滤器进行 <strong>重建</strong>，重新分配一个 <code>size</code> 更大的过滤器，再将所有的历史元素批量 <code>add</code> 进行；</li>
</ul>
<h1 id="三、布隆过滤器的使用"><a href="#三、布隆过滤器的使用" class="headerlink" title="三、布隆过滤器的使用"></a>三、布隆过滤器的使用</h1><p><strong>Redis 官方</strong> 提供的布隆过滤器到了 <strong>Redis 4.0</strong> 提供了插件功能之后才正式登场。布隆过滤器作为一个插件加载到 Redis Server 中，给 Redis 提供了强大的布隆去重功能。下面我们来体验一下 Redis 4.0 的布隆过滤器，为了省去繁琐安装过程，我们直接用<br>Docker 吧。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> docker pull redislabs/rebloom <span class="token comment" spellcheck="true"># 拉取镜像</span>
<span class="token operator">></span> docker run -p6379:6379 redislabs/rebloom <span class="token comment" spellcheck="true"># 运行容器</span>
<span class="token operator">></span> redis-cli <span class="token comment" spellcheck="true"># 连接容器中的 redis 服务</span></code></pre>
<p>如果上面三条指令执行没有问题，下面就可以体验布隆过滤器了。</p>
<ul>
<li>当然，如果你不想使用 Docker，也可以在检查本机 Redis 版本合格之后自行安装插件，可以参考这里: <a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">https://blog.csdn.net/u013030276/article/details/88350641</a></li>
</ul>
<h2 id="布隆过滤器的基本用法"><a href="#布隆过滤器的基本用法" class="headerlink" title="布隆过滤器的基本用法"></a>布隆过滤器的基本用法</h2><p>布隆过滤器有两个基本指令，<code>bf.add</code> 添加元素，<code>bf.exists</code> 查询元素是否存在，它的用法和 set 集合的 <code>sadd</code> 和 <code>sismember</code> 差不多。注意 <code>bf.add</code> 只能一次添加一个元素，如果想要一次添加多个，就需要用到 <code>bf.madd</code> 指令。同样如果需要一次查询多个元素是否存在，就需要用到 <code>bf.mexists</code> 指令。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> bf.add codehole user1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.add codehole user2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.add codehole user3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.exists codehole user4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> bf.madd codehole user4 user5 user6
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> bf.mexists codehole user4 user5 user6 user7
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0</code></pre>
<p>上面使用的布隆过过滤器只是默认参数的布隆过滤器，它在我们第一次 <code>add</code> 的时候自动创建。Redis 也提供了可以自定义参数的布隆过滤器，只需要在 <code>add</code> 之前使用 <code>bf.reserve</code> 指令显式创建就好了。如果对应的 <code>key</code> 已经存在，<code>bf.reserve</code> 会报错。</p>
<p><code>bf.reserve</code> 有三个参数，分别是 <code>key</code>、<code>error_rate</code> <em>(错误率)</em> 和 <code>initial_size</code>：</p>
<ul>
<li><strong><code>error_rate</code> 越低，需要的空间越大</strong>，对于不需要过于精确的场合，设置稍大一些也没有关系，比如上面说的推送系统，只会让一小部分的内容被过滤掉，整体的观看体验还是不会受到很大影响的；</li>
<li><strong><code>initial_size</code> 表示预计放入的元素数量</strong>，当实际数量超过这个值时，误判率就会提升，所以需要提前设置一个较大的数值避免超出导致误判率升高；</li>
</ul>
<p>如果不适用 <code>bf.reserve</code>，默认的 <code>error_rate</code> 是 <code>0.01</code>，默认的 <code>initial_size</code> 是 <code>100</code>。</p>
<h1 id="四、布隆过滤器代码实现"><a href="#四、布隆过滤器代码实现" class="headerlink" title="四、布隆过滤器代码实现"></a>四、布隆过滤器代码实现</h1><h2 id="自己简单模拟实现"><a href="#自己简单模拟实现" class="headerlink" title="自己简单模拟实现"></a>自己简单模拟实现</h2><p>根据上面的基础理论，我们很容易就可以自己实现一个用于 <code>简单模拟</code> 的布隆过滤器数据结构：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BloomFilter</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">BloomFilter</span><span class="token punctuation">(</span><span class="token keyword">int</span> initSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>initSize <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认创建大小 * 2 的空间</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> location1 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash1</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location2 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash2</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location3 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash3</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        data<span class="token punctuation">[</span>location1<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>location2<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>location3<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> location1 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash1</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location2 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash2</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> location3 <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">hash3</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> data<span class="token punctuation">[</span>location1<span class="token punctuation">]</span> <span class="token operator">*</span> data<span class="token punctuation">[</span>location2<span class="token punctuation">]</span> <span class="token operator">*</span> data<span class="token punctuation">[</span>location3<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash1</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash2</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> hashCode <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hashCode <span class="token operator">^</span> <span class="token punctuation">(</span>hashCode <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash3</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> hashCode <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hashCode <span class="token operator">^</span> <span class="token punctuation">(</span>hashCode <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里很简单，内部仅维护了一个 <code>byte</code> 类型的 <code>data</code> 数组，实际上 <code>byte</code> 仍然占有一个字节之多，可以优化成 <code>bit</code> 来代替，这里也仅仅是用于方便模拟。另外我也创建了三个不同的 <code>hash</code> 函数，其实也就是借鉴 <code>HashMap</code> 哈希抖动的办法，分别使用自身的 <code>hash</code> 和右移不同位数相异或的结果。并且提供了基础的 <code>add</code> 和 <code>contains</code> 方法。</p>
<p>下面我们来简单测试一下这个布隆过滤器的效果如何：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 假设我们的数据有 1 百万</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> 1_000_000<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 用一个数据结构保存一下所有实际存在的值</span>
    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> existentNumbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BloomFilter bloomFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BloomFilter</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> randomKey <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        existentNumbers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>randomKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        bloomFilter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>randomKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 验证已存在的数是否都存在</span>
    AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    AtomicInteger finalCount <span class="token operator">=</span> count<span class="token punctuation">;</span>
    existentNumbers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>number <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            finalCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"实际的数据量： %d, 判断存在的数据量: %d \n"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 验证10个不存在的数</span>
    count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> key <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>existentNumbers<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 这里一定是不存在的数</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>输出如下：</p>
<pre class=" language-bash"><code class="language-bash">实际的数据量： 1000000, 判断存在的数据量: 1000000 
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span></code></pre>
<p>这就是前面说到的，当布隆过滤器说某个值 <strong>存在时</strong>，这个值 <strong>可能不存在</strong>，当它说某个值 <strong>不存在时</strong>，那就 <strong>肯定不存在</strong>，并且还有一定的误判率…</p>
<h2 id="手动实现参考"><a href="#手动实现参考" class="headerlink" title="手动实现参考"></a>手动实现参考</h2><p>当然上面的版本特别 low，不过主体思想是不差的，这里也给出一个好一些的版本用作自己实现测试的参考：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>BitSet<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBloomFilter</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     * 位数组的大小
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_SIZE <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 通过这个数组可以创建 6 个不同的哈希函数
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> SEEDS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">,</span> <span class="token number">71</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">134</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 位数组。数组中的元素只能是 0 或者 1
     */</span>
    <span class="token keyword">private</span> BitSet bits <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BitSet</span><span class="token punctuation">(</span>DEFAULT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 存放包含 hash 函数的类的数组
     */</span>
    <span class="token keyword">private</span> SimpleHash<span class="token punctuation">[</span><span class="token punctuation">]</span> func <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHash</span><span class="token punctuation">[</span>SEEDS<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 初始化多个包含 hash 函数的类的数组，每个类中的 hash 函数都不一样
     */</span>
    <span class="token keyword">public</span> <span class="token function">MyBloomFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 初始化多个不同的 Hash 函数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SEEDS<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            func<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleHash</span><span class="token punctuation">(</span>DEFAULT_SIZE<span class="token punctuation">,</span> SEEDS<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 添加元素到位数组
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>SimpleHash f <span class="token operator">:</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断指定元素是否存在于位数组
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> ret <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>SimpleHash f <span class="token operator">:</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ret <span class="token operator">=</span> ret <span class="token operator">&amp;&amp;</span> bits<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 静态内部类。用于 hash 操作！
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SimpleHash</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">int</span> cap<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> seed<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">SimpleHash</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>cap <span class="token operator">=</span> cap<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>seed <span class="token operator">=</span> seed<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/**
         * 计算 hash 值
         */</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> h<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>seed <span class="token operator">*</span> <span class="token punctuation">(</span>cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="使用-Google-开源的-Guava-中自带的布隆过滤器"><a href="#使用-Google-开源的-Guava-中自带的布隆过滤器" class="headerlink" title="使用 Google 开源的 Guava 中自带的布隆过滤器"></a>使用 Google 开源的 Guava 中自带的布隆过滤器</h2><p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>28.0-jre<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建布隆过滤器对象</span>
BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> filter <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>
        Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token number">1500</span><span class="token punctuation">,</span>
        <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 判断指定元素是否存在</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 将元素添加进布隆过滤器</span>
filter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
filter<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <code>true</code> 时，我们可以 <strong>99％</strong> 确定该元素在过滤器中，当过滤器返回 <code>false</code> 时，我们可以 <strong>100％</strong> 确定该元素不存在于过滤器中。</p>
<p>Guava 提供的布隆过滤器的实现还是很不错的 <em>（想要详细了解的可以看一下它的源码实现）</em>，但是它有一个重大的缺陷就是只能单机使用 <em>（另外，容量扩展也不容易）</em>，而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 <strong>Redis</strong> 中的布隆过滤器了。</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a>\</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 深度历险》 - 钱文品/ 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！ - <a href="https://juejin.im/post/5de1e37c5188256e8e43adfc" target="_blank" rel="noopener">https://juejin.im/post/5de1e37c5188256e8e43adfc</a></li>
<li>【原创】不了解布隆过滤器？一文给你整的明明白白！ - <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
        <p class="current">
          1 / 3
        </p>
        
          <a class="next" rel="next" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/page/2/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" href="/categories/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"
            id="categoriesE78988E69CACE789B9E680A7"
            ><div class='name'>版本特性</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" href="/categories/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/"
            id="categoriesE79FA5E4B98EE997AEE7AD94"
            ><div class='name'>知乎问答</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 16.67px; color: #878787">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.33px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.67px; color: #5e5e5e">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 22px; color: #636363">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.67px; color: #6c6c6c">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.33px; color: #909090">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 20px; color: #707070">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.67px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 16.67px; color: #878787">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.33px; color: #828282">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.33px; color: #676767">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.67px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.33px; color: #909090">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16px; color: #8b8b8b">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.67px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.33px; color: #909090">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.33px; color: #828282">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.67px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.67px; color: #797979">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.67px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16px; color: #8b8b8b">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/" style="font-size: 18px; color: #7e7e7e">版本特性</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E7%AD%94/" style="font-size: 14px; color: #999">知乎问答</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 16.67px; color: #878787">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.33px; color: #676767">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19.33px; color: #757575">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
