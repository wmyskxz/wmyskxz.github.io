<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0.0-rc.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
      <meta name="robots" content="noindex,follow">
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>归档：2020 - 我没有三颗心脏的博客</title>
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  

  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-light.css">

    
  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover ' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
    
      <p class="title">我没有三颗心脏</p>
    
    
      <p class="subtitle">分享知识&技术&成长&思考</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="search here..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation search'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              id="categories">
              <i class='fas fa-folder-open fa-fw'></i><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  


  <div class="l_body">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量--> 
<!--思路大概是将值藏到重加载的区域内--> 
 
 
 
<div id="pjax-data" style="display: none"> 
  <div id="pjax-ispage">false</div> 
  <div id="pjax-pageTitle"></div> 
  <div id="pjax-enable-cover">true</div> 
  <div id="pjax-comment-path">none</div> 
  <div id="pjax-comment-placeholder">none</div> 
</div> 
 
 
<script> 
  // 处理封面 此时 jquery 还没加载 
  if ("blog" == "none") { // 移除封面 
    document.getElementsByClassName('cover')[0].style.display = "none"; 
    document.getElementsByClassName('l_body')[0].classList.add("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show"); 
  } else { 
    if ("blog" == "blog") { // 半屏 
      document.getElementsByClassName('cover')[0].classList.remove("full"); 
      document.getElementsByClassName('cover')[0].classList.add("half"); 
      document.getElementsByClassName('scroll-down')[0].style.display = "none"; 
    } else if ("blog" == "docs") { // 全屏 
      document.getElementsByClassName('cover')[0].classList.remove("half"); 
      document.getElementsByClassName('cover')[0].classList.add("full"); 
      document.getElementsByClassName('scroll-down')[0].style.display = ""; 
    } 
    document.getElementsByClassName('cover')[0].style.display = ""; 
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover"); 
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show"); 
  } 
</script> 

      
      

<div class='l_main'>
	
		
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/">
      「MoreThanJava」当大学选择了计算机之后应该知道的
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/MoreThanJava/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>MoreThanJava</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年4月2日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-4dfcc42f11323eb0.png" alt=""></p>
<ul>
<li><strong>「MoreThanJava」</strong> 宣扬的是 <strong>「学习，不止 CODE」</strong>，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 <strong>「帮助新朋友快速高质量的学习」</strong>。</li>
<li>当然 <strong>不论新老朋友</strong> 我相信您都可以 <strong>从中获益</strong>。如果觉得 <strong>「不错」</strong> 的朋友，欢迎 <strong>「关注 + 留言 + 分享」</strong>，文末有完整的获取链接，您的支持是我前进的最大的动力！</li>
</ul>
<h1 id="一、计算机-互联网-高薪-996？"><a href="#一、计算机-互联网-高薪-996？" class="headerlink" title="一、计算机 = 互联网 = 高薪 = 996？"></a>一、计算机 = 互联网 = 高薪 = 996？</h1><h2 id="你真的了解计算机专业吗？"><a href="#你真的了解计算机专业吗？" class="headerlink" title="你真的了解计算机专业吗？"></a>你真的了解计算机专业吗？</h2><p>不论你是自己选择的计算机专业还是家人帮你报的名，首先恭喜你！因为计算机是少数的几个 <strong>「不用拼爹」，完完全全可以凭借自己的努力就能够获得回报的专业</strong>，而且从近 20 年来看，回报还相当不错！</p>
<p>那 <strong>计算机专业</strong> 是做什么的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-1bea29656c745df0.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://mp.weixin.qq.com/s/1sb8YqFZm4yRZBzA_Zbn3g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1sb8YqFZm4yRZBzA_Zbn3g</a></li>
</ul>
<p><strong>简单来说</strong>，计算机专业是以 <strong>计算机等技术</strong> 为主要研究工具，<strong>以扩展人类的信息功能</strong> 为主要目标的一门学科。</p>
<h4 id="计算机是个大门类"><a href="#计算机是个大门类" class="headerlink" title="计算机是个大门类"></a>计算机是个大门类</h4><p>翻开本科专业目录，会发现计算机是个大类，包括计算机科学与技术、软件工程、网络工程、信息安全、物联网工程等等等好多专业。其中，最核心、最基础的专业就是 <strong>计算机科学与技术</strong>  <em>(Computer Science and Technology - CS)</em> 了，这也是各院校计算机系招生的主要专业。</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/10586245?fr=aladdin" target="_blank" rel="noopener">百度百科</a> 给出的计算机专业概念的论述是：<strong>计算机专业是指计算机硬件与软件相结合、面向系统、更偏向应用的宽口径专业</strong>。</p>
</blockquote>
<p>总之计算机是个很大的门类，不光编写应用软件的 <strong>软件工程师</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-cc837e5689795b3f.png" alt=""></p>
<p>还有制作硬件的 <strong>硬件工程师</strong>，例如我们日常使用大到手机，小刀计算器，一切物理设备的底层逻辑都是由它们负责编写的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-8de1ed62818f37b1.png" alt=""></p>
<p>还有 <strong>网络工程师</strong>，但也有黑帽子、白帽子、运维等等很多的分别：<em>(这图感觉明显比较黑和帅呢..)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-b78a90e3753c365e.png" alt=""></p>
<p><strong>and more…</strong></p>
<p>另外想说一点是，随着技术的进步和世界的复杂程度的加深，社会分工越来越细之后，大学专业也随之变得越来越细化，这些都不要紧，无论在哪一个方向 <strong>深耕</strong> 都能带来不菲的收获。<em>(即行行出状元)</em></p>
<h4 id="计算机专业都学哪些课程"><a href="#计算机专业都学哪些课程" class="headerlink" title="计算机专业都学哪些课程"></a>计算机专业都学哪些课程</h4><p>了解一门专业最快的方式就是了解它的课程。我们来看一下 <a href="https://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">网易云课堂顶尖中文大学计算机专业课程体系</a> 给出的标准的 CS 体系的课程表：<em>(链接可戳，下图课程全部免费)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-3ab257ae0073d4ff.png" alt="网易云课堂给出的计算机专业课程体系图"></p>
<p>可以看到计算机专业的课程大致分为基础课程和专业课程两类：</p>
<ul>
<li><strong>主要基础课程</strong>：高等数学、大学英语、线性代数、大学物理、概率论、离散数学等；</li>
<li><strong>主要专业课程</strong>：数据结构、C 语言程序设计、数据库原理、操作系统、计算机网络、算法分析与设计、编译原理、软件工程等；</li>
</ul>
<h2 id="“计算机热”-还能持续多久？"><a href="#“计算机热”-还能持续多久？" class="headerlink" title="“计算机热” 还能持续多久？"></a>“计算机热” 还能持续多久？</h2><p>计算机有多热门呢？看一下现在 <strong>漫天飞</strong> 的程序员培训广告就知道了，在前几年，这些地方还被英语培训占据着。<em>(关于计算机培训逐步替代英语培训这事儿，有兴趣了解更多可以 <a href="http://www.ruanyifeng.com/survivor/directions/technology-training.html" target="_blank" rel="noopener">戳这里</a>)</em></p>
<p>于是总有人担心，报选计算机的 <strong>人太多</strong>，<strong>竞争太激烈了</strong>，或者是传言说计算机行业已经 <strong>快饱和了</strong>、<strong>互联网泡沫正在酝酿</strong> 等，但实际情况是怎么样的呢？</p>
<p>我们先来看一段采访：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-e1fc794a420b0d74.png" alt=""></p>
<p>全球最大豪华车制造商戴姆勒奔驰（Daimler Benz） 的总经理在最近的一次采访中表示：</p>
<blockquote>
<p>“我们的竞争对手哪里是其他汽车公司，我们的竞争对手已经变成了特斯拉，谷歌，苹果，亚马逊等科技公司……</p>
<p>科技公司的发展让我们不安，我们面临着巨大的转变。”</p>
</blockquote>
<p>不难发现，全社会正在 <strong>信息化中加速前进</strong>，计算机和互联网已经 <strong>渗透到生活的方方面面</strong>，促使许多传统行业发生变革：</p>
<ul>
<li><p><strong>招聘</strong>：LinkedIn 的出现，正在蚕食美国4000亿美元的利润丰厚的招聘行业。</p>
</li>
<li><p><strong>零售</strong>：Amazon 的出现，让美国零售业人人自危，尤其是知名百货 Macy’s，因业绩不振已经连续关店及裁员。</p>
</li>
<li><p><strong>交通</strong>：Uber 一辆“出租车”都没有，却是全球最大的打车公司，改变交通行业的游戏规则。</p>
</li>
<li><p><strong>住宿</strong>：Airbnb 从不盖楼造宾馆，但是把目前世界最大的连锁酒店集团 Marriott 逼的不得不重新进行战略布局。</p>
</li>
<li><p><strong>医疗</strong>：人工智能医疗机器人、智能诊断、可穿戴医疗设备…新的技术给医疗行业多个领域带来发展机会。</p>
</li>
<li><p><strong>金融</strong>：金融领域也因为互联网和数据的发展，发生着剧变……一夜之间铺遍所有商家的 “扫码支付” 就是最好的例子。</p>
</li>
<li><p>就连 <strong>国防领域</strong>，也越来越以软件为基础，对科技人才的需求日趋迫切：</p>
<ul>
<li><p>软件驱动的无人机发动空袭，不再让人类飞行员面临风险；</p>
</li>
<li><p>情报机构利用软件进行大规模数据挖掘，以发现和追踪潜在的恐怖主义活动；</p>
</li>
</ul>
</li>
</ul>
<p>从某种程度上来说，计算机行业不但不会饱和，并在大口 “侵食” 其它行业！几乎所有的公司和领域，都需要计算机相关的人才！</p>
<p>有人说，未来世界将只剩下三种职业：</p>
<ol>
<li>娱乐人士；</li>
<li>Pizza 快递员；</li>
<li>程序员；</li>
</ol>
<p>不过，基于现在的发展来看，娱乐可以被 VR／AR 渗透，Pizza 快递会由送餐机器人完成，而世界最终需要的，就是程序员。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-f2affd1192354c41.png" alt=""></p>
<h2 id="对程序员的认识"><a href="#对程序员的认识" class="headerlink" title="对程序员的认识"></a>对程序员的认识</h2><h4 id="高薪是真的，996-也是真的"><a href="#高薪是真的，996-也是真的" class="headerlink" title="高薪是真的，996 也是真的"></a>高薪是真的，996 也是真的</h4><p>工作 996，生病 ICU（重症监护病房）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-f33e253bbf80012f.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://36kr.com/p/5191849" target="_blank" rel="noopener">https://36kr.com/p/5191849</a></li>
</ul>
<p>诚然，程序员的薪资水平普遍都要率高于其他一些传统行业：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-580a432ce4a64e81.png" alt=""></p>
<ul>
<li>图片引用自：<a href="http://www.emuban.com/article/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc%2FaW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTg0NTg0ODA0NTk2JmRpPWZiNWZjMWE5NjRkMzQ2MDVmZmFkMTY2ZmI4ZDU5ODU3JmltZ3R5cGU9MCZzcmM9aHR0cCUzQSUyRiUyRnBpYy5kaW5nZGFuZ3lpeGlhLmNuJTJGcGljJTJGMjAxODA4MTklMkYyMDE4MDYxOTEzMjU0NjQyMS5qcGdAQOWNgeWkp%2BmrmOiWquihjOS4mizorqHnrpfmnLrkuJPkuJrljaDmja7ljYrlo4HmsZ%2FlsbFAQDIwMTjorqHnrpfmnLrkuJPkuJrkuI7lhbbku5bkuJPkuJrlr7nmr5Torr7orqE%3D.html" target="_blank" rel="noopener">设计资源网</a></li>
</ul>
<p><strong>但高薪的同时，也意味着高投入</strong>。</p>
<p>中国的信息技术产业，特别是过去十多年崛起的一些大型互联网公司，他们的重点主要还是在对技术应用的开发上。过去十多年来，中国互联网产业的发展所提供的机会，使得业界认识到：投入到应用中的收益，显然比基础研究的收益更大。</p>
<p>随着这些基础的开源技术开发工具的进步，中国的程序员的入行门槛也越来越低，这和市场对程序员的需求数量越来越多这一趋势又是匹配的。随着资本参与互联网的大战，“快” 成为互联网行业的共识。其实由于开源生态的存在，技术开发如今本身已经快得不能再快了，但市场竞争是残酷的，没有最快只有更快。</p>
<p>这就产生了一个矛盾：产业迅速膨胀，从业人员的水分也越来越高，但市场对公司的效率要求也越来越高。<strong>在这种态势下，技术应用方面的研发，很容易落入劳动密集型的实质当中</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-4ecd8972692d4cc2.png" alt=""></p>
<p>难怪如今程序员往往自嘲为 <strong>“码农”</strong>，意思是 <strong>“写代码的农民工”</strong>。程序员褪去了 “智力劳动者” 的光环，似乎成为了和车间工人没太大区别的工种：无论是从工作的复杂程度来看，还是工作时长对工作的产出来看，都越来越接近了。</p>
<blockquote>
<p>当然，把程序员和传统的产业工人做类比其实并不完全正确，这主要是因为：脑力劳动，或者说智力和知识，在信息技术开发的工作中起的作用太大了。</p>
</blockquote>
<h4 id="程序员的「行业偏见」"><a href="#程序员的「行业偏见」" class="headerlink" title="程序员的「行业偏见」"></a>程序员的「行业偏见」</h4><p>在极光大数据的 <code>2018</code> 年中国程序员研究报告里，对于 <strong>「外行对你的职业最大的误解是什么」</strong> 的这个问题，有 <code>46.1%</code> 的程序员选择了 <em>“很会修电脑”</em>，<code>42.7%</code> 的人选择了 <em>“可以轻易开发出任何软件”</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-55b543f52c7022bf.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://www.pingwest.com/a/160607" target="_blank" rel="noopener">https://www.pingwest.com/a/160607</a></li>
</ul>
<p>每个行业都存在各自的行业偏见，例如遇到健身教练就想让人帮你 <code>3</code> 天瘦 <code>10</code> 斤，还得不打针、不吃药、不节食、不运动。这些偏见都无可厚非，重要的是你怎么看待这事儿，是选择被贴标签就靠近标签，还是选择做自己。</p>
<h2 id="什么样的人适合学习计算机？"><a href="#什么样的人适合学习计算机？" class="headerlink" title="什么样的人适合学习计算机？"></a>什么样的人适合学习计算机？</h2><p>4 点吧：<strong>兴趣</strong>、<strong>逻辑</strong>、<strong>就业</strong>、<strong>静下来学习</strong>。</p>
<h4 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h4><p>计算机行业的 <strong>知识迭代</strong> 相比其他行业来说速度要 <strong>快</strong> 上不少，加之市场对程序员的 <strong>要求</strong> 也越来越 <strong>高</strong>，这就要求了程序员需要更多的时间来学习。而说到底，计算机是一个偏实践性的理论知识学科，你不仅需要 <strong>花费大量的时间学习</strong> 枯燥的基础的理论知识，还需要再画 <strong>大量时间去动手实践</strong> 最终将这些知识 <strong>融会贯通</strong> 起来，这个过程可能略显枯燥和冗长，而 <strong>兴趣会帮助你跨过不少的无趣</strong>。</p>
<p>在 <a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与漫画》</a> 一书中有这样一段描述：</p>
<blockquote>
<p>在达·芬奇的年代，绘画并不是一件很酷的事情，达·芬奇用自己的工作推动绘画成为一种伟大的表达方式。同样，编程到底能够有多酷，取决于我们能够用这种新媒介做出怎样的工作。</p>
</blockquote>
<p><strong>「兴趣是最好的老师」</strong> 这句话再怎么吹也不为过，你对一件事情的兴趣和热爱，在很大程度上决定了你做一件事情所取得的成绩。</p>
<p>看到有网友调侃：”给我妈买的智能洗衣机教了 n 遍都不会用，后来给她买了台麻将机，不仅会用还会修呢。”</p>
<p>还看到有网友吐槽说：「也可以先结婚后恋爱的..」，这… 你们自己品吧…</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-6b3135e795c9d775.png" alt=""></p>
<h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>现代的计算机还没有足够的「聪明」，当你实现一些东西和想法的时候，需要考虑 <strong>「足够多」</strong> 的细节，这就涉及到 <strong>「逻辑思考，讲求因果」</strong> 的能力了。</p>
<p>这事儿我在 <a href="https://www.zhihu.com/question/22508677/answer/141334678" target="_blank" rel="noopener">「知乎讨论 - 编程到底难在哪里？」</a> 看到了许多有趣生动的例子，这里我们截取一个关于 <strong>「树上有十只鸟，开枪打死一只，还剩几只?」</strong> 问题的讨论来论述：<em>(例子略长.. 不感兴趣的读者可以跳过..)</em></p>
<blockquote>
<p>某日，老师在课堂上想考考学生们的智商，就问一个男孩: “树上有十只鸟，开枪打死一只，还剩几只?”　　</p>
<ul>
<li>🙋‍♂️:“是无声手枪，还是其他没有声音的枪么?”　　</li>
<li>“不是.”　　</li>
<li>🙋‍♂️：“枪声有多大?”　　</li>
<li>“80~100 分贝.”　</li>
<li>🙋‍♂️：“那就是说会震的耳朵疼?”　　</li>
<li>“是.”　　</li>
<li>🙋‍♂️：“在这个城市里打鸟犯不犯法?”　　</li>
<li>“不犯.”　　</li>
<li>🙋‍♂️：“您确定那只鸟真的被打死啦?”　　</li>
<li>“确定.” (老师已经不耐烦了)，”拜托，你告诉我还剩几只就行了,OK?”　　</li>
<li>🙋‍♂️：“OK.鸟里有没有聋子?”　　</li>
<li>“没有.”　　</li>
<li>🙋‍♂️：“有没有鸟智力有问题，呆傻到听到枪响不知道飞的?”　　</li>
<li>“没有，智商都在 200 以上!”　　</li>
<li>🙋‍♂️：“有没有关在笼子里的?”　　</li>
<li>“没有.”　　</li>
<li>🙋‍♂️：“边上还有没有其他的树，树上还有没有其他鸟?”　　</li>
<li>“没有.” </li>
<li>🙋‍♂️：“方圆十里呢?” </li>
<li>“就这么一棵树!”　　</li>
<li>🙋‍♂️：“有没有残疾或饿的飞不动的鸟?”　　</li>
<li>“没有，都身体倍棒.”　　</li>
<li>🙋‍♂️：“算不算怀孕肚子里的小鸟?”　　</li>
<li>“都是公的.”　　</li>
<li>🙋‍♂️：“都不可能怀孕?”　　</li>
<li>“………，决不可能.”　　</li>
<li>🙋‍♂️：“打鸟的人眼里有没有花?保证是十只?”　　</li>
<li>“没有花，就十只.” 老师脑门上的汗已经流下来了，　　</li>
<li>🙋‍♂️：“有没有傻的不怕死的?”　　</li>
<li>“都怕死.”　　</li>
<li>🙋‍♂️：“有没有因为情侣被打中，自己留下来的?”　　</li>
<li>“笨蛋，之前不是说都是公的嘛!”　　</li>
<li>🙋‍♂️：“同性恋可不可以啊？”　　</li>
<li>“………….，性取向都很正常!”　　</li>
<li>🙋‍♂️：“会不会一枪打死两只?”　　</li>
<li>“不会.”　　</li>
<li>🙋‍♂️：“一枪打死三只呢?”　　</li>
<li>“不会.”　　</li>
<li>🙋‍♂️：“四只呢?”　　</li>
<li>“更不会!”　　</li>
<li>🙋‍♂️：“五只呢?”　　</li>
<li>“绝对不会!!!”　　</li>
<li>🙋‍♂️：“那六只总有可能吧?”　　</li>
<li>“除非你他妈的是猪生的才有可能!一枪只能打死一只!”　　</li>
<li>🙋‍♂️：“…好吧，那么所有的鸟都可以自由活动么?”　　</li>
<li>“完全可以.”　　</li>
<li>🙋‍♂️：“它们受到惊吓起飞时会不会惊慌失措而互相撞上?”</li>
<li>“不会，每只鸟都装有卫星导航系统，而且可以自动飞行.”</li>
<li>🙋‍♂️：“恩，如果您的回答没有骗人，” <strong>学生满怀信心的回答，“打死的鸟要是挂在树上没掉下来，那么就剩一只，如果掉下来，就一只不剩.”</strong></li>
<li>老师推推眼镜，强忍着要昏倒的感觉，颤抖地说道：<strong>“你可以去当程序员了……”</strong></li>
</ul>
</blockquote>
<h4 id="静下来学习"><a href="#静下来学习" class="headerlink" title="静下来学习"></a>静下来学习</h4><p><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与漫画》</a> 一书中有描述说：</p>
<blockquote>
<p>程序员因为常常埋头于编程，而没有更多的时间精力去与学习如何与别人相处。这常常导致他们看起来有点“呆”——就像书呆子经常只和书打交道一样，程序员大部分时间只对着计算机屏幕。</p>
</blockquote>
<p>这也从侧面反映出了编程这件事的特点。我们需要 <strong>「静下来沉淀学习」</strong> 的能力，如果你渴望几个月速成，或者不想学习新技术，指望二十来岁拿一个学位证，可以吃到退休，那么你就不太适合计算机行业。</p>
<h1 id="二、对「大学」了解多一些"><a href="#二、对「大学」了解多一些" class="headerlink" title="二、对「大学」了解多一些"></a>二、对「大学」了解多一些</h1><h2 id="为什么你可以不读大学？"><a href="#为什么你可以不读大学？" class="headerlink" title="为什么你可以不读大学？"></a>为什么你可以不读大学？</h2><p>可不要被这个标题吓到，读书，念大学仍然是当今社会下的主流选择，这里只是借 <a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a> 大大的文章来提供一种 <strong>全新的视角</strong>，我相信读者会跟我一样，看完会带来一定思考的。</p>
<blockquote>
<p>以下内容均引用自：<a href="http://www.ruanyifeng.com/survivor/collapse/university.html" target="_blank" rel="noopener">为什么你可以不读大学 | 阮一峰</a></p>
</blockquote>
<h4 id="什么知识才是有用的知识？"><a href="#什么知识才是有用的知识？" class="headerlink" title="什么知识才是有用的知识？"></a>什么知识才是有用的知识？</h4><p>在 <strong>农业社会</strong>，上一代人的知识可以一成不变地用在下一代。而在信息社会，前几年的知识，再过几年就不能用了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-df4149f6f9ce0641.png" alt=""></p>
<p>举例来说，眼下就业前景最好的行业，我觉得有两个：区块链和 VR。它们在五年前都是不存在的，那时就业最好的是苹果 iOS 系统的应用开发，可是再往前推五年，它也是不存在的。伴随着它们的是，很多旧工作岗位的消失，比如塞班、黑莓、Windows Phone 的开发。</p>
<p>这种情况下，大学应该教什么，我们根本不知道。学生毕业后的行业，现在根本还没有出现。因此，大学只能重点教 <strong>基础类课程</strong>，而且各个方向都必须教到，因为不知道学生将来会用到哪个方向的东西。这样就会耗费大量的时间，学习专业的各种基础知识，其中许多对人生来说是没用的。学生常常感叹：<strong>「考试一结束，有些课程这辈子再没有用到的机会了」</strong>。</p>
<p>更糟糕的是，学生的培养计划，都是一些二三十年前毕业、然后一直待在大学里、与社会生产实践脱节的人制定的。他们的知识和思维早已过时了。这样的人指定你应该学习的知识，很可能在你学的时候就已经过时了。</p>
<h4 id="大学的四年时间"><a href="#大学的四年时间" class="headerlink" title="大学的四年时间"></a>大学的四年时间</h4><p>退一步说，就算你在大学里能学到了真正的知识，那也不应该在那里待四年。如果只学最需要学习的东西，一年就够了。</p>
<p><strong>四年时间足以让一个人在任何领域成为资深业者，甚至专家</strong>。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-47b3674a9ab934df.png" alt=""></p>
<p><code>18</code> 岁是人生最有热情和精力投入一项事业的时候，但是，大学将你一连四年关在教室和图书馆里，把考试和绩点伪装成你奋斗的目标，人为将你与真实世界隔离，引导你去关注那些对未来人生毫不重要的事情。经过这样四年的歧途，等你真正走上社会、要跟全世界竞争的时候，你的竞争力不是变强了，而是变弱了。换句话说，四年制大学很可能是削弱你，而不是让你变得更强。</p>
<p><code>2014</code> 年诺贝尔物理学奖得主中村修二，就曾经写过一篇长文，名字就叫 <a href="https://www.jiemian.com/article/887630.html" target="_blank" rel="noopener">《东亚教育浪费了太多的生命》</a>。</p>
<p>我们时代的很多成功者—-乔布斯、比尔盖茨、扎克伯格等等—-都是退学生，这绝不是偶然的。不是他们在大学待不下去，而是他们发现，没必要在那个地方待四年。如果他们咬着牙忍受下去，熬到拿到文凭的那一天，苹果公司和微软公司可能都不会有了。</p>
<h4 id="不是说知识无用"><a href="#不是说知识无用" class="headerlink" title="不是说知识无用"></a>不是说知识无用</h4><p>注意，我不是说知识无用，而是说知识（尤其是非学术的知识）不一定要通过大学获得，通过互联网一样可以接受高等教育，而且更高效和便宜。</p>
<p><strong>技术已经成为人类社会发展的主导性力量，学习和教育变得比以往更重要、更关键</strong>。但是很不幸，我们的学习和教育制度已经完全过时，传授的知识有用的少，没用的多；传授方法仍然依靠灌输和记忆，而不是启发和理解，极其低效，浪费学生的时间，打击学习热情，磨灭对知识的兴趣；对年轻人的成长，正面影响少，负面影响大，而且看不到改变的希望。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-de5a1eeab222f95b.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://zhuanlan.zhihu.com/p/54933216" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54933216</a></li>
</ul>
<p>以前，人生的选择很少，你不得不去读大学，因为没有其他地方可以接受高等教育。社会还把很多机会与文凭挂钩，先有文凭，然后才能有就业、职称、住房等等。</p>
<p>但是，时代已经变了，文凭正变得越来越不重要。那些与文凭挂钩的东西，正在一项项脱钩。</p>
<p>互联网将教育的自主权，交到了每个人自己手里。上什么课程、什么时间上，都完全由你决定。你可以一边工作，一边利用夜晚和周末，学习网络课程。这样的话，不仅早早就会有收入，而且只学那些对自己最有用、最感兴趣的内容，学习的效率很高。如果发现对学术有兴趣，将来再回大学，攻读更高的学位，也是完全可以的。</p>
<p><strong>大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程”画地为牢“限制住。你要主动去接触和学习，那些自己感兴趣的东西</strong>。引用一个网友的话，“你要做的就是自主、跨界、终身学习“。</p>
<h2 id="中国大学的教育理念"><a href="#中国大学的教育理念" class="headerlink" title="中国大学的教育理念"></a>中国大学的教育理念</h2><p>在吴军老师 <a href="https://book.douban.com/subject/26584286/" target="_blank" rel="noopener">《大学之路》</a> 中介绍了大学的基本教育理念有两种：</p>
<ol>
<li><strong>纽曼的教育理念</strong>：倡导通才教育，本科阶段讲求知识面的广阔，要求更多的课外活动，而不要求专业的深度，专业的深造放到大四或者研究生阶段。具体像是哈佛大学，耶鲁大学，本科生在入学时有足够多的课程可以选择，但不需要确定专业，本科学习的后期才要求确定专业，保证本科生能够在尝试中找到自己心仪的专业，以确定未来自己的发展方向。</li>
<li><strong>德国洪堡教育体制</strong>：强调专才教育，要求学生入学时就选定发展方向，讲求专业的深度。<strong>中国目前的高等教育模式就来自洪堡教育体制</strong>。</li>
</ol>
<p>在纽曼的教育理念之下，学生一毕业并不能马上达到专业工作的要求，但事业和未来发展会有后劲。洪堡教育体制则更适合需要迅速发展生产的时代，比如工业革命后需要大量科学家的美国。洪堡教育体制下毕业的学生能够迅速为国家所用，实现自身脱贫，有助于社会的迅速工业化。</p>
<p>纽曼的教育理念和洪堡教育体制很难简单地说谁更好一点，而是要看 <strong>社会发展所处的阶段</strong>。</p>
<p>改革开放初期需要尽快发展经济，类似于工业革命背景之下的美国，显然洪堡教育体制下的大学教育见效更快。社会发展趋于稳定之后，纽曼的教育理念能够帮助学生找到发展的后劲。这也是为什么现在高考开始出现 <strong>“3 + 3”</strong>、某些地方大学计划可以自选专业课的原因。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-ca9f410f973b3272.png" alt="高考 3+3 改革"></p>
<blockquote>
<p>虽然专才教育能够培养出很好的执行层面的人(无论是科学家、工程师，还是律师和医生)，但是却很难培养出拥有广阔事业的领袖以及实业家。当一个国家已经处于稳步发现阶段，当一个学生来自中上产之家，正朝着精英目标努力，这个时候，倘若缺少博雅的素质教育，路就跟难走得远。今天，中国的高中生一进高中就开始专攻那些高考必考的课程，而一进入大学，他们就被限制在不允许修改的专业中，这不仅失去了得到通才教育的机会，甚至被剥夺了培养自己学习兴趣的可能，我自己在读高中时受到了很多的通才教育，以至于到今天我所具备的人文和社会科学方面的素养，足以让我成为一个受人尊敬的人。可以说，没有好的通才教育，一个人的事业发展就不会有后劲。——吴军《大学之路》</p>
</blockquote>
<h1 id="三、我该如何学习？"><a href="#三、我该如何学习？" class="headerlink" title="三、我该如何学习？"></a>三、我该如何学习？</h1><h2 id="先做好终身学习的心里准备"><a href="#先做好终身学习的心里准备" class="headerlink" title="先做好终身学习的心里准备"></a>先做好终身学习的心里准备</h2><p>美国有一个谚语 <strong>「手里拿着锤子，看什么都是钉子」</strong>。指的是人们被自己的所拥有的知识能力所局限，导致自己做什么事情都想用手头已有的锤子来解决问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-c331b3d0a9b0ec0e.png" alt=""></p>
<ul>
<li>图片引用自：<a href="https://m.zcool.com.cn/work/ZNDA2NDkwNzY=.html" target="_blank" rel="noopener">https://m.zcool.com.cn/work/ZNDA2NDkwNzY=.html</a></li>
</ul>
<p>要克服这种铁锤人综合症的方法就是：<strong>在精通某一领域的同时接受各个领域的知识，并且将他们用来解决现实世界中的问题</strong>。</p>
<p>如此，再遇见钉子我们就有了一个工具箱。既有锤子，也有螺丝刀，还有钳子…</p>
<p>但是，要在短短的四年时间里做到这一点是有一定困难的：</p>
<ul>
<li><strong>首先，学校要有能力开出足够可供学生选择的课程</strong>。这一点，即使是如上交这样 <em>(有大量政府投入的)</em> 的学校都很难做到。每年到了选课的季节，都是对学校教务系统服务器的一次大考。学生们需要像抢春运火车票一样来抢仅有的上百门选修课。</li>
<li><strong>其次，即使强行开出这些课程，但是课程的质量往往无法得到保障</strong>。在我的学校，许多选修课完全算不上吸引人，也很少教课教的好的老师 <em>(我大学有一门课，老师上课不讲课就放视频，学生安静地待到下课就可以走了…)</em>，于是这些选修课成了同学赶作业，玩手机的时间。</li>
</ul>
<p><strong>唯一的解决办法就是延长教育时间</strong>。 在美国许多名校，例如哈弗，普林斯顿采用本科给学生以通识教育，学生可以自由选课 <em>(哈弗为了 <code>6000</code> 名本科开出了 <code>2000</code> 多门课)</em>。之后再通过 <code>1-2</code> 年的研究生教育让学生实现专业教育。这个与中国研究生的轻教育重科研有所不同。</p>
<p>但是对于我们普通人来说，我们很难有机会进入这些顶级大学，接触到这样的资源，那我们应该怎么办呢？</p>
<p>这个就要抛出所秉持的观念：<strong>坚持终身教育</strong>。这里引用吴军在《大学之路》里面的一段话：</p>
<blockquote>
<p>可能许多人认识不到教育是一辈子的事情，我们不必担心输在起跑线上，因为世界上大部分人跑到一半就不会再跑了，这就给了长跑者机会</p>
<p>并且，一个善于学习的人，随着年龄的增长，他会找到自己的兴趣点，如果他还能够学习，就有了目的性和针对性。</p>
</blockquote>
<p>在大学里我们需要养成一种自学的习惯。不仅仅是自学学校所定制的专业课，并且要有能根据自己的兴趣，要解决的问题而高效自学的能力。</p>
<p>并且养成习惯：</p>
<p>遇见问题 -&gt; 分析问题 -&gt; 搜集相关资料 -&gt; 学习相关资料 -&gt; 解决问题。</p>
<p>通过这样的方式，我们才能够跳出环境给我们带来的局限性，拥有更丰富的的人生。</p>
<h2 id="方向不对，努力白费"><a href="#方向不对，努力白费" class="headerlink" title="方向不对，努力白费"></a>方向不对，努力白费</h2><h4 id="有一个清晰的目标很重要"><a href="#有一个清晰的目标很重要" class="headerlink" title="有一个清晰的目标很重要"></a>有一个清晰的目标很重要</h4><p>就说说我的两个同学吧。</p>
<p><strong>同学 A | 大佬程序员：</strong></p>
<p>一个是在大一刚进来，正当同学们还处于刚进入大学的那种朦朦胧胧、放放松松时，就已经决定好了要走技术这条路线的 <strong>同学 A</strong>。</p>
<p>在大一刚开学时就开始早早准备自学 C/ C++，等到我们开始上学校为我们开设的课程时，他已经利用一个暑假的时间，自己基于 Unix 改写自己的 <strong>操作系统</strong>。在我们上机的课堂上还听他吐槽自己实现的垃圾桶删不了文件，有 BUG。</p>
<p>后来等到我们开始学习计算机网络时，他又自己仿写了一个类 <strong>Nginx 服务器</strong>。</p>
<p>再等我们大四准备实习时，他俨然已经成为了 <strong>Offer 收割机</strong>，想去哪儿就去哪儿 <em>(尽管我们学校仅仅是一个二本院校)</em>。当时看着他简历上的两个项目：自己实现的操作系统和服务器，心里就是一句：「卧槽！牛逼！」。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-522544089486dd3d.gif" alt=""></p>
<p><strong>同学 B | 大佬销售员：</strong></p>
<p>大一就开始卖我们电脑.. 后来大二开学开始代理学校的电信、移动等移动业务，再后来还开展了驾校的业务，大四的时候吧，我们都还在找实习呢，他已经在学校周边开办起了自己的公司..成为了自己的 <strong>CEO</strong>.. </p>
<h4 id="为之努力，并且永远不要怕晚"><a href="#为之努力，并且永远不要怕晚" class="headerlink" title="为之努力，并且永远不要怕晚"></a>为之努力，并且永远不要怕晚</h4><p>后来想起这两位同学，常常会以 <strong>“他们目标好清晰”</strong> 这样的句式来 <strong>掩盖他们为之付出的努力</strong>，方向固然重要，但为之努力也同样。如果不是 <strong>同学 A</strong> 牺牲其他同学玩耍的时间自学学习编程，他不会成为后来人人眼红的 <strong>Offer 收割机</strong>，如果不是 <strong>同学 B</strong> 勤勤恳恳不怕辛苦经营、探索各种业务，那也不会后来早早成为自己的 <strong>CEO</strong>。</p>
<p><strong>为之努力，并且永远不要觉得晚</strong>。说来惭愧，我的大学几乎可以说是从大三开始的，当我突然开始意识到我即将进入社会却身无长物时，我突然觉得需要一些些的改变和努力。于是我当天就开始制定计划，从那天到学期结束还有 <strong>七个星期零 2 天</strong>，于是有了下面这个计划：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-1d688e96c0175d0c.png" alt="七个星期零2天的计划 &amp; 总结"></p>
<p>从最基础的 Servlet/ JSP 到 SpringBoot 一整个基础的学习过来，也到了暑假，发现自己还是有差距所以毅然决定留校学习，于是有了 <strong>暑期计划</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-0c1101bd415c3d0b.png" alt="暑期计划"></p>
<p>这一段时间，给自己的简历上增加项目、学习巩固基础的数据结构、算法知识，然后 <strong>参加秋招</strong> <em>(<a href="https://www.wmyskxz.com/2018/08/15/qiu-zhao-ti-qian-pi-cvte-yi-mian-gua-a-li-san-mian-gua/">当时的面经</a>)</em>，意识到自己的差距，并且想明白了自己想要继续学习更多的知识之后，决定 <strong>考研</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-1878855356bb1675.png" alt=""></p>
<p>两个月的拼搏，虽然最终以 <code>4</code> 分的差距未能如愿择校，但后来春招也算是如愿进入了自己比较心仪的公司。</p>
<p><strong>这一切的 “逆袭” 对于我来说，也不过仅仅一年的时间。</strong></p>
<blockquote>
<p>我把这些经历也记录在了这里 - <a href="https://www.wmyskxz.com/2019/01/01/2018-nian-zhong-zong-jie/">2018 年终总结</a></p>
</blockquote>
<h2 id="锻炼独立思考、自主研究解决问题的能力"><a href="#锻炼独立思考、自主研究解决问题的能力" class="headerlink" title="锻炼独立思考、自主研究解决问题的能力"></a>锻炼独立思考、自主研究解决问题的能力</h2><p>在前一段时间里，我接触到一个词：<strong>「二手人生」</strong>。它概括的是这样一种处境：<strong>「你发现你在生活里遇到的所有问题，在搜索引擎里都能找到答案」</strong>。</p>
<p>比如说，怎么搭配衣服才低调优雅，去哪吃饭便宜又美味，买哪款耳机更划算，工作还是考研，要不要入手比特币，都有人替你解答了。你还发现有一批人用照片、视频、段子、广告为你提供了一个精心加工过的世界，这个世界常常比你自个儿的世界要美丽有趣深刻好笑有品位得多。<strong>如果把当代生活比作一场开卷考，比起你自己慢慢找答案，达人们已经为你提供了一套高分答案放到你面前让你参考</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-84fd8bb3c8aa16f9.png" alt=""></p>
<p>渐渐地你养成了一种 <strong>学生式习惯，当生活给你发了一份新卷子，你的第一反应就是先翻到网上，去看参考答案</strong>。</p>
<p>事实证明，后来我们接触的大部分事情 (无论生活还是学习上)，都不太容易有一个标准答案，<strong>当问题来临时，如何独立思考、自主研究解决问题，是非常重要的能力</strong>。</p>
<p>自我写博客以来，常常收到读者们发来的问题，有一些是他们真实地遇到了不可解决的问题寻求我的帮助，有一些问题则显得我很意外，就像下面这样：<em>(网站链接 <a href="https://lmbtfy.cn/" target="_blank" rel="noopener">戳这里</a>)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-e9795883eb364393.gif" alt=""></p>
<p>为什么会这样呢？我想大概就是学生时代遗留下来的习惯吧，习惯了更轻松一些的向别人寻求帮助或者是翻找参考答案，很少自己主动地去思考并得出问题的答案。</p>
<blockquote>
<p>这里给出一个问问题的标准模板：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-e24425ee93b35663.png" alt=""></p>
</blockquote>
<h2 id="学会编程而不是学会-Java"><a href="#学会编程而不是学会-Java" class="headerlink" title="学会编程而不是学会 Java"></a>学会编程而不是学会 Java</h2><p>其实技术是相通的。编程的落脚点还是应该放在 <strong>解决问题</strong> 上，而不是使用某种工具上。更重要的是我们通过学习某一种编程语言，来帮助我们养成 <strong>计算机的思维方式</strong>，这也要求了我们在掌握一种技术时，不仅要 <strong>知其然，还要知其所以然</strong>。</p>
<p>例如在「码农翻身」的一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=417056471&idx=1&sn=0ef5cbe0e336f34fc267f209b20d5379&scene=21#wechat_redirect" target="_blank" rel="noopener">「学会编程， 而不是学会Java」</a> 里就提到了一个问题，模仿 Java 的 <code>ArrayList</code> 实现一个自己的 <code>SimpleList</code> 类：<em>(现在看不懂也没关系)</em></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleList</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">SimpleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>T e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这个题目不要求实现复杂的算法， 也不需要进行面向对象的设计，也不需要考虑多线程下的线程安全， 况且已经给了提示：「用一个Object数组来实现」。如果说有一点语法层面的难度， 那就是使用了一点泛型。 </p>
<p>这个 <code>SimpleList</code> 要求的就是能对一个数组进行操作，核心就两点：</p>
<ol>
<li><p>能往数组添加数据， 记录size ，如果数组空间不够了， 需要增大空间</p>
</li>
<li><p>能删除数组指定位置的数据，并且把之后的数据往前挪动。</p>
</li>
</ol>
<p>难吗？这其实是编程序的基本素养，编程的本质，和用什么语言实现没有关系。</p>
<h2 id="写更多更多的代码"><a href="#写更多更多的代码" class="headerlink" title="写更多更多的代码"></a>写更多更多的代码</h2><h4 id="技术没有捷径"><a href="#技术没有捷径" class="headerlink" title="技术没有捷径"></a>技术没有捷径</h4><p>技术不要想着有捷径可寻，十年入行是有道理的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-32b4cf7afd0494fd.png" alt=""></p>
<p>现在随便走进一家书店，都会在技术类的书架上看到一堆的类似于《24小时学会Java》、《21天C++从入门到精通》这样的的书 (上面的漫画就很好地调侃了)，然而这一类「标题党」书籍，都是让你「走马观花」地瞧上一瞧，也没有时间让你写几个真正有意义的程序，这样的 <strong>「一知半解」</strong> 是一件极其危险的事情。</p>
<p>踏踏实实铺平基础知识，才是正道。</p>
<h4 id="做-ABC-的程序员而不是-ABR"><a href="#做-ABC-的程序员而不是-ABR" class="headerlink" title="做 ABC 的程序员而不是 ABR"></a>做 ABC 的程序员而不是 ABR</h4><ul>
<li><strong>ABC</strong>: Always Be Coding…</li>
<li><strong>ABR</strong>: Always Be Reading…</li>
</ul>
<p>看时会，做时废？人们口中常说的 <strong>「经验」</strong>，其实是指从自己 <strong>「一手实践」</strong> 中得到的 <strong>「一手经验」</strong>，而不是指那些从文章从别人口中获取到的「二手经验」。所以要保持 <strong>「保持始终编程」</strong>，你编写的代码越多，那么你的水平就会提升得越多。</p>
<p>去 <strong>造重复的轮子</strong>、<strong>与其他程序员交流</strong>、<strong>动手实践自己的想法</strong>。最佳实践就是集中训练，并且不断地探索新领域并挑战自己。</p>
<h2 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h2><p>自学是程序员必须掌握的一项技能，上面已经说到了大学的课程设计不是以 <strong>培养程序员</strong> 为目的的，而是以 <strong>教授最基础的知识技能</strong>，所以自学很重要。</p>
<h4 id="一些高质量的自学资料和平台"><a href="#一些高质量的自学资料和平台" class="headerlink" title="一些高质量的自学资料和平台"></a>一些高质量的自学资料和平台</h4><blockquote>
<p>部分摘录自：<a href="https://zhuanlan.zhihu.com/p/113820077" target="_blank" rel="noopener">Github 近90k点赞的计算机专业课程,在家也能上名校! | JavaGuide</a></p>
</blockquote>
<p><a href="https://github.com/ossu/computer-science#intro-cs" target="_blank" rel="noopener">computer-science</a></p>
<ol>
<li>star :56.1k</li>
<li>Github 地址：<a href="https://github.com/ossu/computer-science#intro-cs" target="_blank" rel="noopener">https://github.com/ossu/computer-science#intro-cs</a></li>
<li>介绍：通往计算机科学免费自学教育之路！计算机专业课程</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-9981342a8857add8.png" alt=""></p>
<p><a href="https://github.com/keithnull/TeachYourselfCS-CN" target="_blank" rel="noopener">TeachYourselfCS-CN (自学计算机科学)</a></p>
<ol>
<li>star :0.8k</li>
<li>Github 地址：<a href="https://github.com/keithnull/TeachYourselfCS-CN" target="_blank" rel="noopener">https://github.com/keithnull/TeachYourselfCS-CN</a></li>
<li>介绍：TeachYourselfCS 的中文翻译。内容超级棒！如果你是一个自学成才的工程师，或者从编程培训班毕业，那么你很有必要学习计算机科学。幸运的是，不必为此花上数年光阴和不菲费用去攻读一个学位：仅仅依靠自己，你就可以获得世界一流水平的教育。在这份指引中会为你解答：你应当学习 <strong>哪些科目</strong>，为什么？对于这些科目，<strong>最好的书籍或者视频课程是什么</strong>？</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-4c6825dc10824da0.png" alt=""></p>
<p><a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener">REKCARC-TSC-UHT(清华大学计算机系课程攻略)</a></p>
<ol>
<li>star :12.2k</li>
<li>Github 地址：<a href="https://github.com/PKUanonym/REKCARC-TSC-UHT" target="_blank" rel="noopener">https://github.com/PKUanonym/REKCARC-TSC-UHT</a></li>
<li>介绍：清华大学计算机系课程攻略。受 <a href="https://github.com/QSCTech/zju-icicles" target="_blank" rel="noopener">浙江大学相关项目</a> 启发，创立了本项目。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-411647071772abb6.png" alt=""></p>
<p><a href="https://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">网易云课堂 - 顶尖中文大学计算机专业课程体系</a></p>
<ol>
<li>地址：<a href="https://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">https://study.163.com/curricula/cs.htm</a></li>
<li>介绍：汇集全国多家知名大学里广受学生好评的计算机老师，每一门课程都由他们亲自制作，权威、专业！人人都可以在这里体验到时下最流行的 MOOC，系统地掌握计算机专业知识。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-3100026e92aaee8c.png" alt=""></p>
<p><strong>and more…</strong></p>
<p>类似的资料有很多，重点还是要自己能够静得下心来学习，如果纠结「看书还是看视频」，我的建议是 <strong>「都看！」</strong>。</p>
<h4 id="不要在寝室学习"><a href="#不要在寝室学习" class="headerlink" title="不要在寝室学习"></a>不要在寝室学习</h4><p>宿舍里面吃的喝的玩的，要啥啥都有，而且环境复杂.. 很难不被各种奇怪的东西影响.. 所以要学习就不要呆在宿舍。</p>
<h2 id="对自己有更高的标准，才会有更多选择"><a href="#对自己有更高的标准，才会有更多选择" class="headerlink" title="对自己有更高的标准，才会有更多选择"></a>对自己有更高的标准，才会有更多选择</h2><blockquote>
<p>这里直接引用<a href="https://book.douban.com/subject/26761696/" target="_blank" rel="noopener">《精进》</a> 的段落。</p>
</blockquote>
<p>决策心理学认为，人在面临选择时，通常会采用 <strong>“满意原则”</strong>，而不是 <strong>“最优原则”</strong>。所谓 “满意原则”，就是人会从自己最熟悉的待选项开始逐一考察，如果发现了一个能满足内心标准的选项，觉得它是 <code>OK</code> 的，就会采纳它，不会继续寻找其他选项了。</p>
<p>拿怎样度过大学生涯来举例子。很多大一新生来到大学后，以为你刚刚从原本严苛的高中生活中解放出来，所以一时间不知道怎么适应大学生活，整天耽于玩乐，荒废了学业。本来他们完全可以选择认真地对待学习，可是他们却选择了相反的大学之路，其中一个最重要的原因就是没有在心中设立一个比较高的标准。</p>
<p>特别是那些考入二三流大学的学生，在这方面的问题可能更加严重，因为高考本身带来的挫败感、二三流高校学生的身份设定及环境暗示、不称职的老师引发的失望以及同学间放任自流气氛的带动作用，都容易让他们在一个低标准下自觉“满意”地度过每一天。</p>
<p><strong>一个成熟的人，他的标准来自他的内心，而大多数人，却受环境所左右</strong>。一个年轻人，进入一所不那么优秀的高校，对自己的标准会不由自主地降低以适应这个环境，减少自身与环境的冲突，而这种做法对他们的人生也许是致命的。一个二三流大学的学生，能够勇敢地以 “985” 高校学生中的中档乃至高档水准来要求自己才是更恰当的做法，他也一定会从中受益。</p>
<p>如果心中有了更高的标准，他甚至可以选择 “炒掉” 自己的学校、专业，打破旧环境的束缚，寻找更高层次的新环境，比如选择做这些事：</p>
<ol>
<li>选择网络上高水平的在线课程，不选择本校水平稀烂的课程；</li>
<li>选择国内或国外优秀的教材，不选择国内某些拼凑而成的注水教材；</li>
<li>选择与最优秀的同学或学长交流，不选择与班级里成天玩乐的同学为伍；</li>
<li>选择参加具有挑战性的各类竞赛，不选择只满足于完成基本的课程作业；</li>
<li>……</li>
</ol>
<p><strong>首先意识到你是有更多选择的，意识到现在环境给你的选项远远不是你可以获得的全部，然后你便可以让更高的标准推动着你，去发现更多的选项，最后做出对自己来说更好的选择</strong>。</p>
<p>这个方法，不论是对于什么身份、什么年龄、什么处境的人应该都是适用的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665516406&idx=1&sn=e6642108d466268b47b118d8143bd6f1&chksm=80d67535b7a1fc235c61db117588e583163eeb47e1ee7f1b78e0878a4e2c6d408a6357b792e7&mpshare=1&scene=1&srcid=%23rd" target="_blank" rel="noopener">千万别学计算机 | 码农翻身</a></li>
<li><a href="https://medium.com/@laioffer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E8%BF%98%E8%83%BD%E7%81%AB%E5%A4%9A%E4%B9%85-d093c765252b" target="_blank" rel="noopener">计算机行业还能火多久？</a></li>
<li><a href="https://www.infoq.cn/article/0iTzgfWTY8-ehJV5JoTO" target="_blank" rel="noopener">996.ICU 背后：程序员在互联网公司的真实生态 | InfoQ</a></li>
<li><a href="https://www.zhihu.com/question/22508677/answer/141334678" target="_blank" rel="noopener">编程到底难在哪？ | 知乎</a></li>
<li><a href="https://www.itcodemonkey.com/article/15470.html" target="_blank" rel="noopener">这篇写给想选计算机专业的学弟学妹们 | Crossin的编程教室</a></li>
<li><a href="http://www.ruanyifeng.com/survivor/collapse/university.html" target="_blank" rel="noopener">为什么你可以不读大学 | 阮一峰</a></li>
<li><a href="https://book.douban.com/review/9245959/" target="_blank" rel="noopener">从《大学之路》思考我的大学教育为什么失败？</a></li>
<li><a href="https://book.douban.com/review/8451017/" target="_blank" rel="noopener">纽曼+鸿堡 | 真正的大学生活</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=417056471&idx=1&sn=0ef5cbe0e336f34fc267f209b20d5379&scene=21#wechat_redirect" target="_blank" rel="noopener">学会编程，而不是学会Java</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E5%BD%93%E5%A4%A7%E5%AD%A6%E9%80%89%E6%8B%A9%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E5%90%8E%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/7896890-d00b6d33f7f28202.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/30/dong-yi-dian-qian-duan-vue-kuai-su-ru-men/">
      懂一点前端—Vue快速入门
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>前端/懂一点系列</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月30日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-1c02ae35202887d4.png" alt=""></p>
<h1 id="01-什么是-Vue"><a href="#01-什么是-Vue" class="headerlink" title="01. 什么是 Vue"></a>01. 什么是 Vue</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-028081a4f57de388.png" alt=""></p>
<p><strong>Vue</strong> <em>(读音 /vjuː/，类似于 view)</em> 是一套用于构建用户界面的渐进式框架，是当下很火的一个 <strong>JavaScript MVVM 库</strong>，是以 <strong>数据驱动和组件化</strong> 的思想构建的。</p>
<h2 id="MVVM-模式简述"><a href="#MVVM-模式简述" class="headerlink" title="MVVM 模式简述"></a>MVVM 模式简述</h2><p>下图不仅概括了 MVVM 模式 <em>（Model-View-ViewModel）</em>，还描述了在 Vue.js 中 ViewModel 是如何和 View 以及 Model 进行交互的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-ed4735335d7728b5.png" alt=""></p>
<p><strong>ViewModel 是 Vue.js 的核心</strong>，它是一个 Vue 实例。Vue 实例是作用于某一个 HTML 元素上的，这个元素可以是 HTML 的 <code>body</code> 元素，也可以是指定了 <code>id</code> 的某个元素。</p>
<p>当创建了 ViewModel 后，双向绑定是如何达成的呢？</p>
<p>首先，我们将上图中的 <em>DOM Listeners</em> 和 <em>Data Bindings</em> 看作两个工具，它们是实现双向绑定的关键。</p>
<ul>
<li>从 View 侧看，ViewModel 中的 DOM Listeners 工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；</li>
<li>从 Model 侧看，当我们更新 Model 中的数据时，Data Bindings 工具会帮我们更新页面中的 DOM 元素。</li>
</ul>
<h2 id="库和框架的区别"><a href="#库和框架的区别" class="headerlink" title="库和框架的区别"></a>库和框架的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-84681aa96817c873.png" alt=""></p>
<p>在这里我们需要稍微注意一下前端 <strong>库(Library)</strong> 和 <strong>框架(Framework)</strong> 的区别，它们的本质都是某人编写的，用于解决常见问题的 <strong>可复用代码</strong> 的集合。</p>
<p>比如，你有一个处理字符串的程序，你为了保持代码的 <strong>DRY</strong> <em>(Don’t Repeat Yourself)</em>，你编写了如下可复用的功能代码：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getWords</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> words <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> words<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">createSentence</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> sentence <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sentence<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>恭喜你，你创建了一个 JavaScript 库！</p>
<p>如果我们用 <em>「构建房子」</em> 来类比 <em>「构建应用」</em> 的话，那么 <strong>使用库</strong> 就像是 <strong>去宜家购物</strong> 一样，我已经有了一个家，现在我需要挑选自己喜欢的一些家具，以达到我自己满意的状态，这一切 <strong>都在我的控制范围之内</strong>；而 <strong>使用框架</strong> 就会像是已经有了一个 <strong>清装房</strong>，在已经规划好的蓝图和选择之中，我们的一些想法会显得十分地有限。</p>
<p><strong>Vue.js 本身只是一个 JavaScript 库</strong>，包括 React 也一样，只不过平时我们所说的 <strong>Vue 框架</strong>，是指包含 Router/ Vuex 等一系列组件之后融合的 <strong>一整套解决方案</strong>。</p>
<blockquote>
<p>更加详细的解释如下：</p>
<ul>
<li><strong>「库」</strong> 是一个封装好的特定的集合，提供给开发者使用，而且是特定于某一方面的集合（方法和函数），库没有控制权，控制权完全在于使用者本身；</li>
<li><strong>「框架」</strong> 顾名思义是一套架构，会基于自身的特点向用户提供一套比较完整的解决方案，如果使用者选定了一套框架，那么就需要根据框架本身做出一定的适应。</li>
</ul>
</blockquote>
<h1 id="02-为什么使用-Vue？"><a href="#02-为什么使用-Vue？" class="headerlink" title="02. 为什么使用 Vue？"></a>02. 为什么使用 Vue？</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-fb93d039c156554c.png" alt=""></p>
<p>说实话，我个人非常喜欢 Vue。在我大学刚尝试学习 HTML + CSS + JavaScript 和 Bootstrap 融合之后，我就接触了 Vue，它对我来说这样的「前端小白」来说，几乎没有什么开发的门槛，很平滑地就得以过渡到 Vue 的使用中去。</p>
<p>典型的 <code>.vue</code> 文件可以简单成如下的样子：<em>(vue-tutorial/typical-case.html)</em></p>
<pre class=" language-vue"><code class="language-vue"><template>
    <!-- HTML 代码 -->
</template>

<script>
    // JavaScript 代码
</script>

<style>
    /* css 代码 */
</style></code></pre>
<p>另外我也非常喜欢尤大大本人，大家可以去看一看 Honeypot 记录的关于 Vue 的 <a href="https://www.youtube.com/watch?v=OrxmtDw4pVI&t=7s" target="_blank" rel="noopener">纪录片</a> <em>(趁着写文的间隙我又看了一遍)</em>，当然如果英文有些吃力也可以围观一下在 B 站上的 <a href="https://www.bilibili.com/video/BV1L7411M7Ut?from=search&seid=11338729656895120592" target="_blank" rel="noopener">带中文字幕的版本</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-7079c8e45951e276.png" alt="B 站翻译版本截图"></p>
<blockquote>
<p>Vue 从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。———— 尤雨溪</p>
</blockquote>
<h2 id="理由一：易上手、学习曲线平滑"><a href="#理由一：易上手、学习曲线平滑" class="headerlink" title="理由一：易上手、学习曲线平滑"></a>理由一：易上手、学习曲线平滑</h2><p>就像上面的典型 <code>.vue</code> 文件的展示一样，在 Vue 中，一切都很自然，例如我们使用 Vue 来构建我们的 <strong>Hello World</strong> 程序：<em>(vue-tutorial/hello-vue.html)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Hello Vue!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    {{ message }}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token comment" spellcheck="true">// 创建一个 Vue 实例或者说是 VieModel 实例</span>
    <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            message<span class="token punctuation">:</span> <span class="token string">'Hello Vue!'</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>可以看到几乎没有多余的部分，只是在创建 Vue 实例时，把 <code>id</code> 为 <code>app</code> 的对象 <em>(此处为一个 <code>div</code>)</em> 绑定到了 Vue 实例中而已。</p>
<h2 id="理由二：文档友好"><a href="#理由二：文档友好" class="headerlink" title="理由二：文档友好"></a>理由二：文档友好</h2><p>由于 Vue 是国人编写的，所以在官网中有完整的中文文档可供开发者参考，并且借由尤大大出色的文笔，非常地清晰易懂，相信看过的朋友会和我有一样的感受：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-0057b8b7a94bccd7.png" alt="官方网站的文档"></p>
<blockquote>
<p>官方文档的地址可戳 <a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<h2 id="理由三：MVVM-天然的双向绑定"><a href="#理由三：MVVM-天然的双向绑定" class="headerlink" title="理由三：MVVM 天然的双向绑定"></a>理由三：MVVM 天然的双向绑定</h2><p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 JavaScript 库，这就让我们能够专注于 View 层的开发，这种轻量级的框架让前端开发更加高效、便捷。</p>
<p>例如，我们使用 <code>v-model</code> 来简单改造一下我们的 <code>hello-vue.html</code> 文件让它编程一个简单的双向绑定示例：<em>(vue-tutorial/v-model-demo.html)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ message }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>将 <code>message</code> 绑定到文本框，当更改文本框的值的时候， <code>&lt;p&gt;&lt;/p&gt;</code> 中的内容也会被更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-f0f4cecc0d5b2725.gif" alt=""></p>
<p>反过来如果我们更改 <code>message</code> 的值的话，文本框的值也会被更新，我们可以在控制台中尝试一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-5c118b0f35854dbd.gif" alt=""></p>
<h2 id="千万不要把框架能力看得比你解决问题的能力还重要"><a href="#千万不要把框架能力看得比你解决问题的能力还重要" class="headerlink" title="千万不要把框架能力看得比你解决问题的能力还重要"></a>千万不要把框架能力看得比你解决问题的能力还重要</h2><p>这里是借鉴了 <a href="https://www.zhihu.com/question/294210442" target="_blank" rel="noopener">知乎中的一个讨论</a>，不论是使用 React 还是 Vue，我们最终还是要以 <strong>解决实际的问题</strong> 为出发点。引用一下尤大大在 <a href="https://www.zhihu.com/question/301860721/answer/545031906" target="_blank" rel="noopener">知乎-Vue 和 React 的优点分别是什么？</a> 上的回答部分截取：</p>
<blockquote>
<p>说了这么多，无非是希望大家能停下来想想所谓的 ”A 技术比 B 技术牛逼“ 背后到底是在争些什么，我们使用这些技术的初衷又是什么。很多时候你说这方面，他说那方面，鸡同鸭讲，即使说到一起去，也往往缺乏对等的信息量或者基础共识，只是各自表达主观看法，最后变成两个阵营各自抱团取暖… 说到底，就算你证明了 A 比 B 牛逼，也不意味着你或者你的项目就牛逼了… 比起争这个，不如多想想怎么让自己变得更牛逼吧。—————— 尤雨溪</p>
</blockquote>
<h1 id="03-Vue-常用指令"><a href="#03-Vue-常用指令" class="headerlink" title="03. Vue 常用指令"></a>03. Vue 常用指令</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-be9c3c7d0f0fcbab.png" alt=""></p>
<p>上面我们已经实际体验了一个 Vue 的指令 <code>v-model</code> 了，在 Vue 中，指令都带有 <code>v-</code> 前缀，以表示它们是 Vue 提供的特殊的 <code>attribute</code>，它们会在渲染 DOM 时进行特殊的响应式行为。</p>
<p>Vue 内置了一些常用的指令，接下来我们将依次来介绍：</p>
<ul>
<li><code>v-if</code> 和 <code>v-else</code> 条件渲染指令；</li>
<li><code>v-show</code> 条件展示指令；</li>
<li><code>v-for</code> 列表渲染指令</li>
<li><code>v-bind</code> 条件绑定指令；</li>
<li><code>v-on</code> 事件处理指令；</li>
</ul>
<blockquote>
<p>大部分照搬的官方教程，写得非常具有参考性，感兴趣的朋友可以直接略过下面部分去参考 <a href="https://cn.vuejs.org/v2/guide" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<h2 id="v-if-和-v-else-条件渲染指令"><a href="#v-if-和-v-else-条件渲染指令" class="headerlink" title="v-if 和 v-else 条件渲染指令"></a>v-if 和 v-else 条件渲染指令</h2><h4 id="v-if-指令"><a href="#v-if-指令" class="headerlink" title="v-if 指令"></a>v-if 指令</h4><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>truthy</code> 值的时候被渲染。例如：<em>(vue-tutorial/v-if-demo)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>现在你看到我了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        seen<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>页面会正确的显示「现在你看到我了！」这几个字。</p>
<h4 id="v-else-指令"><a href="#v-else-指令" class="headerlink" title="v-else 指令"></a>v-else 指令</h4><p>你也可以使用 <code>v-else</code> 来添加一个 “else 块” 来表达条件不满足时应该渲染的模块：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>现在你看到我了！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>Oh no!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        seen<span class="token punctuation">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>此时条件 <code>seen</code> 不满足，页面就会显示「Oh no!」的字样。</p>
<h4 id="v-else-if-指令"><a href="#v-else-if-指令" class="headerlink" title="v-else-if 指令"></a>v-else-if 指令</h4><p>这是 <code>2.1.0</code> 版本新增的指令，充当 <code>v-if</code> 的 “else-if 块”，可以用来连续判断条件：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token punctuation">'</span>A<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  A
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token punctuation">'</span>B<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  B
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>type <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> <span class="token punctuation">'</span>C<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  C
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>
  Not A/B/C
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</p>
<h2 id="v-show-条件展示指令"><a href="#v-show-条件展示指令" class="headerlink" title="v-show 条件展示指令"></a>v-show 条件展示指令</h2><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ok<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre>
<p>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code> <em>(条件不满足则把元素 display 属性设置为 none)</em>，而 <code>v-if</code> 则在条件不满足时直接不渲染出对象。</p>
<h4 id="v-if-与-v-show"><a href="#v-if-与-v-show" class="headerlink" title="v-if 与 v-show"></a>v-if 与 v-show</h4><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是 <strong>惰性</strong> 的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
<h2 id="v-for-列表渲染指令"><a href="#v-for-列表渲染指令" class="headerlink" title="v-for 列表渲染指令"></a>v-for 列表渲染指令</h2><p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的别名。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in items<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    {{ item.message }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> example1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#example-1'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    items<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> message<span class="token punctuation">:</span> <span class="token string">'Foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> message<span class="token punctuation">:</span> <span class="token string">'Bar'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>结果：</p>
<ul>
<li>Foo</li>
<li>Bar</li>
</ul>
<blockquote>
<p><strong>注意：永远不要把 v-if 和 v-for 同时用在同一个元素上。</strong></p>
<p>因为当 Vue 处理指令时，<code>v-for</code> 比 <code>v-if</code> 拥有更高的优先级，所以会导致错误，详细的技术细节可以 <a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81" target="_blank" rel="noopener">戳这里</a></p>
</blockquote>
<h2 id="v-bind-条件绑定指令"><a href="#v-bind-条件绑定指令" class="headerlink" title="v-bind 条件绑定指令"></a>v-bind 条件绑定指令</h2><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：<em>(也可以用缩写 <code>:</code> 来替代 <code>v-bind</code> 指令)</em></p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ active: isActive }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据属性 <code>isActive</code> 的 <code>truthiness</code>。</p>
<p>你可以在对象中传入更多属性来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class 属性共存。当有如下模板：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>static<span class="token punctuation">"</span></span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ active: isActive, <span class="token punctuation">'</span>text-danger<span class="token punctuation">'</span>: hasError }<span class="token punctuation">"</span></span>
<span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>和如下 data：</p>
<pre class=" language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  isActive<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  hasError<span class="token punctuation">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span></code></pre>
<p>结果渲染为：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>static active<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p>
<h2 id="v-on-事件处理指令"><a href="#v-on-事件处理指令" class="headerlink" title="v-on 事件处理指令"></a>v-on 事件处理指令</h2><p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。<em>(也可以用缩写 <code>@</code> 来替代 <code>v-on</code> 指令)</em></p>
<p>示例：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>example-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>counter +<span class="token punctuation">=</span> 1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Add 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The button above has been clicked {{ counter }} times.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> example1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#example-1'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    counter<span class="token punctuation">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-72b4ee1014d5f762.gif" alt=""></p>
<h4 id="v-on-的事件修饰符"><a href="#v-on-的事件修饰符" class="headerlink" title="v-on 的事件修饰符"></a>v-on 的事件修饰符</h4><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 阻止单击事件继续传播 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.stop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThis<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 提交事件不再重载页面 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">v-on:</span>submit.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onSubmit<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 修饰符可以串联 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.stop.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 只有修饰符 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">v-on:</span>submit.prevent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 添加事件监听器时使用事件捕获模式 --></span>
<span class="token comment" spellcheck="true">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.capture</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThis<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --></span>
<span class="token comment" spellcheck="true">&lt;!-- 即事件不是从内部元素触发的 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click.self</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>doThat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre>
<blockquote>
<p>另外事件处理还可以支持 <strong>按键码</strong> <em>(某一个键按下)</em>、<strong>系统修饰符</strong> <em>(键盘鼠标按下)</em>，可以参看 <a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">官方教程</a></p>
</blockquote>
<h1 id="04-Todo-List-示例"><a href="#04-Todo-List-示例" class="headerlink" title="04. Todo-List 示例"></a>04. Todo-List 示例</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-17bf7a6193c7bf40.png" alt=""></p>
<p>上面我们了解了一些基本的指令了，接下来我们实际动动手，来搭建一个简单的 <strong>TodoList</strong> demo 小程序。</p>
<h2 id="第一步：明确需求"><a href="#第一步：明确需求" class="headerlink" title="第一步：明确需求"></a>第一步：明确需求</h2><p>TodoList 想必大家都很熟悉，使用来记录我们接下来要做的一些事情的程序，最基本的功能有增加和删除：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-87f3a4def16405b3.gif" alt=""></p>
<p>很简单，可以看出我们只需要一个输入框 <em>(用来记录将要保存的数据)<em>，一个按钮 *(用来添加数据)</em>，和一个集合 *(用来保存数据)</em> 就差不多可以了，上手！</p>
<h2 id="第二步：创建好需要的-data"><a href="#第二步：创建好需要的-data" class="headerlink" title="第二步：创建好需要的 data"></a>第二步：创建好需要的 data</h2><p>先来创建好我们需要的数据 data：</p>
<pre class=" language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    todos<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> nextTodoId<span class="token operator">++</span><span class="token punctuation">,</span>
            text<span class="token punctuation">:</span> <span class="token string">'写代码'</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> nextTodoId<span class="token operator">++</span><span class="token punctuation">,</span>
            text<span class="token punctuation">:</span> <span class="token string">'还是写代码'</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    newTodoText<span class="token punctuation">:</span> <span class="token string">""</span>
<span class="token punctuation">}</span></code></pre>
<p>这里多定义了 <code>id</code> 属性是为了方便我们的删除操作。</p>
<h2 id="第三步：创建好对应的-HTML"><a href="#第三步：创建好对应的-HTML" class="headerlink" title="第三步：创建好对应的 HTML"></a>第三步：创建好对应的 HTML</h2><p>没有任何布局，就直接定义好我们所需要的组件就好了：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newTodoText<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>添加<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in todos<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>{{ item.text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>removeItem(item.id)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>del<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre>
<p>没有任何的特别，只是里面包含了两个我们 <code>未定义</code> 的方法：<code>addItem</code> 和 <code>removeItem</code> 而已。</p>
<h2 id="第三步：定义并实现方法"><a href="#第三步：定义并实现方法" class="headerlink" title="第三步：定义并实现方法"></a>第三步：定义并实现方法</h2><p>Vue 中的方法需要定义在 Vue 实例的 <code>methods</code> 关键字下面：</p>
<pre class=" language-javascript"><code class="language-javascript">methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">addItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            id<span class="token punctuation">:</span> nextTodoId<span class="token punctuation">,</span>
            text<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newTodoText
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>newTodoText <span class="token operator">=</span> <span class="token string">""</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">removeItem</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>todos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>todo <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> todo<span class="token punctuation">.</span>id <span class="token operator">!==</span> id
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里数组的更新需要用到 <code>push</code>，另外删除时我们使用了一个 lambda 表达式来完成，删除时传入了一个要删除元素的 <code>id</code>，然后从数组中挑选出所有 <strong>不等于</strong> 这个 <code>id</code> 的元素重新赋值给原数组，这样就相当于是删除了元素了。</p>
<blockquote>
<p>本文涉及的所有代码都上传到了【More Than Java】项目中。<em>(地址下方)</em></p>
</blockquote>
<h2 id="更好的参考"><a href="#更好的参考" class="headerlink" title="更好的参考"></a>更好的参考</h2><p>上面的代码仅仅是简单实现，更好的参考可以查看 Vue 官方实现的一个更加具有参考性的例子：<a href="https://codesandbox.io/s/o29j95wx9" target="_blank" rel="noopener">https://codesandbox.io/s/o29j95wx9</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Vue【官方文档】 - <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li>
<li>【译】框架与库的差异 - <a href="https://juejin.im/post/5c5fe3e751882561dd7b4e9b" target="_blank" rel="noopener">https://juejin.im/post/5c5fe3e751882561dd7b4e9b</a></li>
<li>Vue.js——60分钟快速入门 - <a href="https://www.cnblogs.com/keepfool/p/5619070.html" target="_blank" rel="noopener">https://www.cnblogs.com/keepfool/p/5619070.html</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9%E5%89%8D%E7%AB%AF%E2%80%94Vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/25/dong-yi-dian-python-xi-lie-kuai-su-ru-men-1/">
      妈妈再也不担心我面试被Redis问得脸都绿了
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试/中间件</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月25日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-36f1278b896ced09.png" alt=""></p>
<blockquote>
<p>长文前排提醒，收藏向前排提醒，素质三连 <strong>(转发 + 在看 + 留言)</strong> 前排提醒！</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fbe27d1657e593c3.png" alt=""></p>
<p><strong>Redis</strong> 作为一个开源的，高级的键值存储和一个适用的解决方案，已经越来越在构建 <strong>「高性能」</strong>、<strong>「可扩展」</strong> 的 Web 应用上发挥着举足轻重的作用。</p>
<p>当今互联网技术架构中 <strong>Redis</strong> 已然成为了应用得最广泛的中间件之一，它也是中高级后端工程 <strong>技术面试</strong> 中面试官最喜欢问的工程技能之一，不仅仅要求着我们对 <strong>基本的使用</strong> 进行掌握，更要深层次地理解 Redis <strong>内部实现</strong> 的细节原理。</p>
<p>熟练掌握 Redis，甚至可以毫不夸张地说已经半只脚踏入心仪的公司了。下面我们一起来盘点回顾一下 Redis 的面试经典问题，就不要再被面试官问得 <strong>脸都绿了</strong> 呀！</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-62a9826a061d71dc.png" alt=""></p>
<ul>
<li><strong>Ps</strong>： 我把 <strong>重要的知识点</strong> 都做成了 <strong>图片</strong>，希望各位 <strong>“用餐愉快”</strong>。<em>(不错记得付餐费.. 点个赞留个言..)</em></li>
</ul>
<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4e434da31115b92d.png" alt=""></p>
<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><h4 id="先解释-Redis-基本概念"><a href="#先解释-Redis-基本概念" class="headerlink" title="先解释 Redis 基本概念"></a>先解释 Redis 基本概念</h4><p><strong>Redis</strong> (<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver) 是一个使用 <strong>C 语言</strong> 编写的，开源的 <em>(BSD许可)</em> 高性能 <strong>非关系型</strong> <em>(NoSQL)</em> 的 <strong>键值对数据库</strong>。</p>
<h4 id="简单提一下-Redis-数据结构"><a href="#简单提一下-Redis-数据结构" class="headerlink" title="简单提一下 Redis 数据结构"></a>简单提一下 Redis 数据结构</h4><p><strong>Redis</strong> 可以存储 <strong>键</strong> 和 <strong>不同类型数据结构值</strong> 之间的映射关系。键的类型只能是字符串，而值除了支持最 <strong>基础的五种数据类型</strong> 外，还支持一些 <strong>高级数据类型</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-ea1e1248cb5d8f88.png" alt=""></p>
<blockquote>
<p>一定要说出一些高级数据结构 <em>(当然你自己也要了解.. 下面会说到的别担心)</em>，这样面试官的眼睛才会亮。</p>
</blockquote>
<h4 id="Redis-小总结"><a href="#Redis-小总结" class="headerlink" title="Redis 小总结"></a>Redis 小总结</h4><p>与传统数据库不同的是 <strong>Redis</strong> 的数据是 <strong>存在内存</strong> 中的，所以 <strong>读写速度</strong> 非常 <strong>快</strong>，因此 Redis 被广泛应用于 <strong>缓存</strong> 方向，每秒可以处理超过 <code>10</code> 万次读写操作，是已知性能最快的 Key-Value 数据库。另外，Redis 也经常用来做 <strong>分布式锁</strong>。</p>
<p>除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h2 id="Redis-优缺点"><a href="#Redis-优缺点" class="headerlink" title="Redis 优缺点"></a>Redis 优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>读写性能优异</strong>， Redis能读的速度是 <code>110000</code> 次/s，写的速度是 <code>81000</code> 次/s。</li>
<li><strong>支持数据持久化</strong>，支持 AOF 和 RDB 两种持久化方式。</li>
<li><strong>支持事务</strong>，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</li>
<li><strong>数据结构丰富</strong>，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</li>
<li><strong>支持主从复制</strong>，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>数据库 <strong>容量受到物理内存的限制</strong>，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis <strong>不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了 <strong>系统的可用性</strong>。</li>
<li><strong>Redis 较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="为什么要用缓存？为什么使用-Redis？"><a href="#为什么要用缓存？为什么使用-Redis？" class="headerlink" title="为什么要用缓存？为什么使用 Redis？"></a>为什么要用缓存？为什么使用 Redis？</h2><h4 id="提一下现在-Web-应用的现状"><a href="#提一下现在-Web-应用的现状" class="headerlink" title="提一下现在 Web 应用的现状"></a>提一下现在 Web 应用的现状</h4><p>在日常的 Web 应用对数据库的访问中，<strong>读操作的次数远超写操作</strong>，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用 SQL 语句去数据库进行读写操作时，数据库就会 <strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p>
<h4 id="使用-Redis-or-使用缓存带来的优势"><a href="#使用-Redis-or-使用缓存带来的优势" class="headerlink" title="使用 Redis or 使用缓存带来的优势"></a>使用 Redis or 使用缓存带来的优势</h4><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样 <strong>速度</strong> 明显就会快上不少 <em>(高性能)</em>，并且会 <strong>极大减小数据库的压力</strong> <em>(特别是在高并发情况下)</em>。</p>
<blockquote>
<p>记得是 <strong>两个角度</strong> 啊.. <strong>高性能</strong> 和 <strong>高并发</strong>..</p>
</blockquote>
<h4 id="也要提一下使用缓存的考虑"><a href="#也要提一下使用缓存的考虑" class="headerlink" title="也要提一下使用缓存的考虑"></a>也要提一下使用缓存的考虑</h4><p>但是使用内存进行数据存储开销也是比较大的，<strong>限于成本</strong> 的原因，一般我们只是使用 Redis 存储一些 <strong>常用和主要的数据</strong>，比如用户登录的信息等。</p>
<p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p>
<ul>
<li><strong>业务数据常用吗？命中率如何？</strong> 如果命中率很低，就没有必要写入缓存；</li>
<li><strong>该业务数据是读操作多，还是写操作多？</strong> 如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li>
<li><strong>业务数据大小如何？</strong> 如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li>
</ul>
<p>在考虑了这些问题之后，如果觉得有必要使用缓存，那么就使用它！</p>
<h2 id="使用缓存会出现什么问题？"><a href="#使用缓存会出现什么问题？" class="headerlink" title="使用缓存会出现什么问题？"></a>使用缓存会出现什么问题？</h2><p>一般来说有如下几个问题，回答思路遵照 <strong>是什么</strong> → <strong>为什么</strong> → <strong>怎么解决</strong>：</p>
<ol>
<li>缓存雪崩问题；</li>
<li>缓存穿透问题；</li>
<li>缓存和数据库双写一致性问题；</li>
</ol>
<h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-891c01ada1be7099.png" alt=""></p>
<p>另外对于 <strong>“Redis 挂掉了，请求全部走数据库”</strong> 这样的情况，我们还可以有如下的思路：</p>
<ul>
<li><strong>事发前</strong>：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。</li>
<li><strong>事发中</strong>：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li>
<li><strong>事发后</strong>：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-aa9398e52cf83891.png" alt=""></p>
<h4 id="缓存与数据库双写一致问题"><a href="#缓存与数据库双写一致问题" class="headerlink" title="缓存与数据库双写一致问题"></a>缓存与数据库双写一致问题</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-1c3e67935d7763d4.png" alt=""></p>
<p>双写一致性上图还是稍微粗糙了些，你还需要知道两种方案 <em>(先操作数据库和先操作缓存)</em> 分别都有什么优势和对应的问题，这里不作赘述，可以参考一下下方的文章，写得非常详细。</p>
<blockquote>
<ul>
<li>面试前必须要知道的Redis面试题 | Java3y - <a href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么早期版本选择单线程？"><a href="#Redis-为什么早期版本选择单线程？" class="headerlink" title="Redis 为什么早期版本选择单线程？"></a>Redis 为什么早期版本选择单线程？</h2><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p>因为 Redis 是基于内存的操作，<strong>CPU 不是 Redis 的瓶颈</strong>，Redis 的瓶颈最有可能是 <strong>机器内存的大小</strong> 或者 <strong>网络带宽</strong>。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h4 id="简单总结一下"><a href="#简单总结一下" class="headerlink" title="简单总结一下"></a>简单总结一下</h4><ol>
<li>使用单线程模型能带来更好的 <strong>可维护性</strong>，方便开发和调试；</li>
<li>使用单线程模型也能 <strong>并发</strong> 的处理客户端的请求；<em>(I/O 多路复用机制)</em></li>
<li>Redis 服务中运行的绝大多数操作的 <strong>性能瓶颈都不是 CPU</strong>；</li>
</ol>
<blockquote>
<p><strong>强烈推荐</strong> 各位亲看一下这篇文章：</p>
<ul>
<li>为什么 Redis 选择单线程模型 · Why’s THE Design? - <a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener">https://draveness.me/whys-the-design-redis-single-thread</a></li>
</ul>
</blockquote>
<h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><p>简单总结：</p>
<ol>
<li><strong>纯内存操作</strong>：读取不需要进行磁盘 I/O，所以比传统数据库要快上不少；<em>(但不要有误区说磁盘就一定慢，例如 Kafka 就是使用磁盘顺序读取但仍然较快)</em></li>
<li><strong>单线程，无锁竞争</strong>：这保证了没有线程的上下文切换，不会因为多线程的一些操作而降低性能；</li>
<li><strong>多路 I/O 复用模型，非阻塞 I/O</strong>：采用多路 I/O 复用技术可以让单个线程高效的处理多个网络连接请求（尽量减少网络 IO 的时间消耗）；</li>
<li><strong>高效的数据结构，加上底层做了大量优化</strong>：Redis 对于底层的数据结构和内存占用做了大量的优化，例如不同长度的字符串使用不同的结构体表示，HyperLogLog 的密集型存储结构等等..</li>
</ol>
<h1 id="二、数据结构篇"><a href="#二、数据结构篇" class="headerlink" title="二、数据结构篇"></a>二、数据结构篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-68ecbdc6cf4c5588.png" alt=""></p>
<h2 id="简述一下-Redis-常用数据结构及实现？"><a href="#简述一下-Redis-常用数据结构及实现？" class="headerlink" title="简述一下 Redis 常用数据结构及实现？"></a>简述一下 Redis 常用数据结构及实现？</h2><p>首先在 Redis 内部会使用一个 <strong>RedisObject</strong> 对象来表示所有的 <code>key</code> 和 <code>value</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-16511ec4f7f30569.png" alt=""></p>
<p>其次 Redis 为了 <strong>平衡空间和时间效率</strong>，针对 <code>value</code> 的具体类型在底层会采用不同的数据结构来实现，下图展示了他们之间的映射关系：<em>(好像乱糟糟的，但至少能看清楚..)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-0801fee369ecca97.png" alt=""></p>
<h2 id="Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>Redis 的 SDS 和 C 中字符串相比有什么优势？</h2><h4 id="先简单总结一下"><a href="#先简单总结一下" class="headerlink" title="先简单总结一下"></a>先简单总结一下</h4><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 <strong>不符合 Redis 对字符串在安全性、效率以及功能方面的要求</strong>。</p>
<h4 id="再来说-C-语言字符串的问题"><a href="#再来说-C-语言字符串的问题" class="headerlink" title="再来说 C 语言字符串的问题"></a>再来说 C 语言字符串的问题</h4><p>这样简单的数据结构可能会造成以下一些问题：</p>
<ul>
<li><strong>获取字符串长度为 O(N) 级别的操作</strong> → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组；</li>
<li>不能很好的杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；</li>
<li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li>
</ul>
<h4 id="Redis-如何解决的-SDS-的优势"><a href="#Redis-如何解决的-SDS-的优势" class="headerlink" title="Redis 如何解决的 | SDS 的优势"></a>Redis 如何解决的 | SDS 的优势</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9570ea52d515e1cb.png" alt=""></p>
<p>如果去看 Redis 的源码 <code>sds.h/sdshdr</code> 文件，你会看到 SDS 完整的实现细节，这里简单来说一下 Redis 如何解决的：</p>
<ol>
<li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li>
<li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的覆盖情况；</li>
<li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li>
<li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li>
</ol>
<h2 id="字典是如何实现的？Rehash-了解吗？"><a href="#字典是如何实现的？Rehash-了解吗？" class="headerlink" title="字典是如何实现的？Rehash 了解吗？"></a>字典是如何实现的？Rehash 了解吗？</h2><h4 id="先总体聊一下-Redis-中的字典"><a href="#先总体聊一下-Redis-中的字典" class="headerlink" title="先总体聊一下 Redis 中的字典"></a>先总体聊一下 Redis 中的字典</h4><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p>
<h4 id="说明字典内部结构和-rehash"><a href="#说明字典内部结构和-rehash" class="headerlink" title="说明字典内部结构和 rehash"></a>说明字典内部结构和 rehash</h4><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的 <strong>链地址法</strong> 来解决部分 哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p>
<p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个 <code>hashtable</code> 有值，但是在字典扩容缩容时，需要分配新的 <code>hashtable</code>，然后进行 <strong>渐进式搬迁</strong> <em>(rehash)</em>，这时候两个 <code>hashtable</code> 分别存储旧的和新的 <code>hashtable</code>，待搬迁结束后，旧的将被删除，新的 <code>hashtable</code> 取而代之。</p>
<h4 id="扩缩容的条件"><a href="#扩缩容的条件" class="headerlink" title="扩缩容的条件"></a>扩缩容的条件</h4><p>正常情况下，当 hash 表中 <strong>元素的个数等于第一维数组的长度时</strong>，就会开始扩容，扩容的新数组是 <strong>原数组大小的 2 倍</strong>。不过如果 Redis 正在做 <code>bgsave(持久化命令)</code>，为了减少内存也得过多分离，Redis 尽量不去扩容，但是如果 hash 表非常满了，<strong>达到了第一维数组长度的 5 倍了</strong>，这个时候就会 <strong>强制扩容</strong>。</p>
<p>当 hash 表因为元素逐渐被删除变得越来越稀疏时，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。所用的条件是 <strong>元素个数低于数组长度的 10%</strong>，缩容不会考虑 Redis 是否在做 <code>bgsave</code>。</p>
<h2 id="跳跃表是如何实现的？原理？"><a href="#跳跃表是如何实现的？原理？" class="headerlink" title="跳跃表是如何实现的？原理？"></a>跳跃表是如何实现的？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9e9cbfe4fc061f3.png" alt=""></p>
<blockquote>
<p>这是 Redis 中比较重要的一个数据结构，<strong>建议阅读</strong> 之前写过的文章，里面详细介绍了原理和一些细节：</p>
<ul>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
</ul>
</blockquote>
<h2 id="HyperLogLog-有了解吗？"><a href="#HyperLogLog-有了解吗？" class="headerlink" title="HyperLogLog 有了解吗？"></a>HyperLogLog 有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
</ul>
</blockquote>
<h2 id="布隆过滤器有了解吗？"><a href="#布隆过滤器有了解吗？" class="headerlink" title="布隆过滤器有了解吗？"></a>布隆过滤器有了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
</ul>
</blockquote>
<h2 id="GeoHash-了解吗？"><a href="#GeoHash-了解吗？" class="headerlink" title="GeoHash 了解吗？"></a>GeoHash 了解吗？</h2><blockquote>
<p><strong>建议阅读</strong> 之前的系列文章：</p>
<ul>
<li>Redis(6)——GeoHash查找附近的人 - <a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
</ul>
</blockquote>
<h2 id="压缩列表了解吗？"><a href="#压缩列表了解吗？" class="headerlink" title="压缩列表了解吗？"></a>压缩列表了解吗？</h2><p>这是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，<strong>zset</strong> 和 <strong>hash</strong> 容器对象会在元素个数较少的时候，采用压缩列表（ziplist）进行存储。压缩列表是 <strong>一块连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。</p>
<blockquote>
<p>因为之前自己也没有学习过，所以找了一篇比较好比较容易理解的文章：</p>
<ul>
<li>图解Redis之数据结构篇——压缩列表 - <a href="https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nba0FUEAVRs0vi24KUoyQg</a></li>
<li>这一篇稍微底层稍微硬核一点：<a href="http://www.web-lovers.com/redis-source-ziplist.html" target="_blank" rel="noopener">http://www.web-lovers.com/redis-source-ziplist.html</a></li>
</ul>
</blockquote>
<h2 id="快速列表-quicklist-了解吗？"><a href="#快速列表-quicklist-了解吗？" class="headerlink" title="快速列表 quicklist 了解吗？"></a>快速列表 quicklist 了解吗？</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p>
<p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>。</p>
<blockquote>
<p>同上..建议阅读一下以下的文章：</p>
<ul>
<li>Redis列表list 底层原理 - <a href="https://zhuanlan.zhihu.com/p/102422311" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102422311</a></li>
</ul>
</blockquote>
<h2 id="Stream-结构有了解吗？"><a href="#Stream-结构有了解吗？" class="headerlink" title="Stream 结构有了解吗？"></a>Stream 结构有了解吗？</h2><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-b9d8afde068a165f.png" alt=""></p>
<p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p>
<ul>
<li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li>
<li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li>
<li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li>
</ul>
<h4 id="Stream-消息太多怎么办？"><a href="#Stream-消息太多怎么办？" class="headerlink" title="Stream 消息太多怎么办？"></a>Stream 消息太多怎么办？</h4><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p>
<p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> XADD mystream MAXLEN 2 * value 1
1526654998691-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 2
1526654999635-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 3
1526655000369-0
<span class="token operator">></span> XLEN mystream
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token operator">></span> XRANGE mystream - +
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526654999635-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526655000369-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p>
<p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p>
<pre class=" language-bash"><code class="language-bash">XADD mystream MAXLEN ~ 1000 * <span class="token punctuation">..</span>. entry fields here <span class="token punctuation">..</span>.</code></pre>
<p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p>
<h4 id="PEL-是如何避免消息丢失的？"><a href="#PEL-是如何避免消息丢失的？" class="headerlink" title="PEL 是如何避免消息丢失的？"></a>PEL 是如何避免消息丢失的？</h4><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p>
<h4 id="和-Kafka-对比起来呢？"><a href="#和-Kafka-对比起来呢？" class="headerlink" title="和 Kafka 对比起来呢？"></a>和 Kafka 对比起来呢？</h4><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p>
<p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p>
<blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章，里面 <strong>也对 Pub/ Sub 做了详细的描述</strong>：</p>
<ul>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ul>
</blockquote>
<h1 id="三、持久化篇"><a href="#三、持久化篇" class="headerlink" title="三、持久化篇"></a>三、持久化篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-54bd130bf8e635e0.png" alt=""></p>
<h2 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h2><h4 id="先简单谈一谈是什么"><a href="#先简单谈一谈是什么" class="headerlink" title="先简单谈一谈是什么"></a>先简单谈一谈是什么</h4><p><strong>Redis</strong> 的数据 <strong>全部存储</strong> 在 <strong>内存</strong> 中，如果 <strong>突然宕机</strong>，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 <strong>持久化机制</strong>，它会将内存中的数据库状态 <strong>保存到磁盘</strong> 中。</p>
<h4 id="解释一下持久化发生了什么"><a href="#解释一下持久化发生了什么" class="headerlink" title="解释一下持久化发生了什么"></a>解释一下持久化发生了什么</h4><p>我们来稍微考虑一下 <strong>Redis</strong> 作为一个 <strong>“内存数据库”</strong> 要做的关于持久化的事情。通常来说，从客户端发起请求开始，到服务器真实地写入磁盘，需要发生如下几件事情：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-5c209bc08da11abb.png" alt=""></p>
<p><strong>详细版</strong> 的文字描述大概就是下面这样：</p>
<ol>
<li>客户端向数据库 <strong>发送写命令</strong> <em>(数据在客户端的内存中)</em></li>
<li>数据库 <strong>接收</strong> 到客户端的 <strong>写请求</strong> <em>(数据在服务器的内存中)</em></li>
<li>数据库 <strong>调用系统 API</strong> 将数据写入磁盘 <em>(数据在内核缓冲区中)</em></li>
<li>操作系统将 <strong>写缓冲区</strong> 传输到 <strong>磁盘控控制器</strong> <em>(数据在磁盘缓存中)</em></li>
<li>操作系统的磁盘控制器将数据 <strong>写入实际的物理媒介</strong> 中 <em>(数据在磁盘中)</em></li>
</ol>
<h4 id="分析如何保证持久化安全"><a href="#分析如何保证持久化安全" class="headerlink" title="分析如何保证持久化安全"></a>分析如何保证持久化安全</h4><p>如果我们故障仅仅涉及到 <strong>软件层面</strong> <em>(该进程被管理员终止或程序崩溃)</em> 并且没有接触到内核，那么在 <em>上述步骤 3</em> 成功返回之后，我们就认为成功了。即使进程崩溃，操作系统仍然会帮助我们把数据正确地写入磁盘。</p>
<p>如果我们考虑 <strong>停电/ 火灾</strong> 等 <strong>更具灾难性</strong> 的事情，那么只有在完成了第 <strong>5</strong> 步之后，才是安全的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-de083f477fe1bce4.png" alt="机房”火了“"></p>
<p>所以我们可以总结得出数据安全最重要的阶段是：<strong>步骤三、四、五</strong>，即：</p>
<ul>
<li>数据库软件调用写操作将用户空间的缓冲区转移到内核缓冲区的频率是多少？</li>
<li>内核多久从缓冲区取数据刷新到磁盘控制器？</li>
<li>磁盘控制器多久把数据写入物理媒介一次？</li>
<li><strong>注意：</strong> 如果真的发生灾难性的事件，我们可以从上图的过程中看到，任何一步都可能被意外打断丢失，所以只能 <strong>尽可能地保证</strong> 数据的安全，这对于所有数据库来说都是一样的。</li>
</ul>
<p>我们从 <strong>第三步</strong> 开始。Linux 系统提供了清晰、易用的用于操作文件的 <code>POSIX file API</code>，<code>20</code> 多年过去，仍然还有很多人对于这一套 <code>API</code> 的设计津津乐道，我想其中一个原因就是因为你光从 <code>API</code> 的命名就能够很清晰地知道这一套 API 的用途：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">/*,mode_t mode */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">close</span> <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fname <span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fildes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbyte<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>参考自：API 设计最佳实践的思考 - <a href="https://www.cnblogs.com/yuanjiangw/p/10846560.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanjiangw/p/10846560.html</a></li>
</ul>
<p>所以，我们有很好的可用的 <code>API</code> 来完成 <strong>第三步</strong>，但是对于成功返回之前，我们对系统调用花费的时间没有太多的控制权。</p>
<p>然后我们来说说 <strong>第四步</strong>。我们知道，除了早期对电脑特别了解那帮人 <em>(操作系统就这帮人搞的)</em>，实际的物理硬件都不是我们能够 <strong>直接操作</strong> 的，都是通过 <strong>操作系统调用</strong> 来达到目的的。为了防止过慢的 I/O 操作拖慢整个系统的运行，操作系统层面做了很多的努力，譬如说 <strong>上述第四步</strong> 提到的 <strong>写缓冲区</strong>，并不是所有的写操作都会被立即写入磁盘，而是要先经过一个缓冲区，默认情况下，Linux 将在 <strong>30 秒</strong> 后实际提交写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c08b7572ef02d67b.jpg" alt=""></p>
<p>但是很明显，<strong>30 秒</strong> 并不是 Redis 能够承受的，这意味着，如果发生故障，那么最近 30 秒内写入的所有数据都可能会丢失。幸好 <code>PROSIX API</code> 提供了另一个解决方案：<code>fsync</code>，该命令会 <strong>强制</strong> 内核将 <strong>缓冲区</strong> 写入 <strong>磁盘</strong>，但这是一个非常消耗性能的操作，每次调用都会 <strong>阻塞等待</strong> 直到设备报告 IO 完成，所以一般在生产环境的服务器中，<strong>Redis</strong> 通常是每隔 1s 左右执行一次 <code>fsync</code> 操作。</p>
<p>到目前为止，我们了解到了如何控制 <code>第三步</code> 和 <code>第四步</code>，但是对于 <strong>第五步</strong>，我们 <strong>完全无法控制</strong>。也许一些内核实现将试图告诉驱动实际提交物理介质上的数据，或者控制器可能会为了提高速度而重新排序写操作，不会尽快将数据真正写到磁盘上，而是会等待几个多毫秒。这完全是我们无法控制的。</p>
<blockquote>
<p>普通人简单说一下第一条就过了，如果你详细地对后面两方面 <strong>侃侃而谈</strong>，那面试官就会对你另眼相看了。</p>
</blockquote>
<h2 id="Redis-中的两种持久化方式？"><a href="#Redis-中的两种持久化方式？" class="headerlink" title="Redis 中的两种持久化方式？"></a>Redis 中的两种持久化方式？</h2><h4 id="方式一：快照"><a href="#方式一：快照" class="headerlink" title="方式一：快照"></a>方式一：快照</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-9a4d234c53120b33.gif" alt=""></p>
<p><strong>Redis 快照</strong> 是最简单的 Redis 持久性模式。当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 <code>100</code> 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 <code>.rdb</code> 文件生成。</p>
<h4 id="方式二：AOF"><a href="#方式二：AOF" class="headerlink" title="方式二：AOF"></a>方式二：AOF</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-e4e08ebef2cf0144.gif" alt=""></p>
<p><strong>快照不是很持久</strong>。如果运行 Redis 的计算机停止运行，电源线出现故障或者您 <code>kill -9</code> 的实例意外发生，则写入 Redis 的最新数据将丢失。尽管这对于某些应用程序可能不是什么大问题，但有些使用案例具有充分的耐用性，在这些情况下，快照并不是可行的选择。</p>
<p><strong>AOF(Append Only File - 仅追加文件)</strong> 它的工作方式非常简单：每次执行 <strong>修改内存</strong> 中数据集的写操作时，都会 <strong>记录</strong> 该操作。假设 AOF 日志记录了自 Redis 实例创建以来 <strong>所有的修改性指令序列</strong>，那么就可以通过对一个空的 Redis 实例 <strong>顺序执行所有的指令</strong>，也就是 <strong>「重放」</strong>，来恢复 Redis 当前实例的内存数据结构的状态。</p>
<h4 id="Redis-4-0-的混合持久化"><a href="#Redis-4-0-的混合持久化" class="headerlink" title="Redis 4.0 的混合持久化"></a>Redis 4.0 的混合持久化</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-7de9f7706be6216c.gif" alt=""></p>
<p>重启 Redis 时，我们很少使用 <code>rdb</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>rdb</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p>
<p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-2f7887f84eaa34d9.png" alt=""></p>
<p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<blockquote>
<p>关于两种持久化方式的更多细节 <em>(原理)</em> 可以参考：</p>
<ul>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
</ul>
</blockquote>
<h2 id="RDB-和-AOF-各自有什么优缺点？"><a href="#RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="RDB 和 AOF 各自有什么优缺点？"></a>RDB 和 AOF 各自有什么优缺点？</h2><h4 id="RDB-优点"><a href="#RDB-优点" class="headerlink" title="RDB | 优点"></a>RDB | 优点</h4><ol>
<li>只有一个文件 <code>dump.rdb</code>，<strong>方便持久化</strong>。</li>
<li><strong>容灾性好</strong>，一个文件可以保存到安全的磁盘。</li>
<li><strong>性能最大化</strong>，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能</li>
<li>相对于数据集大时，比 AOF 的 <strong>启动效率</strong> 更高。</li>
</ol>
<h4 id="RDB-缺点"><a href="#RDB-缺点" class="headerlink" title="RDB | 缺点"></a>RDB | 缺点</h4><ol>
<li><strong>数据安全性低</strong>。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候；</li>
</ol>
<h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF | 优点"></a>AOF | 优点</h4><ol>
<li><strong>数据安全</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li>
</ol>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF | 缺点"></a>AOF | 缺点</h4><ol>
<li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li>
<li><strong>数据集大</strong> 的时候，比 rdb <strong>启动效率低</strong>。</li>
</ol>
<h2 id="两种方式如何选择？"><a href="#两种方式如何选择？" class="headerlink" title="两种方式如何选择？"></a>两种方式如何选择？</h2><ul>
<li>一般来说， 如果想达到足以媲美 PostgreSQL 的 <strong>数据安全性</strong>，你应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li>
<li>如果你非常关心你的数据， 但仍然 <strong>可以承受数分钟以内的数据丢失</strong>，那么你可以 <strong>只使用 RDB 持久化</strong>。</li>
<li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li>
<li>如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
</ul>
<h2 id="Redis-的数据恢复"><a href="#Redis-的数据恢复" class="headerlink" title="Redis 的数据恢复"></a>Redis 的数据恢复</h2><p><strong>Redis</strong> 的数据恢复有着如下的优先级：</p>
<ol>
<li>如果只配置 AOF ，重启时加载 AOF 文件恢复数据；</li>
<li>如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；</li>
<li>如果只配置 RDB，启动将加载 dump 文件恢复数据。</li>
</ol>
<p>拷贝 <strong>AOF</strong> 文件到 Redis 的数据目录，启动 redis-server AOF 的数据恢复过程：Redis 虚拟一个客户端，读取 AOF 文件恢复 Redis 命令和参数，然后执行命令从而恢复数据，这些过程主要在 <code>loadAppendOnlyFile()</code> 中实现。</p>
<p>拷贝 <strong>RDB</strong> 文件到 Redis 的数据目录，启动 redis-server 即可，因为 RDB 文件和重启前保存的是真实数据而不是命令状态和参数。</p>
<h1 id="四、集群篇"><a href="#四、集群篇" class="headerlink" title="四、集群篇"></a>四、集群篇</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-83a0181f29cccb73.png" alt=""></p>
<h2 id="主从同步了解吗？"><a href="#主从同步了解吗？" class="headerlink" title="主从同步了解吗？"></a>主从同步了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。</p>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="哨兵模式了解吗？"><a href="#哨兵模式了解吗？" class="headerlink" title="哨兵模式了解吗？"></a>哨兵模式了解吗？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h4><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<blockquote>
<p>更多细节 <strong>推荐阅读</strong> 之前的系列文章，不仅有原理讲解，还有实战环节：</p>
<ul>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">https://www.wmyskxz.com/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/</a></li>
</ul>
</blockquote>
<h2 id="Redis-集群使用过吗？原理？"><a href="#Redis-集群使用过吗？原理？" class="headerlink" title="Redis 集群使用过吗？原理？"></a>Redis 集群使用过吗？原理？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="集群中数据如何分区？"><a href="#集群中数据如何分区？" class="headerlink" title="集群中数据如何分区？"></a>集群中数据如何分区？</h2><p>Redis 采用方案三。</p>
<h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点之间的通信机制了解吗？"><a href="#节点之间的通信机制了解吗？" class="headerlink" title="节点之间的通信机制了解吗？"></a>节点之间的通信机制了解吗？</h2><p>集群的建立离不开节点之间的通信，例如我们在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="集群数据如何存储的有了解吗？"><a href="#集群数据如何存储的有了解吗？" class="headerlink" title="集群数据如何存储的有了解吗？"></a>集群数据如何存储的有了解吗？</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<h1 id="五、其他问题"><a href="#五、其他问题" class="headerlink" title="五、其他问题"></a>五、其他问题</h1><h2 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h2><blockquote>
<p><strong>推荐阅读</strong> 之前的系列文章：<br>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></p>
</blockquote>
<h2 id="Redis-过期键的删除策略？"><a href="#Redis-过期键的删除策略？" class="headerlink" title="Redis 过期键的删除策略？"></a>Redis 过期键的删除策略？</h2><h4 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h4><p>先抛开 Redis 想一下几种可能的删除策略：</p>
<ol>
<li><strong>定时删除</strong>:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</li>
<li><strong>定期删除</strong>:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ol>
<p>在上述的三种策略中定时删除和定期删除属于不同时间粒度的 <strong>主动删除</strong>，惰性删除属于 <strong>被动删除</strong>。</p>
<h4 id="三种策略都有各自的优缺点"><a href="#三种策略都有各自的优缺点" class="headerlink" title="三种策略都有各自的优缺点"></a>三种策略都有各自的优缺点</h4><ol>
<li>定时删除对内存使用率有优势，但是对 CPU 不友好；</li>
<li>惰性删除对内存不友好，如果某些键值对一直不被使用，那么会造成一定量的内存浪费；</li>
<li>定期删除是定时删除和惰性删除的折中。</li>
</ol>
<h4 id="Redis-中的实现"><a href="#Redis-中的实现" class="headerlink" title="Redis 中的实现"></a>Redis 中的实现</h4><p>Reids 采用的是 <strong>惰性删除和定时删除</strong> 的结合，一般来说可以借助最小堆来实现定时器，不过 Redis 的设计考虑到时间事件的有限种类和数量，使用了无序链表存储时间事件，这样如果在此基础上实现定时删除，就意味着 <code>O(N)</code> 遍历获取最近需要删除的数据。</p>
<h2 id="Redis-的淘汰策略有哪些？"><a href="#Redis-的淘汰策略有哪些？" class="headerlink" title="Redis 的淘汰策略有哪些？"></a>Redis 的淘汰策略有哪些？</h2><h4 id="Redis-有六种淘汰策略"><a href="#Redis-有六种淘汰策略" class="headerlink" title="Redis 有六种淘汰策略"></a>Redis 有六种淘汰策略</h4><table>
<thead>
<tr>
<th align="left">策略</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">volatile-lru</td>
<td align="left">从已设置过期时间的 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-ttl</td>
<td align="left">从已设置过期时间的 KV 集中优先对剩余时间短(time to live)的数据淘汰</td>
</tr>
<tr>
<td align="left">volitile-random</td>
<td align="left">从已设置过期时间的 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">allkeys-lru</td>
<td align="left">从所有 KV 集中优先对最近最少使用(less recently used)的数据淘汰</td>
</tr>
<tr>
<td align="left">allKeys-random</td>
<td align="left">从所有 KV 集中随机选择数据淘汰</td>
</tr>
<tr>
<td align="left">noeviction</td>
<td align="left">不淘汰策略，若超过最大内存，返回错误信息</td>
</tr>
</tbody></table>
<h4 id="4-0-版本后增加以下两种"><a href="#4-0-版本后增加以下两种" class="headerlink" title="4.0 版本后增加以下两种"></a>4.0 版本后增加以下两种</h4><ul>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<h2 id="More"><a href="#More" class="headerlink" title="More.."></a>More..</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>3w字深度好文|Redis面试全攻略，读完这个就可以和面试官大战几个回合了 - <a href="https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w</a></li>
<li>大厂面试！我和面试官之间关于Redis的一场对弈！ - <a href="https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g</a></li>
<li>Redis面试题（2020最新版） - <a href="https://blog.csdn.net/ThinkWon/article/details/103522351" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/103522351</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E5%A6%88%E5%A6%88%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%8B%85%E5%BF%83%E6%88%91%E9%9D%A2%E8%AF%95%E8%A2%ABRedis%E9%97%AE%E5%BE%97%E8%84%B8%E9%83%BD%E7%BB%BF%E4%BA%86/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/23/dong-yi-dian-python-xi-lie-kuai-su-ru-men/">
      懂一点Python系列——快速入门
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>Python/懂一点系列</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月23日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-71e6f0dcd9d841a5.png" alt=""></p>
<blockquote>
<p>本文面相有 <strong>一定编程基础</strong> 的朋友学习，所以略过了 <em>环境安装<em>、</em>IDE 搭建</em> 等一系列简单繁琐的事情。</p>
</blockquote>
<h1 id="一、Python-简介"><a href="#一、Python-简介" class="headerlink" title="一、Python 简介"></a>一、Python 简介</h1><p><strong>Python</strong> 英文原意为 <strong>“蟒蛇”</strong>，直到 <code>1989</code> 年荷兰人 <strong>Guido van Rossum</strong> （简称 Guido）发明了一种 <strong>面向对象</strong> 的 <strong>解释型</strong> 编程语言，并将其命名为  Python，才赋予了它表示一门编程语言的含义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-8cc9b31907c8afca.png" alt=""></p>
<blockquote>
<p>说到 Python 的诞生，极具戏剧色彩，据 Guido 的自述记载，Python 语言是他在圣诞节期间为了打发时间开发出来的，之所以会选择 Python 作为该编程语言的名字，是因为他是一个叫 Monty Python 戏剧团体的忠实粉丝。</p>
</blockquote>
<h2 id="解释型-vs-编译型"><a href="#解释型-vs-编译型" class="headerlink" title="解释型 vs 编译型"></a>解释型 vs 编译型</h2><p>作为电子元器件的 <strong>计算机</strong>，实际上 <strong>只能</strong> 识别某些 <strong>特定的二进制指令</strong> <em>(特殊的 <code>01</code> 组合)</em>，但由于 <strong>人类阅读</strong> 这些 <strong>指令</strong> 非常难以阅读，加上使用这些指令编写程序的 <strong>耗时</strong> 太过于 <strong>冗长</strong>，所以，人们在此基础上再次制定了一套规范，采用特定的 <strong>人类可阅读</strong> 的代码编写，待到要执行时再 <strong>翻译</strong> 回特定二进制指令，这样就帮助了人们更加轻松地理解和阅读程序逻辑了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-4b5f50ce1ddc7077.png" alt=""></p>
<p>这也就是所谓现在的 <strong>“高级编程语言”</strong> 了。</p>
<p>上述 <strong>翻译</strong> 这个过程 <em>(其实相当复杂，涉及语法分析、语义分析、性能优化等等..)</em> 其实也是由一个特定程序来执行的，那 <strong>什么时候将源代码翻译成二进制指令呢？</strong>，不同的编程语言有不同的规定：</p>
<ul>
<li><strong>编译型语言</strong>：必须 <strong>提前</strong> 将所有源代码 <strong>一次性</strong> 转换成二进制指令，生成一个可执行文件 <em>(例如 Windows 下的 <code>.exe</code>)</em> 比如：C 语言、C++、Golang、汇编等。使用的转换工具我们称为 <strong>编译器</strong>。</li>
<li><strong>解释型语言</strong>：允许程序 <strong>一边执行一边转换</strong>，并且不会生成可执行程序，比如 Python、JavaScript、PHP 等。使用的转换工具我们称为 <strong>解释器</strong>。</li>
</ul>
<blockquote>
<p><strong>Java</strong> 和 <strong>C#</strong> 是一种比较奇葩的存在，它们是 <strong>半编译半解释型</strong> 的语言，源码需要先转换成一种中间文件 <em>(字节码文件)</em>，然后再把中间文件拿到 <strong>虚拟机</strong> 中执行。Java 引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-e0d8266f6398eb03.png" alt=""></p>
<p><em>上图</em> 就展示了两种不同类型语言的执行流程的不同，两种方式对比起来总结如下：</p>
<ul>
<li><strong>编译型语言一般不能跨平台</strong>：对于不同的 CPU 来说，它们的指令集是有差异的，这就导致了 <strong>可执行文件</strong> <em>(翻译后的指令)</em> 不能跨平台，另外不同的系统之间的命令也会存在差异，例如 Linux 中睡眠是 <code>sleep()</code> 参数是毫秒，而 Windows 中是 <code>Sleep()</code> <em>(首字母大写)</em> 参数是秒，这就导致了 <strong>源代码也不能跨平台</strong>；</li>
<li><strong>解释型语言可跨平台</strong>：这一切都归功于 <strong>解释器</strong>，它本身就是一个可执行文件，官方只要针对不同的平台开发不同的解释器，那么解释器就能够根据相同的语法解析出同样功能的指令；</li>
<li><strong>编译型一般比解释型效率高</strong>：由于解释型是采取一边执行一边翻译的做法，所以会慢上一些，再加上我们强大的 <strong>编译器</strong> 会帮我们做许多代码优化的工作。</li>
</ul>
<h4 id="关于-Python"><a href="#关于-Python" class="headerlink" title="关于 Python"></a>关于 Python</h4><p><strong>Python</strong> 属于典型的解释型语言，所以运行 Python 程序需要解释器的支持，只要你在不同的平台安装了不同的解释器，你的代码就可以随时运行，不用担心任何兼容性问题，真正的 <strong>“一次编写，到处运行”</strong>。</p>
<p><strong>Python</strong> 几乎支持所有常见的平台，比如 Linux、Windows、Mac OS、Android、FreeBSD、Solaris、PocketPC 等，你所写的 Python 代码无需修改就能在这些平台上正确运行。也就是说，Python 的 <strong>可移植性</strong> 是很强的。</p>
<h2 id="面向对象-vs-面向过程"><a href="#面向对象-vs-面向过程" class="headerlink" title="面向对象 vs 面向过程"></a>面向对象 vs 面向过程</h2><p><strong>面向对象</strong> 和 <strong>面向过程</strong> 是我们使用计算机编程解决问题的两种不同方式的方案。</p>
<p><strong>面向过程</strong> 可以说是一种 <strong>基于事件 or 过程</strong> 来描述的编码方式，譬如「把大象放进冰箱」就可以描述成那经典的三个步骤，「把牛放进冰箱」又是另一个相似的经典三步，只是这样单独的事件 or 过程多了之后，随着项目复杂度的增加，项目会变得非常难以维护。</p>
<blockquote>
<p>软件危机最典型的例子莫过于 IBM 的 <code>System/360</code> 的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks, Jr.）作为项目主管，率领 <code>2000</code> 多个程序员夜以继日的工作，共计花费了 <code>5000</code> 人一年的工作量，写出将近 <code>100</code> 万行的源码，总共投入 <code>5</code> 亿美元，是美国的 “曼哈顿” 原子弹计划投入的 <code>1/4</code>。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了史上最畅销的软件工程书籍。</p>
<ul>
<li>引用自：<a href="http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110880" target="_blank" rel="noopener">http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110880</a></li>
</ul>
</blockquote>
<p>尽管 <strong>结构化的程序设计</strong> <em>(将一个大问题逐步划分成一个一个的小问题)</em> 能够帮助我们解决一部分问题，但 <strong>面向过程</strong> 仍然有一些不符合人类惯有的思考方式，譬如说：我今天想去存钱，我不会说「请拿走我的银行卡和钱，然后在我卡上充值上相应的数目，最后把银行卡还给我谢谢」，而我只会说「存钱，谢谢」，因为人大部分时间都是基于 <strong>对象</strong> <em>(或者可以说角色)</em> 来思考的。</p>
<p>对于 <strong>面向过程</strong> 最好的总结可能是：<strong>「程序 = 算法 + 数据结构」</strong>，而对于 <strong>面向对象</strong> 来说则可以更改为：<strong>「程序 = 对象 + 交互」</strong>。</p>
<h2 id="Why-Python？"><a href="#Why-Python？" class="headerlink" title="Why Python？"></a>Why Python？</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-8f4e79f34df177e6.png" alt=""></p>
<p>上面的 <em>漫画</em> 很好地说明了 Python 快速构建工具的能力，这也是 <code>Why Python</code> 的一大理由。下面根据惯例列举一些让我们足以选择 Python 的原因。</p>
<h4 id="初学者友善-容易明白且功能强大"><a href="#初学者友善-容易明白且功能强大" class="headerlink" title="初学者友善 | 容易明白且功能强大"></a>初学者友善 | 容易明白且功能强大</h4><p>Python 的设计足够简单和易于使用，这样使得初学者能够从中不断得获取到乐趣以继续 Python 之旅。</p>
<p>另外作为一种非常高级的语言，Python 读起来像英语，这减轻了编码初学者的许多语法学习压力。Python 为您处理了很多复杂性，因此它非常适合初学者，因为它使初学者可以专注于学习编程概念，而不必担心过多的细节。</p>
<p>Python 还一度被爆纳入高考，收编到小学课本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-451180aa92102c5b.png" alt=""></p>
<h4 id="非常灵活"><a href="#非常灵活" class="headerlink" title="非常灵活"></a>非常灵活</h4><p>作为一种 <strong>动态类型</strong> 的语言，Python 确实非常灵活。这意味着没有关于如何构建特征的硬性规则，并且使用不同的方法来解决问题将具有更大的灵活性 <em>（尽管 Python 哲学鼓励使用明显的方法来解决问题）</em>。此外，Python 也更宽容错误，因此您仍然可以编译并运行程序，直到遇到问题为止。</p>
<h4 id="越来越火爆"><a href="#越来越火爆" class="headerlink" title="越来越火爆"></a>越来越火爆</h4><p>Python 在诞生之初，因为其功能不好，运转功率低，不支持多核，根本没有并发性可言，在计算功能不那么好的年代，一直没有火爆起来，甚至很多人根本不知道有这门语言。</p>
<p>随着时代的发展，物理硬件功能不断提高，而软件的复杂性也不断增大，开发效率越来越被企业重视。因此就有了不一样的声音，在软件开发的初始阶段，性能并没有开发效率重要，没必然为了节省不到 <code>1ms</code> 的时间却让开发量增加好几倍，这样划不过来。也就是开发效率比机器效率更为重要，那么 Python 就逐渐得到越来越多开发者的亲睐了。</p>
<p>在 <code>12-14</code> 年，云计算升温，大量创业公司和互联网巨头挤进云计算领域，而最著名的云核算开源渠道 OpenStack 就是基于 Python 开发的。</p>
<p>随后几年的备受关注的人工智能，机器学习首选开发语言也是 Python。</p>
<p>至此，Python 已经成为互联网开发的焦点。在 <em>「Top 10 的编程语言走势图」</em> 可以看到，Python 已经跃居第三位，而且在 <code>2017</code> 年还成为了最受欢迎的语言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-e92d013f1190a7ca.png" alt=""></p>
<h4 id="工作机会-薪资待遇高"><a href="#工作机会-薪资待遇高" class="headerlink" title="工作机会 | 薪资待遇高"></a>工作机会 | 薪资待遇高</h4><ul>
<li>来自 <a href="gooroo.io">gooroo.io</a> 的薪资信息：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-501633340f69b855.png" alt=""></p>
<p>在天使榜上，Python 是需求第二高的技能，也是提供最高平均薪水的技能。</p>
<p>随着大数据的兴起，Python 开发人员需要作为数据科学家，尤其是因为 Python 可以轻松集成到 Web 应用程序中以执行需要机器学习的任务。</p>
<h2 id="快速体验-No-Hello-World"><a href="#快速体验-No-Hello-World" class="headerlink" title="快速体验 | No Hello World !"></a>快速体验 | No Hello World !</h2><p><code>Hello World</code> 似乎是学习编程绕不过去的东西，但使用 <strong>Python</strong>，我们来换点儿别的，Emmm.. 比如，一个 <strong>查询天气</strong> 的小程序 <em>(效果如下图)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-627c3e77b32f2db0.gif" alt=""></p>
<h4 id="源码-amp-解释"><a href="#源码-amp-解释" class="headerlink" title="源码 &amp; 解释"></a>源码 &amp; 解释</h4><p><code>http://wthrcdn.etouch.cn/weather_mini?city=xxx</code> 这个网址可以返回任意城市昨日以及 5 天内的天气预报，包括气温、指数、空气质量、风力等，你可以用浏览器试着访问一下，你会得到一个 <code>weather_mini</code> 的文件，里面就包含了我们想要的一些数据。</p>
<p>不过这里由于我们发起了网络请求用到了第三方库 <code>requests</code>，所以在运行之前还需要使用 <code>pip install requests</code> 命令把该库下载到 Python 的安装目录下。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>
<span class="token keyword">import</span> requests

<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    city <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'请输入城市,回车退出:\n'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> city<span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    req <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'http://wthrcdn.etouch.cn/weather_mini?city=%s'</span> <span class="token operator">%</span> city<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
</code></pre>
<h4 id="运行你的代码"><a href="#运行你的代码" class="headerlink" title="运行你的代码"></a>运行你的代码</h4><p>你可以在 <strong>当前文件夹</strong> 下执行命令： <code>python hello_python.py</code>，或是使用 <code>python &lt;源文件路径&gt;</code> 运行也行，例如，如果我是 Windows 用户并且将上述源文件保存在了 <code>D</code> 盘下面，那就可以执行 <code>python D:\hello_python.py</code>，然后你就可以看到上面的效果了。当然如果使用 IDE 将更加方便。</p>
<h2 id="Python-vs-Java"><a href="#Python-vs-Java" class="headerlink" title="Python vs Java"></a>Python vs Java</h2><p>引入一张比较著名的图吧，可以很明显地感受到 Python 在写法上要简洁一些吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-60e9032d6e669f4c.png" alt=""></p>
<h1 id="二、Python-基本语法简介"><a href="#二、Python-基本语法简介" class="headerlink" title="二、Python 基本语法简介"></a>二、Python 基本语法简介</h1><p>Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 <code>{}</code> 来控制类，函数以及其他逻辑判断。Python 最具特色的就是用 <strong>缩进</strong> 来写模块。</p>
<h2 id="2-0-注释"><a href="#2-0-注释" class="headerlink" title="2.0 注释"></a>2.0 注释</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第一个注释</span>
<span class="token comment" spellcheck="true"># 第二个注释</span>

<span class="token triple-quoted-string string">'''
第三注释
第四注释
'''</span>

<span class="token triple-quoted-string string">"""
第五注释
第六注释
"""</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Python!"</span><span class="token punctuation">)</span></code></pre>
<h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p>Python 中的变量赋值不需要类型声明。Python 有五个标准的数据类型：</p>
<ol>
<li><strong>Numbers（数字）</strong>：Python3 中有四种数字类型 <em>(没有 Python2 中的 Long)</em>，分别是 <code>int</code> 长整型、<code>bool</code> 布尔、<code>float</code> 浮点数、<code>complex</code> 复数 <em>(1 + 2j)</em>；</li>
<li><strong>String（字符串）</strong>：Python 中字符串不能改变，并且没有单独的字符类型，一个字符就是长度为 1 的字符串；</li>
<li><strong>Tuple（元组）</strong>：类似于 List，但不能二次赋值，相当于只读列表。eg：<code>(&#39;test1&#39;, &#39;test2&#39;)</code></li>
<li><strong>List（列表）</strong>：类似 Java 中的 Array 类型。eg:<code>[1, 2, ,3]</code></li>
<li><strong>Dictionary（字典）</strong>：类似于 Java 的 Map 类型。eg:<code>{a: 1, b: 2}</code></li>
</ol>
<blockquote>
<p><code>set</code> 集合也属于数据结构，它是一个 <strong>无序</strong> 且 <strong>不重复</strong> 的元素序列。可以使用大括号 <code>{ }</code> 或者 <code>set()</code> 函数创建集合，注意：创建一个空集合必须用 <code>set()</code> 而不是 <code>{ }</code>，因为 <code>{ }</code> 是用来创建一个空字典。</p>
</blockquote>
<pre class=" language-python"><code class="language-python">str <span class="token operator">=</span> <span class="token string">'Hello World!'</span>
<span class="token keyword">print</span> str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>      <span class="token comment" spellcheck="true"># 输出字符串中第三个至第五个之间的字符串</span>

list <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">786</span> <span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'john'</span><span class="token punctuation">,</span> <span class="token number">70.2</span> <span class="token punctuation">]</span>
<span class="token keyword">print</span> list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># 输出第二个至第三个元素</span>

tuple <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token string">'runoob'</span><span class="token punctuation">,</span> <span class="token number">786</span> <span class="token punctuation">,</span> <span class="token number">2.23</span><span class="token punctuation">,</span> <span class="token string">'john'</span><span class="token punctuation">,</span> <span class="token number">70.2</span> <span class="token punctuation">)</span>
<span class="token keyword">print</span> tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># 输出第二个至第三个的元素</span>

tinydict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'john'</span><span class="token punctuation">,</span><span class="token string">'code'</span><span class="token punctuation">:</span><span class="token number">6734</span><span class="token punctuation">,</span> <span class="token string">'dept'</span><span class="token punctuation">:</span> <span class="token string">'sales'</span><span class="token punctuation">}</span>
<span class="token keyword">print</span> tinydict<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>              <span class="token comment" spellcheck="true"># 输出键为 2 的值</span></code></pre>
<h2 id="2-2-条件语句"><a href="#2-2-条件语句" class="headerlink" title="2.2 条件语句"></a>2.2 条件语句</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 当判断条件为 1 个值时</span>
flag <span class="token operator">=</span> <span class="token boolean">False</span>
name <span class="token operator">=</span> <span class="token string">'luren'</span>
<span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">'python'</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 判断变量否为'python'</span>
    flag <span class="token operator">=</span> <span class="token boolean">True</span>           <span class="token comment" spellcheck="true"># 条件成立时设置标志为真</span>
    <span class="token keyword">print</span> <span class="token string">'welcome boss'</span>  <span class="token comment" spellcheck="true"># 并输出欢迎信息</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> name            <span class="token comment" spellcheck="true"># 条件不成立时输出变量名称</span>

<span class="token comment" spellcheck="true"># 当判断条件为多个值时</span>
num <span class="token operator">=</span> <span class="token number">5</span>     
<span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 判断num的值</span>
    <span class="token keyword">print</span> <span class="token string">'boss'</span>        
<span class="token keyword">elif</span> num <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> <span class="token string">'user'</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span> <span class="token string">'roadman'</span>       <span class="token comment" spellcheck="true"># 条件均不成立时输出</span></code></pre>
<h2 id="2-3-循环"><a href="#2-3-循环" class="headerlink" title="2.3 循环"></a>2.3 循环</h2><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>在 Python 中没有 <code>do..while</code> 的循环</p>
<pre class=" language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 小于 5"</span><span class="token punctuation">)</span>
   count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 大于或等于 5"</span><span class="token punctuation">)</span></code></pre>
<h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h4><p><code>for..in</code> 适用于 <code>list/ dict/ set</code> 数据类型，如果需要遍历数字序列，我们也可以借助 <code>range(min, max, step)</code> 函数来生成数列。</p>
<pre class=" language-python"><code class="language-python">sites <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Baidu"</span><span class="token punctuation">,</span> <span class="token string">"Google"</span><span class="token punctuation">,</span><span class="token string">"Runoob"</span><span class="token punctuation">,</span><span class="token string">"Taobao"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> site <span class="token keyword">in</span> sites<span class="token punctuation">:</span>
    <span class="token keyword">if</span> site <span class="token operator">==</span> <span class="token string">"Runoob"</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"菜鸟教程!"</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"循环数据 "</span> <span class="token operator">+</span> site<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有循环数据!"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"完成循环!"</span><span class="token punctuation">)</span>


<span class="token comment" spellcheck="true"># 输出 0/ 3/ 6/ 9</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 替换成 range(5) 则输出 0/ 1/ 2/ 3/ 4</span>
<span class="token comment" spellcheck="true"># 替换成 range(5,9) 则输出 5/ 6/ 7/ 8</span></code></pre>
<h2 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h2><h4 id="函数基本定义和使用"><a href="#函数基本定义和使用" class="headerlink" title="函数基本定义和使用"></a>函数基本定义和使用</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 计算面积函数</span>
<span class="token keyword">def</span> <span class="token function">area</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> width <span class="token operator">*</span> height

<span class="token keyword">def</span> <span class="token function">print_welcome</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Welcome"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>

print_welcome<span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span>
w <span class="token operator">=</span> <span class="token number">4</span>
h <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"width ="</span><span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token string">" height ="</span><span class="token punctuation">,</span> h<span class="token punctuation">,</span> <span class="token string">" area ="</span><span class="token punctuation">,</span> area<span class="token punctuation">(</span>w<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>在 Python 中，类型属于对象，变量是没有类型的，例如 <code>name = &quot;wmyskxz&quot;</code>，则 <code>&quot;wmyskxz&quot;</code> 是 String 类型，而变量 <code>name</code> 仅仅是一个对象的引用。</p>
<p>Python 中一切都是对象，严格意义我们 <strong>不能说值传递还是引用传递</strong>，我们应该说传 <strong>不可变对象</strong> <em>(string、tuples、number 不可变)</em> 和 <strong>传可变对象</strong> <em>(list、dict 可变)</em>。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">############################################</span>
<span class="token comment" spellcheck="true"># 传递不可变对象</span>
<span class="token keyword">def</span> <span class="token function">ChangeInt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">10</span>

b <span class="token operator">=</span> <span class="token number">2</span>
ChangeInt<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token keyword">print</span> b <span class="token comment" spellcheck="true"># 结果是 2</span>

<span class="token comment" spellcheck="true">############################################</span>
<span class="token comment" spellcheck="true"># 传递可变对象</span>
<span class="token keyword">def</span> <span class="token function">changeme</span><span class="token punctuation">(</span> mylist <span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token string">"修改传入的列表"</span>
   mylist<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"函数内取值: "</span><span class="token punctuation">,</span> mylist<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [10, 20, 30, [1, 2, 3, 4]]</span>
   <span class="token keyword">return</span>

<span class="token comment" spellcheck="true"># 调用changeme函数</span>
mylist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span>
changeme<span class="token punctuation">(</span> mylist <span class="token punctuation">)</span>
<span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"函数外取值: "</span><span class="token punctuation">,</span> mylist<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [10, 20, 30, [1, 2, 3, 4]]</span>
<span class="token comment" spellcheck="true"># 函数内外值一致，因为都同属于同一个引用</span></code></pre>
<h2 id="2-5-class-类"><a href="#2-5-class-类" class="headerlink" title="2.5 class 类"></a>2.5 class 类</h2><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">people</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true">#定义基本属性</span>
    name <span class="token operator">=</span> <span class="token string">''</span>
    age <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment" spellcheck="true">#定义私有属性,私有属性在类外部无法直接进行访问</span>
    __weight <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment" spellcheck="true">#定义构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>n<span class="token punctuation">,</span>a<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> n
        self<span class="token punctuation">.</span>age <span class="token operator">=</span> a
        self<span class="token punctuation">.</span>__weight <span class="token operator">=</span> w
    <span class="token keyword">def</span> <span class="token function">speak</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 说: 我 %d 岁。"</span> <span class="token operator">%</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>self<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 实例化类</span>
p <span class="token operator">=</span> people<span class="token punctuation">(</span><span class="token string">'wmyskxz'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>speak<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># wmyskxz 说: 我 10 岁。</span></code></pre>
<h4 id="继承-amp-多继承-amp-方法重写"><a href="#继承-amp-多继承-amp-方法重写" class="headerlink" title="继承 &amp; 多继承 &amp; 方法重写"></a>继承 &amp; 多继承 &amp; 方法重写</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 单继承</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClassName</span><span class="token punctuation">(</span>BaseClassName1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>statement<span class="token number">-1</span><span class="token operator">></span>
    <span class="token punctuation">.</span>
    <span class="token operator">&lt;</span>statement<span class="token operator">-</span>N<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 多继承</span>
<span class="token keyword">class</span> <span class="token class-name">DerivedClassName</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">,</span> Base3<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">&lt;</span>statement<span class="token number">-1</span><span class="token operator">></span>
    <span class="token punctuation">.</span>
    <span class="token punctuation">.</span>
    <span class="token punctuation">.</span>
    <span class="token operator">&lt;</span>statement<span class="token operator">-</span>N<span class="token operator">></span>

<span class="token comment" spellcheck="true"># 方法重写演示</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 定义父类</span>
   <span class="token keyword">def</span> <span class="token function">myMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'调用父类方法'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 定义子类</span>
   <span class="token keyword">def</span> <span class="token function">myMethod</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'调用子类方法'</span><span class="token punctuation">)</span>

c <span class="token operator">=</span> Child<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 子类实例</span>
c<span class="token punctuation">.</span>myMethod<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 子类调用重写方法</span>
super<span class="token punctuation">(</span>Child<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>myMethod<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#用子类对象调用父类已被覆盖的方法</span>
<span class="token comment" spellcheck="true"># 先输出 "调用子类方法" 再输出 "调用父类方法"</span></code></pre>
<h2 id="2-6-module-模块"><a href="#2-6-module-模块" class="headerlink" title="2.6 module 模块"></a>2.6 module 模块</h2><p>一个 <code>.py</code> 文件就是一个模块，想要使用其他 <code>.py</code> 文件中的方法就需要引入进来。</p>
<ol>
<li><code>import [module]</code></li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 导入整个random模块，可以是内置/当前路径</span>
<span class="token keyword">import</span> random
<span class="token comment" spellcheck="true"># 使用 `random` 模块下的 `randint` 方法</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<ol start="2">
<li><code>from [module] import [name1, name2, ...]</code></li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 从 `random` 模块里导入其中一个方法 `randint`</span>
<span class="token keyword">from</span> random <span class="token keyword">import</span> randint
<span class="token comment" spellcheck="true"># 不一样的是，使用 `randint` 的就不需要先写 `random` 了</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<ol start="3">
<li><code>import [module] as [new_name]</code></li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 但这个名字可能跟其他地方有冲突，因此改名成 `rd`</span>
<span class="token keyword">import</span> random <span class="token keyword">as</span> rd
<span class="token comment" spellcheck="true"># 使用 `rd` 这个名称取代原本的 `random`</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>rd<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<ol start="4">
<li><code>from [module] import *</code></li>
</ol>
<p><strong>不推荐</strong>，容易造成名称冲突，降低可读性和可维护性。</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Import 所有 `random` module 底下的东西</span>
<span class="token keyword">from</span> random <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token comment" spellcheck="true"># 使用 `randint` 的时候也不需要先写 `random`</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="module-搜索路径"><a href="#module-搜索路径" class="headerlink" title="module 搜索路径"></a>module 搜索路径</h4><p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：</p>
<ol>
<li>当前目录</li>
<li>如果不在当前目录，Python 则搜索在 shell 变量 <code>PYTHONPATH</code> 下的每个目录。</li>
<li>如果都找不到，Python 会察看默认路径。UNIX 下，默认路径一般为 <code>/usr/local/lib/python/</code>。</li>
</ol>
<h2 id="2-7-package-包"><a href="#2-7-package-包" class="headerlink" title="2.7 package 包"></a>2.7 package 包</h2><p>把两个 module 放在一个新的目录 <code>sample_package</code>，再新增 <code>_init__.py</code> <em>(可以是空，但不能没有)</em>，宣称自己是一个 package :</p>
<pre><code>sample_package
  |-- __init__.py
  |-- 1.py
  |-- 2.py</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># package_runoob 同级目录下创建 test.py 来调用 package_runoob 包</span>
<span class="token comment" spellcheck="true"># 导入包</span>
<span class="token keyword">from</span> package_runoob<span class="token punctuation">.</span>runoob1 <span class="token keyword">import</span> runoob1
<span class="token keyword">from</span> package_runoob<span class="token punctuation">.</span>runoob2 <span class="token keyword">import</span> runoob2

runoob1<span class="token punctuation">(</span><span class="token punctuation">)</span>
runoob2<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>单个py文件就是一个 module，而当多个 <code>.py</code> 文件 + <code>__init__.py</code> 文件时，就等于 package。</p>
</blockquote>
<h1 id="三、基本代码规范"><a href="#三、基本代码规范" class="headerlink" title="三、基本代码规范"></a>三、基本代码规范</h1><p><strong>代码规范</strong> 再怎么强调也不为过：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-6467610c0eb161a8.png" alt=""></p>
<ul>
<li>图片来源：<a href="https://codingpy.com/article/programmers-daily-what-idiot-wrote-this-crappy-code/" target="_blank" rel="noopener">https://codingpy.com/article/programmers-daily-what-idiot-wrote-this-crappy-code/</a></li>
</ul>
<h2 id="3-1-命名规范"><a href="#3-1-命名规范" class="headerlink" title="3.1 命名规范"></a>3.1 命名规范</h2><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>模块尽量使用 <strong>小写命名</strong>，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 正确的模块名</span>
<span class="token keyword">import</span> decoder
<span class="token keyword">import</span> html_parser

<span class="token comment" spellcheck="true"># 不推荐的模块名</span>
<span class="token keyword">import</span> Decoder</code></pre>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><ul>
<li>类名使用 <strong>驼峰</strong> (CamelCase)命名风格，首字母大写，私有类可用一个下划线开头</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Farm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">AnimalFarm</span><span class="token punctuation">(</span>Farm<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">_PrivateFarm</span><span class="token punctuation">(</span>Farm<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span></code></pre>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>函数名 <strong>一律小写</strong>，如有多个单词，用下划线隔开</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>

<span class="token keyword">def</span> <span class="token function">run_with_env</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span> </code></pre>
<ul>
<li>私有函数在函数前加一个下划线 <code>_</code></li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">_private_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span></code></pre>
<h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><ul>
<li>变量名尽量 <strong>小写</strong>, 如有多个单词，用下划线隔开</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    count <span class="token operator">=</span> <span class="token number">0</span>
    school_name <span class="token operator">=</span> <span class="token string">''</span></code></pre>
<ul>
<li>常量使用以下划线分隔的 <strong>大写</strong> 命名</li>
</ul>
<pre class=" language-python"><code class="language-python">MAX_CLIENT <span class="token operator">=</span> <span class="token number">100</span>
MAX_CONNECTION <span class="token operator">=</span> <span class="token number">1000</span>
CONNECTION_TIMEOUT <span class="token operator">=</span> <span class="token number">600</span></code></pre>
<h2 id="3-2-基本编码规范"><a href="#3-2-基本编码规范" class="headerlink" title="3.2 基本编码规范"></a>3.2 基本编码规范</h2><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><ul>
<li>统一使用 4 个空格进行缩进</li>
</ul>
<h4 id="行宽"><a href="#行宽" class="headerlink" title="行宽"></a>行宽</h4><p>每行代码尽量不超过 <code>80</code> 个字符(在特殊情况下可以略微超过 <code>80</code> ，但最长不得超过 <code>120</code>)</p>
<p>理由：</p>
<ul>
<li>这在查看 <code>side-by-side</code> 的 <code>diff</code> 时很有帮助</li>
<li>方便在控制台下查看代码</li>
<li>太长可能是设计有缺陷</li>
</ul>
<h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>简单说，自然语言使用双引号，机器标示使用单引号，因此 <strong>代码里</strong> 多数应该使用 <strong>单引号</strong></p>
<ul>
<li><strong>自然语言</strong> 使用双引号 <code>&quot;...&quot;</code>，例如错误信息；很多情况还是 unicode，使用u”你好世界”</li>
<li><strong>机器标识</strong> 使用单引号 ‘<code>...&#39;</code>，例如 dict 里的 key</li>
<li><strong>正则表达式</strong> 使用原生的双引号 <code>r&quot;...&quot;</code></li>
<li><strong>文档字符串</strong> (docstring) 使用三个双引号 <code>&quot;&quot;&quot;......&quot;&quot;&quot;</code></li>
</ul>
<h4 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h4><ul>
<li>import 语句应该分行书写</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 正确的写法</span>
<span class="token keyword">import</span> os
<span class="token keyword">import</span> sys

<span class="token comment" spellcheck="true"># 不推荐的写法</span>
<span class="token keyword">import</span> sys<span class="token punctuation">,</span>os

<span class="token comment" spellcheck="true"># 正确的写法</span>
<span class="token keyword">from</span> subprocess <span class="token keyword">import</span> Popen<span class="token punctuation">,</span> PIPE</code></pre>
<ul>
<li>import 语句应该使用 absolute import</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 正确的写法</span>
<span class="token keyword">from</span> foo<span class="token punctuation">.</span>bar <span class="token keyword">import</span> Bar

<span class="token comment" spellcheck="true"># 不推荐的写法</span>
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>bar <span class="token keyword">import</span> Bar</code></pre>
<ul>
<li>import 语句应该放在文件头部，置于模块说明及 <code>DocString</code> 之后，于全局变量之前；</li>
<li>import 语句应该按照顺序排列，每组之间用一个空行分隔</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> sys

<span class="token keyword">import</span> msgpack
<span class="token keyword">import</span> zmq

<span class="token keyword">import</span> foo</code></pre>
<ul>
<li>导入其他模块的类定义时，可以使用相对导入</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> myclass <span class="token keyword">import</span> MyClass</code></pre>
<ul>
<li>如果发生命名冲突，则可使用命名空间</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> bar
<span class="token keyword">import</span> foo<span class="token punctuation">.</span>bar

bar<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span><span class="token punctuation">)</span>
foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="DocString"><a href="#DocString" class="headerlink" title="DocString"></a>DocString</h4><p>DocString 的规范中最其本的两点：</p>
<ol>
<li>所有的公共模块、函数、类、方法，都应该写 DocString 。私有方法不一定需要，但应该在 <code>def</code> 后提供一个块注释来说明。</li>
<li>DocString 的结束”””应该独占一行，除非此 DocString 只有一行。</li>
</ol>
<pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""Return a foobar
Optional plotz says to frobnicate the bizbaz first.
"""</span>

<span class="token triple-quoted-string string">"""Oneline docstring"""</span></code></pre>
<h2 id="3-3-注释规范"><a href="#3-3-注释规范" class="headerlink" title="3.3 注释规范"></a>3.3 注释规范</h2><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>在代码的 <strong>关键部分</strong>(或比较复杂的地方), 能写注释的要尽量写注释</li>
<li>比较重要的注释段, 使用多个等号隔开, 可以更加醒目, <strong>突出</strong> 重要性</li>
</ul>
<pre class=" language-python"><code class="language-python">app <span class="token operator">=</span> create_app<span class="token punctuation">(</span>name<span class="token punctuation">,</span> options<span class="token punctuation">)</span>


<span class="token comment" spellcheck="true"># =====================================</span>
<span class="token comment" spellcheck="true"># 请勿在此处添加 get post等app路由行为 !!!</span>
<span class="token comment" spellcheck="true"># =====================================</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h4 id="文档注释（DocString）"><a href="#文档注释（DocString）" class="headerlink" title="文档注释（DocString）"></a>文档注释（DocString）</h4><ul>
<li>文档注释以 “”” 开头和结尾, 首行不换行, 如有多行, 末行必需换行, 以下是Google的docstring风格示例</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>
<span class="token triple-quoted-string string">"""Example docstrings.

This module demonstrates documentation as specified by the `Google Python
Style Guide`_. Docstrings may extend over multiple lines. Sections are created
with a section header and a colon followed by a block of indented text.

Example:
    Examples can be given using either the ``Example`` or ``Examples``
    sections. Sections support any reStructuredText formatting, including
    literal blocks::

        $ python example_google.py

Section breaks are created by resuming unindented text. Section breaks
are also implicitly created anytime a new section starts.
"""</span></code></pre>
<ul>
<li>不要在文档注释复制函数定义原型, 而是具体描述其具体内容, 解释具体参数和返回值等</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#  不推荐的写法(不要写函数原型等废话)</span>
<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""function(a, b) -> list"""</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>


<span class="token comment" spellcheck="true">#  正确的写法</span>
<span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""计算并返回a到b范围内数据的平均值"""</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>
<ul>
<li>对函数参数、返回值等的说明采用 <code>numpy</code> 标准, 如下所示</li>
</ul>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""在这里写函数的一句话总结(如: 计算平均值).

    这里是具体描述.

    参数
    ----------
    arg1 : int
        arg1的具体描述
    arg2 : int
        arg2的具体描述

    返回值
    -------
    int
        返回值的具体描述

    参看
    --------
    otherfunc : 其它关联函数等...

    示例
    --------
    示例使用doctest格式, 在`>>>`后的代码可以被文档测试工具作为测试用例自动运行

    >>> a=[1,2,3]
    >>> print [x + 3 for x in a]
    [4, 5, 6]
    """</span></code></pre>
<blockquote>
<p>更多细致详细的规范可以参考：</p>
<ol>
<li><strong>Google 开源项目指南</strong> - <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/</a></li>
<li><strong>官方 PEP 8 代码规范</strong> - <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></li>
</ol>
</blockquote>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ol>
<li>Redis(9)——史上最强【集群】入门实践教程 - <a href="https://juejin.im/post/5e7429a16fb9a07ccc460fe7" target="_blank" rel="noopener">https://juejin.im/post/5e7429a16fb9a07ccc460fe7</a></li>
<li>React入门学习 - <a href="https://juejin.im/post/5da5e9e8e51d4525292d2ed7" target="_blank" rel="noopener">https://juejin.im/post/5da5e9e8e51d4525292d2ed7</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>WhyStudyPython.md | TwoWater - <a href="https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python0/WhyStudyPython.md" target="_blank" rel="noopener">https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python0/WhyStudyPython.md</a></li>
<li>C 语言中文网 | Python 系列教程 - <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">http://c.biancheng.net/python/</a></li>
<li>Crossin的编程教室 - <a href="https://python666.cn/" target="_blank" rel="noopener">https://python666.cn/</a></li>
<li>计算机和编程语言的发展历史 - <a href="https://blog.csdn.net/abc6368765/article/details/83990756" target="_blank" rel="noopener">https://blog.csdn.net/abc6368765/article/details/83990756</a></li>
<li>面向对象葵花宝典 - <a href="http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110879" target="_blank" rel="noopener">http://www.kancloud.cn:8080/yunhua_lee/oobaodian/110879</a></li>
<li>RUNOOB | Python3 系列教程 - <a href="ttps://www.runoob.com/python3">ttps://www.runoob.com/python3</a></li>
<li>Python 基础语法 | springleo’sblog - <a href="https://lq782655835.github.io/blogs/tools/python-grammar.html#_1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">https://lq782655835.github.io/blogs/tools/python-grammar.html#_1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E6%87%82%E4%B8%80%E7%82%B9Python%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/17/redis-9-shi-shang-zui-qiang-ji-qun-ru-men-shi-jian-jiao-cheng/">
      Redis(9)——史上最强【集群】入门实践教程
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月17日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-80c61b0ae541a750.png" alt=""></p>
<h1 id="一、Redis-集群概述"><a href="#一、Redis-集群概述" class="headerlink" title="一、Redis 集群概述"></a>一、Redis 集群概述</h1><h4 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h4><p>到 <a href="#相关阅读">目前</a> 为止，我们所学习的 Redis 都是 <strong>单机版</strong> 的，这也就意味着一旦我们所依赖的 Redis 服务宕机了，我们的主流程也会受到一定的影响，这当然是我们不能够接受的。</p>
<p>所以一开始我们的想法是：搞一台备用机。这样我们就可以在一台服务器出现问题的时候切换动态地到另一台去：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c48d255bc0b13672.gif" alt=""></p>
<p>幸运的是，两个节点数据的同步我们可以使用 Redis 的 <strong>主从同步</strong> 功能帮助到我们，这样一来，有个备份，心里就踏实多了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-4a32b9efa3885655.jpg" alt=""></p>
<h4 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h4><p>后来因为某种神秘力量，Redis 老会在莫名其妙的时间点出问题 <em>(比如半夜 2 点)</em>，我总不能 24 小时时刻守在电脑旁边切换节点吧，于是另一个想法又开始了：给所有的节点找一个 <strong>“管家”</strong>，自动帮我监听照顾节点的状态并切换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-de8d9ce9e77bf211.gif" alt=""></p>
<p>这大概就是 <strong>Redis 哨兵</strong> <em>(Sentinel)</em> 的简单理解啦。什么？管家宕机了怎么办？相较于有大量请求的 Redis 服务来说，管家宕机的概率就要小得多啦.. 如果真的宕机了，我们也可以直接切换成当前可用的节点保证可用..</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c7657fb8140d7cc6.jpg" alt=""></p>
<h4 id="Redis-集群化"><a href="#Redis-集群化" class="headerlink" title="Redis 集群化"></a>Redis 集群化</h4><p>好了，通过上面的一些解决方案我们对 Redis 的 <strong>稳定性</strong> 稍微有了一些底气了，但单台节点的计算能力始终有限，所谓人多力量大，如果我们把 <strong>多个节点组合</strong> 成 <strong>一个可用的工作节点</strong>，那就大大增加了 Redis 的  <strong>高可用、可扩展、分布式、容错</strong> 等特性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-8957aa6d1484c5de.png" alt=""></p>
<h1 id="二、主从复制"><a href="#二、主从复制" class="headerlink" title="二、主从复制"></a>二、主从复制</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-4956a718c124a81f.png" alt=""></p>
<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h4 id="主从复制主要的作用"><a href="#主从复制主要的作用" class="headerlink" title="主从复制主要的作用"></a>主从复制主要的作用</h4><ul>
<li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li>
<li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li>
</ul>
<h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p>在 <strong>Redis</strong> 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 <code>slaveof</code> 选项，让一个服务器去复制另一个服务器，以下三种方式是 <strong>完全等效</strong> 的：</p>
<ul>
<li><strong>配置文件</strong>：在从服务器的配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li><strong>启动命令</strong>：redis-server 启动命令后加入 <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li><strong>客户端命令</strong>：Redis 服务器启动后，直接通过客户端执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，让该 Redis 实例成为从节点。</li>
</ul>
<p>需要注意的是：<strong>主从复制的开启，完全是在从节点发起的，不需要我们在主节点做任何事情。</strong></p>
<h4 id="第一步：本地启动两个节点"><a href="#第一步：本地启动两个节点" class="headerlink" title="第一步：本地启动两个节点"></a>第一步：本地启动两个节点</h4><p>在正确安装好 Redis 之后，我们可以使用 <code>redis-server --port &lt;port&gt;</code> 的方式指定创建两个不同端口的 Redis 实例，例如，下方我分别创建了一个 <code>6379</code> 和 <code>6380</code> 的两个 Redis 实例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个端口为 6379 的 Redis 实例</span>
redis-server --port 6379
<span class="token comment" spellcheck="true"># 创建一个端口为 6380 的 Redis 实例</span>
redis-server --port 6380</code></pre>
<p>此时两个 Redis 节点启动后，都默认为 <strong>主节点</strong>。</p>
<h4 id="第二步：建立复制"><a href="#第二步：建立复制" class="headerlink" title="第二步：建立复制"></a>第二步：建立复制</h4><p>我们在 <code>6380</code> 端口的节点中执行 <code>slaveof</code> 命令，使之变为从节点：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在 6380 端口的 Redis 实例中使用控制台</span>
redis-cli -p 6380
<span class="token comment" spellcheck="true"># 成为本地 6379 端口实例的从节点</span>
127.0.0.1:6380<span class="token operator">></span> SLAVEOF 127.0.0.1ø 6379
OK</code></pre>
<h4 id="第三步：观察效果"><a href="#第三步：观察效果" class="headerlink" title="第三步：观察效果"></a>第三步：观察效果</h4><p>下面我们来验证一下，主节点的数据是否会复制到从节点之中：</p>
<ul>
<li>先在 <strong>从节点</strong> 中查询一个 <strong>不存在</strong> 的 key：<br>```bash</li>
</ul>
<p>127.0.0.1:6380&gt; GET mykey<br>(nil)</p>
<pre><code>- 再在 **主节点** 中添加这个 key：
```bash
127.0.0.1:6379&gt; SET mykey myvalue
OK</code></pre><ul>
<li>此时再从 <strong>从节点</strong> 中查询，会发现已经从 <strong>主节点</strong> 同步到 <strong>从节点</strong>：<br>```bash</li>
</ul>
<p>127.0.0.1:6380&gt; GET mykey<br>“myvalue”</p>
<pre><code>
#### 第四步：断开复制

通过 `slaveof &lt;masterip&gt; &lt;masterport&gt;` 命令建立主从复制关系以后，可以通过 `slaveof no one` 断开。需要注意的是，从节点断开复制后，**不会删除已有的数据**，只是不再接受主节点新的数据变化。

从节点执行 `slaveof no one` 之后，从节点和主节点分别打印日志如下：、

```bash
# 从节点打印日志
61496:M 17 Mar 2020 08:10:22.749 # Connection with master lost.
61496:M 17 Mar 2020 08:10:22.749 * Caching the disconnected master state.
61496:M 17 Mar 2020 08:10:22.749 * Discarding previously cached master state.
61496:M 17 Mar 2020 08:10:22.749 * MASTER MODE enabled (user request from &#39;id=4 addr=127.0.0.1:55096 fd=8 name= age=1664 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof&#39;)

# 主节点打印日志
61467:M 17 Mar 2020 08:10:22.749 # Connection with replica 127.0.0.1:6380 lost.</code></pre><h2 id="实现原理简析"><a href="#实现原理简析" class="headerlink" title="实现原理简析"></a>实现原理简析</h2><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-c97a6bcc0936cd17.png" alt=""></p>
<p>为了节省篇幅，我把主要的步骤都 <strong>浓缩</strong> 在了上图中，其实也可以 <strong>简化成三个阶段：准备阶段-数据同步阶段-命令传播阶段</strong>。下面我们来进行一些必要的说明。</p>
<h4 id="身份验证-主从复制安全问题"><a href="#身份验证-主从复制安全问题" class="headerlink" title="身份验证 | 主从复制安全问题"></a>身份验证 | 主从复制安全问题</h4><p>在上面的 <strong>快速体验</strong> 过程中，你会发现 <code>slaveof</code> 这个命令居然不需要验证？这意味着只要知道了 ip 和端口就可以随意拷贝服务器上的数据了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-d0c7a74da972fca3.jpg" alt=""></p>
<p>那当然不能够了，我们可以通过在 <strong>主节点</strong> 配置 <code>requirepass</code> 来设置密码，这样就必须在 <strong>从节点</strong> 中对应配置好 <code>masterauth</code> 参数 <em>(与主节点 <code>requirepass</code> 保持一致)</em> 才能够进行正常复制了。</p>
<h4 id="SYNC-命令是一个非常耗费资源的操作"><a href="#SYNC-命令是一个非常耗费资源的操作" class="headerlink" title="SYNC 命令是一个非常耗费资源的操作"></a>SYNC 命令是一个非常耗费资源的操作</h4><p>每次执行 <code>SYNC</code> 命令，主从服务器需要执行如下动作：</p>
<ol>
<li><strong>主服务器</strong> 需要执行 <code>BGSAVE</code> 命令来生成 RDB 文件，这个生成操作会 <strong>消耗</strong> 主服务器大量的 <strong>CPU、内存和磁盘 I/O 的资源</strong>；</li>
<li><strong>主服务器</strong> 需要将自己生成的 RDB 文件 发送给从服务器，这个发送操作会 <strong>消耗</strong> 主服务器 <strong>大量的网络资源</strong> <em>(带宽和流量)</em>，并对主服务器响应命令请求的时间产生影响；</li>
<li>接收到 RDB 文件的 <strong>从服务器</strong> 需要载入主服务器发来的 RBD 文件，并且在载入期间，从服务器 <strong>会因为阻塞而没办法处理命令请求</strong>；</li>
</ol>
<p>特别是当出现 <strong>断线重复制</strong> 的情况是时，为了让从服务器补足断线时确实的那一小部分数据，却要执行一次如此耗资源的 <code>SYNC</code> 命令，显然是不合理的。</p>
<h4 id="PSYNC-命令的引入"><a href="#PSYNC-命令的引入" class="headerlink" title="PSYNC 命令的引入"></a>PSYNC 命令的引入</h4><p>所以在 <strong>Redis 2.8</strong> 中引入了 <code>PSYNC</code> 命令来代替 <code>SYNC</code>，它具有两种模式：</p>
<ol>
<li><strong>全量复制：</strong> 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作；</li>
<li><strong>部分复制：</strong> 用于网络中断等情况后的复制，只将 <strong>中断期间主节点执行的写命令</strong> 发送给从节点，与全量复制相比更加高效。<strong>需要注意</strong> 的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制；</li>
</ol>
<p>部分复制的原理主要是靠主从节点分别维护一个 <strong>复制偏移量</strong>，有了这个偏移量之后断线重连之后一比较，之后就可以仅仅把从服务器断线之后确实的这部分数据给补回来了。</p>
<blockquote>
<p>更多的详细内容可以参考下方 <em>参考资料 3</em></p>
</blockquote>
<h1 id="三、Redis-Sentinel-哨兵"><a href="#三、Redis-Sentinel-哨兵" class="headerlink" title="三、Redis Sentinel 哨兵"></a>三、Redis Sentinel 哨兵</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-884d5be9a2ddfebc.png" alt=""></p>
<p><em>上图</em> 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li>
</ul>
<p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下方是官方对于哨兵功能的描述：</p>
<ul>
<li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li>
<li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li>
<li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p>
<h2 id="快速体验-1"><a href="#快速体验-1" class="headerlink" title="快速体验"></a>快速体验</h2><h4 id="第一步：创建主从节点配置文件并启动"><a href="#第一步：创建主从节点配置文件并启动" class="headerlink" title="第一步：创建主从节点配置文件并启动"></a>第一步：创建主从节点配置文件并启动</h4><p>正确安装好 Redis 之后，我们去到 Redis 的安装目录 <em>(mac 默认在 <code>/usr/local/</code>)*，找到 <code>redis.conf</code> 文件复制三份分别命名为 <code>redis-master.conf</code>/<code>redis-slave1.conf</code>/<code>redis-slave2.conf</code>，分别作为 <code>1</code> 个主节点和 <code>2</code> 个从节点的配置文件 *(下图演示了我本机的 <code>redis.conf</code> 文件的位置)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-34de77bfca56d32e.png" alt=""></p>
<p>打开可以看到这个 <code>.conf</code> 后缀的文件里面有很多说明的内容，全部删除然后分别改成下面的样子：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#redis-master.conf</span>
port 6379
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6379.log"</span>
dbfilename <span class="token string">"dump-6379.rdb"</span>

<span class="token comment" spellcheck="true">#redis-slave1.conf</span>
port 6380
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6380.log"</span>
dbfilename <span class="token string">"dump-6380.rdb"</span>
slaveof 127.0.0.1 6379

<span class="token comment" spellcheck="true">#redis-slave2.conf</span>
port 6381
daemonize <span class="token function">yes</span>
logfile <span class="token string">"6381.log"</span>
dbfilename <span class="token string">"dump-6381.rdb"</span>
slaveof 127.0.0.1 6379</code></pre>
<p>然后我们可以执行 <code>redis-server &lt;config file path&gt;</code> 来根据配置文件启动不同的 Redis 实例，依次启动主从节点：</p>
<pre class=" language-bash"><code class="language-bash">redis-server /usr/local/redis-5.0.3/redis-master.conf
redis-server /usr/local/redis-5.0.3/redis-slave1.conf
redis-server /usr/local/redis-5.0.3/redis-slave2.conf</code></pre>
<p>节点启动后，我们执行 <code>redis-cli</code> 默认连接到我们端口为 <code>6379</code> 的主节点执行 <code>info Replication</code> 检查一下主从状态是否正常：<em>(可以看到下方正确地显示了两个从节点)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-a1c935f094240cac.png" alt=""></p>
<h4 id="第二步：创建哨兵节点配置文件并启动"><a href="#第二步：创建哨兵节点配置文件并启动" class="headerlink" title="第二步：创建哨兵节点配置文件并启动"></a>第二步：创建哨兵节点配置文件并启动</h4><p>按照上面同样的方法，我们给哨兵节点也创建三个配置文件。<em>(哨兵节点本质上是特殊的 Redis 节点，所以配置几乎没什么差别，只是在端口上做区分就好)</em></p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># redis-sentinel-1.conf</span>
port 26379
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26379.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2

<span class="token comment" spellcheck="true"># redis-sentinel-2.conf</span>
port 26380
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26380.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2

<span class="token comment" spellcheck="true"># redis-sentinel-3.conf</span>
port 26381
daemonize <span class="token function">yes</span>
logfile <span class="token string">"26381.log"</span>
sentinel monitor mymaster 127.0.0.1 6379 2</code></pre>
<p>其中，<code>sentinel monitor mymaster 127.0.0.1 6379 2</code> 配置的含义是：该哨兵节点监控 <code>127.0.0.1:6379</code> 这个主节点，该主节点的名称是 <code>mymaster</code>，最后的 <code>2</code> 的含义与主节点的故障判定有关：至少需要 <code>2</code> 个哨兵节点同意，才能判定主节点故障并进行故障转移。</p>
<p>执行下方命令将哨兵节点启动起来：</p>
<pre class=" language-bash"><code class="language-bash">redis-server /usr/local/redis-5.0.3/redis-sentinel-1.conf --sentinel
redis-server /usr/local/redis-5.0.3/redis-sentinel-2.conf --sentinel
redis-server /usr/local/redis-5.0.3/redis-sentinel-3.conf --sentinel</code></pre>
<p>使用 <code>redis-cil</code> 工具连接哨兵节点，并执行 <code>info Sentinel</code> 命令来查看是否已经在监视主节点了：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 连接端口为 26379 的 Redis 节点</span>
➜  ~ redis-cli -p 26379
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>此时你打开刚才写好的哨兵配置文件，你还会发现出现了一些变化：</p>
<h4 id="第三步：演示故障转移"><a href="#第三步：演示故障转移" class="headerlink" title="第三步：演示故障转移"></a>第三步：演示故障转移</h4><p>首先，我们使用 <code>kill -9</code> 命令来杀掉主节点，<strong>同时</strong> 在哨兵节点中执行 <code>info Sentinel</code> 命令来观察故障节点的过程：</p>
<pre class=" language-bash"><code class="language-bash">➜  ~ <span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> 6379
longtao          74529   0.3  0.0  4346936   2132   ??  Ss   10:30上午   0:03.09 redis-server *:26379 <span class="token punctuation">[</span>sentinel<span class="token punctuation">]</span>
longtao          73541   0.2  0.0  4348072   2292   ??  Ss   10:18上午   0:04.79 redis-server *:6379
longtao          75521   0.0  0.0  4286728    728 s008  S+   10:39上午   0:00.00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto --exclude-dir<span class="token operator">=</span>.bzr --exclude-dir<span class="token operator">=</span>CVS --exclude-dir<span class="token operator">=</span>.git --exclude-dir<span class="token operator">=</span>.hg --exclude-dir<span class="token operator">=</span>.svn 6379
longtao          74836   0.0  0.0  4289844    944 s006  S+   10:32上午   0:00.01 redis-cli -p 26379
➜  ~ <span class="token function">kill</span> -9 73541</code></pre>
<p>如果 <strong>刚杀掉瞬间</strong> 在哨兵节点中执行 <code>info</code> 命令来查看，会发现主节点还没有切换过来，因为哨兵发现主节点故障并转移需要一段时间：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 第一时间查看哨兵节点发现并未转移，还在 6379 端口</span>
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6379,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>一段时间之后你再执行 <code>info</code> 命令，查看，你就会发现主节点已经切换成了 <code>6381</code> 端口的从节点：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 过一段时间之后在执行，发现已经切换了 6381 端口</span>
127.0.0.1:26379<span class="token operator">></span> info Sentinel
<span class="token comment" spellcheck="true"># Sentinel</span>
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name<span class="token operator">=</span>mymaster,status<span class="token operator">=</span>ok,address<span class="token operator">=</span>127.0.0.1:6381,slaves<span class="token operator">=</span>2,sentinels<span class="token operator">=</span>3</code></pre>
<p>但同时还可以发现，<strong>哨兵节点认为新的主节点仍然有两个从节点</strong> <em>(上方 slaves=2)</em>，这是因为哨兵在将 <code>6381</code> 切换成主节点的同时，将 <code>6379</code> 节点置为其从节点。虽然 <code>6379</code> 从节点已经挂掉，但是由于 <strong>哨兵并不会对从节点进行客观下线</strong>，因此认为该从节点一直存在。当 <code>6379</code> 节点重新启动后，会自动变成 <code>6381</code> 节点的从节点。</p>
<p>另外，在故障转移的阶段，哨兵和主从节点的配置文件都会被改写：</p>
<ul>
<li><strong>对于主从节点：</strong> 主要是 <code>slaveof</code> 配置的变化，新的主节点没有了 <code>slaveof</code> 配置，其从节点则 <code>slaveof</code> 新的主节点。</li>
<li><strong>对于哨兵节点：</strong> 除了主从节点信息的变化，纪元(epoch) <em>(记录当前集群状态的参数)</em> 也会变化，纪元相关的参数都 +1 了。</li>
</ul>
<h2 id="客户端访问哨兵系统代码演示"><a href="#客户端访问哨兵系统代码演示" class="headerlink" title="客户端访问哨兵系统代码演示"></a>客户端访问哨兵系统代码演示</h2><p>上面我们在 <em>快速体验</em> 中主要感受到了服务端自己对于当前主从节点的自动化治理，下面我们以 Java 代码为例，来演示一下客户端如何访问我们的哨兵系统：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSentinel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
         String masterName <span class="token operator">=</span> <span class="token string">"mymaster"</span><span class="token punctuation">;</span>
         Set<span class="token operator">&lt;</span>String<span class="token operator">></span> sentinels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26379"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26380"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         sentinels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1:26381"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">// 初始化过程做了很多工作</span>
         JedisSentinelPool pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span>masterName<span class="token punctuation">,</span> sentinels<span class="token punctuation">)</span><span class="token punctuation">;</span> 
         Jedis jedis <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         pool<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="客户端原理"><a href="#客户端原理" class="headerlink" title="客户端原理"></a>客户端原理</h4><p>Jedis 客户端对哨兵提供了很好的支持。如上述代码所示，我们只需要向 Jedis 提供哨兵节点集合和 <code>masterName</code> ，构造 <code>JedisSentinelPool</code> 对象，然后便可以像使用普通 Redis 连接池一样来使用了：通过 <code>pool.getResource()</code> 获取连接，执行具体的命令。</p>
<p>在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点；代码中对故障转移没有任何体现，就可以在哨兵完成故障转移后自动的切换主节点。之所以可以做到这一点，是因为在 <code>JedisSentinelPool</code> 的构造器中，进行了相关的工作；主要包括以下两点：</p>
<ol>
<li><strong>遍历哨兵节点，获取主节点信息：</strong> 遍历哨兵节点，通过其中一个哨兵节点 + <code>masterName</code> 获得主节点的信息；该功能是通过调用哨兵节点的 <code>sentinel get-master-addr-by-name</code> 命令实现；</li>
<li><strong>增加对哨兵的监听：</strong> 这样当发生故障转移时，客户端便可以收到哨兵的通知，从而完成主节点的切换。具体做法是：利用 Redis 提供的 <strong>发布订阅</strong> 功能，为每一个哨兵节点开启一个单独的线程，订阅哨兵节点的 + switch-master 频道，当收到消息时，重新初始化连接池。</li>
</ol>
<h2 id="新的主服务器是怎样被挑选出来的？"><a href="#新的主服务器是怎样被挑选出来的？" class="headerlink" title="新的主服务器是怎样被挑选出来的？"></a>新的主服务器是怎样被挑选出来的？</h2><p><strong>故障转移操作的第一步</strong> 要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好、数据完整的从服务器，然后向这个从服务器发送 <code>slaveof no one</code> 命令，将这个从服务器转换为主服务器。但是这个从服务器是怎么样被挑选出来的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-02dfea57f44fc27e.png" alt=""></p>
<p>简单来说 Sentinel 使用以下规则来选择新的主服务器：</p>
<ol>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被 <strong>淘汰</strong>。</li>
<li>在 <strong>经历了以上两轮淘汰之后</strong> 剩下来的从服务器中， 我们选出 <strong>复制偏移量（replication offset）最大</strong> 的那个 <strong>从服务器</strong> 作为新的主服务器；如果复制偏移量不可用，或者从服务器的复制偏移量相同，那么 <strong>带有最小运行 ID</strong> 的那个从服务器成为新的主服务器。</li>
</ol>
<h1 id="四、Redis-集群"><a href="#四、Redis-集群" class="headerlink" title="四、Redis 集群"></a>四、Redis 集群</h1><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-516eb4a9465451a6.png" alt=""></p>
<p><em>上图</em> 展示了 <strong>Redis Cluster</strong> 典型的架构图，集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-f65c71ca6811c634.png" alt=""></p>
<p>Redis 集群中内置了 <code>16384</code> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <code>key</code> 值进行操作时，会计算出它的一个 Hash 值，然后把结果对 <code>16384</code>  <strong>求余数</strong>，这样每个 <code>key</code> 都会对应一个编号在 <code>0-16383</code> 之间的哈希槽，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>再结合集群的配置信息就能够知道这个 <code>key</code> 值应该存储在哪一个具体的 Redis 节点中，如果不属于自己管，那么就会使用一个特殊的 <code>MOVED</code> 命令来进行一个跳转，告诉客户端去连接这个节点以获取数据：</p>
<pre class=" language-bash"><code class="language-bash">GET x
-MOVED 3999 127.0.0.1:6381</code></pre>
<p><code>MOVED</code> 指令第一个参数 <code>3999</code> 是 <code>key</code> 对应的槽位编号，后面是目标节点地址，<code>MOVED</code> 命令前面有一个减号，表示这是一个错误的消息。客户端在收到 <code>MOVED</code> 指令后，就立即纠正本地的 <strong>槽位映射表</strong>，那么下一次再访问 <code>key</code> 时就能够到正确的地方去获取了。</p>
<h4 id="集群的主要作用"><a href="#集群的主要作用" class="headerlink" title="集群的主要作用"></a>集群的主要作用</h4><ol>
<li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及，例如，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出……</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ol>
<h2 id="快速体验-2"><a href="#快速体验-2" class="headerlink" title="快速体验"></a>快速体验</h2><h4 id="第一步：创建集群节点配置文件"><a href="#第一步：创建集群节点配置文件" class="headerlink" title="第一步：创建集群节点配置文件"></a>第一步：创建集群节点配置文件</h4><p>首先我们找一个地方创建一个名为 <code>redis-cluster</code> 的目录：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/Desktop/redis-cluster</code></pre>
<p>然后按照上面的方法，创建六个配置文件，分别命名为：<code>redis_7000.conf</code>/<code>redis_7001.conf</code>…..<code>redis_7005.conf</code>，然后根据不同的端口号修改对应的端口值就好了：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 后台执行</span>
daemonize <span class="token function">yes</span>
<span class="token comment" spellcheck="true"># 端口号</span>
port 7000
<span class="token comment" spellcheck="true"># 为每一个集群节点指定一个 pid_file</span>
pidfile ~/Desktop/redis-cluster/redis_7000.pid
<span class="token comment" spellcheck="true"># 启动集群模式</span>
cluster-enabled <span class="token function">yes</span>
<span class="token comment" spellcheck="true"># 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通</span>
cluster-config-file nodes-7000.conf
<span class="token comment" spellcheck="true"># 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败</span>
cluster-node-timeout 5000
<span class="token comment" spellcheck="true"># 最后将 appendonly 改成 yes(AOF 持久化)</span>
appendonly <span class="token function">yes</span></code></pre>
<p>记得把对应上述配置文件中根端口对应的配置都修改掉 <em>(port/ pidfile/ cluster-config-file)</em>。</p>
<h4 id="第二步：分别启动-6-个-Redis-实例"><a href="#第二步：分别启动-6-个-Redis-实例" class="headerlink" title="第二步：分别启动 6 个 Redis 实例"></a>第二步：分别启动 6 个 Redis 实例</h4><pre class=" language-bash"><code class="language-bash">redis-server ~/Desktop/redis-cluster/redis_7000.conf
redis-server ~/Desktop/redis-cluster/redis_7001.conf
redis-server ~/Desktop/redis-cluster/redis_7002.conf
redis-server ~/Desktop/redis-cluster/redis_7003.conf
redis-server ~/Desktop/redis-cluster/redis_7004.conf
redis-server ~/Desktop/redis-cluster/redis_7005.conf</code></pre>
<p>然后执行 <code>ps -ef | grep redis</code> 查看是否启动成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-452c3152054c36f1.png" alt=""></p>
<p>可以看到 <code>6</code> 个 Redis 节点都以集群的方式成功启动了，<strong>但是现在每个节点还处于独立的状态</strong>，也就是说它们每一个都各自成了一个集群，还没有互相联系起来，我们需要手动地把他们之间建立起联系。</p>
<h4 id="第三步：建立集群"><a href="#第三步：建立集群" class="headerlink" title="第三步：建立集群"></a>第三步：建立集群</h4><p>执行下列命令：</p>
<pre class=" language-bash"><code class="language-bash">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code></pre>
<ul>
<li>这里稍微解释一下这个 <code>--replicas 1</code> 的意思是：我们希望为集群中的每个主节点创建一个从节点。</li>
</ul>
<p>观察控制台输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-d5ab644e76e9cc87.png" alt=""></p>
<p>看到 <code>[OK]</code> 的信息之后，就表示集群已经搭建成功了，可以看到，这里我们正确地创建了三主三从的集群。</p>
<h4 id="第四步：验证集群"><a href="#第四步：验证集群" class="headerlink" title="第四步：验证集群"></a>第四步：验证集群</h4><p>我们先使用 <code>redic-cli</code> 任意连接一个节点：</p>
<pre class=" language-bash"><code class="language-bash">redis-cli -c -h 127.0.0.1 -p 7000
127.0.0.1:7000<span class="token operator">></span></code></pre>
<ul>
<li><code>-c</code>表示集群模式；<code>-h</code> 指定 ip 地址；<code>-p</code> 指定端口。</li>
</ul>
<p>然后随便 <code>set</code> 一些值观察控制台输入：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:7000<span class="token operator">></span> SET name wmyskxz
-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>5798<span class="token punctuation">]</span> located at 127.0.0.1:7001
OK
127.0.0.1:7001<span class="token operator">></span></code></pre>
<p>可以看到这里 Redis 自动帮我们进行了 <code>Redirected</code> 操作跳转到了 <code>7001</code> 这个实例上。</p>
<p>我们再使用 <code>cluster info</code> <em>(查看集群信息)</em> 和 <code>cluster nodes</code> <em>(查看节点列表)</em> 来分别看看：<em>(任意节点输入均可)</em></p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:7001<span class="token operator">></span> CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:2
cluster_stats_messages_ping_sent:1365
cluster_stats_messages_pong_sent:1358
cluster_stats_messages_meet_sent:4
cluster_stats_messages_sent:2727
cluster_stats_messages_ping_received:1357
cluster_stats_messages_pong_received:1369
cluster_stats_messages_meet_received:1
cluster_stats_messages_received:2727

127.0.0.1:7001<span class="token operator">></span> CLUSTER NODES
56a04742f36c6e84968cae871cd438935081e86f 127.0.0.1:7003@17003 slave 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 0 1584428884000 4 connected
4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 127.0.0.1:7000@17000 master - 0 1584428884000 1 connected 0-5460
e2539c4398b8258d3f9ffa714bd778da107cb2cd 127.0.0.1:7005@17005 slave a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 0 1584428885222 6 connected
d31cd1f423ab1e1849cac01ae927e4b6950f55d9 127.0.0.1:7004@17004 slave 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 0 1584428884209 5 connected
236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 127.0.0.1:7001@17001 myself,master - 0 1584428882000 2 connected 5461-10922
a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 127.0.0.1:7002@17002 master - 0 1584428884000 3 connected 10923-16383
127.0.0.1:7001<span class="token operator">></span></code></pre>
<h2 id="数据分区方案简析"><a href="#数据分区方案简析" class="headerlink" title="数据分区方案简析"></a>数据分区方案简析</h2><h4 id="方案一：哈希值-节点数"><a href="#方案一：哈希值-节点数" class="headerlink" title="方案一：哈希值 % 节点数"></a>方案一：哈希值 % 节点数</h4><p>哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<h4 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h4><p>一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 - 2<sup>32 - 1</sup>]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-40e8a2c096c8da92.png" alt=""></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<h4 id="方案三：带有虚拟节点的一致性哈希分区"><a href="#方案三：带有虚拟节点的一致性哈希分区" class="headerlink" title="方案三：带有虚拟节点的一致性哈希分区"></a>方案三：带有虚拟节点的一致性哈希分区</h4><p>该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)； </p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
<h2 id="节点通信机制简析"><a href="#节点通信机制简析" class="headerlink" title="节点通信机制简析"></a>节点通信机制简析</h2><p>集群的建立离不开节点之间的通信，例如我们上访在 <em>快速体验</em> 中刚启动六个集群节点之后通过 <code>redis-cli</code> 命令帮助我们搭建起来了集群，实际上背后每个集群之间的两两连接是通过了 <code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令发送 <code>MEET</code> 消息完成的，下面我们展开详细说说。</p>
<h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在 <strong>哨兵系统</strong> 中，节点分为 <strong>数据节点</strong> 和 <strong>哨兵节点</strong>：前者存储数据，后者实现额外的控制功能。在 <strong>集群</strong> 中，没有数据节点与非数据节点之分：<strong>所有的节点都存储数据，也都参与集群状态的维护</strong>。为此，集群中的每个节点，都提供了两个 TCP 端口：</p>
<ul>
<li><strong>普通端口：</strong> 即我们在前面指定的端口 <em>(7000等)</em>。普通端口主要用于为客户端提供服务 <em>（与单机节点类似）</em>；但在节点间数据迁移时也会使用。</li>
<li><strong>集群端口：</strong> 端口号是普通端口 + 10000 <em>（10000是固定值，无法改变）</em>，如 <code>7000</code> 节点的集群端口为 <code>17000</code>。<strong>集群端口只用于节点之间的通信</strong>，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</li>
</ul>
<h4 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h4><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。重点是广播和 Gossip 的对比。</p>
<ul>
<li>广播是指向集群内所有节点发送消息。<strong>优点</strong> 是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，<strong>缺点</strong> 是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li>
<li>Gossip 协议的特点是：在节点数量有限的网络中，<strong>每个节点都 “随机” 的与部分节点通信</strong> <em>（并不是真正的随机，而是根据特定的规则选择通信的节点）<em>，经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip 协议的 *</em>优点** 有负载 *(比广播)</em> 低、去中心化、容错性高 <em>(因为通信有冗余)</em> 等；<strong>缺点</strong> 主要是集群的收敛速度慢。</li>
</ul>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为 <code>5</code> 种：<code>meet 消息</code>、<code>ping 消息</code>、<code>pong 消息</code>、<code>fail 消息</code>、<code>publish 消息</code>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息：</strong> 集群里每个节点每秒钟会选择部分节点发送 <code>PING</code> 消息，接收者收到消息后会回复一个 <code>PONG</code> 消息。<strong>PING 消息的内容是自身节点和部分其他节点的状态信息</strong>，作用是彼此交换信息，以及检测节点是否在线。<code>PING</code> 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，<strong>具体规则如下</strong>：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 <code>PONG</code> 消息时间大于 <code>cluster_node_timeout / 2</code> 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h2 id="数据结构简析"><a href="#数据结构简析" class="headerlink" title="数据结构简析"></a>数据结构简析</h2><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是 <code>clusterNode</code> 和 <code>clusterState</code> 结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。</p>
<h4 id="clusterNode-结构"><a href="#clusterNode-结构" class="headerlink" title="clusterNode 结构"></a>clusterNode 结构</h4><p><code>clusterNode</code> 结构保存了 <strong>一个节点的当前状态</strong>，包括创建时间、节点 id、ip 和端口号等。每个节点都会用一个 <code>clusterNode</code> 结构记录自己的状态，并为集群内所有其他节点都创建一个 <code>clusterNode</code> 结构来记录节点状态。</p>
<p>下面列举了 <code>clusterNode</code> 的部分字段，并说明了字段的含义和作用：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterNode <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//节点创建时间</span>
    mstime_t ctime<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点id</span>
    <span class="token keyword">char</span> name<span class="token punctuation">[</span>REDIS_CLUSTER_NAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点的ip和端口号</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span>REDIS_IP_STR_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元：故障转移时起作用，类似于哨兵的配置纪元</span>
    uint64_t configEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//节点中槽的数量</span>
    <span class="token keyword">int</span> numslots<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterNode<span class="token punctuation">;</span></code></pre>
<p>除了上述字段，<code>clusterNode</code> 还包含节点连接、主从复制、故障发现和转移需要的信息等。</p>
<h4 id="clusterState-结构"><a href="#clusterState-结构" class="headerlink" title="clusterState 结构"></a>clusterState 结构</h4><p><code>clusterState</code> 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> clusterState <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自身节点</span>
    clusterNode <span class="token operator">*</span>myself<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//配置纪元</span>
    uint64_t currentEpoch<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群状态：在线还是下线</span>
    <span class="token keyword">int</span> state<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//集群中至少包含一个槽的节点数量</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//哈希表，节点名称->clusterNode节点指针</span>
    dict <span class="token operator">*</span>nodes<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL</span>
    clusterNode <span class="token operator">*</span>slots<span class="token punctuation">[</span><span class="token number">16384</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span> clusterState<span class="token punctuation">;</span></code></pre>
<p>除此之外，<code>clusterState</code> 还包括故障转移、槽迁移等需要的信息。</p>
<blockquote>
<p>更多关于集群内容请自行阅读《Redis 设计与实现》，其中有更多细节方面的介绍 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></p>
</blockquote>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
<li>Redis(6)——GeoHash查找附近的人<a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
<li>Redis(8)——发布/订阅与Stream - <a href="https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">https://www.wmyskxz.com/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《Redis 设计与实现》 | 黄健宏 著 - <a href="http://redisbook.com/" target="_blank" rel="noopener">http://redisbook.com/</a></li>
<li>《Redis 深度历险》 | 钱文品 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>深入学习Redis（3）：主从复制 - <a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></li>
<li>Redis 主从复制 原理与用法 - <a href="https://blog.csdn.net/Stubborn_Cow/article/details/50442950" target="_blank" rel="noopener">https://blog.csdn.net/Stubborn_Cow/article/details/50442950</a></li>
<li>深入学习Redis（4）：哨兵 - <a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9609938.html</a></li>
<li>Redis 5 之后版本的高可用集群搭建 - <a href="https://www.jianshu.com/p/8045b92fafb2" target="_blank" rel="noopener">https://www.jianshu.com/p/8045b92fafb2</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BA%E3%80%90%E9%9B%86%E7%BE%A4%E3%80%91%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box shadow reveal ">
  


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h2 class="title">
    <a href="/2020/03/15/redis-8-fa-bu-ding-yue-yu-stream/">
      Redis(8)——发布/订阅与Stream
    </a>
  </h2>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a class='author' href="" rel="nofollow">
    <img no-lazy src="">
    <p></p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>中间件/JavaWeb进阶</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2020年3月15日</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  


            
          
            
              

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-31406a824536c54a.png" alt=""></p>
<h1 id="一、Redis-中的发布-订阅功能"><a href="#一、Redis-中的发布-订阅功能" class="headerlink" title="一、Redis 中的发布/订阅功能"></a>一、Redis 中的发布/订阅功能</h1><p><strong>发布/ 订阅系统</strong> 是 Web 系统中比较常用的一个功能。简单点说就是 <strong>发布者发布消息，订阅者接受消息</strong>，这有点类似于我们的报纸/ 杂志社之类的： <em>(借用前边的一张图)</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-13aa5cb2668368fe.png" alt=""></p>
<ul>
<li>图片引用自：「消息队列」看过来! - <a href="https://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/">https://www.wmyskxz.com/2019/07/16/xiao-xi-dui-lie-kan-guo-lai/</a></li>
</ul>
<p>从我们 <em>前面(下方相关阅读)</em> 学习的知识来看，我们虽然可以使用一个 <code>list</code> 列表结构结合 <code>lpush</code> 和 <code>rpop</code> 来实现消息队列的功能，但是似乎很难实现实现 <strong>消息多播</strong> 的功能：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-526a5b110a7c4ea2.png" alt=""></p>
<p>为了支持消息多播，<strong>Redis</strong> 不能再依赖于那 5 种基础的数据结构了，它单独使用了一个模块来支持消息多播，这个模块就是 <strong>PubSub</strong>，也就是 <strong>PublisherSubscriber</strong> <em>(发布者/ 订阅者模式)</em>。</p>
<h2 id="PubSub-简介"><a href="#PubSub-简介" class="headerlink" title="PubSub 简介"></a>PubSub 简介</h2><p>我们从 <em>上面的图</em> 中可以看到，基于 <code>list</code> 结构的消息队列，是一种 <code>Publisher</code> 与 <code>Consumer</code> 点对点的强关联关系，<strong>Redis</strong> 为了消除这样的强关联，引入了另一种概念：<strong>频道</strong> <em>(channel)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-cc3bb012eeca9fca.png" alt=""></p>
<p>当 <code>Publisher</code> 往 <code>channel</code> 中发布消息时，关注了指定 <code>channel</code> 的 <code>Consumer</code> 就能够同时受到消息。但这里的 <strong>问题</strong> 是，消费者订阅一个频道是必须 <strong>明确指定频道名称</strong> 的，这意味着，如果我们想要 <strong>订阅多个</strong> 频道，那么就必须 <strong>显式地关注多个</strong> 名称。</p>
<p>为了简化订阅的繁琐操作，<strong>Redis</strong> 提供了 <strong>模式订阅</strong> 的功能 <strong>Pattern Subscribe</strong>，这样就可以 <strong>一次性关注多个频道</strong> 了，即使生产者新增了同模式的频道，消费者也可以立即受到消息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-18ac258e4e9387da.png" alt=""></p>
<p>例如上图中，<strong>所有</strong> 位于图片下方的 <strong><code>Consumer</code> 都能够受到消息</strong>。</p>
<p><code>Publisher</code> 往 <code>wmyskxz.chat</code> 这个 <code>channel</code> 中发送了一条消息，不仅仅关注了这个频道的 <code>Consumer 1</code> 和 <code>Consumer 2</code> 能够受到消息，图片中的两个 <code>channel</code> 都和模式 <code>wmyskxz.*</code> 匹配，所以 <strong>Redis</strong> 此时会同样发送消息给订阅了 <code>wmyskxz.*</code> 这个模式的 <code>Consumer 3</code> 和关注了在这个模式下的另一个频道 <code>wmyskxz.log</code> 下的 <code>Consumer 4</code> 和 <code>Consumer 5</code>。</p>
<p>另一方面，如果接收消息的频道是 <code>wmyskxz.chat</code>，那么 <code>Consumer 3</code> 也会受到消息。  </p>
<h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p>在 <strong>Redis</strong> 中，<strong>PubSub</strong> 模块的使用非常简单，常用的命令也就下面这么几条：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 订阅频道：</span>
SUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 订阅给定的一个或多个频道的信息</span>
PSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 订阅一个或多个符合给定模式的频道</span>
<span class="token comment" spellcheck="true"># 发布频道：</span>
PUBLISH channel message  <span class="token comment" spellcheck="true"># 将消息发送到指定的频道</span>
<span class="token comment" spellcheck="true"># 退订频道：</span>
UNSUBSCRIBE <span class="token punctuation">[</span>channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 退订指定的频道</span>
PUNSUBSCRIBE <span class="token punctuation">[</span>pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#退订所有给定模式的频道</span></code></pre>
<p>我们可以在本地快速地来体验一下 <strong>PubSub</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-518e0d1e93135775.gif" alt=""></p>
<p>具体步骤如下：</p>
<ol>
<li>开启本地 Redis 服务，新建两个控制台窗口；</li>
<li>在其中一个窗口输入 <code>SUBSCRIBE wmyskxz.chat</code> 关注 <code>wmyskxz.chat</code> 频道，让这个窗口成为 <strong>消费者</strong>。</li>
<li>在另一个窗口输入 <code>PUBLISH wmyskxz.chat &#39;message&#39;</code> 往这个频道发送消息，这个时候就会看到 <strong>另一个窗口实时地出现</strong> 了发送的测试消息。</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>可以看到，我们通过很简单的两条命令，几乎就可以简单使用这样的一个 <strong>发布/ 订阅系统</strong> 了，但是具体是怎么样实现的呢？</p>
<p><strong>每个 Redis 服务器进程维持着一个标识服务器状态</strong> 的 <code>redis.h/redisServer</code> 结构，其中就 <strong>保存着有订阅的频道</strong> 以及 <strong>订阅模式</strong> 的信息：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
    dict <span class="token operator">*</span>pubsub_channels<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅频道</span>
    list <span class="token operator">*</span>pubsub_patterns<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅模式</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="订阅频道原理"><a href="#订阅频道原理" class="headerlink" title="订阅频道原理"></a>订阅频道原理</h3><p>当客户端订阅某一个频道之后，Redis 就会往 <code>pubsub_channels</code> 这个字典中新添加一条数据，实际上这个 <code>dict</code> 字典维护的是一张链表，比如，下图展示的 <code>pubsub_channels</code> 示例中，<code>client 1</code>、<code>client 2</code> 就订阅了 <code>channel 1</code>，而其他频道也分别被其他客户端订阅：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-218fc15f7c368eee.png" alt=""></p>
<h4 id="SUBSCRIBE-命令"><a href="#SUBSCRIBE-命令" class="headerlink" title="SUBSCRIBE 命令"></a>SUBSCRIBE 命令</h4><p><code>SUBSCRIBE</code> 命令的行为可以用下列的伪代码表示：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">SUBSCRIBE</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> channels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 遍历所有输入频道</span>
    <span class="token keyword">for</span> channel <span class="token keyword">in</span> channels<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 将客户端添加到链表的末尾</span>
        redisServer<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>client<span class="token punctuation">)</span></code></pre>
<p>通过 <code>pubsub_channels</code> 字典，程序只要检查某个频道是否为字典的键，就可以知道该频道是否正在被客户端订阅；只要取出某个键的值，就可以得到所有订阅该频道的客户端的信息。</p>
<h4 id="PUBLISH-命令"><a href="#PUBLISH-命令" class="headerlink" title="PUBLISH 命令"></a>PUBLISH 命令</h4><p>了解 <code>SUBSCRIBE</code>，那么 <code>PUBLISH</code> 命令的实现也变得十分简单了，只需要通过上述字典定位到具体的客户端，再把消息发送给它们就好了：<em>(伪代码实现如下)</em></p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 遍历所有订阅频道 channel 的客户端</span>
    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 将信息发送给它们</span>
        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span></code></pre>
<h4 id="UNSUBSCRIBE-命令"><a href="#UNSUBSCRIBE-命令" class="headerlink" title="UNSUBSCRIBE 命令"></a>UNSUBSCRIBE 命令</h4><p>使用 <code>UNSUBSCRIBE</code> 命令可以退订指定的频道，这个命令执行的是订阅的反操作：它从 <code>pubsub_channels</code> 字典的给定频道（键）中，删除关于当前客户端的信息，这样被退订频道的信息就不会再发送给这个客户端。</p>
<h3 id="订阅模式原理"><a href="#订阅模式原理" class="headerlink" title="订阅模式原理"></a>订阅模式原理</h3><p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-18ac258e4e9387da.png" alt=""></p>
<p>正如我们上面说到了，当发送一条消息到 <code>wmyskxz.chat</code> 这个频道时，Redis 不仅仅会发送到当前的频道，还会发送到匹配于当前模式的所有频道，实际上，<code>pubsub_patterns</code> 背后还维护了一个 <code>redis.h/pubsubPattern</code> 结构：</p>
<pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> pubsubPattern <span class="token punctuation">{</span>
    redisClient <span class="token operator">*</span>client<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 订阅模式的客户端</span>
    robj <span class="token operator">*</span>pattern<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 订阅的模式</span>
<span class="token punctuation">}</span> pubsubPattern<span class="token punctuation">;</span></code></pre>
<p>每当调用 <code>PSUBSCRIBE</code> 命令订阅一个模式时，程序就创建一个包含客户端信息和被订阅模式的 <code>pubsubPattern</code> 结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。</p>
<p>我们来看一个 <code>pusub_patterns</code> 链表的示例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-d0d3b1849fdb6162.png" alt=""></p>
<p>这个时候客户端 <code>client 3</code> 执行 <code>PSUBSCRIBE wmyskxz.java.*</code>，那么 <code>pubsub_patterns</code> 链表就会被更新成这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-edbf11995590de50.png" alt=""></p>
<p>通过遍历整个 <code>pubsub_patterns</code> 链表，程序可以检查所有正在被订阅的模式，以及订阅这些模式的客户端。</p>
<h4 id="PUBLISH-命令-1"><a href="#PUBLISH-命令-1" class="headerlink" title="PUBLISH 命令"></a>PUBLISH 命令</h4><p>上面给出的伪代码并没有 <strong>完整描述</strong> <code>PUBLISH</code> 命令的行为，因为 <code>PUBLISH</code> 除了将 <code>message</code> 发送到 <strong>所有订阅 <code>channel</code> 的客户端</strong> 之外，它还会将 <code>channel</code> 和 <code>pubsub_patterns</code> 中的 <strong>模式</strong> 进行对比，如果 <code>channel</code> 和某个模式匹配的话，那么也将 <code>message</code> 发送到 <strong>订阅那个模式的客户端</strong>。</p>
<p>完整描述 <code>PUBLISH</code> 功能的伪代码定于如下：</p>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">PUBLISH</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 遍历所有订阅频道 channel 的客户端</span>
    <span class="token keyword">for</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_channels<span class="token punctuation">[</span>channel<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 将信息发送给它们</span>
        send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 取出所有模式，以及订阅模式的客户端</span>
    <span class="token keyword">for</span> pattern<span class="token punctuation">,</span> client <span class="token keyword">in</span> server<span class="token punctuation">.</span>pubsub_patterns<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 如果 channel 和模式匹配</span>
        <span class="token keyword">if</span> match<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># 那么也将信息发给订阅这个模式的客户端</span>
            send_message<span class="token punctuation">(</span>client<span class="token punctuation">,</span> message<span class="token punctuation">)</span></code></pre>
<h4 id="PUNSUBSCRIBE-命令"><a href="#PUNSUBSCRIBE-命令" class="headerlink" title="PUNSUBSCRIBE 命令"></a>PUNSUBSCRIBE 命令</h4><p>使用 <code>PUNSUBSCRIBE</code> 命令可以退订指定的模式，这个命令执行的是订阅模式的反操作：序会删除 <code>redisServer.pubsub_patterns</code> 链表中，所有和被退订模式相关联的 <code>pubsubPattern</code> 结构，这样客户端就不会再收到和模式相匹配的频道发来的信息。</p>
<h2 id="PubSub-的缺点"><a href="#PubSub-的缺点" class="headerlink" title="PubSub 的缺点"></a>PubSub 的缺点</h2><p>尽管 <strong>Redis</strong> 实现了 <strong>PubSub</strong> 模式来达到了 <strong>多播消息队列</strong> 的目的，但在实际的消息队列的领域，几乎 <strong>找不到特别合适的场景</strong>，因为它的缺点十分明显：</p>
<ul>
<li><strong>没有 Ack 机制，也不保证数据的连续：</strong> PubSub 的生产者传递过来一个消息，Redis 会直接找到相应的消费者传递过去。如果没有一个消费者，那么消息会被直接丢弃。如果开始有三个消费者，其中一个突然挂掉了，过了一会儿等它再重连时，那么重连期间的消息对于这个消费者来说就彻底丢失了。</li>
<li><strong>不持久化消息：</strong> 如果 Redis 停机重启，PubSub 的消息是不会持久化的，毕竟 Redis 宕机就相当于一个消费者都没有，所有的消息都会被直接丢弃。</li>
</ul>
<p>基于上述缺点，Redis 的作者甚至单独开启了一个 Disque 的项目来专门用来做多播消息队列，不过该项目目前好像都没有成熟。不过后来在 2018 年 6 月，<strong>Redis 5.0</strong> 新增了 <code>Stream</code> 数据结构，这个功能给 Redis 带来了 <strong>持久化消息队列</strong>，从此 PubSub 作为消息队列的功能可以说是就消失了..</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-3a144fda1a0dafcb.gif" alt="image"></p>
<h1 id="二、更为强大的-Stream-持久化的发布-订阅系统"><a href="#二、更为强大的-Stream-持久化的发布-订阅系统" class="headerlink" title="二、更为强大的 Stream | 持久化的发布/订阅系统"></a>二、更为强大的 Stream | 持久化的发布/订阅系统</h1><p><strong>Redis Stream</strong> 从概念上来说，就像是一个 <strong>仅追加内容</strong> 的 <strong>消息链表</strong>，把所有加入的消息都一个一个串起来，每个消息都有一个唯一的 ID 和内容，这很简单，让它复杂的是从 Kafka 借鉴的另一种概念：<strong>消费者组(Consumer Group)</strong> <em>(思路一致，实现不同)</em>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-b9d8afde068a165f.png" alt=""></p>
<p>上图就展示了一个典型的 <strong>Stream</strong> 结构。每个 Stream 都有唯一的名称，它就是 Redis 的 <code>key</code>，在我们首次使用 <code>xadd</code> 指令追加消息时自动创建。我们对图中的一些概念做一下解释：</p>
<ul>
<li><strong>Consumer Group</strong>：消费者组，可以简单看成记录流状态的一种数据结构。消费者既可以选择使用 <code>XREAD</code> 命令进行 <strong>独立消费</strong>，也可以多个消费者同时加入一个消费者组进行 <strong>组内消费</strong>。同一个消费者组内的消费者共享所有的 Stream 信息，<strong>同一条消息只会有一个消费者消费到</strong>，这样就可以应用在分布式的应用场景中来保证消息的唯一性。</li>
<li><strong>last_delivered_id</strong>：用来表示消费者组消费在 Stream 上 <strong>消费位置</strong> 的游标信息。每个消费者组都有一个 Stream 内 <strong>唯一的名称</strong>，消费者组不会自动创建，需要使用 <code>XGROUP CREATE</code> 指令来显式创建，并且需要指定从哪一个消息 ID 开始消费，用来初始化 <code>last_delivered_id</code> 这个变量。</li>
<li><strong>pending_ids</strong>：每个消费者内部都有的一个状态变量，用来表示 <strong>已经</strong> 被客户端 <strong>获取</strong>，但是 <strong>还没有 ack</strong> 的消息。记录的目的是为了 <strong>保证客户端至少消费了消息一次</strong>，而不会在网络传输的中途丢失而没有对消息进行处理。如果客户端没有 ack，那么这个变量里面的消息 ID 就会越来越多，一旦某个消息被 ack，它就会对应开始减少。这个变量也被 Redis 官方称为 <strong>PEL</strong> <em>(Pending Entries List)</em>。</li>
</ul>
<h2 id="消息-ID-和消息内容"><a href="#消息-ID-和消息内容" class="headerlink" title="消息 ID 和消息内容"></a>消息 ID 和消息内容</h2><h4 id="消息-ID"><a href="#消息-ID" class="headerlink" title="消息 ID"></a>消息 ID</h4><p>消息 ID 如果是由 <code>XADD</code> 命令返回自动创建的话，那么它的格式会像这样：<code>timestampInMillis-sequence</code> <em>(毫秒时间戳-序列号)</em>，例如 <code>1527846880585-5</code>，它表示当前的消息是在毫秒时间戳 <code>1527846880585</code> 时产生的，并且是该毫秒内产生的第 5 条消息。</p>
<p>这些 ID 的格式看起来有一些奇怪，<strong>为什么要使用时间来当做 ID 的一部分呢？</strong> 一方面，我们要 <strong>满足 ID 自增</strong> 的属性，另一方面，也是为了 <strong>支持范围查找</strong> 的功能。由于 ID 和生成消息的时间有关，这样就使得在根据时间范围内查找时基本上是没有额外损耗的。</p>
<p>当然消息 ID 也可以由客户端自定义，但是形式必须是 <strong>“整数-整数”</strong>，而且后面加入的消息的 ID 必须要大于前面的消息 ID。</p>
<h4 id="消息内容"><a href="#消息内容" class="headerlink" title="消息内容"></a>消息内容</h4><p>消息内容就是普通的键值对，形如 hash 结构的键值对。</p>
<h2 id="增删改查示例"><a href="#增删改查示例" class="headerlink" title="增删改查示例"></a>增删改查示例</h2><p>增删改查命令很简单，详情如下：</p>
<ol>
<li><code>xadd</code>：追加消息</li>
<li><code>xdel</code>：删除消息，这里的删除仅仅是设置了标志位，不影响消息总长度</li>
<li><code>xrange</code>：获取消息列表，会自动过滤已经删除的消息</li>
<li><code>xlen</code>：消息长度</li>
<li><code>del</code>：删除Stream</li>
</ol>
<p>使用示例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># *号表示服务器自动生成ID，后面顺序跟着一堆key/value</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name laoqian age 30  <span class="token comment" spellcheck="true">#  名字叫laoqian，年龄30岁</span>
1527849609889-0  <span class="token comment" spellcheck="true"># 生成的消息ID</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name xiaoyu age 29
1527849629172-0
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name xiaoqian age 1
1527849637634-0
127.0.0.1:6379<span class="token operator">></span> xlen codehole
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6379<span class="token operator">></span> xrange codehole - +  <span class="token comment" spellcheck="true"># -表示最小值, +表示最大值</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849609889-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"30"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849637634-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> xrange codehole 1527849629172-0 +  <span class="token comment" spellcheck="true"># 指定最小消息ID的列表</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849637634-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> xrange codehole - 1527849629172-0  <span class="token comment" spellcheck="true"># 指定最大消息ID的列表</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849609889-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"30"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
127.0.0.1:6379<span class="token operator">></span> xdel codehole 1527849609889-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> xlen codehole  <span class="token comment" spellcheck="true"># 长度不受影响</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6379<span class="token operator">></span> xrange codehole - +  <span class="token comment" spellcheck="true"># 被删除的消息没了</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849629172-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoyu"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"29"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527849637634-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
      2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
      3<span class="token punctuation">)</span> <span class="token string">"age"</span>
      4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> del codehole  <span class="token comment" spellcheck="true"># 删除整个Stream</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1</code></pre>
<h2 id="独立消费示例"><a href="#独立消费示例" class="headerlink" title="独立消费示例"></a>独立消费示例</h2><p>我们可以在不定义消费组的情况下进行 Stream 消息的 <strong>独立消费</strong>，当 Stream 没有新消息时，甚至可以阻塞等待。Redis 设计了一个单独的消费指令 <code>xread</code>，可以将 Stream 当成普通的消息队列(list)来使用。使用 <code>xread</code> 时，我们可以完全忽略 <strong>消费组(Consumer Group)</strong> 的存在，就好比 Stream 就是一个普通的列表(list)：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 从Stream头部读取两条消息</span>
127.0.0.1:6379<span class="token operator">></span> xread count 2 streams codehole 0-0
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851486781-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"30"</span>
      2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851493405-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"yurui"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"29"</span>
<span class="token comment" spellcheck="true"># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span>
127.0.0.1:6379<span class="token operator">></span> xread count 1 streams codehole $
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span>
127.0.0.1:6379<span class="token operator">></span> xread block 0 count 1 streams codehole $
<span class="token comment" spellcheck="true"># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name youming age 60
1527852774092-0
<span class="token comment" spellcheck="true"># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span>
<span class="token comment" spellcheck="true"># 而且还显示了一个等待时间，这里我们等待了93s</span>
127.0.0.1:6379<span class="token operator">></span> xread block 0 count 1 streams codehole $
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527852774092-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"youming"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token punctuation">(</span>93.11s<span class="token punctuation">)</span></code></pre>
<p>客户端如果想要使用 <code>xread</code> 进行 <strong>顺序消费</strong>，一定要 <strong>记住当前消费</strong> 到哪里了，也就是返回的消息 ID。下次继续调用 <code>xread</code> 时，将上次返回的最后一个消息 ID 作为参数传递进去，就可以继续消费后续的消息。</p>
<p><code>block 0</code> 表示永远阻塞，直到消息到来，<code>block 1000</code> 表示阻塞 <code>1s</code>，如果 <code>1s</code> 内没有任何消息到来，就返回 <code>nil</code>：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> xread block 1000 count 1 streams codehole $
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token punctuation">(</span>1.07s<span class="token punctuation">)</span></code></pre>
<h2 id="创建消费者示例"><a href="#创建消费者示例" class="headerlink" title="创建消费者示例"></a>创建消费者示例</h2><p>Stream 通过 <code>xgroup create</code> 指令创建消费组(Consumer Group)，需要传递起始消息 ID 参数用来初始化 <code>last_delivered_id</code> 变量：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> xgroup create codehole cg1 0-0  <span class="token comment" spellcheck="true">#  表示从头开始消费</span>
OK
<span class="token comment" spellcheck="true"># $表示从尾部开始消费，只接受新消息，当前Stream消息会全部忽略</span>
127.0.0.1:6379<span class="token operator">></span> xgroup create codehole cg2 $
OK
127.0.0.1:6379<span class="token operator">></span> xinfo codehole  <span class="token comment" spellcheck="true"># 获取Stream信息</span>
 1<span class="token punctuation">)</span> length
 2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3  <span class="token comment" spellcheck="true"># 共3个消息</span>
 3<span class="token punctuation">)</span> radix-tree-keys
 4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
 5<span class="token punctuation">)</span> radix-tree-nodes
 6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
 7<span class="token punctuation">)</span> <span class="token function">groups</span>
 8<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2  <span class="token comment" spellcheck="true"># 两个消费组</span>
 9<span class="token punctuation">)</span> first-entry  <span class="token comment" spellcheck="true"># 第一个消息</span>
10<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851486781-0
    2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
       2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
       3<span class="token punctuation">)</span> <span class="token string">"age"</span>
       4<span class="token punctuation">)</span> <span class="token string">"30"</span>
11<span class="token punctuation">)</span> last-entry  <span class="token comment" spellcheck="true"># 最后一个消息</span>
12<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851498956-0
    2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
       2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
       3<span class="token punctuation">)</span> <span class="token string">"age"</span>
       4<span class="token punctuation">)</span> <span class="token string">"1"</span>
127.0.0.1:6379<span class="token operator">></span> xinfo <span class="token function">groups</span> codehole  <span class="token comment" spellcheck="true"># 获取Stream的消费组信息</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg1"</span>
   3<span class="token punctuation">)</span> consumers
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 该消费组还没有消费者</span>
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 该消费组没有正在处理的消息</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg2"</span>
   3<span class="token punctuation">)</span> consumers  <span class="token comment" spellcheck="true"># 该消费组还没有消费者</span>
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 该消费组没有正在处理的消息</span></code></pre>
<h2 id="组内消费示例"><a href="#组内消费示例" class="headerlink" title="组内消费示例"></a>组内消费示例</h2><p>Stream 提供了 <code>xreadgroup</code> 指令可以进行消费组的组内消费，需要提供 <strong>消费组名称、消费者名称和起始消息 ID</strong>。它同 <code>xread</code> 一样，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 <strong>PEL</strong> <em>(正在处理的消息)</em> 结构里，客户端处理完毕后使用 <code>xack</code> 指令 <strong>通知服务器</strong>，本条消息已经处理完毕，该消息 ID 就会从 <strong>PEL</strong> 中移除，下面是示例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># >号表示从当前消费组的last_delivered_id后面开始读</span>
<span class="token comment" spellcheck="true"># 每当消费者读取一条消息，last_delivered_id变量就会前进</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 1 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851486781-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"laoqian"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"30"</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 1 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851493405-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"yurui"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"29"</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 2 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527851498956-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"xiaoqian"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"1"</span>
      2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527852774092-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"youming"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token comment" spellcheck="true"># 再继续读取，就没有新消息了</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 count 1 streams codehole <span class="token operator">></span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 那就阻塞等待吧</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole <span class="token operator">></span>
<span class="token comment" spellcheck="true"># 开启另一个窗口，往里塞消息</span>
127.0.0.1:6379<span class="token operator">></span> xadd codehole * name lanying age 61
1527854062442-0
<span class="token comment" spellcheck="true"># 回到前一个窗口，发现阻塞解除，收到新消息了</span>
127.0.0.1:6379<span class="token operator">></span> xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole <span class="token operator">></span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"codehole"</span>
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1527854062442-0
         2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"name"</span>
            2<span class="token punctuation">)</span> <span class="token string">"lanying"</span>
            3<span class="token punctuation">)</span> <span class="token string">"age"</span>
            4<span class="token punctuation">)</span> <span class="token string">"61"</span>
<span class="token punctuation">(</span>36.54s<span class="token punctuation">)</span>
127.0.0.1:6379<span class="token operator">></span> xinfo <span class="token function">groups</span> codehole  <span class="token comment" spellcheck="true"># 观察消费组信息</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg1"</span>
   3<span class="token punctuation">)</span> consumers
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1  <span class="token comment" spellcheck="true"># 一个消费者</span>
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5  <span class="token comment" spellcheck="true"># 共5条正在处理的信息还有没有ack</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"cg2"</span>
   3<span class="token punctuation">)</span> consumers
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># 消费组cg2没有任何变化，因为前面我们一直在操纵cg1</span>
   5<span class="token punctuation">)</span> pending
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
<span class="token comment" spellcheck="true"># 如果同一个消费组有多个消费者，我们可以通过xinfo consumers指令观察每个消费者的状态</span>
127.0.0.1:6379<span class="token operator">></span> xinfo consumers codehole cg1  <span class="token comment" spellcheck="true"># 目前还有1个消费者</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"c1"</span>
   3<span class="token punctuation">)</span> pending
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5  <span class="token comment" spellcheck="true"># 共5条待处理消息</span>
   5<span class="token punctuation">)</span> idle
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 418715  <span class="token comment" spellcheck="true"># 空闲了多长时间ms没有读取消息了</span>
<span class="token comment" spellcheck="true"># 接下来我们ack一条消息</span>
127.0.0.1:6379<span class="token operator">></span> xack codehole cg1 1527851486781-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> xinfo consumers codehole cg1
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"c1"</span>
   3<span class="token punctuation">)</span> pending
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4  <span class="token comment" spellcheck="true"># 变成了5条</span>
   5<span class="token punctuation">)</span> idle
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 668504
<span class="token comment" spellcheck="true"># 下面ack所有消息</span>
127.0.0.1:6379<span class="token operator">></span> xack codehole cg1 1527851493405-0 1527851498956-0 1527852774092-0 1527854062442-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
127.0.0.1:6379<span class="token operator">></span> xinfo consumers codehole cg1
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> name
   2<span class="token punctuation">)</span> <span class="token string">"c1"</span>
   3<span class="token punctuation">)</span> pending
   4<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0  <span class="token comment" spellcheck="true"># pel空了</span>
   5<span class="token punctuation">)</span> idle
   6<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 745505</code></pre>
<h2 id="QA-1：Stream-消息太多怎么办？-Stream-的上限"><a href="#QA-1：Stream-消息太多怎么办？-Stream-的上限" class="headerlink" title="QA 1：Stream 消息太多怎么办？ | Stream 的上限"></a>QA 1：Stream 消息太多怎么办？ | Stream 的上限</h2><p>很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉就是个问题了。<code>xdel</code> 指令又不会删除消息，它只是给消息做了个标志位。</p>
<p>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 <code>xadd</code> 的指令提供一个定长长度 <code>maxlen</code>，就可以将老的消息干掉，确保最多不超过指定长度，使用起来也很简单：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> XADD mystream MAXLEN 2 * value 1
1526654998691-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 2
1526654999635-0
<span class="token operator">></span> XADD mystream MAXLEN 2 * value 3
1526655000369-0
<span class="token operator">></span> XLEN mystream
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token operator">></span> XRANGE mystream - +
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526654999635-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"2"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> 1526655000369-0
   2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"value"</span>
      2<span class="token punctuation">)</span> <span class="token string">"3"</span></code></pre>
<p>如果使用 <code>MAXLEN</code> 选项，当 Stream 的达到指定长度后，老的消息会自动被淘汰掉，因此 Stream 的大小是恒定的。目前还没有选项让 Stream 只保留给定数量的条目，因为为了一致地运行，这样的命令必须在很长一段时间内阻塞以淘汰消息。<em>(例如在添加数据的高峰期间，你不得不长暂停来淘汰旧消息和添加新的消息)</em></p>
<p>另外使用 <code>MAXLEN</code> 选项的花销是很大的，Stream 为了节省内存空间，采用了一种特殊的结构表示，而这种结构的调整是需要额外的花销的。所以我们可以使用一种带有 <code>~</code> 的特殊命令：</p>
<pre class=" language-bash"><code class="language-bash">XADD mystream MAXLEN ~ 1000 * <span class="token punctuation">..</span>. entry fields here <span class="token punctuation">..</span>.</code></pre>
<p>它会基于当前的结构合理地对节点执行裁剪，来保证至少会有 <code>1000</code> 条数据，可能是 <code>1010</code> 也可能是 <code>1030</code>。</p>
<h2 id="QA-2：PEL-是如何避免消息丢失的？"><a href="#QA-2：PEL-是如何避免消息丢失的？" class="headerlink" title="QA 2：PEL 是如何避免消息丢失的？"></a>QA 2：PEL 是如何避免消息丢失的？</h2><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID，待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数 <code>&gt;</code> ，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自 <code>last_delivered_id</code> 之后的新消息。</p>
<h2 id="Redis-Stream-Vs-Kafka"><a href="#Redis-Stream-Vs-Kafka" class="headerlink" title="Redis Stream Vs Kafka"></a>Redis Stream Vs Kafka</h2><p>Redis 基于内存存储，这意味着它会比基于磁盘的 Kafka 快上一些，也意味着使用 Redis 我们 <strong>不能长时间存储大量数据</strong>。不过如果您想以 <strong>最小延迟</strong> 实时处理消息的话，您可以考虑 Redis，但是如果 <strong>消息很大并且应该重用数据</strong> 的话，则应该首先考虑使用 Kafka。</p>
<p>另外从某些角度来说，<code>Redis Stream</code> 也更适用于小型、廉价的应用程序，因为 <code>Kafka</code> 相对来说更难配置一些。</p>
<h1 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h1><ol>
<li>Redis(1)——5种基本数据结构 - <a href="https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/">https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/</a></li>
<li>Redis(2)——跳跃表 - <a href="https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/">https://www.wmyskxz.com/2020/02/29/redis-2-tiao-yue-biao/</a></li>
<li>Redis(3)——分布式锁深入探究 - <a href="https://www.wmyskxz.com/2020/03/01/redis-3/">https://www.wmyskxz.com/2020/03/01/redis-3/</a></li>
<li>Reids(4)——神奇的HyperLoglog解决统计问题 - <a href="https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/">https://www.wmyskxz.com/2020/03/02/reids-4-shen-qi-de-hyperloglog-jie-jue-tong-ji-wen-ti/</a></li>
<li>Redis(5)——亿级数据过滤和布隆过滤器 - <a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></li>
<li>Redis(6)——GeoHash查找附近的人<a href="https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/">https://www.wmyskxz.com/2020/03/12/redis-6-geohash-cha-zhao-fu-jin-de-ren/</a></li>
<li>Redis(7)——持久化【一文了解】 - <a href="https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/">https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/</a></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>订阅与发布——Redis 设计与实现 - <a href="https://redisbook.readthedocs.io/en/latest/feature/pubsub.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/feature/pubsub.html</a></li>
<li>《Redis 深度历险》 - 钱文品/ 著 - <a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">https://book.douban.com/subject/30386804/</a></li>
<li>Introduction to Redis Streams【官方文档】 - <a href="https://redis.io/topics/streams-intro" target="_blank" rel="noopener">https://redis.io/topics/streams-intro</a></li>
<li>Kafka vs. Redis: Log Aggregation Capabilities and Performance - <a href="https://logz.io/blog/kafka-vs-redis/" target="_blank" rel="noopener">https://logz.io/blog/kafka-vs-redis/</a></li>
</ol>
<blockquote>
<ul>
<li>本文已收录至我的 Github 程序员成长系列 <strong>【More Than Java】，学习，不止 Code，欢迎 star：<a href="https://github.com/wmyskxz/MoreThanJava" target="_blank" rel="noopener">https://github.com/wmyskxz/MoreThanJava</a></strong></li>
<li><strong>个人公众号</strong> ：wmyskxz，<strong>个人独立域名博客</strong>：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wmyskxz/img/img/Redis%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E4%B8%8EStream/7896890-fca34cfd601e7449.png" alt=""></p>
<p>非常感谢各位人才能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「我没有三颗心脏」有点东西</strong> 的话，<strong>求点赞，求关注，求分享，求留言！</strong></p>
<p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p>

      
    </div>
    
      
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/archives/2020/page/2/">
            <section class="post prev white-box shadow" >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          3 / 5
        </p>
        
          <a class="next" rel="next" href="/archives/2020/page/4/">
            <section class="post next white-box shadow">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


	
</div>
<aside class='l_side'>
  
  
    
    

<section class="widget blogger shadow desktop mobile">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img no-lazy src='https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/avatar.png'/>
        </a>
      
    
    
      <div class='text'>
        
        
          <p>想做一个自由且自律的人，靠势必实现的决心认真地或者</p>

        
        
      </div>
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xxx.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/volantis-x/"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=260045301"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

  

  
    
    
  

  <section class="widget category shadow desktop">
    
  <header>
    
      <a href='/blog/categories/'><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span></a>
    
  </header>


    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/categories/Java-Web/" href="/categories/Java-Web/"
            id="categoriesJava-Web"
            ><div class='name'>Java Web</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/Spring/" href="/categories/Java-Web/Spring/"
            id="categoriesJava-WebSpring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/Java-Web/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesJava-WebE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaWebE59FBAE7A180"
            ><div class='name'>JavaWeb基础</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/"
            id="categoriesJavaWebE59FBAE7A180SSM"
            ><div class='name'>SSM</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SSM/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180SSME9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring-MVC/"
            id="categoriesJavaWebE59FBAE7A180Spring-MVC"
            ><div class='name'>Spring MVC</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/Spring/"
            id="categoriesJavaWebE59FBAE7A180Spring"
            ><div class='name'>Spring</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/SpringBoot/"
            id="categoriesJavaWebE59FBAE7A180SpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E5%9F%BA%E7%A1%80/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE59FBAE7A180E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesJavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6Spring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/Spring-Boot/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6Spring-BootE9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesJavaWebE8BF9BE998B6E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E5898DE7ABAFSpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
            id="categoriesJavaWebE8BF9BE998B6E5BEAEE69C8DE58AA1"
            ><div class='name'>微服务</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesJavaWebE8BF9BE998B6E69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAE"
            ><div class='name'>项目</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/" href="/categories/JavaWeb%E8%BF%9B%E9%98%B6/%E9%A1%B9%E7%9B%AE/Spring-Boot/"
            id="categoriesJavaWebE8BF9BE998B6E9A1B9E79BAESpring-Boot"
            ><div class='name'>Spring Boot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Java%E5%9F%BA%E7%A1%80/" href="/categories/Java%E5%9F%BA%E7%A1%80/"
            id="categoriesJavaE59FBAE7A180"
            ><div class='name'>Java基础</div><div class='badge'>(15)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
            id="categoriesJavaE59FBAE7A180E5B9B6E58F91E7BC96E7A88B"
            ><div class='name'>并发编程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/"
            id="categoriesJavaE59FBAE7A180E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/MoreThanJava/" href="/categories/MoreThanJava/"
            id="categoriesMoreThanJava"
            ><div class='name'>MoreThanJava</div><div class='badge'>(12)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/MoreThanJava/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesMoreThanJavaE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" href="/categories/MoreThanJava/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/"
            id="categoriesMoreThanJavaE79FA5E4B98EE997AEE9A298"
            ><div class='name'>知乎问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Python/" href="/categories/Python/"
            id="categoriesPython"
            ><div class='name'>Python</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/Python/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesPythonE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Redis/" href="/categories/Redis/"
            id="categoriesRedis"
            ><div class='name'>Redis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/Redis/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesRedisE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Ruby/" href="/categories/Ruby/"
            id="categoriesRuby"
            ><div class='name'>Ruby</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/Spring-Cloud/" href="/categories/Spring-Cloud/"
            id="categoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/JavaWeb%E8%BF%9B%E9%98%B6/"
            id="categoriesE4B8ADE997B4E4BBB6JavaWebE8BF9BE998B6"
            ><div class='name'>JavaWeb进阶</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/" href="/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9Awmyskxz/"
            id="categoriesE585ACE4BC97E58FB7EFBC9Awmyskxz"
            ><div class='name'>公众号：wmyskxz</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%89%8D%E7%AB%AF/" href="/categories/%E5%89%8D%E7%AB%AF/"
            id="categoriesE5898DE7ABAF"
            ><div class='name'>前端</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" href="/categories/%E5%89%8D%E7%AB%AF/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/"
            id="categoriesE5898DE7ABAFE68782E4B880E782B9E7B3BBE58897"
            ><div class='name'>懂一点系列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" href="/categories/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/"
            id="categoriesE5969CE6ACA2E79A84E4B889E8A782"
            ><div class='name'>喜欢的三观</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"
            id="categoriesE5A49AE7BABFE7A88B"
            ><div class='name'>多线程</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" href="/categories/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/"
            id="categoriesE5A5BDE5A587E6989FE4BABA"
            ><div class='name'>好奇星人</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0"
            ><div class='name'>学习笔记</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java%E8%BF%9B%E9%98%B6/"
            id="categoriesE5ADA6E4B9A0E7AC94E8AEB0JavaE8BF9BE998B6"
            ><div class='name'>Java进阶</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395"
            ><div class='name'>数据结构与算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"
            id="categoriesE695B0E68DAEE7BB93E69E84E4B88EE7AE97E6B395E99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" href="/categories/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/"
            id="categoriesE69C89E8B6A3E99B86E4B8ADE890A5"
            ><div class='name'>有趣集中营</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" href="/categories/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"
            id="categoriesE69EB6E69E84E4B98BE8B7AF"
            ><div class='name'>架构之路</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%94%9F%E6%B4%BB/" href="/categories/%E7%94%9F%E6%B4%BB/"
            id="categoriesE7949FE6B4BB"
            ><div class='name'>生活</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/"
            id="categoriesE7BC96E7A88BE4BABAE7949F"
            ><div class='name'>编程人生</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/" href="/categories/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/%E9%9D%A2%E8%AF%95/"
            id="categoriesE7BC96E7A88BE4BABAE7949FE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/categories/%E9%9D%A2%E8%AF%95/" href="/categories/%E9%9D%A2%E8%AF%95/"
            id="categoriesE99DA2E8AF95"
            ><div class='name'>面试</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/" href="/categories/%E9%9D%A2%E8%AF%95/%E4%B8%AD%E9%97%B4%E4%BB%B6/"
            id="categoriesE99DA2E8AF95E4B8ADE997B4E4BBB6"
            ><div class='name'>中间件</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


  

  
    
    
  

  <section class="widget tagcloud shadow desktop mobile">
    
  <header>
    
      <a href='/blog/tags/'><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span></a>
    
  </header>


    <div class='content'>
      <a href="/tags/Docker/" style="font-size: 14px; color: #999">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 14px; color: #999">Elasticsearch</a> <a href="/tags/Java-Web/" style="font-size: 17.08px; color: #848484">Java Web</a> <a href="/tags/Java8/" style="font-size: 14px; color: #999">Java8</a> <a href="/tags/JavaWeb%E5%9F%BA%E7%A1%80/" style="font-size: 23.23px; color: #5a5a5a">JavaWeb基础</a> <a href="/tags/JavaWeb%E8%BF%9B%E9%98%B6/" style="font-size: 22.46px; color: #5f5f5f">JavaWeb进阶</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 21.69px; color: #656565">Java基础</a> <a href="/tags/Kafka/" style="font-size: 14px; color: #999">Kafka</a> <a href="/tags/MongoDB/" style="font-size: 14px; color: #999">MongoDB</a> <a href="/tags/MoreThanJava/" style="font-size: 20.92px; color: #6a6a6a">MoreThanJava</a> <a href="/tags/MyBatis/" style="font-size: 15.54px; color: #8f8f8f">MyBatis</a> <a href="/tags/Python/" style="font-size: 14px; color: #999">Python</a> <a href="/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/tags/Redis/" style="font-size: 20.15px; color: #6f6f6f">Redis</a> <a href="/tags/Ruby/" style="font-size: 14.77px; color: #949494">Ruby</a> <a href="/tags/SSM/" style="font-size: 17.08px; color: #848484">SSM</a> <a href="/tags/Shiro/" style="font-size: 14px; color: #999">Shiro</a> <a href="/tags/Spring/" style="font-size: 17.85px; color: #7f7f7f">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.85px; color: #7f7f7f">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/Spring-MVC/" style="font-size: 14px; color: #999">Spring MVC</a> <a href="/tags/Vue/" style="font-size: 14px; color: #999">Vue</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 21.69px; color: #656565">中间件</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 14.77px; color: #949494">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.54px; color: #8f8f8f">前端</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 24px; color: #555">原创</a> <a href="/tags/%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%89%E8%A7%82/" style="font-size: 16.31px; color: #898989">喜欢的三观</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 14.77px; color: #949494">多线程</a> <a href="/tags/%E5%A5%BD%E5%A5%87%E6%98%9F%E4%BA%BA/" style="font-size: 15.54px; color: #8f8f8f">好奇星人</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 17.85px; color: #7f7f7f">学习笔记</a> <a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 14px; color: #999">导航</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 14.77px; color: #949494">并发编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 18.62px; color: #7a7a7a">总结</a> <a href="/tags/%E6%87%82%E4%B8%80%E7%82%B9%E7%B3%BB%E5%88%97/" style="font-size: 14.77px; color: #949494">懂一点系列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.31px; color: #898989">数据结构与算法</a> <a href="/tags/%E6%9C%89%E8%B6%A3%E9%9B%86%E4%B8%AD%E8%90%A5/" style="font-size: 14px; color: #999">有趣集中营</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/" style="font-size: 14px; color: #999">架构之路</a> <a href="/tags/%E7%9F%A5%E4%B9%8E%E9%97%AE%E9%A2%98/" style="font-size: 14px; color: #999">知乎问题</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E4%BA%BA%E7%94%9F/" style="font-size: 17.08px; color: #848484">编程人生</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 14px; color: #999">翻译</a> <a href="/tags/%E7%BF%BB%E8%AF%91%E6%96%87/" style="font-size: 14px; color: #999">翻译文</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 21.69px; color: #656565">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 19.38px; color: #747474">项目</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 14px; color: #999">领域驱动设计</a>
    </div>
  </section>


  

  


</aside>





	<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
	

	


    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xxx.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/volantis-x/"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=260045301"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
      
  

  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='option'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-text' onclick='document.execCommand("copy")'><i class='fa fa-copy fa-fw'></i>复制文本</a>
        <hr id='hr-text'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-href'><i class='fa fa-link fa-fw'></i>复制链接</a>
        <a class='vlts-menu opt fix-cursor-default' id='menu-open-href'><i class='fa fa-external-link-square-alt fa-fw'></i>在新标签页打开</a>
        <hr id='hr-href'>
        <a class='vlts-menu opt fix-cursor-default' id='menu-copy-src'><i class='fa fa-image fa-fw'></i>复制图片地址</a>
        <hr id='hr-src'>
      </li>
      <li class='navigation'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <hr>
      
        
      
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          
    <li>
      <a class='vlts-menu fix-cursor-default' 
        
        
        
          onclick="document.execCommand('print')"
        
        >
        <i class='fa fa-print fa-fw'></i> 打印页面
      </a>
    </li>
  
        
      
        
          <hr>
        
      
        
          <li class='music name'>
            <p class='nav music-title fix-cursor-default'></p>
          </li>
          <li class='music ctrl'>
            <a class='nav icon-only backward fix-cursor-default' onclick='aplayerBackward()'><i class='fa fa-step-backward fa-fw'></i></a>
            <a class='nav icon-only toggle fix-cursor-default' onclick='aplayerToggle()'><i class='fa fa-play fa-fw'></i></a>
            <a class='nav icon-only forward fix-cursor-default' onclick='aplayerForward()'><i class='fa fa-step-forward fa-fw'></i></a>
          </li>
          <li class='music volume'>
            <a class='nav volume'>
              <div class="aplayer-volume-bar-wrap">
                <div class="aplayer-volume-bar fix-cursor-pointer">
                  <div class="aplayer-volume"></div>
                  <i class='left fa fa-volume-off fa-fw'></i>
                  <i class='right fa fa-volume-up fa-fw'></i>
                </div>
              </div>
            </a>
          </li>
        
      
    </ul>
  </div>

  <script>
    window.document.oncontextmenu = function (event) {
      if (event.ctrlKey) return true;
      if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true;
      return popMenu(event);
    };
    document.addEventListener("click", function (event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      mymenu.style.display = "none";
    });
    function popMenu(event) {
      var mymenu = document.getElementById('rightmenu-wrapper');
      var menuContent = document.getElementById('rightmenu-content');
      var screenWidth = document.documentElement.clientWidth || document.body.clientWidth;
      var screenHeight = document.documentElement.clientHeight || document.body.clientHeight;
      mymenu.style.left = event.clientX + "px"; // 获取鼠标位置
      mymenu.style.top = event.clientY + "px";
      mymenu.style.display = 'block';
      if (event.clientX * 2 > screenWidth) {
        menuContent.classList.add('left');
      } else {
        menuContent.classList.remove('left');
      }
      if (event.clientY * 2 > screenHeight) {
        menuContent.classList.add('top');
      } else {
        menuContent.classList.remove('top');
      }

      let hrText = document.getElementById('hr-text');
      let hrSrc = document.getElementById('hr-src');
      let hrHref = document.getElementById('hr-href');

      // 选中图片
      let copySrc = document.getElementById('menu-copy-src');
      if (copySrc != undefined) {
        if (event.target.currentSrc) {
          copySrc.style.display = 'block';
          copySrc.addEventListener("click", function (e) {
            copyString(event.target.currentSrc);
          },{once: true});
          hrSrc.style.display = 'block';
        } else {
          copySrc.style.display = 'none';
          hrSrc.style.display = 'none';
        }
      }

      // 选中按钮
      // 判断是不是按钮
      let href = '';
      if (event.path) {
        for (i = 0; i < event.path.length; i++) {
          if (event.path[i].href != undefined && event.path[i].href.length > 0) {
            href = event.path[i].href;
          }
        }
      }

      let copyText = document.getElementById('menu-copy-text');
      copyText.style.display = 'none';
      hrText.style.display = 'none';
      if (href.length == 0) {
        // 选中文本
        if (window.getSelection().toString()) {
          copyText.style.display = 'block';
          hrText.style.display = 'block';
        }
      }

      // 在新标签页打开
      let openHref = document.getElementById('menu-open-href');
      if (openHref != undefined) {
        if (href.length > 0) {
          openHref.style.display = 'block';
          openHref.addEventListener("click", function (e) {
            window.open(href);
          },{once: true});
          hrHref.style.display = 'block';
        } else {
          openHref.style.display = 'none';
          hrHref.style.display = 'none';
        }
      }
      // 复制链接
      let copyHref = document.getElementById('menu-copy-href');
      if (copyHref != undefined) {
        if (href.length > 0) {
          copyHref.style.display = 'block';
          copyHref.addEventListener("click", function (e) {
            copyString(href);
          },{once: true});
        } else {
          copyHref.style.display = 'none';
        }
      }

      // 有音乐播放器
      if (true == true) {
        // 如果有aplayer，初始化一下
      	try {
      		checkAPlayer();
          updateTitle();
      	} catch (error) {
      		console.log(error);
      	}
      }

      return false; // 该行代码确保系统自带的右键菜单不会被调出
    }
    function hideMenu() {
      document.getElementById('rightmenu-wrapper').style.display = 'none';
    }
    function copyString(str) {
      const input = document.createElement('input');
      input.setAttribute('readonly', 'readonly');
      document.body.appendChild(input);
      input.setAttribute('value', str);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
    }
    document.execCommand('click');
  </script>


    
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  <script>
    let APlayerController = new Object();
    APlayerController.id = '3175833810';  // 设定全局音乐播放ID
    APlayerController.volume = '0.7';
  </script>
  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  
    
<script src="/js/aplayer.js"></script>

  




  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  function pjax_gitalk() {
    let pageUrl = $.trim($('#pjax-comment-path').text()) === "none" ? 
      decodeURI(window.location.pathname) : $.trim($('#pjax-comment-path').text());
    
    let ALLPATH = '';
    if(ALLPATH != '') pageUrl = ALLPATH;

    if (document.getElementById('gitalk-container') != null) {
      var gitalk = new Gitalk({
        clientID: "a9f57bed080703426741",
        clientSecret: "03fe7aec06a7794dedfcc123b6475f0231f6a0ce",
        repo: "wmyskxz.github.io",
        owner: "wmyskxz",
        admin: "wmyskxz",
        id: pageUrl,
        distractionFreeMode: false  // Facebook-like distraction free mode
      });
      gitalk.render('gitalk-container');
    }
  }

  $(function () {
    pjax_gitalk();
  });
</script>




<!-- darkmodejs -->


<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
    
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
  




    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      $('.s-top').unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('.cover') {
            $('.cover').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
        
        
          pjax_gitalk();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
